- en: Chapter 4. Creating Specialized Graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first three chapters looked at different ways to create many common types
    of charts with JavaScript. But if your data has unique properties or if you want
    to show it in an unusual way, a more specialized chart might be more appropriate
    than a typical bar, line, or scatter chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there are many JavaScript techniques and plug-ins to expand our
    visualization vocabulary beyond the standard charts. In this chapter, we’ll look
    at approaches for several specialized chart types, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to combine hierarchy and dimension with tree maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to highlight regions with heat maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to show links between elements with network graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reveal language patterns with word clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing Hierarchies with Tree Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data that we want to visualize can often be organized into a hierarchy, and
    in many cases that hierarchy is itself an important aspect of the visualization.
    This chapter considers several tools for visualizing hierarchical data, and we’ll
    begin the examples with one of the simplest approaches: tree maps. Tree maps represent
    numeric data with two-dimensional areas, and they indicate hierarchies by nesting
    subordinate areas within their parents.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several algorithms for constructing tree maps from hierarchical data;
    one of the most common is the squarified algorithm developed by Mark Bruls, Kees
    Huizing, and Jarke J. van Wijk (*[http://www.win.tue.nl/~vanwijk/stm.pdf](http://www.win.tue.nl/~vanwijk/stm.pdf)*).
    This algorithm is favored for many visualizations because it usually generates
    visually pleasing proportions for the tree map area. To create the graphics in
    our example, we can use Imran Ghory’s treemap-squared library (*[https://github.com/imranghory/treemap-squared](https://github.com/imranghory/treemap-squared)*).
    That library includes code for both calculating and drawing tree maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Required Libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The treemap-squared library itself depends on the Raphaël library (*[http://raphaeljs.com/](http://raphaeljs.com/)*)
    for low-level drawing functions. Our markup, therefore, must include both libraries.
    The Raphaël library is popular enough for public CDNs to support.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve set aside a `<div>` to hold our tree map. We’ve also included
    the JavaScript libraries as the last part of the `<body>` element, as that provides
    the best browser performance. In this example, we’re relying on CloudFlare’s CDN
    ➊. We’ll have to use our own resources, however, to host the treemap-squared library
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**See [Step 1: Include the Required JavaScript Libraries](ch02.html#step_1_include_the_required_javascript_l
    "Step 1: Include the Required JavaScript Libraries") for a more extensive discussion
    of CDNs and the tradeoffs involved in using them.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our example we’ll show the population of the United States divided by region
    and then, within each region, by state. The data is available from the US Census
    Bureau (*[http://www.census.gov/popest/data/state/totals/2012/index.html](http://www.census.gov/popest/data/state/totals/2012/index.html)*).
    We’ll follow its convention and divide the country into four regions. The resulting
    JavaScript array could look like the following snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ve retained both the 2010 and the 2012 data.
  prefs: []
  type: TYPE_NORMAL
- en: To structure the data for the treemap-squared library, we need to create separate
    data arrays for each region. At the same time, we can also create arrays to label
    the data values using the two-letter state abbreviations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code steps through the `census` array to build data and label arrays for
    the `"South"` region. The same approach works for the other three regions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Draw the Tree Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’re ready to use the library to construct our tree map. We need to assemble
    the individual data and label arrays and then call the library’s main function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters at ➊ are the width and height of the map.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting chart, shown in [Figure 4-1](ch04.html#tree_maps_show_the_relative_size_of_data
    "Figure 4-1. Tree maps show the relative size of data values using rectangular
    area."), provides a simple visualization of the US population. Among the four
    regions, it is clear where most of the population resides. The bottom-right quadrant
    (the South) has the largest share of the population. And within the regions, the
    relative size of each state’s population is also clear. Notice, for example, how
    California dominates the West.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree maps show the relative size of data values using rectangular area.](figs/web/04fig01.png.jpg)Figure 4-1. Tree
    maps show the relative size of data values using rectangular area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Vary the Shading to Show Additional Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tree map in [Figure 4-1](ch04.html#tree_maps_show_the_relative_size_of_data
    "Figure 4-1. Tree maps show the relative size of data values using rectangular
    area.") does a nice job of showing the US population distribution in 2012\. The
    population isn’t static, however, and we can enhance our visualization to indicate
    trends by taking advantage of the 2010 population data that’s still lurking in
    our data set. When we iterate through the `census` array to extract individual
    regions, we can also calculate a few additional values.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an expanded version of our earlier code fragment that includes these
    additional calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through those additional calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: We accumulate the total population for all states, both in 2010 and in 2012,
    at ➊ and ➋, respectively. These values let us calculate the average growth rate
    for the entire country.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each state, we can calculate its growth rate at ➌.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each region, we save both the minimum and maximum growth rates at ➍ and
    ➎.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same way that we created a master object for the data and the labels,
    we create another master object for the growth rates. Let’s also calculate the
    total growth rate for the country.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we need a function to calculate the color for a tree-map rectangle. We start
    by defining two color ranges, one for growth rates higher than the national average
    and another for lower growth rates. We can then pick an appropriate color for
    each state, based on that state’s growth rate. As an example, here’s one possible
    set of colors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next is the `pickColor()` function that uses these color ranges to select the
    right color for each box. The treemap-squared library will call it with two parameters—the
    coordinates of the rectangle it’s about to draw, and the index into the data set.
    We don’t need the coordinates in our example, but we will use the index to find
    the value to model. Once we find the state’s growth rate, we can subtract the
    national average. That calculation determines which color range to use. States
    that are growing faster than the national average get the positive color range;
    states growing slower than the average get the negative range.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the code calculates where on the appropriate color range to
    select the color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code uses a linear scale based on the extreme values from among all the
    states. So, for example, if a state’s growth rate is halfway between the overall
    average and the maximum growth rate, we’ll give it a color that’s halfway in the
    positive color range array.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we call `TreeMap.draw()`, we can add this function to its parameters,
    specifically by setting it as the value for the `box` key of the options object.
    The treemap-squared library will then defer to our function for selecting the
    colors of the regions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The resulting tree map of [Figure 4-2](ch04.html#tree_maps_can_use_color_as_well_as_area
    "Figure 4-2. Tree maps can use color as well as area to show data values.") still
    shows the relative populations for all of the states. Now, through the use of
    color shades, it also indicates the rate of population growth compared to the
    national average. The visualization clearly shows the migration from the Northeast
    and Midwest to the South and West.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree maps can use color as well as area to show data values.](figs/web/04fig02.png.jpg)Figure 4-2. Tree
    maps can use color as well as area to show data values.'
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting Regions with a Heat Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you work in the web industry, heat maps may already be a part of your job.
    Usability researchers often use heat maps to evaluate site designs, especially
    when they want to analyze which parts of a web page get the most attention from
    users. Heat maps work by overlaying values, represented as semitransparent colors,
    over a two-dimensional area. As the example in [Figure 4-3](ch04.html#heat_maps_traditionally_show_where_web_u
    "Figure 4-3. Heat maps traditionally show where web users focus their attention
    on a page.") shows, different colors represent different levels of attention.
    Users focus most on areas colored red, and less on yellow, green, and blue areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we’ll use a heat map to visualize an important aspect of
    a basketball game: from where on the court the teams are scoring most of their
    points. The software we’ll use is the heatmap.js library from Patrick Wied (*[http://www.patrick-wied.at/static/heatmapjs/](http://www.patrick-wied.at/static/heatmapjs/)*).
    If you need to create traditional website heat maps, that library includes built-in
    support for capturing mouse movements and mouse clicks on a web page. Although
    we won’t use those features for our example, the general approach is much the
    same.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heat maps traditionally show where web users focus their attention on a page.](figs/web/04fig03.png.jpg)Figure 4-3. Heat
    maps traditionally show where web users focus their attention on a page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Required JavaScript'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For modern browsers, the heatmap.js library has no additional requirements.
    The library includes optional additions for real-time heat maps and for geographic
    integration, but we won’t need these in our example. Older browsers (principally
    IE8 and older) can use heatmap.js with the *explorer canvas* library. Since we
    don’t need to burden all users with this library, we’ll use conditional comments
    to include it only when it’s needed. Following current best practices, we include
    all script files at the end of our `<body>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Define the Visualization Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our example, we’ll visualize the NCAA Men’s Basketball game on February
    13, 2013, between Duke University and the University of North Carolina. Our data
    set (*[http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE](http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE)*)
    contains details about every point scored in the game. To clean the data, we convert
    the time of each score to minutes from the game start, and we define the position
    of the scorer in x- and y-coordinates. We’ve defined these coordinates using several
    important conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show North Carolina’s points on the left side of the court and Duke’s
    points on the right side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom-left corner of the court corresponds to position (0,0), and the top-right
    corner corresponds to (10,10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid confusing free throws with field goals, we’ve given all free throws
    a position of (–1, –1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s the beginning of the data; the full data is available with the book’s
    source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Create the Background Image'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple diagram of a basketball court, like that in [Figure 4-4](ch04.html#background_image_sets_the_context_for_th
    "Figure 4-4. A background image sets the context for the visualization."), works
    fine for our visualization. The dimensions of our background image are 600×360
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![A background image sets the context for the visualization.](figs/web/04fig04.png.jpg)Figure 4-4. A
    background image sets the context for the visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Set Aside an HTML Element to Contain the Visualization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our web page, we need to define the element (generally a `<div>`) that will
    hold the heat map. When we create the element, we specify its dimensions, and
    we define the background. The following fragment does both of those using inline
    styles to keep the example concise. You might want to use a CSS style sheet in
    an actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’ve given the element a unique `id`. The heatmap.js library needs
    that `id` to place the map on the page. Most importantly, we also set the `position`
    property to `relative`. The heatmap.js library positions its graphics using absolute
    positioning, and we want to contain those graphics within the parent element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Format the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our next step, we must convert the game data into the proper format for
    the library. The heatmap.js library expects individual data points to contain
    three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate, measured in pixels from the left of the containing element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The y-coordinate, measured in pixels from the top of the containing element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magnitude of the data point (specified by the `count` property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library also requires the maximum magnitude for the entire map, and here
    things get a little tricky. With standard heat maps, the magnitudes of all the
    data points for any particular position sum together. In our case, that means
    that all the baskets scored from layups and slam dunks—which are effectively from
    the same position on the court—are added together by the heat-map algorithm. That
    one position, right underneath the basket, dominates the rest of the court. To
    counteract that effect, we specify a maximum value far less than what the heat
    map would expect. In our case, we’ll set the maximum value to `3`, which means
    that any location where at least three points were scored will be colored red,
    and we’ll easily be able to see all the baskets.
  prefs: []
  type: TYPE_NORMAL
- en: We can use JavaScript to transform the `game` array into the appropriate format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start by fetching the height and width of the containing element at ➊, ➋,
    and ➌. If those dimensions change, our code will still work fine. Then we initialize
    the `dataset` object ➍, with a `max` property ➎ and an empty `data` array ➏. Finally,
    we iterate through the game data and add relevant data points to this array. Notice
    that we’re filtering out free throws at ➐.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Draw the Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a containing element and a formatted data set, it’s a simple matter to
    draw the heat map. We create the heat-map object (the library uses the name `h337`
    in an attempt to be clever) by specifying the containing element, a radius for
    each point, and an opacity. Then we add the data set to this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The resulting visualization in [Figure 4-5](ch04.html#heat_map_shows_successful_shots_in_the_g
    "Figure 4-5. The heat map shows successful shots in the game.") shows where each
    team scored its points.
  prefs: []
  type: TYPE_NORMAL
- en: '![The heat map shows successful shots in the game.](figs/web/04fig05.png.jpg)Figure 4-5. The
    heat map shows successful shots in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: Adjust the Heat Map z-index'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heatmap.js library is especially aggressive in its manipulation of the `z-index`
    property. To ensure that the heat map appears above all other elements on the
    page, the library explicitly sets this property to a value of `10000000000`. If
    your web page has elements that you don’t want the heat map to obscure (such as
    fixed-position navigation menus), that value is probably too aggressive. You can
    fix it by modifying the source code directly. Or, as an alternative, you can simply
    reset the value after the library finishes drawing the map.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using jQuery, the following code will reduce the `z-index` to a more
    reasonable value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Showing Relationships with Network Graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visualizations don’t always focus on the actual data values; sometimes the most
    interesting aspects of a data set are the relationships among its members. The
    relationships between members of a social network, for example, might be the most
    important feature of that network. To visualize these types of relationships,
    we can use a *network graph.* Network graphs represent objects, generally known
    as *nodes*, as points or circles. Lines or arcs (technically called *edges*) connect
    these nodes to indicate relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing network graphs can be a bit tricky, as the underlying mathematics
    is not always trivial. Fortunately, the Sigma library (*[http://sigmajs.org/](http://sigmajs.org/)*)
    takes care of most of the complicated calculations. By using that library, we
    can create full-featured network graphs with just a little bit of JavaScript.
    For our example, we’ll consider one critic’s list of the top 25 jazz albums of
    all time (*[http://www.thejazzresource.com/top_25_jazz_albums.html](http://www.thejazzresource.com/top_25_jazz_albums.html)*).
    Several musicians performed on more than one of these albums, and a network graph
    lets us explore those connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Required Libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sigma library does not depend on any other JavaScript libraries, so we don’t
    need any other included scripts. It is not, however, available on common content
    distribution networks. Consequently, we’ll have to serve it from our own web host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve set aside a `<div>` to hold our graph at ➊. We’ve also
    included the JavaScript library as the last part of the `<body>` element at ➋,
    as that provides the best browser performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**In most of the examples in this book, I included steps you can take to make
    your visualizations compatible with older web browsers such as IE8\. In this case,
    however, those approaches degrade performance so severely that they are rarely
    workable. To view the network graph visualization, your users will need a modern
    browser.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our data on the top 25 jazz albums looks like the following snippet. I’m showing
    only the first couple of albums, but you can see the full list in the book’s source
    code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That’s not exactly the structure that Sigma requires. We could convert it to
    a Sigma JSON data structure in bulk, but there’s really no need. Instead, as we’ll
    see in the next step, we can simply pass data to the library one element at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Define the Graph’s Nodes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’re ready to use the library to construct our graph. We start by initializing
    the library and indicating where it should construct the graph. That parameter
    is the `id` of the `<div>` element set aside to hold the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we can continue by adding the nodes to the graph. In our case, each album
    is a node. As we add a node to the graph, we give it a unique identifier (which
    must be a string), a label, and a position. Figuring out an initial position can
    be a bit tricky for arbitrary data. In a few steps, we’ll look at an approach
    that makes the initial position less critical. For now, though, we’ll simply spread
    our albums in a circle using basic trigonometry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `radius` value is roughly half of the width of the container. We can
    also give each node a different size, but for our purposes it’s fine to set every
    album’s size to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after defining the graph, we tell the library to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With [Figure 4-6](ch04.html#sigma_draws_graph_nodes_as_small_circles "Figure 4-6. Sigma
    draws graph nodes as small circles."), we now have a nicely drawn circle of the
    top 25 jazz albums of all time. In this initial attempt, some of the labels may
    get in one another’s way, but we’ll address that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: If you try out this visualization in the browser, you’ll notice that the Sigma
    library automatically supports panning the graph, and users can move their mouse
    pointer over individual nodes to highlight the node labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sigma draws graph nodes as small circles.](figs/web/04fig06.png.jpg)Figure 4-6. Sigma
    draws graph nodes as small circles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Connect the Nodes with Edges'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the nodes drawn in a circle, it’s time to connect them with
    edges. In our case, an edge—or connection between two albums—represents a musician
    who performed on both of the albums. Here’s the code that finds those edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To find the edges, we iterate through the albums in four stages.
  prefs: []
  type: TYPE_NORMAL
- en: Loop through each album as a potential source of a connection at ➊.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the source album, loop through all musicians at ➋.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each musician, loop through all of the remaining albums as potential targets
    for a connection at ➌.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each target album, loop through all the musicians at ➍, looking for a match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the last step we’re using the .`some()` method of JavaScript arrays. That
    method takes a function as a parameter, and it returns `true` if that function
    itself returns `true` for any element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll want to insert this code before we refresh the graph. When we’ve done
    that, we’ll have a connected circle of albums, as shown in [Figure 4-7](ch04.html#sigma_can_then_connect_graph_nodes_using
    "Figure 4-7. Sigma can then connect graph nodes using lines to represent edges.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Sigma can then connect graph nodes using lines to represent edges.](figs/web/04fig07.png.jpg)Figure 4-7. Sigma
    can then connect graph nodes using lines to represent edges.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can pan and zoom in on the graph to focus on different parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Automate the Layout'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve manually placed the nodes in our graph in a circle. That’s not
    a terrible approach, but it can make it hard to discern some of the connections.
    It would be better if we could let the library calculate a more optimal layout
    than the simple circle. That’s exactly what we’ll do now.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematics behind this approach is known as *force-directed graphing*.
    In a nutshell, the algorithm proceeds by treating the graph’s nodes and edges
    as physical objects subject to real forces such as gravity and electromagnetism.
    It simulates the effect of those forces, pushing and prodding the nodes into new
    positions on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying algorithm may be complicated, but Sigma makes it easy to employ.
    First we have to add the optional `forceAtlas2` plug-in to the Sigma library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Mathieu Jacomy and Tommaso Venturini developed the specific force-direction
    algorithm employed by this plug-in; they document the algorithm, known as *ForceAtlas2*,
    in the 2011 paper “ForceAtlas2, A Graph Layout Algorithm for Handy Network Visualization”
    (*[http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf](http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf)).*
    Although we don’t have to understand the mathematical details of the algorithm,
    knowing how to use its parameters does come in handy. There are three parameters
    that are important for most visualizations that use the plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`gravity`****. This parameter determines how strongly the algorithm tries
    to keep isolated nodes from drifting off the edges of the screen. Without any
    gravity, the only force acting on isolated nodes will be one that repels them
    from other nodes; undeterred, that force will push the nodes off the screen entirely.
    Since our data includes several isolated nodes, we’ll want to set this value relatively
    high to keep those nodes on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`scalingRatio`****. This parameter determines how strongly nodes repel
    each other. A small value draws connected nodes closer together, while a large
    value forces all nodes farther apart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`slowDown`****. This parameter decreases the sensitivity of the nodes to
    the repulsive forces from their neighbors. Reducing the sensitivity (by increasing
    this value) can help reduce the instability that may result when nodes face competing
    forces from multiple neighbors. In our data there are many connections that will
    tend to draw the nodes together and compete with the force pulling them apart.
    To dampen the wild oscillations that might otherwise ensue, we’ll set this value
    relatively high as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to settle on values for these parameters is to experiment with
    the actual data. The values we’ve settled on for this data set are shown in the
    following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of simply refreshing the graph when we’re ready to display it,
    we start the force-directed algorithm, which periodically refreshes the display
    while it performs its simulation. We also need to stop the algorithm after it’s
    had a chance to run for a while. In our case, 10 seconds (`10000` milliseconds)
    is plenty of time.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, our albums start out in their original circle, but quickly migrate
    to a position that makes it much easier to identify the connections. Some of the
    top albums are tightly connected, indicating that they have many musicians in
    common. A few, however, remain isolated. Their musicians make the list only once.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-8](ch04.html#force_direction_positions_the_graph_node
    "Figure 4-8. Force direction positions the graph nodes automatically."), the labels
    for the nodes still get in the way of one another; we’ll fix that in the next
    step. What’s important here, however, is that it’s much easier to identify the
    albums with lots of connections. The nodes representing those albums have migrated
    to the center of the graph, and they have many links to other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Force direction positions the graph nodes automatically.](figs/web/04fig08.png.jpg)Figure 4-8. Force
    direction positions the graph nodes automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Add Interactivity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep the labels from interfering with one another, we can add some interactivity
    to the graph. By default, we’ll hide the labels entirely, giving users the chance
    to appreciate the structure of the graph without distractions. We’ll then allow
    them to click on individual nodes to reveal the album title and its connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To suppress the initial label display, we modify the initialization code at
    ➊ so that nodes have blank labels. We save a reference to the album title, though,
    at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need a function that responds to clicks on the node elements. The Sigma
    library supports exactly this sort of function with its interface. We simply bind
    to the `clickNode` event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Within that function, the `ev.data.node.id` property gives us the index of the
    node that the user clicked. The complete set of nodes is available from the array
    returned by `s.graph.nodes()`. Since we want to display the label for the clicked
    node (but not for any other), we can iterate through the entire array. At each
    iteration, we either set the `label` property to an empty string (to hide it)
    or to the `album` property (to show it).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that users have a way to show the title of an album, let’s give them a way
    to hide it. A small addition at ➊ is all it takes to let users toggle the album
    display with subsequent clicks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As long as we’re making the graph respond to clicks, we can also take the opportunity
    to highlight the clicked node’s connections. We do that by changing their color.
    Just as `s.graph.nodes()` returns an array of the graph nodes, `s.graph.edges()`
    returns an array of edges. Each edge object includes `target` and `source` properties
    that hold the index of the relevant node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here we scan through all the graph’s edges to see if they connect to the clicked
    node. If the edge does connect to the node, we change its color at ➋ to something
    other than the default. Otherwise, we change the color back to the default at
    ➌. You can see that we’re using the same approach to toggle the edge colors as
    we did to toggle the node labels on successive clicks at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve changed the graph properties, we have to tell Sigma to redraw
    it. That’s a simple matter of calling `s.refresh()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a fully interactive network graph in [Figure 4-9](ch04.html#interactive_graph_gives_users_the_chance
    "Figure 4-9. An interactive graph gives users the chance to highlight specific
    nodes.").
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Language Patterns with Word Clouds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data visualizations don’t always focus on numbers. Sometimes the data for a
    visualization centers on words instead, and a *word cloud* is often an effective
    way to present this kind of data. Word clouds can associate any quantity with
    a list of words; most often that quantity is a relative frequency. This type of
    word cloud, which we’ll create for our next example, reveals which words are common
    and which are rare.
  prefs: []
  type: TYPE_NORMAL
- en: '![An interactive graph gives users the chance to highlight specific nodes.](figs/web/04fig09.png.jpg)Figure 4-9. An
    interactive graph gives users the chance to highlight specific nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: To create this visualization, we’ll rely on the wordcloud2 library (*[http://timdream.org/wordcloud2.js](http://timdream.org/wordcloud2.js)*),
    a spin-off from author Tim Dream’s HTML5 Word Cloud project (*[http://timc.idv.tw/wordcloud/](http://timc.idv.tw/wordcloud/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**As is the case with a few of the more advanced libraries we’ve examined,
    wordcloud2 doesn’t function very well in older web browsers such as IE8 and earlier.
    Since wordcloud2 itself requires a modern browser, for this example we won’t worry
    about compatibility with older browsers. This will free us to use some other modern
    JavaScript features, too.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Required Libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wordcloud2 library does not depend on any other JavaScript libraries, so
    we don’t need any other included scripts. It is not, however, available on common
    content distribution networks, so we’ll have to serve it from our own web host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To keep our example focused on the visualization, we’ll use a word list that
    doesn’t need any special preparation. If you’re working with natural language
    as spoken or written, however, you might wish to process the text to identify
    alternate forms of the same word. For example, you might want to count *hold*,
    *holds*, and *held* as three instances of *hold* rather than three separate words.
    This type of processing obviously depends greatly on the particular language.
    If you’re working in English and Chinese, though, the same developer that created
    wordcloud2 has also released the WordFreq JavaScript library (*[http://timdream.org/wordfreq/](http://timdream.org/wordfreq/)*),
    which performs exactly this type of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we’ll look at the different tags users associate with their
    questions on the popular Stack Overflow (*[http://stackoverflow.com/](http://stackoverflow.com/)*).
    That site lets users pose programming questions that the community tries to answer.
    Tags provide a convenient way to categorize the questions so that users can browse
    other posts related to the same topic. By constructing a word cloud (perhaps better
    named a *tag cloud*), we can quickly show the relative popularity of different
    programming topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to develop this example into a real application, you could access
    the Stack Overflow data in real time using the site’s API. For our example, though,
    we’ll use a static snapshot. Here’s how it starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this data set, the list of tags is an array, and each tag within the list
    is also an array. These inner arrays have the word itself as the first item and
    a count for that word as the second item. You can see the complete list in the
    book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  prefs: []
  type: TYPE_NORMAL
- en: The format that wordcloud2 expects is quite similar to how our data is already
    laid out, except that in each word array, the second value needs to specify the
    drawing size for that word. For example, the array element `["javascript", 56]`
    would tell wordcloud2 to draw *javascript* with a height of 56 pixels. Our data,
    of course, isn’t set up with pixel sizes. The data value for *javascript* is `557407`,
    and a word 557,407 pixels high wouldn’t even fit on a billboard. As a result,
    we must convert counts to drawing sizes. The specific algorithm for this conversion
    will depend both on the size of the visualization and on the raw values. A simple
    approach that works in this case is to divide the count values by 10,000 and round
    to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 2](ch02.html "Chapter 2. Making Charts Interactive"), we saw how
    jQuery’s `.map()` function makes it easy to process all the elements in an array.
    It turns out that modern browsers have the same functionality built in, so here
    we use the native version of `.map()` even without jQuery. (This native version
    won’t work on older browsers like jQuery will, but we’re not worrying about that
    for this example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After this code executes, our `list` variable will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Add the Required Markup'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wordcloud2 library can build its graphics either using the HTML `<canvas>`
    interface or in pure HTML. As we’ve seen with many graphing libraries, `<canvas>`
    is a convenient interface for creating graphic elements. For word clouds, however,
    there aren’t many benefits to using `<canvas>`. Native HTML, on the other hand,
    lets us use all the standard HTML tools (such as CSS style sheets or JavaScript
    event handling). That’s the approach we’ll take in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When using native HTML, we do have to make sure that the containing element
    has a `position: relative` style, because wordcloud2 relies on that when placing
    the words in their proper location in the cloud. You can see that here we’ve set
    that style inline at ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Create a Simple Cloud'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With these preparations in place, creating a simple word cloud is about as easy
    as it can get. We call the wordcloud2 library and tell it the HTML element in
    which to draw the cloud, and the list of words for the cloud’s data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Even with nothing other than default values, wordcloud2 creates the attractive
    visualization shown in [Figure 4-10](ch04.html#word_cloud_can_show_a_list_of_words_with
    "Figure 4-10. A word cloud can show a list of words with their relative frequency.").
  prefs: []
  type: TYPE_NORMAL
- en: The wordcloud2 interface also provides many options for customizing the visualization.
    As expected, you can set colors and fonts, but you can also change the shape of
    the cloud (even providing a custom polar equation), rotation limits, internal
    grid sizing, and many other features.
  prefs: []
  type: TYPE_NORMAL
- en: '![A word cloud can show a list of words with their relative frequency.](figs/web/04fig10.png.jpg)Figure 4-10. A
    word cloud can show a list of words with their relative frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Add Interactivity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you ask wordcloud2 to use the `<canvas>` interface, it gives you a couple
    of callback hooks that your code can use to respond to user interactions. With
    native HTML, however, we aren’t limited to just the callbacks that wordcloud2
    provides. To demonstrate, we can add a simple interaction to respond to mouse
    clicks on words in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: First we’ll let users know that interactions are supported by changing the cursor
    to a pointer when they hover the mouse over a cloud word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next let’s add an extra element to the markup where we can display information
    about any clicked word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve added the `<div>` with the `id details` at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define a function that can be called when the user clicks within the
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because our function will be called for any clicks on the cloud (including clicks
    on empty space), it first checks to see if the target of the click was really
    a word. Words are contained in `<span>` elements, so we can verify that by looking
    at the `nodeName` property of the click target. As you can see at ➊, JavaScript
    node names are always uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: If the user did click on a word, we can find out which word by looking at the
    `textContent` property of the event target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After ➊, the variable `tag` will hold the word on which the user clicked. So,
    for example, if a user clicks on the word *javascript*, then the tag variable
    will have the value `"javascript"`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’d like to show users the total count when they click on a word, we’re
    going to need to find the word in our original data set. We have the word’s value,
    so that’s simply a matter of searching through the data set to find a match. If
    we were using jQuery, the `.grep()` function would do just that. In this example,
    we’re sticking with native JavaScript, so we can look for an equivalent method
    in pure JavaScript. Unfortunately, although there is such a native method defined—`.find()`—very
    few browsers, even modern ones, currently support it. We could resort to a standard
    `for` or `forEach` loop, but there is an alternative that many consider an improvement
    over that approach. It relies on the `.some()` method, an array method that modern
    browsers support. The `.some()` method passes every element of an array to an
    arbitrary function and stops when that function returns `true`. Here’s how we
    can use it to find the clicked tag in our `tags` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The function that’s the argument to `.some()` is defined beginning at ➊ and
    ending at ➍. It is called with the parameter `el`, short for an *element* in the
    `tags` array. The conditional statement at ➋ checks to see if that element’s word
    matches the clicked node’s text content. If so, the function sets the `clickedTag`
    variable and returns `true` to terminate the `.some()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: If the clicked word doesn’t match the element we’re checking in the `tags` array,
    then the function supplied to .`some()` returns `false` at ➌. When .`some()` sees
    a `false` return value, it continues iterating through the array.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the return value of the `.some()` method to make sure the clicked
    element was found in the array. When that’s the case, `.some()` itself returns
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ and ➋ we update the `details` variable with extra information. At ➌ we
    update the web page with those details.
  prefs: []
  type: TYPE_NORMAL
- en: And finally we tell the browser to call our handler when a user clicks on anything
    in the cloud container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With these few lines of code, our word cloud is now interactive, as shown in
    [Figure 4-11](ch04.html#because_our_word_cloud_consists_of_stand "Figure 4-11. Because
    our word cloud consists of standard HTML elements, we can make it interactive
    with simple JavaScript event handlers.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Because our word cloud consists of standard HTML elements, we can make it
    interactive with simple JavaScript event handlers.](figs/web/04fig11.png.jpg)Figure 4-11. Because
    our word cloud consists of standard HTML elements, we can make it interactive
    with simple JavaScript event handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at several different special-purpose visualizations
    and some JavaScript libraries that can help us create them. Tree maps are handy
    for showing both hierarchy and dimension in a single visualization. Heat maps
    can highlight varying intensities throughout a region. Network graphs reveal the
    connections between objects. And word clouds show relative relationships between
    language properties in an attractive and concise visualization.
  prefs: []
  type: TYPE_NORMAL
