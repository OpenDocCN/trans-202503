<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_703" aria-label="703"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">12</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">BIT MANIPULATION</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Manipulating bits in memory is perhaps the feature for which assembly language is most famous. Even the C programming language, known for bit manipulation, doesn’t provide as complete a set of bit-manipulation operations.</p>&#13;
<p class="TX">This chapter discusses how to manipulate strings of bits in memory and registers by using ARM assembly language. It begins with a review of the bit-manipulation instructions covered thus far, introduces a few new instructions, then reviews information on packing and unpacking bit strings in memory, which is the basis for many bit-manipulation operations. Finally, this chapter discusses several bit-centric algorithms and their implementation in assembly language.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-130"/><span class="SANS_Futura_Std_Bold_B_11">12.1 What Is Bit Data, Anyway?</span></h3>&#13;
<p class="TNI1"><i>Bit manipulation</i> refers to working with <i>bit data</i>, data types consisting of strings of bits that are noncontiguous or are not multiples of 8 bits long. Generally, these bit objects will not represent numeric integers, although I will not place this restriction on bit strings.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_704" aria-label="704"/>A <i>bit string</i> is a contiguous sequence of 1 or more bits. It does not have to start or end at any special point. For example, a bit string could start in bit 7 of one byte in memory and continue through to bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30 of W0, consume the upper 2 bits of W0, and then continue from bit 0 through bit 17 of W1. In memory, the bits must be physically contiguous (that is, bit numbers always increase except when crossing a byte boundary, and at byte boundaries the memory address increases by 1 byte). In registers, if a bit string crosses a register boundary, the application defines the continuation register, but the bit string always continues in bit 0 of that second register.</p>&#13;
<p class="TX">A <i>bit run</i> is a sequence of bits with all the same value. A <i>run of 0s</i> is a bit string that contains all 0s, and a <i>run of 1s</i> is a bit string containing all 1s. The <i>first set bit</i> in a bit string is the bit position of the first bit containing a 1 in a bit string—that is, the first 1 bit following a possible run of 0s. A similar definition exists for the <i>first clear bit</i>. The <i>last set bit</i> is the last bit position in a bit string that contains 1s; the remainder of the string forms an uninterrupted run of 0s. A similar definition exists for the <i>last clear bit</i>.</p>&#13;
<p class="TX">A <i>bit set</i> is a collection of bits, not necessarily contiguous, within a larger data structure. For example, bits 0 to 3, 7, 12, 24, and 31 in a double word form a set of bits. Typically, we will deal with bit sets that are part of a <i>container object</i> (the data structure that encapsulates the bit set) that is no more than about 32 or 64 bits in size, though this limit is completely artificial. Bit strings are special cases of bit sets.</p>&#13;
<p class="TX">A <i>bit offset</i> is the number of bits from a boundary position (usually a byte boundary) to the specified bit. As noted in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, these bits are numbered starting from 0 at the boundary location.</p>&#13;
<p class="TX">A <i>mask</i> is a sequence of bits used to manipulate certain bits in another value. For example, the bit string 0b0000_1111_0000, when used with the <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction, masks away (clears) all bits except bits 4 through 7. Likewise, if you use the same value with the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction, it can set bits 4 through 7 in the destination operand. The term <i>mask</i> derives from the use of these bit strings with the <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction, where the 1 and 0 bits behave like masking tape when you’re painting something: they pass through certain bits unchanged while masking out (clearing) the other bits.</p>&#13;
<p class="TX">Armed with these definitions, you’re ready to start manipulating some bits!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-131"/><span class="SANS_Futura_Std_Bold_B_11">12.2 Instructions That Manipulate Bits</span></h3>&#13;
<p class="TNI1">Let’s begin by reviewing the instructions this book has covered so far that manipulate bits, along with introducing a few additional bit-manipulation instructions.</p>&#13;
<p class="TX">Bit manipulation generally consists of six activities: setting bits, clearing bits, inverting bits, testing and comparing bits, extracting bits from a bit string, and inserting bits into a bit string. The most basic bit-manipulation instructions are the <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ands bic</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orn</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">not</span>), <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span>, and shift and rotate instructions. This section discusses these instructions, concentrating on how to use them to manipulate bits in memory or registers.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_705" aria-label="705"/>&#13;
<h4 class="H2" id="sec3"><span id="h2-216"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.1 Isolating, Clearing, and Testing Bits</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction provides the ability to clear bits in a bit sequence. This instruction is especially useful for isolating a bit string or a bit set that is merged with other, unrelated data (or, at least, data that is not part of the bit string or bit set). For example, if a bit string consumes bit positions 12 through 24 of the W0 register, you can isolate this bit string by using the following instruction to set all other bits in W0 to 0:</p>&#13;
<pre id="pre-910"><code>and w0, w0, 0b1111111111111000000000000</code></pre>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-1">Figure 12-1</a> shows the result of this instruction.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-1" src="../images/Figure12-1.jpg" alt="" width="1680" height="311"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-1: Isolating a bit string by using the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">instruction</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once you’ve cleared the unneeded bits in a set of bits, you can often operate on the bit set in place. For example, to see whether the string of bits in positions 12 through 24 of W0 contains 0x2F3, you could use the following code:</p>&#13;
<pre id="pre-911"><code>mov w1, #0x2f3&#13;
lsl w1, w1,   #12 // Make it 0x2f3000.&#13;
and w0, w0,   #0b1111111111111000000000000&#13;
cmp w0, w1  // 0b0001011110011000000000000</code></pre>&#13;
<p class="TX">You cannot use the immediate constant 0x2F3000 with the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction, so this code first loads that constant into W1 and compares W0 against W1. You also can’t use <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> to load 0x2F3 preshifted to the left 12 bits because <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> allows only shifts of 0, 16, 32, or 48 bits; likewise, 0x2F3 is not a logical immediate pattern, so you can’t use a <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction with 0x2F3000.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The instruction</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mov w1, #</span><span class="SANS_TheSansMonoCd_W5Regular_11">logical_pattern</span> <i>is equivalent to</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">orr w1, wzr, #</span><span class="SANS_TheSansMonoCd_W5Regular_11">logical_pattern</span><i>.</i></p>&#13;
<p class="TX">To make the constants you use in conjunction with this value easier to deal with, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instruction to align the bit string with bit 0 after you’ve masked it, like this:</p>&#13;
<pre id="pre-912"><code>and w0, w0, #0b1111111111111000000000000&#13;
lsr w0, w0, #12&#13;
cmp w0, #0x2F3</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_706" aria-label="706"/>The plain <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction does not affect any condition code flags. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> variant if you would like to update the N and Z flags based on the result of the <span class="SANS_TheSansMonoCd_W5Regular_11">AND</span> operation, remembering that this instruction always clears the carry and overflow flags.</p>&#13;
<p class="TX">If you want to capture the result of the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> operation in the N and Z flags but don’t want to keep the logical result, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction. This is equivalent to (and an alias of) <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> supplying WZR or XZR as the destination register (which throws away the result).</p>&#13;
<p class="TX">Don’t forget that you can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction with the vector registers (both vector and scalar operations); just keep in mind that the vector <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction doesn’t affect the flags (there is no <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> variant).</p>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> is an alias of <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span>, and there is no vector <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction, the Neon instruction set provides this <span class="SANS_TheSansMonoCd_W5Regular_11">cmtst</span> instruction</p>&#13;
<pre id="pre-913"><code>cmtst V<var>d.t</var>, V<var>d.t</var>, V<var>d.t</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> is 8B, 16B, 4H, 8H, 2S, 4S, or 2D (8B, 4H, and 2S types operate on the LO 64 bits of V<i>n</i>, while the others operate on all 128 bits).</p>&#13;
<p class="TX">This instruction logically ANDs each lane in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d.t</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d.t</span>. If the result is not 0, <span class="SANS_TheSansMonoCd_W5Regular_11">cmtst</span> sets the destination lane to all 1s; if the result is 0, it sets the destination lane to all 0s. You can use the result as a bitmask for further vector (bit) operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-217"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.2 Setting and Inserting Bits</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction is especially useful for inserting a bit set into another bit string (in general-purpose or vector registers), using the following steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Clear all the bits surrounding your bit set in the source operand.</p>&#13;
<p class="ListNumber">  2.  Clear all the bits in the destination operand where you wish to insert the bit set.</p>&#13;
<p class="ListNumber">  3.  OR the bit set and destination operand together.</p>&#13;
</div>&#13;
<p class="TX">For example, suppose you have a value in bits 0 to 11 of W0 that you wish to insert into bits 12 to 23 of W1 without affecting any of the other bits in W1. You would begin by stripping out bits 12 and higher from W0, then strip out bits 12 to 23 in W1. Next, you would shift the bits in W0 so the bit string occupied bits 12 to 23 of W0. Finally, you’d OR the value in W0 into W1, as shown in the following code:</p>&#13;
<pre id="pre-914"><code>and     w0, w0, #0xFFF   // Strip all but bits 0 to 11 from W0.&#13;
bic     w1, w1, 0xFFF000 // Clear bits 12 to 23 in W1.&#13;
lsl     w0, w0, 12       // Move bits 0 through 11 to 12 through 23 in W0.&#13;
orr     w1, w1, w0       // Merge the bits into W1.</code></pre>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-2">Figure 12-2</a> shows the result of these four instructions.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_707" aria-label="707"/>&#13;
<figure class="IMG"><img class="img1" id="fig12-2" src="../images/Figure12-2.jpg" alt="" width="1485" height="2106"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-2: Inserting bits 0 to 11 of W0 into bits 12 to 23 of W1</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Step 1 in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> clears the <span class="SANS_TheSansMonoCd_W5Regular_11">U</span> bits in W0. After clearing the <span class="SANS_TheSansMonoCd_W5Regular_11">U</span> bits, step 2 masks out the destination bit field (<span class="SANS_TheSansMonoCd_W5Regular_11">Y</span>). Step 3 shifts the <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> bits (bits 0 to 11 in W0) 12 positions to the left to align them with the destination bit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_708" aria-label="708"/>field. Step 4 ORs the value in W0 with the value in W1, leaving the final result in W1.</p>&#13;
<p class="TX">In <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>, the desired bits (<span class="SANS_TheSansMonoCd_W5Regular_11">AAAAAAAAAAAA</span>) form a bit string. However, this algorithm still works fine even if you’re manipulating a noncontiguous set of bits—you just have to create a bitmask with 1s in the appropriate places.</p>&#13;
<p class="TX">When working with bitmasks, it is incredibly poor programming style to use literal numeric constants, as in the past few examples. I’ve used “magic numbers” thus far because the examples have been simple and using literal constants is clearer in this context. However, you should always create symbolic constants in Gas. Combining these with constant expressions allows you to produce code that is much easier to read and maintain. The previous example code is more properly written as the following:</p>&#13;
<pre id="pre-915"><code>StartPosn = 12;&#13;
BitMask   = 0xFFF &lt;&lt; StartPosn  // Mask occupies bits 12 to 23.&#13;
   .&#13;
   .&#13;
   .&#13;
  lsl w0, w0, #StartPosn  // Move into position.&#13;
  and w0, w0, #BitMask    // Strip all but bits 12 to 23.&#13;
  and w1, w1, #~BitMask   // Clear bits 12 to 23 in W1.&#13;
  orr w1, w1, w0          // Merge the bits into W1.</code></pre>&#13;
<p class="TX">The use of the compile time NOT operator (<span class="SANS_TheSansMonoCd_W5Regular_11">~</span>) for the bitmask inversion saves having to create another constant in the program that must be changed anytime you modify the <span class="SANS_TheSansMonoCd_W5Regular_11">BitMask</span> constant. Maintaining two separate symbols whose values are dependent on each other is not good practice.</p>&#13;
<p class="TX">Of course, in addition to merging one bit set with another, the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction is also useful for forcing bits to 1 in a bit string. By setting various bits in a source operand to 1, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction to force the corresponding bits in the destination operand to 1.</p>&#13;
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">orn</span> (OR NOT) instruction to insert a 1 bit in a destination everywhere there is a 0 bit in the source. Other than that, the instruction behaves identically to <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>.</p>&#13;
<p class="TX">If the <span class="SANS_TheSansMonoCd_W5Regular_11">and w1, w1, #~BitMask</span> cannot be assembled because Gas will not accept the immediate constant, use <span class="SANS_TheSansMonoCd_W5Regular_11">bic w1, w1, #BitMask</span> instead, as described in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-218"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.3 Clearing Bits</span></h4>&#13;
<p class="TNI1">Whereas the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction is useful for setting bits in a register, the <span class="SANS_TheSansMonoCd_W5Regular_11">bic</span> instruction clears them</p>&#13;
<pre id="pre-916"><code>bic  <var>Rd</var>, <var>Rl</var>, <var>Rr</var>  // <var>Rd</var> = <var>Rl</var> &amp;&amp; ~<var>Rr</var>&#13;
bics <var>Rd</var>, <var>Rl</var>, <var>Rr</var>  // Also affects condition codes</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rl</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rr</span> are all W<i>n</i> or X<i>n</i>. The <span class="SANS_TheSansMonoCd_W5Regular_11">bics</span> instruction sets the N and Z condition codes based on the value left in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>. Everywhere a 1 bit appears <span role="doc-pagebreak" epub:type="pagebreak" id="pg_709" aria-label="709"/>in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rr</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">bic</span> instruction will clear the corresponding bit in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rl</span> (storing the result into <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>).</p>&#13;
<p class="TX">The vector version of this instruction allows you to clear arbitrary bits in a 64- or 128-bit vector register</p>&#13;
<pre id="pre-917"><code>bic Vd.<var>t</var>, Vl.<var>t</var>, Vr.<var>t</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 8B for 64 bits and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 16B for 128 bits. This instruction also has an immediate version</p>&#13;
<pre id="pre-918"><code>bic Vd.<var>t</var>, #imm<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">8</span>&#13;
bic Vd.<var>t</var>, #imm<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">8</span>, lsl #<var>shift</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 4H for 64 bits and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 8H for 128 bits, or <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 2S for 64 bits and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> = 4S for 128 bits. The optional shift value can be <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">8</span> for half-word lanes, or <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">8</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">16</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">24</span> for word lanes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-219"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.4 Inverting Bits</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction allows you to invert selected bits in a bit set (in general-purpose or vector registers). If you want to invert all the bits in a destination operand, the <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> (not) instruction is more appropriate; however, to invert selected bits while not affecting others, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> is the way to go.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction lets you manipulate known data in just about any way imaginable. For example, if you know that a field contains 0b1010, you can force that field to 0 by XORing it with 0b1010. Similarly, you can force it to 0b1111 by XORing it with 0b0101.</p>&#13;
<p class="TX">Although this might seem like a waste because you can easily force this 4-bit string to 0 or all 1s by using <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction has two advantages. First, you are not limited to forcing the field to all 0s or all 1s; you can set these bits to any of the 16 valid combinations via <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>. Second, if you need to manipulate other bits in the destination operand at the same time, <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> may not be able to do the job.</p>&#13;
<p class="TX">For example, suppose one field contains 0b1010, which you want to force to 0, while another field in the same operand contains 0b1000, and you wish to increment that field by 1 (that is, set it to 0b1001). You cannot accomplish both operations with a single <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction, but you can do so with a single <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction: just XOR the first field with 0b1010 and the second field with 0b0001. However, note that this trick works only if you know the current value of a bit set within the destination operand.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">eon</span> (exclusive–OR NOT) works just like <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, except that it inverts bits in the destination wherever a 0 bit appears in the right source operand.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-220"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.5 Shift and Rotate</span></h4>&#13;
<p class="TNI1">The shift and rotate instructions are another group you can use to manipulate and test bits. The standard and Neon instruction sets provide a wide <span role="doc-pagebreak" epub:type="pagebreak" id="pg_710" aria-label="710"/>range of shift and rotate instructions that allow you to rearrange bit data as needed:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">asr</span>    Integer arithmetic shift right</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">lsl</span>    Integer logical shift left</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">lsr</span>    Integer logical shift right</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">ror</span>    Integer rotate right</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">shl</span>    Vector or scalar shift left or right</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">ushl</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">sshl</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">ushr</span><b>, and</b> <span class="SANS_TheSansMonoCd_W7Bold_11">sshr</span>    Vector or scalar shift right</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">sli</span>    Vector or scalar shift left and insert</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">sri</span>    Vector or scalar shift right and insert</p>&#13;
</div>&#13;
<p class="TX">In addition to these generic shifts and rotates, specialized variants saturate, round, narrow, and extend. Generally, those specialized instructions aren’t as useful for bit manipulation.</p>&#13;
<p class="TX">The integer shift and rotate instructions (those that operate on general-purpose registers) are quite useful for moving bits into their final position when constructing bit strings from multiple sources. As you saw in section 2.12, <span class="Xref">“Bit Fields and Packed Data,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_85">page 85</a></span>, you can use the shift and rotate instructions (along with the logical instructions) to pack and unpack data.</p>&#13;
<p class="TX">However, the biggest problem with the shift and rotate instructions is that they don’t provide an option to set the condition codes. For example, on many other CPUs (including the 32-bit ARM instruction set), the last bit shifted out of a register during a shift or rotate instruction winds up in the carry flag. The instructions typically set the Z and N flags, based on the final result. This is convenient for many operations, particularly those that use a loop to process each bit in the register; you could, for example, shift the bits out of a register by using a shift-right instruction, capture the output bit in the carry (using <span class="SANS_TheSansMonoCd_W5Regular_11">bcc</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span> to test the bit), and also be able to test the zero flag to see whether any more (set) bits are left in the register. This is not possible (with a single <span class="SANS_TheSansMonoCd_W5Regular_11">shift</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">rotate</span> instruction) on the ARM.</p>&#13;
<p class="TX">This rule has one exception. Although the shifts do not affect the carry flag, the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction does. Using an instruction such as</p>&#13;
<pre id="pre-919"><code>adds w0, w0, w0</code></pre>&#13;
<p class="Continued1">is equivalent to a shift left (by 1 bit) on W0, setting all the condition code flags (including capturing the bit shifted out of bit 31 in the carry flag). The <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instruction behaves like a “rotate through carry by 1 bit” instruction (see section 8.1.11.1, “<span class="Xref">Shift Left,</span>” on <span class="Xref"><a href="chapter8.xhtml#pg_467">page 467</a></span>). Because <span class="Xref"><a href="chapter2.xhtml">Chapters 2</a></span> and <span class="Xref"><a href="chapter8.xhtml">8</a></span> covered the use of the shift instructions to insert and extract bit data (packed fields), this chapter doesn’t consider that further.</p>&#13;
<p class="TX">The vector shift instructions warrant further discussion because they include interesting variants (<span class="SANS_TheSansMonoCd_W5Regular_11">sli</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sri</span>) and don’t provide rotate instructions. Simulating a vector rotate left takes three instructions:</p>&#13;
<pre id="pre-920"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_711" aria-label="711"/>// Simulate rol v1.4s, v1.4s, #4:&#13;
&#13;
        ushr    v2.4s, v1.4s, #28      // HO 4 bits to 0:3&#13;
        shl     v1.4s, v1.4s, #4       // Bits 0:27 to 4:31&#13;
        orr     v1.16b, v1.16b, v2.16b // Merge in LO bits.</code></pre>&#13;
<p class="TX">The biggest problem with this code is that it takes an extra register to hold a temporary result.</p>&#13;
<p class="TX">Here are the instructions to implement a vector rotate right:</p>&#13;
<pre id="pre-921"><code>// Simulate ror v1.4s, v1.4s, #4:&#13;
&#13;
        shl    v2.4s, v1.4s, #28      // Bits 0:3 to 28:31&#13;
        ushr   v1.4s, v1.4s, #4       // Bits 4:31 to 0:27&#13;
        orr    v1.16b, v1.16b, v2.16b // Merge bits.</code></pre>&#13;
<p class="TX">See section 11.6.4, <span class="Xref">“Shift and Insert,”</span> on <span class="Xref"><a href="chapter11.xhtml#pg_652">page 652</a></span> for more information about the <span class="SANS_TheSansMonoCd_W5Regular_11">sli</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sri</span> instructions.</p>&#13;
<p class="TX">Because the vector shift instructions operate only on lanes, you cannot directly shift all 128 bits of a vector register with a single instruction. With five instructions, however, you can pull it off:</p>&#13;
<pre id="pre-922"><code>// Simulate shl for 128 bits:&#13;
&#13;
        ushr    v2.2d, v1.2d, #60      // Save bits 60:63.&#13;
        mov     v2.b[8], v2.b[0]       // Move into HO dword.&#13;
        mov     v2.b[0],  wzr          // No mask at original&#13;
        Shl     v1.4s, v1.4s, #4       // Shift bits left.&#13;
        orr     v1.16b, v1.16b, v2.16b // Merge bits 60:63.</code></pre>&#13;
<p class="TX">I’ll leave it up to you to do the shift-right operation, which is just a straightforward modification of the <span class="SANS_TheSansMonoCd_W5Regular_11">shl</span> code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-221"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.6 Conditional Instructions</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">csinc</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">csinv</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">cinv</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">csetm</span> instructions are also useful for manipulating bits. In particular, <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">csetm</span> can help you initialize a register with 0, 1, or all 1 bits based on the condition codes. All these instructions are useful for dealing with operations that have set the condition codes (see section 12.3, <span class="Xref">“Flag Modification by Arithmetic and Logical Instructions,”</span> on <span class="Xref"><a href="chapter12.xhtml#pg_715">page 715</a></span>). These conditional instructions have no vector equivalents.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-222"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.7 Counting Bits</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">cls</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instructions allow you to count leading 1 and 0 bits (<i>leading</i> means from the HO bit position down to the LO bit position). The <span class="SANS_TheSansMonoCd_W5Regular_11">cnt</span> instruction (population count) counts all the set bits in the byte lanes in a (vector) register. The syntax for these instructions is</p>&#13;
<pre id="pre-923"><code>cls <var>Rd</var>, <var>Rs</var>&#13;
clz <var>Rd</var>, <var>Rs</var>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_712" aria-label="712"/>cls V<var>d.t1</var>, V<var>s.t1</var>&#13;
clz V<var>d.t1</var>, V<var>s.t1</var>&#13;
cnt V<var>d.t2</var>, V<var>s.t2</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are W<i>n</i> or X<i>n;</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t1</span> is 8B, 16B, 4H, 8H, 2S, or 4S; and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t2</span> is 8B or 16B. For the vector instructions, if the operand is 8B, 4H, or 2S, the instruction operates only on the LO 64 bits of the vector register.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cls</span> instruction (general-purpose register form) counts the number of leading sign bits in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> and stores this count into <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>. This instruction counts the number of bits (below the HO bit) that match the HO bit. Note that the sign (HO) bit is not included in the count.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instruction works the same way but counts the number of leading 0 bits including the sign bit. To count the actual number of leading 1 bits (including the HO sign bit), invert the source register value and use the <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instruction to count 0 bits.</p>&#13;
<p class="TX">The vector versions of the <span class="SANS_TheSansMonoCd_W5Regular_11">cls</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instructions count the number of leading 1s or 0s in each lane of the source register, in the same manner as the scalar versions, and stores this count into the corresponding lane of the destination register.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cnt</span> instruction counts the number of set bits in each byte (lane) of the source register and stores the bit count into the corresponding lane of the destination register. To find the total population (bit) count for the vector register (64 or 128 bits), use the <span class="SANS_TheSansMonoCd_W5Regular_11">addv</span> instruction to sum up all the bytes within the destination register. To compute the population count for hwords, words, or dwords, use an <span class="SANS_TheSansMonoCd_W5Regular_11">addp</span> instruction to add the pairs of bytes (to produce hword counts). You can use a second <span class="SANS_TheSansMonoCd_W5Regular_11">addp</span> instruction (again, on pairs of bytes, producing an array of byte results) to count the pairs of hwords, producing word counts, and so on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-223"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.8 Bit Reversal</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">rbit</span> instruction reverses the bits in its source operand and stores the reversed result into the destination operand. The syntax is as follows:</p>&#13;
<pre id="pre-924"><code>rbit W<var>d</var>, W<var>s</var>&#13;
rbit X<var>d</var>, X<var>s</var>&#13;
rbit V<var>d.t</var>, V<var>s.t </var>//<var> t </var>= 8B or 16B</code></pre>&#13;
<p class="TX">With 32-bit register operands, this instruction swaps the bits in positions 0 and 31, 1 and 30, 2 and 29, ..., and 15 and 16. With 64-bit operands, <span class="SANS_TheSansMonoCd_W5Regular_11">rbit</span> swaps the bits in positions 0 and 63, 1 and 62, 2 and 61, ..., and 31 and 32. With vector operands, it reverses the bits in each byte lane of the source vector register, storing the results into the corresponding byte lane in the destination vector register.</p>&#13;
<p class="TX">The vector variant of this instruction reverses only the bits in byte lanes. To reverse the bits in a 16-, 32-, or 64-bit object, also execute an 8-bit lane <span class="SANS_TheSansMonoCd_W5Regular_11">rev16</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">rev32,</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">rev64</span> instruction (before or) after the <span class="SANS_TheSansMonoCd_W5Regular_11">rbit</span>. For example, the following two instructions reverse all the bits in a 64-bit vector register:</p>&#13;
<pre id="pre-925"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_713" aria-label="713"/>rbit  v1.16b, v1.16b  // Do a 2D bit reversal; first bits,&#13;
rev64 v1.16b, v1.16b  // then bytes.</code></pre>&#13;
<p class="TX">You would use similar code (with <span class="SANS_TheSansMonoCd_W5Regular_11">rev32</span>) to reverse the bits in two double-words in a vector register.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-224"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.9 Bit Insertion and Selection</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">bif</span> (bit insert if false), <span class="SANS_TheSansMonoCd_W5Regular_11">bit</span> (bit insert if true), and <span class="SANS_TheSansMonoCd_W5Regular_11">bsl</span> (bit select) instructions allow you to manipulate individual bits in a vector register. These instructions have the following syntax:</p>&#13;
<pre id="pre-926"><code>bif V<var>d.t</var>, V<var>s.t</var>, V<var>m.t</var>    // <var>t</var> = 8B (64 bits) or 16B (128 bits)&#13;
bit V<var>d.t</var>, V<var>s.t</var>, V<var>m.t</var>    // V<var>d</var> = dest, V<var>s</var> = source, V<var>m</var> = mask&#13;
bsl V<var>d.t</var>, V<var>s1.t</var>, V<var>s0.t</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bif</span> instruction first considers the mask register; everywhere a 0 bit appears in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span>, the instruction copies the corresponding bit in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s</span> (source) to the same bit position in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> (destination). Everywhere a 1 appears in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">bif</span> instruction leaves the corresponding bit in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> unchanged.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bit</span> instruction does the same thing as <span class="SANS_TheSansMonoCd_W5Regular_11">bif</span>, except it copies bits on the opposite condition (where there is a 1 in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span>).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bsl</span> instruction uses the (original) bits in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> to select the corresponding bit in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s1</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s0</span>. Everywhere a 1 appears in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bsl</span> will copy the corresponding bit from <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>; everywhere a 0 appears in <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bsl</span> will copy the corresponding bit from <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">V</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-225"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.10 Bit Extraction with ubfx</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ubfx</span> instruction allows you to extract any number of bits from a position in a source register, moving those bits to bit 0 in the destination register. The syntax is</p>&#13;
<pre id="pre-927"><code>ubfx<var> Rd</var>,<var> Rs</var>, #<var>lsb</var>, #<var>len</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are both either W<i>n</i> or X<i>n</i>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span> is the starting bit position for the extraction, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> is the size of the bit string to extract. The sum of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> must not exceed the register size.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ubfx</span> instruction extracts <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> bits from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span>, starting at bit position <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span>. It stores this bit string into <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> (at bit 0) and zeros out the HO bits of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>. For example</p>&#13;
<pre id="pre-928"><code>ubfx x0, x1, #8, #16</code></pre>&#13;
<p class="Continued1">copies bits 8 through 23 from X1 to bits 0 through 15 in X0 (and zeros out bits 16 through 63 in X0).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_714" aria-label="714"/>&#13;
<h4 class="H2" id="sec13"><span id="h2-226"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.11 Bit Movement with ubfiz</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ubfiz</span> (unsigned bit field insert in zero) copies bits from the LO bits of a source register to any other position in the destination register, as the converse of the <span class="SANS_TheSansMonoCd_W5Regular_11">ubfx</span> instruction. The syntax for this instruction is</p>&#13;
<pre id="pre-929"><code>ubfiz<var> Rd</var>,<var> Rs</var>, #<var>posn</var>, #<var>len</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are both either W<i>n</i> or X<i>n</i>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> is the destination location where bit 0 from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> will be moved, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> is the size of the bit string. For example</p>&#13;
<pre id="pre-930"><code>ubfiz w1, w0, #12, #8</code></pre>&#13;
<p class="Continued1">copies bits 0 through 7 from W0 to bits 12 through 19 in W1.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-227"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.12 Bit Movement with ubfm</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ubfm</span> instruction (unsigned bit field move) copies the LO bits from a source register to an arbitrary position in the destination register (and puts 0s everywhere else in the destination register). The syntax is</p>&#13;
<pre id="pre-931"><code>ubfm<var> Rd</var>,<var> Rs</var>, #<var>immr</var>, #<var>imms</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are both either W<i>n</i> or X<i>n</i>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span> are values in the range 0 to 31 for 32-bit operations or 0 to 63 for 64-bit operations. This instruction does one of two operations based on the values of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> ≤ <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>, take bits <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> through <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span> and rotate right by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span>.</li>&#13;
<li class="BL">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> &gt; <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>, take <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span> + 1 LO bits and rotate right by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span>.</li>&#13;
</ul>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ubfm</span> instruction is the basis for many instructions (aliases) in the ARM instruction set: <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">shift</span> is equivalent to</p>&#13;
<pre id="pre-932"><code>ubfm <var>Rd</var>, <var>Rs</var>, #(<var>Rsize</var> - <var>shift</var>) % <var>Rsize</var>, #<var>Rsize</var> - 1 - <var>shift</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rsize</span> is the register size (32 or 64).</p>&#13;
<p class="TX">Meanwhile, <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">shift</span> is equivalent to</p>&#13;
<pre id="pre-933"><code>ubfm <var>Rd</var>, <var>Rs</var>, #<var>shift</var>, #<var>Rsize</var> - 1 // <var>Rsize</var> is register size.</code></pre>&#13;
<p class="Continued1">and <span class="SANS_TheSansMonoCd_W5Regular_11">ubfiz</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">width</span> is equivalent to</p>&#13;
<pre id="pre-934"><code>ubfm <var>Rd</var>, <var>Rs</var>, #(<var>Rsize</var>-<var>lsb</var>) % <var>Rsize</var>, #<var>width</var> - 1</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rsize</span> is the register size (32 or 64). Finally, <span class="SANS_TheSansMonoCd_W5Regular_11">ubfx</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">width</span> is equivalent to</p>&#13;
<pre id="pre-935"><code>ubfm <var>Rd</var>, <var>Rs</var>, #<var>lsb</var>, #<var>lsb</var> + <var>width</var> - 1</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_715" aria-label="715"/>where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">lsb</span> is the LO bit of the bit string to move and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">width</span> is the number of bits to move.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-228"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.13 Bit Extraction with extr</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">extr</span> instruction allows you to extract a bit string across a pair of registers, using the syntax</p>&#13;
<pre id="pre-936"><code>extr<var> Rd</var>,<var> Rl</var>,<var> Rr</var>, #<var>posn</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rl</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rr</span> are all W<i>n</i> or X<i>n</i>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> is a constant in the range 0 to the register size – 1 (31 or 63).</p>&#13;
<p class="TX">This instruction begins by concatenating the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rl</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rr</span> registers to form a 64- or 128-element bit string. It then extracts 32 or 64 bits (depending on the register sizes) from this string, starting at bit position <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ror</span> <i>(immediate) instruction is an alias of</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extr</span> <i>obtained by setting</i> <span class="SANS_TheSansMonoCd_W5Regular_11">Rl</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_11">Rr</span> <i>to the same register.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-229"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.2.14 Bit Testing with tbz and tbnz</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">tbz</span> (test bit zero) and <span class="SANS_TheSansMonoCd_W5Regular_11">tbnz</span> (test bit not zero) instructions allow you to branch to a location based on whether a particular bit is set in a register, using the following syntax:</p>&#13;
<pre id="pre-937"><code>tbz<var>  Rs</var>, #<var>imm</var>,<var> target  </var>// R<var>s </var>= W<var>n </var>or X<var>n</var>,<var> imm </var>= 0 to 31 (W<var>n</var>) or&#13;
tbnz<var> Rs</var>, #<var>imm</var>,<var> target  </var>// 0 to 63 (X<var>n</var>).<var> target </var>is a stmt label.</code></pre>&#13;
<p class="TX">These instructions test the bit specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> in <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s</span> to see if it is a 0 or a 1. The <span class="SANS_TheSansMonoCd_W5Regular_11">tbz</span> instruction transfers control to the specified target label if it is 0 (falling through if it is 1), while <span class="SANS_TheSansMonoCd_W5Regular_11">tbnz</span> transfers control to the specified target label if it is 1 (falling through if it is 0).</p>&#13;
<p class="TX">You can use these instructions to turn any register into a 32- or 64-bit “pseudo condition code register,” allowing you to branch based on whether a particular bit in that register is set or clear. Though no instructions will automatically set or clear these “condition codes,” you can use any of the bit-manipulation instructions in this chapter to manipulate those pseudo condition codes.</p>&#13;
<p class="TX">Don’t forget that you can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">cbz</span> (compare and branch if zero) and <span class="SANS_TheSansMonoCd_W5Regular_11">cbnz</span> (compare and branch if not zero) instructions to compare a register against 0 and transfer control if it is (<span class="SANS_TheSansMonoCd_W5Regular_11">cbz</span>), or is not (<span class="SANS_TheSansMonoCd_W5Regular_11">cbnz</span>), equal to 0. This is useful after instructions such as <span class="SANS_TheSansMonoCd_W5Regular_11">addv</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, or other instructions that don’t set the Z flag, to see if they’ve produced a zero (or nonzero) result.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-132"/><span class="SANS_Futura_Std_Bold_B_11">12.3 Flag Modification by Arithmetic and Logical Instructions</span></h3>&#13;
<p class="TNI1">In the previous sections, the instructions manipulated bits in general-purpose and vector registers. Although the PSR is not a general-purpose <span role="doc-pagebreak" epub:type="pagebreak" id="pg_716" aria-label="716"/>register, remember that the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bics</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instructions set the N and Z flags based on the computed result. If the HO (sign) bit of the result is 1, these instructions set the N flag; if the result is 0, these instructions set the Z flag. Otherwise, they clear the flags.</p>&#13;
<p class="TX">You can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sbcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">negs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ngcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ccmn</span> instructions to set the flags. In particular, keep in mind that</p>&#13;
<pre id="pre-938"><code>adds<var> Rd</var>,<var> Rn</var>,<var> Rn</var> //<var> R</var> = X or W</code></pre>&#13;
<p class="Continued1">shifts the value in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rn</span> to the left one bit and moves the (original) HO bit into the carry flag. This instruction sets the overflow flag if the two original HO bits contain 0b01 or 0b10. It sets the negative flag if the resulting HO bit is 1. Finally, of course, it sets the zero flag if the result of the addition is 0.</p>&#13;
<p class="TX">Also note that the instruction</p>&#13;
<pre id="pre-939"><code>adcs<var> Rn</var>,<var> Rn</var>,<var> Rn</var> //<var> R</var> = X or W</code></pre>&#13;
<p class="Continued1">is equivalent to a “rotate left <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rn</span> 1 bit through the carry flag” instruction. You can use this to set the carry flag based on the HO bit of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rn</span> and capture the previous carry flag value into the LO bit of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rn</span>.</p>&#13;
<p class="TX">Keep in mind that only the arithmetic and logical instructions that operate on general-purpose registers (and have the <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix) affect the flags. In particular, the vector instructions do not affect the flags.</p>&#13;
<p class="TX">While it’s not an arithmetic or logical instruction, the <span class="SANS_TheSansMonoCd_W5Regular_11">mrs</span> (move register to status) instruction, with the destination field NZCV, sets all the flags to the values found in bits 28–31 of the general-purpose register. This provides a quick way to create a multiway branch from 4 bits. Consider the following code (taken from section 11.10.4, <span class="Xref">“Vector Comparison Results,”</span> on <span class="Xref"><a href="chapter11.xhtml#pg_691">page 691</a></span>):</p>&#13;
<pre id="pre-940"><code>        lea     r3, mask            // 0x0008000400020001&#13;
        ldr     q3, [r3]&#13;
        cmeq    v0.4h, v1.4h, v2.4h&#13;
        and     v0.8b, v0.8b, v3.8b // Keep LO bit of each lane.&#13;
        addv    h0, v0.4h           // Merge the bits into H0.&#13;
        umov    w0, v0.h[0]&#13;
        lsl     w0, w0, #28&#13;
        mrs     x0, nzcv</code></pre>&#13;
<p class="TX">Now you can test N, Z, C, and V flags to see if lanes 3, 2, 1, or 0 (respectively) in V1 were equal to the corresponding lanes in V2.</p>&#13;
<p class="TX">This section has provided a generic introduction to setting the condition code flags to capture a bit value. Because instructions with an <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix affect the flags differently, it is important to discuss how instructions affect the individual condition code flags; the following sections handle that task.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-230"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.3.1 The Zero Flag</span></h4>&#13;
<p class="TNI1">The zero flag (Z) setting is one of the most important results produced by the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction. Indeed, programs reference this flag so often after <span role="doc-pagebreak" epub:type="pagebreak" id="pg_717" aria-label="717"/>the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction that ARM added a separate <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction whose main purpose is to logically AND two results and set the flags without otherwise affecting either instruction operand.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Technically,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">tst</span> <i>is not a new instruction, but rather an alias for</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ands</span> <i>when the destination register is WZR or XZR.</i></p>&#13;
<p class="TX">The zero flag can be used to check three things after the execution of an <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction: whether a particular bit in an operand is set, whether at least one of several bits in a bit set is 1, and whether an operand is 0. The first use case is actually a special instance of the second, in which the bit set contains only a single bit. The following paragraphs explore each of these uses.</p>&#13;
<p class="TX">To test whether a particular bit is set in a given operand, <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> an operand with a constant value containing a single set bit you wish to test. This clears all the other bits in the operand, leaving a 0 in the bit position under test if the operand contained a 0 in that bit position and a 1 if it contained a 1. Because all other bits in the result are 0, the entire result will be 0 if that particular bit is 0; the entire result will be nonzero if that bit position contains a 1. The ARM CPU reflects this status in the zero flag (Z = 1 indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence demonstrates how to test if bit 4 is set in W0:</p>&#13;
<pre id="pre-941"><code>  tst w0, 0b10000  // Check bit #4 to see if it is 0/1.&#13;
  bne bitIsSet&#13;
&#13;
<var>  Do this if the bit is clear.</var>&#13;
   .&#13;
   .&#13;
   .&#13;
bitIsSet:   // Branch here if the bit is set.</code></pre>&#13;
<p class="TX">You can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instructions to see whether any one of several bits is set. Simply supply a constant that has a 1 in all the positions you want to test (and 0s everywhere else). ANDing an operand with such a constant will produce a nonzero value if one or more of the bits in the operand under test contain a 1. The following example tests whether the value in W0 contains a 1 in bit positions 1 and 2:</p>&#13;
<pre id="pre-942"><code>    tst w0, 0b0110&#13;
    beq noBitsSet&#13;
&#13;
<var>    Do whatever needs to be done if one of the bits is set.</var>&#13;
&#13;
noBitsSet:</code></pre>&#13;
<p class="TX">You cannot use a single <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction to see whether all the corresponding bits in the bit set are equal to 1. To accomplish this, you must first mask out the bits that are not in the set and then compare the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_718" aria-label="718"/>result against the mask itself. If the result is equal to the mask, all the bits in the bit set contain 1s. You must use the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction for this operation because the <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction does not modify the result. The following example checks whether all the bits in a bit set (<span class="SANS_TheSansMonoCd_W5Regular_11">bitMask</span>) are equal to 1:</p>&#13;
<pre id="pre-943"><code>    ldr  w1, =bitMask     // Assume not valid immediate const.&#13;
    ands w0, w0, w1&#13;
    cmp  w0, w1&#13;
    bne  allBitsArentSet&#13;
&#13;
// All the bit positions in W0 corresponding to the set&#13;
// bits in bitMask are equal to 1 if we get here.&#13;
&#13;
<var>    Do whatever needs to be done if the bits match.</var>&#13;
&#13;
allBitsArentSet:</code></pre>&#13;
<p class="TX">Of course, once you stick the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction in there, you don’t really have to check whether all the bits in the bit set contain 1s. You can check for any combination of values by specifying the appropriate value as the operand to <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instructions will set the zero flag in the preceding code sequences only if all the bits in W0 (or other destination operand) have 0s in the positions where 1s appear in the constant operand. This suggests another way to check for all 1s in the bit set: invert the value in W0 prior to using the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction. In this case, if the zero flag is set, you know that the (original) bit set contained all 1s. For example, the following code checks whether any bits specified by 1s in a bitmask are nonzero:</p>&#13;
<pre id="pre-944"><code>    ldr  w1, =bitMask     // Assume not valid immediate const.&#13;
    mvn  w0, w0&#13;
    tst  w0, w1&#13;
    bne  NotAllOnes&#13;
&#13;
// At this point, W0 contained all 1s in the bit positions&#13;
// occupied by 1s in the bitMask constant.&#13;
&#13;
<var>    Do whatever needs to be done at this point.</var>&#13;
&#13;
NotAllOnes:</code></pre>&#13;
<p class="TX">The previous paragraphs all suggest that the <span class="SANS_TheSansMonoCd_W5Regular_11">bitMask</span> (the source operand) is a constant, but you can use a variable or other register too. Simply load that variable or register with the appropriate bitmask before you execute the <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instructions in the preceding examples.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-231"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.3.2 The Negative Flag</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instructions will also set the negative flag (N, also known as the sign flag) if the HO bit of the result is set. This allows you to test two individual bits in a register, assuming one of those bits is the HO bit. When <span role="doc-pagebreak" epub:type="pagebreak" id="pg_719" aria-label="719"/>using these instructions, the mask value must contain a 1 in the HO bit as well as in the bit position of the other bit you want to test. After executing the <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction, you must check the N flag before testing the Z flag (as the Z flag will be clear if the HO bit was set).</p>&#13;
<p class="TX">If the HO bit is set and you also want to see whether the other bit is set, you must test that other bit again (or use the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction, as in the previous section).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-232"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.3.3 The Carry and Overflow Flags</span></h4>&#13;
<p class="TNI1">The logical instructions (<span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span>) that affect the flags always clear the carry and overflow flags. However, the arithmetic instructions (<span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sbcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">negs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ngcs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ccmn</span>) modify these flags. In particular, when the two source operands are the same, <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> shift the HO bit of the (original) source into the carry flag.</p>&#13;
<p class="TX">Negating the most negative value (for example, the word value <span class="SANS_TheSansMonoCd_W5Regular_11">0x80000000</span>) will set the overflow flag:</p>&#13;
<pre id="pre-945"><code>orr     w1, wzr, #0x80000000  // mov x1, #0x80000000&#13;
negs    w1, w1                // Sets V (and N) flags</code></pre>&#13;
<p class="TX">Refer to the ARM AARCH64 documentation to determine how the various instructions affect the carry and overflow flags. Note that many instructions will not affect these two flags (especially the overflow flag) even though they affect the N and Z flags.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h1-133"/><span class="SANS_Futura_Std_Bold_B_11">12.4 Packing and Unpacking Bit Strings</span></h3>&#13;
<p class="TNI1">Inserting a bit string into an operand and extracting a bit string from an operand are common operations. <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> provided simple examples of packing and unpacking such data; this section formally describes how to do this, now that you’ve learned more instructions and have more tools to work with.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-233"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.4.1 Inserting One Bit String into Another</span></h4>&#13;
<p class="TNI1">For the purposes of this chapter, I will assume that we’re dealing with bit strings that fit within a byte, half-word, word, or double-word operand. Large bit strings that cross object boundaries require additional processing; I discuss bit strings that cross double-word boundaries later in this section.</p>&#13;
<p class="TX">When packing and unpacking a bit string, you must consider its starting bit position and length. The <i>starting bit position</i> is the bit number of the LO bit of the string in the operand. The <i>length</i> is the number of bits in the string.</p>&#13;
<p class="TX">To insert (pack) data into a destination operand, start with a bit string of the appropriate length that is right-justified (starts in bit position 0) and zero-extended to 8, 16, 32, or 64 bits. Next, insert this data at the appropriate starting position in another operand that is 8, 16, 32, or 64 bits wide. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_720" aria-label="720"/>The destination bit positions are not guaranteed to contain any particular value.</p>&#13;
<p class="TX">The first two steps (which can occur in any order) are to clear out the corresponding bits in the destination operand and shift a copy of the bit string so that the LO bit begins at the appropriate bit position. The third step is to OR the shifted result with the destination operand. This inserts the bit string into the destination operand. <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> diagrams this process.</p>&#13;
<figure class="IMG"><img class="img7" id="fig12-3" src="../images/Figure12-3.jpg" alt="" width="1088" height="1867"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-3: Inserting a bit string into a destination operand</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_721" aria-label="721"/>The following three instructions insert a bit string of known length into a destination operand, as shown in <a href="chapter12.xhtml#fig12-3">Figure 12-3</a>. These instructions assume that the source bit string is in W1 (with 0s in positions outside the bit string) and the destination operand is in W0:</p>&#13;
<pre id="pre-946"><code>lsl  w1, w1, #5&#13;
bic  w0, w0, #0b111100000&#13;
orr  w0, w0, w1</code></pre>&#13;
<p class="TX">For the special case when the destination bit position and bit string length are constants (known at assembly time), the ARM CPU provides an instruction to handle bit insertion for you: <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> (bit field insert). It has the following syntax</p>&#13;
<pre id="pre-947"><code>bfi<var> Rd</var>,<var> Rs</var>, #<var>posn</var>, #<var>len</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are both either W<i>n</i> or X<i>n</i>. The sum of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> must not exceed the register size (32 for W<i>n</i> and 64 for X<i>n</i>).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> instruction takes the LO <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> bits of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> and inserts them into the destination register (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>) starting at bit position <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span>. Consider the instruction</p>&#13;
<pre id="pre-948"><code>bfi w0, w1, #12, #16</code></pre>&#13;
<p class="Continued1">assuming W0 contained 0x33333333 (the destination value) and W1 contained 0x1200 (the insertion value). This would leave 0x31200333 in W0.</p>&#13;
<p class="TX">If you don’t know the length and the starting position while writing the program (that is, you have to calculate them at runtime), you must use several instructions to do a bit-string insertion. Suppose you have two values—a starting bit position for the field you’re inserting and a nonzero length value—and that the source operand is in W1 and the destination operand is in W0. The <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> procedure in Listing 12-1 demonstrates how to insert a bit string from W1 into W0.</p>&#13;
<pre id="pre-949"><code>// Listing12-1.S&#13;
//&#13;
// Demonstrate inserting bit strings into a register.&#13;
//&#13;
// Note that this program must be assembled and linked&#13;
// with the "LARGEADDRESSAWARE:NO" option.&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
            .text&#13;
            .pool&#13;
&#13;
ttlStr:     wastr   "Listing 12-1"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_722" aria-label="722"/>// Sample input data for the main program:&#13;
&#13;
Value2Merge:&#13;
            .dword  0x12, 0x1e, 0x5555&#13;
            .dword  0x1200, 0x120&#13;
&#13;
MergeInto:&#13;
            .dword  0xffffffff, 0, 0x12345678&#13;
            .dword  0x33333333, 0xf0f0f0f&#13;
&#13;
LenInBits:  .dword  5, 9, 16, 16, 12&#13;
szLenInBits =       (.-LenInBits)/8&#13;
&#13;
StartPosn:  .dword  7, 4, 4, 12, 18&#13;
&#13;
// Format strings used to print results:&#13;
&#13;
fmtstr1:    wastr   "merge(%x, "&#13;
fmtstr2:    wastr   "%x, "&#13;
fmtstr3:    wastr   "%d) = "&#13;
fmtstr4:    wastr   "%x\n"&#13;
fmtstr:     wastr   "Here I am!\n"&#13;
&#13;
// getTitle&#13;
//&#13;
// Returns a pointer to the program's name&#13;
// in X0:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// MergeBits(Val2Merge, MergeWith, Start, Length)&#13;
//&#13;
// Length (LenInBits[i]) value is passed in X3.&#13;
// Start (StartPosn[i]) is passed in X2.&#13;
// Val2Merge (Value2Merge[i]) and MergeWith (MergeInto[i])&#13;
// are passed in X1 and X0.&#13;
//&#13;
// mergeBits result is returned in X0.&#13;
&#13;
            proc    mergeBits&#13;
&#13;
            locals  mb&#13;
            qword   mb.x1x2&#13;
            qword   mb.x3x4&#13;
            byte    mb.stk, 64&#13;
            endl    mb&#13;
&#13;
            enter   mb.size&#13;
&#13;
            stp     x1, x2, [fp, #mb.x1x2]&#13;
            stp     x3, x4, [fp, #mb.x3x4]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_723" aria-label="723"/>            // Generate mask bits&#13;
            // 1 in bits 0 to n - 1:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> mov     x4, #1&#13;
            lsl     x4, x4, x3  // Compute 2**n.&#13;
            sub     x4, x4, #1  // 2**n - 1&#13;
&#13;
            // Position mask bits to target location:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lsl     x4, x4, x2&#13;
&#13;
            // Mask out target bits:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> bic     x0, x0, x4&#13;
&#13;
            // Merge the bits:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lsl     x1, x1, x2&#13;
            orr     x0, x0, x1&#13;
&#13;
            // Restore registers and return:&#13;
&#13;
            ldp     x3, x4, [fp, #mb.x3x4]&#13;
            ldp     x1, x2, [fp, #mb.x1x2]&#13;
            leave&#13;
            endp    mergeBits&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            qword   am.x20x21&#13;
            qword   am.x22x23&#13;
            dword   am.x24&#13;
            byte    am.stk, 256&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
            stp     x20, x21, [fp, #am.x20x21]&#13;
            stp     x22, x23, [fp, #am.x22x23]&#13;
            str     x24, [fp, #am.x24]&#13;
&#13;
            // The following loop calls mergeBits as&#13;
            // follows&#13;
            //&#13;
            // mergeBits&#13;
            // (&#13;
            //      Value2Merg[i],&#13;
            //      MergeInto[i],&#13;
            //      StartPosn[i],&#13;
            //      LenInBits[i]);&#13;
            //&#13;
            // where "i" runs from 4 down to 0.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_724" aria-label="724"/>            //&#13;
            // Index of the last element in the arrays:&#13;
&#13;
            mov     x20, #szLenInBits - 1&#13;
&#13;
testLoop: &#13;
&#13;
            // Fetch the Value2Merge element and write&#13;
            // its value to the display while it is&#13;
            // handy:&#13;
&#13;
            lea     x1, Value2Merge&#13;
            ldr     x1, [x1, x20, lsl #3]&#13;
            mstr    x1, [sp]&#13;
            lea     x0, fmtstr1&#13;
            mov     x22, x1             // Save for later.&#13;
            bl      printf&#13;
&#13;
            // Fetch the MergeInto element and write&#13;
            // its value to the display:&#13;
&#13;
            lea     x1, MergeInto&#13;
            ldr     x1, [x1, x20, lsl #3]&#13;
            mstr    x1, [sp]&#13;
            mov     x21, x1             // Save for later.&#13;
            lea     x0, fmtstr2&#13;
            bl      printf&#13;
&#13;
            // Fetch the StartPosn element and write&#13;
            // its value to the display:&#13;
&#13;
            lea     x1, StartPosn&#13;
            ldr     x1, [x1, x20, lsl #3]&#13;
            mstr    x1, [sp]&#13;
            mov     x23, x1             // Save for later.&#13;
            lea     x0, fmtstr2&#13;
            bl      printf&#13;
&#13;
            // Fetch the LenInBits element and write&#13;
            // its value to the display:&#13;
&#13;
            lea     x1, LenInBits&#13;
            ldr     x1, [x1, x20, lsl #3]&#13;
            mstr    x1, [sp]&#13;
            mov     x24, x1             // Save for later.&#13;
            lea     x0, fmtstr3&#13;
            bl      printf&#13;
&#13;
            // Call MergeBits:&#13;
            //      (&#13;
            //          Value2Merge,&#13;
            //          MergeInto,&#13;
            //          StartPosn,&#13;
            //          LenInBits&#13;
            //      );&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_725" aria-label="725"/>            mov     x0, x21&#13;
            mov     x1, x22&#13;
            mov     x2, x23&#13;
            mov     x3, x24&#13;
            bl      mergeBits&#13;
&#13;
            // Display the function result (returned in&#13;
            // X0. For this program, the results are&#13;
            // always 32 bits, so it prints only the LO&#13;
            // 32 bits of X0):&#13;
&#13;
            mov     x1, x0&#13;
            mstr    x1, [sp]&#13;
            lea     x0, fmtstr4&#13;
            bl      printf&#13;
&#13;
            // Repeat for each element of the array:&#13;
&#13;
            subs    x20, x20, #1&#13;
            bpl     testLoop&#13;
&#13;
allDone:&#13;
            ldp     x20, x21, [fp, #am.x20x21]&#13;
            ldp     x22, x23, [fp, #am.x22x23]&#13;
            ldr     x24, [fp, #am.x24]&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> function is where the merging occurs. This code begins by generating a mask containing all 1 bits from location 0 to <i>n</i> – 1, where <i>n</i> is the length of the bit string to insert <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The code uses a simple mathematical trick to generate these bits: if you compute 2<i><sup>n</sup></i> and then subtract 1 from this value, the resulting value contains 1 bits in positions 0 to <i>n</i> – 1. After generating this mask, the code positions the mask bits to the position where <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> will insert the bit string <span class="CodeAnnotation" aria-label="annotation2">❷</span>. It then masks out (sets to 0) those bit positions in the destination location <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">To complete the merge, <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> moves the bits to merge to the proper position and ORs those bits into the destination location (which contains 0s at that point) <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> function assumes that the source bits (the bits to merge) form a bit string that is exactly <i>n</i> bits long (<i>n</i> being the value passed in X3) and is located in bit positions 0 to <i>n</i> – 1. Note that if you need to handle bit-insertion values that might have 1 bits in positions <i>n</i> or greater, you should logically AND the value to merge (passed in X1) with the bitmask after shifting it <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The version of <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> in Listing 12-1 assumes that the <span class="SANS_TheSansMonoCd_W5Regular_11">val2Merge</span> argument (X1) doesn’t contain any extra 1 bits.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function <span class="CodeAnnotation" aria-label="annotation5">❺</span> is a loop that steps through the <span class="SANS_TheSansMonoCd_W5Regular_11">ValueToMerge</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">MergeInto</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">LenInBits</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">StartPosn</span> arrays. This loop fetches these four values, prints them, and then calls the <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> function to merge the <span class="SANS_TheSansMonoCd_W5Regular_11">ValueToMerge</span> entry into <span class="SANS_TheSansMonoCd_W5Regular_11">MergeInto</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">LenInBits</span> element contains the size (in bits) to merge, and the value from the <span class="SANS_TheSansMonoCd_W5Regular_11">StartPosn</span> array is the bit position where the merger should take place.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_726" aria-label="726"/>Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 12-1:</p>&#13;
<pre id="pre-950"><code>%<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing12-1</span>&#13;
%<span class="SANS_TheSansMonoCd_W7Bold_11"> ./Listing12-1</span>&#13;
CallingListing 12-1:&#13;
merge(120, f0f0f0f, 12, 12) = 4830f0f&#13;
merge(1200, 33333333, c, 16) = 31200333&#13;
merge(5555, 12345678, 4, 16) = 12355558&#13;
merge(1e, 0, 4, 9) = 1e0&#13;
merge(12, ffffffff, 7, 5) = fffff97f&#13;
Listing12-1 terminated</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> function is very general, allowing you to specify the bit string length and the destination position as variable parameter values. If the length and destination position values are constants within your code (a common special case), you can use a more efficient way to insert bits from one register into another: the <span class="SANS_TheSansMonoCd_W5Regular_11">bfm</span> (bit field move) instruction. This instruction has the syntax</p>&#13;
<pre id="pre-951"><code>bfm<var> Rd</var>,<var> Rs</var>, #<var>rotate</var>, #<var>bitposn</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are both either W<i>n</i> or X<i>n</i>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rotate</span> is the number of rotate-right positions, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">bitposn</span> is the leftmost bit in the source (starting at bit 0) to move.</p>&#13;
<p class="TX">This instruction rotates (a copy of) the LO <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">bitposn</span> bits in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> the specified number of bit positions, then replaces the corresponding bits in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> with these rotated bits.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">bfi</span> <i>instruction is an alias of</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">bfm</span> <i>with a slight modification to the meaning of the two immediate operands (see the ARM documentation for more details).</i></p>&#13;
<p class="TX">The examples in this section assume that the bit string appears completely within a double-word (or smaller) object. This will always be the case if the bit string is less than or equal to 64 bits in length. However, if the length of the bit string plus its starting position (modulo 8) within an object is greater than 64, the bit string will cross a double-word boundary within the object.</p>&#13;
<p class="TX">Inserting such bit strings requires up to three operations: one to extract the start of the bit string (up to the first double-word boundary), one to copy whole double words (assuming the bit string is so long it consumes several double words), and one to copy leftover bits in the last double word at the end of the bit string. I’ll leave the implementation of this operation as an exercise for you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-234"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.4.2 Extracting a Bit String</span></h4>&#13;
<p class="TNI1">The previous section described how to insert one bit string into another. This section covers the converse operation: extracting a bit string from a larger string.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_727" aria-label="727"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">bfxil</span> (bit field extract and insert at low end) instruction extracts any number of bits (at any position) from a source register and copies those bits to the LO bit positions of a destination register. Its syntax is</p>&#13;
<pre id="pre-952"><code>bfxil<var> Rd</var>,<var> Rs</var>, #<var>posn</var>, #<var>len</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> are either W<i>n</i> or X<i>n</i> . The sum of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> must not exceed the register size (32 for W<i>n</i> and 64 for X<i>n</i>), and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> must be less than the register size.</p>&#13;
<p class="TX">This instruction extracts <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> bits, starting at bit number <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span>, from <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s</span> and inserts them into the LO <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> bits of <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>. It does not affect the other bits (at bit positions <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> and higher) in <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>. Generally, you’ll want to set <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> to 0 before using this instruction, as shown in the following example:</p>&#13;
<pre id="pre-953"><code>mov   w0, wzr         // Extract bits 5 through 12 from W1&#13;
bfxil w0, w1, #5, #8  // and store them in W0.</code></pre>&#13;
<p class="TX">Like the <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">bfxil</span> supports only immediate constants for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> operands. If you need to specify variables for either (or both) of these arguments, you must write an <span class="SANS_TheSansMonoCd_W5Regular_11">extractBits</span> function (similar to <span class="SANS_TheSansMonoCd_W5Regular_11">mergeBits</span> in the previous section). The following instructions do the actual bit extraction in <span class="SANS_TheSansMonoCd_W5Regular_11">extractBits</span>:</p>&#13;
<pre id="pre-954"><code>// Generate mask bits&#13;
// 1 in bits 0 to n - 1:&#13;
&#13;
mov     x4, #1&#13;
lsl     x4, x4, x3  // Compute 2**n.&#13;
sub     x4, x4, #1  // 2**n - 1&#13;
&#13;
// Position mask bits to target location:&#13;
&#13;
lsl     x4, x4, x2&#13;
&#13;
// Extract the target bits:&#13;
&#13;
and     x1, x1, x4&#13;
&#13;
// Right-justify the bits to bit 0:&#13;
&#13;
lsr     x0, x1, x2</code></pre>&#13;
<p class="TX">This leaves the extracted bits in the LO bit positions of X0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-235"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.4.3 Clearing a Bit Field</span></h4>&#13;
<p class="TNI1">The Gas assembler provides an alias of the <span class="SANS_TheSansMonoCd_W5Regular_11">bfm</span> instruction that you can use to clear bits in a register: <span class="SANS_TheSansMonoCd_W5Regular_11">bfc</span> (bit field clear). Its syntax is</p>&#13;
<pre id="pre-955"><code>bfc<var> Rd</var>, #<var>posn</var>, #<var>len</var></code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_728" aria-label="728"/>where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> is W<i>n</i> or X<i>n</i> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> have the same meanings and restrictions as the <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> instruction. If you supply a <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> field of 1, you can clear individual bits (specified by a bit number) with <span class="SANS_TheSansMonoCd_W5Regular_11">bfc</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfc</span> instruction zeros out <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">len</span> bits starting at bit position <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">posn</span> in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>. It is equivalent to the following instruction</p>&#13;
<pre id="pre-956"><code>bfi<var> Rd</var>,<var> Rzr</var>, #<var>posn</var>, #<var>len</var>  // Rzr = WZR or XZR</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span> is W<i>d</i> or X<i>d</i>, as appropriate.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfc</span> instruction is available only on ARMv8.2-a and later CPUs, not on Raspberry Pi (3 and 4) and other lower-end systems. (Note that the Raspberry Pi 5 does support this instruction.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-236"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.4.4 Using bfm</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfxil</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> (as well as <span class="SANS_TheSansMonoCd_W5Regular_11">bfc</span>) instructions are actually aliases for the instruction <span class="SANS_TheSansMonoCd_W5Regular_11">bfm</span>:</p>&#13;
<pre id="pre-957"><code>bfm<var> Rd</var>,<var> Rs</var>, #<var>immr</var>, #<var>imms</var></code></pre>&#13;
<p class="Continued1">Like the <span class="SANS_TheSansMonoCd_W5Regular_11">ubfm</span> instruction, they do two operations based on the values of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> ≤ <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>, take bits <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> through <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span> from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> and rotate right by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span>, merging with the existing bits in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>.</li>&#13;
<li class="BL">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span> &gt; <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span>, take <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imms</span> + 1 LO bits from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rs</span> and rotate right by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">immr</span>, merging with the existing bits in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Rd</span>.</li>&#13;
</ul>&#13;
<p class="TX">For example</p>&#13;
<pre id="pre-958"><code>ldr     w0, =0xffffffff&#13;
mov     w1, #0x2&#13;
bfm     w0, w1, #4, #2</code></pre>&#13;
<p class="Continued1">produces 0xAFFFFFFF in W0.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfi</span> instruction is equivalent to the following:</p>&#13;
<pre id="pre-959"><code>bfm<var> Rd</var>,<var> Rs</var>, #(-<var>posn</var> % 64), #(len-1)</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bfxil</span> instruction is equivalent to this:</p>&#13;
<pre id="pre-960"><code>bfm<var> Rd</var>,<var> Rs</var>, #<var>posn</var>, #(<var>len</var>+<var>posn</var>-1)</code></pre>&#13;
<p class="Continued1">Generally, you would use these aliases rather than the <span class="SANS_TheSansMonoCd_W5Regular_11">bfm</span> mnemonic.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1" id="sec26"><span id="h1-134"/><span class="SANS_Futura_Std_Bold_B_11">12.5 Common Bit Operations</span></h3>&#13;
<p class="TNI1">You’ll encounter many bit-manipulation design patterns in assembly language programs. This section covers some of the more common algorithms and patterns.</p>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_729" aria-label="729"/>&#13;
<h4 class="H2" id="sec27"><span id="h2-237"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.1 Coalescing Bit Sets and Distributing Bit Strings</span></h4>&#13;
<p class="TNI1">Inserting and extracting bit sets is only a little different from inserting and extracting bit strings if the “shape” of the bit set you’re inserting (or resulting bit set you’re extracting) is the same as the shape of the bit set in the main object. The <i>shape</i> of a bit set is the distribution of the bits in the set, ignoring the starting bit position of the set. A bit set that includes bits 0, 4, 5, 6, and 7 has the same shape as a bit set that includes bits 12, 16, 17, 18, and 19 because the distribution of the bits is the same.</p>&#13;
<p class="TX">The code to insert or extract this bit set is nearly identical to that of the previous sections; the only difference is the mask value you use. For example, to insert this bit set starting at bit 0 in W0 into the corresponding bit set starting at position 12 in W1, you could use the following code:</p>&#13;
<pre id="pre-961"><code>ldr w2, =0b11110001000000000000 // Bit set mask in posn.&#13;
lsl w0, w0, #12                 // Move src bits into posn.&#13;
and w0, w0, w2                  // Mask out source bits.&#13;
bic w1, w1, w2                  // Clear out destination bits.&#13;
orr w1, w1, w0                  // Merge bit set into W1.</code></pre>&#13;
<p class="TX">However, suppose you have five bits in bit positions 0 through 4 in W0 and want to merge them into bits 12, 16, 17, 18, and 19 in W1. Somehow you have to <i>distribute</i> the bits in W0 prior to logically ORing the values into W1; that is, you have to move the bits from positions 0 to 4 into positions 12, 16, 17, 18, and 19.</p>&#13;
<p class="TX">The converse operation, <i>coalescing bits</i>, extracts the bits from various bit positions and packs them (coalesces them) into the LO bit positions of a destination location. The following code demonstrates how to distribute the bits in a bit string according to the values in a bitmask:</p>&#13;
<pre id="pre-962"><code>// W0- Contains the source value to insert the bits into&#13;
// W1- Contains the bits to insert, justified against bit 0&#13;
// W2- Counter (size of register, 32 in this case)&#13;
// W3- Bitmap; 1s specify bits to copy, 0 specifies bits&#13;
//      to preserve&#13;
&#13;
            mov     w2, #32      // Number of bits to rotate&#13;
            b.al    DistLoop&#13;
&#13;
CopyToW0:&#13;
            extr    w0, w1, w0, #1&#13;
            lsr     w1, w1, #1&#13;
            cbz     w2, Done&#13;
DistLoop:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> sub     w2, w2, #1&#13;
            tst     w3, #1&#13;
            lsr     w3, w3, #1&#13;
            bne     CopyToW0&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ror     w0, w0, #1&#13;
            cbnz    w2, DistLoop&#13;
Done:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_730" aria-label="730"/>The main entry point to this loop is <span class="SANS_TheSansMonoCd_W5Regular_11">DistLoop</span>. It begins by decrementing the loop counter held in W2 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This code will check the value in W2 to see if the loop is done a little later. Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">tst</span> instruction checks whether bit 0 of the bitmap contains a 1. If it does, the code needs to copy a bit from the LO bit position of W1 into W0; otherwise, it keeps the current bit value.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> instruction transfers control to <span class="SANS_TheSansMonoCd_W5Regular_11">CopyToW0</span> if it needs to copy a bit from W1; otherwise, it falls through to <span class="CodeAnnotation" aria-label="annotation2">❷</span> if it’s going to keep the current bit in W0. The <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span> instruction rotates the existing W0 LO bit into the HO bit position (after 32 iterations of this loop, the bit winds up back in its original position). After the <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span>, the code checks whether the loop has executed 32 times (the <span class="SANS_TheSansMonoCd_W5Regular_11">cbnz</span> instruction). If so, the code exits; otherwise, it repeats.</p>&#13;
<p class="TX">If the LO bit of W3 was a 1, control transfers to the <span class="SANS_TheSansMonoCd_W5Regular_11">CopyToW0</span> label, which is responsible for shifting the (current) LO bit of W1 into W0. The code at <span class="SANS_TheSansMonoCd_W5Regular_11">CopyToW0</span> uses the <span class="SANS_TheSansMonoCd_W5Regular_11">extr</span> instruction to grab bit 0 from W1 and place it in bit 31 of W0 (shifting bits 1 to 31 in W0 down 1 bit). The <span class="SANS_TheSansMonoCd_W5Regular_11">lsr w1, w1, #1</span> instruction removes the used bit from W1 and places the next bit to merge into W1 in bit position 0. After a quick check to see whether the loop is complete, the code falls down into <span class="SANS_TheSansMonoCd_W5Regular_11">DistLoop</span> and repeats.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This code would be a bit simpler if the ARM had an instruction that would rotate a register right by one bit through the carry flag. However, since no such instruction exists, this code has to simulate it by using</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extr</span><i>.</i></p>&#13;
<p class="TX">The general algorithm for coalescing bits is a tad more efficient than general distribution. Here’s the code that will extract bits from W1 via the bitmask in W3 and leave the result in W0:</p>&#13;
<pre id="pre-963"><code>// W0- Destination register&#13;
// W1- Source register&#13;
// W3- Bitmap with 1s representing bits to copy to W0&#13;
&#13;
        mov    w0, wzr    // Clear destination register.&#13;
        b.al   ShiftLoop&#13;
&#13;
ShiftInW0:&#13;
        extr    w0, w0, w1, #31&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lsl     w1, w1, #1&#13;
&#13;
ShiftLoop:&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> tst     w3, #0x80000000&#13;
        lsl     w3, w3, #1&#13;
        bne     ShiftInW0   // W3 HO bit was set.&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lsl     w1, w1, #1&#13;
        cbnz    w3, ShiftLoop</code></pre>&#13;
<p class="TX">As with the distribution code, the coalescing code loops through the bits, copying one bit at a time from W1 to W0 wherever there are 1 bits in the bitmap <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">extr</span> instruction creates a 32-bit string from bit 31 of W1 and bits 0 to 30 of W0, then puts the result into W0. On each loop iteration, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_731" aria-label="731"/>the code shifts the bits in W1 one position to the left <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> so that the next bit to (possibly) move into W0 is in the HO bit position. Unlike the distribution code, this code will terminate after it processes all the 1 bits present in the bitmap.</p>&#13;
<p class="TX">Another way to coalesce bits is via table lookup. By grabbing a byte of data at a time (so your tables don’t get too large), you can use that byte’s value as an index into a lookup table that coalesces all the bits down to bit 0. Finally, you can merge the bits at the low end of each byte together. This may produce a more efficient coalescing algorithm in certain cases. The implementation is left to you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-238"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.2 Creating Packed Arrays of Bit Strings</span></h4>&#13;
<p class="TNI1">Though far less efficient, it is possible to create arrays of elements whose size is not a multiple of 8 bits. The drawback is that calculating the “address” of an array element and manipulating it involves a lot of extra work. This section presents a few examples of packing and unpacking array elements that are an arbitrary number of bits long.</p>&#13;
<p class="TX">Why would you want arrays of bit objects? The answer is simple: space. If an object consumes only 3 bits, you can get 2.67 times as many elements into the same space if you pack the data rather than allocating a whole byte for each object. For very large arrays, this can result in substantial savings. Of course, the cost of saving space is speed: you must execute extra instructions to pack and unpack the data, slowing access to it.</p>&#13;
<p class="TX">The calculation for locating the bit offset of an array element in a large block of bits is almost identical to the standard array access:</p>&#13;
<pre id="pre-964"><code><var>Element_Address_in_bits</var> =&#13;
    <var>Base_address_in_bits</var> + <var>index</var> × <var>element_size_in_bits</var></code></pre>&#13;
<p class="TX">Once you calculate the element’s address in bits, you must convert it to a byte address (because you must use byte addresses when accessing memory) and extract the specified element. Because the base address of an array almost always starts on a byte boundary, you can use the following equations to simplify this task:</p>&#13;
<pre id="pre-965"><code><var>Byte_of_1st_bit</var> =&#13;
    <var>Base_Address</var> + (<var>index</var> × <var>element_size_in_bits</var>) / 8&#13;
&#13;
<var>Offset_to_1st_bit</var> =&#13;
    (<var>index</var> × <var>element_size_in_bits</var>) % 8</code></pre>&#13;
<p class="TX">For example, suppose you have an array of 200 3-bit objects declared as follows:</p>&#13;
<pre id="pre-966"><code>AO3Bobjects:&#13;
    .space  (200 * 3)/8 + 2  // "+2" handles truncation.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_732" aria-label="732"/>The constant expression in the preceding dimension reserves space for enough bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression adds 2 extra bytes at the end to ensure you don’t lose any odd bits and to allow you to access 1 byte beyond the end of the array when storing data to the array. (Losing odd bits wouldn’t occur in this example because 600 is evenly divisible by 8, but in general you can’t count on this; adding 2 extra bytes usually won’t hurt.)</p>&#13;
<p class="TX">Now suppose you want to access the <i>i</i>th 3-bit element of this array. You can extract these bits with the following code:</p>&#13;
<pre id="pre-967"><code>// Extract the <var>i</var>th group of 3 bits in AO3Bobjects&#13;
// and leave this value in W0:&#13;
&#13;
        mov     w2, wzr         // Put i / 8 remainder here.&#13;
        ldr     w0, [fp, #i]    // Get the index into the array.&#13;
&#13;
        mov     w4, #3&#13;
        mul     w0, w0, w4      // W0 = W0 * 3 (3 bits/element)&#13;
        ubfiz   w2, w0, #0, #3  // W2 = LO 3 bits of W0&#13;
        lsr     w0, w0, #3      // W0 / 8 -&gt; W0 and W0 % 8 -&gt; W2&#13;
&#13;
// Okay, fetch the word containing the 3 bits you want to&#13;
// extract. You have to fetch a word because the last bit or two&#13;
// could wind up crossing the byte boundary (that is, bit&#13;
// offset 6 and 7 in the byte).&#13;
&#13;
        lea     x1, AO3Bobjects&#13;
&#13;
        ldrh    w0, [x1, x0]    // Fetch 16 bits.&#13;
        lsr     w0, w0, w2      // Move bits down to bit 0.&#13;
        And     w0, w0, #0b111  // Remove the other bits.</code></pre>&#13;
<p class="TX">Inserting an element into the array is a little more difficult. In addition to computing the base address and bit offset of the array element, you must also create a mask to clear out the bits in the destination where you’re going to insert the new data. The following code inserts the LO 3 bits of W0 into the <i>i</i>th element of the <span class="SANS_TheSansMonoCd_W5Regular_11">AO3Bobjects</span> array:</p>&#13;
<pre id="pre-968"><code>Masks:&#13;
            .hword    ~ 0b0111,            ~ 0b00111000&#13;
            .hword    ~ 0b000111000000,    ~ 0b1110&#13;
            .hword    ~ 0b01110000,        ~ 0b001110000000&#13;
            .hword    ~ 0b00011100,        ~ 0b11100000&#13;
              .&#13;
              .&#13;
              .&#13;
&#13;
// Get the index into the array (assume i is a local variable):&#13;
&#13;
            ldr     w1, [fp, #i]&#13;
&#13;
// Use LO 3 bits as index into Masks table:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_733" aria-label="733"/>            and     w2, w1, #0b111&#13;
            lea     x4, Masks&#13;
            ldrh    w4, [x4, w2, uxtw #1] // Get bitmask.&#13;
&#13;
// Convert index into the array into a bit index.&#13;
// To do this, multiply the index by 3:&#13;
&#13;
            mov     w3, #3&#13;
            mul     w1, w1, w3&#13;
&#13;
// Divide by 8 to get the byte index into W1&#13;
// and the bit index (the remainder) into W2:&#13;
&#13;
            and     w2, w1, #0b111&#13;
            lsr     w1, w1, #3&#13;
&#13;
// Grab the bits and clear those you're inserting:&#13;
&#13;
            lea     x5, AO3Bobjects&#13;
            ldrh    w6, [x5, w1, uxtw #0]&#13;
            and     w3, w4, w6&#13;
&#13;
// Put your 3 bits in their proper location:&#13;
&#13;
            lsl     w0, w0, w2&#13;
&#13;
// Merge bits into destination:&#13;
&#13;
            orr     w3, w3, w0&#13;
&#13;
// Store back into memory:&#13;
&#13;
            strh    w3, [x5, w1, uxtw #0]</code></pre>&#13;
<p class="TX">Assuming <span class="SANS_TheSansMonoCd_W5Regular_11">AO3Bobjects</span> contained all 0s, <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> contained 5, and W0 (the value to insert) was 7 upon executing this code, the first couple of bytes would contain <span class="SANS_TheSansMonoCd_W5Regular_11">0x38000</span> after the execution of this code sequence. Because each element is 3 bits, the array looks like</p>&#13;
<pre id="pre-969"><code>000 000 000 000 000 111 000 000 000 000 00 ...</code></pre>&#13;
<p class="Continued1">where bit 0 is the leftmost bit. Flipping the 32 bits around to make them more readable, and grouping them in blocks of 4 bits to make it easy to convert to hexadecimal, we get</p>&#13;
<pre id="pre-970"><code>0000 0000 0000 0011 1000 0000 0000 0000</code></pre>&#13;
<p class="Continued1">which is <span class="SANS_TheSansMonoCd_W5Regular_11">0x38000</span>.</p>&#13;
<p class="TX">This code uses a lookup table (<span class="SANS_TheSansMonoCd_W5Regular_11">Masks</span>) to generate the masks needed to clear out the appropriate position in the array. Each element of this array contains all 1s, except for three 0s in the position you need to clear for a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_734" aria-label="734"/>given bit offset. Note the use of the NOT operator (<span class="SANS_TheSansMonoCd_W5Regular_11">~</span>) to invert the constants in the table.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2" id="sec29"><span id="h2-239"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.3 Searching for Bits</span></h4>&#13;
<p class="TNI1">A common bit operation is to locate the end of a run of bits. A special case of this operation is to locate the first (or last) set or clear bit in a 16-, 32-, or 64-bit value. This section explores ways to handle this special case.</p>&#13;
<p class="TX"><i>First set bit</i> means the first bit in a value, scanning from bit 0 toward the high-order bit, which contains a 1. A similar definition exists for the <i>first clear bit</i>. The <i>last set bit</i> is the first bit in a value, scanning from the high-order bit toward bit 0, which contains a 1. Likewise, a similar definition exists for the <i>last clear bit</i>.</p>&#13;
<p class="TX">One obvious way to scan for the first or last bit is to use a shift instruction in a loop and count the number of iterations before you shift out a 1 (or 0). The number of iterations specifies the position. Here’s some sample code that checks for the first set bit (from bit 0) in W0 and returns that bit position in W1:</p>&#13;
<pre id="pre-971"><code>          mov  w1, #31    // Count off the bit positions in W1.&#13;
TstLp:    adds w0, w0, w0 // Check whether the current bit&#13;
                          // position contains a 1.&#13;
          bcs  Done       // Exit loop if it does.&#13;
          subs w1, w1, #1 // Decrement your bit position counter by 1.&#13;
          bpl  TstLp      // Exit after 32 iterations.&#13;
Done:</code></pre>&#13;
<p class="Continued1">Note that this code returns –1 in W1 if W0 has no set bits.</p>&#13;
<p class="TX">Searching for the first (or last) set bit is such a common operation that Arm added an instruction specifically to accelerate this process: <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> (count leading 0 bits). In particular, the <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instruction counts the number of leading 0s, which tells you the position of the most significant set bit. Consider the following code:</p>&#13;
<pre id="pre-972"><code>clz w0, w0&#13;
sub w0, w0, #31&#13;
neg w0, w0</code></pre>&#13;
<p class="TX">This code computes the bit position of the 1 in the highest position in W0 (leaving the result in W0). This produces –1 if W0 contains 0 (no leading set bits).</p>&#13;
<p class="TX">Don’t forget that <span class="SANS_TheSansMonoCd_W5Regular_11">cls</span> doesn’t count leading <i>set</i> bits but leading <i>sign</i> bits. To count the number of leading (HO) bits containing 1s, invert the number and use <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> to count the leading 0 bits. To count the number of trailing 0 or 1 bits (that is, a bit run of 0s or 1s starting at the LO bit position), use the <span class="SANS_TheSansMonoCd_W5Regular_11">rbit</span> instruction to reverse the bits and then count the HO bits you’re interested in.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_735" aria-label="735"/>&#13;
<h4 class="H2" id="sec30"><span id="h2-240"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.4 Merging Bit Strings</span></h4>&#13;
<p class="TNI1">Another common bit string operation is to produce a single bit string by merging, or interleaving, bits from two sources. For example, the following code sequence creates a 32-bit string by merging alternate bits from two 16-bit strings:</p>&#13;
<pre id="pre-973"><code>          mov  w2, #16&#13;
          lsl  w0, w0, #16     // Put LO 16 bits in the HO&#13;
          lsl  w1, w1, #16     // bit positions.&#13;
MergeLp:  extr w3, w3, w0, #31 // Shift a bit from W0 into W3.&#13;
          Extr w3, w3, w1, #31 // Shift a bit from W1 into W3.&#13;
          lsl  w0, w0, #1      // Move on to the next bit in&#13;
          lsl  w1, w1, #1      // W0 and W1.&#13;
          subs w2, w2, #1      // Repeat 16 times.&#13;
          bne  MergeLp</code></pre>&#13;
<p class="TX">This particular example merges two 16-bit values together, alternating their bits in the result value. For a faster implementation of this code, unroll the loop to eliminate one-third of the instructions.</p>&#13;
<p class="TX">With a few slight modifications, you can merge four 8-bit values together, or merge other bit sets from the source strings. For example, the following code copies bits 0 to 5 from W0, bits 0 to 4 from W1, bits 6 to 11 from W0, bits 5 to 15 from W1, and finally bits 12 to 15 from W0:</p>&#13;
<pre id="pre-974"><code>bfi  w3, w0, #0, #6   // W0[0:5] to W3[0:5]&#13;
bfi  w3, w1, #6, #5   // W1[0:4] to W3[6:10]&#13;
lsr  w0, w0, #6&#13;
bfi  w3, w0, #11, #6  // W0[6:11] to W3[11:16]&#13;
lsr  w1, w1, #5&#13;
bfi  w3, w1, #17, #11 // W1[5:15] to W3[17:27]&#13;
lsr  w0, w0, #6&#13;
bfi  w3, w0, #28, #4  // W0[12:15] to W3[28:31]</code></pre>&#13;
<p class="TX">This code produces the result in W3, extracting the bits from W0 and W1.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-241"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.5 Scattering Bits from a Bit String</span></h4>&#13;
<p class="TNI1">You can also extract and distribute bits in a bit string among multiple destinations, known as <i>scattering bits</i>. The following code takes the 32-bit value in W0 and distributes alternate bits among the LO 16 bits in the W1 and W3 registers:</p>&#13;
<pre id="pre-975"><code>            ldr     w0, =0x55555555&#13;
            mov     w3, wzr&#13;
            mov     w1, wzr&#13;
            mov     w2, #16     // Count the loop iterations.&#13;
ExtractLp:  adds    w0, w0, w0  // Extract odd bits to W3.&#13;
            adc     w3, w3, w3&#13;
            adds    w0, w0, w0  // Extract even bits to W1.&#13;
            adc     w1, w1, w1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_736" aria-label="736"/>            subs    w2, w2, #1  // Repeat 16 times.&#13;
            bne     ExtractLp</code></pre>&#13;
<p class="TX">This code produces 0xffff in W1 and 0x0000 in W0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-242"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">12.5.6 Searching for a Bit Pattern</span></h4>&#13;
<p class="TNI1">Another bit-related operation you may need is the ability to search for a particular bit pattern in a string of bits. For example, you might want to locate the bit index of the first occurrence of 0b1011 starting at a particular position in a bit string. This section explores simple algorithms to accomplish this task.</p>&#13;
<p class="TX">To search for a particular bit pattern, you must know four details:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The pattern</li>&#13;
<li class="BL">The length of that pattern</li>&#13;
<li class="BL">The bit string to search through, known as the <i>source</i></li>&#13;
<li class="BL">The length of the bit string that you’re searching</li>&#13;
</ul>&#13;
<p class="TX">The basic idea behind the search is to create a mask based on the length of the pattern and to mask a copy of the source with this value. You can then directly compare the pattern with the masked source for equality. If they are equal, you’re finished; if not, increment a bit position counter, shift the source one position to the right, and try again. You repeat the operation [<i>length</i>(<i>source</i>) – <i>length</i>(<i>pattern</i>)] times. The algorithm fails if it does not detect the bit pattern after that number of attempts, because it has exhausted all the bits in the source operand that could match the pattern’s length.</p>&#13;
<p class="TX">Listing 12-2 searches for a 4-bit pattern.</p>&#13;
<pre id="pre-976"><code>// Listing12-2.S&#13;
//&#13;
// Demonstration of bit string searching&#13;
&#13;
        #include    "aoaa.inc"&#13;
&#13;
        .text&#13;
        .pool&#13;
ttlStr: wastr   "Listing 12-2"&#13;
noMatchStr:&#13;
        wastr   "Did not find bit string\n"&#13;
&#13;
matchStr:&#13;
        wastr   "Found bit string at posn %d\n"&#13;
&#13;
        proc    getTitle, public&#13;
        lea     x0, ttlStr&#13;
        ret&#13;
        endp    getTitle&#13;
&#13;
        proc    asmMain, public&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_737" aria-label="737"/>        locals  am&#13;
        word    pattern&#13;
        word    source&#13;
        word    mask&#13;
        byte    am.stk, 64&#13;
        endl    am&#13;
&#13;
        enter   am.size&#13;
&#13;
        // Initialize the local variables this code&#13;
        // will use:&#13;
&#13;
        mov     w0, #0b1011110101101100&#13;
        str     w0, [fp, #source]&#13;
        mov     w0, #0b1011&#13;
        str     w0, [fp, #pattern]&#13;
        mov     w0, #0b1111&#13;
        str     w0, [fp, #mask]&#13;
&#13;
        // Here's the code that will search for the&#13;
        // pattern in the source bit string:&#13;
&#13;
        mov     w2, #28             // 28 attempts because 32 - 4 = 28&#13;
                                    // (len(src) - len(pat))&#13;
        ldr     w3, [fp, #mask]     // Mask for the comparison.&#13;
        ldr     w0, [fp, #pattern]  // Pattern to search for&#13;
        and     w0, w0, w3          // Mask unnecessary bits in W0.&#13;
        ldr     w1, [fp, #source]   // Get the source value.&#13;
ScanLp: mov     w4, w1              // Copy the LO 4 bits of W1.&#13;
        and     w4, w4, w3          // Mask unwanted bits.&#13;
        cmp     w0, w4              // See if you match the pattern.&#13;
        beq     Matched&#13;
        sub     w2, w2, #1          // Repeat specified number of times.&#13;
        lsr     w1, w1, #1&#13;
        cbnz    w1, ScanLp&#13;
&#13;
// Do whatever needs to be done if you failed to&#13;
// match the bit string:&#13;
&#13;
        lea     x0, noMatchStr&#13;
        bl      printf&#13;
        b.al    Done&#13;
&#13;
// If you get to this point, you matched the bit string.&#13;
// You can compute the position in the original source as 28 - W2.&#13;
&#13;
Matched:&#13;
        mov     x1, #28&#13;
        sub     x1, x1, x2&#13;
        mstr    x1, [sp]&#13;
        lea     x0, matchStr&#13;
        bl      printf&#13;
Done:&#13;
        leave                       // Return to caller.&#13;
        endp    asmMain</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_738" aria-label="738"/>Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 12-2:</p>&#13;
<pre id="pre-977"><code>%<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing12-2</span>&#13;
%<span class="SANS_TheSansMonoCd_W7Bold_11"> ./Listing12-2</span>&#13;
Calling Listing12-2:&#13;
Found bit string at posn 2&#13;
Listing12-2 terminated</code></pre>&#13;
<p class="TX">As you can see, this program properly located the bit pattern in the source.</p>&#13;
<aside class="box" aria-label="box-30">&#13;
<p class="BH" id="box-30"><span class="SANS_Dogma_OT_Bold_B_11">BIT-STRING SCANNING AND STRING MATCHING</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Bit-string scanning is a special case of string matching. String matching is a well-studied problem in computer science, and many of the algorithms you can use for it are applicable to bit-string matching as well.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">These algorithms are beyond the scope of this chapter, but as a preview of how this works, you’d execute a function passing the pattern and the current source as parameters and use the result as an index into a lookup table to determine the number of bits you can skip. These algorithms let you skip several bits, rather than shifting only once for each iteration of the scanning loop, as the previous algorithm does.</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h3 class="H1" id="sec33"><span id="h1-135"/><span class="SANS_Futura_Std_Bold_B_11">12.6 Moving On</span></h3>&#13;
<p class="TNI1">Assembly language is well known for its powerful bit-manipulation capabilities, difficult to replicate in an HLL. This chapter described those capabilities for the 64-bit ARM CPU. It began with definitions useful for describing bit operations, then introduced a bevy of instructions that manipulate bit data. This chapter also discussed using the condition code flags in the PSR as bit data, along with the instructions to manipulate those flags, specifically the negative (N), zero (Z), carry (C), and overflow (V) flags.</p>&#13;
<p class="TX">After discussing the basic set of bit-manipulation instructions, this chapter covered applications of those instructions, including packing and unpacking bit strings, inserting one bit string into another, extracting a bit string from a source string, coalescing and distributing bits, working with packed arrays of bits, searching for bit strings, merging bit strings, and scattering bits from a bit string.</p>&#13;
<p class="TX">For the most part, this chapter concludes the discussion of new ARM assembly language instructions. The remaining chapters discuss the application of these instructions and various software-engineering topics. The next chapter, for example, focuses on macros you can use to simplify your assembly language programs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_739" aria-label="739"/>&#13;
<h3 class="H1" id="sec34"><span id="h1-136"/><span class="SANS_Futura_Std_Bold_B_11">12.7 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">The ultimate book on bit twiddling is <i>Hacker’s Delight</i>, 2nd edition, by Henry S. Warren Jr. (Addison-Wesley Professional, 2012). While this book uses the C programming language for examples, almost all the concepts it discusses apply to assembly language programs as well.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-31">&#13;
<p class="BH" id="box-31"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What general instruction(s) would you use to clear bits in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What instruction could use you to clear a bit, specified by a bitmask containing 1s where you want 0s in the destination register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What general instruction would you use to set bits in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What general instruction would you use to invert (selected) bits in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What general instruction would you use to test a bit (or group of bits) for 0 or 1 in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What single instruction could you use to extract a run of bits from a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What single instruction could you use to position and insert a run of bits in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What instruction allows you to search for the most-significant set bit in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  How would you search for the last clear bit in a register (that is, the lowest-order bit containing a 0)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  What instruction can you use to count the number of bits in each byte of a vector register?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>