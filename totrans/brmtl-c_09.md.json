["```\nconst uint8_t COLOR_RED = 0;\nconst uint8_t COLOR_BLUE = 1;\nconst uint8_t COLOR_GREEN = 2;\n\n#define colorType uint8_t;\n\ncolorType colorIWant = COLOR_RED\n```", "```\nenum colorType {\n    COLOR_RED,\n    COLOR_BLUE,\n    COLOR_GREEN\n};\n\nenum colorType colorIWant = COLOR_RED;\n```", "```\nenum colorType fgColor = COLOR_GREEN;\nprintf(\"The foreground color is %d\\n\", fgColor);\n```", "```\nThe foreground color is 2\n```", "```\ncolorIWant = 33;\n```", "```\nYour box color is 33.\n```", "```\nstatic const char* const colorNames = {\"Red\", \"Blue\", \"Green\"};\n*--snip--*\nprintf(\"Your box color is %s\\n\", colorNames[colorIWant]);\n```", "```\nYour box color is @ @@@�HH   pp�-�=�=�px�-�=�=�888 XXXDDS�td888 P�td\n```", "```\n// WARNING: Do not change this without changing colorNames.\nenum colorType {\n    COLOR_RED,\n    COLOR_BLUE,\n    COLOR_GREEN\n};\n\n// WARNING: Do not change this without changing colorType.\nstatic const char* const colorNames = {\n    \"COLOR_RED\", \"COLOR_BLUE\", \"COLOR_GREEN\"};\n```", "```\n// This is the beginning of a clever trick to define both the values and\n// the names for the enum colorType. The list below will be used twice,\n// once to generate the value and once to generate the names.\n\n#define COLOR_LIST                      \\\n DEFINE_ITEM(COLOR_RED),         \\\n        DEFINE_ITEM(COLOR_BLUE),        \\\n        DEFINE_ITEM(COLOR_GREEN)\n\n// Define DEFINE_ITEM so it generates the actual values for the enum.\n#define DEFINE_ITEM(X) X\nenum colorType {\n   COLOR_LIST\n};\n#undef DEFINE_ITEM\n\n// Define DEFINE_ITEM so it generates the names for the enum.\n#define DEFINE_ITEM(X) #X\nstatic const char* colorNames[] = {\n   COLOR_LIST\n};\n#undef DEFINE_ITEM\n```", "```\n#define COLOR_LIST                      \\\n        DEFINE_ITEM(COLOR_RED),         \\\n        DEFINE_ITEM(COLOR_BLUE),        \\\n        DEFINE_ITEM(COLOR_GREEN)\n```", "```\nDEFINE_ITEM(COLOR_RED), DEFINE_ITEM(COLOR_BLUE), DEFINE_ITEM(COLOR_GREEN)\n```", "```\nCOLOR_RED, COLOR_BLUE, COLOR_GREEN\n```", "```\n#define DEFINE_ITEM(X) X\n```", "```\nenum colorType {\n   COLOR_LIST\n};\n```", "```\nenum colorType {\n    COLOR_RED, COLOR_BLUE, COLOR_GREEN\n};\n```", "```\n#undef DEFINE_ITEM\n```", "```\n#define DEFINE_ITEM(X) #X\n```", "```\n\"COLOR_RED\",\"COLOR_BLUE\",\"COLOR_GREEN\"\n```", "```\n#define DEFINE_ITEM(X) #X\nstatic const char* colorNames[] = {\n   COLOR_LIST\n};\n#undef DEFINE_ITEM\n```", "```\nstruct house {\n    uint8_t stories;        // Number of stories in the house\n    uint8_t bedrooms;       // Number of bedrooms\n    uint32_t squareFeet;    // Size of the house\n};\n```", "```\nstruct house myHouse;\n--snip--\nmyHouse.stories = 2;\nmyHouse.bedrooms = 4;\nmyHouse.squareFeet = 5000;\n```", "```\n/**\n * Demonstrate the use of a structure.\n */\n\n#include <stdio.h>\n#include <stdint.h>\n\nstruct house {\n    uint8_t stories;        // Number of stories in the house\n    uint8_t bedrooms;       // Number of bedrooms\n    uint32_t squareFeet;    // Size of the house\n};\n\nint main() {\n    struct house myHouse;   // The house for this demo\n\n    myHouse.stories = 2;\n    myHouse.bedrooms = 4;\n    myHouse.squareFeet = 5000;\n    printf(\"House -- Stories: %d Bedrooms %d Square Feet %d\\n\",\n        myHouse.stories, myHouse.bedrooms, myHouse.squareFeet);\n    printf(\"Size of the structure %ld\\n\", sizeof(myHouse));\n    return (0);\n}\n```", "```\nSize of the structure 8\n```", "```\nstruct dataBlockHeader {\n    uint32_t nextBlock;      // Number of the next block in this song\n    uint16_t timeStamp;      // Time in seconds of this section of the song\n    uint32_t previousBlock;  // Number of the previous block in the song\n};\n```", "```\nstruct dataBlockHeader {\n    uint32_t nextBlock;      // Number of the next block in this song\n    uint16_t timeStamp;      // Time in seconds of this section of the song\n    **uint16_t padding;        // Automatically added**\n    uint32_t previousBlock;  // Number of the previous block in the song\n};\n```", "```\nstruct dataBlockHeader {\n    uint32_t nextBlock;      // Number of the next block in this song\n    uint16_t timeStamp;      // Time in seconds of this section of the song\n uint32_t previousBlock;  // Number of the previous block in the song\n}  **__attribute__((packed));**\n```", "```\n/*\n * A demonstration of packed and unpacked.\n * This program does nothing useful except\n * generate an assembly listing showing\n * how hard it is to access squareFeet\n * in a packed structure.\n *\n * To run -- don't. Compile and look at the\n * assembly listing instead.\n */\n\n#include \"stm32f0xx.h\"\n#include \"stm32f0xx_nucleo.h\"\n\n// An example of an unpacked structure\nstruct unpackedHouse {\n    uint8_t stories;     // Number of stories in the house\n    uint8_t bedrooms;    // Number of bedrooms\n    uint32_t squareFeet; // Size of the house\n    uint8_t doors;       // Number of doors\n    uint8_t windows;     // Number of windows\n};\n\n// An example of a packed structure\nstruct packedHouse {\n    uint8_t stories;     // Number of stories in the house\n    uint8_t bedrooms;    // Number of bedrooms\n    uint32_t squareFeet; // Size of the house\n uint8_t doors;       // Number of doors\n    uint8_t windows;     // Number of windows\n} __attribute__((packed));\n\n// A place to dump squareFeet for unpackedHouse\nvolatile uint32_t unpackedFeet;\nvolatile uint32_t packedFeet;   // A place to dump squareFeet for packedHouse\n\n// An example unpackedHouse -- values chosen to make demonstration easier\nstruct unpackedHouse theUnpackedHouse = {0x01, 0x02, 0x11223344, 0x03, 0x04};\n\n// An example packedHouse -- values chosen to make demonstration easier\nstruct   packedHouse thePackedHouse = {0x01, 0x02, 0x11223344, 0x03, 0x04};\n\nint main(void)\n{\n  1 unpackedFeet = theUnpackedHouse.squareFeet;\n  2 packedFeet = thePackedHouse.squareFeet;\n\n    for(;;);\n}\n```", "```\n;unpackedFeet = theUnpackedHouse.squareFeet;\n    ldr     r3, .L3       ; Get address of theUnpackedHouse.\n    ldr     r2, [r3, #4]  ; Get data at offset 4\n                          ; (theUnpackedHouse.squareFeet).\n`--snip--`\nL3: theUnpackedHouse\n```", "```\n;  packedFeet = thePackedHouse.squareFeet;\n    ldr     r3, .L3+8     ; Get address of thePackedHouse.\n    ldrh    r2, [r3, #2]  ; Get uint16_t at offset 2 (0x3344).\n                          ; (Byte order puts the low-order bytes first.)\n\n    ldrh    r3, [r3, #4]  ; Get uint16_t at offset 4 (0x1122).\n                          ; (High bytes come after low.)\n\n    lsls    r3, r3, #16   ; r3 contains the top 1/2 of squareFeet\n                          ; in the bottom 16 bits of r3.\n                          ; Shift it left into the top half.\n\n    orrs    r3, r2        ; Combine the two halves.\n\n.L3: theUnpackedHouse\n     thePackedHouse\n```", "```\nstruct house {\n    uint8_t stories;        // Number of stories in the house\n    uint8_t bedrooms;       // Number of bedrooms\n    uint32_t squareFeet;    // Size of the house\n};\n\n// 2 stories\n// 5 bedrooms\n// 2500 square feet\nstruct house myHouse = {2, 5, 2500};\n```", "```\nstruct house myHouse = {\n  stories: 2,\n  bedrooms: 5,\n  squareFeet: 2500\n};\n```", "```\nstruct house myHouse = {\n    .stories: 2,\n    .squareFeet: 2500,\n    .bedrooms: 5\n};\n```", "```\nint array1[5];           // An array\nint array2[5];           // Another array\n\narray1 = array2;         // Illegal\n\nstruct example {\n    int array[5];        // Array inside a structure\n};\nstruct example struct1;  // A structure\nstruct example struct2;  // Another structure\n\n// Initialize structure 2\n\nstruct1 = struct2;       // Structure assignment allowed\n```", "```\n// A rectangle\nstruct rectangle {\n    unsigned int width;  // Width of the rectangle\n    unsigned int height; // Height of a rectangle\n};\n\n// Inefficient parameter passing\nunsigned int area(const struct rectangle aRectangle)\n{\n    return (aRectangle.width * aRectangle.height);\n}\n```", "```\n// Efficient parameter passing\nunsigned int area(const struct rectangle* const aRectangle)\n{\n    return ((*aRectangle).rectangle * (*aRectangle).height);\n}\n```", "```\n// Efficient parameter passing\nunsigned int area(const struct rectangle* const aRectangle)\n{\n    return (aRectangle->rectangle * aRectangle->height);\n}\n```", "```\nstruct [`struct-name`] {\n    `field1`;\n    `field2`;\n*--snip--*\n} [`var-name(s)`];\n```", "```\n// A box to put our stuff into\nstruct {\n    uint32_t width;     // Width of the box\n    uint32_t height;    // Height of the box\n} aBox;\n```", "```\nstruct box {\n    uint32_t width;     // Width of the box\n    uint32_t height;    // Height of the box\n};\n```", "```\nstruct box aBox; // Box to put stuff into\n```", "```\nstruct box {\n    uint32_t width;     // Width of the box\n    uint32_t height;    // Height of the box\n} aBox;\n```", "```\n// Silly definition\nstruct {\n    uint32_t width;     // Width of the box\n    uint32_t height;    // Height of the box\n};\n```", "```\nunion value {\n    uint32_t anInteger;\n    float aFloat;\n};\n```", "```\nunion value theValue;   // Define the value.\n\ntheValue.anInteger = 5; // anInteger is 5.\ntheValue.aFloat = 1.0;  // Assign the field aFloat/wipe out anInteger.\n```", "```\n theValue.aFloat = 1.2;\n    float someFloat = theValue.aFloat;   // Assigns someFloat 1.2\n```", "```\n theValue.aFloat = 1.2;\n    int someInt = theValue.anInteger;   // Results machine-dependent\n```", "```\nstruct square {\n    unsigned int side; // Size of the square\n};\n```", "```\nstruct rectangle {\n    unsigned int width;   // Width of the rectangle\n    unsigned int height;  // Height of the rectangle\n};\n```", "```\nstruct circle {\n    unsigned int radius;  // Radius of the circle\n};\n```", "```\nstruct triangle {\n unsigned int base;    // Base of the triangle\n    unsigned int height;  // How high is it?\n};\n```", "```\nenum shapeType {\n    SHAPE_SQUARE, SHAPE_RECTANGLE, SHAPE_CIRCLE, SHAPE_TRIANGLE\n};\n```", "```\nstruct shape {\n    enum shapeType type;   // The type of the shape\n    union {\n       struct square theSquare;\n       struct rectangle theRectangle;\n       struct circle theCircle;\n       struct triangle theTriangle;\n    } dimensions;\n};\n```", "```\nvoid drawShape(const shape* const theShape) {\n    switch (theShape->type) {\n        case SHAPE_SQUARE:\n            drawSquare(theShape->dimensions.theSquare.side);\n            break;\n        case SHAPE_RECTANGLE:\n            drawSquare(theShape->dimensions.theRectangle.width,\n                       theShape->dimensions.theRectangle.height);\n            // ... other shapes\n```", "```\nstruct read10 {\n    uint8_t opCode;    // Op code for read\n    uint8_t flags;     // Flag bits\n    **uint32_t lba;      // Logical block address**\n    uint8_t group;     // Command group\n    uint16_t transferLength;  // Length of the data to read\n    uint8_t control;   // Control bits, the NACA being the only one defined\n};\n#include <assert.h>\n\nint main() {\n    assert(sizeof(struct read10) == 10);\n```", "```\nstruct read10 {\n    uint8_t opCode;    // Op code for read\n    uint8_t flags;     // Flag bits\n    uint32_t lba;      // Logical block address\n    uint8_t group;     // Command group\n    uint16_t transferLength;  // Length of the data to read\n    uint8_t control;   //  Control bits, the NACA being the only one defined\n} __attribute__((packed));\n```", "```\ntypedef unsigned int dimension;  // Dimension for use in the plans\n```", "```\ndimension width;   // Width of the thing in furlongs\n```", "```\ntypedef `initialtype` `newtypename`;  // A type definition\n```", "```\n// These typedefs are system-dependent.\ntypedef signed char        int8_t;\ntypedef unsigned char      uint8_t;\ntypedef signed short int   int16_t;\ntypedef unsigned short int uint16_t;\ntypedef signed int         int32_t;\ntypedef unsigned int       uint32_t;\n```", "```\n#ifdef ON_16_BIT_CPU\ntypedef signed int   int16_t;\n#else // ON_32_BIT_CPU\ntypedef signed short int   int16_t;\n#endif\n```", "```\nregisterButtonPressHandler(functionToHandleButtonPress);\n```", "```\nint (*ButtonCallback)(const struct event* const theEvent);\n```", "```\n// Define function that returns int*\nint* getPointer(...)\n```", "```\n// Function type for callback function\ntypedef int ButtonCallbackType(const struct event* const theEvent);\n\n// Pointer to callback function\ntypedef ButtonCallbackType* ButtonCallbackPointer;\n```", "```\nvoid registerButtonPressHandler(int (*callbackPointer)\n     (const struct event* const theEvent));\n```", "```\nvoid registerButtonPressHandler(ButtonCallbackPointer callbackPointer);\n```", "```\nstruct rectangle {\n    uint32_t width;  // Width of the rectangle\n    uint32_t height; // Height of the rectangle\n};\n```", "```\nstruct rectangle bigRectangle;   // A big rectangle\n```", "```\ntypedef struct{\n    uint32_t width;       // Width of the rectangle\n    uint32_t height;      // Height of the rectangle\n} rectangle;\n\nrectangle bigRectangle;   // A big rectangle\n```"]