- en: '**16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BITWISE LOGIC, MULTIPLICATION, AND DIVISION INSTRUCTIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg297_Image_276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve learned about program organization, let’s turn our attention
    to computation. I’ll start by explaining the logic operators, which can be used
    to change individual bits in a value using a technique called *masking*.
  prefs: []
  type: TYPE_NORMAL
- en: Then I’ll move on to shift operations, which provide a way to multiply or divide
    by powers of two. In the last two sections of this chapter, I’ll cover arithmetic
    multiplication and division of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitmasking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s often better to think of data items as patterns of bits rather than numerical
    entities. For example, if you look back at [Table 2-5](ch02.xhtml#ch2tab5) in
    [Chapter 2](ch02.xhtml), you’ll see that the only difference between uppercase
    and lowercase alphabetic characters in ASCII is bit number 5, which is `1` for
    lowercase and `0` for upper-case. The ASCII code for `m`, for instance, is `0x6d`,
    and for `M`, it’s `0x4d`. If you wanted to write a function that changed the case
    of a string of alphabetic characters from lowercase to uppercase, you could view
    this as a numerical difference of 32\. You would need to determine the current
    case of the character and then decide whether to change it by subtracting 32.
  prefs: []
  type: TYPE_NORMAL
- en: But there’s a faster way. We can change bit patterns by using logical bitwise
    operations and a mask, or bitmask. A *mask* is a specific pattern of bits that
    can be used to make specified bits in a variable either `1` or `0`, or to invert
    them. For example, to make sure an alphabetic character is uppercase, we need
    to ensure its bit number 5 is `0`, giving the mask `11011111` = `0xdf`. Then,
    using the previous example of `m`, `0x6d`*∧* `0xdf` = `0x4d`, which is `M`. If
    the character is already uppercase, then `0x4d`*∧* `0xdf` = `0x4d`, leaving it
    as uppercase. This solution avoids checking for the case before the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: We can use similar logic for other operations. To make a bit `1`, place a `1`
    in the appropriate bit position in the mask and use the bitwise OR operation.
    To produce a `0` in a bit position, place a `0` in that position and a `1` in
    each of the other bit positions in the mask and then use the bitwise AND operation.
    You can invert bits by placing a `1` in each bit position you want to invert and
    a `0` in all other positions and using the bitwise XOR operation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Bitmasking in C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Listings 16-1](ch16.xhtml#ch16list1) to [16-3](ch16.xhtml#ch16list3)
    shows how to use a mask to convert all lowercase alphabetic characters in a text
    string to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: '*uppercase.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1: A program to make an alphabetic text string uppercase*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This program, and many that follow in the book, uses the* read_str , write_char
    *, and* write_str *functions that you were asked to write in “Your Turn” [exercise
    14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1). If you want to,
    you can instead use the* gets , putchar *, and* puts *functions, respectively,
    in the C standard library, but you’ll need to make the appropriate changes in
    the book’s functions that call them because their behavior is a little different.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 16-1](ch16.xhtml#ch16list1), we use `#define` to give a symbolic
    name to the maximum number of characters allowed ❶. The `char` array needs to
    have one more element to allow for the terminating `NUL` character ❷. The two
    instances of `#define` allow us to easily change the length in one place and make
    sure that the `char` array is the correct length and the correct value gets passed
    to the `read_str` function.
  prefs: []
  type: TYPE_NORMAL
- en: You learned in [Chapter 14](ch14.xhtml) that when an argument’s name is used
    to pass a variable to a function, it’s passed by value; a copy of the variable’s
    value is passed to the called function. If we wanted to pass the address of the
    variable, we would need to use the `&` (address of) operator. C treats array names
    differently. When the name of an argument is an array, C uses pass by pointer;
    the address of the beginning of the array is passed to the function instead of
    a copy of all the values in the array. So, we *do not* use the `&` operator when
    passing an array as an argument to a function ❸. You’ll learn more about how arrays
    are implemented in [Chapter 17](ch17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Nothing else is new in this `main` function, so we’ll move on to the `to_upper`
    subfunction. [Listing 16-2](ch16.xhtml#ch16list2) shows the header file for this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '*to_upper.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-2: The header file for the* to_upper *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument, `src_ptr`, is the address of the text string to be converted,
    and the second argument, `dest_ptr`, is the address where the result of the conversion
    will be stored. In [Listing 16-1](ch16.xhtml#ch16list1), we passed the same array
    as both the source and destination arrays, so `to_upper` will replace the characters
    stored in the array with the new values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-3](ch16.xhtml#ch16list3) gives the definition of `to_upper`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*to_upper.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-3: A function to convert lowercase alphabetic characters to uppercase*'
  prefs: []
  type: TYPE_NORMAL
- en: To make sure bit 5 is `0`, we use a mask that has a `0` in bit position 5 and
    `1`s elsewhere ❶. While the current character is not the `NUL` character, we perform
    a bitwise AND with the character in the source array, which masks out bit 5 and
    allows all the other bits to remain the same in the result ❷. The result of this
    AND operation is stored in the destination array. Don’t forget to include the
    `NUL` character from the input text string ❸! Forgetting to do so is a programming
    error that won’t show up in testing if the byte in memory following where the
    output is stored happens to be `0x00` (the `NUL` character). If you change the
    length of the input text string, the next byte in memory may not be `0x00`. This
    error might therefore show up in a seemingly random way.
  prefs: []
  type: TYPE_NORMAL
- en: Although this function returns a count of the number of characters processed,
    our `main` function does nothing with the value. A calling function doesn’t need
    to use a returned value, but I usually include a counting algorithm in functions
    like this for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-4](ch16.xhtml#ch16list4) shows the assembly language the compiler
    generates for the `to_upper` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*to_upper.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-4: The compiler-generated assembly language for the function in
    [Listing 16-3](ch16.xhtml#ch16list3)*'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that our compiler structures `while` loops such that it is
    unnecessary to copy the `NUL` character after the loop terminates ❷. But we still
    need to write correct C code, because another compiler might use a different structure
    for `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the current character from the source `char` array, the first
    `and` instruction masks the word in `w0` with `-33` = `0xffffffdf`, which leaves
    bit 5 equal to `0`, thus making sure the character is uppercase ❶. The second
    `and` instruction uses the `0x000000ff` mask to leave us with an 8-bit `char`
    in `w0`.
  prefs: []
  type: TYPE_NORMAL
- en: Treating the characters as bit patterns rather than as numerical values allows
    us to convert lowercase characters to uppercase while leaving upper-case characters
    unchanged, without using an `if` statement to first test the case of the character.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the compiler used two `and` instructions instead
    of simply using `0xdf` as the mask with one `and` instruction. To answer this
    question, let’s look at the basic logic instructions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Logic Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Logic instructions* work bitwise—that is, they operate on the individual bits
    in the corresponding bit positions of the two operands. The three basic logic
    instructions are for the AND, OR, or XOR operations. The A64 instruction set includes
    two versions for each operation. The shifted register versions allow you to shift
    one of the source operands before applying the operation. The immediate data versions
    allow only certain bit patterns, which I’ll explain after describing the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: and**—AND shifted register**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`and w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise AND between
    the values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the AND operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: '`and x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise AND between
    the values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the AND operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: and**—AND immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`and w`d `, w`s `,` imm performs a bitwise AND between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`and x`d `, x`s `,` imm performs a bitwise AND between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: orr**—Inclusive OR shifted register**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`orr w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise OR between the
    values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the OR operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: '`orr x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise OR between the
    values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the OR operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: orr**—Inclusive OR immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`orr w`d `, w`s `,` imm performs a bitwise OR between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`orr x`d `, x`s `,` imm performs a bitwise OR between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: eor**—Exclusive OR shifted register**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`eor w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise XOR between
    the values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the XOR operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: '`eor x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise XOR between
    the values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the XOR operation using the shft amnt option.'
  prefs: []
  type: TYPE_NORMAL
- en: eor**—Exclusive OR immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`eor w`d `, w`s `,` imm performs a bitwise XOR between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`eor x`d `, x`s `,` imm performs a bitwise XOR between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-1](ch16.xhtml#ch16tab1) lists the allowable values for the shft option.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Allowable Values for shft in Shifted Register Logic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| shft | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `lsl` | Logical shift left |'
  prefs: []
  type: TYPE_TB
- en: '| `lsr` | Logical shift right |'
  prefs: []
  type: TYPE_TB
- en: '| `asr` | Arithmetic shift right |'
  prefs: []
  type: TYPE_TB
- en: '| `ror` | Rotate right |'
  prefs: []
  type: TYPE_TB
- en: A logical shift fills the vacated bits with `0`s. An arithmetic shift fills
    the vacated bits with copies of the high-order bit of the value being shifted.
    A right rotation shifts all the bits to the right, moving the low-order bits to
    the high-order positions. The 32-bit versions of these logic instructions do not
    change the 32 high-order bits in the destination register, so a shift or rotation
    of a `w`s register applies only to the low-order 32 bits of the corresponding
    `x`s register.
  prefs: []
  type: TYPE_NORMAL
- en: You learned in [Chapter 12](ch12.xhtml) that the imm values in these logic instructions
    cannot be 32 or 64 bits. To see how these three instructions encode the imm value,
    let’s take a look at the machine code for the first `and` instruction in [Listing
    16-4](ch16.xhtml#ch16list4), shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg357_Image_283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: The machine code for the* and w0, w0, -33 *instruction in [Listing
    16-4](ch16.xhtml#ch16list4)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `0` in the `N` field specifies a 32-bit operation. A `1` would specify a
    64-bit operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imms` field specifies two numbers: the number of bits in a repeating pattern
    and the number of consecutive `1`s in the pattern. I’ll use [Table 16-2](ch16.xhtml#ch16tab2)
    to explain how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-2:** Encoding `imms` Values in Immediate Logic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| N | imms | **Pattern size (bits)** | **Number of 1s** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `11110x` | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1110xx` | 4 | 1–3 |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `110xxx` | 8 | 1–7 |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `10xxxx` | 16 | 1–15 |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0xxxxx` | 32 | 1–31 |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `xxxxxx` | 64 | 1–63 |'
  prefs: []
  type: TYPE_TB
- en: For the rows with `0` in the `N` column, the location of the first `0` in the
    `imms` column (reading from the left) specifies the number of bits in the pattern.
    The `1` in the `N` column specifies a 64-bit pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In each row, the binary number in the `x` positions plus 1 specifies the number
    of consecutive `1`s in the pattern, starting from the right-hand side. For example,
    if `N` is `0` and `imms` is `110010`, this specifies an 8-bit pattern with three
    consecutive `1`s. This would result in the 32-bit mask `0x07070707`.
  prefs: []
  type: TYPE_NORMAL
- en: The 6-bit number in the `immr` field of the `and` instruction that’s shown in
    [Figure 16-1](ch16.xhtml#ch16fig1) specifies the number of right rotations to
    be applied to the mask before the logical operation.
  prefs: []
  type: TYPE_NORMAL
- en: The mask specified in this instruction starts with a 32-bit pattern with 31
    consecutive `1`s, `0x7fffffff`, that occurs only once. This pattern then gets
    rotated 26 bits to the right to give `0xffffffdf` for the mask that is used in
    the AND operation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll show you a way to write this program directly in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '***Bitmasking in Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use the same masking algorithm in our assembly language version, but we’ll
    use identifiers that make it easier to see what’s going on. [Listing 16-5](ch16.xhtml#ch16list5)
    shows the `main` function written in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '*uppercase.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-5: A program to make a text string uppercase*'
  prefs: []
  type: TYPE_NORMAL
- en: We have allocated 50 bytes on the stack for our character array. Adding 16 bytes
    to save `sp` and `fp` takes us to a frame size of at least 66 bytes. To keep the
    stack pointer properly aligned on a 16-byte boundary, we allocate 80 bytes for
    the stack frame ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the address of our `char` array to the `to_upper` function as both the
    source and the destination, so it will replace the original values in the array
    with the new ones ❷.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use the same masking algorithm as the compiler to write `to_upper` in assembly
    language, but I’ll structure the function differently. [Listing 16-6](ch16.xhtml#ch16list6)
    shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '*to_upper.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-6: A program to convert text to uppercase*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using registers `w2`, `w3`, and `w4` for our local variables instead of
    placing them in our stack frame. The standard says we don’t need to save the contents
    of these registers for the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ldrb` instruction loads a character into a `w` register ❷. We need to
    use a 32-bit mask to match the width of the register. The correct mask for this
    algorithm is `0x000000df` ❶. The compiler uses two masks to achieve the correct
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ldrb` instruction zeros the 24 high-order bits in the register, so we could
    use only the first instruction. But this might confuse a person maintaining this
    code, since the algorithm works with bit patterns, not integers, and writing the
    instruction as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: could be even more confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Our use of the `movz` instruction to load the correct mask into a register clearly
    shows our intent ❸. Then, we use the register form of the `and` instruction to
    mask out the lowercase bit in the character. In the next section, I’ll show you
    ways to shift bits to multiply or divide a value by powers of two.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 16.1     Write a program in assembly language that converts all alphabetic characters
    to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2     Write a program in assembly language that changes the case of all alphabetic
    characters to the opposite case.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3     Write a program in assembly language that converts all alphabetic characters
    to uppercase and to lowercase. Your program should also show the user’s original
    input string after displaying both the upper-case and lowercase conversions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shifting Bits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s sometimes useful to be able to shift all the bits in a variable to the
    left or to the right. If the variable is an integer, shifting all the bits one
    position to the left effectively multiplies the integer by two, and shifting them
    one position to the right effectively divides it by two. Using left/right shifts
    to do multiplication/division by powers of two is very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ll cover shifts by showing you a program that reads an integer entered in
    hexadecimal from the keyboard and stores it as a `long int`. The program reads
    up to eight hexadecimal characters, `0`, `1`, . . . , `f`, each in 8-bit ASCII
    code and representing a 4-bit integer: 0, 1, . . . , 15.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-7](ch16.xhtml#ch16list7) shows the `main` function for this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*convert_hex.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-7: A program to convert hexadecimal input to an* int'
  prefs: []
  type: TYPE_NORMAL
- en: In “Your Turn” [exercise 14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1),
    you designed the `read_str` function to limit the number of characters it will
    store in the `char` array passed to it. If the user enters more than eight characters,
    `read_str` will terminate the string with a `NUL` character and discard the excess
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-8](ch16.xhtml#ch16list8) shows the header file for the `hex_to_int`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*hex_to_int.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-8: The header file for the* hex_to_int *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The header file declares the `hex_to_int` function, which takes two pointers.
    The `char` pointer is the input, and the `long int` pointer is the location for
    the primary output. The `hex_to_int` function also returns an `int` that gives
    the number of characters it converted.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-9](ch16.xhtml#ch16list9) shows the definition of the `hex_to_int`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*hex_to_int.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-9: The* hex_to_int *function in C*'
  prefs: []
  type: TYPE_NORMAL
- en: Our program first sets the 32-bit output to `0` ❶. Then, starting with the most
    significant hexadecimal character (the first one entered by the user), the program
    converts each 8-bit ASCII code to its corresponding 4-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at [Tables 2-4](ch02.xhtml#ch2tab4) and [2-5](ch02.xhtml#ch2tab5) in
    [Chapter 2](ch02.xhtml), we see that the ASCII codes for the numeric characters
    range from `0x30` to `0x39`, and for the lowercase alphabetic characters, they
    range from `0x61` to `0x66`. Subtracting this `0x27` gap from the alphabetic characters
    gives us the bit patterns `0x30`, `0x31`, . . . , `0x39`, `0x3a`, . . . , `0x3f`
    for the characters entered ❷. Of course, the user may enter uppercase alphabetic
    characters, which range from `0x41` to `0x46`. Subtracting `0x27` then gives us
    `0x30`, `0x31`, . . . , `0x39`, `0x1a`, . . . , `0x1f`. Each hexadecimal character
    represents 4 bits, and if we look at the low-order 4 bits after subtracting `0x27`,
    they are the same whether the user enters lowercase or uppercase alphabetic characters.
    We can convert the character code to a 4-bit integer by masking off the upper
    4 bits with the bit pattern `0x0f` using `&`, the C bitwise AND operator ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shift all the bits in the accumulated value 4 bits to the left to make
    room for the next 4 bits represented by the hexadecimal character ❹. The left
    shift leaves `0`s in the four least significant bit positions, so we can copy
    the 4 bits in `current` into these positions using `|`, the bitwise OR operator
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The type of the `current` variable is `char`, and the type of `result` is `int`.
    In C, the width of a narrower value will automatically be extended to match the
    width of a wider value for arithmetic and logic operations ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the assembly language the compiler generates for the `hex_to_int`
    function, shown in [Listing 16-10](ch16.xhtml#ch16list10).
  prefs: []
  type: TYPE_NORMAL
- en: '*hex_to_int.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-10: The compiler-generated assembly language for the C function
    in [Listing 16-9](ch16.xhtml#ch16list9)*'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler uses the `ldrb` instruction to load characters into a `w` register
    ❶. This sets bits 8 through 31 to `0`, effectively typecasting the 8-bit `char`
    to a 32-bit `int`. This would have occurred even without our explicit type-casting
    in the C code in [Listing 16-9](ch16.xhtml#ch16list9), but the explicit typecasting
    more clearly shows our intent and doesn’t affect the efficiency of our code.
  prefs: []
  type: TYPE_NORMAL
- en: The mask in this algorithm is four sequential `1`s, so the immediate data form
    of the `and` instruction can be used ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see a new instruction here, `lsl` ❸. As you can probably guess, this instruction
    shifts the value in `x0` 4 bits to the left and loads the result into `x1`. Let’s
    look at some common shift instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: lsl**—Logically shift left immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`lsl w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the left,
    with `0`s in the vacated bits, and loads the result into `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`lsl x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the left,
    with `0`s in the vacated bits, and loads the result into `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: lsr**—Logically shift right immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`lsr w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    with `0`s in the vacated bits, and loads the result into `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`lsr x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    with `0`s in the vacated bits, and loads the result into `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: asr**—Arithmetic shift right immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`asr w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    copying the highest-order bit into the vacated bits, and loads the result into
    `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`asr x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    copying the highest-order bit into the vacated bits, and loads the result into
    `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: ror**—Rotate right immediate**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`ror w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    copying the low-order bits into the vacated high-order bits, and loads the result
    into `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ror x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    copying the low-order bits into the vacated high-order bits, and loads the result
    into `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll take a similar approach to writing the hexadecimal-to-integer conversion
    program in assembly language as I did for the earlier case conversion C program.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll start the design for our `convert_hex` program with a diagram of the stack
    frame for the `main` function, shown in [Figure 16-2](ch16.xhtml#ch16fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg366_Image_284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: The stack frame for the* convert_hex *program*'
  prefs: []
  type: TYPE_NORMAL
- en: With this diagram, the assembly language design of the `main` function is straightforward,
    as shown in [Listing 16-11](ch16.xhtml#ch16list11).
  prefs: []
  type: TYPE_NORMAL
- en: '*convert_hex.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-11: The assembly language* main *function for converting a hex
    value to an* int'
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing new in this `main` function. In addition to the 16 bytes for
    saving the `fp` and `lr` registers and 4 bytes for the `int`, we need to allocate
    9 bytes in our stack frame for the hexadecimal text string, giving a frame size
    of at least 29 bytes. The frame size must be a multiple of 16 to keep the stack
    pointer properly aligned, so we use 32 ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use registers for the variables in our assembly language version of `hex_to_int`.
    Our stack frame will be simple, so we won’t need a diagram to design it. Figure
    16-12 shows our function.
  prefs: []
  type: TYPE_NORMAL
- en: '*hex_to_int.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-12: The assembly language version of the* hex_to_int *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Shifts are good for multiplying and dividing by powers of two, but we also need
    to be able to multiply and divide by other numbers. We’ll look at multiplying
    and dividing by arbitrary integers in the next two sections, deferring consideration
    of fractional and floating-point values until [Chapter 19](ch19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 16.4     Modify the C `main` function in [Listing 16-7](ch16.xhtml#ch16list7)
    so it displays the number of hexadecimal characters converted. Use the assembly
    language `hex_to_int` function in [Listing 16-12](ch16.xhtml#ch16list12) for the
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5     Write a program in assembly language that converts octal input to a
    `long int`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplication**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I’ll cover multiplication by integers that are not powers of
    two. It can be done using loops, but most general-purpose CPUs include multiply
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s modify the C program in [Listings 16-7](ch16.xhtml#ch16list7) to [16-9](ch16.xhtml#ch16list9)
    to convert decimal number text strings into unsigned integers. When converting
    from hexadecimal text strings, we shifted the accumulated value 4 bits to the
    left, thus multiplying it by 16\. We’ll use the same algorithm for converting
    decimal text strings, but this time we’ll multiply by 10 instead of 16.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 16-13](ch16.xhtml#ch16list13) to [16-15](ch16.xhtml#ch16list15) show
    the C program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*convert_dec.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-13: A program to convert decimal input to an* int'
  prefs: []
  type: TYPE_NORMAL
- en: This `main` function is very similar to the one for converting hexadecimal input
    to an `int`, but the maximum number of characters in an `int` is 10\. We need
    to set `MAX` to 11 characters to allow for the possible + or – sign preceding
    the integer ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-14](ch16.xhtml#ch16list14) shows the header file for the `dec_to_int`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*hex_to_int.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-14: The header file for the* dec_to_int *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header file declares the `dec_to_int` function, which takes two pointers:
    the `char` pointer is the input, and the `int` pointer is the location for the
    primary output. The `dec_to_int` function also returns an `int` that gives the
    number of characters it converted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-15](ch16.xhtml#ch16list15) shows the definition of the `dec_to_int`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*dec_to_int.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-15: The* dec_to_int *function in C*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is check for a possible + or – sign preceding
    the number. If there’s a – sign, we set the `negative` flag to `true` ❷. It’s
    typical for users to enter positive numbers without a + sign, but we still need
    to increment the pointer to the first numerical character in the string if there
    is one ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The `RADIX` constant is not a power of two, so we can’t do multiplication with
    a simple left shift ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The `string_ptr` variable points to a `char` ❶. The `char` is being masked and
    added to `result`, which is an `int`. Most compilers will promote a `char` value
    when it’s assigned to an `int` variable, but I prefer to explicitly typecast the
    value ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how the compiler does the multiplication by 10\. This is shown
    in [Listing 16-16](ch16.xhtml#ch16list16).
  prefs: []
  type: TYPE_NORMAL
- en: '*dec_to_int.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-16: The compiler-generated assembly language for the* dec_to_int
    *function in [Listing 16-15](ch16.xhtml#ch16list15)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiplication instruction usually takes longer for the CPU to execute,
    so the compiler used a combination of shifting and adding to multiply `result`
    by 10 ❶. This four-instruction sequence is equivalent to the following C statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The two multiplications in this statement are by powers of two, so they are
    done by simple left shifts.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the arithmetic in this conversion algorithm is unsigned. We checked
    for a – sign at the beginning of the number string, and we negate the converted
    result at the end if there was a – sign ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Using shifts and adds to multiply is limited. To see how the multiplication
    instructions work, we’ll use one to rewrite our decimal conversion program in
    assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The A64 architecture has over a dozen variations of multiply instructions. I’ll
    show you only a few of them in this book; you can read about the others in the
    manual.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) shows the stack frame design for our assembly
    language version of the `main` function of the program to convert a decimal text
    string to an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg373_Image_285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: The stack frame for the* convert_dec *program*'
  prefs: []
  type: TYPE_NORMAL
- en: Our assembly language version of the `main` function is similar to the C version;
    it’s shown in [Listing 16-17](ch16.xhtml#ch16list17).
  prefs: []
  type: TYPE_NORMAL
- en: '*convert_dec.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-17: A program to convert decimal values to* int *s in assembly
    language*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-18](ch16.xhtml#ch16list18) shows our assembly language version
    of `dec_to_int`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*dec_to_int.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-18: The* dec_to_int *function in assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a shift-and-add algorithm to multiply by 10, we’re using the
    `mul` instruction ❶. Let’s look at some variations of this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: mul**—Multiply register**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`mul w`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and stores
    the result in `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mul x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and stores
    the result in `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: When multiplying two *n*-bit integers, the product can be up to 2*n* bits wide.
    Without offering a formal proof here, you can probably be convinced by considering
    the largest 3-bit number, `111`. Add `1` to get `1000`. From `1000 * 1000 = 1000000`,
    we can conclude that `111 * 111 <= 111111`. More precisely, `111 * 111 = 110001`.
  prefs: []
  type: TYPE_NORMAL
- en: If the result of the `mul` instruction exceeds the width of the destination
    register, the high-order bits are lost. For example, if `w2` contains `0xcccccccc`
    and `w1` contains `0x00000002`, then `mul w0, w1, w2` will give `0x0000000099999998`
    in the `x0` register. The correct result is `0x0000000199999998` if we’re treating
    these values as unsigned integers and `0xffffffff99999998` if we’re treating these
    values as signed. But when an instruction writes to the `w` portion of a register,
    the high-order 32 bits of that register are set to `0`. Thus, the `mul` instruction
    yields an incorrect result if the product of two 32-bit integers is not within
    the range 0*≤ product≤* 4,294,967,295 if we’re using unsigned integers and –2,147,483,648*≤
    product≤* +2,147,483,647 if we’re using signed integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with this size problem, the A64 architecture includes two multiplication
    instructions that use a 64-bit destination register for the case when the result
    of multiplying two 32-bit numbers exceeds the range of 32 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: umull**—Unsigned multiply long**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`umull x`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and loads
    the result in `x`d. If the magnitude of the result doesn’t take up the full 64
    bits of `x`d, the unoccupied high-order bits are filled with `0`s.'
  prefs: []
  type: TYPE_NORMAL
- en: smull**—Signed multiply long**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`smull x`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and loads
    the result in `x`d. If the magnitude of the result doesn’t take up the full 64
    bits of `x`d, the unoccupied high-order bits are each filled with a copy of the
    highest-order bit of the result, thus providing sign extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our example, if `w2` contains `0xcccccccc` and `w1` contains
    `0x00000002`, then `umull x0, w1, w2` will give `0x0000000199999998` in `x0` and
    `smull x0, w1, w2` will give `0xffffffff99999998`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’re using 64-bit `long int`s and cannot prove that the result of the multiplication
    can never exceed 64 bits, the A64 architecture includes two multiplication instructions
    that will give the high-order 64 bits when multiplying two 64-bit numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: umulh**—Unsigned multiply high**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`umulh x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and loads
    the high-order 64 bits of the result into `x`d with zero extension.'
  prefs: []
  type: TYPE_NORMAL
- en: smulh**—Signed multiply high**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`smulh x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and loads
    the high-order 64 bits of the result into `x`d with sign extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the multiplication of two 64-bit integers requires two instructions.
    We would use the following two instructions if we were treating two integers in
    `x0` and `x1` as unsigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would use the following two instructions if we were treating two integers
    in `x0` and `x1` as signed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the result is a 128-bit integer with the high-order 64 bits in
    register `x2` and the low-order 64 bits in `x3`.
  prefs: []
  type: TYPE_NORMAL
- en: The multiply instructions don’t affect the condition flags in the `nzcv` register.
    We need to carefully analyze our algorithms for all possible values and use the
    appropriate instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll cover division, the inverse of multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 16.6     Write a `dec_to_uint` function in assembly language that converts an
    unsigned decimal number from its text string format to its `unsigned int` format.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7     I asserted that the C statement `result = 2 * ((4 * result) + result);`
    is equivalent to the `result = RADIX * result`; statement in [Listing 16-15](ch16.xhtml#ch16list15).
    Make that change in [Listing 16-15](ch16.xhtml#ch16list15) and compare the compiler-generated
    assembly language with that in [Listing 16-16](ch16.xhtml#ch16list16).
  prefs: []
  type: TYPE_NORMAL
- en: '**Division**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When multiplying two *n*-bit numbers, we were concerned about the result being
    2*n* bits wide. In division, the quotient will never be wider than the dividend,
    but division takes much longer than multiplication. In this section, you’ll learn
    about an algorithm that can speed up division when the divisor is a constant.
    Integer division can give a remainder, which may also need to be computed.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with a C function that converts an `int` to the numerical text string
    it represents, the inverse of the earlier `dec_to_int` function.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our `main` function will read an integer from the user, subtract 123 from it,
    and show the result. Our subfunction, `int_to_dec`, will use a division algorithm
    to convert a 32-bit `int` to the text string that represents it so that the `main`
    function can display the result. [Listings 16-19](ch16.xhtml#ch16list19) through
    [16-21](ch16.xhtml#ch16list21) show the complete program.
  prefs: []
  type: TYPE_NORMAL
- en: '*sub_123.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-19: A program to subtract 123 from an* int'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function for this program is quite simple. We use the assembly language
    version of `dec_to_int` in [Listing 16-18](ch16.xhtml#ch16list18) to convert the
    user’s input to an `int`. We then subtract 123 from the `int`, convert the resulting
    number to its text string representation, and display the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-20](ch16.xhtml#ch16list20) shows the header file for the `int_to_dec`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*int_to_dec.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-20: The header file for the* int_to_dec *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The header file declares the `int_to_dec` function. The `int` is the input,
    and the `char` pointer is the location for the primary output. The `int_to_dec`
    function also returns an `int` that gives the number of characters in the output
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-21](ch16.xhtml#ch16list21) shows the definition of the `int_to_dec`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*int_to_dec.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-21: The* int_to_dec *function in C*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm we’re using to find the characters that represent the `int` in
    decimal involves the repeated integer division of the `int` by 10\. The `%` operator
    computes the remainder from the division ❹. For positive integers, the remainder
    will be a 32-bit `int` in the range 0 through 9, or `0x00000000` through `0x00000009`,
    which is the value of the lowest-order decimal digit.
  prefs: []
  type: TYPE_NORMAL
- en: However, for negative integers, the remainder will be an `int` in the range
    0 through –9, or `0x00000000` through `0xfffffff7`. The negative values in this
    range require a different algorithm to convert them to their corresponding ASCII
    numeric character. The solution we’re using here is to negate an input negative
    integer, prepend the resulting text string with a – sign, and convert the positive
    result ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works for all but one 32-bit negative number: –2,147,483,648\. There is
    no 32-bit +2,147,483,648 in two’s complement format; negating –2,147,483,648 gives
    –2,147,483,648\. Our solution is to convert the negated `int` to an `unsigned
    int` ❸. This doesn’t change the bit pattern of the value, `0x80000000`, but it
    tells the compiler to use unsigned `%` and `/` operations. So, for 2,147,483,648,
    the `working % RADIX` operation will give us `0x00000008`.'
  prefs: []
  type: TYPE_NORMAL
- en: We convert the `unsigned int` from the `%` operation to a `char` with `(char)`,
    the *cast operator* ❹. The parentheses are part of the syntax for a cast operator.
    Then, we use a bitwise OR operation to convert the `char` to its corresponding
    numeric character in ASCII code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when using a cast operator to convert the type of a value. We’re
    converting from a 32-bit value to an 8-bit one, which may cause a loss of information.
    In this case, we know the information will be encoded in 4 bits, so the conversion
    is safe.*'
  prefs: []
  type: TYPE_NORMAL
- en: Since this algorithm works from right to left, the characters are stored in
    reverse order. So, we need to reverse the order of the text string for the calling
    function ❺. Storing the `NUL` character first ❷ provides a way to know when the
    entire text string has been completely copied in reverse order ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the assembly language generated by the compiler, shown in
    [Listing 16-22](ch16.xhtml#ch16list22).
  prefs: []
  type: TYPE_NORMAL
- en: '*int_to_dec.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-22: The compiler-generated assembly language for the* int_to_dec
    *function in [Listing 16-21](ch16.xhtml#ch16list21)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C algorithm involves division by 10, but the compiler uses a `umull` instruction
    to perform the remainder (`%`) operation ❷. This is because division takes much
    more time than multiplication. Since we’re dividing by a constant, the compiler
    uses the following arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg382_Image_286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The compiler uses *n* = 35, giving the constant 2^(35)/10 = 3,435,973,836.8\.
    Rounding this to the nearest integer gives 3,435,973,837 = `0xcccccccd` ❶. After
    multiplying the `working` integer by this constant, the algorithm shifts the result
    35 bits to the right to divide by 2^(35).
  prefs: []
  type: TYPE_NORMAL
- en: The compiler then uses the shift-and-add algorithm to multiply this quotient
    by 10 ❸. Subtracting the result from the original dividend leaves us with the
    remainder ❹, which is converted to the corresponding ASCII character ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler implements the `/` operation with the same multiply-and-shift algorithm
    that it used for the `%` operation ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiplication and shifts to divide is limited. To see how the division
    instructions work, we’ll use a divide instruction for our assembly language version
    of the `int_to_dec` function.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We didn’t look at the compiler-generated assembly language for the `main` function
    in the C version of our `sub_123` program ([Listing 16-19](ch16.xhtml#ch16list19)).
    It’s similar to our assembly language version, which is shown in [Listing 16-23](ch16.xhtml#ch16list23).
  prefs: []
  type: TYPE_NORMAL
- en: '*sub_123.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-23: The assembly language version of the* main *function for the*
    sub_123 *program*'
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t anything new in the `main` function; we can use the same stack frame
    design from [Figure 16-3](ch16.xhtml#ch16fig3) ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-24](ch16.xhtml#ch16list24) shows our assembly language version
    of the `int_to_dec` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*int_to_dec.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-24: The assembly language version of the* int_to_dec *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a leaf function, we don’t need a frame record, but we do need
    space on the stack for storing the text string locally as we generate it in reverse
    order ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using a multiply-and-shift algorithm like the compiler did, we use
    the `udiv` instruction to divide by 10 ❷. This gives us the quotient in the `w4`
    register. Then, we use the `msub` instruction to multiply the quotient (register
    `w4`) by RADIX (register `w2`) and subtract that product from the dividend (register
    `w1`), leaving the remainder in register `w5` ❸. Since we already have the quotient
    in register `w4`, we can use that for the next iteration of this loop ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 16-24](ch16.xhtml#ch16list24), we see two new instructions: `msub`
    and `udiv`. I’ll also describe `sdiv` here:'
  prefs: []
  type: TYPE_NORMAL
- en: msub**—Multiply and subtract**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`msub w`d `, w`s1 `, w`s2 `, w`s3 multiplies `w`s1 by `w`s2, subtracts the
    value in `w`s3 from the product, and loads the result in `w`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`msub x`d `, x`s1 `, x`s2 `, x`s3 multiplies `x`s1 by `x`s2, subtracts the
    value in `x`s3 from the product, and loads the result in `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: udiv**—Unsigned divide**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`udiv w`d `, w`s1 `, w`s2 divides `w`s1 by `w`s2 and stores the result in `w`d.
    It treats all values as unsigned numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`udiv x`d `, x`s1 `, x`s2 divides `x`s1 by `x`s2 and stores the result in `x`d.
    It treats all values as unsigned numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: sdiv**—Signed divide**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`sdiv w`d `, w`s1 `, w`s2 divides `w`s1 by `w`s2 and stores the result in `w`d.
    If `w`s1 and `w`s2 are of the same sign, the value in `w`d will be positive. If
    they are of opposite signs, the value in `w`d will be negative.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sdiv x`d `, x`s1 `, x`s2 divides `x`s1 by `x`s2 and stores the result in `x`d.
    If `x`s1 and `x`s2 are of the same sign, the value in `x`d will be positive. If
    they are of opposite signs, the value in `x`d will be negative.'
  prefs: []
  type: TYPE_NORMAL
- en: The divide instructions don’t affect the condition flags in the `nzcv` register.
    They don’t even give an error if you divide by zero; they load 0 into the destination
    register. You need to carefully analyze your algorithms for all possible values
    to make sure you never divide by zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 16.8     Write the two functions `put_int` and `get_int` in assembly language.
    The `put_int` function takes one argument, a 32-bit signed integer, and displays
    it on the screen. The `get_int` function returns a 32-bit signed integer, which
    it reads from keyboard input. Write a `main` function in C to test `put_int` and
    `get_int`. We’ll be using `put_int` and `get_int` in subsequent chapters for displaying
    and reading integers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9     Write the two functions `put_uint` and `get_uint` in assembly language.
    The `put_uint` function takes one argument, a 32-bit unsigned integer, and displays
    it on the screen. The `get_uint` function returns a 32-bit unsigned integer, which
    it reads from keyboard input. Use the `dec_to_uint` function from [exercise 16.6](ch16.xhtml#ch16exe6)
    on [page 348](ch16.xhtml#ch16you1), and write the function `uint_to_dec`. Write
    a `main` function in C to test `put_uint` and `get_uint`. We’ll be using `put_uint`
    and `get_uint` in subsequent chapters for displaying and reading integers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10   Write a program in assembly language that allows a user to enter two
    signed decimal integers. The program will add, subtract, multiply, and divide
    the two integers. It will display the sum, difference, product, quotient, and
    remainder resulting from these operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bitmasking** We can use bitwise logic instructions to directly change bit
    patterns in variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit shifting** Bits in variables can be shifted left or right, effectively
    multiplying or dividing by multiples of 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplication** The multiply instructions allow us to perform signed or
    unsigned multiplication. Multiplying large 64-bit values requires two instructions
    for the 128-bit result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster multiplication** When multiplying by a constant, a combination of
    adding and shifting can be faster than a multiply instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Division** The divide instructions allow us to perform signed or unsigned
    division.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster division** When dividing by a constant, a combination of multiplying
    and shifting can be faster than a divide instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting numbers between binary storage and character display** Arithmetic
    operations are easier when numbers are stored in the binary system, but keyboard
    input and screen display use the corresponding character format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now covered ways to organize program flow and perform arithmetic or logic
    operations on data items. In the next chapter, we’ll explore two of the most fundamental
    ways to organize data: arrays and records.'
  prefs: []
  type: TYPE_NORMAL
