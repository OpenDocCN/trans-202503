<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_3"/><strong><span class="big">1</span><br/>THE BASICS OF ANDROID SECURITY</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentsa">To understand Android malware, one has to understand the Android operating system’s security model. In particular, one must recognize the malware specimens that operate within the boundaries of this model and those that try to break out of it. This chapter introduces the basic concepts of Android security and malware that make this possible.</p>&#13;
<h3 class="h3" id="ch01lev1"><strong>The Android Security Model</strong></h3>&#13;
<p class="noindent">Long before the first malware was uploaded to Google Play, the Android operating system and security teams made several design decisions to help protect users from malware. For example, they reused the Linux user account system to isolate Android applications from each other, a choice that made it very hard for applications to maliciously interact with other apps or steal their data from the filesystem. Any malware that wanted to do so had to degrade device security using rooting exploits or other privilege escalation techniques of similar rarity. Likewise, the introduction of the <span epub:type="pagebreak" id="page_4"/>app permission system proved a big step up from older operating systems, as it gave users more fine-grained control over what sensitive data and functionality applications were allowed to access.</p>&#13;
<p class="indent">When the first malware was found on Google Play, the threat landscape changed. Android was so popular by that point that malware developers were making money via abusive Android applications, and those who might previously have developed malware for other platforms started taking a serious look at Android.</p>&#13;
<p class="indent">Responding to these new threats, the Android Security team focused on a defense-in-depth approach. Google developed critical pieces of the Android ecosystem—notably Google Play, the operating system, and the phone hardware (the Nexus and Pixel devices)—putting it in a strong defensive position. As new attacks appeared, the Android Security team was able to counter them by hardening the Android platform, reforming the rules of Google Play, and improving the application scanner that finds malicious functionality in the apps uploaded by Android developers.</p>&#13;
<p class="indent">Google built an <em>Android security model</em> that gets updated with each Android version, using a multilayered approach where each layer of defense tries to stop an attack. Even if one layer cannot completely stop an attack, the malware developer will have to find ways to circumvent one or more additional protection layers, which increases the cost and reduces the likelihood of abuse. The following sections explain these layers and their interactions.</p>&#13;
<h4 class="h4" id="ch01lev1sec1"><strong><em>Application Isolation</em></strong></h4>&#13;
<p class="noindent">The first layer of the Android security model is <em>application isolation</em>. We mentioned that, since the very first version of Android, the operating system has used the Linux user account system to isolate apps and processes from each other. Each app is assigned a new Linux user ID (UID) without access to the private data or process memory of other apps.</p>&#13;
<p class="indent">Over time, Google enhanced this sandboxing model with other technologies. Android 4.3 (Jelly Bean) was the first to use Security-Enhanced Linux, more commonly known as SELinux. <em>SELinux</em> is a Linux kernel module used to configure access control security policies for different parts of the system. Although notoriously difficult to deploy and rarely enabled by default in other versions of Linux, it turns out that SELinux is uniquely powerful, making its implementation one of the most important Android security features protecting against privilege escalation malware. Even malware that uses rooting exploits to gain elevated privileges is bound by its access controls.</p>&#13;
<p class="indent">Process isolation was improved over time, too. For example, Android 10 introduced <em>scoped storage</em>. Previously, all apps on an Android device shared access to the device’s external storage, so a file written by one app could be read by any other app on the device. If an app wanted to store sensitive information, it was supposed to use the internal storage system, where every app had its own protected space. Of course, many apps misbehaved and stored sensitive information in external storage. Spyware could easily access <span epub:type="pagebreak" id="page_5"/>this information, and other apps could accidentally read, write, or delete it. To protect app data, scoped storage introduced access mechanisms similar to those used for internal storage, and now every app can safely store sensitive data in external storage without risking data theft or manipulation by other apps.</p>&#13;
<p class="indent">Android 11 introduced additional features to isolate apps from each other. Prior to Android 11, an app on a device could find information about other installed apps. This allowed the app to make assumptions about a user’s personal life. Android 11 severely restricted this ability, known as <em>package visibility</em>, in the hopes that apps would no longer be able to identify potentially sensitive details about the user.</p>&#13;
<h4 class="h4" id="ch01lev1sec2"><strong><em>Attack Surface Reduction</em></strong></h4>&#13;
<p class="noindent">Application isolation doesn’t work against attacks that can break out of the Linux user space or bypass SELinux. The second layer of the Android security model is <em>attack surface reduction</em>, or the practice of minimizing a potential attacker’s access to code, APIs, services, or other parts of an app.</p>&#13;
<p class="indent">There are many ways to reduce one’s attack surface. The most obvious is to remove unnecessary code, system modules, open ports, or APIs exposed to hackers; it’s easier to secure a system that has a small number of exposed components than one that has many. Similarly, reducing code complexity and size is a good secure software development practice. Complexity makes code hard to understand, difficult to secure, and easy to exploit, as the number of edge cases that a programmer has to consider becomes unwieldy. Less code means fewer opportunities for programming errors and fewer potential attack points.</p>&#13;
<p class="indent">If reducing complexity is not possible, making code inaccessible to exploits is nearly as good a strategy and is an approach the Android team has taken many times over the years. For example, in response to a series of vulnerabilities collectively known as Stagefright, the Android Security team completely refactored the vulnerable <span class="literal">mediaserver</span> component in Android 7.0 (Nougat) to minimize the number of exposed APIs. Additionally, risky code was moved into stronger custom sandboxes, and functionality that was not needed, like <em>execmem</em>, a dangerous SELinux permission to mark memory pages as executable, was removed. The 2016 Android Security blog post “Hardening the Media Stack” provides more details.</p>&#13;
<p class="indent">Another attack surface reduction technology that the Android Security team added was <em>seccomp</em>, introduced in Android 8.0 (Oreo). Short for <em>secure computing mode</em>, seccomp is a Linux technology that acts as a firewall between user-level processes and the kernel. Using filter rules written in Berkeley Packet Filter (BPF), it can block attempts by a user-level process to execute certain system calls and can also terminate user-level processes. Having seccomp enabled in Android removes system calls that would otherwise be available to apps during a privilege escalation attempt.</p>&#13;
<p class="indent">Android 9.0 (Pie) significantly reduced the potential attack surface for malicious apps yet again by disallowing apps from accessing internal Android API methods through reflection or native code. Going forward, <span epub:type="pagebreak" id="page_6"/>only methods belonging to the public Android API remained accessible to apps. Besides improving app compatibility across Android versions by forcing apps to go through official APIs, this change was also important for security. Before this limitation was introduced, Android app developers were occasionally able to find ways to invoke internal APIs through private methods that bypassed the permission system and other restrictions.</p>&#13;
<p class="indent">Attack surface reduction can also take a completely different form. For example, according to statistics compiled by the Android Security team, the most exploited Android vulnerabilities to date have relied on memory corruption. Recent versions of Android have started shipping components written in Rust, a memory-safe programming language that will hopefully reduce the number of memory corruption bugs.</p>&#13;
<h4 class="h4" id="ch01lev1sec3"><strong><em>Exploit Mitigation</em></strong></h4>&#13;
<p class="noindent">Android is a complex, general-purpose operating system with millions of lines of code. No matter how much of it is deleted, made inaccessible, or sandboxed, there will always be opportunities for vulnerabilities to appear. Thus, many security teams operate under the assumption that every attacker will get lucky once; getting lucky twice, however, is less likely. That’s a simplified justification for Android’s many <em>exploit mitigations</em>, which attempt to make it harder (or impossible) for an attack to successfully compromise a system. The official Android Security website maintains a detailed list of the security enhancements introduced since Android 1.5 at <a href="https://source.android.com/security/enhancements"><em>https://source.android.com/security/enhancements</em></a>.</p>&#13;
<p class="indent">Early versions of Android focused on adding exploit mitigation techniques as a way to catch up with existing defenses in other operating systems. Before Android 4.0 (Ice Cream Sandwich), they added defenses like address space layout randomization (ASLR), hardware-based No eXecute (NX), and hardening techniques for memory allocation and deallocation.</p>&#13;
<p class="indent">The addition of these mitigation techniques meant that writing traditional exploit shellcode intended to run in a controlled part of memory became very difficult. Android’s memory layout became unpredictable, and finding executable sections of memory became rarer. To overcome that, attackers started chaining exploits that bypassed these defenses one at a time. On modern Android, such exploit chains are complex and often take months to develop.</p>&#13;
<h4 class="h4" id="ch01lev1sec4"><strong><em>Device Integrity</em></strong></h4>&#13;
<p class="noindent"><em>Device integrity</em> tries to ensure that a device is in its original intended state. In particular, it aims to guarantee that attackers have not planted backdoors or other harmful code in critical parts of the device, like its operating system. After a hacker bypasses all the defenses in the previous layers, they would often like to gain a permanent foothold in the system. Over the years, Android has made this harder and harder.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_7"/>Android 4.4 (KitKat) added a technology called Verified Boot to stop malicious actors from modifying the bootloader. At its core, Verified Boot makes sure that each component of the device boot process has its integrity verified before it is executed. If any part of the boot process fails to verify, users are warned that their device has been manipulated and its security can’t be assured.</p>&#13;
<p class="indent">Full-disk encryption was enabled as an option in Android 5.0 (Lollipop) and became mandatory in Android 6.0 (Marshmallow). Android 7.0 (Nougat) additionally introduced file-based encryption, an improvement over full-disk encryption that allows different files on disk to be encrypted with different keys. File-based encryption became a requirement in Android 10. While not defenses against exploits running on a device, full-disk encryption and file-based encryption do help protect against attackers that have physical access to the device and try to read data from or manipulate data on the disk.</p>&#13;
<h4 class="h4" id="ch01lev1sec5"><strong><em>Permissions</em></strong></h4>&#13;
<p class="noindent">The fifth layer of the Android security model is <em>permissions</em>, Android’s user-facing consent model for controlling access to sensitive system resources and data. For every sensitive operation, an app has to ask the user for consent before the Android operating system allows the operation to proceed. For example, if an app wants to read information from the contact list or send a text, it needs to get the user’s permission first.</p>&#13;
<p class="indent">In early versions of Android, all permissions an app wanted to use had to be granted before installing the app. Users who didn’t want to grant all the requested permissions were unable to install the app, which was inconvenient and a common source of abuse and user complaints. Starting in Android 6.0 (Marshmallow), Android implemented a runtime permission system, where apps asked for permissions while they were running. This change improved app control, as users could now grant or deny individual, more granular permissions for sensitive operations. For example, if a user was comfortable with an app sending texts but not with it accessing their contact list, they could grant the text permission while denying the contact list permission.</p>&#13;
<p class="indent">The runtime model also allowed apps to ask for permissions only when needed. If a user never tried to use an app for a sensitive operation, a well-written app would never ask for the related permissions. That improved user trust in well-developed apps.</p>&#13;
<p class="indent">Some permissions available to Android apps are particularly sensitive and cannot be granted through the default permission dialogs. For example, if an app wants to install other apps, the user must first go to the device settings and grant the app this permission. Likewise, if an app wants to use the Accessibility API, an API that changes parts of Android’s security model to better support users with disabilities, the user has to navigate through a series of warning dialogs first.</p>&#13;
<h4 class="h4" id="ch01lev1sec6"><span epub:type="pagebreak" id="page_8"/><strong><em>Security Updates</em></strong></h4>&#13;
<p class="noindent">The Android security model includes regular <em>security updates</em>. The faster these updates are shipped to devices and installed by users, the less time attackers have to exploit any discovered vulnerabilities.</p>&#13;
<p class="indent">Early versions of Android were tedious to update, no matter how small a security update was. Updating processes and infrastructure were not yet mature, causing long delays between when the code was patched and when fixes were actually deployed to devices. Early updates were also not user-friendly. During the update process, users were often unable to use their phones for 10 minutes or more, lowering their willingness to install security updates.</p>&#13;
<p class="indent">Over time, the Android operating system has made system updates much more pleasant for both users and device manufacturers. Updates now happen in the background during regular device use, and users have to reboot their devices only to complete the process. The architecture of the update process has also been refined. Many critical components that used to be updated through the system update process have been rewritten as standalone apps that can be updated through the normal Google Play app update process. One of the most important examples is the default WebView component used to parse and render HTML content. The code complexity of the parsing and rendering process makes WebView a prime attack target for hackers. Nowadays, if a WebView vulnerability is reported to the Android Security team or if an exploit is discovered in the wild, updating the Web-View component can happen in days rather than months.</p>&#13;
<p class="indent">This change in architecture to allow independent updates of core components also made its way to the core Android operating system. In Android 8.0 (Oreo), Google announced Project Treble, which introduced an abstraction-layer mechanism to separate the operating system from modifications and extensions added by device manufacturers. The goal of Treble was to deliver updates for the core operating system faster by removing device manufacturers from the update process: manufacturers would be responsible for updating their additions and modifications separately, at their own pace.</p>&#13;
<p class="indent">Android 9.0 (Pie) and Android 10 further helped original equipment manufacturers update more efficiently through Generic System Images, or GSIs, which sped up the testing of new Android versions, and Project Mainline, which allowed manufacturers to distribute system updates through Google Play. These changes combined made Android 10 the fastest deployed Android version in history, with adoption rates about twice that of Android 9.0 (Pie) and four times that of Android 8.0 (Oreo).</p>&#13;
<h4 class="h4" id="ch01lev1sec7"><strong><em>Add-on Security and Safety Services</em></strong></h4>&#13;
<p class="noindent">The seventh layer of the Android security model involves the add-on security and safety services that run on Google’s infrastructure. Depending on the service, these are available to either app developers or users.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>The Android malware scanner that powers Google Play Protect, Google’s on-device malware detection and warning system, is one of these services. This scanner is continuously fed with app signals and decisions produced by humans and machines to proactively identify and block application-level threats on the device and on Google Play. Users can see the results of malware scans on their devices through the Google Play app or through the device’s security settings.</p>&#13;
<p class="indent">Services for developers take the form of APIs like Safe Browsing and SafetyNet. The Safe Browsing API protects users from malicious websites in Chrome, Firefox, and other browsers that have an integration with Safe Browsing technology. The SafetyNet API allows any application to check many integrity aspects of the device before executing sensitive operations like collecting user credentials or payment information. As these services depend on access to Google’s backend infrastructure, they are only available on Android-certified devices that ship with Google Play and the Google Play Services module.</p>&#13;
<h4 class="h4" id="ch01lev1sec8"><strong><em>Collaboration Across Google</em></strong></h4>&#13;
<p class="noindent">In addition to improving the security and privacy posture of the Android operating system over the years, the Android Security team has worked with other teams at Google to make the platform safer to use.</p>&#13;
<p class="indent">For example, Android Security has collaborated with the team responsible for rolling out new Google Play policies, many of which aim to make it harder for abusive apps to get into Google Play. In May 2017, the team clarified that an app must not download additional code from sources other than Google Play, as this technique continues to be a key malware tactic to bypass the Google Play malware scanners.</p>&#13;
<p class="indent">To give a few other examples, in August 2019 Google Play banned network proxying behavior for non-proxy apps in response to proxy tools selling access to user device resources and networks without user consent. In April 2020, Google Play took a stronger stance on stalkerware by mandating minimum steps that surveillance apps must take to limit their abuse potential. The Google Play Policy team maintains a website at <a href="https://support.google.com/googleplay/android-developer/answer/9934569"><em>https://support.google.com/googleplay/android-developer/answer/9934569</em></a> that lists changes to the Google Play policy since 2016.</p>&#13;
<h4 class="h4" id="ch01lev1sec9"><strong><em>Sideloaded and Preloaded Malware Protection</em></strong></h4>&#13;
<p class="noindent">Even as the Android Security team worked to remove malware from Google Play, it realized that application <em>sideloading</em>, or the installation of applications from sources other than Google Play, was much more dangerous. According to the annually published <em>Android Security Year in Review</em> reports, malware is approximately 7 to 15 times more common outside of Google Play, so focusing on Google Play is not enough to protect the whole Android ecosystem.</p>&#13;
<p class="indent">To defend against sideloaded malware, the Android Security team developed and launched the SafetyNet malware protection system in 2012. This technology, which we mentioned previously, eventually turned into <span epub:type="pagebreak" id="page_10"/>Google Play Protect. SafetyNet ran silently in the background on all Android devices that had the Google Play app. The only interaction users had with SafetyNet was when it detected malware on the device. Because most Android devices never have any malware installed, most users never interacted with SafetyNet.</p>&#13;
<p class="indent">Next, the Android Security team built systems to secure preloaded apps in response to the discovery of malware that had been preloaded on devices by various manufacturers. In particular, the team launched Build Test Suite (BTS) in 2018. BTS scans the system image of all Android-branded devices that come with the usual bundle of Google apps, like Gmail, Google Play, and Google Maps. This scan is done for all manufacturers, regardless of how popular they are. On average, a new device ships with about 400 preloaded apps, and many companies are involved in building, maintaining, and distributing them to the manufacturers. With such a model, and without controls, the users of some new Android devices might be intentionally or unintentionally exposed to problematic apps.</p>&#13;
<h3 class="h3" id="ch01lev2"><strong>The Android Package</strong></h3>&#13;
<p class="noindent">Despite the many security enhancements Google has implemented over the years, malware continues to evolve, affecting many users around the globe. Today, there are millions of Android applications available for download from Google Play, websites, and other app stores. They all use a common file format, namely the <em>Android Package (APK)</em>, and most are written in Java.</p>&#13;
<p class="indent">An APK is essentially a ZIP-compressed archive file that stores the app’s code. Because application class files cannot be executed directly by the Android device’s central processing unit (CPU), they need to be compiled into Android-specific bytecode for execution in the Android Runtime (ART) virtual machine or its predecessor, Dalvik. These virtual machines exist for different hardware architectures, enabling applications to be run on a wide range of devices, including phones, tablets, laptops, watches, home appliances, TVs, car consoles, and more. The APK contains <em>.dex</em> files for ART or Dalvik, as well as <em>.so</em> libraries with code that is compiled to native assembly for specific hardware. It also includes metadata describing the application in a file called <em>AndroidManifest.xml</em> and the app’s electronic certificate, as well as other resources, such as XML code or <em>.png</em> images.</p>&#13;
<p class="indent">Thousands of developers, from individuals to large corporations (including Google), create new APKs daily to update apps with new features, patches, and services. Unfortunately, not all developers play by the rules. Some build applications that can be harmful and abuse Android’s rich API, system resources, permissions, and unpatched vulnerabilities to commit fraud, get access to user data, or steal user credentials.</p>&#13;
<h3 class="h3" id="ch01lev3"><strong>Categories of Android Malware</strong></h3>&#13;
<p class="noindent">The Android Security team at Google has tracked many malware categories over the years. An application that exhibits the behavior of at least one of <span epub:type="pagebreak" id="page_11"/>the following categories is considered malware, regardless of whether the developer meant to include harmful code in the app, and will be flagged as such by Android Security team members and the malware detection platform. It is important to mention that an application can in practice present multiple harmful or malicious behaviors and therefore be classified in more than one category.</p>&#13;
<p class="indent">Many malware categories share common characteristics. We can say that, in general, malware will often try to (1) avoid detection by hiding its malicious functionality from scanners and security analysts, (2) remain installed and avoid removal by the user or by security software, and (3) make money directly or indirectly, for example by collecting and selling user data, installing other apps, artificially generating clicks on ads, and abusing systems or networks reachable from the device.</p>&#13;
<p class="indent">The following sections describe malware categories that have an impact on the Android ecosystem and its users.</p>&#13;
<h4 class="h4" id="ch01lev1sec10"><strong><em>Denial of Service</em></strong></h4>&#13;
<p class="noindent"><em>Denial of service (DoS)</em> refers to a compromise of the availability of a device, system, or service. A DoS attack can be launched, for example, by exploiting a system integrity issue, like a stack or heap memory corruption bug, that makes the system crash or by overwhelming the system with a large number of requests than it has the resources to handle. In an attempt to process the requests, it might shut down or at least become unresponsive to new requests for some time.</p>&#13;
<p class="indent">The consequences of a DoS attack can be severe. For example, in the case of systems that receive online orders or payments, any downtime might directly affect the business’s bottom line. Recovery from a DoS attack might also be costly, as it could require system upgrades, patching, new protection features and tools, additional capacity, and so on. For critical infrastructure like hospitals, the food supply chain, and utilities, a DoS attack might not only cause economic damage but also large-scale public safety issues.</p>&#13;
<p class="indent">When it comes to Android, the primary DoS concern is the possibility that a large number of devices could become an abuse vehicle for targets selected by an attacker. Some DoS attacks are carried out without a user’s knowledge; in many cases, the user’s device is added to a <em>botnet</em>, or a set of devices under the control of a particular hacker, whose goal is to execute a <em>distributed denial-of-service (DDoS)</em> attack. In such an attack, a large number of devices that have the same malicious app installed might each send a high volume of HTTP requests over the network to a target web server. The volume of traffic is so high that the server is ultimately unable to process the excessive load, which ends up flooding the intake queue and other internal data structures. As a result, the server starts dropping or rejecting new requests, including legitimate ones, which practically takes it offline.</p>&#13;
<p class="indent">DDoS attacks can take various forms. In some cases, the DDoS attack is executed by code that comes with the app at install time. In other cases, the code containing the DDoS logic is dynamically fetched from a command-and-control server at execution time, along with data such as the target IP <span epub:type="pagebreak" id="page_12"/>address, start date and time, and attack duration. The Android Security team has also encountered applications installed on many devices that use WebViews to continuously fetch and load the same resource over and over again, such as image files from a web server, resulting in rapid performance degradation and incapacity to respond. In other cases, a malicious app supports a variety of abuse functions that it can perform upon request by a remote command-and-control server. The server sends specific execution parameters to all devices that have the app installed.</p>&#13;
<p class="indent">Such attacks from mobile botnets have been very rare so far, and security companies have publicly documented just a few of them. However, as mobile connections across the world become more stable and powerful, we expect this to change. Additionally, <em>unintentional</em> DDoS attacks are underreported. These happen when developers hardcode timed connections to a web server. When an app with a timed connection becomes popular, each device with the app may connect to the web server at the same time. A smaller web server suddenly facing a million requests at midnight will easily run into trouble. About half of the DDoS cases identified in the past few years involved a mediation by the Android Security team between clumsy app developers and unhappy web server owners, who were unable to resolve the overwhelming number of connections suddenly coming from Android devices.</p>&#13;
<h4 class="h4" id="ch01lev1sec11"><strong><em>Backdoors</em></strong></h4>&#13;
<p class="noindent">A <em>backdoor</em> app opens an unexpected communication channel to a command-and-control server, which instructs the application to execute unwanted, remote-controlled operations on a device. Such operations may include behavior that would otherwise place the app into one of the other malware categories (for example, spyware, phishing, or DoS).</p>&#13;
<p class="indent">Backdoor apps perform a broad range of operations, including:</p>&#13;
<ul>&#13;
<li class="noindent">Installing apps downloaded from an attacker-controlled server using elevated system application privileges, such as those granted to preinstalled apps</li>&#13;
<li class="noindent">Rooting the device to be able to write freely to the filesystem</li>&#13;
<li class="noindent">Harvesting user information from the device, such as contact lists, device location data, text messages, the user’s phone number and call history, or package names of installed apps</li>&#13;
<li class="noindent">Sending text messages to premium SMS numbers</li>&#13;
<li class="noindent">Capturing sensitive data, including credentials, and asking the user to fill out a web form that sends the data to a fraudster</li>&#13;
<li class="noindent">Fetching and displaying ads</li></ul>&#13;
<p class="indent">The communication that backdoor applications establish with command-and-control servers is often hidden, indirect, or protected with obfuscation or encryption methods. For example, some malware families use common encryption algorithms like AES and 3DES for <span epub:type="pagebreak" id="page_13"/>encrypting data or code, Base64 or XOR for encoding, and code compression for obfuscation. They might evade detection through TCP port hopping and the use of covert channels with platforms like IRC chats, Firebase, and X (formerly Twitter). If the user blocks the communication channel between the command-and-control server and the app, the infected device can no longer be managed, so many malware authors make an effort to protect it as much as possible.</p>&#13;
<p class="indent">Some backdoor applications have been known to aggressively try to achieve persistence on the device so that users or malware scanners cannot easily disable them. One approach is to rely on preinstalled applications that have backdoor logic in them. A more common approach, though, is to use the system privileges of a relatively simple preinstalled application to install a backdoor app later on and to reinstall the app if it detects that the backdoor has been removed. Other techniques for protecting the presence of malware on the device include hiding the app’s icon from the main screen, creating a shortcut to substitute the app’s icon, disabling antivirus software, and moving the application to a read-only location (such as <em>/system/app</em>).</p>&#13;
<h4 class="h4" id="ch01lev1sec12"><strong><em>Rooting</em></strong></h4>&#13;
<p class="noindent">In Android, a <em>rooting</em> app is an unprivileged application that exploits vulnerabilities in the Android operating system or manufacturer-specific device components to gain code execution and administrator-level privileges, or status as <em>root</em>: the most privileged user on the system, identified by user identifier (UID) 0. Because Android employs a number of controls to isolate application and operating system resources, including Linux filesystem permissions, process execution under separate UIDs, and SELinux access control policies, an unprivileged application that wishes to execute privileged operations must find a security hole to bypass those controls.</p>&#13;
<p class="indent">Rooting applications usually rely on known Android vulnerabilities that have been publicly disclosed and assigned a Common Vulnerabilities and Exposures (CVE) ID. When left unpatched on the device, they may enable privilege escalation to root. The case of apps that exploit new, previously unknown vulnerabilities (that is, zero-day vulnerabilities), however, has become increasingly rare. Nowadays, they are nearly exclusively the domain of the state-sponsored actors behind a number of so-called advanced persistent threats (APTs).</p>&#13;
<p class="indent">These vulnerabilities are often memory corruption issues in Linux kernel components and device drivers that serve as interfaces between system services and peripherals and unprivileged applications. Once these components are compromised—for instance, through stack corruption or code injection—the attacker may be able to execute their code in the context of these privileged processes. When the malicious app gains root privileges, it may execute additional operations to achieve persistence, read sensitive data, or download and install other apps. For instance, the app may read user data from a different application’s directory; make system configuration changes, such as enabling app installation from third-party sources or disabling Google Play Protect; read authentication tokens to gain access to <span epub:type="pagebreak" id="page_14"/>the user’s account; or inject malicious code into system runtime libraries to enable them to keep executing even after a reboot.</p>&#13;
<p class="indent">Gaining root privileges via a malware app on the device does not automatically mean gaining full access to system resources. In some cases, depending on the Android operating system version and the device’s SELinux configuration, even apps running as root lack access to some of these post-rooting techniques. Even so, because the configuration of each device differs and may change over time, some rooting apps still succeed.</p>&#13;
<p class="indent">Some rooting malware comes with a battery of exploits that are selectively executed based on certain parameters, such as the Android version running on the compromised device and the presence of certain device drivers. In other cases, the application may execute all exploits sequentially, one at a time, until one of them succeeds. Also, as with other malware families, the application can try to dynamically load malicious code at a later stage. For example, it is quite common for a rooting app to collect fingerprinting information about the device on which it is running and send it to a remote server, which responds with a device-specific exploit module. This keeps the rooting app adaptable to new device types. At the same time, the exploit developer does not have to show their hand by giving away all the exploits in their library.</p>&#13;
<p class="indent">It is important to note that there is a difference between nonmalicious and malicious rooting apps. Nonmalicious rooting apps explicitly advertise themselves as tools for rooting the device, and they do not execute other harmful actions in the background. Malicious rooting, on the other hand, occurs when the application does not disclose its purpose and executes rooting attempts without user consent. In both cases, the Android Security team will flag these apps as malware due to their impact on the security of the system. However, even though the execution of a nonmalicious rooting app may leave the system in a vulnerable state, users can still choose to install the app and ignore any warnings from Google Play Protect or other malware scanners. The Android ecosystem gives the user that flexibility.</p>&#13;
<h4 class="h4" id="ch01lev1sec13"><strong><em>Trojans</em></strong></h4>&#13;
<p class="noindent"><em>Trojan</em> apps appear to be benign (for example, they may impersonate a popular app) but contain hidden functionality that performs undesirable actions. These apps have an innocuous component used to gain user trust by giving them some useful features. In addition to this benign component, however, they include malicious logic that is invisible to the user.</p>&#13;
<p class="indent">One very common technique that the creators of trojans and other malware have used to evade detection is to first publish a clean APK that passes all Google Play checks to reach user devices. Then, some days or weeks later, they create and publish a new version of the APK, this time including malware functionality that the user will install as part of an app update. The advantage of this technique is that it allows a malicious app to build an installation base without fearing removal from Google Play or user devices. If the harmful update successfully clears Google Play scanning, potentially thousands of devices will install the new functionality.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>Malicious apps, including trojans, have also abused a feature available in Android that allows Java code to call non-Java code compiled for the device’s hardware. This <em>Java Native Interface (JNI)</em> lets an app load libraries usually stored in <em>.so</em> files, which are bundled inside the APK and may include malicious code. If a malware scanner inspects only Java bytecode or decompiled Java code, it may be blind to the malicious logic present in these hardware-specific libraries. In fact, we have seen malware samples that obviously use native code for no particular reason beyond hiding from malware scanners. For example, some malware is written exclusively in Java except for a minimal decryption feature written in native code, or even just a small native code function that does nothing but return the encryption key used by Java code. Static analysis engines that do not support cross-architecture control and data flow analysis will be stumped by such simple techniques.</p>&#13;
<p class="indent">Trojan apps can perform a wide range of hidden operations. Some banking trojans, for example, target mobile banking users by impersonating popular apps that offer money transfers, check deposits, and other account services. If the user is tricked into downloading the fake app, they may end up giving fraudsters their account credentials. Other applications may wait for users to execute a legitimate banking app, then try to intercept usernames and passwords by using overlays on top of the legitimate app to display input forms that capture the user data. During authentication, the banking app might send a one-time password (OTP) to the user’s device; a trojan app might try to read those text messages.</p>&#13;
<p class="indent">Other trojan families manipulate online user reviews, fetching fake review text from a command-and-control server and then publishing it on a variety of platforms to artificially inflate ratings. This type of abuse also involves the creation of large numbers of fake user accounts to give the impression that real humans posted the ratings.</p>&#13;
<p class="indent">Over the last few years, some proxy network apps have been flagged for malware behavior. These proxy services allow paying customers to anonymously access online resources that would otherwise be protected by firewalls and IP address restrictions. For example, they might allow a user in country A to access a resource in country B. The problem with these apps is that they often fail to tell the user that their device will become an exit node on a proxy network or that their system’s resources will transport traffic (potentially connected to illegal activities) on behalf of others.</p>&#13;
<p class="indent">Yet another type of trojan that appeared some years ago is cryptomining malware. These apps infect a large number of devices and use system resources, however limited they might be, to mine cryptocurrency in the background. In many cases, the mining occurs without any disclosure to the user, abusing the device’s battery life and processing power without their consent. In cases in which the user is actually aware of the mining, the financial benefit they may get is very limited.</p>&#13;
<p class="indent">Some trojan apps allow the attacker to manage the target device remotely. These share some characteristics with backdoor apps and are commonly referred to as <em>remote access trojans (RATs)</em>. RAT malware hides its <span epub:type="pagebreak" id="page_16"/>purpose by pretending to be benign and often uses keyloggers, rooting, and other techniques to install apps, execute commands, and steal user data.</p>&#13;
<h4 class="h4" id="ch01lev1sec14"><strong><em>Spyware</em></strong></h4>&#13;
<p class="noindent">The goal of <em>spyware</em> is to find, collect, and transmit personal data without the consent of the user. This data can be sold to a third party or used to understand the user’s behavior, perhaps to offer them applications in which they might be interested. In the most severe spyware cases, the application may effectively spy on the user by accessing their physical location (whether by reading GPS data or through other means), photos, browsing history, search history, list of installed applications, text messages, and call history. Some spyware will go as far as activating the camera or microphone in an attempt to identify the user, observe their actions, or listen to their conversations.</p>&#13;
<p class="indent">Some spyware families target social media accounts and related application data stored on the device. If the data managed by an app is not encrypted at the application level (meaning the filesystem may be encrypted, but any application with the proper permissions can read the data), a spyware application might be able to siphon the data.</p>&#13;
<p class="indent">Spyware has also abused the Accessibility API, which supports powerful functions including launching an app, performing automated clicks, and reading text to the user. Some malware families have used these privileges to read WhatsApp messages and execute configuration changes on the system without user consent.</p>&#13;
<h4 class="h4" id="ch01lev1sec15"><strong><em>Stalkerware</em></strong></h4>&#13;
<p class="noindent">The Android Security team’s definition of spyware is focused on data collection in which the identity of the victim doesn’t matter; the collected data is resold in bulk or otherwise monetized without care for the affected individuals. Malware that is used to spy on particular, known individuals is called <em>stalkerware</em>, or sometimes commercial spyware or spouseware.</p>&#13;
<p class="indent">Mobile applications advertised as a tool to track someone can, of course, be used with full consent of all involved parties. However, some of these applications lack proper controls and have been misused to become a staple of abusive relationships and can be found on millions of phones. If someone wants to keep track of their partner’s location or see what text messages they send and receive, a quick internet search for “spying on your girlfriend/boyfriend/husband/wife” reveals a thriving industry in which one can pay around $50 for this kind of surveillance software.</p>&#13;
<p class="indent">Stalkerware applications, whether free or for pay, fail to prominently notify the device’s owner of their presence. For example, certain apps may advertise themselves as parental control tools that enable family members to check on others and, in some cases, manage their mobile devices (for example, seeing what applications are installed and what URLs have been visited). But if not designed correctly, these applications may allow a user to spy on others surreptitiously.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/>Stalkers usually install stalkerware applications on the victim’s device when the device is left unattended. During setup, the stalker will configure the app using their email address or a phone number. Many commercial stalkerware products even offer a web-based interface. The stalkers can then take full control of the device from the comfort of that web interface.</p>&#13;
<p class="indent">Even though there may be legitimate use cases for some of the functionality offered by these apps (for instance, knowing where one’s children are), the Android Security team regards any app that can be used covertly to track another person without their knowledge or permission as malware.</p>&#13;
<h4 class="h4" id="ch01lev1sec16"><strong><em>Phishing</em></strong></h4>&#13;
<p class="noindent"><em>Phishing</em> applications try to steal user credentials or payment information by either asking the user for it or capturing the data when it is transmitted. They often target credit card numbers, bank account numbers, cryptocurrency wallet credentials, usernames, passwords, personal identification numbers (PINs), and other authentication factors, such as OTPs. Once the application has captured the data, it sends it over the network to a system under the control of a third party. In some cases, if captured credentials enable access to a private system or network, the impact might extend beyond the individual and result in large-scale hacking, espionage, or theft of confidential information, such as intellectual property.</p>&#13;
<p class="indent">Applications employ various phishing techniques. For instance, certain phishing apps have impersonated popular email, social network, or financial services apps by using similar package names, logos, and app layouts. Once launched, the application may immediately ask the user to enter their credentials, then tell them that there was an error during the login process and redirect them to the correct site. At that point, the damage is already done; the app will send the credentials to a server that centralizes the collection of stolen data, where it might get sold on the dark web or other underground forums. This technique has also been used by malware campaigns that target crypto wallet apps and phish for the user’s wallet credentials. These can allow the attacker to transfer funds to their own accounts.</p>&#13;
<p class="indent">Messaging and communication apps can also enable phishing. Links embedded in a message can put users at risk if they point to phishing or app download sites. Using social engineering, an attacker might convince users to follow a link, which is how they can end up downloading a malicious app or disclosing sensitive information to a fraudulent site.</p>&#13;
<p class="indent">Applications that intercept credentials in transit (instead of receiving them directly from users) also fall within the phishing malware category. For example, past malware has abused a service that allows mobile carriers to send traffic routing configurations to mobile phones by inserting a proxy between the device and the carrier. An app installed on the device first extracts the device’s <em>International Mobile Subscriber Identity (IMSI)</em> using the Android permission <span class="literal">READ_PHONE_STATE</span> and communicates it to a command-and-control server. The server then sends this device a text with Open Mobile Alliance Client Provisioning (OMA CP) settings requesting that the user install a new configuration with data packet routing changes. As a <span epub:type="pagebreak" id="page_18"/>result, the traffic generated by applications on the device—including email and web traffic, which may include authentication credentials, payments data, or other user information—will go to a proxy server controlled by a third party.</p>&#13;
<h4 class="h4" id="ch01lev1sec17"><strong><em>Hostile Downloaders</em></strong></h4>&#13;
<p class="noindent">If an app is downloaded frequently, opportunities to monetize it often arise. This incentive has resulted in the creation of a large number of apps whose primary job is to install other apps. The developers of benign apps sometimes pay these installer apps to improve their metrics. Unfortunately, some malware developers use these same services. An app that does nothing harmful except download malware applications is considered a <em>hostile downloader</em>. This type of app has been the starting point of numerous malware campaigns over the years.</p>&#13;
<p class="indent">Some hostile downloaders install the same set of apps every time. In other cases, the type and number of apps they install changes. In all cases, determining if an application should be considered a hostile downloader requires data about the type of apps installed and the number of installs. For example, some applications install a very small number of harmful applications, whereas others mainly distribute malware. The Android Security team uses different criteria to define the line between benign and hostile downloaders, and when an application crosses it, it is flagged as malware. For example, at the time of writing, if at least 5 percent of the app’s downloads include malware and the application has downloaded a minimum of 500 apps (benign or otherwise), it will be considered a hostile downloader. Major browsers and file sharing apps are not considered hostile downloaders, as long as a download requires user interaction and any malware download is initiated directly by the user.</p>&#13;
<p class="indent">Hostile downloaders typically make use of two available permissions to install other apps: <span class="literal">INSTALL_PACKAGES</span> and <span class="literal">REQUEST_INSTALL_PACKAGES</span>. Of these, <span class="literal">INSTALL_PACKAGES</span> is more powerful, because it allows an application to install other apps without involving the user. Given the risk of abuse, only pre-installed apps can use this permission.</p>&#13;
<p class="indent">The more benign permission, <span class="literal">REQUEST_INSTALL_PACKAGES</span>, was introduced in Android 8.0 (Oreo) and is available to all Android apps. This permission allows an app to request the installation of other apps, for instance, after the original app has been successfully installed. When declared in the app’s manifest file, <span class="literal">REQUEST_INSTALL_PACKAGES</span> will ask the user for confirmation before an <span class="literal">ACTION_INSTALL_PACKAGE</span> intent can be used to install an APK. This permission makes it more difficult for hostile downloader developers to force app installs, as it requires user intervention. Before Android 8.0 (Oreo) all apps had the option to start a user-consented app installation flow. The introduction of this new permission makes explicit to users which apps can be installers of other apps.</p>&#13;
<p class="indent">Malware developers have found ways to include apps with hostile downloader functionality in the system images that phone carriers and device manufacturers put in their products. Thus, many hostile downloaders come <span epub:type="pagebreak" id="page_19"/>preinstalled on some devices. In addition to having special permissions and access to system resources, these preinstalled applications cannot be easily uninstalled. This privileged position allows a hostile downloader to fetch and install APKs without user intervention. One additional challenge with these applications is that the apps that they’ve installed may not be known to the manufacturer or the company responsible for building the system image. As a result, the user of a brand-new device may end up with a number of unwanted or even harmful applications.</p>&#13;
<p class="indent">Hostile downloaders that do not have permission to install other apps may find alternative ways to do it. For instance, they may try to root the device in order to access the filesystem and copy APKs. Then, they may try to abuse the <span class="literal">PackageManager</span> in some Android versions to actually install apps. Recent Android versions prevent the direct copying of files using absolute paths, which is what some hostile downloaders used to do, and require the app to use <span class="literal">FileProvider</span>, which is a more secure way to handle files. In some cases, if the app cannot be fetched and installed quickly, the hostile downloader may first download the <em>.apk</em> file using the <span class="literal">INTERNET</span> permission and then write it to the SD card (for example, to the <em>Downloads</em> folder) using <span class="literal">WRITE_EXTERNAL_STORAGE</span>. Later, in a second step, the downloader will try to gain the <span class="literal">INSTALL_PACKAGES</span> permission and install the files it previously downloaded.</p>&#13;
<p class="indent">Some hostile downloader developers may be aware of the Android Security team’s detection thresholds and try to stay below those levels. In some cases, to maintain a high number of app downloads, they might install multiple hostile downloaders on the same device. When that’s the case, detection methods can be adjusted to account for that mutation in behavior.</p>&#13;
<h4 class="h4" id="ch01lev1sec18"><strong><em>Privilege Escalation</em></strong></h4>&#13;
<p class="noindent">The <em>privilege escalation</em> malware category covers applications that try to elevate their permissions by abusing the system or exploiting vulnerabilities. This category covers all privilege escalation cases except rooting, which, due to its impact on the integrity of the system, has its own category (discussed previously).</p>&#13;
<p class="indent">Four malware behaviors characterize this malware category, not all of which would be considered privilege escalation in other contexts. It includes:</p>&#13;
<ol>&#13;
<li class="noindent">Applications that are able to access (read, write, or execute) resources they originally didn’t have the privileges to access, thereby breaking the Android app sandbox</li>&#13;
<li class="noindent">Applications that manage to find ways to bypass permissions</li>&#13;
<li class="noindent">Applications that disable security and safety features on the device</li>&#13;
<li class="noindent">Applications that prevent the user from managing their device</li>&#13;
</ol>&#13;
<p class="indent">Applications that disable security features or that modify the system’s configuration in a way that leaves the device in a vulnerable state are flagged as privilege escalation apps. An example is preinstalled applications that abuse system privileges (for example, the <span class="literal">WRITE_SECURE_SETTINGS</span> permission <span epub:type="pagebreak" id="page_20"/>or the <span class="literal">Settings.Global</span> and <span class="literal">Settings.Secure</span> methods) to turn off Google Play Protect’s malware scanning before they self-update or download and install other malware. Other privilege escalation applications in the past have accomplished the same objective of disabling security settings by executing shell commands instead of using Android APIs, and a third group manipulated security settings by modifying the <span class="literal">package_verifier_enable</span> setting, which modifies the malware scanning behavior on the device.</p>&#13;
<p class="indent">Another feature that malware has targeted is SELinux, which complements the filesystem permissions model by defining policies that prevent access to sensitive resources regardless of the permissions a file may have. When SELinux is enabled, some exploits may fail, as the resulting privileges may be insufficient to access the resources it wants. For example, some license cracking applications that patch the code of gaming apps in a way that bypasses license checks and purchase verification need write access to the filesystem in order to create patched versions of the app. When the appropriate SELinux policy is enabled, such modifications are prevented, and malware must try to disable it as one of its first steps. It might do this, for instance, by running a <span class="literal">setenforce 0</span> command to turn SELinux from so-called <em>enforcing</em> mode to <em>permissive</em> mode. It’s worth noting that, on modern devices running at least Android 5.0 (Lollipop), permissive mode is supported only in <em>userdebug</em> and <em>eng</em> builds, which are special Android device configurations usually reserved for development and testing. It should not be possible to turn off SELinux on regular end user devices.</p>&#13;
<p class="indent">Some apps modify the <span class="literal">install_non_market_apps</span> setting for the purposes of privilege escalation. Android devices give the user the ability to install applications from any source. This setting, however, prevents applications from installing additional applications from sources other than Google Play, given that these sources have a higher risk of distributing malware. When an app automatically modifies this setting without user consent, the app will be flagged as malware, as it may leave the device in a vulnerable state.</p>&#13;
<p class="indent">Malware authors have also abused the device manager APIs (implemented in classes like <span class="literal">DevicePolicyManager</span> or <span class="literal">DeviceAdminReceiver</span>), which enable device management operations through a set of policies, especially for enterprise deployments, including resetting and expiring passwords, wiping user data partitions through factory reset, and requiring encryption of stored data. Malware developers have used the device manager APIs to prevent their apps from being removed. For example, some malware families observed in the wild call <span class="literal">resetPassword</span> and <span class="literal">lockNow</span> to lock a device when a user action triggers an <span class="literal">onDisableRequested</span> callback that will try to remove device admin privileges from the potentially harmful app. In other cases, the app may monitor user access to system settings and trigger the same behavior: locking the owner out.</p>&#13;
<p class="indent">Since Android 9.0 (Pie), the device manager APIs have been phased out (deprecated), partially in response to malware abuse, as a number of past privilege escalation apps used them as a vector to exercise device control without user consent. Prior to this, these APIs went through changes that lessened their potential for abuse. For example, as of Android 7.0 (Nougat) <span epub:type="pagebreak" id="page_21"/>the method <span class="literal">resetPassword</span> can only be used to set new device passwords, not to change already existing passwords. This prevents users with existing device passwords from being locked out of their devices.</p>&#13;
<p class="indent">One final setting worth mentioning is <span class="literal">upload_apk_enable</span>. This setting controls whether the device shares APK samples with Google Play Protect to help identify malware. Malware authors may try to disable it as a means to slow down the detection of their apps.</p>&#13;
<p class="indent">It is also worth mentioning that some applications rely on other applications to weaken the security posture of the device before executing. For instance, some malware families include a rooting component whose job is to weaken the security of the execution environment and filesystem in preparation for other applications actually accessing the data made available by the rooting component. Some of these secondary applications take advantage of the vulnerable state of the system to access, for instance, the <em>accounts.db</em> file, which contains tokens that allow the device to access a number of services. These apps might read and then send Google OAuth master tokens and ClientLogin tokens for Google Play. In other cases, file attributes are manipulated to make modification or removal more difficult, for example by declaring files read-only, moving them to privileged partitions, or making files more difficult to remove by using the <span class="literal">chattr</span> shell command to set <span class="literal">+ia</span> attributes on them. A file with these attributes can only be opened in append mode for writing; it cannot be deleted or renamed.</p>&#13;
<h4 class="h4" id="ch01lev1sec19"><strong><em>Ransomware</em></strong></h4>&#13;
<p class="noindent">An app is considered <em>ransomware</em> if it takes control of the user’s data or device and makes demands to release this control. These demands may include the payment of a ransom or a request for the user to perform an action against their will. The two primary ransomware methods observed in the Android ecosystem are preventing access to the user’s data by encrypting it on the device with a key that the attacker controls and locking users out of their devices, either through the actual screen locking mechanism or by making the GUI unusable for anything besides the ransomware app.</p>&#13;
<p class="indent">Ransomware apps that encrypt user data first need to get permission to write to the filesystem (for example, through the <span class="literal">WRITE_EXTERNAL_STORAGE</span> permission). Then they can explore the filesystem, checking the status of specific files and directories via <span class="literal">getExternalStorageState</span>. In some cases, the app will read all files from external storage and write them back in encrypted form using the <span class="literal">java.io.File.*</span> methods and an encryption key. In other cases, only images and messages are encrypted, but not other file formats. In all situations, the app displays a notification to the user explaining how to send the payment, often requesting cryptocurrency to hide the perpetrator’s identity. The message also describes how the user will receive the decryption key and recover their files.</p>&#13;
<p class="indent">These applications often use standard encryption algorithms, such as AES for data encryption and RSA for key protection. With this approach, the AES symmetric key used to encrypt the files is encrypted under the attacker’s RSA public key and sent to a command-and-control server so that <span epub:type="pagebreak" id="page_22"/>the attacker can later decrypt it and then send it to the user if the payment is received.</p>&#13;
<p class="indent">Other applications do not encrypt any data but instead block access to the device by displaying a ransomware note that covers the entire screen and that the user cannot remove. Even after a reboot, the note remains. This type of attack prevents the user from accessing the device’s interface, including performing actions like making calls or reading messages. Some apps use the <span class="literal">SYSTEM_ALERT_WINDOW</span> permission to display such an overlay window. First, they identify the processes running on the device by calling <span class="literal">getRunningServices</span>, checking process IDs on <em>/proc</em> using the command line, or identifying the top activity via <span class="literal">getRunningTasks</span>. Next, they call <span class="literal">startActivity</span> to draw over other apps that are executing.</p>&#13;
<p class="indent">A ransomware application can also use the <span class="literal">BIND_DEVICE_ADMIN</span> permission available in some Android versions and then use <span class="literal">DevicePolicyManager</span> methods, like <span class="literal">resetPassword</span> and <span class="literal">lockNow</span>, to change the device’s password.</p>&#13;
<h4 class="h4" id="ch01lev1sec20"><strong><em>SMS Fraud</em></strong></h4>&#13;
<p class="noindent">Some applications cause direct financial harm to the user. That is the case for malware that uses text messages to commit fraud. The <em>SMS fraud</em> category is composed of applications that send SMS or MMS messages to special numbers, called <em>short codes</em>. These are typically three- to eight-digit-long codes, such as 1234, that charge the user a premium when they send SMS messages to these numbers. Such premium messages were created for legitimate purposes, such as allowing users to send donations to people affected by disasters, vote for a performer on a TV show, or subscribe to information services delivered via text (for example, daily news, jokes, the weather forecast, or horoscopes). Even though carriers support them, the actual services may be delivered by third parties.</p>&#13;
<p class="indent">SMS fraud apps send text messages in an intentionally deceptive way. They abuse the <span class="literal">SEND_SMS</span> permission by calling APIs such as <span class="literal">sendTextMessage</span>, <span class="literal">sendMultimediaMessage</span>, or <span class="literal">sendMultipartTextMessage</span> without the user’s involvement and actively suppress any notifications to prevent detection. In some cases, it is only when the user reviews their phone bill that they learn about the fraudulent charges made to their account.</p>&#13;
<p class="indent">Even in cases where the destination is a regular number but there is no disclosure to the user of the text messages being sent, an application may be suspended for violating Google Play policies that protect users from SMS use without consent. However, when the number is a short code for premium services, the application will be flagged as malware, as these SMS messages directly incur a cost to users. Android warns the user when a premium SMS is being sent. However, this warning does not represent a disclosure; the application sending the message must disclose such activity within the app in a clear and prominent way.</p>&#13;
<p class="indent">SMS fraud apps sometimes come loaded with a list of premium numbers to use. They then check the device’s country and mobile carrier to select a specific number from the list. In other cases, the destination number <span epub:type="pagebreak" id="page_23"/>is dynamically loaded from a command-and-control server, which offers the fraudster flexibility and gives them the ability to add new numbers.</p>&#13;
<p class="indent">These applications may also disguise premium SMS subscriptions by hiding disclosure agreements or messages from the mobile operator that notify the user of charges or new subscriptions.</p>&#13;
<h4 class="h4" id="ch01lev1sec21"><strong><em>Toll Fraud</em></strong></h4>&#13;
<p class="noindent"><em>Toll fraud</em> applications are those that trick users into subscribing to services or purchasing content via charges to their phone bill. It excludes charges generated by premium text messages, which have their own category (discussed in the previous section).</p>&#13;
<p class="indent">Many payment and billing technologies allow users to buy products and subscribe to services by simply charging payments to their mobile phone bill, which is a useful solution in countries where credit or debit card usage is not widespread. These include direct carrier billing (DCB), Wireless Application Protocol (WAP), and mobile airtime transfer (MAT), which track the user’s data and airtime balance, their activity, and their purchases. Because they manage charges, and because purchases can be made relatively silently (in some cases with one click or by simply confirming the phone number to charge), these systems are an inviting target for fraudsters.</p>&#13;
<p class="indent">One of the first things toll fraud applications do to engage in carrier billing is disable the Wi-Fi connection. When the device is using a Wi-Fi network, it won’t use the mobile data connection managed by the carrier, such as LTE, 3G, or 4G. Any traffic generated by the device will flow through the user’s Wi-Fi access point and internet service provider (ISP) instead. Apps can disable Wi-Fi by, for example, using the <span class="literal">setWifiEnabled</span> API, and enable mobile data using the <span class="literal">setMobileDataEnabled</span> API. Once this is done, the app may open a service subscription web page using a WebView with JavaScript enabled, then inject JavaScript to auto-click buttons that complete the subscription. The service may send text messages to the mobile device confirming the subscription, but the toll fraud app will intercept those and delete them, preventing the user from becoming aware of the fraudulent actions.</p>&#13;
<p class="indent">The permissions often abused by toll fraud apps include <span class="literal">CHANGE_WIFI</span> <span class="literal">_STATE</span>, which is needed to switch to mobile data; <span class="literal">RECEIVE_SMS</span> or <span class="literal">READ_SMS</span>, to read confirmation codes or subscription alerts; and <span class="literal">READ_PHONE_STATE</span>, to obtain the phone number or other device identifiers needed to subscribe the user to a service. Recently, toll fraud apps have started to abuse the <span class="literal">BIND</span> <span class="literal">_NOTIFICATION_LISTENER_SERVICE</span> permission to access incoming texts after a Google Play policy change that cracked down on apps using texts.</p>&#13;
<p class="indent">The malicious code that implements the fraudulent functionality is often obfuscated (for example, Base64 encoded) or dynamically fetched after install to avoid detection.</p>&#13;
<h4 class="h4" id="ch01lev1sec22"><span epub:type="pagebreak" id="page_24"/><strong><em>Call Fraud</em></strong></h4>&#13;
<p class="noindent">The <em>call fraud</em> malware category is composed of applications that generate charges on the user’s phone bill by placing phone calls to premium numbers without the user’s consent or knowledge. As with SMS fraud, this type of abuse relies on a convenient feature that many phone carriers offer: the ability to buy products and subscribe to services over the phone by adding them to the user’s phone bill for future payment. In some cases, the billing account may be linked to automated payments via a credit card or a bank account. When that’s the case, the user may not realize that they are being charged for phone calls to toll numbers.</p>&#13;
<p class="indent">In order to hide the calls, fraudulent apps may rely on the <span class="literal">CALL_PHONE</span> permission to initiate them without using the Dialer user interface on the device, as this would visually alert the user. Still, the user could potentially hear the call. In order to silence the audio, some malware uses the <span class="literal">setStreamVolume</span> method in the <span class="literal">AudioManager</span> class, which controls the volume level of audio streams, to set the volume to its lowest level.</p>&#13;
<p class="indent">Other signs of call fraud malware include the use of permissions like <span class="literal">PROCESS_OUTGOING_CALLS</span>, which allows the application to retrieve the phone number being dialed, redirect the call, or terminate it, so that the application can close the call a few seconds after successfully establishing the connection and incurring the toll charge. They might also include the use of <em>call intents</em>, requests to the operating system to make phone calls, to actually perform a call based on predefined toll phone numbers or phone numbers dynamically received from a command-and-control server.</p>&#13;
<h4 class="h4" id="ch01lev1sec23"><strong><em>Spam</em></strong></h4>&#13;
<p class="noindent"><em>Spam</em> applications send unsolicited messages to users or use the device as an email spam relay, often to advertise products or services.</p>&#13;
<p class="indent">The list of targets to spam may come from the user’s phone directory or the contact lists of social networking apps like Facebook and WhatsApp. They can also be dynamically provided by a command-and-control server or fetched from a web server. Once the app has collected the list of targets, it starts sending messages to them silently. In some cases, this may happen via text. In other cases, the application may try to send messages using an API (such as the Facebook API), although that requires the user to be logged in. Spam malware is rare nowadays. We include it here for completeness.</p>&#13;
<h4 class="h4" id="ch01lev1sec24"><strong><em>Ad Fraud</em></strong></h4>&#13;
<p class="noindent">Many Android apps have the ability to fetch ads from an ad network and display them to the user. When an app displays an ad, a publisher and network get credit for that ad, a metric called an <em>impression</em>. When a user actually clicks an ad, advertisers generally compensate publishers for the clicks they helped produce.</p>&#13;
<p class="indent">Where there’s a money flow, there’s the possibility of abuse. The <em>ad fraud</em> category includes applications that maliciously manipulate mobile ad <span epub:type="pagebreak" id="page_25"/>platforms for financial gain. There are two main classes of ad fraud: click fraud and attribution fraud.</p>&#13;
<p class="indent">In <em>click fraud</em>, the application fetches ads from an ad network and generates automated clicks without user intervention or notification. These could be in-app clicks simulated through Java APIs, for example, or clicks triggered via JavaScript code loaded into a WebView. In some cases, the app hides the ads, making them difficult for the user to detect, by using minimum dimensions, like 1×1 pixels. In other cases, the user can see the ad but does not realize that the app is producing click events in the background.</p>&#13;
<p class="indent">Traffic from click fraud applications ends up artificially inflating the number of clicks linked to an ad. The network tracks this number and communicates it to the advertiser, which in turn pays for these clicks, despite the fact that they were not driven by actual user interest. This type of malware defrauds advertisers, whose ad budgets and conversion rates may take a hit, eroding their trust in the ecosystem. Users might also be affected by click fraud when significant fake ad traffic wastes their mobile plan’s data budget and battery charge and irrelevant ads are presented to them.</p>&#13;
<p class="indent">The second class of ad fraud is <em>attribution fraud</em>, which occurs when an app tries to change the data used to attribute an ad impression or an app install to a referrer or publisher. For example, if an ad displayed by the app is linked to a referrer identifier, the ad network will track that identifier to ensure that the appropriate referrer is compensated. However, an attribution fraud app may listen for broadcast intents that include referrer identifiers and then send spoofed traffic to the ad network that changes the identifier. As a consequence, someone else will be compensated for the impressions. In some cases, the code that implements attribution fraud is part of a <em>software development kit (SDK)</em>, a set of tools that application developers may include in their apps without knowing that it contains code that will try to divert ad or app install credits.</p>&#13;
<p class="indent">Additional schemes may fit the definition of ad fraud. For example, for advertising networks that pay per impression, <em>impression fraud</em><a id="dx1-38006"/>, or manipulating how many ads are displayed and how often, can be used to drum up ad income. We have also seen more sophisticated schemes, such as ad networks that spy on their competitors’ impression and click information, or ad networks that collect all the necessary pieces of information to perpetrate a fraud, send it to their servers, and then carry out the actual fraud server-side on simulated Android devices. None of these are covered in this book, however, as the ad fraud space is huge and, for some reason, the historically important ad fraud malware families on Android have all used click fraud or attribution fraud.</p>&#13;
<h4 class="h4" id="ch01lev1sec25"><strong><em>Non-Android Threats</em></strong></h4>&#13;
<p class="noindent">The Android Security team defines one last malware category: <em>non-Android threats</em>. These applications contain some kind of malicious behavior but cannot directly harm Android users. In most cases, this category is used to flag Android apps that contain Windows malware, nearly always because the application developer’s computer was infected with Windows malware at build <span epub:type="pagebreak" id="page_26"/>time. The use of this category mainly benefits app developers, as it lets them realize that something is wrong with their app. Actual Android users won’t be harmed by the app’s malicious components.</p>&#13;
<h3 class="h3" id="ch01lev4"><strong>Up Next</strong></h3>&#13;
<p class="noindent">Now that we’ve introduced the Android security model and the malware categories tracked by Android Security, the next chapter will review 10 years of Android malware. We’ll provide examples of actual malware families and explain why the popularity of a malware category changes over time.</p>&#13;
</div>
</div>
<div style="float: none; margin: 10px 0px 10px 0px; text-align: center;"><p><a href="https://oceanofpdf.com"><i>OceanofPDF.com</i></a></p></div></body></html>