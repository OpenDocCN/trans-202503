["```\n`$ /lib/libc.so.6`\nGNU C Library stable release version 2.10.1, by Roland McGrath et al.\nCopyright (C) 2009 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version 4.4.0 20090506 (Red Hat 4.4.0-4).\nCompiled on a Linux >>2.6.18-128.4.1.el5<< system on 2009-08-19.\nAvailable extensions:\n        The C stubs add-on version 2.1.2.\n        crypt add-on version 2.1 by Michael Glad and others\n        GNU Libidn by Simon Josefsson\n        Native POSIX Threads Library by Ulrich Drepper et al\n        BIND-8.2.3-T5B\n        RT using linux kernel aio\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/libc/bugs.html>.\n```", "```\n$ ldd myprog | grep libc\n        libc.so.6 => /lib/tls/libc.so.6 (0x4004b000)\n```", "```\n#include <gnu/libc-version.h>\n\nconst char *`gnu_get_libc_version`(void);\n```", "```\nfd = open(pathname, flags, mode);       /* system call to open a file */\nif (fd == -1) {\n    /* Code to handle the error */\n}\n...\nif (close(fd) == -1) {\n    /* Code to handle the error */\n}\n```", "```\ncnt = read(fd, buf, numbytes);\nif (cnt == -1) {\n    if (errno == EINTR)\n        fprintf(stderr, \"read was interrupted by a signal\\n\");\n    else {\n        /* Some other error occurred */\n    }\n}\n```", "```\n#include <stdio.h>\n\nvoid `perror`(const char **msg*);\n```", "```\nfd = open(pathname, flags, mode);\nif (fd == -1) {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n}\n```", "```\n#include <string.h>\n\nchar *`strerror`(int *errnum*);\n```", "```\n`lib/tlpi_hdr.h`\n#ifndef TLPI_HDR_H\n#define TLPI_HDR_H      /* Prevent accidental double inclusion */\n\n#include <sys/types.h>  /* Type definitions used by many programs */\n#include <stdio.h>      /* Standard I/O functions */\n#include <stdlib.h>     /* Prototypes of commonly used library functions,\n                           plus EXIT_SUCCESS and EXIT_FAILURE constants */\n#include <unistd.h>     /* Prototypes for many system calls */\n#include <errno.h>      /* Declares errno and defines error constants */\n#include <string.h>     /* Commonly used string-handling functions */\n\n#include \"get_num.h\"    /* Declares our functions for handling numeric\n                           arguments (getInt(), getLong()) */\n\n#include \"error_functions.h\"  /* Declares our error-handling functions */\n\ntypedef enum { FALSE, TRUE } Boolean;\n\n#define min(m,n) ((m) < (n) ? (m) : (n))\n#define max(m,n) ((m) > (n) ? (m) : (n))\n\n#endif\n      `lib/tlpi_hdr.h`\n```", "```\n`lib/error_functions.h`\n#ifndef ERROR_FUNCTIONS_H\n#define ERROR_FUNCTIONS_H\n\nvoid errMsg(const char *format, ...);\n\n#ifdef __GNUC__\n\n/* This macro stops 'gcc -Wall' complaining that \"control reaches\n       end of non-void function\" if we use the following functions to\n       terminate main() or some other non-void function. */\n\n#define NORETURN __attribute__ ((__noreturn__))\n#else\n#define NORETURN\n#endif\n\nvoid errExit(const char *format, ...) NORETURN ;\n\nvoid err_exit(const char *format, ...) NORETURN ;\n\nvoid errExitEN(int errnum, const char *format, ...) NORETURN ;\n\nvoid fatal(const char *format, ...) NORETURN ;\n\nvoid usageErr(const char *format, ...) NORETURN ;\n\nvoid cmdLineErr(const char *format, ...) NORETURN ;\n\n#endif\n      `lib/error_functions.h`\n```", "```\n#include \"tlpi_hdr.h\"\n\nvoid `errMsg`(const char **format*, ...);\nvoid `errExit`(const char **format*, ...);\nvoid `err_exit`(const char **format*, ...);\nvoid `errExitEN`(int *errnum*, const char **format*, ...);\n```", "```\nerrno = pthread_create(&thread, NULL, func, &arg);\nif (errno != 0)\n    errExit(\"pthread_create\");\n```", "```\nint s;\n\ns = pthread_create(&thread, NULL, func, &arg);\nif (s != 0)\n    errExitEN(s, \"pthread_create\");\n```", "```\n#include \"tlpi_hdr.h\"\n\nvoid `fatal`(const char **format*, ...);\nvoid `usageErr`(const char **format*, ...);\nvoid `cmdLineErr`(const char **format*, ...);\n```", "```\n`lib/error_functions.c`\n#include <stdarg.h>\n#include \"error_functions.h\"\n#include \"tlpi_hdr.h\"\n#include \"ename.c.inc\"          /* Defines ename and MAX_ENAME */\n\n#ifdef __GNUC__\n__attribute__ ((__noreturn__))\n#endif\nstatic void\nterminate(Boolean useExit3)\n{\n    char *s;\n\n    /* Dump core if EF_DUMPCORE environment variable is defined and\n       is a nonempty string; otherwise call exit(3) or _exit(2),\n       depending on the value of 'useExit3'. */\n\n    s = getenv(\"EF_DUMPCORE\");\n\n    if (s != NULL && *s != '\\0')\n        abort();\n    else if (useExit3)\n        exit(EXIT_FAILURE);\n    else\n        _exit(EXIT_FAILURE);\n}\n\nstatic void\noutputError(Boolean useErr, int err, Boolean flushStdout,\n        const char *format, va_list ap)\n{\n#define BUF_SIZE 500\n    char buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];\n\n    vsnprintf(userMsg, BUF_SIZE, format, ap);\n\n    if (useErr)\n        snprintf(errText, BUF_SIZE, \" [%s %s]\",\n                (err > 0 && err <= MAX_ENAME) ?\n                ename[err] : \"?UNKNOWN?\", strerror(err));\n    else\n        snprintf(errText, BUF_SIZE, \":\");\n\n    snprintf(buf, BUF_SIZE, \"ERROR%s %s\\n\", errText, userMsg);\n\n    if (flushStdout)\n        fflush(stdout);       /* Flush any pending stdout */\n    fputs(buf, stderr);\n    fflush(stderr);           /* In case stderr is not line-buffered */\n}\n\nvoid\nerrMsg(const char *format, ...)\n{\n    va_list argList;\n    int savedErrno;\n\n    savedErrno = errno;       /* In case we change it here */\n\n    va_start(argList, format);\n    outputError(TRUE, errno, TRUE, format, argList);\n    va_end(argList);\n\n    errno = savedErrno;\n}\n\nvoid\nerrExit(const char *format, ...)\n{\n    va_list argList;\n\n    va_start(argList, format);\n    outputError(TRUE, errno, TRUE, format, argList);\n    va_end(argList);\n\n    terminate(TRUE);\n}\n\nvoid\nerr_exit(const char *format, ...)\n{\n    va_list argList;\n\n    va_start(argList, format);\n    outputError(TRUE, errno, FALSE, format, argList);\n    va_end(argList);\n\n    terminate(FALSE);\n}\n\nvoid\nerrExitEN(int errnum, const char *format, ...)\n{\n    va_list argList;\n\n    va_start(argList, format);\n    outputError(TRUE, errnum, TRUE, format, argList);\n    va_end(argList);\n\n    terminate(TRUE);\n}\n\nvoid\nfatal(const char *format, ...)\n{\n    va_list argList;\n\n    va_start(argList, format);\n    outputError(FALSE, 0, TRUE, format, argList);\n    va_end(argList);\n\n    terminate(TRUE);\n}\n\nvoid\nusageErr(const char *format, ...)\n{\n    va_list argList;\n\n    fflush(stdout);           /* Flush any pending stdout */\n\n    fprintf(stderr, \"Usage: \");\n    va_start(argList, format);\n    vfprintf(stderr, format, argList);\n    va_end(argList);\n\n    fflush(stderr);           /* In case stderr is not line-buffered */\n    exit(EXIT_FAILURE);\n}\n\nvoid\ncmdLineErr(const char *format, ...)\n{\n    va_list argList;\n\n    fflush(stdout);           /* Flush any pending stdout */\n\n    fprintf(stderr, \"Command-line usage error: \");\n    va_start(argList, format);\n    vfprintf(stderr, format, argList);\n    va_end(argList);\n\n    fflush(stderr);           /* In case stderr is not line-buffered */\n    exit(EXIT_FAILURE);\n}\n     `lib/error_functions.c`\n```", "```\n`lib/ename.c.inc`\nstatic char *ename[] = {\n    /*   0 */ \"\",\n    /*   1 */ \"EPERM\", \"ENOENT\", \"ESRCH\", \"EINTR\", \"EIO\", \"ENXIO\", \"E2BIG\",\n    /*   8 */ \"ENOEXEC\", \"EBADF\", \"ECHILD\", \"EAGAIN/EWOULDBLOCK\", \"ENOMEM\",\n    /*  13 */ \"EACCES\", \"EFAULT\", \"ENOTBLK\", \"EBUSY\", \"EEXIST\", \"EXDEV\",\n    /*  19 */ \"ENODEV\", \"ENOTDIR\", \"EISDIR\", \"EINVAL\", \"ENFILE\", \"EMFILE\",\n    /*  25 */ \"ENOTTY\", \"ETXTBSY\", \"EFBIG\", \"ENOSPC\", \"ESPIPE\", \"EROFS\",\n    /*  31 */ \"EMLINK\", \"EPIPE\", \"EDOM\", \"ERANGE\", \"EDEADLK/EDEADLOCK\",\n    /*  36 */ \"ENAMETOOLONG\", \"ENOLCK\", \"ENOSYS\", \"ENOTEMPTY\", \"ELOOP\", \"\",\n    /*  42 */ \"ENOMSG\", \"EIDRM\", \"ECHRNG\", \"EL2NSYNC\", \"EL3HLT\", \"EL3RST\",\n    /*  48 */ \"ELNRNG\", \"EUNATCH\", \"ENOCSI\", \"EL2HLT\", \"EBADE\", \"EBADR\",\n    /*  54 */ \"EXFULL\", \"ENOANO\", \"EBADRQC\", \"EBADSLT\", \"\", \"EBFONT\", \"ENOSTR\",\n    /*  61 */ \"ENODATA\", \"ETIME\", \"ENOSR\", \"ENONET\", \"ENOPKG\", \"EREMOTE\",\n    /*  67 */ \"ENOLINK\", \"EADV\", \"ESRMNT\", \"ECOMM\", \"EPROTO\", \"EMULTIHOP\",\n    /*  73 */ \"EDOTDOT\", \"EBADMSG\", \"EOVERFLOW\", \"ENOTUNIQ\", \"EBADFD\",\n    /*  78 */ \"EREMCHG\", \"ELIBACC\", \"ELIBBAD\", \"ELIBSCN\", \"ELIBMAX\",\n    /*  83 */ \"ELIBEXEC\", \"EILSEQ\", \"ERESTART\", \"ESTRPIPE\", \"EUSERS\",\n    /*  88 */ \"ENOTSOCK\", \"EDESTADDRREQ\", \"EMSGSIZE\", \"EPROTOTYPE\",\n    /*  92 */ \"ENOPROTOOPT\", \"EPROTONOSUPPORT\", \"ESOCKTNOSUPPORT\",\n    /*  95 */ \"EOPNOTSUPP/ENOTSUP\", \"EPFNOSUPPORT\", \"EAFNOSUPPORT\",\n    /*  98 */ \"EADDRINUSE\", \"EADDRNOTAVAIL\", \"ENETDOWN\", \"ENETUNREACH\",\n    /* 102 */ \"ENETRESET\", \"ECONNABORTED\", \"ECONNRESET\", \"ENOBUFS\", \"EISCONN\",\n    /* 107 */ \"ENOTCONN\", \"ESHUTDOWN\", \"ETOOMANYREFS\", \"ETIMEDOUT\",\n    /* 111 */ \"ECONNREFUSED\", \"EHOSTDOWN\", \"EHOSTUNREACH\", \"EALREADY\",\n    /* 115 */ \"EINPROGRESS\", \"ESTALE\", \"EUCLEAN\", \"ENOTNAM\", \"ENAVAIL\",\n    /* 120 */ \"EISNAM\", \"EREMOTEIO\", \"EDQUOT\", \"ENOMEDIUM\", \"EMEDIUMTYPE\",\n    /* 125 */ \"ECANCELED\", \"ENOKEY\", \"EKEYEXPIRED\", \"EKEYREVOKED\",\n    /* 129 */ \"EKEYREJECTED\", \"EOWNERDEAD\", \"ENOTRECOVERABLE\", \"ERFKILL\"\n};\n\n#define MAX_ENAME 132\n     `lib/ename.c.inc`\n```", "```\n#include \"tlpi_hdr.h\"\n\nint `getInt`(const char **arg*, int *flags*, const char **name*);\nlong `getLong`(const char **arg*, int *flags*, const char **name*);\n```", "```\n`lib/get_num.h`\n#ifndef GET_NUM_H\n#define GET_NUM_H\n\n#define GN_NONNEG       01      /* Value must be >= 0 */\n#define GN_GT_0         02      /* Value must be > 0 */\n\n                                /* By default, integers are decimal */\n#define GN_ANY_BASE   0100      /* Can use any base - like strtol(3) */\n#define GN_BASE_8     0200      /* Value is expressed in octal */\n#define GN_BASE_16    0400      /* Value is expressed in hexadecimal */\n\nlong getLong(const char *arg, int flags, const char *name);\n\nint getInt(const char *arg, int flags, const char *name);\n\n#endif\n      `lib/get_num.h`\n```", "```\n`lib/get_num.c`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include \"get_num.h\"\n\nstatic void\ngnFail(const char *fname, const char *msg, const char *arg, const char *name)\n{\n    fprintf(stderr, \"%s error\", fname);\n    if (name != NULL)\n        fprintf(stderr, \" (in %s)\", name);\n    fprintf(stderr, \": %s\\n\", msg);\n    if (arg != NULL && *arg != '\\0')\n        fprintf(stderr, \"        offending text: %s\\n\", arg);\n\n    exit(EXIT_FAILURE);\n}\n\nstatic long\ngetNum(const char *fname, const char *arg, int flags, const char *name)\n{\n    long res;\n    char *endptr;\n    int base;\n\n    if (arg == NULL || *arg == '\\0')\n        gnFail(fname, \"null or empty string\", arg, name);\n\n    base = (flags & GN_ANY_BASE) ? 0 : (flags & GN_BASE_8) ? 8 :\n                        (flags & GN_BASE_16) ? 16 : 10;\n\n    errno = 0;\n    res = strtol(arg, &endptr, base);\n    if (errno != 0)\n        gnFail(fname, \"strtol() failed\", arg, name);\n\n    if (*endptr != '\\0')\n        gnFail(fname, \"nonnumeric characters\", arg, name);\n\n    if ((flags & GN_NONNEG) && res < 0)\n        gnFail(fname, \"negative value not allowed\", arg, name);\n\n    if ((flags & GN_GT_0) && res <= 0)\n        gnFail(fname, \"value must be > 0\", arg, name);\n\n    return res;\n}\n\nlong\ngetLong(const char *arg, int flags, const char *name)\n{\n    return getNum(\"getLong\", arg, flags, name);\n}\n\nint\ngetInt(const char *arg, int flags, const char *name)\n{\n    long res;\n\n    res = getNum(\"getInt\", arg, flags, name);\n\n    if (res > INT_MAX || res < INT_MIN)\n        gnFail(\"getInt\", \"integer out of range\", arg, name);\n\n    return (int) res;\n}\n     `lib/get_num.c`\n```", "```\n#define _BSD_SOURCE 1\n```", "```\n`$ cc -D_BSD_SOURCE prog.c`\n```", "```\n`$ cc -D_POSIX_SOURCE -D_POSIX_C_SOURCE=199506 \\`\n                                           `-D_BSD_SOURCE -D_SVID_SOURCE prog.c`\n```", "```\n`$ cc -std=c99 -D_XOPEN_SOURCE=600`\n```", "```\ntypedef int pid_t;\n```", "```\npid_t mypid;\n```", "```\npid_t mypid;\n\nmypid = getpid();           /* Returns process ID of calling process */\nprintf(\"My PID is %ld\\n\", (long) mypid);\n```", "```\nstruct sembuf {\n    unsigned short sem_num;         /* Semaphore number */\n    short          sem_op;          /* Operation to be performed */\n    short          sem_flg;         /* Operation flags */\n};\n```", "```\nstruct sembuf s = { 3, -1, SEM_UNDO };\n```", "```\nstruct sembuf s;\n\ns.sem_num = 3;\ns.sem_op  = -1;\ns.sem_flg = SEM_UNDO;\n```", "```\nstruct sembuf s = { .sem_num = 3, .sem_op = -1, .sem_flg = SEM_UNDO };\n```", "```\n#ifdef WCOREDUMP\n    /* Use WCOREDUMP() macro */\n#endif\n```"]