["```\n10.times do |n|\n  puts n\nend\n```", "```\n$ **ruby simple.rb**\n0\n1\n2\n3\n--*snip*--\n```", "```\nalias\nand\nbegin\nbreak\ncase\nclass\n```", "```\n retry:\n last_state = lex_state;\n switch (c = nextc()) {\n```", "```\n  /* white spaces */\ncase ' ': case '\\t': case '\\f': case '\\r':\ncase '\\13': /* '\\v' */\n  space_seen = 1;\n--*snip*--\n  goto retry;\n```", "```\n    require 'ripper'\n    require 'pp'\n    code = <<STR\n    10.times do |n|\n      puts n\n    end\n    STR\n    puts code\n pp Ripper.lex(code)\n```", "```\n    $ **ruby lex1.rb**\n    10.times do |n|\n      puts n\n    end\n [[[1, 0], :on_int, \"10\"],\n    [[1, 2], :on_period, \".\"],\n [[1, 3], :on_ident, \"times\"],\n    [[1, 8], :on_sp, \" \"],\n    [[1, 9], :on_kw, \"do\"],\n    [[1, 11], :on_sp, \" \"],\n    [[1, 12], :on_op, \"|\"],\n    [[1, 13], :on_ident, \"n\"],\n    [[1, 14], :on_op, \"|\"],\n    [[1, 15], :on_ignored_nl, \"\\n\"],\n    [[2, 0], :on_sp, \"  \"],\n    [[2, 2], :on_ident, \"puts\"],\n    [[2, 6], :on_sp, \" \"],\n    [[2, 7], :on_ident, \"n\"],\n    [[2, 8], :on_nl, \"\\n\"],\n    [[3, 0], :on_kw, \"end\"],\n    [[3, 3], :on_nl, \"\\n\"]]\n```", "```\n$ **ruby lex2.rb**\n10.times do |n|\n  puts n/4+6\nend\n--*snip*--\n [[2, 2], :on_ident, \"puts\"],\n [[2, 6], :on_sp, \" \"],\n [[2, 7], :on_ident, \"n\"],\n [[2, 8], :on_op, \"/\"],\n [[2, 9], :on_int, \"4\"],\n [[2, 10], :on_op, \"+\"],\n [[2, 11], :on_int, \"6\"],\n [[2, 12], :on_nl, \"\\n\"],\n--*snip*--\n```", "```\n    $ **ruby lex3.rb**\n    array = []\n    10.times do |n|\n      array << n if n < 5\n    end\n    p array\n    --*snip*--\n     [[3, 2], :on_ident, \"array\"],\n     [[3, 7], :on_sp, \" \"],\n  [[3, 8], :on_op, \"<<\"],\n     [[3, 10], :on_sp, \" \"],\n     [[3, 11], :on_ident, \"n\"],\n     [[3, 12], :on_sp, \" \"],\n     [[3, 13], :on_kw, \"if\"],\n     [[3, 15], :on_sp, \" \"],\n     [[3, 16], :on_ident, \"n\"],\n     [[3, 17], :on_sp, \" \"],\n  [[3, 18], :on_op, \"<\"],\n     [[3, 19], :on_sp, \" \"],\n     [[3, 20], :on_int, \"5\"],\n    --*snip*--\n```", "```\n    require 'ripper'\n    require 'pp'\n    code = <<STR\n 10.times do |n\n      puts n\n    end\n    STR\n    puts code\n    pp Ripper.lex(code)\n```", "```\n$ **ruby lex4.rb**\n10.times do |n\n  puts n\nend\n--*snip*--\n[[[1, 0], :on_int, \"10\"],\n [[1, 2], :on_period, \".\"],\n [[1, 3], :on_ident, \"times\"],\n [[1, 8], :on_sp, \" \"],\n [[1, 9], :on_kw, \"do\"],\n [[1, 11], :on_sp, \" \"],\n [[1, 12], :on_op, \"|\"],\n [[1, 13], :on_ident, \"n\"],\n [[1, 14], :on_nl, \"\\n\"],\n--*snip*--\n```", "```\nSpanishPhrase : me gusta el ruby {\n  printf(\"I like Ruby\\n\");\n}\n```", "```\nSpanishPhrase: VerbAndObject el ruby {\n  printf(\"%s Ruby\\n\", $1);\n};\nVerbAndObject: SheLikes | ILike {\n  $$ = $1;\n};\nSheLikes: le gusta {\n  $$ = \"She likes\";\n}\nILike: me gusta {\n  $$ = \"I like\";\n}\n```", "```\n$ **ruby -y simple.rb**\nStarting parse\nEntering state 0\nReducing stack by rule 1 (line 850):\n-> $$ = nterm @1 ()\nStack now 0\nEntering state 2\nReading a token: Next token is token tINTEGER ()\nShifting token tINTEGER ()\nEntering state 41\nReducing stack by rule 498 (line 4293):\n   $1 = token tINTEGER ()\n-> $$ = nterm numeric ()\nStack now 0 2\nEntering state 109\n--*snip*--\n```", "```\n10.times do |n|\n  puts n\nend\n```", "```\n method_call        :\n    --*snip*--\n          primary_value '.' operation2\n          {\n          /*%%%*/\n              $<num>$ = ruby_sourceline;\n          /*% %*/\n          }\n        opt_paren_args\n          {\n          /*%%%*/\n              $$ = NEW_CALL($1, $3, $5);\n              nd_set_line($$, $<num>4);\n          /*%\n              $$ = dispatch3(call, $1, ripper_id2sym('.'), $3);\n              $$ = method_optarg($$, $5);\n          %*/\n          }\n```", "```\n$$ = NEW_CALL($1, $3, $5);\nnd_set_line($$, $<num>4);\n```", "```\n    require 'ripper'\n    require 'pp'\n    code = <<STR\n    10.times do |n|\n      puts n\n    end\n    STR\n    puts code\n pp Ripper.sexp(code)\n```", "```\n[:program,\n  [[:method_add_block,\n     [:call,\n       [:@int, \"10\", [1, 0]], :\".\",\n       [:@ident, \"times\", [1, 3]]],\n     [:do_block,\n       [:block_var,\n         [:params, [[:@ident, \"n\", [1, 13]]],\n                   nil, nil, nil, nil, nil, nil],\n         false],\n       [[:command,\n          [:@ident, \"puts\", [2, 2]],\n          [:args_add_block, [[:var_ref, [:@ident, \"n\", [2, 7]]]],\n                            false]]]]]]]\n```", "```\n    [[:command,\n    [:@ident, \"puts\", [2, 2]],\n       [:args_add_block, [[:var_ref, [:@ident, \"n\", [2, 7]]]],\n                         false]]]\n```", "```\nrequire 'ripper'\nrequire 'pp'\ncode = <<STR\n2 + 2\nSTR\nputs code\npp Ripper.sexp(code)\n```", "```\n[:program,\n  [[:binary,\n     [:@int, \"2\", [1, 0]],\n     :+,\n     [:@int, \"2\", [1, 4]]]]]\n```", "```\nrequire 'ripper'\nrequire 'pp'\ncode = <<STR\n2 + 2 * 3\nSTR\nputs code\npp Ripper.sexp(code)\n```", "```\n    [:program,\n     [[:binary,\n       [:@int, \"2\", [1, 0]],\n       :+,\n    [:binary,\n         [:@int, \"2\", [1, 4]],\n         :*,\n         [:@int, \"3\", [1, 8]]]]]]\n```", "```\n$ **ruby --dump parsetree your_script.rb**\n```"]