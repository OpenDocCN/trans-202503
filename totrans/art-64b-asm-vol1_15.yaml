- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Macros and the MASM Compile-Time Language
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 宏和MASM编译时语言
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter discusses the MASM compile-time language, including the very important
    *macro expansion facilities*. A *macro* is an identifier that the assembler will
    expand into additional text (often many lines of text), allowing you to abbreviate
    large amounts of code with a single identifier. MASM’s macro facility is actually
    a *computer language inside a computer language*; that is, you can write short
    little programs inside a MASM source file whose purpose is to generate other MASM
    source code to be assembled by MASM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论MASM编译时语言，包括非常重要的*宏展开功能*。*宏*是一个标识符，汇编程序会将其展开成额外的文本（通常是多行文本），允许你通过一个标识符来缩写大量代码。MASM的宏功能实际上是一个*计算机语言中的计算机语言*；也就是说，你可以在MASM源文件中编写小型程序，这些程序的目的是生成其他MASM源代码，然后由MASM进行汇编。
- en: This *language inside a language*, also known as a *compile-time language*,
    consists of macros (the compile-time language equivalent of a procedure), conditionals
    (`if` statements), loops, and other statements. This chapter covers many of the
    MASM compile-time language features and shows how you can use them to reduce the
    effort needed to write assembly language code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*语言中的语言*，也称为*编译时语言*，由宏（编译时语言中的过程等效物）、条件语句（`if`语句）、循环和其他语句组成。本章介绍了MASM编译时语言的许多功能，并展示了如何使用它们来减少编写汇编语言代码的工作量。
- en: 13.1 Introduction to the Compile-Time Language
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 编译时语言简介
- en: MASM is actually two languages rolled into a single program. The *runtime language*
    is the standard x86-64/MASM assembly language you’ve been reading about in all
    the previous chapters. This is called the runtime language because the programs
    you write execute when you run the executable file. MASM contains an interpreter
    for a second language, the MASM *compile-time language (CTL)*. MASM source files
    contain instructions for both the MASM CTL and the runtime program, and MASM executes
    the CTL program during assembly (compilation). Once MASM completes assembly, the
    CTL program terminates (see [Figure 13-1](#figure13-1)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 实际上是将两种语言合并成一个程序。*运行时语言*是你在之前所有章节中阅读到的标准x86-64/MASM汇编语言。这被称为运行时语言，因为你编写的程序在运行可执行文件时执行。MASM包含一个解释器，用于另一种语言，即MASM
    *编译时语言（CTL）*。MASM源文件包含MASM CTL和运行时程序的指令，MASM在汇编（编译）期间执行CTL程序。一旦MASM完成汇编，CTL程序就会终止（参见[图13-1](#figure13-1)）。
- en: '![f13001](image_fi/501089c13/f13001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![f13001](image_fi/501089c13/f13001.png)'
- en: 'Figure 13-1: Compile-time versus runtime execution'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：编译时执行与运行时执行
- en: The CTL application is not a part of the runtime executable that MASM emits,
    although the CTL application can *write* part of the runtime program for you,
    and, in fact, this is the major purpose of the CTL. Using automatic code generation,
    the CTL gives you the ability to easily and elegantly emit repetitive code. By
    learning how to use the MASM CTL and applying it properly, you can develop assembly
    language applications as rapidly as high-level language applications (even faster
    because MASM’s CTL lets you create very high-level-language constructs).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CTL应用程序不是MASM生成的运行时可执行文件的一部分，尽管CTL应用程序可以*为你编写*部分运行时程序，事实上，这就是CTL的主要用途。通过自动代码生成，CTL使你能够轻松而优雅地输出重复的代码。通过学习如何使用MASM
    CTL并正确应用它，你可以像开发高级语言应用程序一样快速开发汇编语言应用程序（甚至更快，因为MASM的CTL让你能够创建非常高级语言的构造）。
- en: 13.2 The echo and .err Directives
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 echo 和 .err 指令
- en: You may recall that Chapter 1 began with the typical first program most people
    write when learning a new language, the “Hello, world!” program. [Listing 13-1](#listing13-1)
    provides the basic “Hello, world!” program written in the MASM compile-time language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得第一章开始时提到的大多数人学习新语言时编写的典型第一个程序——“Hello, world！”程序。[列表13-1](#listing13-1)提供了用MASM编译时语言编写的基本“Hello,
    world！”程序。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: The CTL “Hello, world!” program'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-1：CTL “Hello, world！” 程序
- en: The only CTL statement in this program is the `echo` statement.^([1](#c13-footnote-1))
    The `end` statement is needed just to keep MASM happy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序中的唯一CTL语句是`echo`语句。^([1](#c13-footnote-1)) `end`语句仅仅是为了让MASM保持正常运行。
- en: The `echo` statement displays the textual representation of its argument list
    during the assembly of a MASM program. Therefore, if you compile the preceding
    program with the command
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`语句在汇编MASM程序时显示其参数列表的文本表示。因此，如果你使用以下命令编译前面的程序'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'the MASM assembler will immediately print the following text:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MASM汇编器将立即打印以下文本：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other than displaying the text associated with the `echo` parameter list, the
    `echo` statement has no effect on the assembly of the program. It is invaluable
    for debugging CTL programs, displaying the progress of the assembly, and displaying
    assumptions and default actions that take place during assembly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示与`echo`参数列表相关的文本外，`echo`语句对程序的汇编没有任何影响。它对调试CTL程序非常宝贵，可以显示汇编过程的进度，以及在汇编过程中发生的假设和默认操作。
- en: 'Though assembly language calls to `print` also emit text to the standard output,
    there is a big difference between the following two groups of statements in a
    MASM source file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管汇编语言调用`print`也会将文本输出到标准输出，但在MASM源文件中的以下两组语句之间有一个很大的区别：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first statement prints `"Hello World"` (and a newline) during the assembly
    process and has no effect on the executable program. The last two lines don’t
    affect the assembly process (other than the emission of code to the executable
    file). However, when you run the executable file, the second set of statements
    prints the string `Hello World` followed by a newline sequence.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句在汇编过程中打印`"Hello World"`（并带有换行符），并且对可执行程序没有影响。最后两行不会影响汇编过程（除了将代码输出到可执行文件）。然而，当你运行可执行文件时，第二组语句会打印字符串`Hello
    World`，后面跟着换行符序列。
- en: 'The `.err` directive, like `echo`, will display a string to the console during
    assembly, though this must be a text string (delimited by `<` and `>`). The `.err`
    statement displays the text as part of a MASM error diagnostic. Furthermore, the
    `.err` statement increments the error count, and this will cause MASM to stop
    the assembly (without assembling or linking) after processing the current source
    file. You would normally use the `.err` statement to display an error message
    during assembly if your CTL code discovers something that prevents it from creating
    valid code. For example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`.err`指令，类似于`echo`，将在汇编期间将字符串显示到控制台，但这必须是一个文本字符串（由`<`和`>`界定）。`.err`语句将文本作为MASM错误诊断的一部分显示。此外，`.err`语句还会增加错误计数，这将导致MASM在处理完当前源文件后停止汇编（不进行汇编或链接）。通常，当你的CTL代码发现一些问题，导致它无法生成有效代码时，你会使用`.err`语句在汇编过程中显示错误消息。例如：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 13.3 Compile-Time Constants and Variables
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 编译时常量和变量
- en: 'Just as the runtime language does, the compile-time language supports constants
    and variables. You declare compile-time constants by using the `textequ` or `equ`
    directives. You declare compile-time variables by using the `=` directive (compile-time
    assignment statement). For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运行时语言一样，编译时语言也支持常量和变量。你可以通过使用`textequ`或`equ`指令来声明编译时常量。你可以通过使用`=`指令（编译时赋值语句）来声明编译时变量。例如：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 13.4 Compile-Time Expressions and Operators
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 编译时表达式和运算符
- en: The MASM CTL supports constant expressions in the CTL assignment statement.
    See “MASM Constant Declarations” in Chapter 4 for a discussion of constant expressions
    (which are also the CTL expressions and operators).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MASM CTL支持常量表达式在CTL赋值语句中的使用。有关常量表达式的讨论，请参见第4章中的“MASM常量声明”（这些也是CTL表达式和运算符）。
- en: In addition to the operators and functions appearing in that chapter, MASM includes
    several additional CTL operators, functions, and directives you will find useful.
    The following subsections describe these.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中出现的运算符和函数，MASM还包括一些你会发现有用的额外CTL运算符、函数和指令。以下小节将描述这些内容。
- en: 13.4.1 The MASM Escape (!) Operator
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 MASM转义（!）运算符
- en: The first operator is the `!` operator. When placed in front of another symbol,
    this operator tells MASM to treat that character as text rather than as a special
    symbol. For example, `!;` creates a text constant consisting of the semicolon
    character, rather than a comment that causes MASM to ignore all text after the
    `;` symbol (for C/C++ programmers, this is similar to the backslash escape character,
    `\`, in a string constant).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个运算符是`!`运算符。当它放在另一个符号前面时，MASM会将该字符视为文本，而不是特殊符号。例如，`!;`创建一个由分号字符组成的文本常量，而不是一个注释，后者会导致MASM忽略`；`符号后的所有文本（对于C/C++程序员来说，这类似于字符串常量中的反斜杠转义字符`\`）。
- en: 13.4.2 The MASM Evaluation (%) Operator
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 MASM评估（%）运算符
- en: 'The second useful CTL operator is `%`. The percent operator causes MASM to
    evaluate the expression following it and replace that expression with its value.
    For example, consider the following code sequence:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有用的CTL操作符是`%`。百分号操作符使得MASM评估它后面的表达式，并用该表达式的值替换它。例如，考虑以下代码序列：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you assemble this sequence in an assembly language source file and direct
    MASM to produce an assembly listing, it will report the following for these three
    symbols:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在汇编语言源文件中组装这个序列，并指示MASM生成汇编清单，它会报告以下三个符号：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `num10` is properly reported as a numeric value (decimal 10), `text10` as
    a text symbol (containing the string `10`), and `tn11` as a text symbol (as you
    would expect, because this code sequence uses the `textequ` directive to define
    it). However, rather than containing the string `%num10 + 1`, MASM evaluates the
    expression `num10 + 1` to produce the numeric value 11, which MASM then converts
    to text data. (By the way, to put a percent sign in a text string, use the text
    sequence `<!%>`.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`num10`被正确地报告为数值（十进制10），`text10`被报告为文本符号（包含字符串`10`），而`tn11`被报告为文本符号（正如你所预期的，因为该代码序列使用`textequ`指令来定义它）。然而，MASM不会包含字符串`%num10
    + 1`，而是评估表达式`num10 + 1`，产生数值11，然后将其转换为文本数据。（顺便说一下，若要在文本字符串中放置百分号，请使用文本序列`<!%>`。）'
- en: If you place the `%` operator in the first column of a source line, MASM will
    translate all numeric expressions on that line to textual form. This is handy
    with the `echo` directive. It causes `echo` to display the value of numeric equates
    rather than simply displaying the equate names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`%`操作符放在源代码行的第一列，MASM将把该行的所有数值表达式转换为文本形式。这在使用`echo`指令时很有用。它使得`echo`显示数值常量的值，而不仅仅是显示常量的名称。
- en: 13.4.3 The catstr Directive
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 `catstr`指令
- en: 'The `catstr` function has the following syntax:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`catstr`函数具有以下语法：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The identifier is an (up to this point) undefined symbol. The `string1` and
    `string2` operands are textual data surrounded by `<` and `>` symbols. This statement
    stores the concatenation of the two strings into `identifier`. Note that `identifier`
    is a text object, not a string object. If you specify the identifier in your code,
    MASM will substitute the text string for the identifier and try to process that
    text data as though it were part of your source code input.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`identifier`是一个（直到此时）未定义的符号。`string1`和`string2`操作数是被`<`和`>`符号包围的文本数据。这个语句将把两个字符串的连接结果存储到`identifier`中。请注意，`identifier`是一个文本对象，而不是字符串对象。如果你在代码中指定该标识符，MASM会用文本字符串替换标识符，并尝试将该文本数据作为源代码的一部分进行处理。'
- en: 'The `catstr` statement allows two or more operands separated by commas. The
    `catstr` directive will concatenate the text values in the order they appear in
    the operand field. The following statement generates the textual data `Hello,
    World!`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`catstr`语句允许两个或更多用逗号分隔的操作数。`catstr`指令将按照它们在操作数字段中出现的顺序连接文本值。以下语句生成文本数据`Hello,
    World!`：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Two exclamation marks are necessary in this example, because `!` is an operator
    telling MASM to treat the next symbol as text rather than as an operator. With
    only one `!` symbol, MASM thinks that you’re attempting to include a `>` symbol
    as part of the string and reports an error (because there is no closing `>`).
    Putting `!!` in the text string tells MASM to treat the second `!` symbol as a
    text character.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中需要使用两个感叹号，因为`!`是一个操作符，告诉MASM将下一个符号视为文本而非操作符。只有一个`!`符号时，MASM会认为你尝试将`>`符号包含为字符串的一部分，并报告错误（因为没有关闭的`>`符号）。在文本字符串中使用`!!`告诉MASM将第二个`!`符号视为文本字符。
- en: 13.4.4 The instr Directive
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.4 `instr`指令
- en: The `instr` directive searches for the presence of one string within another.
    The syntax for the directive is
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`instr`指令用于在一个字符串中查找另一个字符串的存在。该指令的语法是'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'where `identifier` is a symbol into which MASM will put the offset of the `search`
    string within the `source` string. The search begins at position `start` within
    `source`. Unconventionally, the first character in `source` has the position 1
    (not 0). The following example searches for `World` within the string `Hello World`
    (starting at character position 1, which is the index of the `H` character):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`identifier`是一个符号，MASM将在其中放入`search`字符串在`source`字符串中的偏移量。搜索从`source`中的`start`位置开始。不同于常规，`source`中的第一个字符的位置是1（而不是0）。以下示例在字符串`Hello
    World`中搜索`World`（从字符位置1开始，即`H`字符的索引）：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This statement defines `WorldPosn` as a number with the value 7 (as the string
    `World` is at position 7 in `Hello World` if you start counting from position
    1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句将 `WorldPosn` 定义为值为 7 的数字（因为如果从位置 1 开始计数，字符串 `World` 在 `Hello World` 中的位置是
    7）。
- en: 13.4.5 The sizestr Directive
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.5 `sizestr` 指令
- en: The `sizestr` directive computes the length of a string.^([2](#c13-footnote-2))
    The syntax for the directive is
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizestr` 指令计算字符串的长度。^([2](#c13-footnote-2)) 该指令的语法为：'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where `identifier` is the symbol into which MASM will store the string’s length,
    and `string` is the string literal whose length this directive computes. As an
    example,
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`identifier` 是 MASM 将存储字符串长度的符号，`string` 是该指令计算其长度的字符串字面量。举个例子，
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: defines the symbol `hwLen` as a number and sets it to the value 11.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号 `hwLen` 定义为一个数字，并将其值设为 11。
- en: 13.4.6 The substr Directive
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.6 `substr` 指令
- en: The `substr` directive extracts a substring from a larger string. The syntax
    for this directive is
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr` 指令从较大的字符串中提取子字符串。该指令的语法为：'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where `identifier` is the symbol that MASM will create (type `TEXT`, initialized
    with the substring characters), `source` is the source string from which MASM
    will extract the substring, `start` is the starting position in the string to
    begin the extraction, and `len` is the length of the substring to extract. The
    `len` operand is optional; if it is absent, MASM will assume you want to use the
    remainder of the string (starting at position `start`) for the substring. Here’s
    an example that extracts `Hello` from the string `Hello World`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`identifier` 是 MASM 将创建的符号（类型为 `TEXT`，初始化为子字符串字符），`source` 是 MASM 从中提取子字符串的源字符串，`start`
    是从字符串中开始提取的起始位置，`len` 是要提取的子字符串的长度。`len` 操作数是可选的；如果未指定，MASM 会假定你想要使用从 `start`
    位置开始的字符串剩余部分作为子字符串。以下是一个从字符串 `Hello World` 中提取 `Hello` 的示例：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 13.5 Conditional Assembly (Compile-Time Decisions)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 条件汇编（编译时决策）
- en: MASM’s compile-time language provides an if statement, `if`, that lets you make
    decisions at assembly time. The `if` statement has two main purposes. The traditional
    use of `if` is to support *conditional assembly*, allowing you to include or exclude
    code during an assembly, depending on the status of various symbols or constant
    values in your program. The second use is to support the standard if-statement
    decision-making process in the MASM compile-time language. This section discusses
    these two uses for the MASM `if` statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 的编译时语言提供了一个 `if` 语句，它让你在汇编时做出决策。`if` 语句有两个主要用途。`if` 的传统用法是支持 *条件汇编*，根据程序中各种符号或常量值的状态，在汇编过程中决定是否包含或排除代码。第二个用途是支持
    MASM 编译时语言中的标准 `if` 语句决策过程。本节将讨论这两个 `if` 语句的用途。
- en: 'The simplest form of the MASM compile-time `if` statement uses the following
    syntax:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 编译时 `if` 语句的最简单形式使用以下语法：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At compile time, MASM evaluates the expression after the `if`. This must be
    a constant expression that evaluates to an integer value. If the expression evaluates
    to true (nonzero), MASM continues to process the text in the source file as though
    the `if` statement were not present. However, if the expression evaluates to false
    (zero), MASM treats all the text between the `if` and the corresponding `endif`
    clause as though it were a comment (that is, it ignores this text), as shown in
    [Figure 13-2](#figure13-2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，MASM 会评估 `if` 后面的表达式。该表达式必须是一个常量表达式，且结果为整数值。如果该表达式的值为真（非零），MASM 会继续处理源文件中的文本，就像
    `if` 语句不存在一样。然而，如果表达式的值为假（零），MASM 会将 `if` 和对应的 `endif` 子句之间的所有文本视为注释（即忽略这些文本），如图
    [13-2](#figure13-2) 所示。
- en: '![f13002](image_fi/501089c13/f13002.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f13002](image_fi/501089c13/f13002.png)'
- en: 'Figure 13-2: Operation of a MASM compile-time `if` statement'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2：MASM 编译时 `if` 语句的操作
- en: The identifiers in a compile-time expression must all be constant identifiers
    or a MASM compile-time function call (with appropriate parameters). Because MASM
    evaluates these expressions at assembly time, they cannot contain runtime variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时表达式中的标识符必须是常量标识符或 MASM 编译时函数调用（具有适当的参数）。因为 MASM 在汇编时评估这些表达式，所以它们不能包含运行时变量。
- en: 'The MASM `if` statement supports optional `elseif` and `else` clauses that
    behave in an intuitive fashion. The complete syntax for the `if` statement looks
    like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 的 `if` 语句支持可选的 `elseif` 和 `else` 子句，这些子句的行为直观易懂。`if` 语句的完整语法如下：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the first Boolean expression evaluates to true, MASM processes the text up
    to the `elseif` clause. It then skips all text (that is, treats it like a comment)
    until it encounters the `endif` clause. MASM continues processing the text after
    the `endif` clause in the normal fashion.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个布尔表达式的值为真，MASM 会处理直到 `elseif` 子句的文本。然后它会跳过所有文本（即将其视为注释），直到遇到 `endif` 子句。MASM
    会在 `endif` 子句之后按正常方式继续处理文本。
- en: If the first Boolean expression evaluates to false, MASM skips all the text
    until it encounters an `elseif`, `else`, or `endif` clause. If it encounters an
    `elseif` clause (as in the preceding example), MASM evaluates the Boolean expression
    associated with that clause. If it evaluates to true, MASM processes the text
    between the `elseif` and the `else` clauses (or to the `endif` clause if the `else`
    clause is not present). If, during the processing of this text, MASM encounters
    another `elseif` or, as in the preceding example, an `else` clause, then MASM
    ignores all further text until it finds the corresponding `endif`. If both the
    first and second Boolean expressions in the previous example evaluate to false,
    MASM skips their associated text and begins processing the text in the `else`
    clause.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个布尔表达式的值为假，MASM 会跳过所有文本，直到遇到 `elseif`、`else` 或 `endif` 子句。如果遇到 `elseif`
    子句（如前面的例子），MASM 会评估与该子句相关联的布尔表达式。如果该表达式的值为真，MASM 会处理 `elseif` 和 `else` 子句之间的文本（或者如果没有
    `else` 子句，则处理到 `endif` 子句）。如果在处理该文本时，MASM 遇到另一个 `elseif` 或如前所述的 `else` 子句，MASM
    将忽略所有后续文本，直到找到相应的 `endif`。如果前面例子中的第一个和第二个布尔表达式的值都为假，MASM 将跳过它们关联的文本，开始处理 `else`
    子句中的文本。
- en: You can create a nearly infinite variety of `if` statement sequences by including
    zero or more `elseif` clauses and optionally supplying the `else` clause.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过包含零个或多个 `elseif` 子句，并根据需要提供 `else` 子句，创建几乎无限种的 `if` 语句序列。
- en: 'A traditional use of conditional assembly is to develop software that you can
    easily configure for several environments. For example, the `fcomip` instruction
    makes floating-point comparisons easy, but this instruction is available only
    on Pentium Pro and later processors. To use this instruction on the processors
    that support it and fall back to the standard floating-point comparison on the
    older processors, most engineers use conditional assembly to embed the separate
    sequences in the same source file (instead of writing and maintaining two versions
    of the program). The following example demonstrates how to do this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 条件汇编的传统用途之一是开发可以轻松配置为多个环境的软件。例如，`fcomip` 指令使得浮点比较变得简单，但该指令仅在 Pentium Pro 及更高版本的处理器上可用。为了在支持此指令的处理器上使用它，并在较旧的处理器上回退到标准浮点比较，大多数工程师使用条件汇编将不同的指令序列嵌入到同一个源文件中（而不是编写和维护两个版本的程序）。以下示例演示了如何做到这一点：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As currently written, this code fragment will compile the three-instruction
    sequence in the `else` clause and ignore the code between the `if` and `else`
    clauses (because the constant `PentProOrLater` is false). By changing the value
    of `PentProOrLater` to true, you can tell MASM to compile the single `fcomip`
    instruction rather than the three-instruction sequence.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如当前编写的代码片段，将编译 `else` 子句中的三条指令，并忽略 `if` 和 `else` 子句之间的代码（因为常量 `PentProOrLater`
    为假）。通过将 `PentProOrLater` 的值更改为真，你可以告诉 MASM 编译单条 `fcomip` 指令，而不是三条指令序列。
- en: 'Though you need to maintain only a single source file, conditional assembly
    does not let you create a single *executable* that runs efficiently on all processors.
    When using this technique, you will still have to create two executable programs
    (one for Pentium Pro and later processors, one for the earlier processors) by
    compiling your source file twice: during the first assembly, you must set the
    `PentProOrLater` constant to false; during the second assembly, you must set it
    to true.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你只需维护一个源文件，但条件汇编并不能让你创建一个在所有处理器上都能高效运行的单一 *可执行文件*。使用这种技术时，你仍然需要创建两个可执行程序（一个用于
    Pentium Pro 及更高版本的处理器，一个用于早期的处理器），通过编译源文件两次：第一次汇编时，你必须将 `PentProOrLater` 常量设置为假；第二次汇编时，你必须将其设置为真。
- en: 'If you are familiar with conditional assembly in other languages, such as C/C++,
    you may be wondering if MASM supports a statement like C’s `#ifdef` statement.
    The answer is yes, it does. Consider the following modification to the preceding
    code that uses this directive:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他语言中的条件汇编，如 C/C++，你可能会想知道 MASM 是否支持类似 C 的 `#ifdef` 语句。答案是肯定的，它支持。请考虑以下对前面代码的修改，使用了该指令：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another common use of conditional assembly is to introduce debugging and testing
    code into your programs. A typical debugging technique that many MASM programmers
    use is to insert print statements at strategic points throughout their code; this
    enables them to trace through their code and display important values at various
    checkpoints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 条件汇编的另一个常见用途是将调试和测试代码引入您的程序。许多MASM程序员使用的一种典型调试技巧是在代码中的关键点插入打印语句；这使得他们能够跟踪代码并在各个检查点显示重要的值。
- en: 'A big problem with this technique, however, is that they must remove the debugging
    code prior to completing the project. Two further problems are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术的一个大问题是，在完成项目之前，必须删除调试代码。还有两个进一步的问题如下：
- en: Programmers often forget to remove some debugging statements, and this creates
    defects in the final program.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员常常忘记删除一些调试语句，这会在最终程序中产生缺陷。
- en: After removing a debugging statement, these programmers often discover that
    they need that same statement to debug a different problem at a later time. Hence,
    they are constantly inserting and removing the same statements over and over again.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除调试语句后，这些程序员常常发现他们在稍后的某个时刻需要这个语句来调试另一个问题。因此，他们不断地插入和删除相同的语句。
- en: 'Conditional assembly can provide a solution to this problem. By defining a
    symbol (say, `debug`) to control debugging output in your program, you can activate
    or deactivate *all* debugging output by modifying a single line of source code.
    The following code fragment demonstrates this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 条件汇编可以为此问题提供解决方案。通过定义一个符号（比如`debug`）来控制程序中的调试输出，您可以通过修改一行源代码来启用或禁用*所有*调试输出。以下代码片段演示了这一点：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As long as you surround all debugging output statements with an `if` statement
    like the preceding one, you don’t have to worry about debugging output accidentally
    appearing in your final application. By setting the `debug` symbol to false, you
    can automatically disable all such output. Likewise, you don’t have to remove
    all your debugging statements from your programs after they’ve served their immediate
    purpose. By using conditional assembly, you can leave these statements in your
    code because they are so easy to deactivate. Later, if you decide you need to
    view this same debugging information during assembly, you can reactivate it by
    setting the `debug` symbol to true.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您将所有调试输出语句用如上所述的`if`语句包围，就不必担心调试输出会意外出现在最终应用程序中。通过将`debug`符号设置为false，您可以自动禁用所有这些输出。同样，在调试语句完成即时目的后，您也不必将它们从程序中删除。通过使用条件汇编，您可以将这些语句保留在代码中，因为它们非常容易被禁用。以后，如果您决定在汇编过程中需要查看这些调试信息，您可以通过将`debug`符号设置为true重新启用它。
- en: Although program configuration and debugging control are two of the more common,
    traditional uses for conditional assembly, don’t forget that the `if` statement
    provides the basic conditional statement in the MASM CTL. You will use the `if`
    statement in your compile-time programs the same way you would use an `if` statement
    in MASM or another language. Later sections in this chapter present lots of examples
    of using the `if` statement in this capacity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序配置和调试控制是条件汇编的两个常见的传统用途，但不要忘记，`if`语句提供了MASM CTL中的基本条件语句。您将在编译时程序中像使用MASM或其他语言中的`if`语句一样使用`if`语句。本章后续部分将展示大量使用`if`语句的示例。
- en: 13.6 Repetitive Assembly (Compile-Time Loops)
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 重复汇编（编译时循环）
- en: MASM’s `while..endm`, `for..endm`, and `forc..endm` statements provide compile-time
    loop constructs.^([3](#c13-footnote-3)) The `while` statement tells MASM to process
    the same sequence of statements repetitively during assembly. This is handy for
    constructing data tables as well as providing a traditional looping structure
    for compile-time programs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MASM的`while..endm`、`for..endm`和`forc..endm`语句提供了编译时循环结构。^([3](#c13-footnote-3))
    `while`语句指示MASM在汇编期间重复处理相同的语句序列。这对于构建数据表以及为编译时程序提供传统的循环结构非常有用。
- en: 'The `while` statement uses the following syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句使用以下语法：'
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When MASM encounters the `while` statement during assembly, it evaluates the
    constant Boolean expression. If the expression evaluates to false, MASM will skip
    over the text between the `while` and the `endm` clauses (the behavior is similar
    to the `if` statement if the expression evaluates to false). If the expression
    evaluates to true, MASM will process the statements between the `while` and `endm`
    clauses and then “jump back” to the start of the `while` statement in the source
    file and repeat this process, as shown in [Figure 13-3](#figure13-3).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MASM 在汇编过程中遇到 `while` 语句时，它会评估常量布尔表达式。如果表达式的结果为假，MASM 会跳过 `while` 和 `endm`
    之间的文本（这种行为类似于 `if` 语句在表达式结果为假时的处理）。如果表达式的结果为真，MASM 会处理 `while` 和 `endm` 之间的语句，然后“跳回”源文件中的
    `while` 语句开始处，并重复这个过程，如 [Figure 13-3](#figure13-3) 所示。
- en: '![f13003](image_fi/501089c13/f13003.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f13003](image_fi/501089c13/f13003.png)'
- en: 'Figure 13-3: MASM compile-time `while` statement operation'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：MASM 编译时 `while` 语句操作
- en: To understand how this process works, consider the program in [Listing 13-2](#listing13-2).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程是如何工作的，考虑一下 [Listing 13-2](#listing13-2) 中的程序。
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 13-2: `w``hile``..``endm` demonstration'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-2：`w``hile``..``endm` 演示
- en: 'Here’s the build command and program output for [Listing 13-2](#listing13-2):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [Listing 13-2](#listing13-2) 的构建命令和程序输出：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `while` loop repeats five times during assembly. On each repetition of the
    loop, the MASM assembler processes the statements between the `while` and `endm`
    directives. Therefore, the preceding program is really equivalent to the code
    fragment shown in [Listing 13-3](#listing13-3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环在汇编过程中会重复五次。每次循环时，MASM 汇编器会处理 `while` 和 `endm` 指令之间的语句。因此，前面的程序实际上等价于
    [Listing 13-3](#listing13-3) 中显示的代码片段。'
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 13-3: Program equivalent to the code in [Listing 13-2](#listing13-2)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-3：与 [Listing 13-2](#listing13-2) 中的代码等价的程序
- en: As you can see in this example, the `while` statement is convenient for constructing
    repetitive-code sequences, especially for unrolling loops.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这个例子中看到的，`while` 语句对于构建重复代码序列非常方便，尤其是对于展开循环。
- en: 'MASM provides two forms of the `for..endm` loop. These two loops take the following
    general form:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 提供了两种形式的 `for..endm` 循环。这两种循环的一般形式如下：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first form of the `for` loop (plain `for`) repeats the code once for each
    of the arguments specified between the `<` and `>` brackets. On each repetition
    of the loop, it sets `identifier` to the text of the current argument: on the
    first iteration of the loop, `identifier` is set to `arg1`, and on the second
    iteration it is set to `arg2`, and so on, until the last iteration, when it is
    set to `argn`. For example, the following `for` loop will generate code that pushes
    the RAX, RBX, RCX, and RDX registers onto the stack:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种 `for` 循环形式（普通 `for`）会对指定的 `<` 和 `>` 括号之间的每个参数执行一次代码。在每次循环重复时，它会将 `identifier`
    设置为当前参数的文本：在第一次循环时，`identifier` 被设置为 `arg1`，第二次循环时设置为 `arg2`，以此类推，直到最后一次循环时，`identifier`
    被设置为 `argn`。例如，下面的 `for` 循环会生成将 RAX、RBX、RCX 和 RDX 寄存器压入栈中的代码：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This `for` loop is equivalent to the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `for` 循环等价于以下代码：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `forc` compile-time loop repeats the body of its loop for each character
    appearing in the string specified by the second argument. For example, the following
    `forc` loop generates a hexadecimal byte value for each character in the string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`forc` 编译时循环会对第二个参数指定的字符串中的每个字符重复其循环体。例如，下面的 `forc` 循环会为字符串中的每个字符生成一个十六进制字节值：'
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `for` loop will turn out to be a lot more useful than `forc`. Nevertheless,
    `forc` is handy on occasion. Most of the time when you’re using these loops, you’ll
    be passing them a variable set of arguments rather than a fixed string. As you’ll
    soon see, these loops are handy for processing macro parameters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环比 `forc` 循环更为有用。不过，`forc` 在某些情况下还是很方便的。大多数情况下，当你使用这些循环时，你会传递一组可变的参数，而不是一个固定的字符串。正如你很快会看到的，这些循环对于处理宏参数非常有用。'
- en: 13.7 Macros (Compile-Time Procedures)
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 宏（编译时过程）
- en: '*Macros* are objects that a language processor replaces with other text during
    compilation. Macros are great devices for replacing long, repetitive sequences
    of text with much shorter sequences of text. In addition to the traditional role
    that macros play (for example, `#define` in C/C++), MASM’s macros also serve as
    the equivalent of a compile-time language procedure or function.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏*是语言处理器在编译过程中用其他文本替换的对象。宏是替换长且重复的文本序列为更短文本序列的绝佳工具。除了宏的传统角色（例如，C/C++中的`#define`），MASM的宏还充当了类似编译时语言过程或函数的功能。'
- en: Macros are one of MASM’s main features. The following sections explore MASM’s
    macro-processing facilities and the relationship between macros and other MASM
    CTL control constructs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是MASM的主要功能之一。接下来的章节将探讨MASM的宏处理功能以及宏与其他MASM CTL控制结构之间的关系。
- en: 13.8 Standard Macros
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 标准宏
- en: 'MASM supports a straightforward macro facility that lets you define macros
    in a manner that is similar to declaring a procedure. A typical, simple macro
    declaration takes the following form:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: MASM支持一种简单直接的宏机制，允许你以类似声明过程的方式定义宏。一个典型的简单宏声明如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code is a concrete example of a macro declaration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是宏声明的具体示例：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Execution of this macro’s code will compute the two’s complement of the 128-bit
    value in RDX:RAX (see the description of extended-precision `neg` in “Extended-Precision
    Negation Operations” in Chapter 8).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此宏的代码将计算RDX:RAX中128位值的二补数（参见第8章中“扩展精度负值操作”部分的`neg`描述）。
- en: 'To execute the code associated with `neg128`, you specify the macro’s name
    at the point you want to execute these instructions. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行与`neg128`相关的代码，你需要在希望执行这些指令的地方指定宏的名称。例如：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This intentionally looks just like any other instruction; the original purpose
    of macros was to create synthetic instructions to simplify assembly language programming.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来故意像是任何其他指令；宏的原始目的是创建合成指令，以简化汇编语言编程。
- en: 'Though you don’t need to use a `call` instruction to invoke a macro, from the
    point of view of your program, invoking a macro executes a sequence of instructions
    just like calling a procedure. You could implement this simple macro as a procedure
    by using the following procedure declaration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你不需要使用`call`指令来调用宏，从程序的角度来看，调用宏执行的指令序列就像调用过程一样。你可以通过以下过程声明将此简单宏实现为过程：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following two statements will both negate the value in RDX:RAX:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个语句都将使RDX:RAX中的值取反：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The difference between these two (the macro invocation versus the procedure
    call) is that macros expand their text inline, whereas a procedure call emits
    a call to the corresponding procedure elsewhere in the text. That is, MASM replaces
    the invocation `neg128` directly with the following text:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别（宏调用与过程调用）在于，宏会将其文本内联展开，而过程调用则会发出对文本中其他地方相应过程的调用。也就是说，MASM会将`neg128`的调用直接替换为以下文本：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On the other hand, MASM replaces the procedure `call neg128p` with the machine
    code for the `call` instruction:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MASM会将过程`call neg128p`替换为`call`指令的机器码：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should choose macro versus procedure call based on efficiency. Macros are
    slightly faster than procedure calls because you don’t execute the `call` and
    corresponding `ret` instructions, but they can make your program larger because
    a macro invocation expands to the text of the macro’s body on each invocation.
    If the macro body is large and you invoke the macro several times throughout your
    program, it will make your final executable much larger. Also, if the body of
    your macro executes more than a few simple instructions, the overhead of a `call`
    and `ret` sequence has little impact on the overall execution time of the code,
    so the execution time savings are nearly negligible. On the other hand, if the
    body of a procedure is very short (like the preceding `neg128` example), the macro
    implementation can be faster and doesn’t expand the size of your program by much.
    A good rule of thumb is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据效率来选择宏调用还是过程调用。宏比过程调用稍快，因为你不需要执行`call`和相应的`ret`指令，但它们可能会使你的程序变大，因为每次宏调用都会展开为宏体的文本。如果宏体很大，而且你在程序中多次调用该宏，那么它将使最终的可执行文件变得更大。此外，如果宏体执行的指令超过几个简单指令，`call`和`ret`指令序列的开销对整体执行时间的影响较小，因此执行时间的节省几乎可以忽略不计。另一方面，如果过程的主体非常短（像前面的`neg128`示例），宏实现可能会更快，并且不会显著增加程序的大小。一个好的经验法则如下：
- en: Use *macros* for short, time-critical program units. Use *procedures* for longer
    blocks of code and when execution time is not as critical.
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于短小且时间关键的程序单元，使用*宏*。对于较长的代码块并且执行时间不那么关键时，使用*过程*。
- en: Macros have many other disadvantages over procedures. Macros cannot have local
    (automatic) variables, macro parameters work differently than procedure parameters,
    macros don’t support (runtime) recursion, and macros are a little more difficult
    to debug than procedures (just to name a few disadvantages). Therefore, you shouldn’t
    really use macros as a substitute for procedures except when performance is absolutely
    critical.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于过程，宏有许多其他缺点。宏不能拥有局部（自动）变量，宏参数的工作方式与过程参数不同，宏不支持（运行时）递归，而且调试宏比过程更为困难（仅举几个缺点）。因此，除非性能至关重要，否则你不应将宏作为过程的替代品。
- en: 13.9 Macro Parameters
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 宏参数
- en: Like procedures, macros allow you to define *parameters* that let you supply
    different data on each macro invocation, which lets you write generic macros whose
    behavior can vary depending on the parameters you supply. By processing these
    macro parameters at compile time, you can write sophisticated macros.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 像过程一样，宏允许你定义*参数*，使你能够在每次宏调用时提供不同的数据，这让你可以编写通用宏，其行为可以根据你提供的参数而变化。通过在编译时处理这些宏参数，你可以编写复杂的宏。
- en: 'Macro parameter declaration syntax is straightforward. You supply a list of
    parameter names as the operands in a macro declaration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 宏参数声明语法很简单。你需要在宏声明中提供一个参数名称列表，作为操作数：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When you invoke a macro, you supply the actual parameters as arguments to the
    macro invocation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用宏时，作为参数传递实际的参数值：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 13.9.1 Standard Macro Parameter Expansion
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.1 标准宏参数展开
- en: MASM automatically associates the type `text` with macro parameters. This means
    that during a macro expansion, MASM substitutes the text you supply as the actual
    parameter everywhere the formal parameter name appears. The semantics of *pass
    by textual substitution* are a little different from *pass by value* or *pass
    by reference*, so exploring those differences here is worthwhile.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MASM自动将类型`text`与宏参数关联。这意味着在宏展开过程中，MASM会将你提供的文本替代为实际参数，并在所有出现形式参数名称的地方替换。*按文本替换传递*的语义与*按值传递*或*按引用传递*略有不同，因此在这里探讨这些差异是很有价值的。
- en: 'Consider the following macro invocations, using the `neg128` macro from the
    previous section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下宏调用，使用前面章节中的`neg128`宏：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These two invocations expand into the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用展开成以下代码：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Macro invocations do not make a local copy of the parameters (as *pass by value*
    does), nor do they pass the address of the actual parameter to the macro. Instead,
    a macro invocation of the form `neg128 rdx, rax` is equivalent to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 宏调用不会像*值传递*那样创建参数的局部副本，也不会将实际参数的地址传递给宏。相反，形式为`neg128 rdx, rax`的宏调用等价于以下内容：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The text objects immediately expand their string values inline, producing the
    former expansion for `neg128 rdx, rax`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 文本对象会立即将其字符串值展开为内联文本，产生`neg128 rdx, rax`的前述展开。
- en: 'Macro parameters are not limited to memory, register, or constant operands
    as are instruction or procedure operands. Any text is fine as long as its expansion
    is legal wherever you use the formal parameter. Similarly, formal parameters may
    appear anywhere in the macro body, not just where memory, register, or constant
    operands are legal. Consider the following macro declaration and sample invocations
    that demonstrate how you can expand a formal parameter into a whole instruction:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 宏参数不限于内存、寄存器或常量操作数，就像指令或过程操作数一样。只要其扩展在任何使用正式参数的地方都是合法的，任何文本都是可以的。同样，正式参数可以出现在宏体中的任何位置，而不仅仅是内存、寄存器或常量操作数合法的位置。考虑以下宏声明和示例调用，它们展示了如何将一个正式参数扩展为一个完整的指令：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `<` and `>` brackets to treat the full `cmp` and `test` instructions
    as a single string (normally, the comma in these instructions would split them
    into two macro parameters).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `<` 和 `>` 括号将完整的 `cmp` 和 `test` 指令视为一个单一字符串（通常，这些指令中的逗号会将它们拆分为两个宏参数）。
- en: 'In general, MASM assumes that all text between commas constitutes a single
    macro parameter. If MASM encounters any opening bracketing symbols (left parentheses,
    left braces, or left angle brackets), then it will include all text up to the
    appropriate closing symbol, ignoring any commas that may appear within the bracketing
    symbols. Of course, MASM does not consider commas (and bracketing symbols) within
    a string constant as the end of an actual parameter. So the following macro and
    invocation are perfectly legal:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，MASM 假设所有逗号之间的文本构成一个单一的宏参数。如果 MASM 遇到任何开括号符号（左括号、左大括号或左尖括号），它将包括所有文本直到适当的闭括号符号，忽略括号符号内可能出现的逗号。当然，MASM
    不会将字符串常量中的逗号（和括号符号）视为实际参数的结束。所以以下宏和调用是完全合法的：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: MASM treats the string `Hello, world!` as a single parameter because the comma
    appears inside a literal string constant, just as your intuition suggests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 将字符串 `Hello, world!` 作为一个单独的参数处理，因为逗号出现在字面量字符串常量中，就像你的直觉所示的那样。
- en: 'You can run into some issues when MASM expands your macro parameters, because
    parameters are expanded as text, not values. Consider the following macro declaration
    and invocation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MASM 扩展你的宏参数时，可能会遇到一些问题，因为参数是作为文本而不是值进行扩展的。考虑以下宏声明和调用：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This example displays `Hello` five times during assembly rather than the eight
    times you might intuitively expect. This is because the preceding `while` statement
    expands to
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在汇编期间显示 `Hello` 五次，而不是你直觉上可能期望的八次。这是因为前面的 `while` 语句扩展为
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The actual parameter for `n` is `3 + 1`; because MASM expands this text directly
    in place of `n`, you get an erroneous text expansion. At compile time MASM computes
    `3 + 1 * 2` as the value 5 rather than as the value 8 (which you would get if
    the MASM passed this parameter by value rather than by textual substitution).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` 的实际参数是 `3 + 1`；因为 MASM 将这个文本直接替换到 `n` 位置，所以你会得到一个错误的文本扩展。在编译时，MASM 计算 `3
    + 1 * 2` 的值为 5，而不是值 8（如果 MASM 按值传递该参数，而不是通过文本替换传递的话，你会得到值 8）。'
- en: 'The common solution to this problem when passing numeric parameters that may
    contain compile-time expressions is to surround the formal parameter in the macro
    with parentheses; for example, you would rewrite the preceding macro as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递可能包含编译时表达式的数字参数时，解决这个问题的常见方法是将宏中的正式参数用括号括起来；例如，你可以将前面的宏重写为：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, the invocation expands to the following code that produces the intuitive
    result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用扩展为以下代码，产生直观的结果：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you don’t have control over the macro definition (perhaps it’s part of a
    library module you use, and you can’t change the macro definition because doing
    so could break existing code), there is another solution to this problem: use
    the MASM `%` operator before the argument in the macro invocation so that the
    CTL interpreter evaluates the expression before expanding the parameters. For
    example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法控制宏的定义（可能它是你使用的库模块的一部分，你不能更改宏定义，因为这样做可能会破坏现有代码），还有一个解决此问题的方法：在宏调用中的参数前使用
    MASM `%` 运算符，以便 CTL 解释器在扩展参数之前先计算表达式。例如：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will cause MASM to properly generate eight calls to the `print` procedure
    (and associated data).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 MASM 正确地生成八次对 `print` 过程的调用（及相关数据）。
- en: 13.9.2 Optional and Required Macro Parameters
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.2 可选和必需的宏参数
- en: As a general rule, MASM treats macro arguments as optional arguments. If you
    define a macro that specifies two arguments and invoke that argument with only
    one argument, MASM will not (normally) complain about the invocation. Instead,
    it will simply substitute the empty string for the expansion of the second argument.
    In some cases, this is acceptable and possibly even desirable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，MASM 会将宏参数视为可选参数。如果你定义一个需要两个参数的宏，并且只传递一个参数来调用该宏，MASM 通常不会对该调用提出警告。相反，它会简单地将空字符串替代第二个参数的扩展。有些情况下，这种做法是可以接受的，甚至可能是期望的。
- en: 'However, suppose you left off the second parameter in the `neg128` macro given
    earlier. That would compile to a `neg` instruction with a missing operand and
    MASM would report an error; for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你在前面的 `neg128` 宏中省略了第二个参数。那样会编译成一个缺少操作数的 `neg` 指令，MASM 会报告错误；例如：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s the error that MASM reports:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MASM报告的错误：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `(12)` is telling us that the error occurred on line 12 in the source file.
    The `neg128(2)` line is telling us that the error occurred on line 2 of the `neg128`
    macro. It’s a bit difficult to see what is actually causing the problem here.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`(12)` 表示错误发生在源文件的第12行。`neg128(2)` 行表示错误发生在 `neg128` 宏的第2行。这里有点难以看出究竟是什么导致了问题。'
- en: 'One solution is to use conditional assembly inside the macro to test for the
    presence of both parameters. At first, you might think you could use code like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在宏内部使用条件汇编来测试两个参数是否都存在。起初，你可能认为可以使用如下代码：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unfortunately, this fails for a couple of reasons. First of all, the `eq` operator
    doesn’t work with text operands. MASM will expand the text operands before attempting
    to apply this operator, so the `if` statement in the preceding example effectively
    becomes
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方式失败了，原因有几个。首先，`eq` 运算符不能与文本操作数一起使用。MASM 会在尝试应用该运算符之前扩展文本操作数，因此前面示例中的
    `if` 语句实际上变成了
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: because MASM substitutes the empty string for both the operands around the `eq`
    operator. This, of course, generates a syntax error. Even if there were non-blank
    textual operands around the `eq` operator, this would still fail because `eq`
    expects numeric operands. MASM solves this issue by introducing several additional
    conditional `if` statements intended for use with text operands and macro arguments.
    [Table 13-1](#table13-1) lists these additional `if` statements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 MASM 将空字符串替代了 `eq` 运算符两侧的操作数。当然，这会导致语法错误。即使在 `eq` 运算符两侧有非空的文本操作数，这也会失败，因为
    `eq` 期望的是数值型操作数。MASM 通过引入几个额外的条件 `if` 语句来解决这个问题，这些语句专门用于处理文本操作数和宏参数。[表13-1](#table13-1)列出了这些额外的
    `if` 语句。
- en: 'Table 13-1: Text-Handling Conditional `if` Statements'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1：文本处理条件 `if` 语句
- en: '| **Statement** | **Text operand(s)** | **Meaning** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **语句** | **文本操作数** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ifb`^([*](#c13-footnote-11)) | `arg` | If blank: true if `arg` evaluates
    to an empty string. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `ifb`^([*](#c13-footnote-11)) | `arg` | 如果为空：如果 `arg` 被评估为空字符串，则为真。 |'
- en: '| `ifnb` | `arg` | If not blank: true if `arg` evaluates to a non-empty string.
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `ifnb` | `arg` | 如果不为空：如果 `arg` 被评估为非空字符串，则为真。 |'
- en: '| `ifdif` | `arg1``,` `arg2` | If different: true if `arg1` and `arg2` are
    different (case-sensitive). |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `ifdif` | `arg1``,` `arg2` | 如果不同：如果 `arg1` 和 `arg2` 不同（区分大小写），则为真。 |'
- en: '| `ifdifi` | `arg1``,` `arg2` | If different: true if `arg1` and `arg2` are
    different (case-insensitive). |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `ifdifi` | `arg1``,` `arg2` | 如果不同：如果 `arg1` 和 `arg2` 不同（不区分大小写），则为真。 |'
- en: '| `ifidn` | `arg1``,` `arg2` | If identical: true if `arg1` and `arg2` are
    exactly the same (case-sensitive). |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `ifidn` | `arg1``,` `arg2` | 如果相同：如果 `arg1` 和 `arg2` 完全相同（区分大小写），则为真。 |'
- en: '| `ifidni` | `arg2``,` `arg2` | If identical: true if `arg1` and `arg2` are
    exactly the same (case-insensitive). |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `ifidni` | `arg1``,` `arg2` | 如果相同：如果 `arg1` 和 `arg2` 完全相同（不区分大小写），则为真。 |'
- en: '| ^([*](#c13-footnoteref-11)) `ifb` `arg` is shorthand for `ifidn <``arg``>,
    <>`. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| ^([*](#c13-footnoteref-11)) `ifb` `arg` 是 `ifidn <``arg``>, <>` 的简写。 |'
- en: You use these conditional `if` statements exactly like the standard `if` statement.
    You can also follow these `if` statements with an `elseif` or `else` clause, but
    there are no `elseifb`, `elseifnb`, . . . , variants of these `if` statements
    (only a standard `elseif` with a Boolean expression may follow these statements).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像标准的 `if` 语句一样使用这些条件 `if` 语句。你也可以在这些 `if` 语句后面跟随一个 `elseif` 或 `else` 子句，但没有
    `elseifb`、`elseifnb` 等变体（这些 `if` 语句后面只能跟一个带布尔表达式的标准 `elseif`）。
- en: 'The following snippet demonstrates how to use the `ifb` statement to ensure
    that the `neg128` macro has exactly two arguments. There is no need to check whether
    `reg64HO` is also blank; if `reg64HO` is blank, `reg64LO` will also be blank,
    and the `ifb` statement will report the appropriate error:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用`ifb`语句来确保`neg128`宏有正好两个参数。无需检查`reg64HO`是否为空；如果`reg64HO`为空，`reg64LO`也将为空，`ifb`语句会报告相应的错误：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Be very careful about using `ifb` in your programs. It is easy to pass in a
    text symbol to a macro and wind up testing whether the name of that symbol is
    blank rather than the text itself. Consider the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ifb`时要非常小心。很容易将文本符号传递给宏，最终测试该符号的名称是否为空，而不是文本本身。考虑以下例子：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `neg128` invocation has two arguments, and the second one is not blank,
    so the `ifb` directive is happy with the argument list. However, inside the macro
    when `neg128` expands `reg64LO` after the `neg` instruction, the expansion is
    the empty string, producing an error (which is what the `ifb` was supposed to
    prevent).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`neg128`调用有两个参数，第二个参数不为空，因此`ifb`指令对参数列表是有效的。然而，在宏内部，当`neg128`扩展`reg64LO`并添加`neg`指令后，扩展结果为空字符串，从而产生错误（这正是`ifb`本应防止的情况）。'
- en: 'A different way to handle missing macro arguments is to explicitly tell MASM
    that an argument is required with the `:req` suffix on the macro definition line.
    Consider the following definition for the `neg128` macro:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缺失宏参数的另一种方式是明确告诉MASM某个参数是必需的，可以在宏定义行上使用`:req`后缀。考虑以下`neg128`宏的定义：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the `:req` option present, MASM reports the following if you are missing
    one or more of the macro arguments:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:req`选项后，如果缺少一个或多个宏参数，MASM将报告以下信息：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 13.9.3 Default Macro Parameter Values
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.3 默认宏参数值
- en: 'One way to handle missing macro arguments is to define default values for those
    arguments. Consider the following definition for the `neg128` macro:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缺失宏参数的一种方式是为这些参数定义默认值。考虑以下`neg128`宏的定义：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `:=` operator tells MASM to substitute the text constant to the right of
    the operator for the associated macro argument if an actual value is not present
    on the macro invocation line. Consider the following two invocations of `neg128`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`:=`运算符告诉MASM，如果宏调用行上没有实际值，则将运算符右侧的文本常量替换为相关的宏参数。考虑以下两个`neg128`的调用：'
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 13.9.4 Macros with a Variable Number of Parameters
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.4 带有可变参数数量的宏
- en: 'It is possible to tell MASM to allow a variable number of arguments in a macro
    invocation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以告诉MASM允许在宏调用中使用可变数量的参数：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Within the macro, MASM will create a text object of the form `<``arg1``,` `arg2``,
    ...,` `argn``>` and assign this text object to the associated parameter name (`varying`,
    in the preceding example). You can use the MASM `for` loop to extract the individual
    values of the varying argument. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏内部，MASM将创建一个文本对象，形式为`<``arg1``,` `arg2``, ...,` `argn``>`，并将该文本对象分配给关联的参数名称（在前面的示例中为`varying`）。您可以使用MASM的`for`循环来提取可变参数的单个值。例如：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s the listing output for an assembly containing this example source code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含此示例源代码的汇编输出清单：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A macro can have, at most, one `vararg` parameter. If a macro has more than
    one parameter and also has a `vararg` parameter, the `vararg` parameter must be
    the last argument.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个宏最多可以有一个`vararg`参数。如果一个宏有多个参数，并且也有`vararg`参数，那么`vararg`参数必须是最后一个参数。
- en: 13.9.5 The Macro Expansion (&) Operator
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.5 宏扩展（&）运算符
- en: 'Inside a macro, you can use the `&` operator to replace a macro name (or other
    text symbol) with its actual value. This operator is active anywhere, even with
    string literals. Consider the following examples:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏内部，您可以使用`&`运算符将宏名称（或其他文本符号）替换为其实际值。该运算符在任何地方都是有效的，甚至在字符串文字中也是如此。考虑以下示例：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The macro invocation in this example expands to the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的宏调用扩展为以下代码：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If, for some reason, you need the string `''&parm''` to be emitted within a
    macro (that has `parm` as one of its parameters), you will have to work around
    the expansion operator. Note that `''!&parm''` will not escape the `&` operator.
    One solution that works in this specific case is to rewrite the `byte` directive:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您需要在宏中输出字符串`'&parm'`（该宏将`parm`作为参数之一），则必须绕过扩展运算符。请注意，`'!&parm'`不会转义`&`运算符。一个有效的解决方案是重新编写`byte`指令：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now the `&` operator is not causing the expansion of `parm` inside a string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`&`运算符不会在字符串内扩展`parm`。
- en: 13.10 Local Symbols in a Macro
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10 宏中的局部符号
- en: 'Consider the following macro declaration:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下宏声明：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This macro simulates an instruction that jumps to the specified target location
    if the zero flag is set *and* the carry flag is set. Conversely, if either the
    zero flag or the carry flag is clear, this macro transfers control to the instruction
    immediately following the macro invocation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏模拟了一条指令，只有在零标志和进位标志都被设置时，才会跳转到指定的目标位置。相反，如果零标志或进位标志有一个被清除，则该宏会将控制转移到宏调用后面的指令。
- en: 'There is a serious problem with this macro. Consider what happens if you use
    this macro more than once in your program:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏存在一个严重问题。考虑一下，如果你在程序中多次使用这个宏，会发生什么情况：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding macro invocations expand to the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述宏调用扩展为以下代码：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: These two macro invocations both emit the same label, `NotTarget`, during macro
    expansion. When MASM processes this code, it will complain about a duplicate symbol
    definition.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏调用在宏扩展过程中都会生成相同的标签`NotTarget`。当MASM处理此代码时，它会报告符号重复定义的错误。
- en: 'MASM’s solution to this problem is to allow the use of *local symbols* within
    a macro. Local macro symbols are unique to a specific invocation of a macro. You
    must explicitly tell MASM which symbols must be local by using the `local` directive:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: MASM解决这个问题的方法是允许在宏内部使用*局部符号*。局部宏符号是特定宏调用中唯一的符号。你必须通过使用`local`指令显式地告诉MASM哪些符号必须是局部的：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `list_of_local_names` is a sequence of one or more MASM identifiers separated
    by commas. Whenever MASM encounters one of these names in a particular macro invocation,
    it automatically substitutes a unique name for that identifier. For each macro
    invocation, MASM substitutes a different name for the local symbol.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_local_names`是由一个或多个MASM标识符组成的序列，这些标识符由逗号分隔。每当MASM在特定的宏调用中遇到这些名称时，它会自动为该标识符替换一个唯一的名称。对于每个宏调用，MASM都会为局部符号替换一个不同的名称。'
- en: 'You can correct the problem with the `jzc` macro by using the following macro
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下宏代码来修正`jzc`宏的问题：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now whenever MASM processes this macro, it will automatically associate a unique
    symbol with each occurrence of `NotTarget`. This will prevent the duplicate symbol
    error that occurs if you do not declare `NotTarget` as a local symbol.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当MASM处理这个宏时，它会自动为每个`NotTarget`的出现关联一个唯一的符号。这将防止在没有声明`NotTarget`为局部符号时出现符号重复错误。
- en: MASM generates symbols of the form `??``nnnn`, where `nnnn` is a (unique) four-digit
    hexadecimal number, for each local symbol. So, if you see symbols such as `??0000`
    in your assembly listings, you know where they came from.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MASM为每个局部符号生成`??``nnnn`格式的符号，其中`nnnn`是一个（唯一的）四位十六进制数。因此，如果你在汇编清单中看到像`??0000`这样的符号，你就知道它们的来源。
- en: A macro definition can have multiple `local` directives, each with its own list
    of local names. However, if you have multiple `local` statements in a macro, they
    should all immediately follow the `macro` directive.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义可以包含多个`local`指令，每个指令有自己的一组局部名称。然而，如果在一个宏中有多个`local`语句，它们应该紧跟在`macro`指令之后。
- en: 13.11 The exitm Directive
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.11 exitm指令
- en: The MASM `exitm` directive (which may appear only within a macro) tells MASM
    to immediately terminate the processing of the macro. MASM will ignore any additional
    lines of text within the macro. If you think of a macro as a procedure, `exitm`
    is the return statement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: MASM的`exitm`指令（仅能在宏内部使用）告诉MASM立即终止宏的处理。MASM会忽略宏中的任何额外行。如果你把宏看作是一个过程，那么`exitm`就是返回语句。
- en: 'The `exitm` directive is useful in a conditional assembly sequence. Perhaps
    after checking for the presence (or absence) of certain macro arguments, you might
    want to stop processing the macro to avoid additional errors from MASM. For example,
    consider the earlier `neg128` macro:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`exitm`指令在条件汇编序列中非常有用。也许在检查某些宏参数是否存在（或不存在）之后，你可能希望停止宏的处理，以避免MASM产生额外的错误。例如，考虑之前的`neg128`宏：'
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Without the `exitm` directive inside the conditional assembly, this macro would
    attempt to assemble the `neg reg64LO` instruction, generating another error because
    `reg64LO` expands to the empty string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在条件汇编中没有`exitm`指令，这个宏将尝试汇编`neg reg64LO`指令，并生成另一个错误，因为`reg64LO`会扩展为空字符串。
- en: 13.12 MASM Macro Function Syntax
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.12 MASM宏函数语法
- en: 'Originally, MASM’s macro design allowed programmers to create substitute mnemonics.
    A programmer could use a macro to replace a machine instruction or other statement
    (or sequence of statements) in an assembly language source file. Macros could
    create only *whole lines* of output text in the source file. This prevented programmers
    from using macro invocation such as the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，MASM 的宏设计允许程序员创建替代助记符。程序员可以使用宏来替换汇编语言源文件中的机器指令或其他语句（或语句序列）。宏只能在源文件中创建*整行*的输出文本。这使得程序员无法使用如下的宏调用：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Today, MASM supports additional syntax that allows you to create *macro functions*.
    A MASM macro function definition looks exactly like a normal macro definition
    with one addition: you use an `exitm` directive with a textual argument to return
    a *function result* from the macro. Consider the `upperCase` macro function in
    [Listing 13-4](#listing13-4).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，MASM 支持额外的语法，允许你创建*宏函数*。一个 MASM 宏函数的定义看起来与普通宏定义完全相同，唯一的不同是：你使用一个带有文本参数的 `exitm`
    指令来从宏中返回*函数结果*。请参考[清单 13-4](#listing13-4)中的 `upperCase` 宏函数。
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 13-4: Sample macro function'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-4：示例宏函数
- en: Whenever you invoke a MASM macro function, you must always follow the macro
    name with a pair of parentheses enclosing the macro’s arguments. Even if the macro
    has no arguments, an empty pair of parentheses must be present. This is how MASM
    differentiates standard macros and macro functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用一个 MASM 宏函数时，必须始终在宏名称后面加上一对括号，括号中包含宏的参数。即使宏没有参数，也必须包含一对空括号。这是 MASM 区分标准宏和宏函数的方式。
- en: 'Earlier versions of MASM included functions for directives such as `sizestr`
    (using the name `@sizestr`). Recent versions of MASM have removed these functions.
    However, you can easily write your own macro functions to replace these missing
    functions. Here’s a quick replacement for the `@sizestr` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 MASM 包含了诸如 `sizestr`（使用名称 `@sizestr`）等指令的函数。最近的 MASM 版本已经移除了这些函数。不过，你可以轻松编写自己的宏函数来替代这些丢失的函数。以下是
    `@sizestr` 函数的一个快速替代：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `&` operator in the `exitm` directive forces the `@sizestr` macro to expand
    the text associated with `theLen` local symbol inside the `<` and `>` string delimiters
    before returning the value to whomever invoked the macro function. Without the
    `&` operator, the `@sizestr` macro will return text of the form `??0002` (the
    unique symbol MASM creates for the local symbol `theLen`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`exitm` 指令中的 `&` 运算符强制 `@sizestr` 宏展开与 `theLen` 本地符号关联的文本，并将其放入 `<` 和 `>` 字符串定界符中，然后返回该值给调用宏函数的人。没有
    `&` 运算符时，`@sizestr` 宏将返回形如 `??0002` 的文本（MASM 为本地符号 `theLen` 创建的唯一符号）。'
- en: 13.13 Macros as Compile-Time Procedures and Functions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.13 将宏作为编译时过程和函数
- en: Although programmers typically use macros to expand to a sequence of machine
    instructions, there is absolutely no requirement that a macro body contain any
    executable instructions. Indeed, many macros contain only compile-time language
    statements (for example, `if`, `while`, `for`, `=` assignments, and the like).
    By placing only compile-time language statements in the body of a macro, you can
    effectively write compile-time procedures and functions using macros.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序员通常使用宏来展开成一系列机器指令，但并没有要求宏体中必须包含任何可执行指令。实际上，许多宏只包含编译时语言语句（例如 `if`、`while`、`for`、`=`
    赋值等）。通过在宏体中仅放置编译时语言语句，你可以有效地使用宏编写编译时程序和函数。
- en: 'The following `unique` macro is a good example of a compile-time function that
    returns a string result:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `unique` 宏是一个很好的编译时函数示例，它返回一个字符串结果：
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Whenever your code references this macro, MASM replaces the macro invocation
    with the text `theSym`. MASM generates unique symbols such as `??0000` for local
    macro symbols. Therefore, each invocation of the `unique` macro will generate
    a sequence of symbols such as `??0000`, `??0001`, `??0002`, and so forth.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你的代码引用此宏时，MASM 会将宏调用替换为文本 `theSym`。MASM 为本地宏符号生成唯一的符号，如 `??0000`。因此，每次调用 `unique`
    宏时，都会生成一系列符号，如 `??0000`、`??0001`、`??0002`，以此类推。
- en: 13.14 Writing Compile-Time “Programs”
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.14 编写编译时“程序”
- en: The MASM compile-time language allows you to write short programs *that write
    other programs*—in particular, to automate the creation of large or complex assembly
    language sequences. The following subsections provide simple examples of such
    compile-time programs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 编译时语言允许你编写短程序*来编写其他程序*——特别是自动化创建大型或复杂的汇编语言序列。以下小节提供了这类编译时程序的简单示例。
- en: 13.14.1 Constructing Data Tables at Compile Time
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.14.1 在编译时构建数据表
- en: Earlier, this book suggested that you could write programs to generate large,
    complex lookup tables for your assembly language programs (see the discussion
    of tables in “Generating Tables” in Chapter 10). Chapter 10 provides C++ programs
    that generate tables to paste into assembly programs. In this section, we will
    use the MASM compile-time language to construct data tables during assembly of
    the program that uses the tables.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本书之前提到过，你可以编写程序来为你的汇编语言程序生成大型、复杂的查找表（请参见第 10 章中的“生成表格”讨论）。第 10 章提供了生成表格的 C++
    程序，可以将其粘贴到汇编程序中。在本节中，我们将使用 MASM 编译时语言在程序汇编过程中构建数据表，该程序使用这些表格。
- en: One common use for the compile-time language is to build ASCII character lookup
    tables for alphabetic case manipulation with the `xlat` instruction at runtime.
    [Listing 13-5](#listing13-5) demonstrates how to construct an uppercase conversion
    table and a lowercase conversion table.^([4](#c13-footnote-4)) Note the use of
    a macro as a compile-time procedure to reduce the complexity of the table-generating
    code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时语言的一个常见用法是构建 ASCII 字符查找表，用于运行时的字母大小写转换，使用 `xlat` 指令。[示例 13-5](#listing13-5)
    演示了如何构建一个大写字母转换表和一个小写字母转换表。^([4](#c13-footnote-4)) 请注意使用宏作为编译时过程，以减少生成表格代码的复杂性。
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 13-5: Generating case-conversion tables with the compile-time language'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-5：使用编译时语言生成大小写转换表
- en: 'Here’s the build command and sample output for the program in [Listing 13-5](#listing13-5):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[示例 13-5](#listing13-5)中的程序构建命令和示例输出：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 13.14.2 Unrolling Loops
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.14.2 展开循环
- en: Chapter 7 points out that you can unroll loops to improve the performance of
    certain assembly language programs. However, this requires a lot of extra typing,
    especially if you have many loop iterations. Fortunately, MASM’s compile-time
    language facilities, especially the `while` loop, come to the rescue. With a small
    amount of extra typing plus one copy of the loop body, you can unroll a loop as
    many times as you please.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章指出，你可以展开循环来提高某些汇编语言程序的性能。然而，这需要大量的额外输入，特别是当你有许多循环迭代时。幸运的是，MASM 的编译时语言功能，特别是
    `while` 循环，能够提供帮助。只需少量额外输入和一次循环体复制，你就可以按需展开循环多次。
- en: 'If you simply want to repeat the same code sequence a certain number of times,
    unrolling the code is especially trivial. All you have to do is wrap a MASM `while..endm`
    loop around the sequence and count off the specified number of iterations. For
    example, if you wanted to print `Hello World` 10 times, you could encode this
    as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想重复相同的代码序列一定次数，展开代码尤其简单。你所需要做的只是将一个 MASM `while..endm` 循环包裹在序列周围，并计数指定的迭代次数。例如，如果你想打印
    `Hello World` 10 次，你可以按如下方式编码：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Although this code looks similar to a high-level language `while` loop, remember
    the fundamental difference: the preceding code simply consists of 10 straight
    calls to `print` in the program. Were you to encode this using an actual loop,
    there would be only one call to `print` and lots of additional logic to loop back
    and execute that single call 10 times.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码看起来类似于高级语言中的 `while` 循环，但请记住其根本区别：前面的代码仅仅是程序中 10 次对 `print` 的直接调用。如果你使用实际的循环来编码，那么将只有一次
    `print` 调用，并且会有很多额外的逻辑来循环返回并执行那次唯一的调用 10 次。
- en: 'Unrolling loops becomes slightly more complicated if any instructions in that
    loop refer to the value of a loop control variable or another value, which changes
    with each iteration of the loop. A typical example is a loop that zeroes the elements
    of an integer array:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环中的任何指令引用了循环控制变量或其他随每次迭代变化的值，那么展开循环会变得稍微复杂一些。一个典型的例子是一个将整数数组元素归零的循环：
- en: '[PRE77]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In this code fragment, the loop uses the value of the loop control variable
    (in RBX) to index into `array`. Simply copying `mov [rcx][ebx * 4], eax` 20 times
    is not the proper way to unroll this loop. You must substitute an appropriate
    constant index in the range 0 to 76 (the corresponding loop indices, times 4)
    in place of `rbx * 4` in this example. Correctly unrolling this loop should produce
    the following code sequence:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，循环使用循环控制变量（在 RBX 中）的值来索引 `array`。简单地复制 `mov [rcx][ebx * 4], eax` 20
    次并不是展开该循环的正确方法。你必须用适当的常数索引（范围从 0 到 76，对应的循环索引乘以 4）替换示例中的 `rbx * 4`。正确展开这个循环应该生成以下代码序列：
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can easily do this using the following compile-time code sequence:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下编译时代码序列轻松完成此操作：
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If the statements in a loop use the loop control variable’s value, it is possible
    to unroll such loops only if those values are known at compile time. You cannot
    unroll loops when user input (or other runtime information) controls the number
    of iterations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环中的语句使用了循环控制变量的值，只有当这些值在编译时已知时，才能展开这样的循环。当用户输入（或其他运行时信息）控制迭代次数时，无法展开循环。
- en: 'Of course, if the code sequence loaded RCX with the address of `array` immediately
    prior to this loop, you could also use the following `while` loop to save the
    use of the RCX register:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果代码序列在这个循环之前已经将RCX加载为`array`的地址，你也可以使用以下`while`循环来节省RCX寄存器的使用：
- en: '[PRE80]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 13.15 Simulating HLL Procedure Calls
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.15 模拟高级语言过程调用
- en: Calling procedures (functions) in assembly language is a real chore. Loading
    registers with parameters, pushing values onto the stack, and other activities
    are a complete distraction. High-level language procedure calls are far more readable
    and easier to write than the same calls to an assembly language function. Macros
    provide a good mechanism to call procedures and functions in a high-level-like
    manner.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中调用过程（函数）是一个真正的麻烦。加载寄存器参数、将值推入栈中以及其他活动完全分散注意力。与对汇编语言函数的调用相比，高级语言的过程调用要更具可读性，并且更容易编写。宏提供了一种以类似高级语言的方式调用过程和函数的良好机制。
- en: 13.15.1 HLL-Like Calls with No Parameters
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.15.1 类似高级语言调用的无参数调用
- en: 'Of course, the most trivial example is a call to an assembly language procedure
    that has no arguments at all:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最简单的例子是调用一个没有参数的汇编语言过程：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This simple example demonstrates a couple of conventions this book will use
    for calling procedures via macro invocation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了本书在通过宏调用过程时所使用的一些约定：
- en: If the procedure and all calls to the procedure occur within the same source
    file, place the macro definition immediately before the procedure to make it easy
    to find. (Chapter 15 discusses the placement of the macro if you call the procedure
    from several different source files.)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过程和所有对该过程的调用都发生在同一个源文件中，则将宏定义放置在过程之前，方便查找。（第15章讨论了如果你从多个源文件调用过程时宏的位置问题。）
- en: If you would normally name the procedure `someProc`, change the procedure’s
    name to `_someProc` and then use `someProc` as the macro name.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你通常会命名过程为`someProc`，将过程的名称更改为`_someProc`，然后将`someProc`用作宏名称。
- en: While the advantage to using a macro invocation of the form `someProc` versus
    a call to the procedure using `call someProc` might seem somewhat dubious, keeping
    all procedure calls consistent (by using macro invocations for all of them) helps
    make your programs more readable.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`someProc`形式的宏调用与使用`call someProc`调用过程的优势似乎有些可疑，但保持所有过程调用的一致性（通过对所有过程使用宏调用）有助于提高程序的可读性。
- en: 13.15.2 HLL-Like Calls with One Parameter
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.15.2 类似高级语言调用的单参数调用
- en: 'The next step up in complexity is to call a procedure with a single parameter.
    Assuming you’re using the Microsoft ABI and passing the parameter in RCX, the
    simplest solution is something like the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步的复杂度是调用带有单个参数的过程。假设你正在使用微软的ABI并通过RCX传递参数，最简单的解决方案如下所示：
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This macro works well if you’re passing a 64-bit integer by value. If the parameter
    is an 8-, 16-, or 32-bit value, you would swap CL, CX, or ECX for RCX in the `mov`
    instruction.^([5](#c13-footnote-5))
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递的是64位整数按值传递，此宏效果良好。如果参数是8位、16位或32位值，则需要在`mov`指令中将CL、CX或ECX替换为RCX。^([5](#c13-footnote-5))
- en: 'If you’re passing the first argument by reference, you would swap an `lea`
    instruction for the `mov` instruction in this example. As reference parameters
    are always 64-bit values, the `lea` instruction would usually take this form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按引用传递第一个参数，你将需要将`lea`指令替换为本例中的`mov`指令。由于引用参数总是64位值，`lea`指令通常采用以下形式：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, if you’re passing a `real4` or `real8` value as the parameter, you’d
    swap one of the following instructions for the `mov` instruction in the previous
    macro:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你传递的是`real4`或`real8`值作为参数，你需要将以下其中一条指令替换为前一个宏中的`mov`指令：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As long as the actual parameter is a memory variable or an appropriate integer
    constant, this simple macro definition works quite well, covering a very large
    percentage of the real-world cases.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 只要实际参数是一个内存变量或适当的整数常量，这个简单的宏定义就能很好地工作，覆盖了大量的实际案例。
- en: For example, to call the C Standard Library `printf()` function with a single
    argument (the format string) using the current macro scheme, you’d write the macro
    as follows:^([6](#c13-footnote-6))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用当前宏方案调用C标准库中的`printf()`函数并传入一个单一参数（格式字符串），你应该像下面这样写宏：^([6](#c13-footnote-6))
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: So you can invoke this macro as
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以像这样调用这个宏：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: where `fmtStr` is (presumably) the name of a `byte` object in your `.data` section
    containing the `printf` format string.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`fmtStr`（假设）是位于`.data`段中的`byte`对象，包含了`printf`格式字符串。
- en: 'For a more high-level-like syntax for our procedure calls, we should allow
    something like the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更像高级语言的语法，我们应该允许类似以下的调用方式：
- en: '[PRE87]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Unfortunately, the way the macro is currently written, this will generate the
    following (syntactically incorrect) statement:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当前宏的写法会生成以下（语法上不正确的）语句：
- en: '[PRE88]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We could modify this macro to allow this invocation by rewriting it as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新编写宏来修改它，从而允许这种调用：
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Invoking this macro by using a string constant as the argument expands to the
    following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串常量作为参数调用此宏，展开后的代码如下：
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The only problem with this new form of the macro is that it no longer accepts
    invocations such as
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本宏的唯一问题是它不再接受像这样的调用：
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: where `fmtStr` is a byte object in the `.data` section. We’d really like to
    have a macro that can accept *both* forms.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`fmtStr`是`.data`段中的一个字节对象。我们确实希望有一个可以接受*两种*形式的宏。
- en: 13.15.3 Using opattr to Determine Argument Types
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.15.3 使用`opattr`来确定参数类型
- en: The trick to this is the `opattr` operator (see [Table 4-1](c04.xhtml#table4-1)
    in Chapter 4). This operator returns an integer value with certain bits set based
    on the type of expression that follows. In particular, bit 2 will be set if the
    expression following is relocatable or otherwise references memory. Therefore,
    this bit will be set if a variable such as `fmtStr` appears as the argument, and
    it will be clear if you pass a string literal as the argument (`opattr` actually
    returns the value 0 for string literals that are longer than 8 characters, just
    so you know). Now consider the code in [Listing 13-6](#listing13-6).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的技巧在于`opattr`操作符（参见第4章中的[表4-1](c04.xhtml#table4-1)）。该操作符会根据后续表达式的类型返回一个设置了特定位的整数值。特别地，如果后续的表达式是可重定位的或者引用了内存，则会设置第2位。因此，如果像`fmtStr`这样的变量作为参数出现时，该位将被设置；而如果你传递一个字符串字面量作为参数（`opattr`实际上会对长度超过8个字符的字符串字面量返回0值，仅供参考），那么该位将保持清除。现在考虑[清单13-6](#listing13-6)中的代码。
- en: '[PRE92]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 13-6: `opattr` operator in a macro'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-6：宏中的`opattr`操作符
- en: 'Here’s the build command and sample output for [Listing 13-6](#listing13-6):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[清单13-6](#listing13-6)的构建命令和示例输出：
- en: '[PRE93]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This `cprintf` macro is far from perfect. For example, the C/C++ `printf()`
    function allows multiple arguments that this macro does not handle. But this macro
    does demonstrate how to handle two different calls to `printf` based on the type
    of the argument you pass `cprintf`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`cprintf`宏远非完美。例如，C/C++的`printf()`函数允许多个参数，而这个宏不支持。但该宏确实演示了如何根据传递给`cprintf`的参数类型来处理两种不同的`printf`调用。
- en: 13.15.4 HLL-Like Calls with a Fixed Number of Parameters
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.15.4 使用固定数量参数的类高级语言调用
- en: Expanding the macro-calling mechanism from one parameter to two or more (assuming
    a fixed number of parameters) is fairly easy. All you need to do is add more formal
    parameters and handle those arguments in your macro definition. [Listing 13-7](#listing13-7)
    is a modification of [Listing 9-11](c09.xhtml#listing9-11) in Chapter 9 that uses
    macro invocations for calls to `r10ToStr`, `e10ToStr`, and some fixed calls to
    `printf` (for brevity, as this is a very long program, only the macros and a few
    invocations are included).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 将宏调用机制从一个参数扩展到两个或更多（假设参数数量是固定的）相当简单。你只需要添加更多的形式参数并在宏定义中处理这些参数。[清单13-7](#listing13-7)是第9章[清单9-11](c09.xhtml#listing9-11)的修改版，使用宏调用来调用`r10ToStr`、`e10ToStr`以及一些固定的`printf`调用（为了简洁，鉴于这是一个非常长的程序，这里仅包括宏和少数几个调用）。
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 13-7: Macro call implementation for converting floating-point values
    to strings'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-7：将浮点值转换为字符串的宏调用实现
- en: 'Compare the HLL-like calls to these three functions against the original procedure
    calls in [Listing 9-11](c09.xhtml#listing9-11):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些HLL样式的调用与[清单9-11](c09.xhtml#listing9-11)中的原始过程调用进行比较：
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Clearly, the macro version is easier to read (and, as it turns out, easier to
    debug and maintain too).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，宏版本更易于阅读（事实证明，它也更易于调试和维护）。
- en: 13.15.5 HLL-Like Calls with a Varying Parameter List
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some procedures expect a varying number of parameters; the C/C++ `printf()`
    function is a good example. Some procedures, though they might support only a
    fixed number of arguments, could be better written using a varying argument list.
    For example, consider the `print` procedure that has appeared throughout the examples
    in this book; its string parameter (which follows the call to `print` in the code
    stream) is, technically, a single-string argument. Consider the following macro
    implementation for a call to `print`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You could invoke this macro as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The only problem with this macro is that you will often want to supply multiple
    arguments in its invocation, such as this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Unfortunately, this macro will not accept this list of parameters. However,
    this seems like a natural use of the `print` macro, so it makes a lot of sense
    to modify the `print` macro to handle multiple arguments and combine them as a
    single string after the call to the `_print` function. [Listing 13-8](#listing13-8)
    provides such an implementation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 13-8: Varying arguments’ implementation of `print` macro'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output for the program in [Listing 13-8](#listing13-8):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'With this new `print` macro, you can now call the _`print` procedure in an
    HLL-like fashion by simply listing the arguments in the `print` invocation:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This will generate a byte directive that concatenates all the individual string
    components.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Note, by the way, that it is possible to pass a string containing multiple arguments
    to the original (single-argument) version of `print`. By rewriting the macro invocation
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: as
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: you get the desired output. MASM treats everything between the `<` and `>` brackets
    as a single argument. However, it’s a bit of a pain to have to constantly put
    these brackets around multiple arguments (and your code is inconsistent, as single
    arguments don’t require them). The `print` macro implementation with varying arguments
    is a much better solution.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 13.16 The invoke Macro
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At one time, MASM provided a special directive, `invoke`, that you could use
    to call a procedure and pass it parameters (it worked with the `proc` directive
    to determine the number and type of parameters a procedure expected). When Microsoft
    modified MASM to support 64-bit code, it removed the `invoke` statement from the
    MASM language.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: However, some enterprising programmers have written MASM macros to simulate
    the `invoke` directive in 64-bit versions of MASM. The `invoke` macro not only
    is useful in its own right but also provides a great example of how to write advanced
    macros to call procedures. For more information on the `invoke` macro, visit [https://www.masm32.com/](https://www.masm32.com/)
    and download the MASM32 SDK. This includes a set of macros (and other utilities)
    for 64-bit programs, including the `invoke` macro.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 13.17 Advanced Macro Parameter Parsing
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sections provided examples of macro parameter processing used to
    determine the type of a macro argument in order to determine the type of code
    to emit. By carefully examining the attributes of an argument, a macro can make
    various choices concerning how to deal with that argument. This section presents
    some more advanced techniques you can use when processing macro arguments.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, the `opattr` compile-time operator is one of the most important tools
    you can use when looking at macro arguments. This operator uses the following
    syntax:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note that a generic address expression follows `opattr`; you are not limited
    to a single symbol.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The `opattr` operator returns an integer value that is a bit mask specifying
    the `opattr` attributes of the associated expression. If the expression following
    `opattr` contains forward-referenced symbols or is an illegal expression, `opattr`
    returns 0\. Microsoft’s documentation indicates that `opattr` returns the values
    shown in [Table 13-2](#table13-2).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-2: `opattr` Return Values'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Meaning** |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| 0 | There is a code label in the expression. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| 1 | The expression is relocatable. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| 2 | The expression is a constant expression. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| 3 | The expression is uses direct (PC-relative) addressing. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| 4 | The expression is a register. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| 5 | The expression contains no undefined symbols (obsolete). |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| 6 | The expression is a stack-segment memory expression. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| 7 | The expression references an external symbol. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| 8–11 | Language type^([*](#c13-footnote-12)) |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '|  | Value | Language |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '|  | 0 | No language type |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | C |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '|  | 2 | SYSCALL |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '|  | 3 | STDCALL |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '|  | 4 | Pascal |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '|  | 5 | FORTRAN |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '|  | 6 | BASIC |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c13-footnoteref-12)) 64-bit code generally doesn’t support a language
    type, so these bits are usually 0. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: 'Quite honestly, Microsoft’s documentation does not do the best job explaining
    how MASM sets the bits. For example, consider the following MASM statements:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `opconst` has bits 2 and 5 set, just as you would expect from [Table 13-2](#table13-2).
    However, `opcl` has bits 0, 2, and 5 set; 0 and 5 make sense, but bit 2 (the expression
    is a constant expression) does not make sense. If, in a macro, you were to test
    only bit 2 to determine if the operand is a constant (as, I must admit, I have
    done in earlier examples in this chapter), you could get into trouble when bit
    2 is set and you assume that it is a constant.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Probably the wisest thing to do is to mask off bits 0 to 7 (or maybe just bits
    0 to 6) and compare the result against an 8-bit value rather than a simple mask.
    [Table 13-3](#table13-3) lists some common values you can test against.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-3: 8-Bit Values for `opattr` Results'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Meaning** |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| 0 | Undefined (forward-referenced) symbol or illegal expression |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| 34 / 22h | Memory access of the form `[``reg` `+` `const``]` |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| 36 / 24h | Constant |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| 37 / 25h | Code label (proc name or symbol with a `:` suffix) or `offset`
    `code_label` form |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| 38 / 26h | Expression of the form `offset` `label`, where `label` is a variable
    in the `.data` section |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| 42 / 2Ah | Global symbol (for example, symbol in `.data` section) |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| 43 / 2Bh | Memory access of the form `[``reg` `+` `code_label``]`, where
    `code_label` is a proc name or symbol with `:` suffix |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| 48 / 30h | Register (general-purpose, MM, XMM, YMM, ZMM, floating-point/ST,
    or other special-purpose register) |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| 98 / 62h | Stack-relative memory access (memory addresses of the form `[rsp
    +` `xxx``]` and `[rbp +` `xxx``]`) |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| 165 / 0A5h | External code symbol (37 / 25h with bit 7 set) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| 171 / ABh | External data symbol (43 / 2Bh with bit 7 set) |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: 'Perhaps the biggest issue with `opattr`, as has already been pointed out, is
    that it believes that constant expressions are integers that can fit into 64 bits.
    This creates a problem for two important constant types: string literals (longer
    than 8 characters) and floating-point constants. `opattr` returns 0 for both.^([8](#c13-footnote-7))'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 13.17.1 Checking for String Literal Constants
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although `opattr` won’t help us determine whether an operand is a string, we
    can use MASM’s string-processing operations to test the first character of an
    operand to see if it is a quote. The following code does just that:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Consider the following two invocations of the `testStr` macro:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: MASM will set the symbol `isAStr` to the value 1, and `notAStr` to the value
    0.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 13.17.2 Checking for Real Constants
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Real constants* are another literal type that MASM’s `opattr` operator doesn’t
    support. Again, writing a macro to test for a real constant can resolve that issue.
    Sadly, parsing real numbers isn’t as easy as checking for a string constant: there
    is no single leading character that we can use to say, “Hey, we’ve got a floating-point
    constant here.” The macro will have to explicitly parse the operand character
    by character and validate it.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, here is a grammar that defines a MASM floating-point constant:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: A real number consists of an optional sign followed by a mantissa and an optional
    exponent. A mantissa contains at least one digit; it can also contain a decimal
    point with a digit to its left or right (or both). However, a mantissa cannot
    consist of a decimal point by itself.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro function to test for a real constant should be callable as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'where `some_text` is the textual data we want to test to see if it’s a real
    constant. The macro for `getReal` could be the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Testing for real constants is a complex process, so it’s worthwhile to go through
    this macro (and all subservient macros) step by step:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of the original parameter string. During processing, `getReal` will
    delete characters from the parameter string while parsing the string. This macro
    makes a copy to prevent disturbing the original text string passed in to it.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for a blank parameter. If the caller passes in an empty string, the result
    is not a valid real constant and `getReal` must return false. It’s important to
    check for the empty string right away because the rest of the code makes the assumption
    that the string is at least one character long.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `getSign` macro function. This function (its definition appears a little
    later) returns true if the first character of its argument is a `+` or `-` symbol;
    otherwise, it returns false.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the first character is a sign character, invoke the `extract1st` macro:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `extract1st` macro returns the first character of its argument as the function
    result (which this statement assigns to the `curChar` symbol) and then deletes
    the first character of its argument. So if the original string passed to `getReal`
    was `+1`, this statement puts `+` into `curChar` and deletes the first character
    in `parm` (producing the string `1`). The definition for `extract1st` appears
    a little later in this section.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getReal` doesn’t actually use the sign character assigned to `curChar`. The
    purpose of this `extract1st` invocation was strictly for the side effect of deleting
    the first character in `parm`.'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Invoke `getMant`. This macro function will return true if the prefix of its
    string argument is a valid mantissa. It will return false if the mantissa does
    not contain at least one numeric digit. Note that `getMant` will stop processing
    the string on the first non-mantissa character it encounters (including a second
    decimal point, if there are two or more decimal points in the mantissa). The `getMant`
    function doesn’t care about illegal characters; it leaves it up to `getReal` to
    look at the remaining characters after the return from `getMant` to determine
    if the whole string is valid. As a side effect, `getMant` deletes all leading
    characters from the parameter string that it processes.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `getExp` macro function to process any (optional) trailing exponent.
    The `getExp` macro is also responsible for ensuring that no garbage characters
    follow (which results in a parse failure).
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `isSign` macro is fairly straightforward. Here’s its implementation:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This macro uses the `substr` operation to extract the first character from the
    parameter and then compares this against the sign characters (`+` or `-`). It
    returns true if it is a sign character, and false otherwise.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extract1st` macro function removes the first character from the argument
    passed to it and returns that character as the function result. As a side effect,
    this macro function also deletes the first character from the parameter passed
    to it. Here’s `extract1st`’s implementation:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `ifb` directive checks whether the parameter string is empty. If it is,
    `extract1st` immediately returns the empty string without further modification
    to its parameter.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Note the `%` operator before the `parm` argument. The `parm` argument actually
    expands to the name of the string variable holding the real constant. This turns
    out to be something like `??0005` because of the copy made of the original parameter
    in the `getReal` function. Were you to simply specify `ifb <parm>`,the `ifb` directive
    would see `<??0005>`, which is not blank. Placing the `%` operator before the
    `parm` symbol tells MASM to evaluate the expression (which is just the `??0005`
    symbol) and replace it by the text it evaluates to (which, in this case, is the
    actual string).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: If the string is not blank, `extract1st` uses the `substr` directive to extract
    the first character from the string and assigns this character to the `FirstChar`
    symbol. The `extract1st` macro function will return this value as the function
    result.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `extract1st` function has to delete the first character from the parameter
    string. It uses the `@sizestr` function (whose definition appears a little earlier
    in this chapter) to determine whether the character string contains at least two
    characters. If so, `extract1st` uses the `substr` directive to extract all the
    characters from the parameter, starting at the second character position. It assigns
    this substring back to the parameter passed in. If `extract1st` is processing
    the last character in the string (that is, if `@sizestr` returns 1), then the
    code cannot use the `substr` directive because the index would be out of range.
    The `else` section of the `if` directive returns an empty string if `@sizestr`
    returns a value less than 2.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `getReal` subservient macro function is `getMant`. This macro is responsible
    for parsing the mantissa component of the floating-point constant. The implementation
    is the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: A mantissa must have at least one decimal digit. It can have zero or one occurrence
    of a decimal point (which may appear before the first digit, at the end of the
    mantissa, or in the middle of a string of digits). The `getMant` macro function
    uses the local symbol `sawDecPt` to keep track of whether it has seen a decimal
    point already. The function begins by initializing `sawDecPt` to false (0).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: A valid mantissa must have at least one character (because it must have at least
    one decimal digit). So the next thing `getMant` does is extract the first character
    from the parameter string (and place this character in `curChar`). If the first
    character is a period (decimal point), the macro sets `sawDecPt` to true.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The `getMant` function uses a `while` directive to process all the remaining
    characters in the mantissa. A local variable, `rpt`, controls the execution of
    the `while` loop. The code at the beginning of `getMant` sets `rpt` to true if
    the first character is a period or a decimal digit. The `isDigit` macro function
    tests the first character of its argument and returns true if it’s one of the
    characters 0 to 9\. The definition for `isDigit` will appear shortly.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: If the first character in the parameter was a dot (`.`) or a decimal digit,
    the `getMant` function removes that character from the beginning of the string
    and executes the body of the `while` loop for the first time if the new parameter
    string length is greater than zero.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop grabs the first character from the current parameter string
    (without deleting it just yet) and tests it against a decimal digit or a `.` character.
    If it’s a decimal digit, the loop will remove that character from the parameter
    string and repeat. If the current character is a period, the code first checks
    whether it has already seen a decimal point (using `sawDecPt`). If this is a second
    decimal point, the function returns true (later code will deal with the second
    `.` character). If the code has not already seen a decimal point, the loop sets
    `sawDecPt` to true and continues with the loop execution.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop repeats as long as it sees decimal digits, a single decimal
    point, or a string with length greater than zero. Once the loop completes, the
    `getMant` function returns true. The only way `getMant` returns false is if it
    does not see at least one decimal digit (either at the beginning of the string
    or immediately after the decimal point at the beginning of the string).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isDigit` macro function is a brute-force function that tests its first
    character against the 10 decimal digits. This function does not remove any characters
    from its parameter argument. The source code for `isDigit` is the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The only thing worth commenting on is the `%` operator in `@sizestr` (for reasons
    explained earlier).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we arrive at the last helper function appearing in `getReal`: the `getExp`
    (*get exponent*) macro function. Here’s its implementation:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Exponents are optional in a real constant. Therefore, the first thing this macro
    function does is check whether it has been passed an empty string. If so, it immediately
    returns success. Once again, the `ifb <%parm>` directive must have the `%` operator
    before the `parm` argument.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parameter string is not empty, the first character in the string must
    be an `E` or `e` character. This function returns false if this is not the case.
    Checking for an `E` or `e` is done with the `isE` helper function, whose implementation
    is the following (note the use of `ifidni`, which is case-insensitive):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Next, the `getExp` function looks for an optional sign character. If it encounters
    one, it deletes the sign character from the beginning of the string.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: At least one decimal digit, and at most four decimal digits, must follow the
    `e` or `E` and sign characters. The remaining code in `getExp` handles that.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-9](#listing13-9) is a demonstration of the macro snippets appearing
    throughout this section. Note that this is a pure compile-time program; all its
    activity takes place while MASM assembles this source code. It does not generate
    any executable machine code.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 13-9: Compile-time program with test code for `getReal` macro'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and (compile-time) program output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 13.17.3 Checking for Registers
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the `opattr` operator provides a bit to tell you that its operand is
    an x86-64 register, that’s the only information `opattr` provides. In particular,
    `opattr`’s return value won’t tell you which register it has seen; whether it’s
    a general-purpose, XMM, YMM, ZMM, MM, ST, or other register; or the size of that
    register. Fortunately, with a little work on your part, you can determine all
    this information by using MASM’s conditional assembly statements and other operators.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, here’s a simple macro function, `isReg`, that returns 1 or 0
    depending on whether its operand is a register. This is a simple shell around
    the `opattr` operator that returns the setting of bit 4:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: While this function provides some convenience, it doesn’t really provide any
    information that the `opattr` operator already provides. We want to know what
    register appears in the operand as well as the size of that register.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-10 (available online at [http://artofasm.randallhyde.com/](http://artofasm.randallhyde.com/))
    provides a wide range of useful macro functions and equates for processing register
    operands in your own macros. The following paragraphs describe some of the more
    useful equates and macros.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 13-10 contains a set of equates that map register names to numeric
    values. These equates use symbols of the form `reg``XXX`, where `XXX` is the register
    name (all uppercase). Examples include the following: `regAL`, `regSIL`, `regR8B`,
    `regAX`, `regBP`, `regR8W`, `regEAX`, `regEBP`, `regR8D`, `regRAX`, `regRSI`,
    `regR15`, `regST`, `regST0`, `regMM0`, `regXMM0`, and `regYMM0`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: There is also a special equate for the symbol `regNone` that represents a non-register
    entity. These equates give numeric values in the range 1 to 117 to each of these
    symbols (`regNone` is given the value 0).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind all these equates (and, in general, assigning numeric values
    to registers) is to make it easier to test for specific registers (or ranges of
    registers) within your macros by using conditional assembly.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful set of macros appearing in Listing 13-10 converts textual forms of
    the register names (that is, AL, AX, EAX, RAX, and so forth) to their numeric
    form (`regAL`, `regAX`, `regEAX`, `regRAX`, and so on). The most generic macro
    function to do this is `whichReg(``register``)`. This function accepts a text
    object and returns the appropriate `reg``XXX` value for that text. If the text
    passed as an argument is not one of the valid general-purpose, FPU, MMX, XMM,
    or YMM registers, `whichReg` returns the value `regNone`. Here are some examples
    of calls to `whichReg`:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `whichReg` macro function accepts any of the x86-64 general-purpose, FPU,
    MMX, XMM, or YMM registers. In many situations, you might want to limit the set
    of registers to a particular subset of these. Therefore, Listing 13-11 (also available
    online at [http://artofasm.randallhyde.com/](http://artofasm.randallhyde.com/))
    provides the following macro functions:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '`isGPReg(``text``)` Returns a nonzero register value for any of the general-purpose
    (8-, 16-, 32-, or 64-bit) registers. Returns `regNone` (0) if the argument is
    not one of these registers.'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`is8BitReg(``text``)` Returns a nonzero register value for any of the general-purpose
    8-bit registers. Otherwise, it returns `regNone` (0).'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`is16BitReg(``text``)` Returns a nonzero register value for any of the general-purpose
    16-bit registers. Otherwise, it returns `regNone` (0).'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`is32BitReg(``text``)` Returns a nonzero register value for any of the general-purpose
    32-bit registers. Otherwise, it returns `regNone` (0).'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`is64BitReg(``text``)` Returns a nonzero register value for any of the general-purpose
    64-bit registers. Otherwise, it returns `regNone` (0).'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isFPReg(``text``)` Returns a nonzero register value for any of the FPU registers
    (`ST`, and `ST(0)` to `ST(7)`). Otherwise, it returns `regNone` (0).'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isMMReg(``text``)` Returns a nonzero register value for any of the MMX registers
    (`MM0` to `MM7`). Otherwise, it returns `regNone` (0).'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isXMMReg``(``text``)` Returns a nonzero register value for any of the XMM
    registers (`XMM0` to `XMM15`). Otherwise, it returns `regNone` (0).'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isYMMReg``(``text``)` Returns a nonzero register value for any of the YMM
    registers (`YMM0` to `YMM15`). Otherwise, it returns `regNone` (0).'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you need other register classifications, it’s easy to write your own macro
    functions to return an appropriate value. For example, if you want to test whether
    a particular register is one of the Windows ABI parameter registers (RCX, RDX,
    R8, or R9), you could create a macro function like the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If you’ve converted a register in text form to its numeric value, at some point
    you might need to convert that numeric value back to text so you can use that
    register as part of an instruction. The `toReg(``reg_num``)` macro in Listing
    13-10 accomplishes this. If you supply it a value in the range 1 to 117 (the numeric
    values for the registers), this macro will return the text that corresponds to
    that register value. For example:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: (Note that `regAL` = 1.)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: If you pass `regNone` to the `toReg` macro, `toReg` returns an empty string.
    Any value outside the range 0 to 117 will produce an undefined symbol error message.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'When working in macros, where you’ve passed a register as an argument, you
    may find that you need to convert that register to a larger size (for example,
    convert AL to AX, EAX, or RAX; convert AX to EAX or RAX; or convert EAX to RAX).
    Listing 13-11 provides several macros to do the up conversion. These macro functions
    accept a register number as their parameter input and produce a textual result
    holding the actual register name:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '`reg8To16` Converts an 8-bit general-purpose register to its 16-bit equivalent^([8](#c13-footnote-8))'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reg8To32` Converts an 8-bit general-purpose register to its 32-bit equivalent'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reg8To64` Converts an 8-bit general-purpose register to its 64-bit equivalent'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reg16To32` Converts a 16-bit general-purpose register to its 32-bit equivalent'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reg16To64` Converts a 16-bit general-purpose register to its 64-bit equivalent'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reg32To64` Converts a 32-bit general-purpose register to its 64-bit equivalent'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another useful macro function in Listing 13-10 is the `regSize(``reg_value``)`
    macro. This function returns the size (in bytes) of the register value passed
    as an argument. Here are some example calls:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The macros and equates in Listing 13-10 come in handy when you are writing macros
    to handle generic code. For example, suppose you want to create a `putInt` macro
    that accepts an arbitrary 8-, 16-, or 32-bit register operand and that will print
    that register’s value as an integer. You would like to be able to pass any arbitrary
    (general-purpose) register and sign-extend it, if necessary, before printing.
    [Listing 13-12](#listing13-12) is one possible implementation of this macro.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 13-12: `putInt` macro function test program'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for [Listing 13-12](#listing13-12):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Though [Listing 13-12](#listing13-12) is a relatively simple example, it should
    give you a good idea of how you could make use of the macros in Listing 13-10.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 13.17.4 Compile-Time Arrays
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A compile-time *constant array* is an array that exists only at compile time—data
    for the array does not exist at runtime. Sadly, MASM doesn’t provide direct support
    for this useful CTL data type. Fortunately, it’s possible to use other MASM CTL
    features to simulate compile-time arrays.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'This section considers two ways to simulate compile-time arrays: text strings
    and a list of equates (one equate per array element). The list of equates is probably
    the easiest implementation, so this section considers that first.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'In Listing 13-11 (available online), a very useful function converts all the
    text in a string to uppercase (`toUpper`). The register macros use this macro
    to convert register names to uppercase characters (so that register name comparisons
    are case-insensitive). The `toUpper` macro is relatively straightforward. It extracts
    each character of a string and checks whether that character’s value is in the
    range `a` to `z`, and if it is, it uses that character’s value as an index into
    an array (indexed from `a` to `z`) to extract the corresponding array element
    value (which will have the values `A` to `Z` for each element of the array). Here’s
    the `toUpper` macro:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The “magic” statements, which handle the array access, are these two statements:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `eachChar catstr` operation produces a string of the form `lc_a, lc_b,`
    . . . , `lc_z` whenever this macro encounters a lowercase character. The `result
    catstr` operation expands a label of the form `lc_a`, . . . , to its value and
    concatenates the result to the end of the `result` string (which is a register
    name). Immediately after the `toUpper` macro in Listing 13-11, you will find the
    following equates:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Therefore, `lc_a` will expand to the character `A`, `lc_b` will expand to the
    character `B`, and so forth. This sequence of equates forms the lookup table (array)
    that `toUpper` uses. The array should be called `lc_`, and the index into the
    array is the suffix of the array’s name (`a` to `z`). The `toUpper` macro accesses
    element `lc_[``character``]` by appending `character` to `lc_` and then expanding
    the text equate `lc_``character` (expansion happens by applying the `&` operator
    to the `eachChar` string the macro produces).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Note the following two things. First, the array index doesn’t have to be an
    integer (or ordinal) value. Any arbitrary string of characters will suffice.^([9](#c13-footnote-9))
    Second, if you supply an index that isn’t within bounds (`a` to `z`), the `toUpper`
    macro will attempt to expand a symbol of the form `lc_``xxxx` that results in
    an undefined identifier. Therefore, MASM will report an undefined symbol error
    should you attempt to supply an index that is not within range. This will not
    be an issue for the `toUpper` macro because `toUpper` validates the index (using
    a conditional `if` statement) prior to constructing the `lc_``xxxx` symbol.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 13-11 also provides an example of another way to implement a compile-time
    array: using a text string to hold array elements and using `substr` to extract
    elements of the array from that string. The `is``XX``BitReg` macros (`is8BitReg`,
    `is16BitReg`, and so forth) pass along a couple of arrays of data to the more
    generic `lookupReg` macro. Here’s the `is16BitReg` macro:^([10](#c13-footnote-10))'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `all16Regs` string is a list of register names (all concatenated together
    into one string). The `lookupReg` macro will search for a user-supplied register
    (`parm`) in this string of register names by using the MASM `instr` directive.
    If `instr` does not find the register in the list of names, `parm` is not a valid
    16-bit register and `instr` returns the value 0\. If it does locate the string
    held by `parm` in `all16Regs`, then `instr` returns the (nonzero) index into `all16Regs`
    where the match occurs. By itself, a nonzero index does not indicate that `lookupReg`
    has found a valid 16-bit register. For example, if the user supplies `PR` as a
    register name, the `instr` directive will return a nonzero index into the `all16Regs`
    string (the index of the last character of the `SP` register, with the `R` coming
    from the first character of the `R8W` register name). Likewise, if the caller
    passes the string `R8` to `is16BitReg`, the `instr` directive will return the
    index to the first character of the `R8W` entry, but R8 is not a valid 16-bit
    register.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `instr` can reject a register name (by returning 0), additional validation
    is necessary if `instr` returns a nonzero value; this is where the `all16Lens`
    array comes in. The `lookupReg` macro uses the index that `instr` returns as an
    index into the `all16Lens` array. If the entry is 0, the index into `all16Regs`
    is not a valid register index (it’s an index to a string that is not at the start
    of a register name). If the index into `all16Lens` points at a nonzero value,
    `lookupReg` compares this value against the length of the `parm` string. If they
    are equal, `parm` holds an actual 16-bit register name; if they are not equal,
    `parm` is too long or too short and is not a valid 16-bit register name. Here’s
    the full `lookupReg` macro:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that `lookupReg` also uses the register value constants (`regNone`, `regAL`,
    `regBL`, and so on) as an associative compile-time array (see the `regConst` definitions).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 13.18 Using Macros to Write Macros
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One advanced use of macros is to have a macro invocation create one or more
    new macros. If you nest a macro declaration inside another macro, invoking that
    (enclosing) macro will expand the enclosed macro definition and define that macro
    at that point. Of course, if you invoke the outside (enclosing) macro more than
    once, you could wind up with a duplicate macro definition unless you take care
    in the construction of the new macro (that is, by assigning it a new name with
    each new invocation of the outside macro). In a few cases, being able to generate
    macros on the fly can be useful.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Consider the compile-time array examples from the previous section. If you want
    to create a compile-time array by using the *multiple equates* method, you will
    have to manually define equates for all the array elements before you can use
    that array. This can be tedious, especially if the array has a large number of
    elements. Fortunately, it’s easy to create a macro to automate this process for
    you.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The following macro declaration accepts two arguments: the name of an array
    to create and the number of elements to put into the array. This macro generates
    a list of definitions (using the `=` directive, rather than the `textequ` directive)
    with each element initialized to 0:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'For example, the following macro invocation creates 10 array elements, named
    `ary0` to `ary9`:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can access the array elements directly by using the names `ary0`, `ary1`,
    `ary2`, . . . , `ary9`. If you want to access these array elements programmatically
    (perhaps in a compile-time `while` loop), you would have to use the `catstr` directive
    to create a text equate that has the array name (`ary`) concatenated with the
    index. Wouldn’t it be more convenient to have a macro function that creates this
    text equate for you? It’s easy enough to write a macro that does this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'With this macro, you can easily access elements of the `ary` array by using
    the macro invocation `ary_get(``index``)`. You could also write a macro to store
    a value into a specified element of the `ary` array:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: These two macros are so useful, you’d probably want to include them with each
    array you create with the `genArray` macro. So why not have the ``genArray macro
    write these macros for you? [Listing 13-13](#listing13-13) provides an implementation
    of `genArray` that does exactly this.``
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
