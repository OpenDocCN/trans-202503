["```\n$ `echo -n 'It is good to collect things,' > abc`\n$ ls -li abc\n 122232 -rw-r--r--   1 mtk      users          29 Jun 15 17:07 abc\n$ `ln abc xyz`\n$ `echo ' but it is better to go on walks.' >> xyz`\n$ `cat abc`\nIt is good to collect things, but it is better to go on walks.\n$ `ls -li abc xyz`\n 122232 -rw-r--r--   2 mtk      users          63 Jun 15 17:07 abc\n 122232 -rw-r--r--   2 mtk      users          63 Jun 15 17:07 xyz\n```", "```\n$ `rm abc`\n$ `ls -li xyz`\n 122232 -rw-r--r--   1 mtk      users          63 Jun 15 17:07 xyz\n```", "```\n#include <unistd.h>\n\nint `link`(const char **oldpath*, const char **newpath*);\n```", "```\n#include <unistd.h>\n\nint `unlink`(const char **pathname*);\n```", "```\n`dirs_links/t_unlink.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#define CMD_SIZE 200\n#define BUF_SIZE 1024\n\nint\nmain(int argc, char *argv[])\n{\n    int fd, j, numBlocks;\n    char shellCmd[CMD_SIZE];            /* Command to be passed to system() */\n    char buf[BUF_SIZE];                 /* Random bytes to write to file */\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s temp-file [num-1kB-blocks] \\n\", argv[0]);\n\n    numBlocks = (argc > 2) ? getInt(argv[2], GN_GT_0, \"num-1kB-blocks\")\n                           : 100000;\n\n    fd = open(argv[1], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n        errExit(\"open\");\n\n    if (unlink(argv[1]) == -1)          /* Remove filename */\n        errExit(\"unlink\");\n\n    for (j = 0; j < numBlocks; j++)     /* Write lots of junk to file */\n        if (write(fd, buf, BUF_SIZE) != BUF_SIZE)\n            fatal(\"partial/failed write\");\n\n    snprintf(shellCmd, CMD_SIZE, \"df -k `dirname %s`\", argv[1]);\n    system(shellCmd);                   /* View space used in file system */\n\n    if (close(fd) == -1)                /* File is now destroyed */\n        errExit(\"close\");\n    printf(\"********** Closed file descriptor\\n\");\n\n    system(shellCmd);                   /* Review space used in file system */\n    exit(EXIT_SUCCESS);\n}\n     `dirs_links/t_unlink.c`\n```", "```\n`$ ./t_unlink /tmp/tfile 1000000`\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/sda10             5245020   3204044   2040976  62% /\n********** Closed file descriptor\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/sda10             5245020   2201128   3043892  42% /\n```", "```\n#include <stdio.h>\n\nint `rename`(const char **oldpath*, const char **newpath*);\n```", "```\n    rename(\"sub1/x\", \"sub2/y\");\n    ```", "```\n#include <unistd.h>\n\nint `symlink`(const char **filepath*, const char **linkpath*);\n```", "```\n#include <unistd.h>\n\nssize_t `readlink`(const char **pathname*, char **buffer*, size_t *bufsiz*);\n```", "```\n#include <sys/stat.h>\n\nint `mkdir`(const char **pathname*, mode_t *mode*);\n```", "```\n#include <unistd.h>\n\nint `rmdir`(const char **pathname*);\n```", "```\n#include <stdio.h>\n\nint `remove`(const char **pathname*);\n```", "```\n#include <dirent.h>\n\nDIR *`opendir`(const char **dirpath*);\n```", "```\n#include <dirent.h>\n\nDIR *`fdopendir`(int fd);\n```", "```\n#include <dirent.h>\n\nstruct dirent *`readdir`(DIR **dirp*);\n```", "```\nstruct dirent {\n    ino_t d_ino;          /* File i-node number */\n    char  d_name[];       /* Null-terminated name of file */\n};\n```", "```\nerrno = 0;\ndirentp = readdir(dirp);\nif (direntp == `NULL`) {\n    if (errno != 0) {\n        /* Handle error */\n    } else {\n        /* We reached end-of-directory */\n    }\n}\n```", "```\n#include <dirent.h>\n\nvoid `rewinddir`(DIR **dirp*);\n```", "```\n#include <dirent.h>\n\nint `closedir`(DIR **dirp*);\n```", "```\n#define _BSD_SOURCE             /* Or: #define _SVID_SOURCE */\n#include <dirent.h>\n\nint `dirfd`(DIR **dirp*);\n```", "```\n`$ mkdir sub`                             *Create a test directory*\n`$ touch sub/a sub/b`                     *Make some files in the test directory*\n`$ ./list_files sub`                      *List contents of directory*\nsub/a\nsub/b\n```", "```\n`dirs_links/list_files.c`\n#include <dirent.h>\n#include \"tlpi_hdr.h\"\n\nstatic void             /* List all files in directory 'dirPath' */\nlistFiles(const char *dirpath)\n{\n    DIR *dirp;\n    struct dirent *dp;\n    Boolean isCurrent;          /* True if 'dirpath' is \".\" */\n\n    isCurrent = strcmp(dirpath, \".\") == 0;\n\n    dirp = opendir(dirpath);\n    if (dirp  == NULL) {\n        errMsg(\"opendir failed on '%s'\", dirpath);\n        return;\n    }\n\n    /* For each entry in this directory, print directory + filename */\n\n    for (;;) {\n        errno = 0;              /* To distinguish error from end-of-directory */\n        dp = readdir(dirp);\n        if (dp == NULL)\n            break;\n\n        if (strcmp(dp->d_name, \".\") == 0 || strcmp(dp->d_name, \"..\") == 0)\n            continue;           /* Skip . and .. */\n\n        if (!isCurrent)\n            printf(\"%s/\", dirpath);\n        printf(\"%s\\n\", dp->d_name);\n    }\n\n    if (errno != 0)\n        errExit(\"readdir\");\n\n    if (closedir(dirp) == -1)\n        errMsg(\"closedir\");\n}\n\nint\nmain(int argc, char *argv[])\n{\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [dir...]\\n\", argv[0]);\n\n    if (argc == 1)              /* No arguments - use current directory */\n        listFiles(\".\");\n    else\n        for (argv++; *argv; argv++)\n            listFiles(*argv);\n\n    exit(EXIT_SUCCESS);\n}\n      `dirs_links/list_files.c`\n```", "```\n#include <dirent.h>\n\nint `readdir_r`(DIR **dirp*, struct dirent **entry*, struct dirent ***result*);\n```", "```\nstruct dirent *entryp;\nsize_t len;\n\nlen = offsetof(struct dirent, d_name) + `NAME_MAX` + 1;\nentryp = malloc(len);\nif (entryp == NULL)\n    errExit(\"malloc\");\n```", "```\n#define _XOPEN_SOURCE 500\n#include <ftw.h>\n\nint `nftw`(const char **dirpath*,\n         int (**func*) (const char **pathname*, const struct stat **statbuf*,\n                      int *typeflag*, struct FTW **ftwbuf*),\n         int *nopenfd*, int *flags*);\n```", "```\nstruct FTW {\n    int base;       /* Offset to basename part of pathname */\n    int level;      /* Depth of file within tree traversal */\n};\n```", "```\n`dirs_links/nftw_dir_tree.c`\n#define _XOPEN_SOURCE 600       /* Get nftw() and S_IFSOCK declarations */\n#include <ftw.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName, const char *msg)\n{\n    if (msg != NULL)\n        fprintf(stderr, \"%s\\n\", msg);\n    fprintf(stderr, \"Usage: %s [-d] [-m] [-p] [directory-path]\\n\", progName);\n    fprintf(stderr, \"\\t-d Use FTW_DEPTH flag\\n\");\n    fprintf(stderr, \"\\t-m Use FTW_MOUNT flag\\n\");\n    fprintf(stderr, \"\\t-p Use FTW_PHYS flag\\n\");\n    exit(EXIT_FAILURE);\n}\n\nstatic int                      /* Function called by nftw() */\ndirTree(const char *pathname, const struct stat *sbuf, int type,\n        struct FTW *ftwb)\n{\n    switch (sbuf->st_mode & S_IFMT) {       /* Print file type */\n    case S_IFREG:  printf(\"-\"); break;\n    case S_IFDIR:  printf(\"d\"); break;\n    case S_IFCHR:  printf(\"c\"); break;\n    case S_IFBLK:  printf(\"b\"); break;\n    case S_IFLNK:  printf(\"l\"); break;\n    case S_IFIFO:  printf(\"p\"); break;\n    case S_IFSOCK: printf(\"s\"); break;\n    default:       printf(\"?\"); break;      /* Should never happen (on Linux) */\n    }\n\n    printf(\" %s  \",\n            (type == FTW_D)  ? \"D  \" : (type == FTW_DNR) ? \"DNR\" :\n            (type == FTW_DP) ? \"DP \" : (type == FTW_F)   ? \"F  \" :\n            (type == FTW_SL) ? \"SL \" : (type == FTW_SLN) ? \"SLN\" :\n            (type == FTW_NS) ? \"NS \" : \"  \");\n\n    if (type != FTW_NS)\n        printf(\"%7ld \", (long) sbuf->st_ino);\n    else\n        printf(\"        \");\n\n    printf(\" %*s\", 4 * ftwb->level, \"\");        /* Indent suitably */\n    printf(\"%s\\n\",  &pathname[ftwb->base]);     /* Print basename */\n    return 0;                                   /* Tell nftw() to continue */\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n\n    flags = 0;\n    while ((opt = getopt(argc, argv, \"dmp\")) != -1) {\n        switch (opt) {\n        case 'd': flags |= FTW_DEPTH;   break;\n        case 'm': flags |= FTW_MOUNT;   break;\n        case 'p': flags |= FTW_PHYS;    break;\n        default:  usageError(argv[0], NULL);\n        }\n    }\n\n    if (argc > optind + 1)\n        usageError(argv[0], NULL);\n\n    if (nftw((argc > optind) ? argv[optind] : \".\", dirTree, 10, flags) == -1) {\n        perror(\"nftw\");\n        exit(EXIT_FAILURE);\n    }\n    exit(EXIT_SUCCESS);\n}\n      `dirs_links/nftw_dir_tree.c`\n```", "```\n`$ mkdir dir`\n`$ touch dir/a dir/b`                 *Create some plain files*\n`$ ln -s a dir/sl`                    *and a symbolic link*\n`$ ln -s x dir/dsl`                   *and a dangling symbolic link*\n`$ mkdir dir/sub`                     *and a subdirectory*\n`$ touch dir/sub/x`                   *with a file of its own*\n`$ mkdir dir/sub2`                    *and another subdirectory*\n`$ chmod 0 dir/sub2`                  *that is not readable*\n```", "```\n`$ ./nftw_dir_tree dir`\nd D    2327983  dir\n- F    2327984      a\n- F    2327985      b\n- F    2327984      sl              *The symbolic link sl was resolved to  a*\nl SLN  2327987      dsl\nd D    2327988      sub\n- F    2327989          x\nd DNR  2327994      sub2\n```", "```\n`$ ./nftw_dir_tree -p -d dir`\n- F    2327984      a\n- F    2327985      b\nl SL   2327986      sl              *The symbolic link sl was not resolved*\nl SL   2327987      dsl\n- F    2327989          x\nd DP   2327988      sub\nd DNR  2327994      sub2\nd DP   2327983  dir\n```", "```\n#include <unistd.h>\n\nchar *`getcwd`(char **cwdbuf*, size_t *size*);\n```", "```\n#include <unistd.h>\n\nint `chdir`(const char **pathname*);\n```", "```\n#include <unistd.h>\n\nint `fchdir`(int *fd*);\n```", "```\nint fd;\n\nfd = open(\".\", O_RDONLY);       /* Remember where we are */\nchdir(somepath);                /* Go somewhere else */\nfchdir(fd);                     /* Return to original directory */\nclose(fd);\n```", "```\nchar buf[PATH_MAX];\n\ngetcwd(buf, PATH_MAX);          /* Remember where we are */\nchdir(somepath);                /* Go somewhere else */\nchdir(buf);                     /* Return to original directory */\n```", "```\n#define _XOPEN_SOURCE 700     /* Or define _POSIX_C_SOURCE >= 200809 */\n#include <fcntl.h>\n\nint `openat`(int *dirfd*, const char **pathname*, int\n *flags*, ... /* mode_t  *mode* */);\n```", "```\n#define _BSD_SOURCE\n#include <unistd.h>\n\nint `chroot`(const char **pathname*);\n```", "```\n    int fd;\n\n    fd = open(\"/\", O_RDONLY);\n    chroot(\"/home/mtk\");            /* Jailed */\n    fchdir(fd);\n    chroot(\".\");                    /* Out of jail */\n    ```", "```\n#include <stdlib.h>\n\nchar *`realpath`(const char **pathname*, char **resolved_path*);\n```", "```\n`$ pwd`                                       *Where are we?*\n/home/mtk\n`$ touch x`                                   *Make a file*\n`$ ln -s x y`                                 *and a symbolic link to it*\n`$ ./view_symlink y`\nreadlink: y --> x\nrealpath: y --> /home/mtk/x\n```", "```\n`dirs_links/view_symlink.c`\n#include <sys/stat.h>\n#include <limits.h>             /* For definition of PATH_MAX */\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE PATH_MAX\n\nint\nmain(int argc, char *argv[])\n{\n    struct stat statbuf;\n    char buf[BUF_SIZE];\n    ssize_t numBytes;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pathname\\n\", argv[0]);\n\n    if (lstat(argv[1], &statbuf) == -1)\n        errExit(\"lstat\");\n\n    if (!S_ISLNK(statbuf.st_mode))\n        fatal(\"%s is not a symbolic link\", argv[1]);\n\n    numBytes = readlink(argv[1], buf, BUF_SIZE - 1);\n    if (numBytes == -1)\n        errExit(\"readlink\");\n    buf[numBytes] = '\\0';                       /* Add terminating null byte */\n    printf(\"readlink: %s --> %s\\n\", argv[1], buf);\n\n    if (realpath(argv[1], buf) == NULL)\n        errExit(\"realpath\");\n    printf(\"realpath: %s --> %s\\n\", argv[1], buf);\n\n    exit(EXIT_SUCCESS);\n}\n      `dirs_links/view_symlink.c`\n```", "```\n#include <libgen.h>\n\nchar *`dirname`(char **pathname*);\nchar *`basename`(char **pathname*);\n```", "```\n`dirs_links/t_dirbasename.c`\n#include <libgen.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    char *t1, *t2;\n    int j;\n\n    for (j = 1; j < argc; j++)  {\n        t1 = strdup(argv[j]);\n        if (t1 == NULL)\n            errExit(\"strdup\");\n        t2 = strdup(argv[j]);\n        if (t2 == NULL)\n            errExit(\"strdup\");\n\n        printf(\"%s ==> %s + %s\\n\", argv[j], dirname(t1), basename(t2));\n\n        free(t1);\n        free(t2);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `dirs_links/t_dirbasename.c`\n```", "```\n    $ `cc -o longrunner longrunner.c`\n    $ `./longrunner &`                        *Leave running in background*\n    $ `vi longrunner.c`                       *Make some changes to the source code*\n    $ `cc -o longrunner longrunner.c`\n    ```", "```\n    mkdir(\"test\", S_IRUSR | S_IWUSR | S_IXUSR);\n    chdir(\"test\");\n    fd = open(\"myfile\", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    symlink(\"myfile\", \"../mylink\");\n    chmod(\"../mylink\", S_IRUSR);\n    ```"]