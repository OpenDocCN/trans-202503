- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MEMORY VULNERABILITIES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every application relies on computer memory to store and execute the application’s
    code. A *memory vulnerability* exploits a bug in the application’s memory management.
    The attack results in unintended behavior that could enable an attacker to inject
    and execute their own commands.
  prefs: []
  type: TYPE_NORMAL
- en: Memory vulnerabilities occur in programming languages where developers are responsible
    for applications’ memory management, such as in C and C++. Other languages, like
    Ruby, Python, PHP, and Java, manage memory allocation for developers, making these
    languages less susceptible to memory bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Before performing any dynamic action in C or C++, a developer must ensure that
    the proper amount of memory is allocated for the action. For example, suppose
    you’re coding a dynamic banking application that allows users to import transactions.
    When the application runs, you have no idea how many transactions users will import.
    Some could import one, and others might import a thousand. In languages without
    memory management, you must check the number of transactions being imported and
    then allocate the appropriate memory for them. When a developer doesn’t take into
    account how much memory they need for an application, bugs such as buffer overflows
    can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding and exploiting memory vulnerabilities is complex, and entire books
    have been written on the subject. For this reason, this chapter only provides
    an introduction to the topic by covering just two of the many memory vulnerabilities:
    buffer overflows and read out of bounds vulnerabilities. If you’re interested
    in learning more, I recommend reading *Hacking: The Art of Exploitation* by Jon
    Erickson or *A Bug Hunter’s Diary: A Guided Tour Through the Wilds of Software
    Security* by Tobias Klein; both are available from No Starch Press.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer Overflows**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *buffer overflow* vulnerability is a bug where an application writes data
    that is too big for the memory (the *buffer*) allocated for that data. Buffer
    overflows lead to unpredictable program behavior at best and serious vulnerabilities
    at worst. When an attacker can control the overflow to execute their own code,
    they can potentially compromise the application or, depending on user permissions,
    even the server. This type of vulnerability is similar to the RCE examples in
    [Chapter 12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Buffer overflows usually occur when a developer forgets to check the size of
    the data being written to a variable. They can also occur when a developer makes
    a mistake calculating how much memory the data requires. Because these errors
    can happen any number of ways, we’ll just examine one type—a *length check omission*.
    In the C programming language, omitted length checks commonly involve functions
    that alter memory, such as `strcpy()` and `memcpy()`. But these checks can also
    occur when developers use memory allocation functions, such as `malloc()` or `calloc()`.
    The function `strcpy()` (and `memcpy()`) takes two parameters: a buffer to copy
    data to and the data to copy. Here’s an example in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the string `src` ➊ is set to the string `"hello world"`, which
    is 11 characters long, including the space. This code allocates 16 bytes to `src`
    and `dest` ➋ (each character is 1 byte). Because each character requires 1 byte
    of memory and strings must end with a null byte (`\0`), the `"hello world"` string
    requires a total of 12 bytes, which fit within the 16-byte allocation. The `strcpy()`
    function then takes the string in `src` and copies it into `dest` ➌. The `printf`
    statements at ➍ print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as expected, but what if someone wanted to really emphasize
    that greeting? Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, five exclamation marks are added, bringing the total character count
    of the string up to 16\. The developer remembered that all strings must end with
    a null byte (`\0`) in C. They’ve allocated 17 bytes to `src` ➊ but forgot to do
    the same for `dest` ➋. After compiling and running the program, the developer
    would see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `src` variable is empty despite being assigned `'hello world!!!!!'`. This
    happens because of how C allocates *stack memory*. Stack memory addresses are
    assigned incrementally, so a variable defined earlier in the program will have
    a lower memory address than a variable defined after it. In this case, `src` is
    added to the memory stack, followed by `dest`. When the overflow occurs, the 17
    characters for `'hello world!!!!!!'` are written to the `dest` variable, but the
    string’s null byte (`\0`) overflows into the first character of the `src` variable.
    Because null bytes denote the end of a string, `src` appears to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](ch13.xhtml#ch13fig01) illustrates what the stack looks like as
    each line of code executes from ➊ to ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: How memory overflows from dest to src*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 13-1](ch13.xhtml#ch13fig01), `src` is added to the stack and 17 bytes
    are allocated to the variable, which are labeled in the figure starting from 0
    ➊. Next, `dest` is added to the stack but is only allocated 16 bytes ➋. When `src`
    is copied to `dest`, the last byte that would have been stored in `dest` overflows
    into the first byte of `src` (byte 0) ➌. This makes the first byte of `src` into
    a null byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you added another exclamation mark to `src` and updated the length to 18,
    the output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `dest` variable would only hold `'hello world!!!!!'`, and the final exclamation
    mark and null byte would overflow into `src`. This would make `src` appear as
    though it only held the string `'!'`. The memory shown in [Figure 13-1](ch13.xhtml#ch13fig01)
    ➌ would change to look like [Figure 13-2](ch13.xhtml#ch13fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Two characters overflow from dest to src*'
  prefs: []
  type: TYPE_NORMAL
- en: But what if the developer forgot about the null byte and used the exact length
    of the string, as follows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The developer counts the number of characters in the string without the null
    byte and allocates 12 bytes for the `src` and `dest` strings at ➊ and ➋. The rest
    of the program copies the `src` string into `dest` and prints the results, as
    the previous programs did. Let’s say the developer runs this code on their 64-bit
    processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the null byte overflowed from `dest` in the previous examples, you
    might expect that `src` would become an empty string. But the program’s output
    would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On modern 64-bit processors, this code would not cause unexpected behavior or
    a buffer overflow. The minimum memory allocation on 64-bit machines is 16 bytes
    (because of memory alignment design, which is beyond the scope of this book).
    On 32-bit systems, it’s 8 bytes. Because `hello world!` requires only 13 bytes,
    including the null byte, it doesn’t overflow the minimum 16 bytes allocated to
    the `dest` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read Out of Bounds**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast, the *read out of bounds* vulnerability can allow attackers to read
    data outside a memory boundary. This vulnerability occurs when an application
    reads too much memory for a given variable or action. Reading out of bounds might
    leak sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: A famous read out of bounds vulnerability is the *OpenSSL Heartbleed bug*, which
    was disclosed in April 2014\. OpenSSL is a software library that allows application
    servers to securely communicate over networks without fear of eavesdroppers. Through
    OpenSSL, applications can identify the server at the other end of the communication.
    Heartbleed allowed attackers to read arbitrary data during communications, such
    as server private keys, session data, passwords, and so on, through OpenSSL’s
    server identification process.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability makes use of OpenSSL’s heartbeat request functionality, which
    sends a message to a server. The server then returns the same message to the requester
    to verify that both servers are in communication. Heartbeat requests might include
    a length parameter, which is the factor that led to the vulnerability. Vulnerable
    versions of OpenSSL allocated memory for the server’s return message based on
    the length parameter sent with the request rather than the actual size of the
    message to be echoed back.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, an attacker could exploit Heartbleed by sending a heartbeat request
    with a large length parameter. Let’s say a message was 100 bytes, and an attacker
    sent 1,000 bytes as the length of the message. Any vulnerable servers the attacker
    sent the message to would read the 100 bytes of the intended message and an additional
    900 bytes of arbitrary memory. The information included in the arbitrary data
    depends on the vulnerable server’s running processes and memory layout at the
    time of the request processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP ftp_genlist() Integer Overflow**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://bugs.php.net/bug.php?id=69545/](https://bugs.php.net/bug.php?id=69545/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 28, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: Languages that manage memory for developers are not immune to memory vulnerabilities.
    Although PHP automatically manages memory, the language is written in C, which
    does require memory management. As a result, built-in PHP functions could be vulnerable
    to memory vulnerabilities. Such was the case when Max Spelsberg discovered a buffer
    overflow in PHP’s FTP extension.
  prefs: []
  type: TYPE_NORMAL
- en: PHP’s FTP extension reads incoming data, such as files, to track the size and
    number of lines received in the `ftp_genlist()` function. Variables for size and
    lines were initialized as unsigned integers. On a 32-bit machine, unsigned integers
    have a maximum memory allocation of 2^(32) bytes (4,294,967,295 bytes or 4GB).
    So if an attacker sent more than 2^(32) bytes, the buffers would overflow.
  prefs: []
  type: TYPE_NORMAL
- en: As part of his proof of concept, Spelsberg provided the PHP code to start an
    FTP server and Python code to connect to it. Once the connection was made, his
    Python client sent 2^(32) + 1 bytes over the socket connection to the FTP server.
    The PHP FTP server crashed because Spelsberg had overridden memory, similar to
    what happened in the previously discussed buffer overflow example.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflows are a well-known and well-documented vulnerability type, but
    you can still find them in applications that manage their own memory. Even if
    an application you’re testing isn’t coded in C or C++, you might still discover
    a buffer overflow if the application is coded in a language that is written in
    another language vulnerable to memory management bugs. In those cases, look for
    places where variable length checks have been omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Hotshot Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://bugs.python.org/issue24481](http://bugs.python.org/issue24481)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** June 20, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: Like PHP, the Python programming language is traditionally written in C. In
    fact, sometimes it’s referred to as CPython (Python versions written in other
    languages, including Jython, PyPy, and so on, also exist). The Python hotshot
    module is a replacement for the existing Python profile module. The hotshot module
    describes how often and for how long various parts of a program execute. Hotshot
    is written in C, so it has a smaller performance impact than the existing profile
    module. But in June 2015, John Leitch discovered a buffer overflow in the code
    that allowed an attacker to copy a string from one memory location to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerable code called the method `memcpy()`, which copies a specified
    number of bytes of memory from one location to another. For example, the vulnerable
    code could have looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `memcpy()` method takes three parameters: a destination, a source, and
    the number of bytes to copy. In this example, those values are the variables `self->buffer
    + self->index` (the sum of the buffer and index lengths), `s`, and `len`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The `self->buffer` destination variable would always have a fixed length. But
    `s`, the source variable, could be any length. This meant that when executing
    the copy function, `memcpy()` wouldn’t validate the size of the buffer it was
    writing to. An attacker could pass the function a string longer than the number
    of bytes allocated to copy. The string would be written to the destination and
    overflow, so it would continue writing past the intended buffer and into other
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One method of finding buffer overflows is to look for the functions `strcpy()`
    and `memcpy()`. If you find these functions, validate that they have proper buffer
    length checks. You’ll need to work backward from code that you find to confirm
    you can control the source and destination to overflow the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Libcurl Read Out of Bounds**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://curl.haxx.se/docs/adv_20141105.html](http://curl.haxx.se/docs/adv_20141105.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** November 5, 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $1,000'
  prefs: []
  type: TYPE_NORMAL
- en: Libcurl is a free, client-side URL transfer library that the cURL command line
    tool uses to transfer data. Symeon Paraschoudis discovered a vulnerability in
    the libcurl `curl_easy_duphandle` function that could have been exploited to exfiltrate
    sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: When performing a transfer with libcurl, you can pass data to send with a `POST`
    request using the `CURLOPT_POSTFIELDS` flag. But performing this action doesn’t
    guarantee the data will be preserved during the action. To ensure the data is
    not changed while it’s sent with the `POST` request, another flag, `CURLOPT_COPYPOSTFIELDS`,
    copies the data’s contents and sends the copy with the `POST` request. The memory
    area’s size is set through another variable named `CURLOPT_POSTFIELDSIZE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy the data, cURL would allocate memory. But the internal libcurl function
    that duplicated the data had two problems: first, copying the `POST` data incorrectly
    would cause libcurl to treat the `POST` data buffer as a C string. Libcurl would
    assume the `POST` data ended with a null byte. When the data didn’t, libcurl would
    continue reading the string beyond the allocated memory until it found a null
    byte. This could result in libcurl copying a string that was too small (if a null
    byte was included in the middle of the `POST` body), too large, or might crash
    the application. Second, after duplicating the data, libcurl didn’t update where
    it was supposed to read the data from. This was an issue: between the time libcurl
    duplicated the data and read from the data, the memory could have been cleared
    or reused for other purposes. If either of these events happened, the location
    could have contained data not mean to be sent.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The cURL tool is a very popular and stable library for transferring data over
    networks. Despite its popularity, it still has bugs. Any functionality involved
    in copying memory is a great place to begin looking for memory bugs. Like the
    other memory examples, read out of bounds vulnerabilities are tough to discover.
    But if you start by searching for commonly vulnerable functions, you’ll be more
    likely to find a bug.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memory vulnerabilities can allow attackers to read leaked data or run their
    own code, but these vulnerabilities are difficult to find. Modern programming
    languages are less susceptible to memory vulnerabilities because they handle their
    own memory allocation. But applications written in languages that require the
    developer to allocate memory are still susceptible to memory bugs. To discover
    memory vulnerabilities, you need knowledge of memory management, which can be
    complex and might even depend on hardware. If you want to search for these types
    of exploits, I recommend you also read other books dedicated entirely to the topic.
  prefs: []
  type: TYPE_NORMAL
