- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BOOLEAN ALGEBRA**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Boolean algebra* was developed in the 19th century by an English mathematician,
    George Boole, who was working on ways to use mathematical rigor to solve logic
    problems. He formalized a mathematical system for manipulating logical values
    in which the only possible values for the variables are *true* and *false*, usually
    designated `1` and `0`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic operations in Boolean algebra are *conjunction* (AND), *disjunction*
    (OR), and *negation* (NOT). This distinguishes it from elementary algebra, which
    includes the infinite set of real numbers and uses the arithmetic operations addition,
    subtraction, multiplication, and division. (Exponentiation is a simplified notation
    for repeated multiplication.)
  prefs: []
  type: TYPE_NORMAL
- en: While mathematicians and logicians were expanding the field of Boolean algebra
    in increasingly complex and abstract ways, engineers were learning to harness
    electrical flows using switches in circuits to perform logic operations. The two
    fields developed in parallel until the mid-1930s, when a graduate student named
    Claude Shannon proved that electrical switches could be used to implement the
    full range of Boolean algebraic expressions. (When used to describe switching
    circuits, Boolean algebra is sometimes called *switching algebra*.) With Shannon’s
    discovery, a world of possibilities was opened and Boolean algebra became the
    mathematical foundation of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll start with descriptions of the basic Boolean operators.
    Then, you’ll learn about their logical rules, which form the basis of Boolean
    algebra. Next, I’ll explain ways to combine Boolean variables and operators into
    algebraic expressions to form Boolean logic functions. Finally, I’ll discuss techniques
    for simplifying Boolean functions. In subsequent chapters, you’ll learn how electronic
    on/off switches can be used to implement logic functions that can be connected
    together in logic circuits to perform the primary functions of a computer: arithmetic,
    logic operations, and memory storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Boolean Operators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Boolean operator acts on a value or pair of values called the *operand(s)*.
    There are several symbols used to denote each Boolean operator, which I’ll include
    in the description of each of the operators. In this book, I’ll present the symbols
    used by logicians.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use truth tables to show the results of each operation. A *truth table*
    shows the results for all possible combinations of the operands. For example,
    consider the addition of two bits, *x* and *y*. There are four possible combinations
    of the values, one of which is addition, which will give a sum and a possible
    carry. [Table 4-1](ch04.xhtml#ch4tab1) shows how to express this in a truth table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** A Truth Table for Addition of Two Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***Carry*** | ***Sum*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: I’ll also provide the electronic circuit representations for *gates*, which
    are the electronic devices that implement the Boolean operators. You’ll learn
    more about these devices in [Chapters 5](ch05.xhtml) through [8](ch08.xhtml),
    where you’ll also see that the real-world behavior of the physical devices varies
    slightly from the ideal mathematical behavior shown in the truth tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with elementary algebra, you can combine these basic operators to define
    secondary operators. You’ll see an example of this when I define the XOR operator
    near the end of this chapter. For now, let’s take a look at the basic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AND**'
  prefs: []
  type: TYPE_NORMAL
- en: AND is a *binary operator*, meaning it acts on two operands. The result of AND
    is `1` if and only if *both* operands are `1`; otherwise, the result is `0`. In
    logic, this operation is known as *conjunction*. I’ll use ∧ to designate the AND
    operation. It’s also common to use the *·* symbol or simply AND.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](ch04.xhtml#ch4fig1) shows the circuit symbol for an AND gate and
    a truth table defining the output, with operands *x* and *y*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: An AND gate acting on two variables,* x *and* y'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the truth table, the AND operator has properties similar to
    multiplication in elementary algebra, which is why some use the *·* symbol to
    represent it.
  prefs: []
  type: TYPE_NORMAL
- en: '**OR**'
  prefs: []
  type: TYPE_NORMAL
- en: OR is also a binary operator. The result of OR is `1` if at least one of the
    operands is `1`; otherwise, the result is `0`. In logic, this operation is known
    as *disjunction*. I’ll use ∨ to designate the OR operation. It’s also common to
    use the + symbol or simply OR. [Figure 4-2](ch04.xhtml#ch4fig2) shows the circuit
    symbol for an OR gate and a truth table defining the output, with operands *x*
    and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: An OR gate acting on two variables,* x *and* y'
  prefs: []
  type: TYPE_NORMAL
- en: The truth table shows that the OR operator follows rules somewhat similar to
    addition in elementary algebra, which is why some use the + symbol to represent
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOT**'
  prefs: []
  type: TYPE_NORMAL
- en: NOT is a *unary operator*, which acts on only one operand. The result of NOT
    is `1` if the operand is `0` and `0` if the operand is `1`. Other names for the
    NOT operation are *complement* and *invert*. I’ll use ¬ to designate the NOT operation.
    It’s also common to use the `'` symbol, an overscore above the variable, or simply
    NOT. [Figure 4-3](ch04.xhtml#ch4fig3) shows the circuit symbol for a NOT gate
    and a truth table defining the output, with the operand *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg83_Image_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: A NOT gate acting on one variable,* x'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see, NOT has some properties of the arithmetic negation used in elementary
    algebra, but there are some significant differences.
  prefs: []
  type: TYPE_NORMAL
- en: It’s no accident that AND is multiplicative and OR is additive. George Boole
    developed his algebra to apply mathematical rigor to logic and use addition and
    multiplication to manipulate logical statements. He developed the rules based
    on using AND for multiplication and OR for addition. In the next section, you’ll
    learn how to use these operators, together with NOT, to represent logical statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Expressions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as you can use elementary algebra operators to combine variables into expressions
    such as (*x* + *y*), you can use Boolean operators to combine variables into expressions.
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant difference, though. A Boolean expression is created from
    values (`0` and `1`) and literals. In Boolean algebra, a *literal* is a single
    instance of a variable or its complement that’s being used in an expression. In
    the expression
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg84_Image_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: there are three variables (*x*, *y*, and *z*) and seven literals. In a Boolean
    expression, you have a variable in both its complemented form and its uncomplemented
    form, because each form is a separate literal.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine literals using either the ∧ or the ∨ operator. Like in elementary
    algebra, Boolean algebra expressions are made up of *terms*—groups of literals
    that are acted upon by operators, such as (*x* ∨ *y*) or (*a* ∧ *b*)—and *operation
    precedence* (or *order of operations*) specifies how these operators are applied
    when evaluating an expression. [Table 4-2](ch04.xhtml#ch4tab2) lists the precedence
    rules for the Boolean operators. As with elementary algebra, expressions in parentheses
    are evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Precedence Rules for Boolean Algebra Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notation** | **Precedence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | ¬*x* | Highest |'
  prefs: []
  type: TYPE_TB
- en: '| AND | *x* ∧ *y* | Middle |'
  prefs: []
  type: TYPE_TB
- en: '| OR | *x* ∨ *y* | Lowest |'
  prefs: []
  type: TYPE_TB
- en: Now that you know how the three fundamental Boolean operators work, we’ll look
    at some of the rules they obey when used in algebraic expressions. As you’ll see
    later in the chapter, we can use the rules to simplify Boolean expressions, which
    will allow us to simplify the way we implement those expressions in the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to simplify Boolean expressions is an important tool for both those
    making hardware and those writing software. A computer is just a physical manifestation
    of Boolean logic. Even if your only interest is in programming, every programming
    statement you write is ultimately carried out by hardware that is completely described
    by the system of Boolean algebra. Our programming languages tend to hide much
    of this through abstraction, but they still use Boolean expressions to implement
    programming logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Algebra Rules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When comparing AND and OR in Boolean algebra to multiplication and addition
    in elementary algebra, you’ll find that some of the rules of Boolean algebra are
    familiar but others are significantly different.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rules That Are the Same as Elementary Algebra***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the rules that are the same; in the next section, we’ll look
    at the ones that differ. These rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AND and OR are associative**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We say that an operator is *associative* if we can change the order of applying
    two or more occurrences of the operator in an expression without changing the
    value of the expression. Mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg85_Image_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To prove the associative rule for AND and OR, let’s use exhaustive truth tables,
    as shown in [Tables 4-3](ch04.xhtml#ch4tab3) and [4-4](ch04.xhtml#ch4tab4). [Table
    4-3](ch04.xhtml#ch4tab3) lists all possible values of the variables *x*, *y*,
    and *z*, as well as the intermediate computations of the terms (*y* ∧ *z*) and
    (*x* ∧ *y*). In the last two columns, I compute the values of each expression
    on both sides of the previous equations, which shows that the two equalities hold.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** The Associativity of the AND Operation'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***z*** | (***y*** ∧ ***z***) | (***x*** ∧ ***y***) |
    ***x*** ∧ (***y*** ∧ ***z***) | (***x*** ∧ ***y***) ∧ ***z*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 4-4](ch04.xhtml#ch4tab4) lists all possible values of the variables
    *x*, *y*, and *z*, as well as the intermediate computations of the terms (*y*
    ∨ *z*) and (*x* ∨ *y*). In the last two columns, I compute the values of each
    expression on both sides of the previous equations, which again shows that the
    two equalities hold.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** The Associativity of the OR Operation'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***z*** | (***y*** ∨ ***z***) | (***x*** ∨ ***y***) |
    ***x*** ∨ (***y*** ∨ ***z***) | (***x*** ∨ ***y***) ∨ ***z*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: This strategy works for each of the rules shown in this section, but I’ll only
    go through the truth table for the associative rule here. You’ll get to do this
    for the other rules in “Your Turn” [exercise 4.1](ch04.xhtml#ch4exe1) on [page
    61](ch04.xhtml#ch4you1).
  prefs: []
  type: TYPE_NORMAL
- en: '**AND and OR have identity values**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *identity value* is a value specific to an operation, such that using that
    operation on a quantity with the identity value yields the value of the original
    quantity. For AND and OR, the identity values are `1` and `0`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**AND and OR are commutative**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can say that an operator is *commutative* if we can reverse the order of
    its operands without changing the result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**AND is distributive over OR**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AND operator applied to quantities OR-ed together can be *distributed*
    to apply to each of the OR-ed quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike in elementary algebra, the additive OR *is* distributive over the multiplicative
    AND. You’ll see this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**AND has an annulment (also called annihilation) value**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *annulment value* is a value such that operating on a quantity with the
    annulment value yields the annulment value. The annulment value for AND is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg86_Image_59.jpg) We’re used to 0 being the annulment value
    for multiplication in elementary algebra, but addition has no concept of annulment.
    You’ll learn about the annulment value for OR in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOT shows involution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator shows *involution* if applying it to a quantity twice yields the
    original quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Involution is simply the application of a double complement: NOT(NOT true)
    = true. This is similar to double negation in elementary algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Rules That Differ from Elementary Algebra***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although AND is multiplicative and OR is additive, there are significant differences
    between these logical operations and the arithmetic ones. The differences stem
    from the fact that Boolean algebra deals with logic expressions that evaluate
    to either true or false, while elementary algebra deals with the infinite set
    of real numbers. In this section, you’ll see expressions that might remind you
    of elementary algebra, but the Boolean algebra rules are different. Those rules
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OR is distributive over AND**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The OR operator applied to quantities AND-ed together can be distributed to
    apply to each of the AND-ed quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because addition is not distributive over multiplication in elementary algebra,
    you might overlook this way of manipulating Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at elementary algebra. Using addition for OR and multiplication
    for AND in the previous equation, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg87_Image_62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we plug in the numbers *x* = 1, *y* = 2, and *z* = 3, the left-hand side
    gives
  prefs: []
  type: TYPE_NORMAL
- en: 1 + (2 · 3) = 7
  prefs: []
  type: TYPE_NORMAL
- en: 'and the right-hand side gives:'
  prefs: []
  type: TYPE_NORMAL
- en: (1 + 2) · (1 + 3) = 12
  prefs: []
  type: TYPE_NORMAL
- en: Thus, addition is *not* distributive over multiplication in elementary algebra.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to show that OR is distributive over AND in Boolean algebra is
    to use a truth table, as shown in [Table 4-5](ch04.xhtml#ch4tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-5:** OR Distributes over AND'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***z*** | ***x*** ∨ (***y*** ∧ ***z***) | (***x*** ∨
    ***y***) ∧ (***x*** ∨ ***z***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: Comparing the two right-hand columns, you can tell that OR-ing the variable,
    *x*, with each of the two AND-ed variables, *y* and *z*, gives the same result
    as OR-ing it with each of the variables and AND-ing the two OR-ed terms. Thus,
    the distributive property holds.
  prefs: []
  type: TYPE_NORMAL
- en: '**OR has an annulment (also called annihilation) value**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no annulment value for addition in elementary algebra, but in Boolean
    algebra, the annulment value for OR is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**AND and OR both have a complement value**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *complement value* is the diminished radix complement of the variable.
    You learned in [Chapter 3](ch03.xhtml) that the sum of a quantity and that quantity’s
    diminished radix complement is equal to (*radix* – 1). Since the radix in Boolean
    algebra is 2, the complement of `0` is `1` and the complement of `1` is `0`. So,
    the complement of a Boolean quantity is simply the NOT of that quantity, which
    gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The complement value illustrates one of the differences between the AND and
    OR logical operations and the multiplication and addition arithmetic operations.
    In elementary algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg88_Image_65.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even if we restrict *x* to be 0 or 1, in elementary algebra 1 · (–1) = –1 and
    1 + (–1) = 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**AND and OR are idempotent**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an operator is *idempotent*, applying it to two of the same operands results
    in that operand. In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This looks different than in elementary algebra, where repeatedly multiplying
    a number by itself is exponentiation and repeatedly adding a number to itself
    is equivalent to multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '**De Morgan’s law applies**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Boolean algebra, the special relationship between the AND and OR operations
    is captured by *De Morgan’s law*, which states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg89_Image_67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first equation states that the NOT of the AND of two Boolean quantities
    is equal to the OR of the NOT of the two quantities. The second equation states
    that the NOT of the OR of two Boolean quantities is equal to the AND of the NOT
    of the two quantities.
  prefs: []
  type: TYPE_NORMAL
- en: This relationship is an example of the *principle of duality*, which in Boolean
    algebra states that if you replace every `0` with a `1`, every `1` with a `0`,
    every AND with an OR, and every OR with an AND, the equation is still true. Look
    back over the rules just given and you’ll see that all of them except involution
    have dual operations. De Morgan’s law is one of the best examples of duality;
    you’ll see this principle in play when you complete “Your Turn” [exercise 4.2](ch04.xhtml#ch4exe2).
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1     Use truth tables to prove the Boolean algebra rules given in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2     Prove De Morgan’s law.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functionality of a computer is based on Boolean logic, which means the various
    operations of a computer are specified by Boolean functions. A Boolean function
    looks somewhat like a function in elementary algebra, but the variables can appear
    in either uncomplemented or complemented form. The variables and constants are
    connected by Boolean operators. A Boolean function evaluates to either `1` or
    `0` (true or false).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discussed addition in the binary number system on [page 41](ch03.xhtml#page_41)
    in [Chapter 3](ch03.xhtml), you saw that when adding two bits, *x* and *y*, we
    have to include a possible carry into their bit position in the computation. The
    conditions that cause the carry out from the bit position to be `1` are:'
  prefs: []
  type: TYPE_NORMAL
- en: there’s no carry into the current bit position, *x* = `1`, and *y* = `1`, or
  prefs: []
  type: TYPE_NORMAL
- en: there’s a carry into the current bit position, *x* = `0`, and *y* = `1`, or
  prefs: []
  type: TYPE_NORMAL
- en: there’s a carry into the current bit position, *x* = `1`, and *y* = `0`, or
  prefs: []
  type: TYPE_NORMAL
- en: there’s a carry into the current bit position, *x* = `1`, and *y* = `1`.
  prefs: []
  type: TYPE_NORMAL
- en: We can express this more concisely with the Boolean function
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_68.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *x* is one bit, *y* is the other bit, *c[in]* is the carry in from the
    next lower-order bit position, and *C[out]*(*c[in]*, *x*, *y*) is the carry resulting
    from the addition in the current bit position. We’ll use this equation throughout
    this section, but first, let’s think a bit about the differences between Boolean
    and elementary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Like an elementary algebra function, a Boolean algebra function can be manipulated
    mathematically, but the mathematical operations are different. Operations in elementary
    algebra are performed on the infinite set of real numbers, but Boolean functions
    work on only two possible values, `0` or `1`. Elementary algebra functions can
    evaluate to any real number, but Boolean functions can evaluate only to `0` or
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This difference means we have to think differently about Boolean functions.
    For example, look at this elementary algebra function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_69.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You probably read it as “if I multiply the value of *x* by the negative of the
    value of *y*, I’ll get the value of *F*(*x*, *y*).” However, with the Boolean
    function
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg90_Image_70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: there are only four possibilities. If *x* = 1 and *y* = 0, then *F*(*x*, *y*)
    = `1`; for the other three possibilities, *F*(*x*, *y*) = `0`. Whereas you can
    plug any numbers into an elementary algebra function, a Boolean algebra function
    shows you what the values of the variables are that cause the function to evaluate
    to `1`. I think of elementary algebra functions as *asking* me to plug in values
    for the variables for evaluation, while Boolean algebra functions *tell* me what
    values of the variables cause the function to evaluate to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: There are simpler ways to express the conditions for carry, and those simplifications
    lead to being able to implement a Boolean function for carry with fewer logic
    gates, thus lowering the cost and power usage. In this and the following sections,
    you’ll learn how the mathematical nature of Boolean algebra makes function simplification
    easier and more concise.
  prefs: []
  type: TYPE_NORMAL
- en: '***Canonical Sum or Sum of Minterms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *canonical form* of a Boolean function explicitly shows whether each variable
    in the problem is complemented or not in each term that defines the function,
    just as we did with our plain-language statement of the conditions that produce
    a carry of `1` earlier. This ensures that you have taken all possible combinations
    into account in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the equation for carry on [page 62](ch04.xhtml#page_62) to illustrate
    these concepts. Although the parentheses in the equation are not required, I’ve
    added them to help you see the form of the equation. The parentheses show four
    *product terms*, which are terms where all the literals are operated on only by
    AND. The four product terms are then OR-ed together. Since the OR operation is
    like addition, the right-hand side is called a *sum of products*. It’s also said
    to be in *disjunctive normal form*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look more closely at the product terms. Each of them includes all the
    variables in this equation in the form of a literal (uncomplemented or complemented).
    An equation that has *n* variables has 2*^n* permutations of the values for the
    variables; a *minterm* is a product term that specifies exactly one of the permutations.
    Since there are four combinations of values for *c[in]*, *x*, and *y* that produce
    a carry of `1`, the previous equation has four of the possible eight minterms.
    A Boolean function that is defined by summing (ORing) all the minterms that evaluate
    to `1` is said to be a *canonical sum*, a *sum of minterms*, or in *full disjunctive
    normal form*. A function defined by a sum of minterms evaluates to `1` when at
    least one of the minterms evaluates to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: For every minterm, exactly one set of values for the variables makes the minterm
    evaluate to `1`. For example, the minterm (*c[in]* ∧ *x* ∧ ¬*y*) in the previous
    equation evaluates to `1` only when *c[in]* = `1`, *x* = `1`, *y* = `0`. A product
    term that does not contain all the variables in the problem, in either uncomplemented
    or complemented form, will always evaluate to `1` for more sets of values for
    the variables than a minterm. For example, (*c[in]* ∧ *x*) evaluates to `1` for
    *c[in]* = `1`, *x* = `1`, *y* = `0` and for *c[in]* = `1`, *x* = `1`, *y* = `1`.
    (We call them *min*terms because they minimize the number of cases that evaluate
    to `1`.)
  prefs: []
  type: TYPE_NORMAL
- en: Rather than write out all the literals in a function, logic designers commonly
    use the notation *m[i]* to specify the *i*th minterm, where *i* is the integer
    represented by the values of the literals in the problem if the values are placed
    in order and treated as binary numbers. For example, *c[in]* = `1`, *x* = `1`,
    *y* = `0` gives `110`, which is the (base 10) number 6; thus, that minterm is
    *m*[6].
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-6](ch04.xhtml#ch4tab6) shows all eight possible minterms for the three-variable
    function that specifies carry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-6:** The Conditions That Cause Carry to Be `1`'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***c******[in]*** | ***x*** | ***y*** | Minterm | ***C****[out]***(***c******[in]******,
    x, y***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | *m*[0]     (¬*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | *m*[1]     (¬*c[in]* ∧ ¬*x* ∧ *y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | *m*[2]     (¬*c[in]* ∧ *x* ∧ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | *m*[3]     (¬*c[in]* ∧ *x* ∧ *y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | *m*[4]     (*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | *m*[5]     (*c[in]* ∧ ¬*x* ∧ *y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | *m*[6]     (*c[in]* ∧ *x* ∧ ¬*y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | *m*[7]     (*c[in]* ∧ *x* ∧ y) | `1` |'
  prefs: []
  type: TYPE_TB
- en: The *C[out]*(*c[in]*, *x*, *y*) column shows which minterms in our equation
    cause it to evaluate to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this notation to write a Boolean equation as a canonical sum and using
    the ∑ symbol to denote summation, we can restate the function for carry as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg92_Image_71.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are looking at a simple example here. For more complicated functions, writing
    out all the minterms is error-prone. The simplified notation is easier to work
    with and helps avoid making errors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Canonical Product or Product of Maxterms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on factors like available components and personal choice, a designer
    may prefer to work with the cases where a function evaluates to `0` instead of
    `1`. In our example, that means a design that specifies when the complement of
    carry is `0`. To see how this works, let’s take the complement of both sides of
    the equation for specifying carry, using De Morgan’s law:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg92_Image_72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we complemented both sides of the equation, we now have the Boolean
    equation for ¬*C[out]*, the complement of carry. Thus, we are looking for conditions
    that cause ¬*C[out]* to evaluate to `0`, not `1`. In this equation, the parentheses
    are required due to the precedence rules of Boolean operators. The parentheses
    show four *sum terms*, which are terms where all the literals are operated on
    only by OR. The four sum terms are then AND-ed together. Since the AND operation
    is like multiplication, the right-hand side is called a *product of sums*. It’s
    also said to be in *conjunctive normal form*.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the sum terms includes all the variables in this equation in the form
    of literals (uncomplemented or complemented). Whereas a minterm was a *product*
    term that specified a single permutation of the 2*^n* permutations of possible
    values for the variables, a *maxterm* is a *sum* term specifying exactly one of
    those permutations. A Boolean function that is defined by multiplying (AND-ing)
    all the maxterms that evaluate to `0` is said to be a *canonical product*, a *product
    of maxterms*, or in *full conjunctive normal form*.
  prefs: []
  type: TYPE_NORMAL
- en: Each maxterm identifies exactly one set of values for the variables in a function
    that cause the term to evaluate to `0` when OR-ed together. For example, the maxterm
    (¬*c[in]* ∨ ¬*x* ∨ *y*) in the previous equation evaluates to `0` only when *c[in]*
    = `1`, *x* = `1`, *y* = `0`. But a sum term that does not contain all the variables
    in the problem, in either uncomplemented or complemented form, will always evaluate
    to `0` for more than one set of values. For example, the sum term (¬*c[in]* ∨
    ¬*x*) evaluates to `0` for two sets of values for the three variables in this
    example, *c[in]* = `1`, *x* = `1`, *y* = `0` and *c[in]* = `1`, *x* = `1`, and
    *y* = `1`. (We call them *max*terms because they minimize the number of cases
    that evaluate to `0` and thus *maximize* the number of cases that evaluate to
    `1`.)
  prefs: []
  type: TYPE_NORMAL
- en: Rather than write out all the literals in a function, logic designers commonly
    use the notation *M[i]* to specify the *i*th maxterm, where *i* is the integer
    value of the base 2 number created by concatenating the values of the literals
    in the problem. For example, stringing together *c[in]* = `1`, *x* = `1`, *y*
    = `0` gives `110`, which is the maxterm *M*[6]. The truth table in [Table 4-7](ch04.xhtml#ch4tab7)
    shows the maxterms that cause the carry to be `0`. Notice that maxterm *M*[6]
    = (¬*c[in]* ∨ ¬*x* ∨ *y*) evaluates to `0` when *c[in]* = `1`, *x* = `1`, and
    *y* = `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-7](ch04.xhtml#ch4tab7) shows all eight possible maxterms for the three-variable
    function that specifies the complement of carry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-7:** The Conditions That Cause the Complement of Carry to Be `0`'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***c******[in]*** | ***x*** | ***y*** | Maxterm | **¬*****C******[out]***(***c******[in]******,
    x, y***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | *M*[0]     (*c[in]* ∨ *x* ∨ *y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | *M*[1]     (*c[in]* ∨ *x* ∨ ¬*y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | *M*[2]     (*c[in]* ∨ ¬*x* ∨ *y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | *M*[3]     (*c[in]* ∨ ¬*x* ∨ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | *M*[4]     (¬*c[in]* ∨ *x* ∨ *y*) | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | *M*[5]     (¬*c[in]* ∨ *x* ∨ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | *M*[6]     (¬*c[in]* ∨ ¬*x* ∨ *y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | *M*[7]     (¬*c[in]* ∨ ¬*x* ∨ ¬*y*) | `0` |'
  prefs: []
  type: TYPE_TB
- en: The ¬*C[out]*(*c[in]*, *x*, *y*) column shows which maxterms in our equation
    cause it to evaluate to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this notation to write a Boolean equation as a canonical product and
    using the ∏ symbol to denote multiplication, we can restate the function for the
    complement of carry as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg93_Image_73.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Table 4-7](ch04.xhtml#ch4tab7), you’ll see that these are the conditions
    that cause the complement of carry to be `0` and hence the carry to be `1`. This
    shows that using either minterms or maxterms is equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '***Comparison of Canonical Boolean Forms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 4-8](ch04.xhtml#ch4tab8) shows all the minterms and maxterms for a three-variable
    problem. Comparing the corresponding minterms and maxterms reveals the duality
    of minterms and maxterms: one can be formed from the other using De Morgan’s law
    by complementing each variable and interchanging OR and AND.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-8:** The Canonical Terms for a Three-Variable Problem'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Minterm = 1** | ***x*** | ***y*** | ***z*** | **Maxterm = 0** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[0]     ¬*x* ∧ ¬*y* ∧ ¬*z* | `0` | `0` | `0` | *M*[0]     *x* ∨ *y* ∨
    *z* |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[1]     ¬*x* ∧ ¬*y* ∧ *z* | `0` | `0` | `1` | *M*[1]     *x* ∨ *y* ∨ ¬*z*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[2]     ¬*x* ∧ *y* ∧ ¬*z* | `0` | `1` | `0` | *M*[2]     *x* ∨ ¬*y* ∨*z*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[3]     ¬*x* ∧ *y* ∧ *z* | `0` | `1` | `1` | *M*[3]     *x* ∨ ¬*y* ∨ ¬*z*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *m[4]*     *x* ∧ ¬*y* ∧ ¬*z* | `1` | `0` | `0` | *M*[4]     ¬*x* ∨ *y* ∨
    *z* |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[5]     *x* ∧ ¬*y* ∧ *z* | `1` | `0` | `1` | *M*[5]     ¬*x* ∨ *y* ∨ ¬*z*
    |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[6]     *x* ∧ *y* ∧ ¬*z* | `1` | `1` | `0` | *M*[6]     ¬*x* ∨ ¬*y* ∨
    *z* |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[7]     *x* ∧ *y* ∧ *z* | `1` | `1` | `1` | *M*[7]     ¬*x* ∨ ¬*y* ∨ ¬*z*
    |'
  prefs: []
  type: TYPE_TB
- en: The Venn diagrams in [Figure 4-4](ch04.xhtml#ch4fig4) provide a pictorial view
    of the reason we use the terms minterm and maxterm.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg94_Image_74.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: The relationships between three variables for a minterm and a
    maxterm*'
  prefs: []
  type: TYPE_NORMAL
- en: The canonical forms give us a complete and unique statement of the function
    because they take all possible combinations of the variables’ values into account.
    However, there often are simpler solutions to the problem. The remainder of this
    chapter will be devoted to methods of simplifying Boolean functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Expression Minimization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When implementing a Boolean function in hardware, each ∧ operator specifies
    an AND gate, each ∨ operator specifies an OR gate, and each ¬ operator specifies
    a NOT gate. In general, the complexity of the hardware is related to the number
    of AND and OR gates used (NOT gates are simple and tend not to contribute significantly
    to the complexity). Simpler hardware uses fewer components, thus saving cost and
    space, and uses less power. These savings are especially important with handheld
    and wearable devices. In this section, you’ll learn how you can manipulate Boolean
    expressions to reduce the number of AND and OR gates, thus simplifying their hardware
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Minimal Expressions***'
  prefs: []
  type: TYPE_NORMAL
- en: When simplifying a function, start with one of the canonical forms to ensure
    you have taken all possible cases into account. To translate a problem into a
    canonical form, create a truth table that lists all possible combinations of the
    variables in the problem. From the truth table, it will be easy to list the minterms
    or maxterms that define the function.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with a canonical statement, the next step is to look for a functionally
    equivalent *minimal expression*, which is an expression that does the same thing
    as the canonical one using a minimum number of literals and Boolean operators.
    To minimize an expression, we apply the rules of Boolean algebra to reduce the
    number of terms and the number of literals in each term, without changing the
    logical meaning of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of minimal expressions, depending on whether you use minterms
    or maxterms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal sum of products**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting with a minterms description of the problem, the minimal expression,
    known as a *minimal sum of products*, is a sum of products expression where all
    other mathematically equivalent sum of products expressions have at least as many
    product terms and those with the same number of product terms have at least as
    many literals. As an example of a minimal sum of products, consider these equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_75.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*S* is in canonical form as each of the product terms explicitly shows the
    contribution of all three variables. The other three functions are simplifications
    of *S*. Although all three have the same number of product terms, *S3* is a minimal
    sum of products for *S* because it has fewer literals in its product terms than
    *S1* and *S2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal product of sums**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting with a maxterms description of the problem, the minimal expression,
    known as a *minimal product of sums*, is a product of sums expression where all
    other mathematically equivalent product of sums expressions have at least as many
    sum terms and those with the same number of sum terms have at least as many literals.
    For an example of a minimal product of sums, consider these equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg95_Image_76.jpg) *P* is in canonical form, and the other
    three functions are simplifications of *P*. Although all three have the same number
    of sum terms as *P*, *P3* is a minimal product of sums for *P* because it has
    fewer literals in its product terms than *P1* and *P2*.'
  prefs: []
  type: TYPE_NORMAL
- en: A problem may have more than one minimal solution. Good hardware design typically
    involves finding several minimal solutions and assessing each one within the context
    of the available hardware. This means more than using fewer gates; for example,
    as you’ll learn when we discuss hardware implementation, adding judiciously placed
    NOT gates can reduce hardware complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two sections, you’ll learn two ways to find minimal expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Minimization Using Algebraic Manipulations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To illustrate the importance of reducing the complexity of a Boolean function,
    let’s return to the function for carry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_77.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The expression on the right-hand side of the equation is a sum of minterms.
    [Figure 4-5](ch04.xhtml#ch4fig5) shows the circuit to implement this function.
    It requires four AND gates and one OR gate. The small circles at the inputs to
    the AND gates indicate a NOT gate at that input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_78.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: A hardware implementation of a function to generate the value
    of carry when adding two numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to simplify the Boolean expression implemented in [Figure 4-5](ch04.xhtml#ch4fig5)
    to see whether we can reduce the hardware requirements. Note that there may not
    be a single path to a solution, and there may be more than one correct solution.
    I will present only one way here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll do something that might look strange. We’ll use the idempotency
    rule to duplicate the fourth term twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg96_Image_79.jpg) Next, we’ll rearrange the product terms
    a bit to OR each of the three original terms with (*c[in]* ∧ *x* ∧ *y*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_80.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can use the rule for distribution of AND over OR to factor out terms
    that OR to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-6](ch04.xhtml#ch4fig6) shows the circuit for this function. Not only
    have we eliminated an AND gate, but each of the AND gates and the OR gate has
    one fewer input.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg97_Image_82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: A simplified hardware implementation to generate the value of
    carry when adding two numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing the circuits in [Figures 4-5](ch04.xhtml#ch4fig5) and [4-6](ch04.xhtml#ch4fig6),
    we can see that Boolean algebra has helped us simplify the hardware implementation.
    This simplification results from stating the conditions that result in a carry
    of `1` in plain language. The original, canonical form of the equation stated
    that a carry, *C[out]*(*c[in]*, *x*, *y*), will be `1` in any of these four cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If *c[in]* = `0`, *x* = `1`, and *y* = `1`
  prefs: []
  type: TYPE_NORMAL
- en: If *c[in]* = `1`, *x* = `0`, and *y* = `1`
  prefs: []
  type: TYPE_NORMAL
- en: If *c[in]* = `1`, *x* = `1`, and *y* = `0`
  prefs: []
  type: TYPE_NORMAL
- en: If *c[in]* = `1`, *x* = `1`, and *y* = `1`
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimization can be stated much more simply: carry is `1` if at least two
    of *c[in]*, *x*, and *y* are `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*These examples of specifying a logic circuit for carry from addition, and
    the algorithm for subtraction in [Chapter 3](ch03.xhtml), illustrate one of the
    more common sources of programming errors. Specifying an activity that seems very
    simple to us humans in simple logical steps that a computer can execute can be
    a very tedious, error-prone process.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We arrived at the solution in [Figure 4-6](ch04.xhtml#ch4fig6) by starting
    with the sum of minterms; in other words, we were working with the values of *c[in]*,
    *x*, and *y* that generate a `1` for carry. As you saw in the section “Canonical
    Product or Product of Maxterms” on [page 64](ch04.xhtml#ch04lev2sec4), since carry
    must be either `1` or `0`, it’s equally as valid to start with the values of *c[in]*,
    *x*, and *y* that generate a `0` for the complement of carry and to write the
    equation as a product of maxterms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_83.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To simplify this equation, we’ll take the same approach we took with the sum
    of minterms and start by duplicating the last term twice to give:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_84.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding some parentheses helps to clarify the simplification process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_85.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we’ll use the distribution of OR over AND. Because this is tricky, I’ll
    go over the steps to simplify the first grouping of product terms in this equation;
    the steps for the other two groupings are similar to this one. Distribution of
    OR over AND has this generic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_86.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sum terms in our first grouping share a (¬*x* ∨ ¬*y*), so we’ll make the
    following substitutions into the generic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_87.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Making the substitutions and using the complement rule for AND, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_88.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And applying these same manipulations to the other two groupings, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_89.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows the circuit implementation of this function.
    This circuit produces the complement of carry. We would need to complement the
    output, ¬*C[out]*(*c[in]*, *x*, *y*), to get the value of carry.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg99_Image_90.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: A simplified hardware implementation to generate the complement
    of carry when adding two numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare [Figures 4-7](ch04.xhtml#ch4fig7) and [4-6](ch04.xhtml#ch4fig6),
    you can graphically see De Morgan’s law, where the ORs have become ANDs with complemented
    values as inputs. The circuit in [Figure 4-6](ch04.xhtml#ch4fig6) might look simpler
    to you because the circuit in [Figure 4-7](ch04.xhtml#ch4fig7) requires NOT gates
    at the six inputs to the OR gates. But as you will learn in the next chapter,
    this may not be the case because of the inherent electronic properties of the
    devices used to construct logic gates.
  prefs: []
  type: TYPE_NORMAL
- en: The important point to understand here is that there is more than one way to
    solve the problem. One of the jobs of the hardware engineer is to decide which
    solution is best, based on elements such as cost, component availability, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '***Minimization Using Karnaugh Maps***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The algebraic manipulations used to minimize Boolean functions may not always
    be obvious. You may find it easier to work with a graphic representation of the
    logical statements.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used graphic tool for working with Boolean functions is the *Karnaugh
    map*, also called a *K-map*. The Karnaugh map, invented in 1953 by Maurice Karnaugh,
    a telecommunications engineer at Bell Labs, gives a way to visually find the same
    simplifications you can find algebraically. It can be used either with a sum of
    products, using minterms, or with a product of sums, using maxterms. Here, I illustrate
    how they work, starting with minterms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplifying Sums of Products Using Karnaugh Maps**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Karnaugh map is a rectangular grid with a cell for each minterm. There are
    2*^n* cells for *n* variables. [Figure 4-8](ch04.xhtml#ch4fig8) is a Karnaugh
    map showing all four possible minterms for two variables, *x* and *y*. The vertical
    axis is used to plot *x* and the horizontal axis is used for *y*. The value of
    *x* for each row is shown by the number (`0` or `1`) immediately to the left of
    the row, and the value of *y* for each column appears at the top of the column.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: The mapping of two-variable minterms on a Karnaugh map*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use a Karnaugh map, let’s look at an arbitrary function
    of two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_92.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Start by placing a `1` in each cell corresponding to a minterm that appears
    in the equation, as shown in [Figure 4-9](ch04.xhtml#ch4fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_93.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: A Karnaugh map of the arbitrary function* F*(*x, y*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Placing a `1` in the cell corresponding to each minterm that evaluates to `1`
    shows graphically when the equation evaluates to `1`. The two cells on the right-hand
    side correspond to the minterms *m*[1] and *m*[3], (¬*x* ∧ *y*) and (*x* ∧ *y*).
    Since these terms are OR-ed together, *F*(*x*, *y*) evaluates to `1` if either
    of these minterms evaluates to `1`. Using the distributive and complement rules,
    we get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_94.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows algebraically that *F*(*x*, *y*) evaluates to `1` whenever *y* is
    `1`, which you’ll see next by simplifying this Karnaugh map.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between the two minterms, (¬*x* ∧ *y*) and (*x* ∧ *y*),
    is the change from *x* to ¬*x*. Karnaugh maps are arranged such that only one
    variable changes between two cells that share an edge, a requirement called the
    *adjacency rule*.
  prefs: []
  type: TYPE_NORMAL
- en: To use a Karnaugh map to perform simplification, you group two adjacent cells
    in a sum of products Karnaugh map that have `1`s in them. Then you eliminate the
    variable that differs between them and coalesce the two product terms. Repeating
    this process allows you to simplify the equation. Each grouping eliminates a product
    term in the final sum of products. This can be extended to equations with more
    than two variables, but the number of cells that are grouped together must be
    a multiple of 2, and you can group only adjacent cells. The adjacency wraps around
    from side to side and from top to bottom. You’ll see an example in [Figure 4-18](ch04.xhtml#ch4fig18)
    on [page 79](ch04.xhtml#page_79).
  prefs: []
  type: TYPE_NORMAL
- en: To see how all this works, consider the grouping in the Karnaugh map in [Figure
    4-10](ch04.xhtml#ch4fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_95.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Two of the minterms in* F*(*x, y*) grouped*'
  prefs: []
  type: TYPE_NORMAL
- en: This grouping is a graphical representation of the algebraic manipulation we
    did earlier, where *F*(*x*, *y*) evaluates to `1` whenever *y* = `1`, regardless
    of the value of *x*. Thus, the grouping coalesces two minterms into one product
    term by eliminating *x*.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the last grouping, we know our final simplified function will have a *y*
    term. Let’s do another grouping to find the next term. First, we’ll simplify the
    equation algebraically. Returning to the original equation for *F*(*x*, *y*),
    we can use idempotency to duplicate one of the minterms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_96.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we’ll do some algebraic manipulation on the first product term and the
    one we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of using algebraic manipulations, we can do this directly on our Karnaugh
    map, as shown in [Figure 4-11](ch04.xhtml#ch4fig11). This map shows that separate
    groups can include the same cell (minterm).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_98.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: A Karnaugh map grouping showing that (*x ∧ ¬y*)* ∨ (¬x ∧ y*)*
    ∨ *(*x ∧ y*) =* x ∨ y'
  prefs: []
  type: TYPE_NORMAL
- en: 'The group in the bottom row represents the product term *x* and the one in
    the right-hand column represents *y*, giving us the following minimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_99.jpg) Note that the cell that is included
    in both groupings, (*x* ∧ *y*), is the term that we duplicated using the idempotent
    rule in our algebraic solution previously. You can think of including a cell in
    more than one group as adding a duplicate copy of the cell, as we did in our algebraic
    manipulation earlier, and then coalescing it with the other cell(s) in the group,
    thus removing it.'
  prefs: []
  type: TYPE_NORMAL
- en: The adjacency rule is automatically satisfied when there are only two variables
    in the function. When we add another variable, we need to think about how to order
    the cells of a Karnaugh map such that we can use the adjacency rule to simplify
    Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordering Cells in a Karnaugh Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One of the problems with both the binary and binary coded decimal (BCD) codes
    is that the difference between two adjacent values often involves more than one
    bit being changed. In 1943, Frank Gray introduced a code, the *Gray code*, in
    which adjacent values differ by only one bit. Although encoding values in the
    Gray code complicates arithmetic operations on the values, it simplifies showing
    when the values are adjacent to one another, which shows us how to order the cells
    in a Karnaugh map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing the Gray code is quite easy. Start with one bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: 'To add a bit, first write the mirror image of the existing pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gray code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` |'
  prefs: []
  type: TYPE_TB
- en: Then, add a `0` to the beginning of each of the original bit patterns and add
    a `1` to the beginning of each of the mirror-image set to give the Gray code for
    two bits, as shown in [Table 4-9](ch04.xhtml#ch4tab9).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-9:** The Gray Code for Two Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `00` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `01` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `11` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `10` |'
  prefs: []
  type: TYPE_TB
- en: This is the reason the Gray code is sometimes called *reflected binary code
    (RBC)*. [Table 4-10](ch04.xhtml#ch4tab10) shows the Gray code for four bits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-10:** The Gray Code for Four Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** | **Binary** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   0 | `0000` | `0000` |'
  prefs: []
  type: TYPE_TB
- en: '|   1 | `0001` | `0001` |'
  prefs: []
  type: TYPE_TB
- en: '|   2 | `0011` | `0010` |'
  prefs: []
  type: TYPE_TB
- en: '|   3 | `0010` | `0011` |'
  prefs: []
  type: TYPE_TB
- en: '|   4 | `0110` | `0100` |'
  prefs: []
  type: TYPE_TB
- en: '|   5 | `0111` | `0101` |'
  prefs: []
  type: TYPE_TB
- en: '|   6 | `0101` | `0110` |'
  prefs: []
  type: TYPE_TB
- en: '|   7 | `0100` | `0111` |'
  prefs: []
  type: TYPE_TB
- en: '|   8 | `1100` | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '|   9 | `1101` | `1001` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `1111` | `1010` |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | `1110` | `1011` |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | `1010` | `1100` |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | `1011` | `1101` |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | `1001` | `1110` |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | `1000` | `1111` |'
  prefs: []
  type: TYPE_TB
- en: Let’s compare the binary codes with the Gray codes for the decimal values 7
    and 8 in [Table 4-10](ch04.xhtml#ch4tab10). The binary codes for 7 and 8 are `0111`
    and `1000`, respectively; all four bits change when stepping only 1 in decimal
    value. But the Gray codes for 7 and 8 are `0100` and `1100`, respectively; only
    one bit changes, thus satisfying the adjacency rule for a Karnaugh map.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the pattern of changing only one bit between adjacent values also
    holds when the bit pattern wraps around. That is, when going from the highest
    value (15 for four bits) to the lowest (0), only one bit is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Karnaugh Map for Three Variables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To see how the adjacency property is important, let’s consider a more complicated
    function. We’ll use a Karnaugh map to simplify our function for carry, which has
    three variables. Adding another variable means we need to double the number of
    cells to hold the minterms. To keep the map two-dimensional, we add the new variable
    to an existing variable on one side of the map. We need a total of eight cells
    (2³), so we’ll draw it four cells wide and two cells high. We’ll add *z* to the
    y-axis and draw our Karnaugh map with *y* and *z* on the horizontal axis and *x*
    on the vertical axis, as shown in [Figure 4-12](ch04.xhtml#ch4fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: The mapping of three-variable minterms on a Karnaugh map*'
  prefs: []
  type: TYPE_NORMAL
- en: The order of the bit patterns along the top of the three-variable Karnaugh map
    is `00`, `01`, `11`, `10`, as opposed to `00`, `01`, `10`, `11`, which is the
    Gray code order in [Table 4-9](ch04.xhtml#ch4tab9). The adjacency rule also holds
    when wrapping around the edges of the Karnaugh map—that is, going from *m*[2]
    to *m*[0] or from *m*[6] to *m*[4]—which means that groups can wrap around the
    edges of the map. (Other axis labeling schemes will also work, as you’ll see at
    the end of this section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw earlier in this chapter that carry can be expressed as the sum of four
    minterms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-13](ch04.xhtml#ch4fig13) shows these four minterms on a Karnaugh
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: A Karnaugh map of the function for carry*'
  prefs: []
  type: TYPE_NORMAL
- en: We look for adjacent cells that can be grouped together to eliminate one variable
    from the product term. As noted, the groups can overlap, giving the three groups
    shown in [Figure 4-14](ch04.xhtml#ch4fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: A minimum sum of products of the function for carry =* 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the three groups in the Karnaugh map in [Figure 4-14](ch04.xhtml#ch4fig14),
    we end up with the same equation we got through algebraic manipulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_104.jpg) ##### **Simplifying Products of Sums
    Using Karnaugh Maps**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s equally valid to work with a function that shows when the complement of
    carry is `0`. We did that using maxterms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) shows the arrangement of maxterms on a three-variable
    Karnaugh map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: The mapping of three-variable maxterms on a Karnaugh map*'
  prefs: []
  type: TYPE_NORMAL
- en: When working with a maxterm statement of the solution, you mark the cells that
    evaluate to `0`. The minimization process is the same as when working with minterms,
    except that you group the cells with `0`s in them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows a minimization of ¬*C[out]*(*c[in]*,
    *x*, *y*), the complement of carry.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: A minimum product of sums of the function for NOT carry =* 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Karnaugh map in [Figure 4-16](ch04.xhtml#ch4fig16) leads to the same product
    of sums we got algebraically for the complement of carry = `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparing [Figures 4-14](ch04.xhtml#ch4fig14) and [4-16](ch04.xhtml#ch4fig16)
    gives a graphic view of De Morgan’s law. When making this comparison, keep in
    mind that [Figure 4-14](ch04.xhtml#ch4fig14) shows the product terms that get
    added and [Figure 4-16](ch04.xhtml#ch4fig16) shows the sum terms that get multiplied,
    and the result is complemented. Thus, we exchange `0` and `1` and exchange AND
    and OR to go from one Karnaugh map to the other.
  prefs: []
  type: TYPE_NORMAL
- en: To further emphasize the duality of minterms and maxterms, compare [Figures
    4-17(a)](ch04.xhtml#ch4fig17) and [(b)](ch04.xhtml#ch4fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: A comparison of (a) one minterm and (b) one maxterm*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-17](ch04.xhtml#ch4fig17)(a) shows the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although it’s not necessary and usually not done, we have placed a `0` in each
    of the cells representing minterms not included in this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in [Figure 4-17](ch04.xhtml#ch4fig17)(b), we have placed a `1` in
    each of the cells representing the maxterms that are not included in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This comparison shows graphically how a minterm specifies the minimum number
    of `1`s in a Karnaugh map and a maxterm specifies the maximum number of `1`s.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Larger Groupings on a Karnaugh Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thus far, we have grouped only two cells together on our Karnaugh maps. Here,
    I’ll show you an example of larger groups. Consider a function that outputs `1`
    when a 3-bit number is even. [Table 4-11](ch04.xhtml#ch4tab11) shows the truth
    table. It uses `1` to indicate that the number is even and uses `0` to indicate
    odd.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-11:** The Even Values of a 3-Bit Number'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Minterm** | ***x*** | ***y*** | ***z*** | **Number** | ***Even***(***x,
    y, z***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[0] | `0` | `0` | `0` | 0 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[1] | `0` | `0` | `1` | 1 | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[2] | `0` | `1` | `0` | 2 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[3] | `0` | `1` | `1` | 3 | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[4] | `1` | `0` | `0` | 4 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[5] | `1` | `0` | `1` | 5 | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[6] | `1` | `1` | `0` | 6 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| *m*[7] | `1` | `1` | `1` | 7 | `0` |'
  prefs: []
  type: TYPE_TB
- en: 'The canonical sum of products for this function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-18](ch04.xhtml#ch4fig18) shows these minterms on a Karnaugh map with
    the four terms grouped together. We can group all four together because they all
    have adjacent edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: A Karnaugh map showing even values of a 3-bit number*'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Karnaugh map in [Figure 4-18](ch04.xhtml#ch4fig18), we can write the
    equation for when a 3-bit number is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Karnaugh map shows that it does not matter what the values of *x* and *y*
    are, only that *z* = `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding More Variables to a Karnaugh Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each time you add another variable to a Karnaugh map, you will need to double
    the number of cells. The only requirement for the Karnaugh map to work is that
    you arrange the minterms (or maxterms) according to the adjacency rule. [Figure
    4-19](ch04.xhtml#ch4fig19) shows a four-variable Karnaugh map for minterms. The
    *y* and *z* variables are on the horizontal axis, and *w* and *x* are on the vertical
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: The mapping of four-variable minterms on a Karnaugh map*'
  prefs: []
  type: TYPE_NORMAL
- en: So far we have assumed that every minterm (or maxterm) is accounted for in our
    functions. But design does not take place in a vacuum. We might have knowledge
    about other components of the overall design telling us that some combinations
    of variable values can never occur. Next, I’ll show you how to take this knowledge
    into account in your function simplification process. The Karnaugh map provides
    an especially clear way to visualize the situation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using “Don’t Care” Cells**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, you have information about the values that the variables can have.
    If you know which combinations of values will never occur, then the minterms (or
    maxterms) that represent those combinations are irrelevant. For example, you may
    want a function that indicates whether one of two possible events has occurred
    or not, but you know that the two events cannot occur simultaneously. Let’s name
    the events *x* and *y* and let `0` indicate that the event has not occurred and
    `1` indicate that it has. [Table 4-12](ch04.xhtml#ch4tab12) shows the truth table
    for our function, *F*(*x*, *y*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-12:** A Truth Table for *x* or *y* Occurring, but Not Both'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***F***(***x, y***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | × |'
  prefs: []
  type: TYPE_TB
- en: We can show that both events cannot occur simultaneously by placing an *×* in
    that row. We can draw a Karnaugh map with an *×* for the minterm that can’t exist
    in the system, as shown in [Figure 4-20](ch04.xhtml#ch4fig20). The *×* represents
    a *don’t care* cell; grouping this cell with other cells doesn’t affect the evaluation
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: A Karnaugh map for* F*(*x, y*), showing a “don’t care” cell*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the cell that represents the minterm (*x* ∧ *y*) is a “don’t care” cell,
    we can include it, or not, in our minimization groupings, leading to the two groupings
    shown. The Karnaugh map in [Figure 4-20](ch04.xhtml#ch4fig20) leads us to the
    solution
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is a simple OR gate. You probably guessed this solution without having
    to use a Karnaugh map. You’ll see a more interesting use of “don’t care” cells
    when you learn about the design of two digital logic circuits at the end of [Chapter
    7](ch07.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Karnaugh maps can be used to minimize only two levels of logic: groups of AND
    gates feeding an OR gate, or groups of OR gates feeding an AND gate. As you’ll
    see in the next several chapters, most logic designs involve more than two levels.
    Karnaugh maps can provide some useful guidelines, but you need to think carefully
    about the overall design. You will see an example of using Karnaugh maps to design
    an adder circuit with three levels of logic in [Chapter 6](ch06.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Basic Boolean Operators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, we can combine basic Boolean operators
    to implement more complex Boolean operators. Now that you know how to work with
    Boolean functions, we’ll design one of the more common operators, the *exclusive
    or*, often called *XOR*, using the three basic operators, AND, OR, and NOT. It’s
    so commonly used that it has its own circuit symbol. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XOR**'
  prefs: []
  type: TYPE_NORMAL
- en: XOR is a binary operator. The result is `1` if one, and only one, of the two
    operands is `1`; otherwise, the result is `0`. I’ll use ⊻ to designate the XOR
    operation. It’s also common to use the ⊕ symbol. [Figure 4-21](ch04.xhtml#ch4fig21)
    shows XOR gate operation with inputs *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: An XOR gate acting on two variables,* x *and* y'
  prefs: []
  type: TYPE_NORMAL
- en: 'The minterm implementation of this operation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The XOR operator can be implemented with two AND gates, two NOT gates, and one
    OR gate, as shown in [Figure 4-22](ch04.xhtml#ch4fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-22: An XOR gate made from AND, OR, and NOT gates*'
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, design many more Boolean operators, but we’ll move on in
    the next few chapters to learn how these operators can be implemented in hardware
    using simple on/off switches. As you’ll discover, the idealized minimal solutions
    you’ve learned about in this chapter may not always be the best solutions, due
    to factors such as the inherent electrical characteristics of the switches, multiple
    levels of logic, availability of hardware components, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3     Design a function that will detect all the 4-bit integers that are even.
  prefs: []
  type: TYPE_NORMAL
- en: '4.4     Find a minimal sum of products expression for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '4.5     Find a minimal product of sums expression for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '4.6     The arrangement of the variables for a Karnaugh map is arbitrary, but
    the minterms (or maxterms) need to be consistent with the labeling. Show where
    each minterm is located with this Karnaugh map axis labeling using the notation
    of [Figure 4-12](ch04.xhtml#ch4fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '4.7     The arrangement of the variables for a Karnaugh map is arbitrary, but
    the minterms (or maxterms) need to be consistent with the labeling. Show where
    each minterm is located with this Karnaugh map axis labeling using the notation
    of [Figure 4-12](ch04.xhtml#ch4fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_124.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 4.8     Create a Karnaugh map for five variables. You’ll probably need to review
    the Gray code in [Table 4-10](ch04.xhtml#ch4tab10) and increase it to five bits.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9     Design a logic function that detects the single-digit prime numbers.
    Assume that the numbers are coded in 4-bit BCD (see [Table 2-7](ch02.xhtml#ch2tab7)).
    The function is `1` for each prime number.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Boolean operators**   The three basic Boolean operators are AND, OR, and
    NOT.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rules of Boolean algebra**   Boolean algebra provides a mathematical way
    to work with the rules of logic. AND works like multiplication, and OR is similar
    to addition in elementary algebra.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplifying Boolean algebra expressions**   Boolean functions specify the
    functionality of a computer. Simplifying these functions leads to a simpler hardware
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Karnaugh maps**   These provide a graphical way to simplify Boolean expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gray code**   This shows how to order the cells in a Karnaugh map.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining basic Boolean operators**   XOR can be created from AND, OR, and
    NOT operators.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter starts with an introduction to basic electronics that will
    provide a basis for understanding how transistors can be used to implement switches.
    From there, we’ll look at how transistor switches are used to implement logic
    gates.
  prefs: []
  type: TYPE_NORMAL
