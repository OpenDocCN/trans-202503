- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: BOOLEAN ALGEBRA**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数**
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: '*Boolean algebra* was developed in the 19th century by an English mathematician,
    George Boole, who was working on ways to use mathematical rigor to solve logic
    problems. He formalized a mathematical system for manipulating logical values
    in which the only possible values for the variables are *true* and *false*, usually
    designated `1` and `0`, respectively.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔代数*由19世纪的英国数学家乔治·布尔发展，他致力于用数学严密性解决逻辑问题。他为操作逻辑值建立了一个数学系统，其中变量的唯一可能值为*真*和*假*，通常分别表示为`1`和`0`。'
- en: The basic operations in Boolean algebra are *conjunction* (AND), *disjunction*
    (OR), and *negation* (NOT). This distinguishes it from elementary algebra, which
    includes the infinite set of real numbers and uses the arithmetic operations addition,
    subtraction, multiplication, and division. (Exponentiation is a simplified notation
    for repeated multiplication.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数中的基本运算包括*合取*（AND）、*析取*（OR）和*否定*（NOT）。这将其与初等代数区分开来，后者包括实数的无限集合，并使用加法、减法、乘法和除法等算术运算。（指数运算是重复乘法的简化表示法。）
- en: While mathematicians and logicians were expanding the field of Boolean algebra
    in increasingly complex and abstract ways, engineers were learning to harness
    electrical flows using switches in circuits to perform logic operations. The two
    fields developed in parallel until the mid-1930s, when a graduate student named
    Claude Shannon proved that electrical switches could be used to implement the
    full range of Boolean algebraic expressions. (When used to describe switching
    circuits, Boolean algebra is sometimes called *switching algebra*.) With Shannon’s
    discovery, a world of possibilities was opened and Boolean algebra became the
    mathematical foundation of the computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当数学家和逻辑学家在以越来越复杂和抽象的方式扩展布尔代数领域时，工程师们则在学习如何通过电路中的开关来利用电流流动执行逻辑运算。这两个领域并行发展，直到1930年代中期，一名研究生克劳德·香农证明了电气开关可以用来实现所有布尔代数表达式的功能。（在描述开关电路时，布尔代数有时被称为*开关代数*。）香农的发现打开了无限的可能性，布尔代数也因此成为计算机的数学基础。
- en: 'In this chapter, I’ll start with descriptions of the basic Boolean operators.
    Then, you’ll learn about their logical rules, which form the basis of Boolean
    algebra. Next, I’ll explain ways to combine Boolean variables and operators into
    algebraic expressions to form Boolean logic functions. Finally, I’ll discuss techniques
    for simplifying Boolean functions. In subsequent chapters, you’ll learn how electronic
    on/off switches can be used to implement logic functions that can be connected
    together in logic circuits to perform the primary functions of a computer: arithmetic,
    logic operations, and memory storage.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从基本布尔运算符的描述开始。接下来，你将学习它们的逻辑规则，这些规则构成了布尔代数的基础。然后，我将解释如何将布尔变量和运算符组合成代数表达式，以形成布尔逻辑函数。最后，我将讨论简化布尔函数的技术。在接下来的章节中，你将学习如何利用电子开关实现逻辑功能，并将这些功能连接到逻辑电路中，以执行计算机的基本功能：算术、逻辑运算和存储。
- en: '**Basic Boolean Operators**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本布尔运算符**'
- en: A Boolean operator acts on a value or pair of values called the *operand(s)*.
    There are several symbols used to denote each Boolean operator, which I’ll include
    in the description of each of the operators. In this book, I’ll present the symbols
    used by logicians.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符作用于称为*操作数*的值或值对。有几个符号用于表示每个布尔运算符，我将在每个运算符的描述中提到。在本书中，我将介绍逻辑学家使用的符号。
- en: I’ll use truth tables to show the results of each operation. A *truth table*
    shows the results for all possible combinations of the operands. For example,
    consider the addition of two bits, *x* and *y*. There are four possible combinations
    of the values, one of which is addition, which will give a sum and a possible
    carry. [Table 4-1](ch04.xhtml#ch4tab1) shows how to express this in a truth table.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用真值表来展示每个运算的结果。*真值表*显示所有可能的操作数组合的结果。例如，考虑两个比特*x*和*y*的加法。存在四种可能的值组合，其中一种是加法，结果会有一个和以及一个可能的进位。[表
    4-1](ch04.xhtml#ch4tab1)展示了如何在真值表中表示这一点。
- en: '**Table 4-1:** A Truth Table for Addition of Two Bits'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 两比特加法的真值表'
- en: '| ***x*** | ***y*** | ***Carry*** | ***Sum*** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| ***x*** | ***y*** | ***进位*** | ***和*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 | 1 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 0 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 |'
- en: I’ll also provide the electronic circuit representations for *gates*, which
    are the electronic devices that implement the Boolean operators. You’ll learn
    more about these devices in [Chapters 5](ch05.xhtml) through [8](ch08.xhtml),
    where you’ll also see that the real-world behavior of the physical devices varies
    slightly from the ideal mathematical behavior shown in the truth tables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将提供 *门* 的电子电路表示，这些门是实现布尔运算符的电子设备。你将在 [第 5 章](ch05.xhtml) 到 [第 8 章](ch08.xhtml)
    中学习更多关于这些设备的内容，在这些章节中，你还将看到物理设备的实际行为与真值表中显示的理想数学行为略有不同。
- en: 'As with elementary algebra, you can combine these basic operators to define
    secondary operators. You’ll see an example of this when I define the XOR operator
    near the end of this chapter. For now, let’s take a look at the basic operators:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与初等代数一样，你可以将这些基本运算符结合起来定义二次运算符。你将在本章末尾定义 XOR 运算符时看到一个例子。现在，让我们先来看看这些基本运算符：
- en: '**AND**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**与（AND）**'
- en: AND is a *binary operator*, meaning it acts on two operands. The result of AND
    is `1` if and only if *both* operands are `1`; otherwise, the result is `0`. In
    logic, this operation is known as *conjunction*. I’ll use ∧ to designate the AND
    operation. It’s also common to use the *·* symbol or simply AND.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与运算符是一个 *二元运算符*，意味着它作用于两个操作数。仅当 *两个* 操作数都为 `1` 时，AND 运算的结果才为 `1`；否则，结果为 `0`。在逻辑学中，这个操作被称为
    *合取*。我将用 ∧ 来表示 AND 操作。使用 *·* 符号或简单地使用 AND 也很常见。
- en: '[Figure 4-1](ch04.xhtml#ch4fig1) shows the circuit symbol for an AND gate and
    a truth table defining the output, with operands *x* and *y*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch04.xhtml#ch4fig1) 显示了一个与门的电路符号和定义输出的真值表，操作数为 *x* 和 *y*。'
- en: '![Image](../images/pg83_Image_51.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg83_Image_51.jpg)'
- en: '*Figure 4-1: An AND gate acting on two variables,* x *and* y'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：作用于两个变量的与门，* x *和* y'
- en: As you can see in the truth table, the AND operator has properties similar to
    multiplication in elementary algebra, which is why some use the *·* symbol to
    represent it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如真值表所示，与运算符具有类似于初等代数中乘法的性质，这就是为什么一些人用 *·* 符号来表示它。
- en: '**OR**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**或（OR）**'
- en: OR is also a binary operator. The result of OR is `1` if at least one of the
    operands is `1`; otherwise, the result is `0`. In logic, this operation is known
    as *disjunction*. I’ll use ∨ to designate the OR operation. It’s also common to
    use the + symbol or simply OR. [Figure 4-2](ch04.xhtml#ch4fig2) shows the circuit
    symbol for an OR gate and a truth table defining the output, with operands *x*
    and *y*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或运算符也是一个二元运算符。如果至少有一个操作数为 `1`，则 OR 运算的结果为 `1`；否则，结果为 `0`。在逻辑学中，这个操作被称为 *析取*。我将用
    ∨ 来表示 OR 操作。使用 + 符号或简单地使用 OR 也很常见。[图 4-2](ch04.xhtml#ch4fig2) 显示了一个或门的电路符号和定义输出的真值表，操作数为
    *x* 和 *y*。
- en: '![Image](../images/pg83_Image_52.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg83_Image_52.jpg)'
- en: '*Figure 4-2: An OR gate acting on two variables,* x *and* y'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：作用于两个变量的或门，* x *和* y'
- en: The truth table shows that the OR operator follows rules somewhat similar to
    addition in elementary algebra, which is why some use the + symbol to represent
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表显示，或运算符遵循类似于初等代数中加法的规则，这就是为什么一些人用 + 符号来表示它。
- en: '**NOT**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**非（NOT）**'
- en: NOT is a *unary operator*, which acts on only one operand. The result of NOT
    is `1` if the operand is `0` and `0` if the operand is `1`. Other names for the
    NOT operation are *complement* and *invert*. I’ll use ¬ to designate the NOT operation.
    It’s also common to use the `'` symbol, an overscore above the variable, or simply
    NOT. [Figure 4-3](ch04.xhtml#ch4fig3) shows the circuit symbol for a NOT gate
    and a truth table defining the output, with the operand *x*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 非运算符是一个 *一元运算符*，它只作用于一个操作数。当操作数为 `0` 时，NOT 运算的结果为 `1`；当操作数为 `1` 时，结果为 `0`。非操作的其他名称包括
    *补码* 和 *反转*。我将用 ¬ 来表示 NOT 操作。使用 `'` 符号、在变量上方的下划线或简单地使用 NOT 也很常见。[图 4-3](ch04.xhtml#ch4fig3)
    显示了一个非门的电路符号和定义输出的真值表，操作数为 *x*。
- en: '![Image](../images/pg83_Image_53.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg83_Image_53.jpg)'
- en: '*Figure 4-3: A NOT gate acting on one variable,* x'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：作用于一个变量的非门，* x'
- en: As you’ll see, NOT has some properties of the arithmetic negation used in elementary
    algebra, but there are some significant differences.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，非运算符具有类似于初等代数中算术取反的性质，但也有一些显著的不同之处。
- en: It’s no accident that AND is multiplicative and OR is additive. George Boole
    developed his algebra to apply mathematical rigor to logic and use addition and
    multiplication to manipulate logical statements. He developed the rules based
    on using AND for multiplication and OR for addition. In the next section, you’ll
    learn how to use these operators, together with NOT, to represent logical statements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AND是乘法性质，OR是加法性质，这并非偶然。乔治·布尔发展了他的代数，以将数学严谨性应用于逻辑，并使用加法和乘法来操作逻辑语句。他基于使用AND进行乘法、OR进行加法来制定这些规则。在下一节中，你将学习如何使用这些运算符与NOT一起表示逻辑语句。
- en: '**Boolean Expressions**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: Just as you can use elementary algebra operators to combine variables into expressions
    such as (*x* + *y*), you can use Boolean operators to combine variables into expressions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用初等代数运算符将变量组合成像（*x* + *y*）这样的表达式一样，你也可以使用布尔运算符将变量组合成布尔表达式。
- en: There is a significant difference, though. A Boolean expression is created from
    values (`0` and `1`) and literals. In Boolean algebra, a *literal* is a single
    instance of a variable or its complement that’s being used in an expression. In
    the expression
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个显著的区别。布尔表达式是由值（`0` 和 `1`）和文字构成的。在布尔代数中，*文字*是指在表达式中使用的单一变量实例或其补集。在表达式中
- en: '![Image](../images/pg84_Image_54.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg84_Image_54.jpg)'
- en: there are three variables (*x*, *y*, and *z*) and seven literals. In a Boolean
    expression, you have a variable in both its complemented form and its uncomplemented
    form, because each form is a separate literal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个变量（*x*、*y* 和 *z*）以及七个文字。在布尔表达式中，你会发现每个变量都有它的补集形式和非补集形式，因为每种形式都是一个独立的文字。
- en: We can combine literals using either the ∧ or the ∨ operator. Like in elementary
    algebra, Boolean algebra expressions are made up of *terms*—groups of literals
    that are acted upon by operators, such as (*x* ∨ *y*) or (*a* ∧ *b*)—and *operation
    precedence* (or *order of operations*) specifies how these operators are applied
    when evaluating an expression. [Table 4-2](ch04.xhtml#ch4tab2) lists the precedence
    rules for the Boolean operators. As with elementary algebra, expressions in parentheses
    are evaluated first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用∧或∨运算符来组合文字。像初等代数一样，布尔代数表达式由*项*组成——由运算符作用于文字的组，例如（*x* ∨ *y*）或（*a* ∧ *b*）——*运算优先级*（或*运算顺序*）指定在求值表达式时如何应用这些运算符。[表
    4-2](ch04.xhtml#ch4tab2)列出了布尔运算符的优先级规则。与初等代数一样，括号内的表达式优先计算。
- en: '**Table 4-2:** Precedence Rules for Boolean Algebra Operators'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 布尔代数运算符的优先级规则'
- en: '| **Operation** | **Notation** | **Precedence** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **运算** | **符号** | **优先级** |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT | ¬*x* | Highest |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| NOT | ¬*x* | 最高 |'
- en: '| AND | *x* ∧ *y* | Middle |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| AND | *x* ∧ *y* | 中级 |'
- en: '| OR | *x* ∨ *y* | Lowest |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| OR | *x* ∨ *y* | 最低 |'
- en: Now that you know how the three fundamental Boolean operators work, we’ll look
    at some of the rules they obey when used in algebraic expressions. As you’ll see
    later in the chapter, we can use the rules to simplify Boolean expressions, which
    will allow us to simplify the way we implement those expressions in the hardware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了三个基本布尔运算符的工作原理，接下来我们将研究它们在代数表达式中遵循的一些规则。正如你在本章后面将看到的那样，我们可以利用这些规则来简化布尔表达式，从而简化我们在硬件中实现这些表达式的方式。
- en: Knowing how to simplify Boolean expressions is an important tool for both those
    making hardware and those writing software. A computer is just a physical manifestation
    of Boolean logic. Even if your only interest is in programming, every programming
    statement you write is ultimately carried out by hardware that is completely described
    by the system of Boolean algebra. Our programming languages tend to hide much
    of this through abstraction, but they still use Boolean expressions to implement
    programming logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何简化布尔表达式对于硬件开发者和软件编程者来说都是一项重要工具。计算机仅仅是布尔逻辑的物理表现形式。即使你对编程的唯一兴趣是编写程序，你写下的每一条编程语句最终都是由完全符合布尔代数系统的硬件来执行的。我们的编程语言通过抽象化隐藏了其中的很多细节，但它们仍然使用布尔表达式来实现编程逻辑。
- en: '**Boolean Algebra Rules**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔代数规则**'
- en: When comparing AND and OR in Boolean algebra to multiplication and addition
    in elementary algebra, you’ll find that some of the rules of Boolean algebra are
    familiar but others are significantly different.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将布尔代数中的AND和OR与初等代数中的乘法和加法进行比较时，你会发现布尔代数的一些规则很熟悉，但也有一些显著不同。
- en: '***Rules That Are the Same as Elementary Algebra***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与初等代数相同的规则***'
- en: 'Let’s start with the rules that are the same; in the next section, we’ll look
    at the ones that differ. These rules are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从相同的规则开始；在下一部分，我们将讨论不同的规则。这些规则如下：
- en: '**AND and OR are associative**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**与运算和或运算是结合性的**'
- en: 'We say that an operator is *associative* if we can change the order of applying
    two or more occurrences of the operator in an expression without changing the
    value of the expression. Mathematically:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个运算符是*结合性的*，如果我们可以改变在表达式中应用两个或更多次运算符的顺序，而不会改变表达式的值。数学上表示为：
- en: '![Image](../images/pg85_Image_55.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg85_Image_55.jpg)'
- en: To prove the associative rule for AND and OR, let’s use exhaustive truth tables,
    as shown in [Tables 4-3](ch04.xhtml#ch4tab3) and [4-4](ch04.xhtml#ch4tab4). [Table
    4-3](ch04.xhtml#ch4tab3) lists all possible values of the variables *x*, *y*,
    and *z*, as well as the intermediate computations of the terms (*y* ∧ *z*) and
    (*x* ∧ *y*). In the last two columns, I compute the values of each expression
    on both sides of the previous equations, which shows that the two equalities hold.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明与运算和或运算的结合性规则，让我们使用穷举真值表，如[表 4-3](ch04.xhtml#ch4tab3)和[表 4-4](ch04.xhtml#ch4tab4)所示。[表
    4-3](ch04.xhtml#ch4tab3)列出了变量 *x*、*y* 和 *z* 的所有可能值，以及术语 (*y* ∧ *z*) 和 (*x* ∧ *y*)
    的中间计算结果。在最后两列中，我计算了等式两边每个表达式的值，证明了这两个等式是成立的。
- en: '**Table 4-3:** The Associativity of the AND Operation'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 与运算的结合性'
- en: '| ***x*** | ***y*** | ***z*** | (***y*** ∧ ***z***) | (***x*** ∧ ***y***) |
    ***x*** ∧ (***y*** ∧ ***z***) | (***x*** ∧ ***y***) ∧ ***z*** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| ***x*** | ***y*** | ***z*** | (***y*** ∧ ***z***) | (***x*** ∧ ***y***) |
    ***x*** ∧ (***y*** ∧ ***z***) | (***x*** ∧ ***y***) ∧ ***z*** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `1` | `0` | `0` | `1` | `0` | `0` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | `1` | `0` | `0` |'
- en: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
- en: '[Table 4-4](ch04.xhtml#ch4tab4) lists all possible values of the variables
    *x*, *y*, and *z*, as well as the intermediate computations of the terms (*y*
    ∨ *z*) and (*x* ∨ *y*). In the last two columns, I compute the values of each
    expression on both sides of the previous equations, which again shows that the
    two equalities hold.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-4](ch04.xhtml#ch4tab4)列出了变量 *x*、*y* 和 *z* 的所有可能值，以及术语 (*y* ∨ *z*) 和 (*x*
    ∨ *y*) 的中间计算结果。在最后两列中，我计算了等式两边每个表达式的值，进一步证明了这两个等式是成立的。'
- en: '**Table 4-4:** The Associativity of the OR Operation'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4：** 或运算的结合性'
- en: '| ***x*** | ***y*** | ***z*** | (***y*** ∨ ***z***) | (***x*** ∨ ***y***) |
    ***x*** ∨ (***y*** ∨ ***z***) | (***x*** ∨ ***y***) ∨ ***z*** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| ***x*** | ***y*** | ***z*** | (***y*** ∨ ***z***) | (***x*** ∨ ***y***) |
    ***x*** ∨ (***y*** ∨ ***z***) | (***x*** ∨ ***y***) ∨ ***z*** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `1` | `0` | `1` | `1` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` | `0` | `1` | `1` |'
- en: '| `0` | `1` | `0` | `1` | `1` | `1` | `1` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | `1` | `1` | `1` |'
- en: '| `0` | `1` | `1` | `1` | `1` | `1` | `1` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `0` | `0` | `1` | `1` | `1` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `1` | `1` | `1` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `1` | `1` | `1` |'
- en: '| `1` | `1` | `0` | `1` | `1` | `1` | `1` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` | `1` | `1` |'
- en: This strategy works for each of the rules shown in this section, but I’ll only
    go through the truth table for the associative rule here. You’ll get to do this
    for the other rules in “Your Turn” [exercise 4.1](ch04.xhtml#ch4exe1) on [page
    61](ch04.xhtml#ch4you1).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略适用于本节所示的每个规则，但我这里只会通过真值表来展示结合性规则。你将在“你的转机”部分的[练习 4.1](ch04.xhtml#ch4exe1)中，完成其他规则的真值表。
- en: '**AND and OR have identity values**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**与运算和或运算具有单位值**'
- en: 'An *identity value* is a value specific to an operation, such that using that
    operation on a quantity with the identity value yields the value of the original
    quantity. For AND and OR, the identity values are `1` and `0`, respectively:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*单位值*是特定于某个运算的值，使用该运算对一个具有单位值的量进行运算时，结果是原始量的值。对于与运算（AND）和或运算（OR），单位值分别是 `1`
    和 `0`：
- en: '![Image](../images/pg86_Image_56.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg86_Image_56.jpg)'
- en: '**AND and OR are commutative**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**与运算和或运算是交换性的**'
- en: 'We can say that an operator is *commutative* if we can reverse the order of
    its operands without changing the result of the operation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，如果可以反转操作数的顺序而不改变操作结果，则该运算符是*交换律*的：
- en: '![Image](../images/pg86_Image_57.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_57.jpg)'
- en: '**AND is distributive over OR**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**AND 对 OR 具有分配性**'
- en: 'The AND operator applied to quantities OR-ed together can be *distributed*
    to apply to each of the OR-ed quantities:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对经过 OR 运算的数量应用 AND 运算符时，可以将 AND 运算符*分配*到每一个 OR 运算的数量：
- en: '![Image](../images/pg86_Image_58.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_58.jpg)'
- en: Unlike in elementary algebra, the additive OR *is* distributive over the multiplicative
    AND. You’ll see this in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与初等代数不同，累加型的 OR 对乘法型的 AND 是分配的。你将在下一节看到这一点。
- en: '**AND has an annulment (also called annihilation) value**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**AND 具有废除值（也称为消亡值）**'
- en: 'An *annulment value* is a value such that operating on a quantity with the
    annulment value yields the annulment value. The annulment value for AND is `0`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*废除值*是指对一个数量进行该废除值操作后，结果仍然是废除值。AND 的废除值是 `0`：'
- en: '![Image](../images/pg86_Image_59.jpg) We’re used to 0 being the annulment value
    for multiplication in elementary algebra, but addition has no concept of annulment.
    You’ll learn about the annulment value for OR in the next section.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg86_Image_59.jpg) 我们习惯于在初等代数中将 0 作为乘法的废除值，但加法没有废除值的概念。你将在下一节了解
    OR 运算的废除值。'
- en: '**NOT shows involution**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOT 表示自反**'
- en: 'An operator shows *involution* if applying it to a quantity twice yields the
    original quantity:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运算符表现出*自反性*，如果对一个数量应用两次该运算符后，结果仍然是原始数量：
- en: '![Image](../images/pg87_Image_60.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg87_Image_60.jpg)'
- en: 'Involution is simply the application of a double complement: NOT(NOT true)
    = true. This is similar to double negation in elementary algebra.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自反性仅仅是双重补集的应用：NOT(NOT true) = true。这类似于初等代数中的双重否定。
- en: '***Rules That Differ from Elementary Algebra***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与初等代数不同的规则***'
- en: 'Although AND is multiplicative and OR is additive, there are significant differences
    between these logical operations and the arithmetic ones. The differences stem
    from the fact that Boolean algebra deals with logic expressions that evaluate
    to either true or false, while elementary algebra deals with the infinite set
    of real numbers. In this section, you’ll see expressions that might remind you
    of elementary algebra, but the Boolean algebra rules are different. Those rules
    are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 AND 是乘法型的，OR 是加法型的，但这些逻辑运算与算术运算之间存在显著差异。这些差异源于布尔代数处理的是评估为真或假的逻辑表达式，而初等代数处理的是无限多的实数集合。在这一节中，你将看到一些可能让你想起初等代数的表达式，但布尔代数的规则不同。那些规则是：
- en: '**OR is distributive over AND**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**OR 对 AND 具有分配性**'
- en: 'The OR operator applied to quantities AND-ed together can be distributed to
    apply to each of the AND-ed quantities:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过 AND 运算得到的数量，应用 OR 运算符时可以将 OR 运算符分配到每一个 AND 运算的数量：
- en: '![Image](../images/pg87_Image_61.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg87_Image_61.jpg)'
- en: Because addition is not distributive over multiplication in elementary algebra,
    you might overlook this way of manipulating Boolean expressions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为加法在初等代数中不对乘法具有分配性，你可能会忽视这种布尔表达式的操作方式。
- en: 'First, let’s look at elementary algebra. Using addition for OR and multiplication
    for AND in the previous equation, we have:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看初等代数。使用加法作为 OR，乘法作为 AND 的时候，在之前的方程中我们得到：
- en: '![Image](../images/pg87_Image_62.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg87_Image_62.jpg)'
- en: When we plug in the numbers *x* = 1, *y* = 2, and *z* = 3, the left-hand side
    gives
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们代入 *x* = 1，*y* = 2 和 *z* = 3 时，左边的表达式得到：
- en: 1 + (2 · 3) = 7
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + (2 · 3) = 7
- en: 'and the right-hand side gives:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，右边的表达式得到：
- en: (1 + 2) · (1 + 3) = 12
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (1 + 2) · (1 + 3) = 12
- en: Thus, addition is *not* distributive over multiplication in elementary algebra.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在初等代数中，加法对于乘法*不*具有分配性。
- en: The best way to show that OR is distributive over AND in Boolean algebra is
    to use a truth table, as shown in [Table 4-5](ch04.xhtml#ch4tab5).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 用真值表展示 OR 在布尔代数中对 AND 的分配性是最好的方法，如 [表 4-5](ch04.xhtml#ch4tab5) 所示。
- en: '**Table 4-5:** OR Distributes over AND'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-5：** OR 对 AND 的分配性'
- en: '| ***x*** | ***y*** | ***z*** | ***x*** ∨ (***y*** ∧ ***z***) | (***x*** ∨
    ***y***) ∧ (***x*** ∨ ***z***) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ***x*** | ***y*** | ***z*** | ***x*** ∨ (***y*** ∧ ***z***) | (***x*** ∨
    ***y***) ∧ (***x*** ∨ ***z***) |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `0` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `0` | `0` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `1` | `1` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `0` | `1` | `1` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `1` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `1` |'
- en: '| `1` | `1` | `0` | `1` | `1` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `1` | `1` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` |'
- en: Comparing the two right-hand columns, you can tell that OR-ing the variable,
    *x*, with each of the two AND-ed variables, *y* and *z*, gives the same result
    as OR-ing it with each of the variables and AND-ing the two OR-ed terms. Thus,
    the distributive property holds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个右侧列，你可以看出，将变量*x*与每个AND操作的变量*y*和*z*进行或（OR）运算，得到的结果与将*x*与每个变量进行或（OR）运算，再将两个或（OR）结果进行与（AND）运算的结果相同。因此，分配律成立。
- en: '**OR has an annulment (also called annihilation) value**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**或（OR）有一个消除值（也称为湮灭值）**'
- en: 'There is no annulment value for addition in elementary algebra, but in Boolean
    algebra, the annulment value for OR is `1`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在初等代数中加法没有消除值，但在布尔代数中，或（OR）的消除值是`1`：
- en: '![Image](../images/pg88_Image_63.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg88_Image_63.jpg)'
- en: '**AND and OR both have a complement value**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**与（AND）和或（OR）都有补值**'
- en: 'The *complement value* is the diminished radix complement of the variable.
    You learned in [Chapter 3](ch03.xhtml) that the sum of a quantity and that quantity’s
    diminished radix complement is equal to (*radix* – 1). Since the radix in Boolean
    algebra is 2, the complement of `0` is `1` and the complement of `1` is `0`. So,
    the complement of a Boolean quantity is simply the NOT of that quantity, which
    gives:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*补值*是变量的减基补值。你在[第3章](ch03.xhtml)中学到，某个量与该量的减基补值的和等于（*基数* – 1）。由于布尔代数中的基数为2，`0`的补值是`1`，`1`的补值是`0`。因此，布尔量的补值就是该量的非（NOT），即：'
- en: '![Image](../images/pg88_Image_64.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg88_Image_64.jpg)'
- en: 'The complement value illustrates one of the differences between the AND and
    OR logical operations and the multiplication and addition arithmetic operations.
    In elementary algebra:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 补值展示了与（AND）和或（OR）逻辑运算与乘法和加法算术运算之间的一个区别。在初等代数中：
- en: '![Image](../images/pg88_Image_65.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg88_Image_65.jpg)'
- en: Even if we restrict *x* to be 0 or 1, in elementary algebra 1 · (–1) = –1 and
    1 + (–1) = 0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将*x*限制为0或1，在初等代数中，1 · (–1) = –1，1 + (–1) = 0。
- en: '**AND and OR are idempotent**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**与（AND）和或（OR）是幂等的**'
- en: 'If an operator is *idempotent*, applying it to two of the same operands results
    in that operand. In other words:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个运算符是*幂等的*，将其应用于两个相同的操作数会得到该操作数。换句话说：
- en: '![Image](../images/pg89_Image_66.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg89_Image_66.jpg)'
- en: This looks different than in elementary algebra, where repeatedly multiplying
    a number by itself is exponentiation and repeatedly adding a number to itself
    is equivalent to multiplication.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这与初等代数中的情况不同，在初等代数中，重复将一个数乘以它本身是指数运算，重复将一个数加到它本身则相当于乘法。
- en: '**De Morgan’s law applies**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**德摩根定律适用**'
- en: 'In Boolean algebra, the special relationship between the AND and OR operations
    is captured by *De Morgan’s law*, which states:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔代数中，与（AND）和或（OR）运算之间的特殊关系由*德摩根定律*表达，该定律指出：
- en: '![Image](../images/pg89_Image_67.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg89_Image_67.jpg)'
- en: The first equation states that the NOT of the AND of two Boolean quantities
    is equal to the OR of the NOT of the two quantities. The second equation states
    that the NOT of the OR of two Boolean quantities is equal to the AND of the NOT
    of the two quantities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程表示两个布尔量的与（AND）的非（NOT）等于这两个量的非（NOT）的或（OR）。第二个方程表示两个布尔量的或（OR）的非（NOT）等于这两个量的非（NOT）的与（AND）。
- en: This relationship is an example of the *principle of duality*, which in Boolean
    algebra states that if you replace every `0` with a `1`, every `1` with a `0`,
    every AND with an OR, and every OR with an AND, the equation is still true. Look
    back over the rules just given and you’ll see that all of them except involution
    have dual operations. De Morgan’s law is one of the best examples of duality;
    you’ll see this principle in play when you complete “Your Turn” [exercise 4.2](ch04.xhtml#ch4exe2).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系是*对偶原则*的一个例子，在布尔代数中，若你将每个`0`替换为`1`，每个`1`替换为`0`，每个与（AND）替换为或（OR），每个或（OR）替换为与（AND），该等式仍然成立。回顾刚刚给出的规则，你会发现除了自反外，所有规则都有对偶运算。德摩根定律是对偶的最佳例子之一；你将在完成“你的练习”[4.2节练习](ch04.xhtml#ch4exe2)时看到这一原则的应用。
- en: '**YOUR TURN**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的练习**'
- en: 4.1     Use truth tables to prove the Boolean algebra rules given in this section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 4.1     使用真值表证明本节中给出的布尔代数规则。
- en: 4.2     Prove De Morgan’s law.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2     证明德摩根定律。
- en: '**Boolean Functions**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔函数**'
- en: The functionality of a computer is based on Boolean logic, which means the various
    operations of a computer are specified by Boolean functions. A Boolean function
    looks somewhat like a function in elementary algebra, but the variables can appear
    in either uncomplemented or complemented form. The variables and constants are
    connected by Boolean operators. A Boolean function evaluates to either `1` or
    `0` (true or false).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的功能基于布尔逻辑，这意味着计算机的各种操作是由布尔函数指定的。布尔函数看起来有点像初等代数中的函数，但变量可以是未补充或已补充的形式。变量和常量通过布尔运算符连接。布尔函数的结果只能是
    `1` 或 `0`（真或假）。
- en: 'When we discussed addition in the binary number system on [page 41](ch03.xhtml#page_41)
    in [Chapter 3](ch03.xhtml), you saw that when adding two bits, *x* and *y*, we
    have to include a possible carry into their bit position in the computation. The
    conditions that cause the carry out from the bit position to be `1` are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第41页](ch03.xhtml#page_41)的[第3章](ch03.xhtml)讨论二进制数系统中的加法时，你会看到，在加两个位，*x*
    和 *y* 时，我们必须在计算中考虑可能的进位到它们的位位置。导致进位为 `1` 的条件是：
- en: there’s no carry into the current bit position, *x* = `1`, and *y* = `1`, or
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当前位位置没有进位，*x* = `1`，且 *y* = `1`，或者
- en: there’s a carry into the current bit position, *x* = `0`, and *y* = `1`, or
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当前位位置有进位，*x* = `0`，且 *y* = `1`，或者
- en: there’s a carry into the current bit position, *x* = `1`, and *y* = `0`, or
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当前位位置有进位，*x* = `1`，且 *y* = `0`，或者
- en: there’s a carry into the current bit position, *x* = `1`, and *y* = `1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当前位位置有进位，*x* = `1`，且 *y* = `1`。
- en: We can express this more concisely with the Boolean function
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用布尔函数更简洁地表示这个
- en: '![Image](../images/pg90_Image_68.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_68.jpg)'
- en: where *x* is one bit, *y* is the other bit, *c[in]* is the carry in from the
    next lower-order bit position, and *C[out]*(*c[in]*, *x*, *y*) is the carry resulting
    from the addition in the current bit position. We’ll use this equation throughout
    this section, but first, let’s think a bit about the differences between Boolean
    and elementary functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x* 是一个位，*y* 是另一个位，*c[in]* 是来自下一位位置的进位，*C[out]*(*c[in]*, *x*, *y*) 是当前位位置加法的进位。我们将在本节中使用这个方程，但首先，让我们思考一下布尔函数和初等代数函数之间的区别。
- en: Like an elementary algebra function, a Boolean algebra function can be manipulated
    mathematically, but the mathematical operations are different. Operations in elementary
    algebra are performed on the infinite set of real numbers, but Boolean functions
    work on only two possible values, `0` or `1`. Elementary algebra functions can
    evaluate to any real number, but Boolean functions can evaluate only to `0` or
    `1`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 像初等代数函数一样，布尔代数函数也可以进行数学操作，但数学运算是不同的。初等代数的运算是在无限的实数集上进行的，而布尔函数只在两个可能的值 `0` 或
    `1` 上操作。初等代数函数可以评估为任意实数，但布尔函数只能评估为 `0` 或 `1`。
- en: 'This difference means we have to think differently about Boolean functions.
    For example, look at this elementary algebra function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个差异意味着我们必须以不同的方式思考布尔函数。例如，看看这个初等代数函数：
- en: '![Image](../images/pg90_Image_69.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_69.jpg)'
- en: You probably read it as “if I multiply the value of *x* by the negative of the
    value of *y*, I’ll get the value of *F*(*x*, *y*).” However, with the Boolean
    function
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会这样理解：“如果我将 *x* 的值乘以 *y* 的负值，我将得到 *F*(*x*, *y*) 的值。”然而，对于布尔函数
- en: '![Image](../images/pg90_Image_70.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_70.jpg)'
- en: there are only four possibilities. If *x* = 1 and *y* = 0, then *F*(*x*, *y*)
    = `1`; for the other three possibilities, *F*(*x*, *y*) = `0`. Whereas you can
    plug any numbers into an elementary algebra function, a Boolean algebra function
    shows you what the values of the variables are that cause the function to evaluate
    to `1`. I think of elementary algebra functions as *asking* me to plug in values
    for the variables for evaluation, while Boolean algebra functions *tell* me what
    values of the variables cause the function to evaluate to `1`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只有四种可能性。如果 *x* = 1 且 *y* = 0，那么 *F*(*x*, *y*) = `1`；对于其他三种情况，*F*(*x*, *y*) =
    `0`。而你可以将任何数字代入初等代数函数，但布尔代数函数会告诉你哪些变量值导致该函数的结果为 `1`。我认为初等代数函数是在*要求*我代入变量值进行评估，而布尔代数函数则是*告诉*我哪些变量值会使函数结果为
    `1`。
- en: There are simpler ways to express the conditions for carry, and those simplifications
    lead to being able to implement a Boolean function for carry with fewer logic
    gates, thus lowering the cost and power usage. In this and the following sections,
    you’ll learn how the mathematical nature of Boolean algebra makes function simplification
    easier and more concise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 也有更简单的方式来表达进位的条件，这些简化使得我们能够用更少的逻辑门实现布尔进位函数，从而降低成本和功耗。在本节及接下来的章节中，你将了解布尔代数的数学性质是如何让函数简化变得更加容易和简洁的。
- en: '***Canonical Sum or Sum of Minterms***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***规范和或最小项之和***'
- en: A *canonical form* of a Boolean function explicitly shows whether each variable
    in the problem is complemented or not in each term that defines the function,
    just as we did with our plain-language statement of the conditions that produce
    a carry of `1` earlier. This ensures that you have taken all possible combinations
    into account in the function definition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔函数的*规范形式*明确显示了在定义该函数的每个项中，问题中的每个变量是否取反，就像我们之前用简单语言描述产生进位为`1`的条件一样。这确保了你已经考虑了函数定义中的所有可能组合。
- en: We’ll use the equation for carry on [page 62](ch04.xhtml#page_62) to illustrate
    these concepts. Although the parentheses in the equation are not required, I’ve
    added them to help you see the form of the equation. The parentheses show four
    *product terms*, which are terms where all the literals are operated on only by
    AND. The four product terms are then OR-ed together. Since the OR operation is
    like addition, the right-hand side is called a *sum of products*. It’s also said
    to be in *disjunctive normal form*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第62页](ch04.xhtml#page_62)的进位方程来说明这些概念。尽管方程中的括号不是必需的，但我已将它们添加以帮助你看到方程的形式。括号显示了四个*乘积项*，这些项中的所有字面量仅通过与运算进行操作。然后将这四个乘积项进行或运算。由于或运算类似于加法，因此右侧被称为*积和*。它也被称为*析取标准形式*。
- en: Let’s look more closely at the product terms. Each of them includes all the
    variables in this equation in the form of a literal (uncomplemented or complemented).
    An equation that has *n* variables has 2*^n* permutations of the values for the
    variables; a *minterm* is a product term that specifies exactly one of the permutations.
    Since there are four combinations of values for *c[in]*, *x*, and *y* that produce
    a carry of `1`, the previous equation has four of the possible eight minterms.
    A Boolean function that is defined by summing (ORing) all the minterms that evaluate
    to `1` is said to be a *canonical sum*, a *sum of minterms*, or in *full disjunctive
    normal form*. A function defined by a sum of minterms evaluates to `1` when at
    least one of the minterms evaluates to `1`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些乘积项。每个乘积项都包含了这个方程中所有变量的字面量（正向或取反形式）。一个有 *n* 个变量的方程有2*^n*种变量值的排列；一个*最小项*是一个乘积项，准确地指定了其中一种排列。由于有四种
    *c[in]*、*x* 和 *y* 的取值组合可以产生进位 `1`，因此前面的方程有四个可能的八个最小项。一种通过将所有评估为`1`的最小项求和（或运算）定义的布尔函数，被称为*规范和*，*最小项之和*，或*完整析取标准形式*。由最小项之和定义的函数当至少有一个最小项的值为`1`时，函数的值也为`1`。
- en: For every minterm, exactly one set of values for the variables makes the minterm
    evaluate to `1`. For example, the minterm (*c[in]* ∧ *x* ∧ ¬*y*) in the previous
    equation evaluates to `1` only when *c[in]* = `1`, *x* = `1`, *y* = `0`. A product
    term that does not contain all the variables in the problem, in either uncomplemented
    or complemented form, will always evaluate to `1` for more sets of values for
    the variables than a minterm. For example, (*c[in]* ∧ *x*) evaluates to `1` for
    *c[in]* = `1`, *x* = `1`, *y* = `0` and for *c[in]* = `1`, *x* = `1`, *y* = `1`.
    (We call them *min*terms because they minimize the number of cases that evaluate
    to `1`.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个最小项，恰好有一组变量的取值使得该最小项的值为`1`。例如，前一个方程中的最小项（*c[in]* ∧ *x* ∧ ¬*y*）仅在 *c[in]*
    = `1`，*x* = `1`，*y* = `0` 时取值为`1`。一个不包含问题中所有变量（无论是正向还是取反形式）的乘积项，将总是对于更多的变量取值组合评估为`1`，而不是最小项。例如，(*c[in]*
    ∧ *x*) 对于 *c[in]* = `1`，*x* = `1`，*y* = `0` 和 *c[in]* = `1`，*x* = `1`，*y* = `1`
    时都取值为`1`。（我们称它们为*最小*项，因为它们最小化了评估为`1`的情况数。）
- en: Rather than write out all the literals in a function, logic designers commonly
    use the notation *m[i]* to specify the *i*th minterm, where *i* is the integer
    represented by the values of the literals in the problem if the values are placed
    in order and treated as binary numbers. For example, *c[in]* = `1`, *x* = `1`,
    *y* = `0` gives `110`, which is the (base 10) number 6; thus, that minterm is
    *m*[6].
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与其列出一个函数中所有的文字常量，逻辑设计师通常使用符号*m[i]*来指定第*i*个最小项，其中*i*是通过将文字常量按顺序排列并将其视为二进制数字时，表示该数字的整数。例如，*c[in]*
    = `1`，*x* = `1`，*y* = `0`，得到的二进制数为`110`，即十进制数6；因此，该最小项是*m*[6]。
- en: '[Table 4-6](ch04.xhtml#ch4tab6) shows all eight possible minterms for the three-variable
    function that specifies carry.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-6](ch04.xhtml#ch4tab6)显示了指定进位的三变量函数的所有八个可能最小项。'
- en: '**Table 4-6:** The Conditions That Cause Carry to Be `1`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-6：** 使进位为 `1` 的条件'
- en: '| ***c******[in]*** | ***x*** | ***y*** | Minterm | ***C****[out]***(***c******[in]******,
    x, y***) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ***c******[in]*** | ***x*** | ***y*** | 最小项 | ***C****[out]***(***c******[in]******,
    x, y***) |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | *m*[0]     (¬*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | *m*[0]     (¬*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
- en: '| `0` | `0` | `1` | *m*[1]     (¬*c[in]* ∧ ¬*x* ∧ *y*) | `0` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | *m*[1]     (¬*c[in]* ∧ ¬*x* ∧ *y*) | `0` |'
- en: '| `0` | `1` | `0` | *m*[2]     (¬*c[in]* ∧ *x* ∧ ¬*y*) | `0` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | *m*[2]     (¬*c[in]* ∧ *x* ∧ ¬*y*) | `0` |'
- en: '| `0` | `1` | `1` | *m*[3]     (¬*c[in]* ∧ *x* ∧ *y*) | `1` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | *m*[3]     (¬*c[in]* ∧ *x* ∧ *y*) | `1` |'
- en: '| `1` | `0` | `0` | *m*[4]     (*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | *m*[4]     (*c[in]* ∧ ¬*x* ∧ ¬*y*) | `0` |'
- en: '| `1` | `0` | `1` | *m*[5]     (*c[in]* ∧ ¬*x* ∧ *y*) | `1` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | *m*[5]     (*c[in]* ∧ ¬*x* ∧ *y*) | `1` |'
- en: '| `1` | `1` | `0` | *m*[6]     (*c[in]* ∧ *x* ∧ ¬*y*) | `1` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | *m*[6]     (*c[in]* ∧ *x* ∧ ¬*y*) | `1` |'
- en: '| `1` | `1` | `1` | *m*[7]     (*c[in]* ∧ *x* ∧ y) | `1` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | *m*[7]     (*c[in]* ∧ *x* ∧ y) | `1` |'
- en: The *C[out]*(*c[in]*, *x*, *y*) column shows which minterms in our equation
    cause it to evaluate to `1`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*C[out]*(*c[in]*, *x*, *y*)列显示了在我们的方程中，哪些最小项使其值为`1`。'
- en: 'Using this notation to write a Boolean equation as a canonical sum and using
    the ∑ symbol to denote summation, we can restate the function for carry as:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种符号将布尔方程写为标准和并式，并使用∑符号表示求和，我们可以将进位函数重新表述为：
- en: '![Image](../images/pg92_Image_71.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg92_Image_71.jpg)'
- en: We are looking at a simple example here. For more complicated functions, writing
    out all the minterms is error-prone. The simplified notation is easier to work
    with and helps avoid making errors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里只是一个简单的例子。对于更复杂的函数，列出所有最小项容易出错。简化后的符号更易于操作，且有助于避免出错。
- en: '***Canonical Product or Product of Maxterms***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标准积或最大项积***'
- en: 'Depending on factors like available components and personal choice, a designer
    may prefer to work with the cases where a function evaluates to `0` instead of
    `1`. In our example, that means a design that specifies when the complement of
    carry is `0`. To see how this works, let’s take the complement of both sides of
    the equation for specifying carry, using De Morgan’s law:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据可用组件和个人选择等因素，设计师可能更倾向于处理当函数值为`0`而非`1`的情况。在我们的示例中，这意味着设计中指定了进位补码为`0`的情况。为了了解这个过程，接下来我们对指定进位的方程两边取补，运用德摩根定律：
- en: '![Image](../images/pg92_Image_72.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg92_Image_72.jpg)'
- en: Because we complemented both sides of the equation, we now have the Boolean
    equation for ¬*C[out]*, the complement of carry. Thus, we are looking for conditions
    that cause ¬*C[out]* to evaluate to `0`, not `1`. In this equation, the parentheses
    are required due to the precedence rules of Boolean operators. The parentheses
    show four *sum terms*, which are terms where all the literals are operated on
    only by OR. The four sum terms are then AND-ed together. Since the AND operation
    is like multiplication, the right-hand side is called a *product of sums*. It’s
    also said to be in *conjunctive normal form*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们对方程两边取了补，所以现在得到的是¬*C[out]*的布尔方程，即进位的补码。因此，我们需要寻找使¬*C[out]*的值为`0`而非`1`的条件。在这个方程中，由于布尔运算符的优先级规则，括号是必需的。括号表示四个*和项*，即所有文字常量仅通过“或”运算进行处理的项。然后，四个和项通过“与”运算相乘。由于“与”运算类似于乘法，因此右侧称为*和项的积*，也可以说是*合取标准形式*。
- en: Each of the sum terms includes all the variables in this equation in the form
    of literals (uncomplemented or complemented). Whereas a minterm was a *product*
    term that specified a single permutation of the 2*^n* permutations of possible
    values for the variables, a *maxterm* is a *sum* term specifying exactly one of
    those permutations. A Boolean function that is defined by multiplying (AND-ing)
    all the maxterms that evaluate to `0` is said to be a *canonical product*, a *product
    of maxterms*, or in *full conjunctive normal form*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Each maxterm identifies exactly one set of values for the variables in a function
    that cause the term to evaluate to `0` when OR-ed together. For example, the maxterm
    (¬*c[in]* ∨ ¬*x* ∨ *y*) in the previous equation evaluates to `0` only when *c[in]*
    = `1`, *x* = `1`, *y* = `0`. But a sum term that does not contain all the variables
    in the problem, in either uncomplemented or complemented form, will always evaluate
    to `0` for more than one set of values. For example, the sum term (¬*c[in]* ∨
    ¬*x*) evaluates to `0` for two sets of values for the three variables in this
    example, *c[in]* = `1`, *x* = `1`, *y* = `0` and *c[in]* = `1`, *x* = `1`, and
    *y* = `1`. (We call them *max*terms because they minimize the number of cases
    that evaluate to `0` and thus *maximize* the number of cases that evaluate to
    `1`.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Rather than write out all the literals in a function, logic designers commonly
    use the notation *M[i]* to specify the *i*th maxterm, where *i* is the integer
    value of the base 2 number created by concatenating the values of the literals
    in the problem. For example, stringing together *c[in]* = `1`, *x* = `1`, *y*
    = `0` gives `110`, which is the maxterm *M*[6]. The truth table in [Table 4-7](ch04.xhtml#ch4tab7)
    shows the maxterms that cause the carry to be `0`. Notice that maxterm *M*[6]
    = (¬*c[in]* ∨ ¬*x* ∨ *y*) evaluates to `0` when *c[in]* = `1`, *x* = `1`, and
    *y* = `0`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-7](ch04.xhtml#ch4tab7) shows all eight possible maxterms for the three-variable
    function that specifies the complement of carry.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-7:** The Conditions That Cause the Complement of Carry to Be `0`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| ***c******[in]*** | ***x*** | ***y*** | Maxterm | **¬*****C******[out]***(***c******[in]******,
    x, y***) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | *M*[0]     (*c[in]* ∨ *x* ∨ *y*) | `1` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | *M*[1]     (*c[in]* ∨ *x* ∨ ¬*y*) | `1` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | *M*[2]     (*c[in]* ∨ ¬*x* ∨ *y*) | `1` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | *M*[3]     (*c[in]* ∨ ¬*x* ∨ ¬*y*) | `0` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | *M*[4]     (¬*c[in]* ∨ *x* ∨ *y*) | `1` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | *M*[5]     (¬*c[in]* ∨ *x* ∨ ¬*y*) | `0` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | *M*[6]     (¬*c[in]* ∨ ¬*x* ∨ *y*) | `0` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | *M*[7]     (¬*c[in]* ∨ ¬*x* ∨ ¬*y*) | `0` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: The ¬*C[out]*(*c[in]*, *x*, *y*) column shows which maxterms in our equation
    cause it to evaluate to `0`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this notation to write a Boolean equation as a canonical product and
    using the ∏ symbol to denote multiplication, we can restate the function for the
    complement of carry as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种符号表示法将布尔方程写成标准积形式，并使用∏符号表示乘法，我们可以将进位补函数重新表述为：
- en: '![Image](../images/pg93_Image_73.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg93_Image_73.jpg)'
- en: In [Table 4-7](ch04.xhtml#ch4tab7), you’ll see that these are the conditions
    that cause the complement of carry to be `0` and hence the carry to be `1`. This
    shows that using either minterms or maxterms is equivalent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表4-7](ch04.xhtml#ch4tab7)中，你会看到这些条件导致进位补值为`0`，从而使进位为`1`。这表明，使用最小项或最大项是等效的。
- en: '***Comparison of Canonical Boolean Forms***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标准布尔形式的比较***'
- en: '[Table 4-8](ch04.xhtml#ch4tab8) shows all the minterms and maxterms for a three-variable
    problem. Comparing the corresponding minterms and maxterms reveals the duality
    of minterms and maxterms: one can be formed from the other using De Morgan’s law
    by complementing each variable and interchanging OR and AND.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-8](ch04.xhtml#ch4tab8)显示了三变量问题的所有最小项和最大项。比较对应的最小项和最大项揭示了最小项和最大项的对偶性：可以通过使用德摩根定律，将每个变量取反并互换或门和与门来从另一项构造出对偶。'
- en: '**Table 4-8:** The Canonical Terms for a Three-Variable Problem'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-8：** 三变量问题的标准项'
- en: '| **Minterm = 1** | ***x*** | ***y*** | ***z*** | **Maxterm = 0** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **最小项 = 1** | ***x*** | ***y*** | ***z*** | **最大项 = 0** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| *m*[0]     ¬*x* ∧ ¬*y* ∧ ¬*z* | `0` | `0` | `0` | *M*[0]     *x* ∨ *y* ∨
    *z* |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| *m*[0]     ¬*x* ∧ ¬*y* ∧ ¬*z* | `0` | `0` | `0` | *M*[0]     *x* ∨ *y* ∨
    *z* |'
- en: '| *m*[1]     ¬*x* ∧ ¬*y* ∧ *z* | `0` | `0` | `1` | *M*[1]     *x* ∨ *y* ∨ ¬*z*
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| *m*[1]     ¬*x* ∧ ¬*y* ∧ *z* | `0` | `0` | `1` | *M*[1]     *x* ∨ *y* ∨ ¬*z*
    |'
- en: '| *m*[2]     ¬*x* ∧ *y* ∧ ¬*z* | `0` | `1` | `0` | *M*[2]     *x* ∨ ¬*y* ∨*z*
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| *m*[2]     ¬*x* ∧ *y* ∧ ¬*z* | `0` | `1` | `0` | *M*[2]     *x* ∨ ¬*y* ∨*z*
    |'
- en: '| *m*[3]     ¬*x* ∧ *y* ∧ *z* | `0` | `1` | `1` | *M*[3]     *x* ∨ ¬*y* ∨ ¬*z*
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| *m*[3]     ¬*x* ∧ *y* ∧ *z* | `0` | `1` | `1` | *M*[3]     *x* ∨ ¬*y* ∨ ¬*z*
    |'
- en: '| *m[4]*     *x* ∧ ¬*y* ∧ ¬*z* | `1` | `0` | `0` | *M*[4]     ¬*x* ∨ *y* ∨
    *z* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| *m[4]*     *x* ∧ ¬*y* ∧ ¬*z* | `1` | `0` | `0` | *M*[4]     ¬*x* ∨ *y* ∨
    *z* |'
- en: '| *m*[5]     *x* ∧ ¬*y* ∧ *z* | `1` | `0` | `1` | *M*[5]     ¬*x* ∨ *y* ∨ ¬*z*
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| *m*[5]     *x* ∧ ¬*y* ∧ *z* | `1` | `0` | `1` | *M*[5]     ¬*x* ∨ *y* ∨ ¬*z*
    |'
- en: '| *m*[6]     *x* ∧ *y* ∧ ¬*z* | `1` | `1` | `0` | *M*[6]     ¬*x* ∨ ¬*y* ∨
    *z* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| *m*[6]     *x* ∧ *y* ∧ ¬*z* | `1` | `1` | `0` | *M*[6]     ¬*x* ∨ ¬*y* ∨
    *z* |'
- en: '| *m*[7]     *x* ∧ *y* ∧ *z* | `1` | `1` | `1` | *M*[7]     ¬*x* ∨ ¬*y* ∨ ¬*z*
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| *m*[7]     *x* ∧ *y* ∧ *z* | `1` | `1` | `1` | *M*[7]     ¬*x* ∨ ¬*y* ∨ ¬*z*
    |'
- en: The Venn diagrams in [Figure 4-4](ch04.xhtml#ch4fig4) provide a pictorial view
    of the reason we use the terms minterm and maxterm.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.xhtml#ch4fig4)中的维恩图提供了使用最小项和最大项这两个术语的原因的图示。'
- en: '![Image](../images/pg94_Image_74.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg94_Image_74.jpg)'
- en: '*Figure 4-4: The relationships between three variables for a minterm and a
    maxterm*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：三变量的最小项和最大项之间的关系*'
- en: The canonical forms give us a complete and unique statement of the function
    because they take all possible combinations of the variables’ values into account.
    However, there often are simpler solutions to the problem. The remainder of this
    chapter will be devoted to methods of simplifying Boolean functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 标准形式给出了函数的完整且唯一的陈述，因为它们考虑了变量值的所有可能组合。然而，通常有更简化的解决方案。本章的其余部分将致力于布尔函数简化的方法。
- en: '**Boolean Expression Minimization**'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式简化**'
- en: When implementing a Boolean function in hardware, each ∧ operator specifies
    an AND gate, each ∨ operator specifies an OR gate, and each ¬ operator specifies
    a NOT gate. In general, the complexity of the hardware is related to the number
    of AND and OR gates used (NOT gates are simple and tend not to contribute significantly
    to the complexity). Simpler hardware uses fewer components, thus saving cost and
    space, and uses less power. These savings are especially important with handheld
    and wearable devices. In this section, you’ll learn how you can manipulate Boolean
    expressions to reduce the number of AND and OR gates, thus simplifying their hardware
    implementation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中实现布尔函数时，每个∧运算符表示一个与门（AND gate），每个∨运算符表示一个或门（OR gate），每个¬运算符表示一个非门（NOT gate）。通常，硬件的复杂性与使用的与门和或门的数量有关（非门较简单，通常不会显著增加复杂性）。更简化的硬件使用更少的组件，从而节省成本和空间，并减少功耗。这些节省在手持设备和可穿戴设备中尤为重要。本节将介绍如何操作布尔表达式，以减少与门和或门的数量，从而简化硬件实现。
- en: '#### ***Minimal Expressions***'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***最简表达式***'
- en: When simplifying a function, start with one of the canonical forms to ensure
    you have taken all possible cases into account. To translate a problem into a
    canonical form, create a truth table that lists all possible combinations of the
    variables in the problem. From the truth table, it will be easy to list the minterms
    or maxterms that define the function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在简化函数时，从规范形式之一开始，以确保你已考虑到所有可能的情况。为了将问题转化为规范形式，创建一个列出问题中所有可能组合的真值表。从真值表中，列出定义函数的最小项或最大项将变得容易。
- en: Armed with a canonical statement, the next step is to look for a functionally
    equivalent *minimal expression*, which is an expression that does the same thing
    as the canonical one using a minimum number of literals and Boolean operators.
    To minimize an expression, we apply the rules of Boolean algebra to reduce the
    number of terms and the number of literals in each term, without changing the
    logical meaning of the expression.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有规范表达式后，下一步是寻找一个功能等价的*最小表达式*，这是一个使用最少字面量和布尔运算符实现与规范表达式相同功能的表达式。为了简化表达式，我们应用布尔代数规则，以减少项数和每个项中的字面量数量，而不改变表达式的逻辑意义。
- en: 'There are two types of minimal expressions, depending on whether you use minterms
    or maxterms:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最小表达式有两种类型，具体取决于是使用最小项（minterms）还是最大项（maxterms）：
- en: '**Minimal sum of products**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小和积**'
- en: 'When starting with a minterms description of the problem, the minimal expression,
    known as a *minimal sum of products*, is a sum of products expression where all
    other mathematically equivalent sum of products expressions have at least as many
    product terms and those with the same number of product terms have at least as
    many literals. As an example of a minimal sum of products, consider these equations:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当从最小项描述问题时，最小表达式，称为 *最小和积*，是一个和积表达式，其中所有其他在数学上等价的和积表达式至少有与其相同数量的乘积项，且具有相同数量乘积项的表达式至少有与其相同数量的字面量。作为最小和积的一个例子，考虑以下方程：
- en: '![Image](../images/pg95_Image_75.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg95_Image_75.jpg)'
- en: '*S* is in canonical form as each of the product terms explicitly shows the
    contribution of all three variables. The other three functions are simplifications
    of *S*. Although all three have the same number of product terms, *S3* is a minimal
    sum of products for *S* because it has fewer literals in its product terms than
    *S1* and *S2*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* 处于规范形式，因为每一个乘积项都明确显示了三个变量的贡献。其他三个函数是 *S* 的简化形式。尽管这三个函数的乘积项数量相同，*S3* 是 *S*
    的最小和积，因为它的乘积项比 *S1* 和 *S2* 包含更少的字面量。'
- en: '**Minimal product of sums**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小积和**'
- en: 'When starting with a maxterms description of the problem, the minimal expression,
    known as a *minimal product of sums*, is a product of sums expression where all
    other mathematically equivalent product of sums expressions have at least as many
    sum terms and those with the same number of sum terms have at least as many literals.
    For an example of a minimal product of sums, consider these equations:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当从最大项描述问题时，最小表达式，称为 *最小积和*，是一个积和表达式，其中所有其他在数学上等价的积和表达式至少有与其相同数量的和项，且具有相同数量和项的表达式至少有与其相同数量的字面量。作为最小积和的一个例子，考虑以下方程：
- en: '![Image](../images/pg95_Image_76.jpg) *P* is in canonical form, and the other
    three functions are simplifications of *P*. Although all three have the same number
    of sum terms as *P*, *P3* is a minimal product of sums for *P* because it has
    fewer literals in its product terms than *P1* and *P2*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg95_Image_76.jpg) *P* 处于规范形式，其他三个函数是 *P* 的简化形式。尽管这三个函数的和项数量与
    *P* 相同，*P3* 是 *P* 的最小积和，因为它的乘积项比 *P1* 和 *P2* 包含更少的字面量。'
- en: A problem may have more than one minimal solution. Good hardware design typically
    involves finding several minimal solutions and assessing each one within the context
    of the available hardware. This means more than using fewer gates; for example,
    as you’ll learn when we discuss hardware implementation, adding judiciously placed
    NOT gates can reduce hardware complexity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题可能有多个最小解。良好的硬件设计通常涉及找到多个最小解，并在可用硬件的背景下评估每个解。这不仅仅是使用更少的门电路；例如，当我们讨论硬件实现时，你会学到，合理放置的非门（NOT
    gate）可以减少硬件复杂度。
- en: In the following two sections, you’ll learn two ways to find minimal expressions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两部分中，你将学习找到最小表达式的两种方法。
- en: '***Minimization Using Algebraic Manipulations***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用代数运算进行最小化***'
- en: 'To illustrate the importance of reducing the complexity of a Boolean function,
    let’s return to the function for carry:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明简化布尔函数复杂性的重要性，让我们回到进位函数：
- en: '![Image](../images/pg96_Image_77.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_77.jpg)'
- en: The expression on the right-hand side of the equation is a sum of minterms.
    [Figure 4-5](ch04.xhtml#ch4fig5) shows the circuit to implement this function.
    It requires four AND gates and one OR gate. The small circles at the inputs to
    the AND gates indicate a NOT gate at that input.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 方程右侧的表达式是最小项的和。[图4-5](ch04.xhtml#ch4fig5)展示了实现此功能的电路。它需要四个与门和一个或门。与门输入端的小圆圈表示该输入处有一个非门。
- en: '![Image](../images/pg96_Image_78.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_78.jpg)'
- en: '*Figure 4-5: A hardware implementation of a function to generate the value
    of carry when adding two numbers*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：生成加法两个数字时的进位值的硬件实现*'
- en: Let’s try to simplify the Boolean expression implemented in [Figure 4-5](ch04.xhtml#ch4fig5)
    to see whether we can reduce the hardware requirements. Note that there may not
    be a single path to a solution, and there may be more than one correct solution.
    I will present only one way here.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试简化在[图4-5](ch04.xhtml#ch4fig5)中实现的布尔表达式，看看是否能减少硬件需求。请注意，可能没有单一的解决路径，也可能有多个正确的解决方案。我这里仅展示一种方式。
- en: 'First, we’ll do something that might look strange. We’ll use the idempotency
    rule to duplicate the fourth term twice:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将做一些看起来可能有些奇怪的事情。我们将使用幂等性规则，将第四项复制两次：
- en: '![Image](../images/pg96_Image_79.jpg) Next, we’ll rearrange the product terms
    a bit to OR each of the three original terms with (*c[in]* ∧ *x* ∧ *y*):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg96_Image_79.jpg) 接下来，我们将稍微调整乘积项，以便将三个原始项中的每一项与(*c[in]*
    ∧ *x* ∧ *y*)进行或运算：'
- en: '![Image](../images/pg97_Image_80.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg97_Image_80.jpg)'
- en: 'Now, we can use the rule for distribution of AND over OR to factor out terms
    that OR to `1`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用与或分配规则，将与运算分配到或运算上，提取出与`1`的项：
- en: '![Image](../images/pg97_Image_81.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg97_Image_81.jpg)'
- en: '[Figure 4-6](ch04.xhtml#ch4fig6) shows the circuit for this function. Not only
    have we eliminated an AND gate, but each of the AND gates and the OR gate has
    one fewer input.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-6](ch04.xhtml#ch4fig6)展示了这个功能的电路。我们不仅消除了一个与门，而且每个与门和或门的输入减少了一个。'
- en: '![Image](../images/pg97_Image_82.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg97_Image_82.jpg)'
- en: '*Figure 4-6: A simplified hardware implementation to generate the value of
    carry when adding two numbers*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：简化的硬件实现，用于生成加法两个数字时的进位值*'
- en: 'Comparing the circuits in [Figures 4-5](ch04.xhtml#ch4fig5) and [4-6](ch04.xhtml#ch4fig6),
    we can see that Boolean algebra has helped us simplify the hardware implementation.
    This simplification results from stating the conditions that result in a carry
    of `1` in plain language. The original, canonical form of the equation stated
    that a carry, *C[out]*(*c[in]*, *x*, *y*), will be `1` in any of these four cases:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 比较[图4-5](ch04.xhtml#ch4fig5)和[图4-6](ch04.xhtml#ch4fig6)中的电路，我们可以看到布尔代数帮助我们简化了硬件实现。这种简化来自于用通俗的语言表达出导致进位为`1`的条件。方程的原始标准形式表示，当满足以下四种情况时，进位*C[out]*(*c[in]*,
    *x*, *y*)将为`1`：
- en: If *c[in]* = `0`, *x* = `1`, and *y* = `1`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*c[in]* = `0`，*x* = `1`，且*y* = `1`
- en: If *c[in]* = `1`, *x* = `0`, and *y* = `1`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*c[in]* = `1`，*x* = `0`，且*y* = `1`
- en: If *c[in]* = `1`, *x* = `1`, and *y* = `0`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*c[in]* = `1`，*x* = `1`，且*y* = `0`
- en: If *c[in]* = `1`, *x* = `1`, and *y* = `1`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*c[in]* = `1`，*x* = `1`，且*y* = `1`
- en: 'The minimization can be stated much more simply: carry is `1` if at least two
    of *c[in]*, *x*, and *y* are `1`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化可以更简洁地表述：当*c[in]*、*x*和*y*中至少有两个为`1`时，进位为`1`。
- en: '**NOTE**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*These examples of specifying a logic circuit for carry from addition, and
    the algorithm for subtraction in [Chapter 3](ch03.xhtml), illustrate one of the
    more common sources of programming errors. Specifying an activity that seems very
    simple to us humans in simple logical steps that a computer can execute can be
    a very tedious, error-prone process.*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些指定加法进位的逻辑电路和[第3章](ch03.xhtml)中的减法算法示例，展示了编程错误的常见来源之一。指定看似非常简单的活动，将其转换为计算机可以执行的简单逻辑步骤，可能是一个非常繁琐且容易出错的过程。*'
- en: 'We arrived at the solution in [Figure 4-6](ch04.xhtml#ch4fig6) by starting
    with the sum of minterms; in other words, we were working with the values of *c[in]*,
    *x*, and *y* that generate a `1` for carry. As you saw in the section “Canonical
    Product or Product of Maxterms” on [page 64](ch04.xhtml#ch04lev2sec4), since carry
    must be either `1` or `0`, it’s equally as valid to start with the values of *c[in]*,
    *x*, and *y* that generate a `0` for the complement of carry and to write the
    equation as a product of maxterms:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_83.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'To simplify this equation, we’ll take the same approach we took with the sum
    of minterms and start by duplicating the last term twice to give:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_84.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Adding some parentheses helps to clarify the simplification process:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_85.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Next, we’ll use the distribution of OR over AND. Because this is tricky, I’ll
    go over the steps to simplify the first grouping of product terms in this equation;
    the steps for the other two groupings are similar to this one. Distribution of
    OR over AND has this generic form:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_86.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'The sum terms in our first grouping share a (¬*x* ∨ ¬*y*), so we’ll make the
    following substitutions into the generic form:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_87.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: 'Making the substitutions and using the complement rule for AND, we get:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_88.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'And applying these same manipulations to the other two groupings, we get:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg98_Image_89.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows the circuit implementation of this function.
    This circuit produces the complement of carry. We would need to complement the
    output, ¬*C[out]*(*c[in]*, *x*, *y*), to get the value of carry.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg99_Image_90.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: A simplified hardware implementation to generate the complement
    of carry when adding two numbers*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If you compare [Figures 4-7](ch04.xhtml#ch4fig7) and [4-6](ch04.xhtml#ch4fig6),
    you can graphically see De Morgan’s law, where the ORs have become ANDs with complemented
    values as inputs. The circuit in [Figure 4-6](ch04.xhtml#ch4fig6) might look simpler
    to you because the circuit in [Figure 4-7](ch04.xhtml#ch4fig7) requires NOT gates
    at the six inputs to the OR gates. But as you will learn in the next chapter,
    this may not be the case because of the inherent electronic properties of the
    devices used to construct logic gates.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The important point to understand here is that there is more than one way to
    solve the problem. One of the jobs of the hardware engineer is to decide which
    solution is best, based on elements such as cost, component availability, and
    so on.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '***Minimization Using Karnaugh Maps***'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The algebraic manipulations used to minimize Boolean functions may not always
    be obvious. You may find it easier to work with a graphic representation of the
    logical statements.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used graphic tool for working with Boolean functions is the *Karnaugh
    map*, also called a *K-map*. The Karnaugh map, invented in 1953 by Maurice Karnaugh,
    a telecommunications engineer at Bell Labs, gives a way to visually find the same
    simplifications you can find algebraically. It can be used either with a sum of
    products, using minterms, or with a product of sums, using maxterms. Here, I illustrate
    how they work, starting with minterms.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的图形工具用于处理布尔函数的是 *卡诺图*，也称为 *K-map*。卡诺图由摩里斯·卡诺（Maurice Karnaugh）于1953年发明，他是贝尔实验室的通信工程师，提供了一种可视化的方式来找到与代数方法相同的简化方式。它可以与乘积和（使用最小项）或和之积（使用最大项）一起使用。这里，我将展示它们的工作原理，从最小项开始。
- en: '**Simplifying Sums of Products Using Karnaugh Maps**'
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用卡诺图简化乘积和之和**'
- en: The Karnaugh map is a rectangular grid with a cell for each minterm. There are
    2*^n* cells for *n* variables. [Figure 4-8](ch04.xhtml#ch4fig8) is a Karnaugh
    map showing all four possible minterms for two variables, *x* and *y*. The vertical
    axis is used to plot *x* and the horizontal axis is used for *y*. The value of
    *x* for each row is shown by the number (`0` or `1`) immediately to the left of
    the row, and the value of *y* for each column appears at the top of the column.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 卡诺图是一个矩形网格，每个最小项对应一个单元格。对于 *n* 个变量，共有 2*^n* 个单元格。[图4-8](ch04.xhtml#ch4fig8)
    是一个显示两个变量 *x* 和 *y* 的所有四个可能最小项的卡诺图。纵轴用于绘制 *x*，横轴用于绘制 *y*。每行的 *x* 值通过紧邻行左侧的数字（`0`
    或 `1`）显示，每列的 *y* 值显示在列顶部。
- en: '![Image](../images/pg100_Image_91.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_91.jpg)'
- en: '*Figure 4-8: The mapping of two-variable minterms on a Karnaugh map*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-8：两变量最小项在卡诺图中的映射*'
- en: 'To illustrate how to use a Karnaugh map, let’s look at an arbitrary function
    of two variables:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用卡诺图，我们来看一个两个变量的任意函数：
- en: '![Image](../images/pg100_Image_92.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_92.jpg)'
- en: Start by placing a `1` in each cell corresponding to a minterm that appears
    in the equation, as shown in [Figure 4-9](ch04.xhtml#ch4fig9).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在与方程中出现的每个最小项对应的单元格中放置`1`，如[图4-9](ch04.xhtml#ch4fig9)所示。
- en: '![Image](../images/pg100_Image_93.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_93.jpg)'
- en: '*Figure 4-9: A Karnaugh map of the arbitrary function* F*(*x, y*)*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-9：任意函数* F*(*x*, *y*) *的卡诺图*'
- en: 'Placing a `1` in the cell corresponding to each minterm that evaluates to `1`
    shows graphically when the equation evaluates to `1`. The two cells on the right-hand
    side correspond to the minterms *m*[1] and *m*[3], (¬*x* ∧ *y*) and (*x* ∧ *y*).
    Since these terms are OR-ed together, *F*(*x*, *y*) evaluates to `1` if either
    of these minterms evaluates to `1`. Using the distributive and complement rules,
    we get the result:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在与每个求值为`1`的最小项对应的单元格中放置`1`，图示了方程何时求值为`1`。右侧的两个单元格对应最小项*m*[1]和*m*[3]，（¬*x* ∧
    *y*）和（*x* ∧ *y*）。由于这些项是按“或”运算组合的，只要其中一个最小项求值为`1`，*F*(*x*, *y*) 就求值为`1`。使用分配律和补充规则，我们得到结果：
- en: '![Image](../images/pg100_Image_94.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg100_Image_94.jpg)'
- en: This shows algebraically that *F*(*x*, *y*) evaluates to `1` whenever *y* is
    `1`, which you’ll see next by simplifying this Karnaugh map.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这在代数上显示，当 *y* 为`1`时，*F*(*x*, *y*) 的值为`1`，接下来通过简化此卡诺图你会看到这一点。
- en: The only difference between the two minterms, (¬*x* ∧ *y*) and (*x* ∧ *y*),
    is the change from *x* to ¬*x*. Karnaugh maps are arranged such that only one
    variable changes between two cells that share an edge, a requirement called the
    *adjacency rule*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最小项（¬*x* ∧ *y*）和（*x* ∧ *y*）之间的唯一区别是从 *x* 变为 ¬*x*。卡诺图的排列方式使得仅有一个变量在共享边的两个单元格之间发生变化，这一要求称为*邻接规则*。
- en: To use a Karnaugh map to perform simplification, you group two adjacent cells
    in a sum of products Karnaugh map that have `1`s in them. Then you eliminate the
    variable that differs between them and coalesce the two product terms. Repeating
    this process allows you to simplify the equation. Each grouping eliminates a product
    term in the final sum of products. This can be extended to equations with more
    than two variables, but the number of cells that are grouped together must be
    a multiple of 2, and you can group only adjacent cells. The adjacency wraps around
    from side to side and from top to bottom. You’ll see an example in [Figure 4-18](ch04.xhtml#ch4fig18)
    on [page 79](ch04.xhtml#page_79).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: To see how all this works, consider the grouping in the Karnaugh map in [Figure
    4-10](ch04.xhtml#ch4fig10).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_95.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Two of the minterms in* F*(*x, y*) grouped*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This grouping is a graphical representation of the algebraic manipulation we
    did earlier, where *F*(*x*, *y*) evaluates to `1` whenever *y* = `1`, regardless
    of the value of *x*. Thus, the grouping coalesces two minterms into one product
    term by eliminating *x*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'From the last grouping, we know our final simplified function will have a *y*
    term. Let’s do another grouping to find the next term. First, we’ll simplify the
    equation algebraically. Returning to the original equation for *F*(*x*, *y*),
    we can use idempotency to duplicate one of the minterms:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_96.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Now, we’ll do some algebraic manipulation on the first product term and the
    one we just added:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_97.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Instead of using algebraic manipulations, we can do this directly on our Karnaugh
    map, as shown in [Figure 4-11](ch04.xhtml#ch4fig11). This map shows that separate
    groups can include the same cell (minterm).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_98.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: A Karnaugh map grouping showing that (*x ∧ ¬y*)* ∨ (¬x ∧ y*)*
    ∨ *(*x ∧ y*) =* x ∨ y'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'The group in the bottom row represents the product term *x* and the one in
    the right-hand column represents *y*, giving us the following minimization:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_99.jpg) Note that the cell that is included
    in both groupings, (*x* ∧ *y*), is the term that we duplicated using the idempotent
    rule in our algebraic solution previously. You can think of including a cell in
    more than one group as adding a duplicate copy of the cell, as we did in our algebraic
    manipulation earlier, and then coalescing it with the other cell(s) in the group,
    thus removing it.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The adjacency rule is automatically satisfied when there are only two variables
    in the function. When we add another variable, we need to think about how to order
    the cells of a Karnaugh map such that we can use the adjacency rule to simplify
    Boolean expressions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordering Cells in a Karnaugh Map**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One of the problems with both the binary and binary coded decimal (BCD) codes
    is that the difference between two adjacent values often involves more than one
    bit being changed. In 1943, Frank Gray introduced a code, the *Gray code*, in
    which adjacent values differ by only one bit. Although encoding values in the
    Gray code complicates arithmetic operations on the values, it simplifies showing
    when the values are adjacent to one another, which shows us how to order the cells
    in a Karnaugh map.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing the Gray code is quite easy. Start with one bit:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: 'To add a bit, first write the mirror image of the existing pattern:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gray code** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `0` |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `1` |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `1` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `0` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: Then, add a `0` to the beginning of each of the original bit patterns and add
    a `1` to the beginning of each of the mirror-image set to give the Gray code for
    two bits, as shown in [Table 4-9](ch04.xhtml#ch4tab9).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-9:** The Gray Code for Two Bits'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| 0 | `00` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| 1 | `01` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| 2 | `11` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| 3 | `10` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: This is the reason the Gray code is sometimes called *reflected binary code
    (RBC)*. [Table 4-10](ch04.xhtml#ch4tab10) shows the Gray code for four bits.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-10:** The Gray Code for Four Bits'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal** | **Gray code** | **Binary** |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '|   0 | `0000` | `0000` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '|   1 | `0001` | `0001` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '|   2 | `0011` | `0010` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '|   3 | `0010` | `0011` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '|   4 | `0110` | `0100` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '|   5 | `0111` | `0101` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '|   6 | `0101` | `0110` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '|   7 | `0100` | `0111` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '|   8 | `1100` | `1000` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '|   9 | `1101` | `1001` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| 10 | `1111` | `1010` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| 11 | `1110` | `1011` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| 12 | `1010` | `1100` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| 13 | `1011` | `1101` |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| 14 | `1001` | `1110` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| 15 | `1000` | `1111` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: Let’s compare the binary codes with the Gray codes for the decimal values 7
    and 8 in [Table 4-10](ch04.xhtml#ch4tab10). The binary codes for 7 and 8 are `0111`
    and `1000`, respectively; all four bits change when stepping only 1 in decimal
    value. But the Gray codes for 7 and 8 are `0100` and `1100`, respectively; only
    one bit changes, thus satisfying the adjacency rule for a Karnaugh map.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the pattern of changing only one bit between adjacent values also
    holds when the bit pattern wraps around. That is, when going from the highest
    value (15 for four bits) to the lowest (0), only one bit is changed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Karnaugh Map for Three Variables**'
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To see how the adjacency property is important, let’s consider a more complicated
    function. We’ll use a Karnaugh map to simplify our function for carry, which has
    three variables. Adding another variable means we need to double the number of
    cells to hold the minterms. To keep the map two-dimensional, we add the new variable
    to an existing variable on one side of the map. We need a total of eight cells
    (2³), so we’ll draw it four cells wide and two cells high. We’ll add *z* to the
    y-axis and draw our Karnaugh map with *y* and *z* on the horizontal axis and *x*
    on the vertical axis, as shown in [Figure 4-12](ch04.xhtml#ch4fig12).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_100.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: The mapping of three-variable minterms on a Karnaugh map*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The order of the bit patterns along the top of the three-variable Karnaugh map
    is `00`, `01`, `11`, `10`, as opposed to `00`, `01`, `10`, `11`, which is the
    Gray code order in [Table 4-9](ch04.xhtml#ch4tab9). The adjacency rule also holds
    when wrapping around the edges of the Karnaugh map—that is, going from *m*[2]
    to *m*[0] or from *m*[6] to *m*[4]—which means that groups can wrap around the
    edges of the map. (Other axis labeling schemes will also work, as you’ll see at
    the end of this section.)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw earlier in this chapter that carry can be expressed as the sum of four
    minterms:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_101.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-13](ch04.xhtml#ch4fig13) shows these four minterms on a Karnaugh
    map.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_102.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: A Karnaugh map of the function for carry*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We look for adjacent cells that can be grouped together to eliminate one variable
    from the product term. As noted, the groups can overlap, giving the three groups
    shown in [Figure 4-14](ch04.xhtml#ch4fig14).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_103.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: A minimum sum of products of the function for carry =* 1'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the three groups in the Karnaugh map in [Figure 4-14](ch04.xhtml#ch4fig14),
    we end up with the same equation we got through algebraic manipulations:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_104.jpg) ##### **Simplifying Products of Sums
    Using Karnaugh Maps**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s equally valid to work with a function that shows when the complement of
    carry is `0`. We did that using maxterms:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_105.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) shows the arrangement of maxterms on a three-variable
    Karnaugh map.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_106.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: The mapping of three-variable maxterms on a Karnaugh map*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: When working with a maxterm statement of the solution, you mark the cells that
    evaluate to `0`. The minimization process is the same as when working with minterms,
    except that you group the cells with `0`s in them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows a minimization of ¬*C[out]*(*c[in]*,
    *x*, *y*), the complement of carry.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_107.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: A minimum product of sums of the function for NOT carry =* 0'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The Karnaugh map in [Figure 4-16](ch04.xhtml#ch4fig16) leads to the same product
    of sums we got algebraically for the complement of carry = `0`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_108.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Comparing [Figures 4-14](ch04.xhtml#ch4fig14) and [4-16](ch04.xhtml#ch4fig16)
    gives a graphic view of De Morgan’s law. When making this comparison, keep in
    mind that [Figure 4-14](ch04.xhtml#ch4fig14) shows the product terms that get
    added and [Figure 4-16](ch04.xhtml#ch4fig16) shows the sum terms that get multiplied,
    and the result is complemented. Thus, we exchange `0` and `1` and exchange AND
    and OR to go from one Karnaugh map to the other.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: To further emphasize the duality of minterms and maxterms, compare [Figures
    4-17(a)](ch04.xhtml#ch4fig17) and [(b)](ch04.xhtml#ch4fig17).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_109.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: A comparison of (a) one minterm and (b) one maxterm*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-17](ch04.xhtml#ch4fig17)(a) shows the function:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_110.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: Although it’s not necessary and usually not done, we have placed a `0` in each
    of the cells representing minterms not included in this function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in [Figure 4-17](ch04.xhtml#ch4fig17)(b), we have placed a `1` in
    each of the cells representing the maxterms that are not included in the function:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_111.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: This comparison shows graphically how a minterm specifies the minimum number
    of `1`s in a Karnaugh map and a maxterm specifies the maximum number of `1`s.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Larger Groupings on a Karnaugh Map**'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thus far, we have grouped only two cells together on our Karnaugh maps. Here,
    I’ll show you an example of larger groups. Consider a function that outputs `1`
    when a 3-bit number is even. [Table 4-11](ch04.xhtml#ch4tab11) shows the truth
    table. It uses `1` to indicate that the number is even and uses `0` to indicate
    odd.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-11:** The Even Values of a 3-Bit Number'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '| **Minterm** | ***x*** | ***y*** | ***z*** | **Number** | ***Even***(***x,
    y, z***) |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| *m*[0] | `0` | `0` | `0` | 0 | `1` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| *m*[1] | `0` | `0` | `1` | 1 | `0` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| *m*[2] | `0` | `1` | `0` | 2 | `1` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| *m*[3] | `0` | `1` | `1` | 3 | `0` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| *m*[4] | `1` | `0` | `0` | 4 | `1` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| *m*[5] | `1` | `0` | `1` | 5 | `0` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| *m*[6] | `1` | `1` | `0` | 6 | `1` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| *m*[7] | `1` | `1` | `1` | 7 | `0` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: 'The canonical sum of products for this function is:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_112.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: '[Figure 4-18](ch04.xhtml#ch4fig18) shows these minterms on a Karnaugh map with
    the four terms grouped together. We can group all four together because they all
    have adjacent edges.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_113.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: A Karnaugh map showing even values of a 3-bit number*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Karnaugh map in [Figure 4-18](ch04.xhtml#ch4fig18), we can write the
    equation for when a 3-bit number is even:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_114.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: The Karnaugh map shows that it does not matter what the values of *x* and *y*
    are, only that *z* = `0`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding More Variables to a Karnaugh Map**'
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each time you add another variable to a Karnaugh map, you will need to double
    the number of cells. The only requirement for the Karnaugh map to work is that
    you arrange the minterms (or maxterms) according to the adjacency rule. [Figure
    4-19](ch04.xhtml#ch4fig19) shows a four-variable Karnaugh map for minterms. The
    *y* and *z* variables are on the horizontal axis, and *w* and *x* are on the vertical
    axis.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_115.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: The mapping of four-variable minterms on a Karnaugh map*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: So far we have assumed that every minterm (or maxterm) is accounted for in our
    functions. But design does not take place in a vacuum. We might have knowledge
    about other components of the overall design telling us that some combinations
    of variable values can never occur. Next, I’ll show you how to take this knowledge
    into account in your function simplification process. The Karnaugh map provides
    an especially clear way to visualize the situation.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**Using “Don’t Care” Cells**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, you have information about the values that the variables can have.
    If you know which combinations of values will never occur, then the minterms (or
    maxterms) that represent those combinations are irrelevant. For example, you may
    want a function that indicates whether one of two possible events has occurred
    or not, but you know that the two events cannot occur simultaneously. Let’s name
    the events *x* and *y* and let `0` indicate that the event has not occurred and
    `1` indicate that it has. [Table 4-12](ch04.xhtml#ch4tab12) shows the truth table
    for our function, *F*(*x*, *y*).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-12:** A Truth Table for *x* or *y* Occurring, but Not Both'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x*** | ***y*** | ***F***(***x, y***) |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | × |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: We can show that both events cannot occur simultaneously by placing an *×* in
    that row. We can draw a Karnaugh map with an *×* for the minterm that can’t exist
    in the system, as shown in [Figure 4-20](ch04.xhtml#ch4fig20). The *×* represents
    a *don’t care* cell; grouping this cell with other cells doesn’t affect the evaluation
    of the function.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_116.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: A Karnaugh map for* F*(*x, y*), showing a “don’t care” cell*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Since the cell that represents the minterm (*x* ∧ *y*) is a “don’t care” cell,
    we can include it, or not, in our minimization groupings, leading to the two groupings
    shown. The Karnaugh map in [Figure 4-20](ch04.xhtml#ch4fig20) leads us to the
    solution
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_117.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: which is a simple OR gate. You probably guessed this solution without having
    to use a Karnaugh map. You’ll see a more interesting use of “don’t care” cells
    when you learn about the design of two digital logic circuits at the end of [Chapter
    7](ch07.xhtml).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Karnaugh maps can be used to minimize only two levels of logic: groups of AND
    gates feeding an OR gate, or groups of OR gates feeding an AND gate. As you’ll
    see in the next several chapters, most logic designs involve more than two levels.
    Karnaugh maps can provide some useful guidelines, but you need to think carefully
    about the overall design. You will see an example of using Karnaugh maps to design
    an adder circuit with three levels of logic in [Chapter 6](ch06.xhtml).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Basic Boolean Operators**'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, we can combine basic Boolean operators
    to implement more complex Boolean operators. Now that you know how to work with
    Boolean functions, we’ll design one of the more common operators, the *exclusive
    or*, often called *XOR*, using the three basic operators, AND, OR, and NOT. It’s
    so commonly used that it has its own circuit symbol. Let’s take a look:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '**XOR**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: XOR is a binary operator. The result is `1` if one, and only one, of the two
    operands is `1`; otherwise, the result is `0`. I’ll use ⊻ to designate the XOR
    operation. It’s also common to use the ⊕ symbol. [Figure 4-21](ch04.xhtml#ch4fig21)
    shows XOR gate operation with inputs *x* and *y*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_118.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: An XOR gate acting on two variables,* x *and* y'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'The minterm implementation of this operation is:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_119.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
- en: The XOR operator can be implemented with two AND gates, two NOT gates, and one
    OR gate, as shown in [Figure 4-22](ch04.xhtml#ch4fig22).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_120.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-22: An XOR gate made from AND, OR, and NOT gates*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, design many more Boolean operators, but we’ll move on in
    the next few chapters to learn how these operators can be implemented in hardware
    using simple on/off switches. As you’ll discover, the idealized minimal solutions
    you’ve learned about in this chapter may not always be the best solutions, due
    to factors such as the inherent electrical characteristics of the switches, multiple
    levels of logic, availability of hardware components, and so forth.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 4.3     Design a function that will detect all the 4-bit integers that are even.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '4.4     Find a minimal sum of products expression for this function:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_121.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: '4.5     Find a minimal product of sums expression for this function:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_122.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: '4.6     The arrangement of the variables for a Karnaugh map is arbitrary, but
    the minterms (or maxterms) need to be consistent with the labeling. Show where
    each minterm is located with this Karnaugh map axis labeling using the notation
    of [Figure 4-12](ch04.xhtml#ch4fig12):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_123.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: '4.7     The arrangement of the variables for a Karnaugh map is arbitrary, but
    the minterms (or maxterms) need to be consistent with the labeling. Show where
    each minterm is located with this Karnaugh map axis labeling using the notation
    of [Figure 4-12](ch04.xhtml#ch4fig12):'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_124.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 4.8     Create a Karnaugh map for five variables. You’ll probably need to review
    the Gray code in [Table 4-10](ch04.xhtml#ch4tab10) and increase it to five bits.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 4.9     Design a logic function that detects the single-digit prime numbers.
    Assume that the numbers are coded in 4-bit BCD (see [Table 2-7](ch02.xhtml#ch2tab7)).
    The function is `1` for each prime number.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Boolean operators**   The three basic Boolean operators are AND, OR, and
    NOT.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**Rules of Boolean algebra**   Boolean algebra provides a mathematical way
    to work with the rules of logic. AND works like multiplication, and OR is similar
    to addition in elementary algebra.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplifying Boolean algebra expressions**   Boolean functions specify the
    functionality of a computer. Simplifying these functions leads to a simpler hardware
    implementation.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '**Karnaugh maps**   These provide a graphical way to simplify Boolean expressions.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**Gray code**   This shows how to order the cells in a Karnaugh map.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining basic Boolean operators**   XOR can be created from AND, OR, and
    NOT operators.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter starts with an introduction to basic electronics that will
    provide a basis for understanding how transistors can be used to implement switches.
    From there, we’ll look at how transistor switches are used to implement logic
    gates.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
