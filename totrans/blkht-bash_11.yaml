- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 NETWORK PROBING AND LATERAL MOVEMENT
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 网络探测与横向移动
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The network or machine to which you initially gain access during a penetration
    test might offer little of value. By moving laterally through a target’s environment,
    you can find crown jewels such as adjacent networks, databases, application servers,
    file-sharing servers, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，你最初获得访问的网络或机器可能提供的价值有限。通过在目标环境中横向移动，你可以发现像相邻网络、数据库、应用服务器、文件共享服务器等珍贵资源。
- en: 'As a penetration tester, you’ll quickly learn that real-life enterprise environments
    emphasize the security of their externally facing assets: those that are exposed
    to the wild and noisy internet. This is because the external perimeter is considered
    to be a greater risk than the internal networks used by trusted users such as
    employees.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你会很快发现，现实中的企业环境更加注重其外部资产的安全性：这些资产暴露在喧嚣且开放的互联网中。这是因为外部边界被认为比内部网络更具风险，后者通常是由受信任的用户（如员工）使用的。
- en: Whereas companies may have only a handful of internet-facing assets, such as
    marketing websites or other web servers, their internal networks are often target
    rich. You may find printers, network switches, employee computers, file servers,
    smart devices, and more once you land on an organization’s internal network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公司可能只有少数面向互联网的资产，如营销网站或其他 Web 服务器，但其内部网络通常资产丰富。一旦进入一个组织的内部网络，你可能会发现打印机、网络交换机、员工计算机、文件服务器、智能设备等。
- en: 'To identify and then access these resources, you can repeat steps we’ve already
    covered: performing reconnaissance, gathering valuable network information, identifying
    and exploiting vulnerabilities, and compromising endpoints connected to the network
    of interest. As such, this chapter will reinforce lessons from earlier in the
    book to scan an internally accessible network and identify additional assets,
    though we’ll highlight a few new techniques.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别并访问这些资源，你可以重复我们已经讨论过的步骤：进行侦察、收集有价值的网络信息、识别和利用漏洞，并攻破连接到感兴趣网络的终端。因此，本章将加强之前章节的教训，扫描一个内部可访问的网络并识别额外的资产，尽管我们会强调一些新的技术。
- en: The examples will target the lab environment’s corporate network (10.1.0.0/24).
    Before continuing, we recommend you take a second look at [Figure 3.2](chapter3.xhtml#fig3-2)
    on [page 58](chapter3.xhtml#pg_58) to refresh your memory regarding the available
    networks in the lab—namely, the public and corporate networks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将针对实验环境中的企业网络（10.1.0.0/24）。在继续之前，我们建议你再查看一下[图 3.2](chapter3.xhtml#fig3-2)（位于[第58页](chapter3.xhtml#pg_58)），以便刷新你对实验室中可用网络的记忆——即公共网络和企业网络。
- en: The machines *p-jumpbox-01* (172.16.10.13) and *p-web-02* (172.16.10.12) are
    the only ones with a leg in both the public and corporate networks. Each machine
    has two network interfaces, allowing them to be part of both networks. As such,
    we’ll perform some of the attacks in this chapter from these machines; we’ll execute
    the others from Kali by using port forwarding.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 机器 *p-jumpbox-01*（172.16.10.13）和 *p-web-02*（172.16.10.12）是唯一同时连接到公共网络和企业网络的机器。每台机器有两个网络接口，使它们能够同时连接两个网络。因此，我们将在本章的一些攻击中使用这些机器来执行；其他攻击则通过
    Kali 使用端口转发来执行。
- en: Probing the Corporate Network
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探测企业网络
- en: We have yet to collect information about the 10.1.0.0/24 corporate network.
    In this section, we’ll build a small port scanner that uses special files to map
    found ports to named services and speed up port scanning by prioritizing ports
    based on how frequently they’re found open in the wild. Internal networks tend
    to host far more assets than a penetration tester might see from the outside,
    so tweaking your processes and tools can help accelerate this asset discovery.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未收集有关 10.1.0.0/24 企业网络的信息。在这一部分中，我们将构建一个小型端口扫描器，它使用特殊的文件将发现的端口映射到命名的服务，并通过根据端口在外部环境中被打开的频率来优先扫描端口，从而加速端口扫描。内部网络往往托管的资产比渗透测试员从外部看到的要多，因此调整你的流程和工具有助于加速资产发现。
- en: We’ll perform a network scan from the *p-jumpbox-01* (172.16.10.13) machine
    by using tools available on the operating system. Note that you could also modify
    and reuse some of the port-scanning and information-gathering scripts used so
    far in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用操作系统上可用的工具，从 *p-jumpbox-01*（172.16.10.13）机器上执行网络扫描。请注意，你也可以修改并重用本书中迄今为止使用的一些端口扫描和信息收集脚本。
- en: Service Mapping
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务映射
- en: 'On Linux, the */etc/services* file maps services to the port numbers assigned
    by the Internet Assigned Numbers Authority. The file contains a few columns separated
    by tabs, such as the service name, the port number and protocol (for example,
    22/tcp), and the description of the service. Here is a snippet of the /*etc/services*
    file from *p-jumpbox-01*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，*/etc/services* 文件将服务映射到由互联网号码分配局（IANA）分配的端口号。该文件包含几个由制表符分隔的列，例如服务名称、端口号和协议（例如，22/tcp），以及服务的描述。以下是来自
    *p-jumpbox-01* 的 /*etc/services* 文件片段：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With grep, we use -w to perform a whole-word match and use -e to look for multiple
    TCP ports. We can use this file to iterate through common ports and identify the
    services they’re likely running. [Listing 11-1](chapter11.xhtml#Lis11-1) is a
    bash script that takes advantage of */etc/services* in this way. It uses Ncat
    installed on *p-jumpbox-01* for the port scanning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 grep 时，我们使用 -w 来执行整词匹配，并使用 -e 查找多个 TCP 端口。我们可以使用此文件迭代常见端口，并识别它们可能运行的服务。[清单
    11-1](chapter11.xhtml#Lis11-1) 是一个 bash 脚本，利用 */etc/services* 以这种方式进行端口扫描。它使用安装在
    *p-jumpbox-01* 上的 Ncat 进行端口扫描。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-1: Performing port scanning by using /etc/services as a database
    file'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-1：使用 /etc/services 作为数据库文件进行端口扫描
- en: At ❶, we define the TARGETS=() array variable, using "$@" inside the parentheses
    to assign any command line arguments passed to the script to this array. We then
    use an if condition to check whether the TARGETS array is empty ❷. If so, we print
    a help message ❸ by using the print_help() function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我们定义了 TARGETS=() 数组变量，使用 "$@" 将传递给脚本的任何命令行参数赋值给此数组。然后，我们使用 if 条件检查 TARGETS
    数组是否为空 ❷。若为空，则使用 print_help() 函数打印帮助信息 ❸。
- en: 'We iterate through the TARGETS array ❹. We also iterate through all the TCP
    ports in */etc/services* by using a while loop ❻, then connect to the target and
    port by using the nc command ❺. If the port is found open, we print the target,
    the port, and the service name mapping from */etc/services*. The script should
    output the following when run against *c-backup-01* (10.1.0.13) and *c-redis-01*
    (10.1.0.14):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历 TARGETS 数组 ❹。我们还通过使用 while 循环 ❻ 遍历 */etc/services* 中的所有 TCP 端口，然后使用 nc
    命令 ❺ 连接到目标和端口。如果端口被发现开放，我们会打印目标、端口和来自 */etc/services* 的服务名称映射。脚本在对 *c-backup-01*（10.1.0.13）和
    *c-redis-01*（10.1.0.14）进行扫描时应输出以下内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we’ve identified a few open ports and their commonly assigned
    service names. For example, we see that the key-value database Redis often uses
    port 6379.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已识别出一些开放端口及其常见的服务名称。例如，我们看到键值数据库 Redis 经常使用端口 6379。
- en: Services can run on alternative ports, however, so you’ll need to fingerprint
    them. To do this for port 6379, pipe a Redis INFO command to the nc command ([Listing
    11-2](chapter11.xhtml#Lis11-2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务可以在备用端口上运行，因此你需要对其进行指纹识别。要对端口 6379 进行指纹识别，请将 Redis INFO 命令通过管道传输到 nc 命令中（[清单
    11-2](chapter11.xhtml#Lis11-2)）。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-2: Fingerprinting the service running on a port'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-2：指纹识别端口上运行的服务
- en: This is a typical response from a Redis server; we’ll return to this service
    in “Compromising a Redis Server” on [page 271](#pg_271). Continue by scanning
    the remaining machines, *c-db-01* (10.1.0.15) and *c-db-02* (10.1.0.16), to identify
    any other ports that are available.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Redis 服务器的典型响应；我们将在《**攻陷 Redis 服务器**》章节中回到此服务，见 [第 271 页](#pg_271)。继续扫描其余机器
    *c-db-01*（10.1.0.15）和 *c-db-02*（10.1.0.16），以识别是否有其他可用端口。
- en: Port Frequencies
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口频率
- en: 'The */etc/services* file offers a simple port-to-service-name mapping, but
    we can improve it. Nmap has a file called *nmap-services* (usually located at
    */usr/share/ nmap/nmap-services*) that looks almost identical to */etc/services*
    but has one advantage: it includes the *port open frequency*, a numerical value
    that describes how often a port is seen open, such as 0.18010\. For instance,
    common network services like HTTP or HTTPS are far more common to see than spooling
    services.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/services* 文件提供了一个简单的端口到服务名称的映射，但我们可以改进它。Nmap 有一个名为 *nmap-services* 的文件（通常位于
    */usr/share/nmap/nmap-services*），它看起来几乎与 */etc/services* 相同，但有一个优势：它包含了 *端口开放频率*，这是一个描述端口被发现打开的频率的数值，例如
    0.18010。举例来说，HTTP 或 HTTPS 等常见网络服务比打印服务更常见。'
- en: 'Let’s take a look at this file. The command in [Listing 11-3](chapter11.xhtml#Lis11-3)
    filters for port 22 (SSH), port 23 (Telnet), port 3306 (MySQL), and port 1433
    (Microsoft SQL). Execute the command on Kali, then observe the frequency values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个文件。[清单 11-3](chapter11.xhtml#Lis11-3) 中的命令过滤了端口 22（SSH）、端口 23（Telnet）、端口
    3306（MySQL）和端口 1433（Microsoft SQL）。在 Kali 上执行该命令，然后观察频率值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-3: Viewing only certain ports in the /etc/services file'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 11-3: 查看*/etc/services*文件中的特定端口'
- en: Telnet (0.221265) is open more frequently than SSH (0.182286), while MySQL (0.045390)
    is open more frequently than Microsoft SQL (0.007929). This frequency data helps
    us prioritize which ports to scan, remove ports that are not commonly seen open,
    and focus on a limited subset of ports while reducing the risk of missing out
    on key services. In Exercise 23, we’ll build a scanner that scans for ports based
    on their open frequency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet (0.221265) 的开放频率比SSH (0.182286) 高，而MySQL (0.045390) 的开放频率比Microsoft SQL
    (0.007929) 高。这些频率数据帮助我们优先考虑要扫描的端口，去除不常见开放的端口，并集中于一小部分端口，从而降低错过关键服务的风险。在练习23中，我们将构建一个基于开放频率扫描端口的扫描器。
- en: Note that while service names are associated with the found ports, those may
    not necessarily reflect the services that are actually running. Files such as
    */etc/services* and *nmap-services* use a static mapping of ports and services,
    so it’s up to us to properly identify the service during a penetration test by
    connecting to each port.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然服务名称与找到的端口关联，但这些端口未必反映实际运行的服务。例如*/etc/services*和*nmap-services*文件使用静态映射端口和服务，因此我们需要通过连接每个端口来正确识别渗透测试中的服务。
- en: We encourage you to perform additional information gathering on these hosts
    by using what you’ve learned so far in the book. Can you identify applications
    or databases that are running, along with their versions? How about the running
    operating system? In the subsequent sections, we’ll exploit some of these services
    to gain access to additional machines and move laterally through the network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您利用书中学到的知识对这些主机进行额外的信息收集。您能否识别正在运行的应用程序或数据库及其版本？正在运行的操作系统又如何？在随后的部分中，我们将利用其中一些服务来访问其他机器并在网络中横向移动。
- en: 'Exercise 23: Scanning Ports Based on Frequencies'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '练习23: 基于频率扫描端口'
- en: 'In this exercise, you’ll perform a similar port scan to the one in [Listing
    11-1](chapter11.xhtml#Lis11-1), except you’ll examine the frequency at which a
    port is found open and prioritize commonly opened ports. Here is what you’ll do,
    at a high level:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将执行类似于[清单 11-1](chapter11.xhtml#Lis11-1)中的端口扫描，但您将检查找到开放端口的频率，并优先考虑常见开放的端口。以下是您将要执行的高层次操作：
- en: 1.  On Kali, extract the services, ports, and their open frequency values from
    the */usr/share/nmap/nmap-services* file. Write them to a new file or integrate
    them into a script.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  在Kali上，从*/usr/share/nmap/nmap-services*文件中提取服务、端口及其开放频率值。将它们写入新文件或集成到脚本中。
- en: 2.  Sort the ports from the highest frequency to the lowest by using commands
    such as sort and awk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用sort和awk等命令将端口按从最高频率到最低频率排序。
- en: 3.  Create a port-scanning script that iterates through the frequency-ordered
    ports and returns the result in some format.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  创建一个端口扫描脚本，通过频率排序的端口进行迭代，并以某种格式返回结果。
- en: You can go about this in various ways, and we encourage you to write the script
    by using your own logic. If you get stuck, try modifying the script in [Listing
    11-1](chapter11.xhtml#Lis11-1). [Listing 11-4](chapter11.xhtml#Lis11-4) shows
    how you might sort the ports in the *nmap-services* file by frequency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种方式来进行这项工作，我们鼓励你根据自己的逻辑编写脚本。如果遇到困难，请尝试修改[清单 11-1](chapter11.xhtml#Lis11-1)中的脚本。[清单
    11-4](chapter11.xhtml#Lis11-4)展示了如何按*nmap-services*文件中端口的频率排序。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-4: Ordering the nmap-services file by frequency'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 11-4: 按频率排序*nmap-services*文件'
- en: We use grep "/tcp" to filter for TCP-based ports only. We then pipe the result
    to the sort command and pass it -r (reverse) -k (key) followed by 3, which represents
    the frequency column (third). We print only the first, second, and third fields,
    using awk for a cleaner output. This gives us an ordered list of ports, which
    will give you an idea of which ports are more common.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用grep "/tcp"仅过滤基于TCP的端口。然后将结果传递给sort命令，并传递-r（逆序）-k（键），后跟3，表示频率列（第三列）。我们使用awk仅打印第一、第二和第三个字段，以获得更清晰的输出。这为我们提供了一个有序的端口列表，让您了解哪些端口更常见。
- en: Now that you have a list, the next step is to either hardcode this list into
    your script and iterate over it or write the content to a file and have the bash
    script iterate over the lines in the file. The direction you choose is ultimately
    up to you. However, hardcoding a large list will make the script hard to read
    unless you shortlist only a handful of ports, so we recommend writing it to a
    dedicated file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个列表，下一步是将此列表硬编码到你的脚本中并对其进行迭代，或者将内容写入文件并让 bash 脚本对文件中的每一行进行迭代。你选择的方向最终取决于你自己。然而，硬编码一个庞大的列表会使脚本难以阅读，除非你只列出少数几个端口，所以我们建议将其写入专用文件。
- en: 'To test your script, copy it to *p-jumpbox-01* (172.16.10.13) and run it against
    the list of targets to identify any services running on the 10.1.0.0/24 corporate
    network. You should see output similar to this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的脚本，将它复制到 *p-jumpbox-01*（172.16.10.13），并对目标列表运行它，以识别 10.1.0.0/24 企业网络上运行的任何服务。你应该看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep in mind that the scan can take a couple of minutes to complete.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，扫描可能需要几分钟才能完成。
- en: Exploiting Cron Scripts on Shared Volumes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用共享卷上的 Cron 脚本
- en: Now that we’ve gathered information about the corporate network, we’ll exploit
    various vulnerable services to gain access to it. Cron jobs may sometimes execute
    scripts that live on volumes shared by multiple machines. If system administrators
    misconfigure their permissions, unauthorized users may be able to modify them,
    which could potentially impact systems that rely on those scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了有关企业网络的信息，我们将利用各种易受攻击的服务来获得对它的访问权限。Cron 作业有时会执行存储在多个机器共享的卷上的脚本。如果系统管理员配置错误了权限，未经授权的用户可能能够修改这些脚本，从而潜在地影响依赖这些脚本的系统。
- en: 'Notice that on *p-web-01* (172.16.10.10) a volume is mounted on */mnt/scripts*.
    You can see it by running the commands mount or df -hTP on the server:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 *p-web-01*（172.16.10.10）上挂载了一个卷在 */mnt/scripts* 下。你可以通过在服务器上运行 mount 或 df
    -hTP 命令来查看它：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside this directory is a script called *execute.sh* that the *root* user owns
    and can write to. [Listing 11-5](chapter11.xhtml#Lis11-5) shows its contents.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录下有一个名为 *execute.sh* 的脚本，由 *root* 用户拥有并可以写入。[列表 11-5](chapter11.xhtml#Lis11-5)
    显示了它的内容。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-5: The /mnt/scripts/execute.sh file'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11-5: /mnt/scripts/execute.sh 文件'
- en: The comment in the script indicates that it is executed on the machine *c-backup-01*
    (10.1.0.13) every minute. We can infer that the network share and this script
    are both available on *c-backup-01*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的注释表明它每分钟在 *c-backup-01*（10.1.0.13）机器上执行。我们可以推断，网络共享和这个脚本都在 *c-backup-01*
    上可用。
- en: Let’s dissect what this script does. At ❶, the variable LOG is set to the filepath
    */tmp/job.log*. At ❷, an if condition checks the exit status of find. The find
    command searches for any files under the */tmp* directory that are not named *job.log*;
    the exclamation point (!) is a NOT operator in this case. If the find command
    finds any such files, -exec rm -rf {} + is executed, removing these files from
    the system. At ❸, an echo command writes the removed files into the logfile set
    up at ❶.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这个脚本的功能。在 ❶ 处，变量 LOG 被设置为文件路径 */tmp/job.log*。在 ❷ 处，if 条件检查 find 命令的退出状态。find
    命令搜索 */tmp* 目录下所有不叫 *job.log* 的文件；在这种情况下，感叹号（!）是一个“非”操作符。如果 find 命令找到任何此类文件，则执行
    -exec rm -rf {} + 命令，删除这些文件。在 ❸ 处，echo 命令将被删除的文件写入在 ❶ 处设置的日志文件中。
- en: 'This entire script is essentially a directory cleanup tool that empties the
    */tmp* directory every minute by using a cron job running on *c-backup-01*. Because
    this bash script exists on a volume mounted on two machines, one of which we have
    root access on, we can try to modify it to get *c-backup-01* to run our custom
    instructions. There’s one challenge, however: while the volume is shared with
    both *p-web-01* and *c-backup-01*, these machines aren’t on the same network.
    [Figure 11-1](chapter11.xhtml#fig11-1) illustrates how the machines are connected.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的脚本本质上是一个目录清理工具，每分钟通过在 *c-backup-01* 上运行的 cron 作业清空 */tmp* 目录。由于这个 bash
    脚本存在于一个挂载在两台机器上的卷中，其中一台我们有 root 权限，我们可以尝试修改它，让 *c-backup-01* 执行我们的自定义指令。然而有一个挑战：虽然该卷与
    *p-web-01* 和 *c-backup-01* 共享，但这两台机器不在同一网络中。[图 11-1](chapter11.xhtml#fig11-1)
    说明了这些机器是如何连接的。
- en: '![](../images/pg264.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg264.jpg)'
- en: 'Figure 11-1: The indirect network access between p-web-01 and c-backup-01'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-1: p-web-01 和 c-backup-01 之间的间接网络访问'
- en: While *p-web-01* does not have direct access to the corporate network, *p-web-02*
    does. This means we’ll modify the *execute.sh* script from *p-web-01* but try
    to interact with *c-backup-01* via *p-web-02*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*p-web-01*没有直接访问公司网络的权限，但*p-web-02*有。这意味着我们将修改*p-web-01*中的*execute.sh*脚本，但尝试通过*p-web-02*与*c-backup-01*进行交互。
- en: Verifying Exploitability
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证可利用性
- en: 'To verify whether *c-backup-01* is in fact executing the *execute.sh* script,
    we need it to emit a signal. This signal could be a network packet sent to a listener
    we open; alternatively, we could force *c-backup-01* to create a file in the shared
    drive. Let’s try this. On *p-web-01* (172.16.10.10), add the following line to
    the end of */mnt/script/execute.sh*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证*c-backup-01*是否确实在执行*execute.sh*脚本，我们需要让它发出一个信号。这个信号可以是发送到我们打开的监听器的网络数据包；或者，我们可以强制*c-backup-01*在共享驱动器中创建一个文件。让我们试试这个。在*p-web-01*（172.16.10.10）上，将以下行添加到*/mnt/script/execute.sh*的末尾：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the script claims to run every minute, we need to monitor the file-creation
    event so we can see it before the file is deleted. We can do so using the watch
    command. [Listing 11-6](chapter11.xhtml#Lis11-6) will run the ls -l command and
    refresh the output every two seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本声称每分钟运行一次，我们需要监视文件创建事件，以便在文件被删除之前看到它。我们可以使用watch命令来做到这一点。[列表 11-6](chapter11.xhtml#Lis11-6)将运行ls
    -l命令，并每两秒刷新一次输出。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-6: Using the watch command to monitor file changes'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：使用watch命令监控文件变化
- en: As you can see, the *c-backup-01.acme-infinity-servers.com.txt* file appears,
    indicating that *c-backup-01* is in fact executing this script.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*c-backup-01.acme-infinity-servers.com.txt*文件出现，表明*c-backup-01*确实在执行这个脚本。
- en: Checking the User Context
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查用户上下文
- en: 'Cron jobs can be run by dedicated users, but in certain cases, they may run
    as the *root* user. This could happen out of convenience or may be a security
    oversight. To verify the user context with which the script is running, we can
    add commands to the file to capture the hostname, the identity of the user running
    the cron job, and the list of all the processes running on the system:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Cron作业可以由专用用户运行，但在某些情况下，它们可能会以*root*用户身份运行。这可能出于方便，或者是安全疏忽。为了验证脚本运行的用户上下文，我们可以在文件中添加命令，以捕获主机名、运行cron作业的用户身份以及系统上运行的所有进程列表：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Repeat the watch command from [Listing 11-4](chapter11.xhtml#Lis11-4) to see
    the new content written into the file. Once content is written, run cat to see
    the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重复[列表 11-4](chapter11.xhtml#Lis11-4)中的watch命令，查看写入文件的新内容。一旦写入内容，运行cat命令查看结果：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The script is running as root. This means we have full command execution ability
    under the root context. From here, we can do pretty much anything, such as viewing
    files owned by the *root* user, like */etc/shadow*; writing custom files into
    key system directories; copying files to a remote server; and adding users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本以root身份运行。这意味着我们在root上下文下拥有完全的命令执行能力。从这里开始，我们几乎可以做任何事情，例如查看由*root*用户拥有的文件，如*/etc/shadow*；在关键系统目录中写入自定义文件；将文件复制到远程服务器；以及添加用户。
- en: 'Exercise 24: Gaining a Reverse Shell on the Backup Server'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 24：在备份服务器上获取反向Shell
- en: While the vulnerability in the cron job script discovered in the previous section
    gives us an unlimited ability to execute commands on *c-backup-01* (10.1.0.13),
    we don’t yet have a shell on the server. Let’s get one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上一节中发现的cron作业脚本漏洞赋予了我们在*c-backup-01*（10.1.0.13）上无限执行命令的能力，但我们还没有在服务器上获得shell。让我们获取一个。
- en: 'No machine on the corporate network has internet access. You’ll have to find
    another way to transfer any additional tools you may need to complete a full compromise
    over the corporate network. How to establish the reverse shell is ultimately up
    to you, but here is high-level guidance you can follow:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 公司网络上的机器没有互联网访问权限。你需要找到其他方式来传输你可能需要的任何额外工具，以完成对公司网络的完全入侵。如何建立反向shell最终取决于你，但这里有一些高级指导，你可以遵循：
- en: 1.  Open a shell listener on a machine you have access to that can access the
    corporate network, such as *p-web-02* (172.16.10.12).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你有权限并能够访问公司网络的机器上打开一个shell监听器，例如*p-web-02*（172.16.10.12）。
- en: 2.  If the tools to establish a reverse shell listener aren’t available, make
    them available from another remote location, such as by running a web server on
    your main Kali machine containing the necessary tools.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果没有可用的工具来建立反向shell监听器，可以从另一个远程位置获取这些工具，例如通过在你的主Kali机器上运行一个包含必要工具的Web服务器。
- en: 3.  Modify the vulnerable *execute.sh* script described in the previous section
    to send a shell over the network to the listener.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  修改前一节描述的易受攻击的*execute.sh*脚本，将Shell发送到侦听器的网络。
- en: 4.  Verify that you have shell access as the *root* user.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  验证您是否以*root*用户身份具有Shell访问权限。
- en: Exploiting a Database Server
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用数据库服务器
- en: 'Earlier in this chapter, we identified a potential MySQL service on *c-db-02*
    (10.1.0.16). We can verify whether this is indeed a database by probing the port.
    Run the following command from *p-jumpbox-01* (172.16.10.13) to learn about the
    service:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候，我们在*c-db-02*（10.1.0.16）上识别出一个可能的MySQL服务。我们可以通过探测端口来验证这是否确实是一个数据库。从*p-jumpbox-01*（172.16.10.13）运行以下命令来了解这项服务：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The database on *c-backup-01* is a MariaDB server. It uses TCP port 3306, similarly
    to MySQL. Accessing a database’s management console requires a username and sometimes
    a password, if set by an administrator. In this section, we’ll attempt to brute-force
    the database to gain remote access to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*c-backup-01*上的数据库是MariaDB服务器。它使用TCP端口3306，类似于MySQL。访问数据库管理控制台需要用户名，有时还需要管理员设置的密码。在本节中，我们将尝试暴力破解数据库，以获得对其的远程访问权限。'
- en: Port Forwarding
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口转发
- en: Although both *p-jumpbox-01* and *p-web-02* are connected to the corporate network,
    neither has an installed database client we could use to connect with. To get
    around this, we can use port forwarding and the tools available on Kali to brute-force
    the database. We’ll establish a local port forward from the Kali machine by using
    an intermediate jump host, *p-jumpbox-01* (172.16.10.13).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*p-jumpbox-01*和*p-web-02*都连接到企业网络，但两者都没有我们可以用来连接的安装的数据库客户端。为了解决这个问题，我们可以使用端口转发和Kali上可用的工具来暴力破解数据库。我们将通过使用中间跳转主机*p-jumpbox-01*（172.16.10.13）在Kali机器上建立本地端口转发。
- en: We can perform the port forwarding by using the command in [Listing 11-7](chapter11.xhtml#Lis11-7).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[列表11-7](chapter11.xhtml#Lis11-7)中的命令执行端口转发。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-7: Port forwarding with SSH'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-7：使用SSH进行端口转发
- en: This command uses local port forwarding (-L) and the syntax local_port:remote_ip:remote_port,
    followed by the intermediate host through which the forwarding will be done. After
    executing this command, you’ll be prompted to enter the password for the backup
    user on *p-jumpbox-01*. As a reminder, the password is *backup*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用本地端口转发（-L）和语法local_port:remote_ip:remote_port，接着是将通过的中间主机进行的转发。执行此命令后，将提示您输入*p-jumpbox-01*上备份用户的密码。作为提醒，密码是*backup*。
- en: 'Once the command successfully executes, Kali will start listening locally on
    port 3306\. Verify that port 3306 is listening by using the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令成功执行，Kali将开始在本地监听3306端口。使用以下命令验证3306端口是否在监听：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Any traffic destined to 127.0.0.1:3306 on Kali will be sent to *c-db-02* (10.1.0.16)
    on port 3306 via the intermediate host *p-jumpbox-01*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kali上发送到127.0.0.1:3306的任何流量将通过中间主机*p-jumpbox-01*转发到*c-db-02*（10.1.0.16）的3306端口。
- en: Brute-Forcing with Medusa
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Medusa进行暴力破解
- en: 'Now that we can run attacks from Kali, we can use a preinstalled tool such
    as Medusa to brute-force the database. The following command uses Medusa’s *mysql*
    module, which works against MariaDB servers, to achieve the task:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从Kali运行攻击，可以使用预安装的工具如Medusa来暴力破解数据库。以下命令使用Medusa的*mysql*模块，在MariaDB服务器上执行任务：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use the medusa command with the arguments -h (host), -u (user), -P (password
    file), and -M (module), specifying the 127.0.0.1 host, the root user, the password
    file */usr/share/metasploit-framework/data/wordlists/unix_users.txt*, and *mysql*.
    Medusa will brute-force the root account by using a list of passwords from the
    *unix_users.txt* file. Let Medusa run for a few minutes until it finds the password:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用medusa命令和参数-h（主机）、-u（用户）、-P（密码文件）和-M（模块），指定127.0.0.1主机、root用户、密码文件*/usr/share/metasploit-framework/data/wordlists/unix_users.txt*和*mysql*。Medusa将使用*unix_users.txt*文件中的密码列表来暴力破解root帐户。让Medusa运行几分钟，直到找到密码：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Great, Medusa found that the password for the *root* user is *root*. Let’s
    try to connect to the database. From Kali, run the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，Medusa找到了*root*用户的密码是*root*。让我们尝试连接数据库。从Kali运行以下命令：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, enumerate the available databases by using the show databases command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过使用show databases命令枚举可用数据库：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we’ve found a WordPress database. Let’s connect some dots:
    this *c-db-02* server is probably the backend database of the WordPress instance
    running on *p-web-02*. Recall that this database wasn’t available to us when we
    performed penetration testing against the public network in earlier chapters.
    Let’s now try to use it for further exploitation.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们找到了一个WordPress数据库。让我们连接一些点：这个*c-db-02*服务器可能是运行在*p-web-02*上的WordPress实例的后台数据库。回想一下，在之前章节中我们进行公共网络渗透测试时，这个数据库是无法访问的。现在我们尝试使用它进行进一步的利用。
- en: Backdooring WordPress
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向植入WordPress
- en: Now that we have access to a WordPress database as the *root* user, we can alter
    the database and introduce our own WordPress user. This will allow us to log in
    to the WordPress administration page and control the blog platform entirely. The
    administration page is located at *http://172.16.10.12/wp-admin*, as shown in
    [Figure 11-2](chapter11.xhtml#fig11-2).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以*root*用户身份访问WordPress数据库，可以修改数据库并添加我们自己的WordPress用户。这将使我们能够登录到WordPress管理页面，并完全控制博客平台。管理页面位于*http://172.16.10.12/wp-admin*，如[图11-2](chapter11.xhtml#fig11-2)所示。
- en: '![](../images/pg268.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg268.jpg)'
- en: 'Figure 11-2: The WordPress administrator portal'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：WordPress管理员门户
- en: 'To add a user, we need to insert three database rows into two tables—namely,
    wp_users and wp_usermeta. From within the MariaDB console, run the following command
    to switch into the wordpress database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加用户，我们需要向两个表（即wp_users和wp_usermeta）插入三行数据库记录。在MariaDB控制台中，运行以下命令切换到wordpress数据库：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, run three INSERT INTO SQL commands to add new rows and create the user.
    The first command inserts a new user named *jane*, with the password *bash*, along
    with some metadata:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行三条INSERT INTO SQL命令来添加新记录并创建用户。第一条命令插入一个名为*jane*的新用户，密码为*bash*，并附带一些元数据：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second and third commands set the user’s permissions to that of an administrator:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条和第三条命令将用户的权限设置为管理员权限：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As these commands are quite verbose, you can also copy them from *add _wordpress_admin.sql*
    in the [Chapter 11](chapter11.xhtml) folder of this book’s GitHub repository.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些命令比较冗长，你也可以从本书GitHub仓库中的[第11章](chapter11.xhtml)文件夹内的*add_wordpress_admin.sql*文件中复制它们。
- en: After executing the three INSERT INTO SQL commands, you should now be able to
    navigate to *http://172.16.10.12/wp-admin* and log in as the user *jane* with
    the password *bash*. You should see the WordPress administration panel, as shown
    in [Figure 11-3](chapter11.xhtml#fig11-3).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这三条INSERT INTO SQL命令后，你现在应该能够访问*http://172.16.10.12/wp-admin*并以用户*jane*身份登录，密码为*bash*。你应该能看到WordPress管理面板，如[图11-3](chapter11.xhtml#fig11-3)所示。
- en: '![](../images/pg270.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg270.jpg)'
- en: 'Figure 11-3: The WordPress panel after authentication'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：身份验证后的WordPress面板
- en: WordPress admin pages allow the modification of WordPress content files, such
    as HTML and PHP files, from within its interface. They also let you install plug-ins
    and themes, manage users, change settings related to the platform, and more.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress管理员页面允许从其界面内修改WordPress内容文件，例如HTML和PHP文件。它们还允许你安装插件和主题，管理用户，更改与平台相关的设置等。
- en: Running SQL Commands with Bash
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bash运行SQL命令
- en: It’s worth noting that you can run SQL commands from within a bash script by
    using a heredoc (introduced in [Chapter 1](chapter1.xhtml)). [Listing 11-8](chapter11.xhtml#Lis11-8)
    provides an example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以通过在bash脚本中使用heredoc（在[第1章](chapter1.xhtml)中介绍）来运行SQL命令。[列表11-8](chapter11.xhtml#Lis11-8)提供了一个示例。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-8: Running SQL commands in a bash script'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-8：在bash脚本中运行SQL命令
- en: We set a few variables containing database connection information such as the
    host, user, and name. We then use the mysql command (which works for MariaDB servers)
    and pass these variables to the command. Using a heredoc (<<), we define a list
    of SQL commands as input to the mysql command. The two EOF delimiter strings signal
    the beginning and end of the command within the heredoc. Once you enter this command,
    you’ll be prompted to enter the password you discovered through the brute-force
    attack in “Brute-Forcing with Medusa” on [page 267](#pg_267).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了几个包含数据库连接信息的变量，例如主机、用户和数据库名。然后我们使用mysql命令（适用于MariaDB服务器）并将这些变量传递给命令。通过使用heredoc（<<），我们将一系列SQL命令定义为mysql命令的输入。两个EOF分隔符字符串标志着heredoc中命令的开始和结束。一旦你输入此命令，系统会提示你输入通过“使用Medusa进行暴力破解”章节中[第267页](#pg_267)发现的密码。
- en: 'Exercise 25: Executing Shell Commands via WordPress'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 练习25：通过WordPress执行Shell命令
- en: 'In the previous section, you gained access to a WordPress admin page. Can you
    find a way to execute shell commands on the host that is serving the blog platform?
    You can achieve this in various ways. Here are some examples:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您已经访问了WordPress管理页面。您能找到在托管博客平台的主机上执行Shell命令的方法吗？您可以通过多种方式实现这一目标。以下是一些示例：
- en: Modify the PHP file of a theme through the WordPress Editor by adding a PHP-based
    web shell to its source code.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WordPress编辑器修改主题的PHP文件，向其源代码添加基于PHP的Web shell。
- en: Upload a custom plug-in that will compromise the underlying system.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传一个自定义插件，将危及底层系统。
- en: Install a plug-in from the WordPress.com Marketplace that offers the execution
    of shell commands as a feature.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从WordPress.com Marketplace安装一个插件，该插件提供执行Shell命令的功能。
- en: Once you’re able to execute shell commands, establish a reverse shell by using
    one of the methods you’ve learned so far.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您能够执行Shell命令，请使用您已学习的方法之一建立一个反向Shell。
- en: Compromising a Redis Server
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 妥协Redis服务器
- en: Earlier in this chapter, we identified a Redis server running on the *c-redis-01*
    machine (10.1.0.14). Redis is a fast key-value database commonly used in software
    architecture for purposes such as caching. It’s often deployed without security
    protections such as passwords or ACLs that limit the commands clients can run
    on the database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们确认了运行在 *c-redis-01* 机器 (10.1.0.14) 上的Redis服务器。Redis是一种快速的键值数据库，通常在软件架构中用于缓存等目的。它经常部署时没有密码或ACL等安全保护，限制客户端在数据库上执行的命令。
- en: We already know that the Redis server we’ve discovered isn’t password protected.
    When protected by passwords, Redis servers won’t allow unauthenticated clients
    to execute commands without supplying the correct password, and the INFO command
    we sent to the server for fingerprinting purposes wouldn’t have worked.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们发现的Redis服务器没有密码保护。当Redis服务器受密码保护时，未经身份验证的客户端将无法在不提供正确密码的情况下执行命令，我们用于指纹识别目的的INFO命令也无法工作。
- en: 'Some versions of Redis are vulnerable to a trick that lets you write arbitrary
    files to the system by abusing its CONFIG SET command. Malware dubbed *Kinsing*
    has used this technique to compromise internet-facing Redis servers. The attack
    works as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 某些版本的Redis对一种技巧是有漏洞的，它可以通过滥用其CONFIG SET命令向系统写入任意文件。名为 *Kinsing* 的恶意软件就利用了这种技术来妥协面向互联网的Redis服务器。攻击步骤如下：
- en: 1.  Connect to an unprotected Redis server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  连接到一个未受保护的Redis服务器。
- en: 2.  Issue the CONFIG SET dir command to set the Redis configuration file’s directory
    path.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  发出CONFIG SET dir命令设置Redis配置文件的目录路径。
- en: 3.  Issue a subsequent CONFIG SET dbfilename command to set the name of the
    configuration file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  接着发出CONFIG SET dbfilename命令设置配置文件的名称。
- en: 4.  Write arbitrary malicious content into the file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  向文件中写入任意恶意内容。
- en: 5.  Issue a SAVE command to save the contents.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  发出SAVE命令保存内容。
- en: 'In this section, we’ll compromise Redis by using two methods: sending it raw
    Redis commands and using a Metasploit auxiliary module. Our goal is to add a backdoor
    SSH key on *c-redis-01*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两种方法来妥协Redis：发送原始Redis命令和使用Metasploit辅助模块。我们的目标是在 *c-redis-01* 上添加一个后门SSH密钥。
- en: Raw CLI Commands
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始CLI命令
- en: 'As when exploiting the MariaDB database, we’ll establish a local port forward
    by using SSH to send traffic destined for *c-redis-01* through an intermediate
    host. This lets us make use of Kali’s tools. Run the following command on Kali
    to open port 6379 locally. We’ll tunnel the traffic via *p-jumpbox-01* (172.16.10.13)
    to *c-redis-01* (10.1.0.14) on port 6379:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像利用MariaDB数据库一样，我们将通过SSH建立本地端口转发，将流向 *c-redis-01* 的流量通过中间主机发送。这样我们就可以使用Kali的工具。在Kali上运行以下命令以在本地打开6379端口。我们将通过
    *p-jumpbox-01* (172.16.10.13) 隧道传输流量到 *c-redis-01* (10.1.0.14) 的6379端口：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s verify that port 6379 is listening locally on Kali:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下Kali本地是否监听6379端口：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, run the redis-cli command on Kali to open a Redis console and send instructions
    to the Redis server:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Kali上运行redis-cli命令打开Redis控制台，并向Redis服务器发送指令：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’ll run the CONFIG SET dir Redis command to set the directory in which to
    write our public key on the Redis server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行 CONFIG SET dir Redis 命令，在Redis服务器上设置写入公钥的目录：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We set dbfilename to authorized_keys. This will ensure that the final path
    where content will be written is */root/.ssh/authorized_keys*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将dbfilename设置为authorized_keys。这将确保内容最终写入的路径是 */root/.ssh/authorized_keys*：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we’ll set a key (k1) by using SET followed by the public SSH key. Note
    that there are two newlines (\n\n) at the beginning and end of the public-key
    string so that the authorized_keys file format doesn’t get mangled:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 SET 设置一个键（k1），后跟公钥。请注意，在公钥字符串的开头和结尾有两个换行符（\n\n），以确保 authorized_keys
    文件格式不会被损坏：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, save the content by using the SAVE command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 SAVE 命令保存内容：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you don’t currently have an SSH key pair set up in Kali, run ssh-keygen -t
    rsa and follow the wizard to generate one. The public key will be available at
    */home/kali/.ssh/id_rsa.pub*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你当前在 Kali 中没有设置 SSH 密钥对，请运行 ssh-keygen -t rsa 并按照向导生成一个。公钥将位于 */home/kali/.ssh/id_rsa.pub*。
- en: 'Now we’ll try to SSH into the *c-redis-01* server with the private key. We
    need to perform one more port forward so we can tunnel this SSH traffic via the
    jump host. We’ll listen locally on port 2222 and send traffic on port 22:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试使用私钥 SSH 进入 *c-redis-01* 服务器。我们需要执行一次端口转发，以便通过跳板主机隧道化这个 SSH 流量。我们将在本地监听
    2222 端口，并将流量转发到 22 端口：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Verify that port 2222 is listening locally on Kali:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 Kali 上是否有 2222 端口在本地监听：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now run an SSH client to connect to 10.1.0.14:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行一个 SSH 客户端连接到 10.1.0.14：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! We’ve gained root SSH access to *c-redis-01* by using some Redis tricks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们通过一些 Redis 技巧成功获得了 *c-redis-01* 的 root SSH 访问权限。
- en: Metasploit
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metasploit
- en: We can compromise Redis in a similar manner by using a Metasploit auxiliary
    module. *Metasploit* is a penetration-testing, vulnerability assessment, and exploitation
    platform written in the Ruby language and founded by H.D. Moore. It can perform
    many tasks, including deploying payloads.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Metasploit 辅助模块以类似的方式攻破 Redis。*Metasploit* 是一个渗透测试、漏洞评估和利用平台，使用 Ruby
    语言编写，由 H.D. Moore 创建。它可以执行许多任务，包括部署有效载荷。
- en: 'In this section, we’ll use Metasploit to exploit the Redis vulnerability. This
    should give you exposure to Metasploit and show you alternative exploitation methods.
    On Kali, start Metasploit by running the msfconsole command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Metasploit 利用 Redis 漏洞。这将使你接触到 Metasploit，并展示其他的利用方法。在 Kali 上，通过运行
    msfconsole 命令启动 Metasploit：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, use the Redis *file_upload* auxiliary module by running the use command
    followed by the path to the module:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过运行 use 命令并指定模块路径来使用 Redis *file_upload* 辅助模块：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The module requires a few options; run show options to see them:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块需要一些选项；运行 show options 以查看它们：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’ve bolded the options you’ll need to set. The LocalFile option should point
    to the filepath containing the public key; RHOSTS should point to 127.0.0.1, where
    we’ve set up a local port forward; and RemoteFile should point to the remote filepath
    where LocalFile should be uploaded:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将你需要设置的选项加粗。LocalFile 选项应指向包含公钥的文件路径；RHOSTS 应指向 127.0.0.1，我们已在此设置了本地端口转发；RemoteFile
    应指向远程文件路径，LocalFile 应上传到该路径：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, run the exploit with the run command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 run 命令运行利用程序：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that the public key is in the root user’s *authorized_keys* file on *c-redis-01*,
    we can SSH into it through the local 2222 port, as we did earlier:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于公钥已经存储在 *c-redis-01* 上 root 用户的 *authorized_keys* 文件中，我们可以像之前一样通过本地 2222
    端口 SSH 进入该主机：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using key-based authentication, we now have persistent root access to the Redis
    machine. Having root access will allow you to freely explore this machine and
    everything that it contains.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于密钥的认证，我们现在对 Redis 主机拥有持久的 root 访问权限。拥有 root 权限将允许你自由地探索这台机器及其包含的所有内容。
- en: Exposed Database Files
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露的数据库文件
- en: Web servers such as Apache and nginx can be configured to serve web files from
    only specific directories or to serve only very specific file extensions, such
    as.*html* or.*php*. However, you may sometimes run into web applications that
    read from or write to files located in the same directory as the main web application.
    These could include configuration files (such as *.conf*, *.env*, and *.ini* files),
    simple database files such as SQLite, or even files containing credentials.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Apache 和 nginx 这样的 Web 服务器可以配置为仅从特定目录提供 Web 文件，或仅提供非常特定的文件扩展名，如.*html* 或 .*php*。然而，你有时可能会遇到从与主
    Web 应用程序相同目录中读取或写入文件的 Web 应用程序。这些文件可能包括配置文件（如 *.conf*、*.env* 和 *.ini* 文件）、简单的数据库文件如
    SQLite，甚至包含凭据的文件。
- en: When applications are programmed in this way, they risk exposing these sensitive
    files to unauthorized users. Clients able to guess filenames on the web server
    may encounter downloadable files that could contain sensitive information about
    the application or the underlying server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序以这种方式编程时，它们有风险将这些敏感文件暴露给未经授权的用户。能够猜测 Web 服务器上文件名的客户端可能会遇到可下载的文件，这些文件可能包含有关应用程序或底层服务器的敏感信息。
- en: 'We have one more target to compromise: the *c-db-01* machine (10.1.0.15). If
    you scan this host, you’ll see that only port 80 (HTTP) is open, indicating that
    it is running a web server. Let’s start a local port forward so we can run some
    scanning tools from Kali. We’ll listen on port 8888 locally and use port 80 as
    the target:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个目标可以攻击：*c-db-01* 机器（10.1.0.15）。如果你扫描这个主机，你会发现只有端口 80（HTTP）是开放的，表明它正在运行一个
    Web 服务器。让我们启动一个本地端口转发，以便我们可以从 Kali 运行一些扫描工具。我们将在本地监听端口 8888，并将端口 80 作为目标使用：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Verify that port 8888 is open by using netstat:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 netstat 验证端口 8888 是否打开：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we’ll use dirsearch to search the website for any interesting pages or
    files. Be sure to run it for a few minutes so it can iterate through its database
    of possible web paths:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 dirsearch 在网站上搜索任何有趣的页面或文件。确保运行几分钟，以便它可以遍历可能的 Web 路径数据库：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, some pages returned HTTP response code 403 Forbidden, while
    a few returned 200 OK (namely, *adminer.php*, *database.sql*, *index.html*, and
    *uploads*).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一些页面返回了 HTTP 响应代码 403 Forbidden，而少数页面返回了 200 OK（即 *adminer.php*，*database.sql*，*index.html*
    和 *uploads*）。
- en: Open your local browser in Kali and navigate to *http://localhost:8888/adminer.php*
    to see what comes up. You should see a page similar to [Figure 11-4](chapter11.xhtml#fig11-4).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 中打开你的本地浏览器，并导航至 *http://localhost:8888/adminer.php* 看看会出现什么。你应该看到一个类似于
    [图 11-4](chapter11.xhtml#fig11-4) 的页面。
- en: '![](../images/pg276.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg276.jpg)'
- en: 'Figure 11-4: The adminer.php page'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：adminer.php 页面
- en: '*Adminer* is a database management tool that lives in a single, self- contained
    PHP file. It’s a lightweight alternative to database management tools such as
    phpMyAdmin and allows you to query databases, export and import table data, create
    new databases, and more.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*Adminer* 是一个数据库管理工具，它存在于单个、自包含的 PHP 文件中。它是诸如 phpMyAdmin 等数据库管理工具的轻量级替代品，允许你查询数据库，导出和导入表数据，创建新数据库等。'
- en: 'The *adminer.php* page presents a login form, and we don’t have credentials
    for logging in. However, the dirsearch results include a file named *database.sql*
    that we have yet to explore. Let’s download this file by using the curl -o argument,
    which writes the response output to a file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*adminer.php* 页面呈现了一个登录表单，我们没有登录的凭据。然而，dirsearch 的结果包括一个名为 *database.sql* 的文件，我们尚未探索。让我们使用
    curl -o 参数下载这个文件，该参数将响应输出写入文件中：'
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Open this file in a text editor in Kali or simply run cat on it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 中的文本编辑器中打开这个文件或者简单地运行 cat 命令：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This file contains SQL commands. Let’s break down what it does. First, it creates
    a database named *adminer_db* if one does not already exist ❶. It then creates
    a user named *adminer_user* if one does not already exist, with a password set
    to *P@ssword321* ❷. Permissions to all databases and tables are granted to the
    *adminer_user* user ❸.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含 SQL 命令。让我们分解一下它的作用。首先，如果不存在，则创建一个名为 *adminer_db* 的数据库 ❶。然后，如果不存在，则创建一个名为
    *adminer_user* 的用户，并将密码设置为 *P@ssword321* ❷。向 *adminer_user* 用户授予对所有数据库和表的权限 ❸。
- en: This script essentially sets up a database. Is it possible that the same password
    included in the file might grant us access to the Adminer panel? Let’s find out.
    Open *http://localhost:8888/adminer.php* in Kali’s browser and enter in the username
    and password fields **adminer_user** and **P@ssword321**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本本质上是设置一个数据库。文件中包含的相同密码是否可能让我们访问 Adminer 面板？让我们找出来。在 Kali 的浏览器中打开 *http://localhost:8888/adminer.php*
    并在用户名和密码字段中输入 **adminer_user** 和 **P@ssword321**。
- en: Success! We’ve logged in to Adminer. You should see various databases, such
    as *adminer_db*, *customers*, *sys*, and *mysql*. In the next sections, we’ll
    use Adminer to dump database table data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经登录到了 Adminer。你应该看到各种数据库，比如 *adminer_db*，*customers*，*sys* 和 *mysql*。在接下来的部分中，我们将使用
    Adminer 来导出数据库表数据。
- en: Dumping Sensitive Information
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泄露敏感信息
- en: We’ll use Adminer’s SQL interface to send SQL commands and export information
    from the tables in the *customers* database. Explore the tables that exist in
    the database by selecting **Customers** from the list ([Figure 11-5](chapter11.xhtml#fig11-5)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Adminer 的 SQL 接口来发送 SQL 命令，并从 *customers* 数据库中导出信息。通过从列表中选择 **Customers**
    来探索数据库中存在的表格（见 [图 11-5](chapter11.xhtml#fig11-5)）。
- en: '![](../images/pg277.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg277.jpg)'
- en: 'Figure 11-5: Tables in the customers database'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：客户数据库中的表
- en: 'The database has two tables: *acme_hyper_branding* and *acme_impact _alliance*.
    Let’s run a few commands by using the SQL Command page in Adminer, found in the
    top-left menu:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库有两个表：*acme_hyper_branding* 和 *acme_impact_alliance*。让我们在 Adminer 中使用 SQL
    命令页面运行几个命令，该页面位于左上角菜单：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you run these commands, two tables should appear that contain PII for two
    companies, including first names, last names, designations, emails, and cleartext
    credentials. Save this information to CSV or SQL by clicking **Export**, then
    choose a file format and click **Export** again. [Listing 11-9](chapter11.xhtml#Lis11-9)
    shows what a CSV export of the *acme_hyper_branding* table looks like.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这些命令时，应该会出现包含两个公司的个人身份信息（PII）的两张表，信息包括名字、姓氏、职位、电子邮件和明文凭证。通过点击 **导出**，将这些信息保存为
    CSV 或 SQL 格式，再次点击 **导出** 进行导出。[列表 11-9](chapter11.xhtml#Lis11-9) 显示了 *acme_hyper_branding*
    表的 CSV 导出内容。
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 11-9: Table data containing sensitive information'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-9：包含敏感信息的表数据
- en: While we’ve accessed customer information, we haven’t yet completely compromised
    the database server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经访问了客户信息，但还没有完全破坏数据库服务器。
- en: Uploading a Web Shell with SQL
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SQL 上传 Web Shell
- en: Can we upload a web shell by using SQL commands? MySQL has an INTO OUTFILE statement
    that writes results to an output file. Using a SELECT statement with INTO OUTFILE,
    we could try to write arbitrary contents to the database server’s filesystem.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能通过 SQL 命令上传 Web Shell 吗？MySQL 有一个 INTO OUTFILE 语句，可以将查询结果写入输出文件。通过使用带有 INTO
    OUTFILE 的 SELECT 语句，我们可以尝试将任意内容写入数据库服务器的文件系统。
- en: To be able to upload a web shell or write a file to the system, we first need
    to know whether the destination path we’re trying to write to exists on the system
    in the first place. The user account running the application must also have permission
    to write to the path.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够上传 Web Shell 或将文件写入系统，我们首先需要知道我们尝试写入的目标路径是否存在于系统中。运行该应用程序的用户账户也必须具有写入该路径的权限。
- en: 'Let’s run a few test commands in the **SQL Command** section in Adminer to
    see if we can write to the system. The following SQL command attempts to add content
    to a file named *file_write.txt*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Adminer 中的 **SQL 命令** 部分运行几个测试命令，看看我们是否能够写入系统。以下 SQL 命令尝试将内容添加到名为 *file_write.txt*
    的文件中：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The execution succeeds, as indicated by the Query executed OK, 1 row affected
    response message, but we don’t know where this file exists on the filesystem.
    If we try browsing to *http://localhost:8888/file_write1.txt*, we get a 404 Not
    Found error. This means the file wasn’t saved in the web root directory, but somewhere
    else that we can’t browse to.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成功，响应信息显示查询执行成功，受影响的行数为 1，但我们不知道这个文件在文件系统中的位置。如果我们尝试浏览 *http://localhost:8888/file_write1.txt*，会得到
    404 未找到错误。这意味着文件没有保存在 Web 根目录，而是保存在我们无法访问的其他地方。
- en: 'Can we identify the filesystem path from which the site is served? Common web
    root paths include directories such as */var/www*or */var/www/html*. Run the following
    command to write the file into the */var/www/html* directory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能识别出提供网站的文件系统路径吗？常见的 Web 根目录路径包括 */var/www* 或 */var/www/html*。运行以下命令将文件写入
    */var/www/html* 目录：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time, we get a permission-denied error, as indicated by the message Error
    in query (1): can''t create/write to file, which means that the path exists but
    that the user executing the command on our behalf doesn’t have write access to
    it.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们收到了权限拒绝错误，错误信息为查询中的错误 (1)：无法创建/写入文件，这意味着路径存在，但代我们执行命令的用户没有写入权限。
- en: 'Our dirsearch scan detected an *uploads* directory. Perhaps we can write to
    it? Let’s find out:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 dirsearch 扫描检测到了一个 *uploads* 目录。也许我们可以向其中写入文件？让我们试试看：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Browse to *http://localhost:8888/uploads/file_write3.txt*; you should see the
    *test_write3* text, which indicates that we were able to write a file to the *uploads*
    directory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到 *http://localhost:8888/uploads/file_write3.txt*；你应该能看到 *test_write3* 文本，这表明我们成功地将文件写入了
    *uploads* 目录。
- en: 'Now we need to write something that gives us the ability to execute commands.
    We can use a PHP web shell for this. Run the following commands to write a PHP
    web shell into the *uploads* directory:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要写一些代码，使我们能够执行命令。我们可以使用 PHP Web Shell 来实现这一点。运行以下命令将 PHP Web Shell 写入 *uploads*
    目录：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, run curl to check whether we can execute commands by using the web
    shell:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行 curl 来检查我们是否能够通过 Web Shell 执行命令：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Success! We’re able to run system commands in the context of the *www-data*
    user. Before moving on, try establishing a reverse shell by using what you’ve
    learned so far in the book.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们能够在*www-data*用户的上下文中运行系统命令。在继续之前，尝试利用你目前在书中学到的内容建立一个反向Shell。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we improved our port scanning by using a frequency-enriched
    database of ports and identified possible access paths to additional assets on
    the corporate network. While moving laterally, we exploited scripts hosted on
    shared drives, breached unprotected databases, backdoored a WordPress instance,
    accessed a database administration panel through a leaked SQL file, performed
    Redis configuration tweaks, and uploaded a web shell by using SQL commands.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用一个富含频率的端口数据库来改进了我们的端口扫描，并识别了可能的访问路径，以便访问公司网络中的额外资源。在横向移动的过程中，我们利用托管在共享驱动器上的脚本，攻破了未受保护的数据库，给WordPress实例植入后门，通过泄露的SQL文件访问了数据库管理面板，进行了Redis配置调整，并通过SQL命令上传了Web
    Shell。
