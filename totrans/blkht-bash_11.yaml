- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 11 NETWORK PROBING AND LATERAL MOVEMENT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The network or machine to which you initially gain access during a penetration
    test might offer little of value. By moving laterally through a target’s environment,
    you can find crown jewels such as adjacent networks, databases, application servers,
    file-sharing servers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a penetration tester, you’ll quickly learn that real-life enterprise environments
    emphasize the security of their externally facing assets: those that are exposed
    to the wild and noisy internet. This is because the external perimeter is considered
    to be a greater risk than the internal networks used by trusted users such as
    employees.'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas companies may have only a handful of internet-facing assets, such as
    marketing websites or other web servers, their internal networks are often target
    rich. You may find printers, network switches, employee computers, file servers,
    smart devices, and more once you land on an organization’s internal network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify and then access these resources, you can repeat steps we’ve already
    covered: performing reconnaissance, gathering valuable network information, identifying
    and exploiting vulnerabilities, and compromising endpoints connected to the network
    of interest. As such, this chapter will reinforce lessons from earlier in the
    book to scan an internally accessible network and identify additional assets,
    though we’ll highlight a few new techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: The examples will target the lab environment’s corporate network (10.1.0.0/24).
    Before continuing, we recommend you take a second look at [Figure 3.2](chapter3.xhtml#fig3-2)
    on [page 58](chapter3.xhtml#pg_58) to refresh your memory regarding the available
    networks in the lab—namely, the public and corporate networks.
  prefs: []
  type: TYPE_NORMAL
- en: The machines *p-jumpbox-01* (172.16.10.13) and *p-web-02* (172.16.10.12) are
    the only ones with a leg in both the public and corporate networks. Each machine
    has two network interfaces, allowing them to be part of both networks. As such,
    we’ll perform some of the attacks in this chapter from these machines; we’ll execute
    the others from Kali by using port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Probing the Corporate Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have yet to collect information about the 10.1.0.0/24 corporate network.
    In this section, we’ll build a small port scanner that uses special files to map
    found ports to named services and speed up port scanning by prioritizing ports
    based on how frequently they’re found open in the wild. Internal networks tend
    to host far more assets than a penetration tester might see from the outside,
    so tweaking your processes and tools can help accelerate this asset discovery.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll perform a network scan from the *p-jumpbox-01* (172.16.10.13) machine
    by using tools available on the operating system. Note that you could also modify
    and reuse some of the port-scanning and information-gathering scripts used so
    far in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Service Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Linux, the */etc/services* file maps services to the port numbers assigned
    by the Internet Assigned Numbers Authority. The file contains a few columns separated
    by tabs, such as the service name, the port number and protocol (for example,
    22/tcp), and the description of the service. Here is a snippet of the /*etc/services*
    file from *p-jumpbox-01*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With grep, we use -w to perform a whole-word match and use -e to look for multiple
    TCP ports. We can use this file to iterate through common ports and identify the
    services they’re likely running. [Listing 11-1](chapter11.xhtml#Lis11-1) is a
    bash script that takes advantage of */etc/services* in this way. It uses Ncat
    installed on *p-jumpbox-01* for the port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: Performing port scanning by using /etc/services as a database
    file'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶, we define the TARGETS=() array variable, using "$@" inside the parentheses
    to assign any command line arguments passed to the script to this array. We then
    use an if condition to check whether the TARGETS array is empty ❷. If so, we print
    a help message ❸ by using the print_help() function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We iterate through the TARGETS array ❹. We also iterate through all the TCP
    ports in */etc/services* by using a while loop ❻, then connect to the target and
    port by using the nc command ❺. If the port is found open, we print the target,
    the port, and the service name mapping from */etc/services*. The script should
    output the following when run against *c-backup-01* (10.1.0.13) and *c-redis-01*
    (10.1.0.14):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve identified a few open ports and their commonly assigned
    service names. For example, we see that the key-value database Redis often uses
    port 6379.
  prefs: []
  type: TYPE_NORMAL
- en: Services can run on alternative ports, however, so you’ll need to fingerprint
    them. To do this for port 6379, pipe a Redis INFO command to the nc command ([Listing
    11-2](chapter11.xhtml#Lis11-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Fingerprinting the service running on a port'
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical response from a Redis server; we’ll return to this service
    in “Compromising a Redis Server” on [page 271](#pg_271). Continue by scanning
    the remaining machines, *c-db-01* (10.1.0.15) and *c-db-02* (10.1.0.16), to identify
    any other ports that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Port Frequencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The */etc/services* file offers a simple port-to-service-name mapping, but
    we can improve it. Nmap has a file called *nmap-services* (usually located at
    */usr/share/ nmap/nmap-services*) that looks almost identical to */etc/services*
    but has one advantage: it includes the *port open frequency*, a numerical value
    that describes how often a port is seen open, such as 0.18010\. For instance,
    common network services like HTTP or HTTPS are far more common to see than spooling
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this file. The command in [Listing 11-3](chapter11.xhtml#Lis11-3)
    filters for port 22 (SSH), port 23 (Telnet), port 3306 (MySQL), and port 1433
    (Microsoft SQL). Execute the command on Kali, then observe the frequency values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: Viewing only certain ports in the /etc/services file'
  prefs: []
  type: TYPE_NORMAL
- en: Telnet (0.221265) is open more frequently than SSH (0.182286), while MySQL (0.045390)
    is open more frequently than Microsoft SQL (0.007929). This frequency data helps
    us prioritize which ports to scan, remove ports that are not commonly seen open,
    and focus on a limited subset of ports while reducing the risk of missing out
    on key services. In Exercise 23, we’ll build a scanner that scans for ports based
    on their open frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while service names are associated with the found ports, those may
    not necessarily reflect the services that are actually running. Files such as
    */etc/services* and *nmap-services* use a static mapping of ports and services,
    so it’s up to us to properly identify the service during a penetration test by
    connecting to each port.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to perform additional information gathering on these hosts
    by using what you’ve learned so far in the book. Can you identify applications
    or databases that are running, along with their versions? How about the running
    operating system? In the subsequent sections, we’ll exploit some of these services
    to gain access to additional machines and move laterally through the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Scanning Ports Based on Frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll perform a similar port scan to the one in [Listing
    11-1](chapter11.xhtml#Lis11-1), except you’ll examine the frequency at which a
    port is found open and prioritize commonly opened ports. Here is what you’ll do,
    at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  On Kali, extract the services, ports, and their open frequency values from
    the */usr/share/nmap/nmap-services* file. Write them to a new file or integrate
    them into a script.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Sort the ports from the highest frequency to the lowest by using commands
    such as sort and awk.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Create a port-scanning script that iterates through the frequency-ordered
    ports and returns the result in some format.
  prefs: []
  type: TYPE_NORMAL
- en: You can go about this in various ways, and we encourage you to write the script
    by using your own logic. If you get stuck, try modifying the script in [Listing
    11-1](chapter11.xhtml#Lis11-1). [Listing 11-4](chapter11.xhtml#Lis11-4) shows
    how you might sort the ports in the *nmap-services* file by frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: Ordering the nmap-services file by frequency'
  prefs: []
  type: TYPE_NORMAL
- en: We use grep "/tcp" to filter for TCP-based ports only. We then pipe the result
    to the sort command and pass it -r (reverse) -k (key) followed by 3, which represents
    the frequency column (third). We print only the first, second, and third fields,
    using awk for a cleaner output. This gives us an ordered list of ports, which
    will give you an idea of which ports are more common.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a list, the next step is to either hardcode this list into
    your script and iterate over it or write the content to a file and have the bash
    script iterate over the lines in the file. The direction you choose is ultimately
    up to you. However, hardcoding a large list will make the script hard to read
    unless you shortlist only a handful of ports, so we recommend writing it to a
    dedicated file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your script, copy it to *p-jumpbox-01* (172.16.10.13) and run it against
    the list of targets to identify any services running on the 10.1.0.0/24 corporate
    network. You should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the scan can take a couple of minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Cron Scripts on Shared Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve gathered information about the corporate network, we’ll exploit
    various vulnerable services to gain access to it. Cron jobs may sometimes execute
    scripts that live on volumes shared by multiple machines. If system administrators
    misconfigure their permissions, unauthorized users may be able to modify them,
    which could potentially impact systems that rely on those scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that on *p-web-01* (172.16.10.10) a volume is mounted on */mnt/scripts*.
    You can see it by running the commands mount or df -hTP on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inside this directory is a script called *execute.sh* that the *root* user owns
    and can write to. [Listing 11-5](chapter11.xhtml#Lis11-5) shows its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: The /mnt/scripts/execute.sh file'
  prefs: []
  type: TYPE_NORMAL
- en: The comment in the script indicates that it is executed on the machine *c-backup-01*
    (10.1.0.13) every minute. We can infer that the network share and this script
    are both available on *c-backup-01*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dissect what this script does. At ❶, the variable LOG is set to the filepath
    */tmp/job.log*. At ❷, an if condition checks the exit status of find. The find
    command searches for any files under the */tmp* directory that are not named *job.log*;
    the exclamation point (!) is a NOT operator in this case. If the find command
    finds any such files, -exec rm -rf {} + is executed, removing these files from
    the system. At ❸, an echo command writes the removed files into the logfile set
    up at ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'This entire script is essentially a directory cleanup tool that empties the
    */tmp* directory every minute by using a cron job running on *c-backup-01*. Because
    this bash script exists on a volume mounted on two machines, one of which we have
    root access on, we can try to modify it to get *c-backup-01* to run our custom
    instructions. There’s one challenge, however: while the volume is shared with
    both *p-web-01* and *c-backup-01*, these machines aren’t on the same network.
    [Figure 11-1](chapter11.xhtml#fig11-1) illustrates how the machines are connected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: The indirect network access between p-web-01 and c-backup-01'
  prefs: []
  type: TYPE_NORMAL
- en: While *p-web-01* does not have direct access to the corporate network, *p-web-02*
    does. This means we’ll modify the *execute.sh* script from *p-web-01* but try
    to interact with *c-backup-01* via *p-web-02*.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Exploitability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To verify whether *c-backup-01* is in fact executing the *execute.sh* script,
    we need it to emit a signal. This signal could be a network packet sent to a listener
    we open; alternatively, we could force *c-backup-01* to create a file in the shared
    drive. Let’s try this. On *p-web-01* (172.16.10.10), add the following line to
    the end of */mnt/script/execute.sh*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since the script claims to run every minute, we need to monitor the file-creation
    event so we can see it before the file is deleted. We can do so using the watch
    command. [Listing 11-6](chapter11.xhtml#Lis11-6) will run the ls -l command and
    refresh the output every two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: Using the watch command to monitor file changes'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the *c-backup-01.acme-infinity-servers.com.txt* file appears,
    indicating that *c-backup-01* is in fact executing this script.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the User Context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cron jobs can be run by dedicated users, but in certain cases, they may run
    as the *root* user. This could happen out of convenience or may be a security
    oversight. To verify the user context with which the script is running, we can
    add commands to the file to capture the hostname, the identity of the user running
    the cron job, and the list of all the processes running on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the watch command from [Listing 11-4](chapter11.xhtml#Lis11-4) to see
    the new content written into the file. Once content is written, run cat to see
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The script is running as root. This means we have full command execution ability
    under the root context. From here, we can do pretty much anything, such as viewing
    files owned by the *root* user, like */etc/shadow*; writing custom files into
    key system directories; copying files to a remote server; and adding users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 24: Gaining a Reverse Shell on the Backup Server'
  prefs: []
  type: TYPE_NORMAL
- en: While the vulnerability in the cron job script discovered in the previous section
    gives us an unlimited ability to execute commands on *c-backup-01* (10.1.0.13),
    we don’t yet have a shell on the server. Let’s get one.
  prefs: []
  type: TYPE_NORMAL
- en: 'No machine on the corporate network has internet access. You’ll have to find
    another way to transfer any additional tools you may need to complete a full compromise
    over the corporate network. How to establish the reverse shell is ultimately up
    to you, but here is high-level guidance you can follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Open a shell listener on a machine you have access to that can access the
    corporate network, such as *p-web-02* (172.16.10.12).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  If the tools to establish a reverse shell listener aren’t available, make
    them available from another remote location, such as by running a web server on
    your main Kali machine containing the necessary tools.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Modify the vulnerable *execute.sh* script described in the previous section
    to send a shell over the network to the listener.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Verify that you have shell access as the *root* user.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a Database Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we identified a potential MySQL service on *c-db-02*
    (10.1.0.16). We can verify whether this is indeed a database by probing the port.
    Run the following command from *p-jumpbox-01* (172.16.10.13) to learn about the
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The database on *c-backup-01* is a MariaDB server. It uses TCP port 3306, similarly
    to MySQL. Accessing a database’s management console requires a username and sometimes
    a password, if set by an administrator. In this section, we’ll attempt to brute-force
    the database to gain remote access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Port Forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although both *p-jumpbox-01* and *p-web-02* are connected to the corporate network,
    neither has an installed database client we could use to connect with. To get
    around this, we can use port forwarding and the tools available on Kali to brute-force
    the database. We’ll establish a local port forward from the Kali machine by using
    an intermediate jump host, *p-jumpbox-01* (172.16.10.13).
  prefs: []
  type: TYPE_NORMAL
- en: We can perform the port forwarding by using the command in [Listing 11-7](chapter11.xhtml#Lis11-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-7: Port forwarding with SSH'
  prefs: []
  type: TYPE_NORMAL
- en: This command uses local port forwarding (-L) and the syntax local_port:remote_ip:remote_port,
    followed by the intermediate host through which the forwarding will be done. After
    executing this command, you’ll be prompted to enter the password for the backup
    user on *p-jumpbox-01*. As a reminder, the password is *backup*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command successfully executes, Kali will start listening locally on
    port 3306\. Verify that port 3306 is listening by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Any traffic destined to 127.0.0.1:3306 on Kali will be sent to *c-db-02* (10.1.0.16)
    on port 3306 via the intermediate host *p-jumpbox-01*.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing with Medusa
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can run attacks from Kali, we can use a preinstalled tool such
    as Medusa to brute-force the database. The following command uses Medusa’s *mysql*
    module, which works against MariaDB servers, to achieve the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the medusa command with the arguments -h (host), -u (user), -P (password
    file), and -M (module), specifying the 127.0.0.1 host, the root user, the password
    file */usr/share/metasploit-framework/data/wordlists/unix_users.txt*, and *mysql*.
    Medusa will brute-force the root account by using a list of passwords from the
    *unix_users.txt* file. Let Medusa run for a few minutes until it finds the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, Medusa found that the password for the *root* user is *root*. Let’s
    try to connect to the database. From Kali, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enumerate the available databases by using the show databases command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we’ve found a WordPress database. Let’s connect some dots:
    this *c-db-02* server is probably the backend database of the WordPress instance
    running on *p-web-02*. Recall that this database wasn’t available to us when we
    performed penetration testing against the public network in earlier chapters.
    Let’s now try to use it for further exploitation.'
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring WordPress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have access to a WordPress database as the *root* user, we can alter
    the database and introduce our own WordPress user. This will allow us to log in
    to the WordPress administration page and control the blog platform entirely. The
    administration page is located at *http://172.16.10.12/wp-admin*, as shown in
    [Figure 11-2](chapter11.xhtml#fig11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: The WordPress administrator portal'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a user, we need to insert three database rows into two tables—namely,
    wp_users and wp_usermeta. From within the MariaDB console, run the following command
    to switch into the wordpress database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run three INSERT INTO SQL commands to add new rows and create the user.
    The first command inserts a new user named *jane*, with the password *bash*, along
    with some metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The second and third commands set the user’s permissions to that of an administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As these commands are quite verbose, you can also copy them from *add _wordpress_admin.sql*
    in the [Chapter 11](chapter11.xhtml) folder of this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the three INSERT INTO SQL commands, you should now be able to
    navigate to *http://172.16.10.12/wp-admin* and log in as the user *jane* with
    the password *bash*. You should see the WordPress administration panel, as shown
    in [Figure 11-3](chapter11.xhtml#fig11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: The WordPress panel after authentication'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress admin pages allow the modification of WordPress content files, such
    as HTML and PHP files, from within its interface. They also let you install plug-ins
    and themes, manage users, change settings related to the platform, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL Commands with Bash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s worth noting that you can run SQL commands from within a bash script by
    using a heredoc (introduced in [Chapter 1](chapter1.xhtml)). [Listing 11-8](chapter11.xhtml#Lis11-8)
    provides an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-8: Running SQL commands in a bash script'
  prefs: []
  type: TYPE_NORMAL
- en: We set a few variables containing database connection information such as the
    host, user, and name. We then use the mysql command (which works for MariaDB servers)
    and pass these variables to the command. Using a heredoc (<<), we define a list
    of SQL commands as input to the mysql command. The two EOF delimiter strings signal
    the beginning and end of the command within the heredoc. Once you enter this command,
    you’ll be prompted to enter the password you discovered through the brute-force
    attack in “Brute-Forcing with Medusa” on [page 267](#pg_267).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 25: Executing Shell Commands via WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you gained access to a WordPress admin page. Can you
    find a way to execute shell commands on the host that is serving the blog platform?
    You can achieve this in various ways. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the PHP file of a theme through the WordPress Editor by adding a PHP-based
    web shell to its source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload a custom plug-in that will compromise the underlying system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install a plug-in from the WordPress.com Marketplace that offers the execution
    of shell commands as a feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re able to execute shell commands, establish a reverse shell by using
    one of the methods you’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Compromising a Redis Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we identified a Redis server running on the *c-redis-01*
    machine (10.1.0.14). Redis is a fast key-value database commonly used in software
    architecture for purposes such as caching. It’s often deployed without security
    protections such as passwords or ACLs that limit the commands clients can run
    on the database.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the Redis server we’ve discovered isn’t password protected.
    When protected by passwords, Redis servers won’t allow unauthenticated clients
    to execute commands without supplying the correct password, and the INFO command
    we sent to the server for fingerprinting purposes wouldn’t have worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some versions of Redis are vulnerable to a trick that lets you write arbitrary
    files to the system by abusing its CONFIG SET command. Malware dubbed *Kinsing*
    has used this technique to compromise internet-facing Redis servers. The attack
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Connect to an unprotected Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Issue the CONFIG SET dir command to set the Redis configuration file’s directory
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Issue a subsequent CONFIG SET dbfilename command to set the name of the
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Write arbitrary malicious content into the file.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Issue a SAVE command to save the contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll compromise Redis by using two methods: sending it raw
    Redis commands and using a Metasploit auxiliary module. Our goal is to add a backdoor
    SSH key on *c-redis-01*.'
  prefs: []
  type: TYPE_NORMAL
- en: Raw CLI Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As when exploiting the MariaDB database, we’ll establish a local port forward
    by using SSH to send traffic destined for *c-redis-01* through an intermediate
    host. This lets us make use of Kali’s tools. Run the following command on Kali
    to open port 6379 locally. We’ll tunnel the traffic via *p-jumpbox-01* (172.16.10.13)
    to *c-redis-01* (10.1.0.14) on port 6379:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify that port 6379 is listening locally on Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the redis-cli command on Kali to open a Redis console and send instructions
    to the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll run the CONFIG SET dir Redis command to set the directory in which to
    write our public key on the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We set dbfilename to authorized_keys. This will ensure that the final path
    where content will be written is */root/.ssh/authorized_keys*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll set a key (k1) by using SET followed by the public SSH key. Note
    that there are two newlines (\n\n) at the beginning and end of the public-key
    string so that the authorized_keys file format doesn’t get mangled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, save the content by using the SAVE command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t currently have an SSH key pair set up in Kali, run ssh-keygen -t
    rsa and follow the wizard to generate one. The public key will be available at
    */home/kali/.ssh/id_rsa.pub*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll try to SSH into the *c-redis-01* server with the private key. We
    need to perform one more port forward so we can tunnel this SSH traffic via the
    jump host. We’ll listen locally on port 2222 and send traffic on port 22:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that port 2222 is listening locally on Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run an SSH client to connect to 10.1.0.14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Great! We’ve gained root SSH access to *c-redis-01* by using some Redis tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can compromise Redis in a similar manner by using a Metasploit auxiliary
    module. *Metasploit* is a penetration-testing, vulnerability assessment, and exploitation
    platform written in the Ruby language and founded by H.D. Moore. It can perform
    many tasks, including deploying payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll use Metasploit to exploit the Redis vulnerability. This
    should give you exposure to Metasploit and show you alternative exploitation methods.
    On Kali, start Metasploit by running the msfconsole command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the Redis *file_upload* auxiliary module by running the use command
    followed by the path to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The module requires a few options; run show options to see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve bolded the options you’ll need to set. The LocalFile option should point
    to the filepath containing the public key; RHOSTS should point to 127.0.0.1, where
    we’ve set up a local port forward; and RemoteFile should point to the remote filepath
    where LocalFile should be uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the exploit with the run command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the public key is in the root user’s *authorized_keys* file on *c-redis-01*,
    we can SSH into it through the local 2222 port, as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using key-based authentication, we now have persistent root access to the Redis
    machine. Having root access will allow you to freely explore this machine and
    everything that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Exposed Database Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web servers such as Apache and nginx can be configured to serve web files from
    only specific directories or to serve only very specific file extensions, such
    as.*html* or.*php*. However, you may sometimes run into web applications that
    read from or write to files located in the same directory as the main web application.
    These could include configuration files (such as *.conf*, *.env*, and *.ini* files),
    simple database files such as SQLite, or even files containing credentials.
  prefs: []
  type: TYPE_NORMAL
- en: When applications are programmed in this way, they risk exposing these sensitive
    files to unauthorized users. Clients able to guess filenames on the web server
    may encounter downloadable files that could contain sensitive information about
    the application or the underlying server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more target to compromise: the *c-db-01* machine (10.1.0.15). If
    you scan this host, you’ll see that only port 80 (HTTP) is open, indicating that
    it is running a web server. Let’s start a local port forward so we can run some
    scanning tools from Kali. We’ll listen on port 8888 locally and use port 80 as
    the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that port 8888 is open by using netstat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll use dirsearch to search the website for any interesting pages or
    files. Be sure to run it for a few minutes so it can iterate through its database
    of possible web paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, some pages returned HTTP response code 403 Forbidden, while
    a few returned 200 OK (namely, *adminer.php*, *database.sql*, *index.html*, and
    *uploads*).
  prefs: []
  type: TYPE_NORMAL
- en: Open your local browser in Kali and navigate to *http://localhost:8888/adminer.php*
    to see what comes up. You should see a page similar to [Figure 11-4](chapter11.xhtml#fig11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The adminer.php page'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adminer* is a database management tool that lives in a single, self- contained
    PHP file. It’s a lightweight alternative to database management tools such as
    phpMyAdmin and allows you to query databases, export and import table data, create
    new databases, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *adminer.php* page presents a login form, and we don’t have credentials
    for logging in. However, the dirsearch results include a file named *database.sql*
    that we have yet to explore. Let’s download this file by using the curl -o argument,
    which writes the response output to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this file in a text editor in Kali or simply run cat on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This file contains SQL commands. Let’s break down what it does. First, it creates
    a database named *adminer_db* if one does not already exist ❶. It then creates
    a user named *adminer_user* if one does not already exist, with a password set
    to *P@ssword321* ❷. Permissions to all databases and tables are granted to the
    *adminer_user* user ❸.
  prefs: []
  type: TYPE_NORMAL
- en: This script essentially sets up a database. Is it possible that the same password
    included in the file might grant us access to the Adminer panel? Let’s find out.
    Open *http://localhost:8888/adminer.php* in Kali’s browser and enter in the username
    and password fields **adminer_user** and **P@ssword321**.
  prefs: []
  type: TYPE_NORMAL
- en: Success! We’ve logged in to Adminer. You should see various databases, such
    as *adminer_db*, *customers*, *sys*, and *mysql*. In the next sections, we’ll
    use Adminer to dump database table data.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping Sensitive Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use Adminer’s SQL interface to send SQL commands and export information
    from the tables in the *customers* database. Explore the tables that exist in
    the database by selecting **Customers** from the list ([Figure 11-5](chapter11.xhtml#fig11-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Tables in the customers database'
  prefs: []
  type: TYPE_NORMAL
- en: 'The database has two tables: *acme_hyper_branding* and *acme_impact _alliance*.
    Let’s run a few commands by using the SQL Command page in Adminer, found in the
    top-left menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you run these commands, two tables should appear that contain PII for two
    companies, including first names, last names, designations, emails, and cleartext
    credentials. Save this information to CSV or SQL by clicking **Export**, then
    choose a file format and click **Export** again. [Listing 11-9](chapter11.xhtml#Lis11-9)
    shows what a CSV export of the *acme_hyper_branding* table looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-9: Table data containing sensitive information'
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve accessed customer information, we haven’t yet completely compromised
    the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a Web Shell with SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Can we upload a web shell by using SQL commands? MySQL has an INTO OUTFILE statement
    that writes results to an output file. Using a SELECT statement with INTO OUTFILE,
    we could try to write arbitrary contents to the database server’s filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to upload a web shell or write a file to the system, we first need
    to know whether the destination path we’re trying to write to exists on the system
    in the first place. The user account running the application must also have permission
    to write to the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a few test commands in the **SQL Command** section in Adminer to
    see if we can write to the system. The following SQL command attempts to add content
    to a file named *file_write.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The execution succeeds, as indicated by the Query executed OK, 1 row affected
    response message, but we don’t know where this file exists on the filesystem.
    If we try browsing to *http://localhost:8888/file_write1.txt*, we get a 404 Not
    Found error. This means the file wasn’t saved in the web root directory, but somewhere
    else that we can’t browse to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we identify the filesystem path from which the site is served? Common web
    root paths include directories such as */var/www*or */var/www/html*. Run the following
    command to write the file into the */var/www/html* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we get a permission-denied error, as indicated by the message Error
    in query (1): can''t create/write to file, which means that the path exists but
    that the user executing the command on our behalf doesn’t have write access to
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our dirsearch scan detected an *uploads* directory. Perhaps we can write to
    it? Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Browse to *http://localhost:8888/uploads/file_write3.txt*; you should see the
    *test_write3* text, which indicates that we were able to write a file to the *uploads*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to write something that gives us the ability to execute commands.
    We can use a PHP web shell for this. Run the following commands to write a PHP
    web shell into the *uploads* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run curl to check whether we can execute commands by using the web
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Success! We’re able to run system commands in the context of the *www-data*
    user. Before moving on, try establishing a reverse shell by using what you’ve
    learned so far in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we improved our port scanning by using a frequency-enriched
    database of ports and identified possible access paths to additional assets on
    the corporate network. While moving laterally, we exploited scripts hosted on
    shared drives, breached unprotected databases, backdoored a WordPress instance,
    accessed a database administration panel through a leaked SQL file, performed
    Redis configuration tweaks, and uploaded a web shell by using SQL commands.
  prefs: []
  type: TYPE_NORMAL
