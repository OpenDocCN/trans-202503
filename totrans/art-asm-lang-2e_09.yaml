- en: Chapter 10. BIT MANIPULATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![BIT MANIPULATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating bits in memory is, perhaps, the feature for which assembly language
    is most famous. Indeed, one of the reasons people claim that the C programming
    language is a medium-level language rather than a high-level language is because
    of the vast array of bit-manipulation operators that C provides. Even with this
    wide array of bit-manipulation operations, the C programming language doesn't
    provide as complete a set of bit-manipulation operations as assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    using 80x86 assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, and it also introduces a few new instructions.
    This chapter reviews information on packing and unpacking bit strings in memory
    because this is the basis for many bit-manipulation operations. Finally, this
    chapter discusses several bit-centric algorithms and their implementation in assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 What Is Bit Data, Anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before describing how to manipulate bits, it might not be a bad idea to define
    exactly what this text means by *bit data*. Most readers probably assume that
    bit-manipulation programs twiddle individual bits in memory. While programs that
    do this are definitely bit-manipulation programs, we're not going to limit our
    definition to just those programs. For our purposes, *bit manipulation* refers
    to working with data types that consist of strings of bits that are noncontiguous
    or are not a multiple of 8 bits long. Generally, such bit objects will not represent
    numeric integers, although we will not place this restriction on our bit strings.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit string* is some contiguous sequence of one or more bits. Note that a
    bit string does not have to start or end at any special point. For example, a
    bit string could start in bit 7 of one byte in memory and continue through to
    bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30
    of EAX, consume the upper 2 bits of EAX, and then continue from bit 0 through
    bit 17 of EBX. In memory, the bits must be physically contiguous (that is, the
    bit numbers are always increasing except when crossing a byte boundary, and at
    byte boundaries the memory address increases by 1 byte). In registers, if a bit
    string crosses a register boundary, the application defines the continuation register,
    but the bit string always continues in bit 0 of that second register.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit set* is a collection of bits, not necessarily contiguous, within some
    larger data structure. For example, bits 0..3, 7, 12, 24, and 31 from some double
    word form a set of bits. Usually, we will limit bit sets to some reasonably sized
    *container object* (the data structure that encapsulates the bit set), but the
    definition doesn't specifically limit the size. Normally, we will deal with bit
    sets that are part of an object no more than about 32 or 64 bits in size, though
    this limit is completely artificial. Note that bit strings are special cases of
    bit sets.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit run* is a sequence of bits with all the same value. A *run of zeros*
    is a bit string that contains all zeros, and a *run of ones* is a bit string containing
    all ones. The *first set bit* in a bit string is the bit position of the first
    bit containing a 1 in a bit string, that is, the first 1 bit following a possible
    run of zeros. A similar definition exists for the *first clear bit*. The *last
    set bit* is the last bit position in a bit string that contains 1; the remainder
    of the string forms an uninterrupted run of zeros. A similar definition exists
    for the *last clear bit*.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit offset* is the number of bits from some boundary position (usually a
    byte boundary) to the specified bit. As noted in [Chapter 2](ch02.html "Chapter 2. DATA
    REPRESENTATION"), we number the bits starting from 0 at the boundary location.
  prefs: []
  type: TYPE_NORMAL
- en: A *mask* is a sequence of bits that we'll use to manipulate certain bits in
    another value. For example, the bit string %0000_1111_0000, when it's used with
    the and instruction, can mask away (clear) all the bits except bits 4 through
    7\. Likewise, if you use the same value with the or instruction, it can force
    bits 4 through 7 to ones in the destination operand. The term *mask* comes from
    the use of these bit strings with the `and` instruction; in those situations the
    1 and 0 bits behave like masking tape when you're painting something; they pass
    through certain bits unchanged while masking out (clearing) the other bits.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these definitions, we're ready to start manipulating some bits!
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Instructions That Manipulate Bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. By now you should be familiar with most
    of the instructions we''ll use to perform these operations; their introduction
    started way back in the earliest chapters of this text. Nevertheless, it''s worthwhile
    to review the old instructions here as well as present the few bit-manipulation
    instructions we''ve yet to consider.'
  prefs: []
  type: TYPE_NORMAL
- en: The most basic bit-manipulation instructions are the `and`, `or`, `xor`, `not`,
    `test`, and shift and rotate instructions. Indeed, on the earliest 80x86 processors,
    these were the only instructions available for bit manipulation. The following
    paragraphs review these instructions, concentrating on how you could use them
    to manipulate bits in memory or registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `and` instruction provides the ability to strip away unwanted bits from
    some bit sequence, replacing the unwanted bits with zeros. This instruction is
    especially useful for isolating a bit string or a bit set that is merged with
    other, unrelated data (or, at least, data that is not part of the bit string or
    bit set). For example, suppose that a bit string consumes bit positions 12 through
    24 of the EAX register; we can isolate this bit string by setting all other bits
    in EAX to 0 by using the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most programs use the `and` instruction to clear bits that are not part of the
    desired bit string. In theory, you could use the `or` instruction to mask all
    unwanted bits to ones rather than zeros, but later comparisons and operations
    are often easier if the unneeded bit positions contain 0 (see [Figure 10-1](ch10s02.html#isolating_a_bit_string_using_the_and_ins
    "Figure 10-1. Isolating a bit string using the and instruction")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating a bit string using the and instruction](tagoreillycom20100401nostarchimages578069.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Isolating a bit string using the `and` instruction
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see if the string of bits in positions
    12 through 24 of EAX contains $12F3, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another solution, using constant expressions, that''s a little easier
    to digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, however, you''ll want (or need) the bit string aligned with
    bit 0 in EAX prior to any operations you would want to perform. Of course, you
    can use the `shr` instruction to properly align the value after you''ve masked
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that the bit string is aligned to bit 0, the constants and other values
    you use in conjunction with this value are easier to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `or` instruction to mask unwanted bits. However, the `or`
    instruction does not let you clear bits; it allows you to set bits to ones. In
    some instances setting all the bits around your bit set may be desirable; most
    software, however, is easier to write if you clear the surrounding bits rather
    than set them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `or` instruction is especially useful for inserting a bit set into some
    other bit string. To do this, there are several steps you must go through:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear all the bits surrounding your bit set in the source operand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all the bits in the destination operand where you wish to insert the bit
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or` the bit set and destination operand together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose you have a value in bits 0..12 of EAX that you wish to
    insert into bits 12..24 of EBX without affecting any of the other bits in EBX.
    You would begin by stripping out bits 13 and above from EAX; then you would strip
    out bits 12..24 in EBX. Next, you would shift the bits in EAX so the bit string
    occupies bits 12..24 of EAX. Finally, you would `or` the value in EAX into EBX
    (see [Figure 10-2](ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12 "Figure 10-2. Inserting
    bits 0..12 of EAX into bits 12..24 of EBX")), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Inserting bits 0..12 of EAX into bits 12..24 of EBX](tagoreillycom20100401nostarchimages578071.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. Inserting bits 0..12 of EAX into bits 12..24 of EBX
  prefs: []
  type: TYPE_NORMAL
- en: In this figure the desired bits (AAAAAAAAAAAAA) formed a bit string. However,
    this algorithm still works fine even if you're manipulating a noncontiguous set
    of bits. All you have to do is to create an appropriate bit mask you can use for
    `and`ing that has ones in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with bit masks, it is incredibly poor programming style to use
    literal numeric constants as in the past few examples. You should always create
    symbolic constants in the HLA `const` (or `val`) section for your bit masks. Combined
    with some constant expressions, you can produce code that is much easier to read
    and maintain. The current example code is more properly written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the compile time `not` operator (`!`) to invert the bit mask
    in order to clear the bit positions in EBX where the code inserts the bits from
    EAX. This saves having to create another constant in the program that has to be
    changed anytime you modify the `BitMask` constant. Having to maintain two separate
    symbols whose values are dependent on one another is not a good thing in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in addition to merging one bit set with another, the `or` instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can force the corresponding bits in the destination
    operand to 1 by using the `or` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `xor` instruction allows you to invert selected bits in a bit set. Although
    inverting bits isn't as common as setting or clearing them, the `xor` instruction
    often appears in bit-manipulation programs. Of course, if you want to invert all
    the bits in some destination operand, the `not` instruction is probably more appropriate
    than the `xor` instruction; however, to invert selected bits while not affecting
    others, the `xor` is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting fact about `xor`''s operation is that it lets you manipulate
    known data in just about any way imaginable. For example, if you know that a field
    contains %1010, you can force that field to 0 by `xor`ing it with %1010\. Similarly,
    you can force it to %1111 by `xor`ing it with %0101\. Although this might seem
    like a waste, because you can easily force this 4-bit string to 0 or all ones
    using `and`/`or`, the `xor` instruction has two advantages: (1) You are not limited
    to forcing the field to all zeros or all ones; you can actually set these bits
    to any of the 16 valid combinations via `xor`; and (2) if you need to manipulate
    other bits in the destination operand at the same time, `and`/`or` may not be
    able to accommodate you. For example, suppose that you know that one field contains
    %1010 that you want to force to 0 and another field contains %1000 and you wish
    to increment that field by 1 (i.e., set the field to %1001). You cannot accomplish
    both operations with a single `and` or `or` instruction, but you can do this with
    a single `xor` instruction; just `xor` the first field with %1010 and the second
    field with `%0001`. Remember, however, that this trick works only if you know
    the current value of a bit set within the destination operand. Of course, while
    you''re adjusting the values of bit fields containing known values, you can invert
    bits in other fields simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting, clearing, and inverting bits in some destination operand,
    the `and`, `or`, and `xor` instructions also affect various condition codes in
    the flags register. These instructions affect the flags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: These instructions always clear the carry and overflow flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions set the sign flag if the result has a 1 in the H.O. bit;
    they clear it otherwise. That is, these instructions copy the H.O. bit of the
    result into the sign flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions set/clear the zero flag if the result is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions set the parity flag if there is an even number of set bits
    in the L.O. byte of the destination operand; they clear the parity flag if there
    is an odd number of 1 bits in the L.O. byte of the destination operand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing to note is that these instructions always clear the carry and
    overflow flags. This means that you cannot expect the system to preserve the state
    of these two flags across the execution of these instructions. A very common mistake
    in many assembly language programs is the assumption that these instructions do
    not affect the carry flag. Many people will execute an instruction that sets/clears
    the carry flag, execute an `and`/`or`/`xor` instruction, and then attempt to test
    the state of the carry from the previous instruction. This simply will not work.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more interesting aspects to these instructions is that they copy
    the H.O. bit of their result into the sign flag. This means that you can easily
    test the setting of the H.O. bit of the result by testing the sign flag (using
    `sets/setns` or `js`/`jns` instructions, or using the `@s`/`@ns` flags in a boolean
    expression). For this reason, many assembly language programmers will often place
    an important boolean variable in the H.O. bit of some operand so they can easily
    test the state of that bit using the sign flag after a logical operation.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't talked much about the parity flag in this text. We're not going to
    get into a big discussion of this flag and what you use it for because the primary
    purpose for this flag has been taken over by hardware.^([[126](#ftn.CHP-10-FN-1)])
    However, because this is a chapter on bit manipulation, and parity computation
    is a bit-manipulation operation, it seems only fitting to provide a brief discussion
    of the parity flag at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Parity is a very simple error-detection scheme originally employed by telegraphs
    and other serial communication protocols. The idea was to count the number of
    set bits in a character and include an extra bit in the transmission to indicate
    whether that character contained an even or odd number of set bits. The receiving
    end of the transmission would also count the bits and verify that the extra "parity"
    bit indicated a successful transmission. We're not going to explore the information-theory
    aspects of this error-checking scheme at this point other than to point out that
    the purpose of the parity flag is to help compute the value of this extra bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 80x86 `and`, `or`, and `xor` instructions set the parity bit if the L.O.
    byte of their operand contains an even number of set bits. An important fact bears
    repeating here: The parity flag reflects only the number of set bits in the L.O.
    byte of the destination operand; it does not include the H.O. bytes in a word,
    double-word, or other-sized operand. The instruction set uses the L.O. byte only
    to compute the parity because communication programs that use parity are typically
    character-oriented transmission systems (there are better error-checking schemes
    if you transmit more than 8 bits at a time).'
  prefs: []
  type: TYPE_NORMAL
- en: The zero flag setting is one of the more important results the `and`/`or`/`xor`
    instructions produce. Indeed, programs reference this flag so often after the
    `and` instruction that Intel added a separate instruction, `test`, whose main
    purpose is to logically `and` two results and set the flags without otherwise
    affecting either instruction operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main uses of the zero flag after the execution of an `and`
    or `test` instruction: (1) checking to see if a particular bit in an operand is
    set, (2) checking to see if at least one of several bits in a bit set is 1, and
    (3) checking to see if an operand is 0\. Using (1) is actually a special case
    of (2) in which the bit set contains only a single bit. We''ll explore each of
    these uses in the following paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use for the `and` instruction, and also the original reason for the
    inclusion of the `test` instruction in the 80x86 instruction set, is to test to
    see if a particular bit is set in a given operand. To perform this type of test,
    you would normally `and`/`test` a constant value containing a single set bit with
    the operand you wish to test. This clears all the other bits in the second operand,
    leaving a 0 in the bit position under `test` if the operand contains a 0 in that
    bit position. `and`ing with a 1 leaves a 1 in that position if it originally contained
    a 1\. Because all of the other bits in the result are 0, the entire result will
    be 0 if that particular bit is 0; the entire result will be nonzero if that bit
    position contains a 1\. The 80x86 reflects this status in the zero flag (Z = 1
    indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence
    demonstrates how to test to see if bit 4 is set in EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `and`/`test` instructions to see if any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and zeros everywhere else). `and`ing such a value with an unknown quantity
    will produce a nonzero value if one or more of the bits in the operand under test
    contain a 1\. The following example tests to see if the value in EAX contains
    a 1 in bit positions 1, 2, 4, and 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you cannot use a single `and` or `test` instruction to see if all
    the corresponding bits in the bit set are equal to 1\. To accomplish this, you
    must first mask out the bits that are not in the set and then compare the result
    against the mask itself. If the result is equal to the mask, then all the bits
    in the bit set contain ones. You must use the `and` instruction for this operation
    because the `test` instruction does not mask out any bits. The following example
    checks to see if all the bits in a bit set (`bitMask`) are equal to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, once we stick the `cmp` instruction in there, we don't really have
    to check to see if all the bits in the bit set contain ones. We can check for
    any combination of values by specifying the appropriate value as the operand to
    the `cmp` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `test`/`and` instructions will set the zero flag in the above
    code sequences only if all the bits in EAX (or other destination operand) have
    zeros in the positions where ones appear in the constant operand. This suggests
    another way to check for all ones in the bit set: Invert the value in EAX prior
    to using the `and` or `test` instruction. Then if the zero flag is set, you know
    that there were all ones in the (original) bit set. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous paragraphs all suggest that the `bitMask` (the source operand)
    is a constant. This was for purposes of example only. In fact, you can use a variable
    or other register here, if you prefer. Simply load that variable or register with
    the appropriate bit mask before you execute the `test`, `and`, or `cmp` instructions
    in the examples above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another set of instructions we''ve already seen that we can use to manipulate
    bits are the bit test instructions. These instructions include `bt` (bit test),
    `bts` (bit test and set), `btc` (bit test and complement), and `btr` (bit test
    and reset). We''ve used these instructions to manipulate bits in HLA character-set
    variables; we can also use them to manipulate bits in general. The `bt`*`x`* instructions
    allow the following syntactical forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `btx` instruction's first operand is a bit number that specifies which bit
    to check in the second operand. If the second operand is a register, then the
    first operand must contain a value between 0 and the size of the register (in
    bits) minus 1; because the 80x86's largest registers are 32 bits, this value has
    the maximum value 31 (for 32-bit registers). If the second operand is a memory
    location, then the bit count is not limited to values in the range 0..31\. If
    the first operand is a constant, it can be any 8-bit value in the range 0..255\.
    If the first operand is a register, it has no limitation.
  prefs: []
  type: TYPE_NORMAL
- en: The `bt` instruction copies the specified bit from the second operand into the
    carry flag. For example, the `bt( 8, eax );` instruction copies bit 8 of the EAX
    register into the carry flag. You can test the carry flag after this instruction
    to determine whether bit 8 was set or clear in EAX.
  prefs: []
  type: TYPE_NORMAL
- en: The `bts`, `btc`, and `btr` instructions manipulate the bit they test while
    they are testing it. These instructions may be slow (depending on the processor
    you're using), and you should avoid them if performance is your primary concern
    and you're using an older CPU. If performance (versus convenience) is an issue,
    you should always try two different algorithms—one that uses these instructions,
    one that uses `and`/`or` instructions—and measure the performance difference;
    then choose the best of the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The shift and rotate instructions are another group of instructions you can
    use to manipulate and test bits. These instructions move the H.O. (left shift/rotate)
    or L.O. (right shift/rotate) bits into the carry flag. Therefore, you can test
    the carry flag after you execute one of these instructions to determine the original
    setting of the operand's H.O. or L.O. bit. The shift and rotate instructions are
    invaluable for aligning bit strings and packing and unpacking data. [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") has several examples of this, and some earlier
    examples in this chapter also use the shift instructions for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[126](#CHP-10-FN-1)]) Serial communications chips and other communications
    hardware that use parity for error checking normally compute the parity in hardware;
    you don't have to use software for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 The Carry Flag as a Bit Accumulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bt`*`x`*, shift, and rotate instructions set or clear the carry flag depending
    on the operation and selected bit. Because these instructions place their "bit
    result" in the carry flag, it is often convenient to think of the carry flag as
    a 1-bit register or accumulator for bit operations. In this section we will explore
    some of the operations possible with this bit result in the carry flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions that will be useful for manipulating bit results in the carry
    flag are those that use the carry flag as some sort of input value. The following
    is a sampling of such instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adc`, `sbb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rcl`, `rcr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmc` (We''ll throw in `clc` and `stc` even though they don''t use the carry
    as input.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jc`, `jnc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setc`, `setnc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adc` and `sbb` instructions add or subtract their operands along with the
    carry flag. So if you've computed some bit result into the carry flag, you can
    figure that result into an addition or subtraction using these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: To merge a bit result into the carry flag, you most often use the rotate through
    carry instructions (`rcl` and `rcr`). These instructions move the carry flag into
    the L.O. or H.O. bits of their destination operand. These instructions are very
    useful for packing a set of bit results into a byte, word, or double-word value.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmc` (complement carry) instruction lets you easily invert the result of
    some bit operation. You can also use the `clc` and `stc` instructions to initialize
    the carry flag prior to some string of bit operations involving the carry flag.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions that test the carry flag are going to be very popular after a calculation
    that leaves a bit result in the carry flag. The `jc`, `jnc`, `setc`, and `setnc`
    instructions are quite useful here. You can also use the HLA `@c` and `@nc` operands
    in a boolean expression to test the result in the carry flag.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a sequence of bit calculations and you would like to test to see
    if the calculations produce a specific set of 1-bit results, the easiest way to
    do this is to clear a register or memory location and use the `rcl` or `rcr` instruction
    to shift each result into that location. Once the bit operations are complete,
    then you can compare the register or memory location holding the result against
    a constant value. If you want to test a sequence of results involving conjunction
    and disjunction (that is, strings of results involving `and`s and `or`s), then
    you could use the `setc` and `setnc` instruction to set a register to 0 or 1 and
    then use the `and`/`or` instructions to merge the results.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Packing and Unpacking Bit Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common bit operation is inserting a bit string into an operand or extracting
    a bit string from an operand. [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION")
    provided simple examples of packing and unpacking such data; now it is time to
    formally describe how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes we will assume that we're dealing with bit strings—that is,
    a contiguous sequence of bits. In [10.11 Extracting Bit Strings](ch10s11.html
    "10.11 Extracting Bit Strings") we'll look at how to extract and insert bit sets.
    Another simplification we'll make is that the bit string completely fits within
    a byte, word, or double-word operand. Large bit strings that cross object boundaries
    require additional processing; a discussion of bit strings that cross double-word
    boundaries appears later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit string has two attributes that we must consider when packing and unpacking
    that bit string: a starting bit position and a length. The starting bit position
    is the bit number of the L.O. bit of the string in the larger operand. The length
    is the number of bits in the operand. To insert (pack) data into a destination
    operand, you start with a bit string of the appropriate length that is right justified
    (that is, starts in bit position 0) and is zero extended to 8, 16, or 32 bits.
    The task is to insert this data at the appropriate starting position in some other
    operand that is 8-, 16-, or 32-bits wide. There is no guarantee that the destination
    bit positions contain any particular value.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and to shift (a copy of) the bit string so that
    the L.O. bit begins at the appropriate bit position. The third step is to `or`
    the shifted result with the destination operand. This inserts the bit string into
    the destination operand (see [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting a bit string into a destination operand](tagoreillycom20100401nostarchimages578073.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3. Inserting a bit string into a destination operand
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes only three instructions to insert a bit string of known length into
    a destination operand. The following three instructions demonstrate how to handle
    the insertion operation in [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand"). These instructions
    assume that the source operand is in BX and the destination operand is AX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the length and the starting position aren''t known when you''re writing
    the program (that is, you have to calculate them at runtime), then bit-string
    insertion is a little more difficult. However, with the use of a lookup table
    it''s still an easy operation to accomplish. Let''s assume that we have two 8-bit
    values: a starting bit position for the field we''re inserting and a nonzero 8-bit
    length value. Also assume that the source operand is in EBX and the destination
    operand is in EAX. The code to insert one operand into another could take the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the `MaskByLen` table contains the number of 1 bits specified
    by the index into the table. Using the *`Length`* value as an index into this
    table fetches a value that has as many 1 bits as the *`Length`* value. The code
    above fetches an appropriate mask, shifts it to the left so that the L.O. bit
    of this run of ones matches the starting position of the field into which we want
    to insert the data, and then inverts the mask and uses the inverted value to clear
    the appropriate bits in the destination operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting a bit string from a larger operand is just as easy as inserting
    a bit string into some larger operand. All you have to do is mask out the unwanted
    bits and then shift the result until the L.O. bit of the bit string is in bit
    0 of the destination operand. For example, to extract the 4-bit field starting
    at bit position 5 in EBX and leave the result in EAX, you could use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not know the bit string''s length and starting position when you''re
    writing the program, you can still extract the desired bit string. The code is
    very similar to insertion (though a little simpler). Assuming you have the *`Length`*
    and *`StartingPosition`* values we used when inserting a bit string, you can extract
    the corresponding bit string using the following code (assuming source = EBX and
    dest = EAX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples up to this point all assume that the bit string appears completely
    within a double-word (or smaller) object. This will always be the case if the
    bit string is less than or equal to 32 bits in length. However, if the length
    of the bit string plus its starting position (modulo 8) within an object is greater
    than 32, then the bit string will cross a double-word boundary within the object.
    Extracting such bit strings requires up to three operations: one operation to
    extract the start of the bit string (up to the first double-word boundary), an
    operation that copies whole double words (assuming the bit string is so long that
    it consumes several double words), and a final operation that copies leftover
    bits in the last double word at the end of the bit string. The actual implementation
    of this operation is left as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Coalescing Bit Sets and Distributing Bit Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting and extracting bit sets is little different than inserting and extract
    bit strings if the "shape" of the bit set you''re inserting (or resulting bit
    set you''re extracting) is the same as the bit set in the main object. The shape
    of a bit set is the distribution of the bits in the set, ignoring the starting
    bit position of the set. So a bit set that includes bits 0, 4, 5, 6, and 7 has
    the same shape as a bit set that includes bits 12, 16, 17, 18, and 19 because
    the distribution of the bits is the same. The code to insert or extract this bit
    set is nearly identical to that of the previous section; the only difference is
    the mask value you use. For example, to insert this bit set starting at bit 0
    in EAX into the corresponding bit set starting at position 12 in EBX, you could
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, suppose you have 5 bits in bit positions 0 through 4 in EAX and you
    want to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to
    distribute the bits in EAX prior to logically `or`ing the values into EBX. Given
    the fact that this particular bit set has only two runs of 1 bits, the process
    is somewhat simplified. The following code achieves this in a somewhat sneaky
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This trick with the `btr` (bit test and reset) instruction worked well because
    we had only 1 bit out of place in the original source operand. Alas, had the bits
    all been in the wrong location relative to one another, this scheme might not
    have worked quite as well. We'll see a more general solution in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting this bit set and collecting ("coalescing") the bits into a bit string
    is not quite as easy. However, there are still some sneaky tricks we can pull.
    Consider the following code that extracts the bit set from EBX and places the
    result into bits 0..4 of EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code moves (original) bit 12 into bit position 7, the H.O. bit of AL. At
    the same time it moves bits 16..19 down to bits 11..14 (bits 3..6 of AH). Then
    the code shifts bits 3..6 in AH down to bit 0\. This positions the H.O. bits of
    the bit set so that they are adjacent to the bit left in AL. Finally, the code
    shifts all the bits down to bit 0\. Again, this is not a general solution, but
    it shows a clever way to attack this problem if you think about it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the coalescing and distribution algorithms above is that they
    are not general. They apply only to their specific bit sets. Usually specific
    solutions will provide the most efficient solution. A generalized solution (perhaps
    one that lets you specify a mask, and the code distributes or coalesces the bits
    accordingly) is going to be a bit more difficult. The following code demonstrates
    how to distribute the bits in a bit string according to the values in a bit mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, if we load EDX with %1100_1001, then this code will copy
    bits 0..3 to bits 0, 3, 6, and 7 in EAX. Notice the short-circuit test that checks
    to see if we've exhausted the values in EDX (by checking for a 0 in EDX). Note
    that the rotate instructions do not affect the zero flag but the shift instructions
    do. Hence the `shr` instruction above will set the zero flag when there are no
    more bits to distribute (when EDX becomes 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'The general algorithm for coalescing bits is a tad more efficient than distribution.
    Here''s the code that will extract bits from EBX via the bit mask in EDX and leave
    the result in EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This sequence takes advantage of a sneaky trait of the shift and rotate instructions:
    the shift instructions affect the zero flag, whereas the rotate instructions do
    not. Therefore, the `shl( 1, edx );` instruction sets the zero flag when EDX becomes
    0 (after the shift). If the carry flag was also set, the code will make one additional
    pass through the loop in order to shift a bit into EAX, but the next time the
    code shifts EDX 1 bit to the left, EDX is still 0 and so the carry will be clear.
    On this iteration, the code falls out of the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don't get too large), you can use that byte's value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This might produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Packed Arrays of Bit Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it is far more efficient to create arrays whose elements have an integral
    number of bytes, it is quite possible to create arrays of elements whose size
    is not a multiple of 8 bits. The drawback is that calculating the "address" of
    an array element and manipulating that array element involves a lot of extra work.
    In this section we'll take a look at a few examples of packing and unpacking array
    elements in an array whose elements are an arbitrary number of bits long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, it''s probably worthwhile to discuss why you would want
    to bother with arrays of bit objects. The answer is simple: space. If an object
    consumes only 3 bits, you can get 2.67 times as many elements into the same space
    if you pack the data rather than allocating a whole byte for each object. For
    very large arrays, this can be a substantial savings. Of course, the cost of this
    space savings is speed: You have to execute extra instructions to pack and unpack
    the data, thus slowing down access to the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access; it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you calculate the element''s address in bits, you need to convert it to
    a byte address (because we have to use byte addresses when accessing memory) and
    extract the specified element. Because the base address of an array element (almost)
    always starts on a byte boundary, we can use the following equations to simplify
    this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, suppose we have an array of 200 3-bit objects that we declare
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The constant expression in the dimension above reserves space for enough bytes
    to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression
    adds 2 extra bytes at the end to ensure we don't lose any odd bits (that won't
    happen in this example because 600 is evenly divisible by 8, but in general you
    can't count on this; one extra byte usually won't hurt things) and also to allow
    us to access 1 byte beyond the end of the array (when storing data to the array).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Inserting an element into the array is a bit more difficult. In addition to
    computing the base address and bit offset of the array element, you also have
    to create a mask to clear out the bits in the destination where you're going to
    insert the new data. The following code inserts the L.O. 3 bits of EAX into the
    *i*th element of the `AO3Bobjects` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of a lookup table to generate the masks needed to clear out the
    appropriate position in the array. Each element of this array contains all ones
    except for three zeros in the position we need to clear for a given bit offset
    (note the use of the `!` operator to invert the constants in the table).
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Searching for a Bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common bit operation is to locate the end of some run of bits. A special
    case of this operation is to locate the first (or last) set or clear bit in a
    16- or 32-bit value. In this section we'll explore ways to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Before describing how to search for the first or last bit of a given value,
    perhaps it's wise to discuss exactly what the terms *first* and *last* mean in
    this context. The term *first set bit* means the first bit in a value, scanning
    from bit 0 toward the high-order bit, which contains a 1\. A similar definition
    exists for the *first clear bit*. The *last set bit* is the first bit in a value,
    scanning from the high-order bit toward bit 0, which contains a 1\. A similar
    definition exists for the *last clear bit*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0) into
    the carry flag. The number of iterations specifies the position. Here''s some
    sample code that checks for the first set bit in EAX and returns that bit position
    in ECX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The only thing tricky about this code is the fact that it runs the loop counter
    from −32 up to 0 rather than 32 down to 0\. This makes it slightly easier to calculate
    the bit position once the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback to this particular loop is that it's expensive. This loop repeats
    as many as 32 times depending on the original value in EAX. If the values you're
    checking often have lots of zeros in the L.O. bits of EAX, this code runs rather
    slowly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the first (or last) set bit is such a common operation that Intel
    added a couple of instructions on the 80386 specifically to accelerate this process.
    These instructions are `bsf` (bit scan forward) and `bsr` (bit scan reverse).
    Their syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The source and destinations operands must be the same size, and they must both
    be 16- or 32-bit objects. The destination operand has to be a register. The source
    operand can be a register or a memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bsf` instruction scans for the first set bit (starting from bit position
    0) in the source operand. The `bsr` instruction scans for the last set bit in
    the source operand by scanning from the H.O. bit toward the L.O. bit. If these
    instructions find a bit that is set in the source operand, then they clear the
    zero flag and put the bit position into the destination register. If the source
    register contains 0 (that is, there are no set bits), then these instructions
    set the zero flag and leave an indeterminate value in the destination register.
    Note that you should test the zero flag immediately after the execution of these
    instructions to validate the destination register''s value. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You use the `bsr` instruction in an identical fashion except that it computes
    the bit position of the last set bit in an operand (that is, the first set bit
    it finds when scanning from the H.O. bit toward the L.O. bit).
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 CPUs do not provide instructions to locate the first bit containing
    a 0\. However, you can easily scan for a 0 bit by first inverting the source operand
    (or a copy of the source operand if you must preserve the source operand's value)
    and then search for the first 1 bit; this corresponds to the first 0 bit in the
    original operand value.
  prefs: []
  type: TYPE_NORMAL
- en: The `bsf` and `bsr` instructions are very complex 80x86 instructions. Therefore,
    these instructions may be slower than other instructions. Indeed, in some circumstances
    it may be faster to locate the first set bit using discrete instructions. However,
    because the execution time of these instructions varies widely from CPU to CPU,
    you should test the performance of these instructions prior to using them in time-critical
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `bsf` and `bsr` instructions do not affect the source operand.
    A common operation is to extract the first (or last) set bit you find in some
    operand. That is, you might want to clear the bit once you find it. If the source
    operand is a register (or you can easily move it into a register), then you can
    use the `btr` (or `btc`) instruction to clear the bit once you''ve found it. Here''s
    some code that achieves this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At the end of this sequence, the zero flag indicates whether we found a bit
    (note that `btr` does not affect the zero flag). Alternately, you could add an
    `else` section to the `if` statement above that handles the case when the source
    operand (EAX) contains 0 at the beginning of this instruction sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `bsf` and `bsr` instructions support only 16- and 32-bit operands,
    you will have to compute the first bit position of an 8-bit operand a little differently.
    There are a couple of reasonable approaches. First, of course, you can usually
    zero extend an 8-bit operand to 16 or 32 bits and then use the `bsf` or `bsr`
    instruction on this operand. Another alternative is to create a lookup table where
    each entry in the table contains the number of bits in the value you use as an
    index into the table; then you can use the `xlat` instruction to "compute" the
    first bit position in the value (note that you will have to handle the value 0
    as a special case). Another solution is to use the shift algorithm appearing at
    the beginning of this section; for an 8-bit operand, this is not an entirely inefficient
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting use of the `bsf` and `bsr` instructions is to fill in a character
    set with all the values from the lowest valued character in the set through the
    highest valued character. For example, suppose a character set contains the values
    `{'A', 'M', 'a'..'n', 'z'}`; if we filled in the gaps in this character set we
    would have the values `{'A'..'z'}`. To compute this new set we can use `bsf` to
    determine the ASCII code of the first character in the set and `bsr` to determine
    the ASCII code of the last character in the set. After doing this, we can feed
    those two ASCII codes to the HLA Standard Library `cs.rangeChar` function to compute
    the new set.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `bsf` and `bsr` instructions to determine the size of a
    run of bits, assuming that you have a single run of bits in your operand. Simply
    locate the first and last bits in the run (as above) and then compute the difference
    (plus 1) of the two values. Of course, this scheme is valid only if there are
    no intervening zeros between the first and last set bits in the value.
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Counting Bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last example in the previous section demonstrates a specific case of a
    very general problem: counting bits. Unfortunately, that example has a severe
    limitation: It only counts a single run of 1 bits appearing in the source operand.
    This section discusses a more general solution to this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardly a week goes by that someone doesn''t ask on one of the Internet newsgroups
    how to count the number of bits in a register operand. This is a common request,
    undoubtedly, because many assembly language course instructors assign this task
    as a project to their students as a way to teach them about the shift and rotate
    instructions. Undoubtedly, the solution these instructors expect is something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The "trick" worth noting here is that this code uses the `adc` instruction to
    add the value of the carry flag into the BL register. Because the count is going
    to be less than 32, the result will fit comfortably into BL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tricky code or not, this instruction sequence is not particularly fast. As
    you can tell with just a small amount of analysis, the loop above always executes
    32 times, so this code sequence executes 130 instructions (4 instructions per
    iteration plus 2 extra instructions). You might ask if there is a more efficient
    solution; the answer is yes. The following code, taken from the AMD Athlon optimization
    guide, provides a faster solution (see the comments for a description of the algorithm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 10.9 Reversing a Bit String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common programming project instructors assign, and a useful function
    in its own right, is a program that reverses the bits in an operand. That is,
    it swaps the L.O. bit with the H.O. bit, bit 1 with the next-to-H.O. bit, and
    so on. The typical solution an instructor probably expects for this assignment
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous examples, this code suffers from the fact that it repeats
    the loop 32 times, for a grand total of 129 instructions. By unrolling the loop
    you can get it down to 64 instructions, but this is still somewhat expensive.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the best solution to an optimization problem is often a better algorithm
    rather than attempting to tweak your code by trying to choose faster instructions
    to speed up some code. However, a little intelligence goes a long way when manipulating
    bits. In the last section, for example, we were able to speed up counting the
    bits in a string by substituting a more complex algorithm for the simplistic "shift
    and count" algorithm. In the example above, we are once again faced with a very
    simple algorithm with a loop that repeats for 1 bit in each number. The question
    is "Can we discover an algorithm that doesn't execute 129 instructions to reverse
    the bits in a 32-bit register?" The answer is yes, and the trick is to do as much
    work as possible in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that all we wanted to do was swap the even and odd bits in a 32-bit
    value. We can easily swap the even and odd bits in EAX using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, swapping the even and odd bits, while somewhat interesting, does
    not solve our larger problem of reversing all the bits in the number. But it does
    take us part of the way there. For example, if after executing the preceding code
    sequence you swap adjacent pairs of bits, you''ve managed to swap the bits in
    all the nibbles in the 32-bit value. Swapping adjacent pairs of bits is done in
    a manner very similar to the above; the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After completing the preceding sequence, you swap the adjacent nibbles in the
    32-bit register. Again, the only difference is the bit mask and the length of
    the shifts. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can probably see the pattern developing and can figure out that in the
    next two steps you have to swap the bytes and then the words in this object. You
    can use code like the above, but there is a better way: Use the `bswap` instruction.
    The `bswap` (byte swap) instruction uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction swaps bytes 0 and 3, and it swaps bytes 1 and 2 in the specified
    32-bit register. The principle use of this instruction is to convert data between
    the so-called little-endian and big-endian data formats.^([[127](#ftn.CHP-10-FN-2)])
    Although you don''t specifically use this instruction for this purpose here, the
    bswap instruction does swap the bytes and words in a 32-bit object exactly the
    way you want them when reversing bits. Rather than sticking in another 12 instructions
    to swap the bytes and then the words, you can simply use a `bswap( eax );` instruction
    to complete the job after the instructions above. The final code sequence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm requires only 19 instructions, and it executes much faster than
    the bit-shifting loop appearing earlier. Of course, this sequence does consume
    a little more memory. If you're trying to save memory rather than clock cycles,
    the loop is probably a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[127](#CHP-10-FN-2)]) In the little-endian system, which is the native 80x86
    format, the L.O. byte of an object appears at the lowest address in memory. In
    the big-endian system, which various RISC processors use, the H.O. byte of an
    object appears at the lowest address in memory. The `bswap` instruction converts
    between these two data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 10.10 Merging Bit Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common bit string operation is producing a single bit string by merging,
    or interleaving, bits from two different sources. The following example code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This particular example merged two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unrolling
    the loop is probably your best bet because this eliminates half the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few slight modifications, we could also have merged four 8-bit values
    together, or we could have generated the result using other bit sequences. For
    example, the following code copies bits 0..5 from EAX, then bits 0..4 from EBX,
    then bits 6..11 from EAX, then bits 5..15 from EBX, and finally bits 12..15 from
    EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 10.11 Extracting Bit Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we can easily accomplish the converse of merging two bit streams;
    that is, we can extract and distribute bits in a bit string among multiple destinations.
    The following code takes the 32-bit value in EAX and distributes alternate bits
    among the BX and DX registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This sequence executes 99 instructions. This isn't terrible, but we can probably
    do a little better by using an algorithm that extracts bits in parallel. Employing
    the technique we used to reverse bits in a register, we can come up with the following
    algorithm that relocates all the even bits to the L.O. word of EAX and all the
    odd bits to the H.O. word of EAX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This sequence requires 30 instructions. At first blush it looks like a winner
    because the original loop executes 64 instructions. However, this code isn't quite
    as good as it looks. After all, if we're willing to write this much code, why
    not unroll the loop above 16 times? That sequence requires only 64 instructions.
    So the complexity of the previous algorithm may not gain much on instruction count.
    As to which sequence is faster, well, you'll have to time them to figure this
    out. However, the `shrd` instructions are not particularly fast on all processors
    and neither are the instructions in the other sequence. This example appears here
    not to show you a better algorithm but rather to demonstrate that writing really
    tricky code doesn't always provide a big performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting other bit combinations is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 10.12 Searching for a Bit Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of %1011 starting at some particular position in
    a bit string. In this section we'll explore some simple algorithms to accomplish
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for a particular bit pattern we''re going to need to know four things:
    (1) the pattern to search for (the *pattern*), (2) the length of the pattern we''re
    searching for, (3) the bit string that we''re going to search through (the *source*),
    and (4) the length of the bit string to search through. The basic idea behind
    the search is to create a mask based on the length of the pattern and mask a copy
    of the source with this value. Then we can directly compare the pattern with the
    masked source for equality. If they are equal, you''re finished; if they''re not
    equal, then increment a bit position counter, shift the source one position to
    the right, and try again. You repeat this operation `length(`*`source`*`) - length(`*`pattern`*`)`
    times. The algorithm fails if it does not detect the bit pattern after this many
    attempts (because we will have exhausted all the bits in the source operand that
    could match the pattern''s length). Here''s a simple algorithm that searches for
    a 4-bit pattern throughout the EBX register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Bit-string scanning is a special case of string matching. String matching is
    a well-studied problem in computer science, and many of the algorithms you can
    use for string matching are applicable to bit-string matching as well. Such algorithms
    are beyond the scope of this chapter, but to give you a preview of how this works,
    you compute some function (like `xor` or `sub`) between the pattern and the current
    source bits and use the result as an index into a lookup table to determine how
    many bits you can skip. Such algorithms let you skip several bits rather than
    shifting only once for each iteration of the scanning loop (as is done by the
    previous algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 10.13 The HLA Standard Library Bits Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA Standard Library provides the `bits.hhf` module that provides several
    bit-related functions, including built-in functions for many of the algorithms
    we've studied in this chapter. This section describes some of the functions available
    in the HLA Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This procedure returns the number of 1 bits present in the `b` parameter. It
    returns the count in the EAX register. To count the number of 0 bits in the parameter
    value, invert the value of the parameter before passing it to `bits.cnt`. If you
    want to count the number of bits in a 16-bit operand, simply zero extend it to
    32 bits prior to calling this function. Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you want to compute the number of bits in an 8-bit operand, it's probably
    faster to write a simple loop that rotates all the bits in the source operand
    and adds the carry into the accumulating sum. Of course, if performance isn't
    an issue, you can zero extend the byte to 32 bits and call the `bits.cnt` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the L.O. *n* bits of `source`, where *n* is the number of
    1 bits in `mask`, and inserts these bits into `dest` at the bit positions specified
    by the 1 bits in `mask` (that is, the same as the distribute algorithm appearing
    earlier in this chapter). This function does not change the bits in `dest` that
    correspond to the zeros in the `mask` value. This function does not affect the
    value of the actual `dest` parameter; it returns the new value in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This function is the converse of `bits.distribute`. It extracts all the bits
    in source whose corresponding positions in `mask` contain a 1\. This function
    coalesces (right justifies) these bits in the L.O. bit positions of the result
    and returns the result in EAX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This function extracts the first set bit in `d` searching from bit 0 and returns
    the index of this bit in the EAX register; the function also returns the zero
    flag clear in this case. This function also clears that bit in the operand. If
    `d` contains 0, then this function returns the zero flag set and EAX will contain
    −1.
  prefs: []
  type: TYPE_NORMAL
- en: Note that HLA actually implements this function as a macro, not a procedure.
    This means that you can pass any double-word operand as a parameter (a memory
    or a register operand). However, the results are undefined if you pass EAX as
    the parameter (because this function computes the bit number in EAX).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These three routines return their parameter value with its bits reversed in
    the accumulator register (AL/AX/EAX). Call the routine appropriate for your data
    size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: These routines merge two streams of bits to produce a value whose size is the
    combination of the two parameters. The bits from the `even` parameter occupy the
    even bit positions in the result; the bits from the `odd` parameter occupy the
    odd bit positions in the result. Notice that these functions return 16, 32, or
    64 bits based on byte, word, and double-word parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These routines extract each nibble from the parameter and place those nibbles
    into individual bytes. The `bits.nibbles8` function extracts the two nibbles from
    the `b` parameter and places the L.O. nibble in AL and the H.O. nibble in AH.
    The `bits.nibbles16` function extracts the four nibbles in `w` and places them
    in each of the 4 bytes of EAX. You can use the `bswap` or rox instructions to
    gain access to the nibbles in the H.O. word of EAX. The `bits.nibbles32` function
    extracts the eight nibbles in EAX and distributes them through the 8 bytes in
    EDX:EAX. Nibble 0 winds up in AL and nibble 7 winds up in the H.O. byte of EDX.
    Again, you can use `bswap` or the rotate instructions to access the upper bytes
    of EAX and EDX.
  prefs: []
  type: TYPE_NORMAL
- en: 10.14 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The electronic edition of The Art of Assembly Language at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    and [http://www.artofasm.com/](http://www.artofasm.com/) contains some additional
    information you may find useful when developing bit-manipulation algorithms. In
    particular, the chapter on digital design discusses boolean algebra, a subject
    that you will find essential when working with bits. The HLA Standard Library
    reference manual contains more information about the HLA Standard Library bit-manipulation
    routines. See that documentation on the website for more information about those
    functions. As noted in the section on bit counting, the AMD Athlon optimization
    guide contains some useful algorithms for bit-based computations. Finally, to
    learn more about bit searching algorithms, you should pick up a textbook on data
    structures and algorithms and study the section on string-matching algorithms.
  prefs: []
  type: TYPE_NORMAL
