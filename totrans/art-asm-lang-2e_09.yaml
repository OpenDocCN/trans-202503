- en: Chapter 10. BIT MANIPULATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 位操作
- en: '![BIT MANIPULATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![位操作](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: Manipulating bits in memory is, perhaps, the feature for which assembly language
    is most famous. Indeed, one of the reasons people claim that the C programming
    language is a medium-level language rather than a high-level language is because
    of the vast array of bit-manipulation operators that C provides. Even with this
    wide array of bit-manipulation operations, the C programming language doesn't
    provide as complete a set of bit-manipulation operations as assembly language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作内存中的位或许是汇编语言最著名的特性之一。确实，人们宣称C语言是一种中级语言而不是高级语言的原因之一，是因为C语言提供了大量的位操作符。即便有了这如此广泛的位操作功能，C语言提供的位操作集合仍不如汇编语言完整。
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    using 80x86 assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, and it also introduces a few new instructions.
    This chapter reviews information on packing and unpacking bit strings in memory
    because this is the basis for many bit-manipulation operations. Finally, this
    chapter discusses several bit-centric algorithms and their implementation in assembly
    language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何使用80x86汇编语言操作内存和寄存器中的位字符串。它从回顾到目前为止涉及的位操作指令开始，并介绍了一些新的指令。本章回顾了在内存中打包和解包位字符串的信息，因为这是许多位操作的基础。最后，本章讨论了几个以位为中心的算法及其在汇编语言中的实现。
- en: 10.1 What Is Bit Data, Anyway?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 什么是位数据？
- en: Before describing how to manipulate bits, it might not be a bad idea to define
    exactly what this text means by *bit data*. Most readers probably assume that
    bit-manipulation programs twiddle individual bits in memory. While programs that
    do this are definitely bit-manipulation programs, we're not going to limit our
    definition to just those programs. For our purposes, *bit manipulation* refers
    to working with data types that consist of strings of bits that are noncontiguous
    or are not a multiple of 8 bits long. Generally, such bit objects will not represent
    numeric integers, although we will not place this restriction on our bit strings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何操作位之前，最好先明确一下本书中*位数据*的具体含义。大多数读者可能会认为位操作程序是修改内存中的单个位。虽然这样的程序无疑是位操作程序，但我们不会将定义仅限于这些程序。就我们的目的而言，*位操作*是指处理由非连续位字符串或长度不是8位的倍数的位数据类型。通常，这样的位对象不会表示数值整数，尽管我们并不会对我们的位字符串做出这一限制。
- en: A *bit string* is some contiguous sequence of one or more bits. Note that a
    bit string does not have to start or end at any special point. For example, a
    bit string could start in bit 7 of one byte in memory and continue through to
    bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30
    of EAX, consume the upper 2 bits of EAX, and then continue from bit 0 through
    bit 17 of EBX. In memory, the bits must be physically contiguous (that is, the
    bit numbers are always increasing except when crossing a byte boundary, and at
    byte boundaries the memory address increases by 1 byte). In registers, if a bit
    string crosses a register boundary, the application defines the continuation register,
    but the bit string always continues in bit 0 of that second register.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*位字符串*是一个连续的由一个或多个比特组成的序列。请注意，位字符串不必从任何特定位置开始或结束。例如，位字符串可以从内存中一个字节的第7个位开始，继续到下一个字节的第6个位。同样，位字符串可以从EAX的第30个位开始，消耗EAX的上2个位，然后从EBX的第0个位到第17个位继续。在内存中，位必须是物理连续的（即，位编号总是递增，除非跨越字节边界，而在字节边界时，内存地址增加1字节）。在寄存器中，如果位字符串跨越了寄存器边界，应用程序定义继续的寄存器，但位字符串总是从第二个寄存器的第0个位开始继续。'
- en: A *bit set* is a collection of bits, not necessarily contiguous, within some
    larger data structure. For example, bits 0..3, 7, 12, 24, and 31 from some double
    word form a set of bits. Usually, we will limit bit sets to some reasonably sized
    *container object* (the data structure that encapsulates the bit set), but the
    definition doesn't specifically limit the size. Normally, we will deal with bit
    sets that are part of an object no more than about 32 or 64 bits in size, though
    this limit is completely artificial. Note that bit strings are special cases of
    bit sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: A *bit run* is a sequence of bits with all the same value. A *run of zeros*
    is a bit string that contains all zeros, and a *run of ones* is a bit string containing
    all ones. The *first set bit* in a bit string is the bit position of the first
    bit containing a 1 in a bit string, that is, the first 1 bit following a possible
    run of zeros. A similar definition exists for the *first clear bit*. The *last
    set bit* is the last bit position in a bit string that contains 1; the remainder
    of the string forms an uninterrupted run of zeros. A similar definition exists
    for the *last clear bit*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A *bit offset* is the number of bits from some boundary position (usually a
    byte boundary) to the specified bit. As noted in [Chapter 2](ch02.html "Chapter 2. DATA
    REPRESENTATION"), we number the bits starting from 0 at the boundary location.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A *mask* is a sequence of bits that we'll use to manipulate certain bits in
    another value. For example, the bit string %0000_1111_0000, when it's used with
    the and instruction, can mask away (clear) all the bits except bits 4 through
    7\. Likewise, if you use the same value with the or instruction, it can force
    bits 4 through 7 to ones in the destination operand. The term *mask* comes from
    the use of these bit strings with the `and` instruction; in those situations the
    1 and 0 bits behave like masking tape when you're painting something; they pass
    through certain bits unchanged while masking out (clearing) the other bits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these definitions, we're ready to start manipulating some bits!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Instructions That Manipulate Bits
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. By now you should be familiar with most
    of the instructions we''ll use to perform these operations; their introduction
    started way back in the earliest chapters of this text. Nevertheless, it''s worthwhile
    to review the old instructions here as well as present the few bit-manipulation
    instructions we''ve yet to consider.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The most basic bit-manipulation instructions are the `and`, `or`, `xor`, `not`,
    `test`, and shift and rotate instructions. Indeed, on the earliest 80x86 processors,
    these were the only instructions available for bit manipulation. The following
    paragraphs review these instructions, concentrating on how you could use them
    to manipulate bits in memory or registers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The `and` instruction provides the ability to strip away unwanted bits from
    some bit sequence, replacing the unwanted bits with zeros. This instruction is
    especially useful for isolating a bit string or a bit set that is merged with
    other, unrelated data (or, at least, data that is not part of the bit string or
    bit set). For example, suppose that a bit string consumes bit positions 12 through
    24 of the EAX register; we can isolate this bit string by setting all other bits
    in EAX to 0 by using the following instruction:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most programs use the `and` instruction to clear bits that are not part of the
    desired bit string. In theory, you could use the `or` instruction to mask all
    unwanted bits to ones rather than zeros, but later comparisons and operations
    are often easier if the unneeded bit positions contain 0 (see [Figure 10-1](ch10s02.html#isolating_a_bit_string_using_the_and_ins
    "Figure 10-1. Isolating a bit string using the and instruction")).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating a bit string using the and instruction](tagoreillycom20100401nostarchimages578069.png.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Isolating a bit string using the `and` instruction
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see if the string of bits in positions
    12 through 24 of EAX contains $12F3, you could use the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s another solution, using constant expressions, that''s a little easier
    to digest:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of the time, however, you''ll want (or need) the bit string aligned with
    bit 0 in EAX prior to any operations you would want to perform. Of course, you
    can use the `shr` instruction to properly align the value after you''ve masked
    it, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that the bit string is aligned to bit 0, the constants and other values
    you use in conjunction with this value are easier to deal with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `or` instruction to mask unwanted bits. However, the `or`
    instruction does not let you clear bits; it allows you to set bits to ones. In
    some instances setting all the bits around your bit set may be desirable; most
    software, however, is easier to write if you clear the surrounding bits rather
    than set them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The `or` instruction is especially useful for inserting a bit set into some
    other bit string. To do this, there are several steps you must go through:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Clear all the bits surrounding your bit set in the source operand.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all the bits in the destination operand where you wish to insert the bit
    set.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or` the bit set and destination operand together.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose you have a value in bits 0..12 of EAX that you wish to
    insert into bits 12..24 of EBX without affecting any of the other bits in EBX.
    You would begin by stripping out bits 13 and above from EAX; then you would strip
    out bits 12..24 in EBX. Next, you would shift the bits in EAX so the bit string
    occupies bits 12..24 of EAX. Finally, you would `or` the value in EAX into EBX
    (see [Figure 10-2](ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12 "Figure 10-2. Inserting
    bits 0..12 of EAX into bits 12..24 of EBX")), as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你希望将EAX的位0..12中的值插入到EBX的位12..24中，而不影响EBX中的其他位。你将首先从EAX中去除位13及以上的位；然后从EBX中去除位12..24的位。接下来，你将位移EAX中的位，使得位串占据EAX的位12..24。最后，你将EAX中的值通过`or`操作插入到EBX中（参见[图10-2](ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12
    "图10-2. 将EAX的位0..12插入EBX的位12..24")），如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Inserting bits 0..12 of EAX into bits 12..24 of EBX](tagoreillycom20100401nostarchimages578071.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![将EAX的位0..12插入EBX的位12..24](tagoreillycom20100401nostarchimages578071.png.jpg)'
- en: Figure 10-2. Inserting bits 0..12 of EAX into bits 12..24 of EBX
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2. 将EAX的位0..12插入EBX的位12..24
- en: In this figure the desired bits (AAAAAAAAAAAAA) formed a bit string. However,
    this algorithm still works fine even if you're manipulating a noncontiguous set
    of bits. All you have to do is to create an appropriate bit mask you can use for
    `and`ing that has ones in the appropriate places.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，期望的位（AAAAAAAAAAAAA）形成了一个位串。然而，即使你正在操作一个非连续的位集合，这个算法仍然能够正常工作。你只需创建一个适当的位掩码，用于`and`操作，并在适当的位置填充1即可。
- en: 'When working with bit masks, it is incredibly poor programming style to use
    literal numeric constants as in the past few examples. You should always create
    symbolic constants in the HLA `const` (or `val`) section for your bit masks. Combined
    with some constant expressions, you can produce code that is much easier to read
    and maintain. The current example code is more properly written as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用位掩码时，像前面几个例子那样使用字面数值常量是非常不好的编程风格。你应该始终在HLA的`const`（或`val`）部分为你的位掩码创建符号常量。结合一些常量表达式，你可以编写出更易读和更易维护的代码。当前的示例代码更恰当的写法如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the use of the compile time `not` operator (`!`) to invert the bit mask
    in order to clear the bit positions in EBX where the code inserts the bits from
    EAX. This saves having to create another constant in the program that has to be
    changed anytime you modify the `BitMask` constant. Having to maintain two separate
    symbols whose values are dependent on one another is not a good thing in a program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用编译时的`not`运算符（`!`）来反转位掩码，以便清除EBX中代码插入EAX中的位的位位置。这样就不需要在程序中创建另一个常量，并且每次修改`BitMask`常量时都需要更新它。程序中维护两个相互依赖的符号并不是一个好习惯。
- en: Of course, in addition to merging one bit set with another, the `or` instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can force the corresponding bits in the destination
    operand to 1 by using the `or` instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了将一个位集合与另一个合并外，`or`指令也非常适用于强制将位设置为1。在源操作数中将不同的位设置为1后，你可以通过使用`or`指令将目标操作数中的相应位强制设置为1。
- en: The `xor` instruction allows you to invert selected bits in a bit set. Although
    inverting bits isn't as common as setting or clearing them, the `xor` instruction
    often appears in bit-manipulation programs. Of course, if you want to invert all
    the bits in some destination operand, the `not` instruction is probably more appropriate
    than the `xor` instruction; however, to invert selected bits while not affecting
    others, the `xor` is the way to go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`指令允许你反转位集合中的选定位。虽然反转位不像设置或清除位那么常见，但`xor`指令在位操作程序中经常出现。当然，如果你想反转某个目标操作数中的所有位，`not`指令可能比`xor`指令更合适；然而，要反转选定的位而不影响其他位时，`xor`是更合适的选择。'
- en: 'One interesting fact about `xor`''s operation is that it lets you manipulate
    known data in just about any way imaginable. For example, if you know that a field
    contains %1010, you can force that field to 0 by `xor`ing it with %1010\. Similarly,
    you can force it to %1111 by `xor`ing it with %0101\. Although this might seem
    like a waste, because you can easily force this 4-bit string to 0 or all ones
    using `and`/`or`, the `xor` instruction has two advantages: (1) You are not limited
    to forcing the field to all zeros or all ones; you can actually set these bits
    to any of the 16 valid combinations via `xor`; and (2) if you need to manipulate
    other bits in the destination operand at the same time, `and`/`or` may not be
    able to accommodate you. For example, suppose that you know that one field contains
    %1010 that you want to force to 0 and another field contains %1000 and you wish
    to increment that field by 1 (i.e., set the field to %1001). You cannot accomplish
    both operations with a single `and` or `or` instruction, but you can do this with
    a single `xor` instruction; just `xor` the first field with %1010 and the second
    field with `%0001`. Remember, however, that this trick works only if you know
    the current value of a bit set within the destination operand. Of course, while
    you''re adjusting the values of bit fields containing known values, you can invert
    bits in other fields simultaneously.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor` 操作的一个有趣事实是，它让你能够以几乎任何可想象的方式操作已知数据。例如，如果你知道某个字段包含 %1010，你可以通过与 %1010 进行
    `xor` 操作将该字段强制为 0。同样，你也可以通过与 %0101 进行 `xor` 操作将其强制为 %1111。虽然这看起来可能是一种浪费，因为你可以很容易地通过
    `and`/`or` 将这个 4 位字符串强制为 0 或全部为 1，但 `xor` 指令有两个优点：（1）你不仅仅局限于将字段强制为全零或全一；你实际上可以通过
    `xor` 将这些位设置为 16 种有效组合中的任何一种；（2）如果你需要同时操作目标操作数中的其他位，`and`/`or` 可能无法满足你的需求。例如，假设你知道一个字段包含
    %1010，你想将其强制为 0，另一个字段包含 %1000，你希望将该字段加 1（即将字段设置为 %1001）。你无法通过单个 `and` 或 `or` 指令完成这两个操作，但你可以通过单个
    `xor` 指令做到；只需将第一个字段与 %1010 进行 `xor`，将第二个字段与 `%0001` 进行 `xor`。然而，请记住，这个技巧仅在你知道目标操作数中某个位的当前值时才有效。当然，在你调整包含已知值的位字段时，你还可以同时翻转其他字段中的位。'
- en: 'In addition to setting, clearing, and inverting bits in some destination operand,
    the `and`, `or`, and `xor` instructions also affect various condition codes in
    the flags register. These instructions affect the flags as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在某些目标操作数中设置、清除和翻转位外，`and`、`or` 和 `xor` 指令还会影响标志寄存器中的各种条件码。这些指令会按以下方式影响标志：
- en: These instructions always clear the carry and overflow flags.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些指令始终会清除进位标志和溢出标志。
- en: These instructions set the sign flag if the result has a 1 in the H.O. bit;
    they clear it otherwise. That is, these instructions copy the H.O. bit of the
    result into the sign flag.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果的最高有效位是 1，这些指令会设置符号标志；否则，它们会清除符号标志。也就是说，这些指令将结果的最高有效位复制到符号标志中。
- en: These instructions set/clear the zero flag if the result is 0.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果为 0，这些指令会设置/清除零标志。
- en: These instructions set the parity flag if there is an even number of set bits
    in the L.O. byte of the destination operand; they clear the parity flag if there
    is an odd number of 1 bits in the L.O. byte of the destination operand.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标操作数的低字节中有偶数个已设置的位，这些指令会设置奇偶标志；如果目标操作数的低字节中有奇数个 1 位，这些指令会清除奇偶标志。
- en: The first thing to note is that these instructions always clear the carry and
    overflow flags. This means that you cannot expect the system to preserve the state
    of these two flags across the execution of these instructions. A very common mistake
    in many assembly language programs is the assumption that these instructions do
    not affect the carry flag. Many people will execute an instruction that sets/clears
    the carry flag, execute an `and`/`or`/`xor` instruction, and then attempt to test
    the state of the carry from the previous instruction. This simply will not work.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这些指令始终会清除进位标志和溢出标志。这意味着你不能期望系统在执行这些指令后保留这两个标志的状态。许多汇编语言程序中一个非常常见的错误是假设这些指令不会影响进位标志。很多人会执行一个设置/清除进位标志的指令，然后执行
    `and`/`or`/`xor` 指令，再尝试测试之前指令的进位标志状态。这显然是行不通的。
- en: One of the more interesting aspects to these instructions is that they copy
    the H.O. bit of their result into the sign flag. This means that you can easily
    test the setting of the H.O. bit of the result by testing the sign flag (using
    `sets/setns` or `js`/`jns` instructions, or using the `@s`/`@ns` flags in a boolean
    expression). For this reason, many assembly language programmers will often place
    an important boolean variable in the H.O. bit of some operand so they can easily
    test the state of that bit using the sign flag after a logical operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的一个有趣的方面是，它们将结果的最高有效位（H.O.位）复制到符号标志中。这意味着你可以通过测试符号标志（使用`sets/setns`或`js`/`jns`指令，或者在布尔表达式中使用`@s`/`@ns`标志）轻松测试结果的H.O.位的设置。因此，许多汇编语言程序员常常将一个重要的布尔变量放置在某个操作数的H.O.位中，这样他们就可以在进行逻辑操作后，通过符号标志轻松测试该位的状态。
- en: We haven't talked much about the parity flag in this text. We're not going to
    get into a big discussion of this flag and what you use it for because the primary
    purpose for this flag has been taken over by hardware.^([[126](#ftn.CHP-10-FN-1)])
    However, because this is a chapter on bit manipulation, and parity computation
    is a bit-manipulation operation, it seems only fitting to provide a brief discussion
    of the parity flag at this time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们没有太多讨论奇偶标志。我们不会深入讨论这个标志及其用途，因为该标志的主要用途已经被硬件所接管。^([[126](#ftn.CHP-10-FN-1)])
    然而，因为这是关于位操作的章节，而奇偶计算是一个位操作，所以现在简要讨论奇偶标志似乎是合适的。
- en: Parity is a very simple error-detection scheme originally employed by telegraphs
    and other serial communication protocols. The idea was to count the number of
    set bits in a character and include an extra bit in the transmission to indicate
    whether that character contained an even or odd number of set bits. The receiving
    end of the transmission would also count the bits and verify that the extra "parity"
    bit indicated a successful transmission. We're not going to explore the information-theory
    aspects of this error-checking scheme at this point other than to point out that
    the purpose of the parity flag is to help compute the value of this extra bit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶是一个非常简单的错误检测方案，最早由电报和其他串行通信协议使用。其原理是计算字符中设置位的数量，并在传输中添加一个额外的位，以指示该字符包含偶数或奇数个设置位。接收端也会计算位并验证额外的“奇偶”位是否表示传输成功。我们此时不会深入探讨这种错误检查方案的信息理论方面，只是指出奇偶标志的目的是帮助计算这个额外位的值。
- en: 'The 80x86 `and`, `or`, and `xor` instructions set the parity bit if the L.O.
    byte of their operand contains an even number of set bits. An important fact bears
    repeating here: The parity flag reflects only the number of set bits in the L.O.
    byte of the destination operand; it does not include the H.O. bytes in a word,
    double-word, or other-sized operand. The instruction set uses the L.O. byte only
    to compute the parity because communication programs that use parity are typically
    character-oriented transmission systems (there are better error-checking schemes
    if you transmit more than 8 bits at a time).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的`and`、`or`和`xor`指令会在其操作数的最低有效字节（L.O.字节）中包含偶数个设置位时设置奇偶位。这里有一个重要的事实需要重申：奇偶标志仅反映目标操作数的L.O.字节中设置位的数量；它不包括字、双字或其他大小操作数中的H.O.字节。指令集仅使用L.O.字节来计算奇偶性，因为使用奇偶性的通信程序通常是面向字符的传输系统（如果一次传输超过8位，通常有更好的错误检查方案）。
- en: The zero flag setting is one of the more important results the `and`/`or`/`xor`
    instructions produce. Indeed, programs reference this flag so often after the
    `and` instruction that Intel added a separate instruction, `test`, whose main
    purpose is to logically `and` two results and set the flags without otherwise
    affecting either instruction operand.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志的设置是`and`/`or`/`xor`指令产生的更重要的结果之一。实际上，程序在`and`指令之后如此频繁地引用这个标志，以至于英特尔添加了一个单独的指令`test`，其主要目的是对两个结果进行逻辑`and`操作并设置标志，而不会对任何指令操作数产生其他影响。
- en: 'There are three main uses of the zero flag after the execution of an `and`
    or `test` instruction: (1) checking to see if a particular bit in an operand is
    set, (2) checking to see if at least one of several bits in a bit set is 1, and
    (3) checking to see if an operand is 0\. Using (1) is actually a special case
    of (2) in which the bit set contains only a single bit. We''ll explore each of
    these uses in the following paragraphs.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use for the `and` instruction, and also the original reason for the
    inclusion of the `test` instruction in the 80x86 instruction set, is to test to
    see if a particular bit is set in a given operand. To perform this type of test,
    you would normally `and`/`test` a constant value containing a single set bit with
    the operand you wish to test. This clears all the other bits in the second operand,
    leaving a 0 in the bit position under `test` if the operand contains a 0 in that
    bit position. `and`ing with a 1 leaves a 1 in that position if it originally contained
    a 1\. Because all of the other bits in the result are 0, the entire result will
    be 0 if that particular bit is 0; the entire result will be nonzero if that bit
    position contains a 1\. The 80x86 reflects this status in the zero flag (Z = 1
    indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence
    demonstrates how to test to see if bit 4 is set in EAX:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the `and`/`test` instructions to see if any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and zeros everywhere else). `and`ing such a value with an unknown quantity
    will produce a nonzero value if one or more of the bits in the operand under test
    contain a 1\. The following example tests to see if the value in EAX contains
    a 1 in bit positions 1, 2, 4, and 7:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that you cannot use a single `and` or `test` instruction to see if all
    the corresponding bits in the bit set are equal to 1\. To accomplish this, you
    must first mask out the bits that are not in the set and then compare the result
    against the mask itself. If the result is equal to the mask, then all the bits
    in the bit set contain ones. You must use the `and` instruction for this operation
    because the `test` instruction does not mask out any bits. The following example
    checks to see if all the bits in a bit set (`bitMask`) are equal to 1:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, once we stick the `cmp` instruction in there, we don't really have
    to check to see if all the bits in the bit set contain ones. We can check for
    any combination of values by specifying the appropriate value as the operand to
    the `cmp` instruction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `test`/`and` instructions will set the zero flag in the above
    code sequences only if all the bits in EAX (or other destination operand) have
    zeros in the positions where ones appear in the constant operand. This suggests
    another way to check for all ones in the bit set: Invert the value in EAX prior
    to using the `and` or `test` instruction. Then if the zero flag is set, you know
    that there were all ones in the (original) bit set. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous paragraphs all suggest that the `bitMask` (the source operand)
    is a constant. This was for purposes of example only. In fact, you can use a variable
    or other register here, if you prefer. Simply load that variable or register with
    the appropriate bit mask before you execute the `test`, `and`, or `cmp` instructions
    in the examples above.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Another set of instructions we''ve already seen that we can use to manipulate
    bits are the bit test instructions. These instructions include `bt` (bit test),
    `bts` (bit test and set), `btc` (bit test and complement), and `btr` (bit test
    and reset). We''ve used these instructions to manipulate bits in HLA character-set
    variables; we can also use them to manipulate bits in general. The `bt`*`x`* instructions
    allow the following syntactical forms:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `btx` instruction's first operand is a bit number that specifies which bit
    to check in the second operand. If the second operand is a register, then the
    first operand must contain a value between 0 and the size of the register (in
    bits) minus 1; because the 80x86's largest registers are 32 bits, this value has
    the maximum value 31 (for 32-bit registers). If the second operand is a memory
    location, then the bit count is not limited to values in the range 0..31\. If
    the first operand is a constant, it can be any 8-bit value in the range 0..255\.
    If the first operand is a register, it has no limitation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The `bt` instruction copies the specified bit from the second operand into the
    carry flag. For example, the `bt( 8, eax );` instruction copies bit 8 of the EAX
    register into the carry flag. You can test the carry flag after this instruction
    to determine whether bit 8 was set or clear in EAX.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `bts`, `btc`, and `btr` instructions manipulate the bit they test while
    they are testing it. These instructions may be slow (depending on the processor
    you're using), and you should avoid them if performance is your primary concern
    and you're using an older CPU. If performance (versus convenience) is an issue,
    you should always try two different algorithms—one that uses these instructions,
    one that uses `and`/`or` instructions—and measure the performance difference;
    then choose the best of the two approaches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The shift and rotate instructions are another group of instructions you can
    use to manipulate and test bits. These instructions move the H.O. (left shift/rotate)
    or L.O. (right shift/rotate) bits into the carry flag. Therefore, you can test
    the carry flag after you execute one of these instructions to determine the original
    setting of the operand's H.O. or L.O. bit. The shift and rotate instructions are
    invaluable for aligning bit strings and packing and unpacking data. [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") has several examples of this, and some earlier
    examples in this chapter also use the shift instructions for this purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: ^([[126](#CHP-10-FN-1)]) Serial communications chips and other communications
    hardware that use parity for error checking normally compute the parity in hardware;
    you don't have to use software for this purpose.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 The Carry Flag as a Bit Accumulator
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bt`*`x`*, shift, and rotate instructions set or clear the carry flag depending
    on the operation and selected bit. Because these instructions place their "bit
    result" in the carry flag, it is often convenient to think of the carry flag as
    a 1-bit register or accumulator for bit operations. In this section we will explore
    some of the operations possible with this bit result in the carry flag.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions that will be useful for manipulating bit results in the carry
    flag are those that use the carry flag as some sort of input value. The following
    is a sampling of such instructions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`adc`, `sbb`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rcl`, `rcr`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmc` (We''ll throw in `clc` and `stc` even though they don''t use the carry
    as input.)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jc`, `jnc`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setc`, `setnc`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adc` and `sbb` instructions add or subtract their operands along with the
    carry flag. So if you've computed some bit result into the carry flag, you can
    figure that result into an addition or subtraction using these instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: To merge a bit result into the carry flag, you most often use the rotate through
    carry instructions (`rcl` and `rcr`). These instructions move the carry flag into
    the L.O. or H.O. bits of their destination operand. These instructions are very
    useful for packing a set of bit results into a byte, word, or double-word value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The `cmc` (complement carry) instruction lets you easily invert the result of
    some bit operation. You can also use the `clc` and `stc` instructions to initialize
    the carry flag prior to some string of bit operations involving the carry flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Instructions that test the carry flag are going to be very popular after a calculation
    that leaves a bit result in the carry flag. The `jc`, `jnc`, `setc`, and `setnc`
    instructions are quite useful here. You can also use the HLA `@c` and `@nc` operands
    in a boolean expression to test the result in the carry flag.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: If you have a sequence of bit calculations and you would like to test to see
    if the calculations produce a specific set of 1-bit results, the easiest way to
    do this is to clear a register or memory location and use the `rcl` or `rcr` instruction
    to shift each result into that location. Once the bit operations are complete,
    then you can compare the register or memory location holding the result against
    a constant value. If you want to test a sequence of results involving conjunction
    and disjunction (that is, strings of results involving `and`s and `or`s), then
    you could use the `setc` and `setnc` instruction to set a register to 0 or 1 and
    then use the `and`/`or` instructions to merge the results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Packing and Unpacking Bit Strings
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common bit operation is inserting a bit string into an operand or extracting
    a bit string from an operand. [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION")
    provided simple examples of packing and unpacking such data; now it is time to
    formally describe how to do this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes we will assume that we're dealing with bit strings—that is,
    a contiguous sequence of bits. In [10.11 Extracting Bit Strings](ch10s11.html
    "10.11 Extracting Bit Strings") we'll look at how to extract and insert bit sets.
    Another simplification we'll make is that the bit string completely fits within
    a byte, word, or double-word operand. Large bit strings that cross object boundaries
    require additional processing; a discussion of bit strings that cross double-word
    boundaries appears later in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit string has two attributes that we must consider when packing and unpacking
    that bit string: a starting bit position and a length. The starting bit position
    is the bit number of the L.O. bit of the string in the larger operand. The length
    is the number of bits in the operand. To insert (pack) data into a destination
    operand, you start with a bit string of the appropriate length that is right justified
    (that is, starts in bit position 0) and is zero extended to 8, 16, or 32 bits.
    The task is to insert this data at the appropriate starting position in some other
    operand that is 8-, 16-, or 32-bits wide. There is no guarantee that the destination
    bit positions contain any particular value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and to shift (a copy of) the bit string so that
    the L.O. bit begins at the appropriate bit position. The third step is to `or`
    the shifted result with the destination operand. This inserts the bit string into
    the destination operand (see [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand")).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting a bit string into a destination operand](tagoreillycom20100401nostarchimages578073.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3. Inserting a bit string into a destination operand
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes only three instructions to insert a bit string of known length into
    a destination operand. The following three instructions demonstrate how to handle
    the insertion operation in [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand"). These instructions
    assume that the source operand is in BX and the destination operand is AX:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the length and the starting position aren''t known when you''re writing
    the program (that is, you have to calculate them at runtime), then bit-string
    insertion is a little more difficult. However, with the use of a lookup table
    it''s still an easy operation to accomplish. Let''s assume that we have two 8-bit
    values: a starting bit position for the field we''re inserting and a nonzero 8-bit
    length value. Also assume that the source operand is in EBX and the destination
    operand is in EAX. The code to insert one operand into another could take the
    following form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each entry in the `MaskByLen` table contains the number of 1 bits specified
    by the index into the table. Using the *`Length`* value as an index into this
    table fetches a value that has as many 1 bits as the *`Length`* value. The code
    above fetches an appropriate mask, shifts it to the left so that the L.O. bit
    of this run of ones matches the starting position of the field into which we want
    to insert the data, and then inverts the mask and uses the inverted value to clear
    the appropriate bits in the destination operand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting a bit string from a larger operand is just as easy as inserting
    a bit string into some larger operand. All you have to do is mask out the unwanted
    bits and then shift the result until the L.O. bit of the bit string is in bit
    0 of the destination operand. For example, to extract the 4-bit field starting
    at bit position 5 in EBX and leave the result in EAX, you could use the following
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you do not know the bit string''s length and starting position when you''re
    writing the program, you can still extract the desired bit string. The code is
    very similar to insertion (though a little simpler). Assuming you have the *`Length`*
    and *`StartingPosition`* values we used when inserting a bit string, you can extract
    the corresponding bit string using the following code (assuming source = EBX and
    dest = EAX):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The examples up to this point all assume that the bit string appears completely
    within a double-word (or smaller) object. This will always be the case if the
    bit string is less than or equal to 32 bits in length. However, if the length
    of the bit string plus its starting position (modulo 8) within an object is greater
    than 32, then the bit string will cross a double-word boundary within the object.
    Extracting such bit strings requires up to three operations: one operation to
    extract the start of the bit string (up to the first double-word boundary), an
    operation that copies whole double words (assuming the bit string is so long that
    it consumes several double words), and a final operation that copies leftover
    bits in the last double word at the end of the bit string. The actual implementation
    of this operation is left as an exercise for the reader.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Coalescing Bit Sets and Distributing Bit Strings
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting and extracting bit sets is little different than inserting and extract
    bit strings if the "shape" of the bit set you''re inserting (or resulting bit
    set you''re extracting) is the same as the bit set in the main object. The shape
    of a bit set is the distribution of the bits in the set, ignoring the starting
    bit position of the set. So a bit set that includes bits 0, 4, 5, 6, and 7 has
    the same shape as a bit set that includes bits 12, 16, 17, 18, and 19 because
    the distribution of the bits is the same. The code to insert or extract this bit
    set is nearly identical to that of the previous section; the only difference is
    the mask value you use. For example, to insert this bit set starting at bit 0
    in EAX into the corresponding bit set starting at position 12 in EBX, you could
    use the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, suppose you have 5 bits in bit positions 0 through 4 in EAX and you
    want to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to
    distribute the bits in EAX prior to logically `or`ing the values into EBX. Given
    the fact that this particular bit set has only two runs of 1 bits, the process
    is somewhat simplified. The following code achieves this in a somewhat sneaky
    fashion:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This trick with the `btr` (bit test and reset) instruction worked well because
    we had only 1 bit out of place in the original source operand. Alas, had the bits
    all been in the wrong location relative to one another, this scheme might not
    have worked quite as well. We'll see a more general solution in just a moment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting this bit set and collecting ("coalescing") the bits into a bit string
    is not quite as easy. However, there are still some sneaky tricks we can pull.
    Consider the following code that extracts the bit set from EBX and places the
    result into bits 0..4 of EAX:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code moves (original) bit 12 into bit position 7, the H.O. bit of AL. At
    the same time it moves bits 16..19 down to bits 11..14 (bits 3..6 of AH). Then
    the code shifts bits 3..6 in AH down to bit 0\. This positions the H.O. bits of
    the bit set so that they are adjacent to the bit left in AL. Finally, the code
    shifts all the bits down to bit 0\. Again, this is not a general solution, but
    it shows a clever way to attack this problem if you think about it carefully.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the coalescing and distribution algorithms above is that they
    are not general. They apply only to their specific bit sets. Usually specific
    solutions will provide the most efficient solution. A generalized solution (perhaps
    one that lets you specify a mask, and the code distributes or coalesces the bits
    accordingly) is going to be a bit more difficult. The following code demonstrates
    how to distribute the bits in a bit string according to the values in a bit mask:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the code above, if we load EDX with %1100_1001, then this code will copy
    bits 0..3 to bits 0, 3, 6, and 7 in EAX. Notice the short-circuit test that checks
    to see if we've exhausted the values in EDX (by checking for a 0 in EDX). Note
    that the rotate instructions do not affect the zero flag but the shift instructions
    do. Hence the `shr` instruction above will set the zero flag when there are no
    more bits to distribute (when EDX becomes 0).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The general algorithm for coalescing bits is a tad more efficient than distribution.
    Here''s the code that will extract bits from EBX via the bit mask in EDX and leave
    the result in EAX:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This sequence takes advantage of a sneaky trait of the shift and rotate instructions:
    the shift instructions affect the zero flag, whereas the rotate instructions do
    not. Therefore, the `shl( 1, edx );` instruction sets the zero flag when EDX becomes
    0 (after the shift). If the carry flag was also set, the code will make one additional
    pass through the loop in order to shift a bit into EAX, but the next time the
    code shifts EDX 1 bit to the left, EDX is still 0 and so the carry will be clear.
    On this iteration, the code falls out of the loop.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don't get too large), you can use that byte's value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This might produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to the reader.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Packed Arrays of Bit Strings
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it is far more efficient to create arrays whose elements have an integral
    number of bytes, it is quite possible to create arrays of elements whose size
    is not a multiple of 8 bits. The drawback is that calculating the "address" of
    an array element and manipulating that array element involves a lot of extra work.
    In this section we'll take a look at a few examples of packing and unpacking array
    elements in an array whose elements are an arbitrary number of bits long.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, it''s probably worthwhile to discuss why you would want
    to bother with arrays of bit objects. The answer is simple: space. If an object
    consumes only 3 bits, you can get 2.67 times as many elements into the same space
    if you pack the data rather than allocating a whole byte for each object. For
    very large arrays, this can be a substantial savings. Of course, the cost of this
    space savings is speed: You have to execute extra instructions to pack and unpack
    the data, thus slowing down access to the data.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access; it is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you calculate the element''s address in bits, you need to convert it to
    a byte address (because we have to use byte addresses when accessing memory) and
    extract the specified element. Because the base address of an array element (almost)
    always starts on a byte boundary, we can use the following equations to simplify
    this task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example, suppose we have an array of 200 3-bit objects that we declare
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The constant expression in the dimension above reserves space for enough bytes
    to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression
    adds 2 extra bytes at the end to ensure we don't lose any odd bits (that won't
    happen in this example because 600 is evenly divisible by 8, but in general you
    can't count on this; one extra byte usually won't hurt things) and also to allow
    us to access 1 byte beyond the end of the array (when storing data to the array).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits by using the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inserting an element into the array is a bit more difficult. In addition to
    computing the base address and bit offset of the array element, you also have
    to create a mask to clear out the bits in the destination where you're going to
    insert the new data. The following code inserts the L.O. 3 bits of EAX into the
    *i*th element of the `AO3Bobjects` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice the use of a lookup table to generate the masks needed to clear out the
    appropriate position in the array. Each element of this array contains all ones
    except for three zeros in the position we need to clear for a given bit offset
    (note the use of the `!` operator to invert the constants in the table).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Searching for a Bit
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common bit operation is to locate the end of some run of bits. A special
    case of this operation is to locate the first (or last) set or clear bit in a
    16- or 32-bit value. In this section we'll explore ways to accomplish this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Before describing how to search for the first or last bit of a given value,
    perhaps it's wise to discuss exactly what the terms *first* and *last* mean in
    this context. The term *first set bit* means the first bit in a value, scanning
    from bit 0 toward the high-order bit, which contains a 1\. A similar definition
    exists for the *first clear bit*. The *last set bit* is the first bit in a value,
    scanning from the high-order bit toward bit 0, which contains a 1\. A similar
    definition exists for the *last clear bit*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0) into
    the carry flag. The number of iterations specifies the position. Here''s some
    sample code that checks for the first set bit in EAX and returns that bit position
    in ECX:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only thing tricky about this code is the fact that it runs the loop counter
    from −32 up to 0 rather than 32 down to 0\. This makes it slightly easier to calculate
    the bit position once the loop terminates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The drawback to this particular loop is that it's expensive. This loop repeats
    as many as 32 times depending on the original value in EAX. If the values you're
    checking often have lots of zeros in the L.O. bits of EAX, this code runs rather
    slowly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the first (or last) set bit is such a common operation that Intel
    added a couple of instructions on the 80386 specifically to accelerate this process.
    These instructions are `bsf` (bit scan forward) and `bsr` (bit scan reverse).
    Their syntax is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The source and destinations operands must be the same size, and they must both
    be 16- or 32-bit objects. The destination operand has to be a register. The source
    operand can be a register or a memory location.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bsf` instruction scans for the first set bit (starting from bit position
    0) in the source operand. The `bsr` instruction scans for the last set bit in
    the source operand by scanning from the H.O. bit toward the L.O. bit. If these
    instructions find a bit that is set in the source operand, then they clear the
    zero flag and put the bit position into the destination register. If the source
    register contains 0 (that is, there are no set bits), then these instructions
    set the zero flag and leave an indeterminate value in the destination register.
    Note that you should test the zero flag immediately after the execution of these
    instructions to validate the destination register''s value. Here''s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You use the `bsr` instruction in an identical fashion except that it computes
    the bit position of the last set bit in an operand (that is, the first set bit
    it finds when scanning from the H.O. bit toward the L.O. bit).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 CPUs do not provide instructions to locate the first bit containing
    a 0\. However, you can easily scan for a 0 bit by first inverting the source operand
    (or a copy of the source operand if you must preserve the source operand's value)
    and then search for the first 1 bit; this corresponds to the first 0 bit in the
    original operand value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The `bsf` and `bsr` instructions are very complex 80x86 instructions. Therefore,
    these instructions may be slower than other instructions. Indeed, in some circumstances
    it may be faster to locate the first set bit using discrete instructions. However,
    because the execution time of these instructions varies widely from CPU to CPU,
    you should test the performance of these instructions prior to using them in time-critical
    code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `bsf` and `bsr` instructions do not affect the source operand.
    A common operation is to extract the first (or last) set bit you find in some
    operand. That is, you might want to clear the bit once you find it. If the source
    operand is a register (or you can easily move it into a register), then you can
    use the `btr` (or `btc`) instruction to clear the bit once you''ve found it. Here''s
    some code that achieves this result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At the end of this sequence, the zero flag indicates whether we found a bit
    (note that `btr` does not affect the zero flag). Alternately, you could add an
    `else` section to the `if` statement above that handles the case when the source
    operand (EAX) contains 0 at the beginning of this instruction sequence.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Because the `bsf` and `bsr` instructions support only 16- and 32-bit operands,
    you will have to compute the first bit position of an 8-bit operand a little differently.
    There are a couple of reasonable approaches. First, of course, you can usually
    zero extend an 8-bit operand to 16 or 32 bits and then use the `bsf` or `bsr`
    instruction on this operand. Another alternative is to create a lookup table where
    each entry in the table contains the number of bits in the value you use as an
    index into the table; then you can use the `xlat` instruction to "compute" the
    first bit position in the value (note that you will have to handle the value 0
    as a special case). Another solution is to use the shift algorithm appearing at
    the beginning of this section; for an 8-bit operand, this is not an entirely inefficient
    solution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: One interesting use of the `bsf` and `bsr` instructions is to fill in a character
    set with all the values from the lowest valued character in the set through the
    highest valued character. For example, suppose a character set contains the values
    `{'A', 'M', 'a'..'n', 'z'}`; if we filled in the gaps in this character set we
    would have the values `{'A'..'z'}`. To compute this new set we can use `bsf` to
    determine the ASCII code of the first character in the set and `bsr` to determine
    the ASCII code of the last character in the set. After doing this, we can feed
    those two ASCII codes to the HLA Standard Library `cs.rangeChar` function to compute
    the new set.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `bsf` and `bsr` instructions to determine the size of a
    run of bits, assuming that you have a single run of bits in your operand. Simply
    locate the first and last bits in the run (as above) and then compute the difference
    (plus 1) of the two values. Of course, this scheme is valid only if there are
    no intervening zeros between the first and last set bits in the value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Counting Bits
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last example in the previous section demonstrates a specific case of a
    very general problem: counting bits. Unfortunately, that example has a severe
    limitation: It only counts a single run of 1 bits appearing in the source operand.
    This section discusses a more general solution to this problem.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardly a week goes by that someone doesn''t ask on one of the Internet newsgroups
    how to count the number of bits in a register operand. This is a common request,
    undoubtedly, because many assembly language course instructors assign this task
    as a project to their students as a way to teach them about the shift and rotate
    instructions. Undoubtedly, the solution these instructors expect is something
    like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The "trick" worth noting here is that this code uses the `adc` instruction to
    add the value of the carry flag into the BL register. Because the count is going
    to be less than 32, the result will fit comfortably into BL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Tricky code or not, this instruction sequence is not particularly fast. As
    you can tell with just a small amount of analysis, the loop above always executes
    32 times, so this code sequence executes 130 instructions (4 instructions per
    iteration plus 2 extra instructions). You might ask if there is a more efficient
    solution; the answer is yes. The following code, taken from the AMD Athlon optimization
    guide, provides a faster solution (see the comments for a description of the algorithm):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 10.9 Reversing a Bit String
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common programming project instructors assign, and a useful function
    in its own right, is a program that reverses the bits in an operand. That is,
    it swaps the L.O. bit with the H.O. bit, bit 1 with the next-to-H.O. bit, and
    so on. The typical solution an instructor probably expects for this assignment
    is the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As with the previous examples, this code suffers from the fact that it repeats
    the loop 32 times, for a grand total of 129 instructions. By unrolling the loop
    you can get it down to 64 instructions, but this is still somewhat expensive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the best solution to an optimization problem is often a better algorithm
    rather than attempting to tweak your code by trying to choose faster instructions
    to speed up some code. However, a little intelligence goes a long way when manipulating
    bits. In the last section, for example, we were able to speed up counting the
    bits in a string by substituting a more complex algorithm for the simplistic "shift
    and count" algorithm. In the example above, we are once again faced with a very
    simple algorithm with a loop that repeats for 1 bit in each number. The question
    is "Can we discover an algorithm that doesn't execute 129 instructions to reverse
    the bits in a 32-bit register?" The answer is yes, and the trick is to do as much
    work as possible in parallel.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that all we wanted to do was swap the even and odd bits in a 32-bit
    value. We can easily swap the even and odd bits in EAX using the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, swapping the even and odd bits, while somewhat interesting, does
    not solve our larger problem of reversing all the bits in the number. But it does
    take us part of the way there. For example, if after executing the preceding code
    sequence you swap adjacent pairs of bits, you''ve managed to swap the bits in
    all the nibbles in the 32-bit value. Swapping adjacent pairs of bits is done in
    a manner very similar to the above; the code is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After completing the preceding sequence, you swap the adjacent nibbles in the
    32-bit register. Again, the only difference is the bit mask and the length of
    the shifts. Here''s the code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can probably see the pattern developing and can figure out that in the
    next two steps you have to swap the bytes and then the words in this object. You
    can use code like the above, but there is a better way: Use the `bswap` instruction.
    The `bswap` (byte swap) instruction uses the following syntax:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This instruction swaps bytes 0 and 3, and it swaps bytes 1 and 2 in the specified
    32-bit register. The principle use of this instruction is to convert data between
    the so-called little-endian and big-endian data formats.^([[127](#ftn.CHP-10-FN-2)])
    Although you don''t specifically use this instruction for this purpose here, the
    bswap instruction does swap the bytes and words in a 32-bit object exactly the
    way you want them when reversing bits. Rather than sticking in another 12 instructions
    to swap the bytes and then the words, you can simply use a `bswap( eax );` instruction
    to complete the job after the instructions above. The final code sequence is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This algorithm requires only 19 instructions, and it executes much faster than
    the bit-shifting loop appearing earlier. Of course, this sequence does consume
    a little more memory. If you're trying to save memory rather than clock cycles,
    the loop is probably a better solution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ^([[127](#CHP-10-FN-2)]) In the little-endian system, which is the native 80x86
    format, the L.O. byte of an object appears at the lowest address in memory. In
    the big-endian system, which various RISC processors use, the H.O. byte of an
    object appears at the lowest address in memory. The `bswap` instruction converts
    between these two data formats.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 10.10 Merging Bit Strings
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common bit string operation is producing a single bit string by merging,
    or interleaving, bits from two different sources. The following example code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This particular example merged two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unrolling
    the loop is probably your best bet because this eliminates half the instructions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few slight modifications, we could also have merged four 8-bit values
    together, or we could have generated the result using other bit sequences. For
    example, the following code copies bits 0..5 from EAX, then bits 0..4 from EBX,
    then bits 6..11 from EAX, then bits 5..15 from EBX, and finally bits 12..15 from
    EAX:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 10.11 Extracting Bit Strings
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we can easily accomplish the converse of merging two bit streams;
    that is, we can extract and distribute bits in a bit string among multiple destinations.
    The following code takes the 32-bit value in EAX and distributes alternate bits
    among the BX and DX registers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This sequence executes 99 instructions. This isn't terrible, but we can probably
    do a little better by using an algorithm that extracts bits in parallel. Employing
    the technique we used to reverse bits in a register, we can come up with the following
    algorithm that relocates all the even bits to the L.O. word of EAX and all the
    odd bits to the H.O. word of EAX.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This sequence requires 30 instructions. At first blush it looks like a winner
    because the original loop executes 64 instructions. However, this code isn't quite
    as good as it looks. After all, if we're willing to write this much code, why
    not unroll the loop above 16 times? That sequence requires only 64 instructions.
    So the complexity of the previous algorithm may not gain much on instruction count.
    As to which sequence is faster, well, you'll have to time them to figure this
    out. However, the `shrd` instructions are not particularly fast on all processors
    and neither are the instructions in the other sequence. This example appears here
    not to show you a better algorithm but rather to demonstrate that writing really
    tricky code doesn't always provide a big performance boost.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Extracting other bit combinations is left as an exercise for the reader.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 10.12 Searching for a Bit Pattern
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of %1011 starting at some particular position in
    a bit string. In this section we'll explore some simple algorithms to accomplish
    this task.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for a particular bit pattern we''re going to need to know four things:
    (1) the pattern to search for (the *pattern*), (2) the length of the pattern we''re
    searching for, (3) the bit string that we''re going to search through (the *source*),
    and (4) the length of the bit string to search through. The basic idea behind
    the search is to create a mask based on the length of the pattern and mask a copy
    of the source with this value. Then we can directly compare the pattern with the
    masked source for equality. If they are equal, you''re finished; if they''re not
    equal, then increment a bit position counter, shift the source one position to
    the right, and try again. You repeat this operation `length(`*`source`*`) - length(`*`pattern`*`)`
    times. The algorithm fails if it does not detect the bit pattern after this many
    attempts (because we will have exhausted all the bits in the source operand that
    could match the pattern''s length). Here''s a simple algorithm that searches for
    a 4-bit pattern throughout the EBX register:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Bit-string scanning is a special case of string matching. String matching is
    a well-studied problem in computer science, and many of the algorithms you can
    use for string matching are applicable to bit-string matching as well. Such algorithms
    are beyond the scope of this chapter, but to give you a preview of how this works,
    you compute some function (like `xor` or `sub`) between the pattern and the current
    source bits and use the result as an index into a lookup table to determine how
    many bits you can skip. Such algorithms let you skip several bits rather than
    shifting only once for each iteration of the scanning loop (as is done by the
    previous algorithm).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 10.13 The HLA Standard Library Bits Module
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA Standard Library provides the `bits.hhf` module that provides several
    bit-related functions, including built-in functions for many of the algorithms
    we've studied in this chapter. This section describes some of the functions available
    in the HLA Standard Library.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This procedure returns the number of 1 bits present in the `b` parameter. It
    returns the count in the EAX register. To count the number of 0 bits in the parameter
    value, invert the value of the parameter before passing it to `bits.cnt`. If you
    want to count the number of bits in a 16-bit operand, simply zero extend it to
    32 bits prior to calling this function. Here are a couple of examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to compute the number of bits in an 8-bit operand, it's probably
    faster to write a simple loop that rotates all the bits in the source operand
    and adds the carry into the accumulating sum. Of course, if performance isn't
    an issue, you can zero extend the byte to 32 bits and call the `bits.cnt` procedure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function takes the L.O. *n* bits of `source`, where *n* is the number of
    1 bits in `mask`, and inserts these bits into `dest` at the bit positions specified
    by the 1 bits in `mask` (that is, the same as the distribute algorithm appearing
    earlier in this chapter). This function does not change the bits in `dest` that
    correspond to the zeros in the `mask` value. This function does not affect the
    value of the actual `dest` parameter; it returns the new value in the EAX register.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function is the converse of `bits.distribute`. It extracts all the bits
    in source whose corresponding positions in `mask` contain a 1\. This function
    coalesces (right justifies) these bits in the L.O. bit positions of the result
    and returns the result in EAX.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function extracts the first set bit in `d` searching from bit 0 and returns
    the index of this bit in the EAX register; the function also returns the zero
    flag clear in this case. This function also clears that bit in the operand. If
    `d` contains 0, then this function returns the zero flag set and EAX will contain
    −1.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that HLA actually implements this function as a macro, not a procedure.
    This means that you can pass any double-word operand as a parameter (a memory
    or a register operand). However, the results are undefined if you pass EAX as
    the parameter (because this function computes the bit number in EAX).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These three routines return their parameter value with its bits reversed in
    the accumulator register (AL/AX/EAX). Call the routine appropriate for your data
    size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These routines merge two streams of bits to produce a value whose size is the
    combination of the two parameters. The bits from the `even` parameter occupy the
    even bit positions in the result; the bits from the `odd` parameter occupy the
    odd bit positions in the result. Notice that these functions return 16, 32, or
    64 bits based on byte, word, and double-word parameter values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These routines extract each nibble from the parameter and place those nibbles
    into individual bytes. The `bits.nibbles8` function extracts the two nibbles from
    the `b` parameter and places the L.O. nibble in AL and the H.O. nibble in AH.
    The `bits.nibbles16` function extracts the four nibbles in `w` and places them
    in each of the 4 bytes of EAX. You can use the `bswap` or rox instructions to
    gain access to the nibbles in the H.O. word of EAX. The `bits.nibbles32` function
    extracts the eight nibbles in EAX and distributes them through the 8 bytes in
    EDX:EAX. Nibble 0 winds up in AL and nibble 7 winds up in the H.O. byte of EDX.
    Again, you can use `bswap` or the rotate instructions to access the upper bytes
    of EAX and EDX.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 10.14 For More Information
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The electronic edition of The Art of Assembly Language at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    and [http://www.artofasm.com/](http://www.artofasm.com/) contains some additional
    information you may find useful when developing bit-manipulation algorithms. In
    particular, the chapter on digital design discusses boolean algebra, a subject
    that you will find essential when working with bits. The HLA Standard Library
    reference manual contains more information about the HLA Standard Library bit-manipulation
    routines. See that documentation on the website for more information about those
    functions. As noted in the section on bit counting, the AMD Athlon optimization
    guide contains some useful algorithms for bit-based computations. Finally, to
    learn more about bit searching algorithms, you should pick up a textbook on data
    structures and algorithms and study the section on string-matching algorithms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
