- en: Chapter 10. BIT MANIPULATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 位操作
- en: '![BIT MANIPULATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![位操作](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: Manipulating bits in memory is, perhaps, the feature for which assembly language
    is most famous. Indeed, one of the reasons people claim that the C programming
    language is a medium-level language rather than a high-level language is because
    of the vast array of bit-manipulation operators that C provides. Even with this
    wide array of bit-manipulation operations, the C programming language doesn't
    provide as complete a set of bit-manipulation operations as assembly language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作内存中的位或许是汇编语言最著名的特性之一。确实，人们宣称C语言是一种中级语言而不是高级语言的原因之一，是因为C语言提供了大量的位操作符。即便有了这如此广泛的位操作功能，C语言提供的位操作集合仍不如汇编语言完整。
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    using 80x86 assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, and it also introduces a few new instructions.
    This chapter reviews information on packing and unpacking bit strings in memory
    because this is the basis for many bit-manipulation operations. Finally, this
    chapter discusses several bit-centric algorithms and their implementation in assembly
    language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何使用80x86汇编语言操作内存和寄存器中的位字符串。它从回顾到目前为止涉及的位操作指令开始，并介绍了一些新的指令。本章回顾了在内存中打包和解包位字符串的信息，因为这是许多位操作的基础。最后，本章讨论了几个以位为中心的算法及其在汇编语言中的实现。
- en: 10.1 What Is Bit Data, Anyway?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 什么是位数据？
- en: Before describing how to manipulate bits, it might not be a bad idea to define
    exactly what this text means by *bit data*. Most readers probably assume that
    bit-manipulation programs twiddle individual bits in memory. While programs that
    do this are definitely bit-manipulation programs, we're not going to limit our
    definition to just those programs. For our purposes, *bit manipulation* refers
    to working with data types that consist of strings of bits that are noncontiguous
    or are not a multiple of 8 bits long. Generally, such bit objects will not represent
    numeric integers, although we will not place this restriction on our bit strings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何操作位之前，最好先明确一下本书中*位数据*的具体含义。大多数读者可能会认为位操作程序是修改内存中的单个位。虽然这样的程序无疑是位操作程序，但我们不会将定义仅限于这些程序。就我们的目的而言，*位操作*是指处理由非连续位字符串或长度不是8位的倍数的位数据类型。通常，这样的位对象不会表示数值整数，尽管我们并不会对我们的位字符串做出这一限制。
- en: A *bit string* is some contiguous sequence of one or more bits. Note that a
    bit string does not have to start or end at any special point. For example, a
    bit string could start in bit 7 of one byte in memory and continue through to
    bit 6 of the next byte in memory. Likewise, a bit string could begin in bit 30
    of EAX, consume the upper 2 bits of EAX, and then continue from bit 0 through
    bit 17 of EBX. In memory, the bits must be physically contiguous (that is, the
    bit numbers are always increasing except when crossing a byte boundary, and at
    byte boundaries the memory address increases by 1 byte). In registers, if a bit
    string crosses a register boundary, the application defines the continuation register,
    but the bit string always continues in bit 0 of that second register.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*位字符串*是一个连续的由一个或多个比特组成的序列。请注意，位字符串不必从任何特定位置开始或结束。例如，位字符串可以从内存中一个字节的第7个位开始，继续到下一个字节的第6个位。同样，位字符串可以从EAX的第30个位开始，消耗EAX的上2个位，然后从EBX的第0个位到第17个位继续。在内存中，位必须是物理连续的（即，位编号总是递增，除非跨越字节边界，而在字节边界时，内存地址增加1字节）。在寄存器中，如果位字符串跨越了寄存器边界，应用程序定义继续的寄存器，但位字符串总是从第二个寄存器的第0个位开始继续。'
- en: A *bit set* is a collection of bits, not necessarily contiguous, within some
    larger data structure. For example, bits 0..3, 7, 12, 24, and 31 from some double
    word form a set of bits. Usually, we will limit bit sets to some reasonably sized
    *container object* (the data structure that encapsulates the bit set), but the
    definition doesn't specifically limit the size. Normally, we will deal with bit
    sets that are part of an object no more than about 32 or 64 bits in size, though
    this limit is completely artificial. Note that bit strings are special cases of
    bit sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*位集合*是一个位的集合，这些位不一定是连续的，位于某个较大的数据结构内。例如，某个双字中的位0..3、7、12、24和31构成一个位集合。通常，我们会将位集合限制为某个合理大小的*容器对象*（封装位集合的数据结构），但该定义并没有特别限制其大小。通常，我们会处理大小不超过32或64位的位集合，尽管这个限制是完全人为设定的。请注意，位串是位集合的特例。'
- en: A *bit run* is a sequence of bits with all the same value. A *run of zeros*
    is a bit string that contains all zeros, and a *run of ones* is a bit string containing
    all ones. The *first set bit* in a bit string is the bit position of the first
    bit containing a 1 in a bit string, that is, the first 1 bit following a possible
    run of zeros. A similar definition exists for the *first clear bit*. The *last
    set bit* is the last bit position in a bit string that contains 1; the remainder
    of the string forms an uninterrupted run of zeros. A similar definition exists
    for the *last clear bit*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*位串*是一个所有位值相同的位序列。*零串*是一个只包含零的位串，*一串*是一个只包含一的位串。*第一个置位*是指在位串中第一个包含1的位的位置，也就是可能在零串后的第一个1位。*第一个清除位*也有类似的定义。*最后一个置位*是指在位串中最后一个包含1的位位置；位串的其余部分形成一个不间断的零串。*最后一个清除位*也有类似的定义。'
- en: A *bit offset* is the number of bits from some boundary position (usually a
    byte boundary) to the specified bit. As noted in [Chapter 2](ch02.html "Chapter 2. DATA
    REPRESENTATION"), we number the bits starting from 0 at the boundary location.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*位偏移*是指从某个边界位置（通常是字节边界）到指定位的位数。如[第2章](ch02.html "第2章. 数据表示")所述，我们从边界位置的0开始编号每一位。'
- en: A *mask* is a sequence of bits that we'll use to manipulate certain bits in
    another value. For example, the bit string %0000_1111_0000, when it's used with
    the and instruction, can mask away (clear) all the bits except bits 4 through
    7\. Likewise, if you use the same value with the or instruction, it can force
    bits 4 through 7 to ones in the destination operand. The term *mask* comes from
    the use of these bit strings with the `and` instruction; in those situations the
    1 and 0 bits behave like masking tape when you're painting something; they pass
    through certain bits unchanged while masking out (clearing) the other bits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*掩码*是一个位的序列，我们将用它来操作另一个值中的某些位。例如，位串%0000_1111_0000，当与`and`指令一起使用时，可以屏蔽掉（清除）所有位，只留下位4到7的位。类似地，如果你使用相同的值与`or`指令一起使用，它可以将目标操作数中的位4到7强制为1。术语*掩码*来源于这些位串与`and`指令的结合使用；在这种情况下，1和0的位像遮蔽胶带一样使用；它们通过某些位而不改变这些位，同时遮蔽（清除）其他位。'
- en: Armed with these definitions, we're ready to start manipulating some bits!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这些定义后，我们已经准备好开始操作一些位了！
- en: 10.2 Instructions That Manipulate Bits
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.2 操作位的指令
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. By now you should be familiar with most
    of the instructions we''ll use to perform these operations; their introduction
    started way back in the earliest chapters of this text. Nevertheless, it''s worthwhile
    to review the old instructions here as well as present the few bit-manipulation
    instructions we''ve yet to consider.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 位操作通常包括六个活动：设置位、清除位、反转位、测试和比较位、从位串中提取位、以及将位插入位串。到目前为止，你应该已经熟悉了我们用来执行这些操作的大部分指令；这些指令的介绍可以追溯到本书最早的章节。然而，回顾一下旧的指令并介绍我们尚未考虑的几条位操作指令，仍然是值得的。
- en: The most basic bit-manipulation instructions are the `and`, `or`, `xor`, `not`,
    `test`, and shift and rotate instructions. Indeed, on the earliest 80x86 processors,
    these were the only instructions available for bit manipulation. The following
    paragraphs review these instructions, concentrating on how you could use them
    to manipulate bits in memory or registers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The `and` instruction provides the ability to strip away unwanted bits from
    some bit sequence, replacing the unwanted bits with zeros. This instruction is
    especially useful for isolating a bit string or a bit set that is merged with
    other, unrelated data (or, at least, data that is not part of the bit string or
    bit set). For example, suppose that a bit string consumes bit positions 12 through
    24 of the EAX register; we can isolate this bit string by setting all other bits
    in EAX to 0 by using the following instruction:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most programs use the `and` instruction to clear bits that are not part of the
    desired bit string. In theory, you could use the `or` instruction to mask all
    unwanted bits to ones rather than zeros, but later comparisons and operations
    are often easier if the unneeded bit positions contain 0 (see [Figure 10-1](ch10s02.html#isolating_a_bit_string_using_the_and_ins
    "Figure 10-1. Isolating a bit string using the and instruction")).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating a bit string using the and instruction](tagoreillycom20100401nostarchimages578069.png.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. Isolating a bit string using the `and` instruction
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see if the string of bits in positions
    12 through 24 of EAX contains $12F3, you could use the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s another solution, using constant expressions, that''s a little easier
    to digest:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of the time, however, you''ll want (or need) the bit string aligned with
    bit 0 in EAX prior to any operations you would want to perform. Of course, you
    can use the `shr` instruction to properly align the value after you''ve masked
    it, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that the bit string is aligned to bit 0, the constants and other values
    you use in conjunction with this value are easier to deal with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `or` instruction to mask unwanted bits. However, the `or`
    instruction does not let you clear bits; it allows you to set bits to ones. In
    some instances setting all the bits around your bit set may be desirable; most
    software, however, is easier to write if you clear the surrounding bits rather
    than set them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The `or` instruction is especially useful for inserting a bit set into some
    other bit string. To do this, there are several steps you must go through:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Clear all the bits surrounding your bit set in the source operand.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all the bits in the destination operand where you wish to insert the bit
    set.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or` the bit set and destination operand together.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, suppose you have a value in bits 0..12 of EAX that you wish to
    insert into bits 12..24 of EBX without affecting any of the other bits in EBX.
    You would begin by stripping out bits 13 and above from EAX; then you would strip
    out bits 12..24 in EBX. Next, you would shift the bits in EAX so the bit string
    occupies bits 12..24 of EAX. Finally, you would `or` the value in EAX into EBX
    (see [Figure 10-2](ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12 "Figure 10-2. Inserting
    bits 0..12 of EAX into bits 12..24 of EBX")), as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你希望将EAX的位0..12中的值插入到EBX的位12..24中，而不影响EBX中的其他位。你将首先从EAX中去除位13及以上的位；然后从EBX中去除位12..24的位。接下来，你将位移EAX中的位，使得位串占据EAX的位12..24。最后，你将EAX中的值通过`or`操作插入到EBX中（参见[图10-2](ch10s02.html#inserting_bits_0..12_of_eax_into_bits_12
    "图10-2. 将EAX的位0..12插入EBX的位12..24")），如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Inserting bits 0..12 of EAX into bits 12..24 of EBX](tagoreillycom20100401nostarchimages578071.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![将EAX的位0..12插入EBX的位12..24](tagoreillycom20100401nostarchimages578071.png.jpg)'
- en: Figure 10-2. Inserting bits 0..12 of EAX into bits 12..24 of EBX
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2. 将EAX的位0..12插入EBX的位12..24
- en: In this figure the desired bits (AAAAAAAAAAAAA) formed a bit string. However,
    this algorithm still works fine even if you're manipulating a noncontiguous set
    of bits. All you have to do is to create an appropriate bit mask you can use for
    `and`ing that has ones in the appropriate places.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，期望的位（AAAAAAAAAAAAA）形成了一个位串。然而，即使你正在操作一个非连续的位集合，这个算法仍然能够正常工作。你只需创建一个适当的位掩码，用于`and`操作，并在适当的位置填充1即可。
- en: 'When working with bit masks, it is incredibly poor programming style to use
    literal numeric constants as in the past few examples. You should always create
    symbolic constants in the HLA `const` (or `val`) section for your bit masks. Combined
    with some constant expressions, you can produce code that is much easier to read
    and maintain. The current example code is more properly written as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用位掩码时，像前面几个例子那样使用字面数值常量是非常不好的编程风格。你应该始终在HLA的`const`（或`val`）部分为你的位掩码创建符号常量。结合一些常量表达式，你可以编写出更易读和更易维护的代码。当前的示例代码更恰当的写法如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the use of the compile time `not` operator (`!`) to invert the bit mask
    in order to clear the bit positions in EBX where the code inserts the bits from
    EAX. This saves having to create another constant in the program that has to be
    changed anytime you modify the `BitMask` constant. Having to maintain two separate
    symbols whose values are dependent on one another is not a good thing in a program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用编译时的`not`运算符（`!`）来反转位掩码，以便清除EBX中代码插入EAX中的位的位位置。这样就不需要在程序中创建另一个常量，并且每次修改`BitMask`常量时都需要更新它。程序中维护两个相互依赖的符号并不是一个好习惯。
- en: Of course, in addition to merging one bit set with another, the `or` instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can force the corresponding bits in the destination
    operand to 1 by using the `or` instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了将一个位集合与另一个合并外，`or`指令也非常适用于强制将位设置为1。在源操作数中将不同的位设置为1后，你可以通过使用`or`指令将目标操作数中的相应位强制设置为1。
- en: The `xor` instruction allows you to invert selected bits in a bit set. Although
    inverting bits isn't as common as setting or clearing them, the `xor` instruction
    often appears in bit-manipulation programs. Of course, if you want to invert all
    the bits in some destination operand, the `not` instruction is probably more appropriate
    than the `xor` instruction; however, to invert selected bits while not affecting
    others, the `xor` is the way to go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`指令允许你反转位集合中的选定位。虽然反转位不像设置或清除位那么常见，但`xor`指令在位操作程序中经常出现。当然，如果你想反转某个目标操作数中的所有位，`not`指令可能比`xor`指令更合适；然而，要反转选定的位而不影响其他位时，`xor`是更合适的选择。'
- en: 'One interesting fact about `xor`''s operation is that it lets you manipulate
    known data in just about any way imaginable. For example, if you know that a field
    contains %1010, you can force that field to 0 by `xor`ing it with %1010\. Similarly,
    you can force it to %1111 by `xor`ing it with %0101\. Although this might seem
    like a waste, because you can easily force this 4-bit string to 0 or all ones
    using `and`/`or`, the `xor` instruction has two advantages: (1) You are not limited
    to forcing the field to all zeros or all ones; you can actually set these bits
    to any of the 16 valid combinations via `xor`; and (2) if you need to manipulate
    other bits in the destination operand at the same time, `and`/`or` may not be
    able to accommodate you. For example, suppose that you know that one field contains
    %1010 that you want to force to 0 and another field contains %1000 and you wish
    to increment that field by 1 (i.e., set the field to %1001). You cannot accomplish
    both operations with a single `and` or `or` instruction, but you can do this with
    a single `xor` instruction; just `xor` the first field with %1010 and the second
    field with `%0001`. Remember, however, that this trick works only if you know
    the current value of a bit set within the destination operand. Of course, while
    you''re adjusting the values of bit fields containing known values, you can invert
    bits in other fields simultaneously.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor` 操作的一个有趣事实是，它让你能够以几乎任何可想象的方式操作已知数据。例如，如果你知道某个字段包含 %1010，你可以通过与 %1010 进行
    `xor` 操作将该字段强制为 0。同样，你也可以通过与 %0101 进行 `xor` 操作将其强制为 %1111。虽然这看起来可能是一种浪费，因为你可以很容易地通过
    `and`/`or` 将这个 4 位字符串强制为 0 或全部为 1，但 `xor` 指令有两个优点：（1）你不仅仅局限于将字段强制为全零或全一；你实际上可以通过
    `xor` 将这些位设置为 16 种有效组合中的任何一种；（2）如果你需要同时操作目标操作数中的其他位，`and`/`or` 可能无法满足你的需求。例如，假设你知道一个字段包含
    %1010，你想将其强制为 0，另一个字段包含 %1000，你希望将该字段加 1（即将字段设置为 %1001）。你无法通过单个 `and` 或 `or` 指令完成这两个操作，但你可以通过单个
    `xor` 指令做到；只需将第一个字段与 %1010 进行 `xor`，将第二个字段与 `%0001` 进行 `xor`。然而，请记住，这个技巧仅在你知道目标操作数中某个位的当前值时才有效。当然，在你调整包含已知值的位字段时，你还可以同时翻转其他字段中的位。'
- en: 'In addition to setting, clearing, and inverting bits in some destination operand,
    the `and`, `or`, and `xor` instructions also affect various condition codes in
    the flags register. These instructions affect the flags as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在某些目标操作数中设置、清除和翻转位外，`and`、`or` 和 `xor` 指令还会影响标志寄存器中的各种条件码。这些指令会按以下方式影响标志：
- en: These instructions always clear the carry and overflow flags.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些指令始终会清除进位标志和溢出标志。
- en: These instructions set the sign flag if the result has a 1 in the H.O. bit;
    they clear it otherwise. That is, these instructions copy the H.O. bit of the
    result into the sign flag.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果的最高有效位是 1，这些指令会设置符号标志；否则，它们会清除符号标志。也就是说，这些指令将结果的最高有效位复制到符号标志中。
- en: These instructions set/clear the zero flag if the result is 0.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果为 0，这些指令会设置/清除零标志。
- en: These instructions set the parity flag if there is an even number of set bits
    in the L.O. byte of the destination operand; they clear the parity flag if there
    is an odd number of 1 bits in the L.O. byte of the destination operand.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标操作数的低字节中有偶数个已设置的位，这些指令会设置奇偶标志；如果目标操作数的低字节中有奇数个 1 位，这些指令会清除奇偶标志。
- en: The first thing to note is that these instructions always clear the carry and
    overflow flags. This means that you cannot expect the system to preserve the state
    of these two flags across the execution of these instructions. A very common mistake
    in many assembly language programs is the assumption that these instructions do
    not affect the carry flag. Many people will execute an instruction that sets/clears
    the carry flag, execute an `and`/`or`/`xor` instruction, and then attempt to test
    the state of the carry from the previous instruction. This simply will not work.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这些指令始终会清除进位标志和溢出标志。这意味着你不能期望系统在执行这些指令后保留这两个标志的状态。许多汇编语言程序中一个非常常见的错误是假设这些指令不会影响进位标志。很多人会执行一个设置/清除进位标志的指令，然后执行
    `and`/`or`/`xor` 指令，再尝试测试之前指令的进位标志状态。这显然是行不通的。
- en: One of the more interesting aspects to these instructions is that they copy
    the H.O. bit of their result into the sign flag. This means that you can easily
    test the setting of the H.O. bit of the result by testing the sign flag (using
    `sets/setns` or `js`/`jns` instructions, or using the `@s`/`@ns` flags in a boolean
    expression). For this reason, many assembly language programmers will often place
    an important boolean variable in the H.O. bit of some operand so they can easily
    test the state of that bit using the sign flag after a logical operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的一个有趣的方面是，它们将结果的最高有效位（H.O.位）复制到符号标志中。这意味着你可以通过测试符号标志（使用`sets/setns`或`js`/`jns`指令，或者在布尔表达式中使用`@s`/`@ns`标志）轻松测试结果的H.O.位的设置。因此，许多汇编语言程序员常常将一个重要的布尔变量放置在某个操作数的H.O.位中，这样他们就可以在进行逻辑操作后，通过符号标志轻松测试该位的状态。
- en: We haven't talked much about the parity flag in this text. We're not going to
    get into a big discussion of this flag and what you use it for because the primary
    purpose for this flag has been taken over by hardware.^([[126](#ftn.CHP-10-FN-1)])
    However, because this is a chapter on bit manipulation, and parity computation
    is a bit-manipulation operation, it seems only fitting to provide a brief discussion
    of the parity flag at this time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们没有太多讨论奇偶标志。我们不会深入讨论这个标志及其用途，因为该标志的主要用途已经被硬件所接管。^([[126](#ftn.CHP-10-FN-1)])
    然而，因为这是关于位操作的章节，而奇偶计算是一个位操作，所以现在简要讨论奇偶标志似乎是合适的。
- en: Parity is a very simple error-detection scheme originally employed by telegraphs
    and other serial communication protocols. The idea was to count the number of
    set bits in a character and include an extra bit in the transmission to indicate
    whether that character contained an even or odd number of set bits. The receiving
    end of the transmission would also count the bits and verify that the extra "parity"
    bit indicated a successful transmission. We're not going to explore the information-theory
    aspects of this error-checking scheme at this point other than to point out that
    the purpose of the parity flag is to help compute the value of this extra bit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶是一个非常简单的错误检测方案，最早由电报和其他串行通信协议使用。其原理是计算字符中设置位的数量，并在传输中添加一个额外的位，以指示该字符包含偶数或奇数个设置位。接收端也会计算位并验证额外的“奇偶”位是否表示传输成功。我们此时不会深入探讨这种错误检查方案的信息理论方面，只是指出奇偶标志的目的是帮助计算这个额外位的值。
- en: 'The 80x86 `and`, `or`, and `xor` instructions set the parity bit if the L.O.
    byte of their operand contains an even number of set bits. An important fact bears
    repeating here: The parity flag reflects only the number of set bits in the L.O.
    byte of the destination operand; it does not include the H.O. bytes in a word,
    double-word, or other-sized operand. The instruction set uses the L.O. byte only
    to compute the parity because communication programs that use parity are typically
    character-oriented transmission systems (there are better error-checking schemes
    if you transmit more than 8 bits at a time).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的`and`、`or`和`xor`指令会在其操作数的最低有效字节（L.O.字节）中包含偶数个设置位时设置奇偶位。这里有一个重要的事实需要重申：奇偶标志仅反映目标操作数的L.O.字节中设置位的数量；它不包括字、双字或其他大小操作数中的H.O.字节。指令集仅使用L.O.字节来计算奇偶性，因为使用奇偶性的通信程序通常是面向字符的传输系统（如果一次传输超过8位，通常有更好的错误检查方案）。
- en: The zero flag setting is one of the more important results the `and`/`or`/`xor`
    instructions produce. Indeed, programs reference this flag so often after the
    `and` instruction that Intel added a separate instruction, `test`, whose main
    purpose is to logically `and` two results and set the flags without otherwise
    affecting either instruction operand.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志的设置是`and`/`or`/`xor`指令产生的更重要的结果之一。实际上，程序在`and`指令之后如此频繁地引用这个标志，以至于英特尔添加了一个单独的指令`test`，其主要目的是对两个结果进行逻辑`and`操作并设置标志，而不会对任何指令操作数产生其他影响。
- en: 'There are three main uses of the zero flag after the execution of an `and`
    or `test` instruction: (1) checking to see if a particular bit in an operand is
    set, (2) checking to see if at least one of several bits in a bit set is 1, and
    (3) checking to see if an operand is 0\. Using (1) is actually a special case
    of (2) in which the bit set contains only a single bit. We''ll explore each of
    these uses in the following paragraphs.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `and` 或 `test` 指令后，零标志有三种主要用途：（1）检查操作数中的某一特定位是否为1，（2）检查位集中的多个位中是否有至少一个为1，以及（3）检查操作数是否为0。使用（1）实际上是（2）的特例，其中位集仅包含一个位。我们将在接下来的段落中探讨这些用途。
- en: 'A common use for the `and` instruction, and also the original reason for the
    inclusion of the `test` instruction in the 80x86 instruction set, is to test to
    see if a particular bit is set in a given operand. To perform this type of test,
    you would normally `and`/`test` a constant value containing a single set bit with
    the operand you wish to test. This clears all the other bits in the second operand,
    leaving a 0 in the bit position under `test` if the operand contains a 0 in that
    bit position. `and`ing with a 1 leaves a 1 in that position if it originally contained
    a 1\. Because all of the other bits in the result are 0, the entire result will
    be 0 if that particular bit is 0; the entire result will be nonzero if that bit
    position contains a 1\. The 80x86 reflects this status in the zero flag (Z = 1
    indicates a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence
    demonstrates how to test to see if bit 4 is set in EAX:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 指令的一个常见用途，也是80x86指令集中包含 `test` 指令的初衷，是测试给定操作数中某一特定位是否被置为1。要执行这种类型的测试，通常会将包含一个单独置位的常数值与你想要测试的操作数进行
    `and`/`test` 操作。这样可以清除第二个操作数中的所有其他位，如果该操作数在该位置上是0，则在 `test` 下的该位置会留0。使用1进行 `and`
    操作时，如果原来该位置是1，则会留下1。由于结果中的其他位都是0，因此如果该特定位是0，整个结果将为0；如果该位置是1，整个结果则为非零值。80x86通过零标志（Z
    = 1表示该位为0；Z = 0表示该位为1）反映这一状态。以下指令序列演示了如何测试EAX寄存器的第4位是否被置位：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the `and`/`test` instructions to see if any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and zeros everywhere else). `and`ing such a value with an unknown quantity
    will produce a nonzero value if one or more of the bits in the operand under test
    contain a 1\. The following example tests to see if the value in EAX contains
    a 1 in bit positions 1, 2, 4, and 7:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `and`/`test` 指令来检查多个位中是否有至少一个位被置为1。只需提供一个常数，其中你想测试的位置上为1，其余位置为0。将此值与待测操作数进行
    `and` 操作，如果待测操作数中的一个或多个位包含1，则会产生非零值。以下示例测试EAX中第1位、第2位、第4位和第7位是否为1：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that you cannot use a single `and` or `test` instruction to see if all
    the corresponding bits in the bit set are equal to 1\. To accomplish this, you
    must first mask out the bits that are not in the set and then compare the result
    against the mask itself. If the result is equal to the mask, then all the bits
    in the bit set contain ones. You must use the `and` instruction for this operation
    because the `test` instruction does not mask out any bits. The following example
    checks to see if all the bits in a bit set (`bitMask`) are equal to 1:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能仅使用单个 `and` 或 `test` 指令来检查位集中的所有相应位是否都为1。要实现这一点，必须首先屏蔽掉不在位集中的位，然后将结果与掩码本身进行比较。如果结果等于掩码，则位集中的所有位都包含1。必须使用
    `and` 指令来执行此操作，因为 `test` 指令不会屏蔽任何位。以下示例检查位集（`bitMask`）中的所有位是否都为1：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, once we stick the `cmp` instruction in there, we don't really have
    to check to see if all the bits in the bit set contain ones. We can check for
    any combination of values by specifying the appropriate value as the operand to
    the `cmp` instruction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们在其中使用了 `cmp` 指令，就不再需要检查位集中的所有位是否都为1。我们可以通过将适当的值作为操作数传递给 `cmp` 指令，来检查任意组合的值。
- en: 'Note that the `test`/`and` instructions will set the zero flag in the above
    code sequences only if all the bits in EAX (or other destination operand) have
    zeros in the positions where ones appear in the constant operand. This suggests
    another way to check for all ones in the bit set: Invert the value in EAX prior
    to using the `and` or `test` instruction. Then if the zero flag is set, you know
    that there were all ones in the (original) bit set. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`test`/`and`指令只有在EAX（或其他目标操作数）中的所有位在常量操作数的相应位置为1时，才会设置零标志。这表明另一种检查位集中是否全为1的方法：在使用`and`或`test`指令之前，将EAX中的值取反。然后，如果零标志被设置，你就知道（原始的）位集中全为1。例如：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous paragraphs all suggest that the `bitMask` (the source operand)
    is a constant. This was for purposes of example only. In fact, you can use a variable
    or other register here, if you prefer. Simply load that variable or register with
    the appropriate bit mask before you execute the `test`, `and`, or `cmp` instructions
    in the examples above.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的段落都表明`bitMask`（源操作数）是一个常量。这只是为了举例说明。事实上，如果你愿意，你可以在这里使用变量或其他寄存器。在执行上面例子中的`test`、`and`或`cmp`指令之前，简单地将该变量或寄存器加载上适当的位掩码。
- en: 'Another set of instructions we''ve already seen that we can use to manipulate
    bits are the bit test instructions. These instructions include `bt` (bit test),
    `bts` (bit test and set), `btc` (bit test and complement), and `btr` (bit test
    and reset). We''ve used these instructions to manipulate bits in HLA character-set
    variables; we can also use them to manipulate bits in general. The `bt`*`x`* instructions
    allow the following syntactical forms:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的另一组可以用来操作位的指令是位测试指令。这些指令包括`bt`（位测试）、`bts`（位测试并设置）、`btc`（位测试并取反）和`btr`（位测试并重置）。我们曾用这些指令操作HLA字符集变量中的位；同样，我们也可以使用它们来操作一般的位。这些`bt`*`x`*指令允许以下语法形式：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `btx` instruction's first operand is a bit number that specifies which bit
    to check in the second operand. If the second operand is a register, then the
    first operand must contain a value between 0 and the size of the register (in
    bits) minus 1; because the 80x86's largest registers are 32 bits, this value has
    the maximum value 31 (for 32-bit registers). If the second operand is a memory
    location, then the bit count is not limited to values in the range 0..31\. If
    the first operand is a constant, it can be any 8-bit value in the range 0..255\.
    If the first operand is a register, it has no limitation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`btx`指令的第一个操作数是一个位号，指定要检查第二个操作数中的哪一位。如果第二个操作数是寄存器，那么第一个操作数必须包含一个介于0和寄存器大小（以位为单位）减1之间的值；因为80x86架构的最大寄存器是32位，所以该值的最大值为31（对于32位寄存器）。如果第二个操作数是内存位置，那么位计数不限制在0..31的范围内。如果第一个操作数是常量，它可以是0..255范围内的任何8位值。如果第一个操作数是寄存器，则没有限制。'
- en: The `bt` instruction copies the specified bit from the second operand into the
    carry flag. For example, the `bt( 8, eax );` instruction copies bit 8 of the EAX
    register into the carry flag. You can test the carry flag after this instruction
    to determine whether bit 8 was set or clear in EAX.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt`指令将指定的位从第二个操作数复制到进位标志中。例如，`bt( 8, eax );`指令将EAX寄存器的第8位复制到进位标志中。你可以在此指令之后测试进位标志，以确定EAX中的第8位是设置为1还是清零。'
- en: The `bts`, `btc`, and `btr` instructions manipulate the bit they test while
    they are testing it. These instructions may be slow (depending on the processor
    you're using), and you should avoid them if performance is your primary concern
    and you're using an older CPU. If performance (versus convenience) is an issue,
    you should always try two different algorithms—one that uses these instructions,
    one that uses `and`/`or` instructions—and measure the performance difference;
    then choose the best of the two approaches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`bts`、`btc`和`btr`指令在测试位的同时，也会操作它们所测试的位。这些指令可能会较慢（取决于你使用的处理器），如果性能是你的主要关注点，并且你使用的是较老的CPU，应该避免使用它们。如果性能（与便捷性相对）是一个问题，你应该始终尝试两种不同的算法——一种使用这些指令，另一种使用`and`/`or`指令——并测量它们的性能差异；然后选择最优的方案。'
- en: The shift and rotate instructions are another group of instructions you can
    use to manipulate and test bits. These instructions move the H.O. (left shift/rotate)
    or L.O. (right shift/rotate) bits into the carry flag. Therefore, you can test
    the carry flag after you execute one of these instructions to determine the original
    setting of the operand's H.O. or L.O. bit. The shift and rotate instructions are
    invaluable for aligning bit strings and packing and unpacking data. [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") has several examples of this, and some earlier
    examples in this chapter also use the shift instructions for this purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 移位和旋转指令是另一类可以用于操作和测试位的指令。这些指令将高位（左移/旋转）或低位（右移/旋转）位移动到进位标志中。因此，在执行这些指令之后，你可以测试进位标志，以确定操作数的高位或低位的原始设置。移位和旋转指令对于对齐位串以及打包和解包数据非常有价值。[第2章](ch02.html
    "第2章 数据表示")中有几个示例，且本章前面的部分也使用移位指令进行此类操作。
- en: '* * *'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[126](#CHP-10-FN-1)]) Serial communications chips and other communications
    hardware that use parity for error checking normally compute the parity in hardware;
    you don't have to use software for this purpose.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[126](#CHP-10-FN-1)]) 使用奇偶校验进行错误检查的串行通信芯片和其他通信硬件通常会在硬件中计算奇偶校验；你不需要使用软件来完成这个任务。
- en: 10.3 The Carry Flag as a Bit Accumulator
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.3 进位标志作为位累加器
- en: The `bt`*`x`*, shift, and rotate instructions set or clear the carry flag depending
    on the operation and selected bit. Because these instructions place their "bit
    result" in the carry flag, it is often convenient to think of the carry flag as
    a 1-bit register or accumulator for bit operations. In this section we will explore
    some of the operations possible with this bit result in the carry flag.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt`*`x`*、移位和旋转指令会根据操作和选定的位设置或清除进位标志。因为这些指令将其“位结果”放入进位标志中，所以通常可以将进位标志视为一个1位的寄存器或累加器来进行位操作。在本节中，我们将探讨一些使用进位标志中位结果的操作。'
- en: 'Instructions that will be useful for manipulating bit results in the carry
    flag are those that use the carry flag as some sort of input value. The following
    is a sampling of such instructions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的指令是那些将进位标志作为输入值的指令。以下是这类指令的一些示例：
- en: '`adc`, `sbb`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adc`、`sbb`'
- en: '`rcl`, `rcr`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rcl`, `rcr`'
- en: '`cmc` (We''ll throw in `clc` and `stc` even though they don''t use the carry
    as input.)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmc`（虽然`clc`和`stc`不使用进位作为输入，我们也一并提到它们。）'
- en: '`jc`, `jnc`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jc`、`jnc`'
- en: '`setc`, `setnc`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setc`、`setnc`'
- en: The `adc` and `sbb` instructions add or subtract their operands along with the
    carry flag. So if you've computed some bit result into the carry flag, you can
    figure that result into an addition or subtraction using these instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`adc`和`sbb`指令会将操作数与进位标志一起加或减。因此，如果你已经计算出一些位结果并存入进位标志中，你可以使用这些指令将结果纳入加法或减法操作中。'
- en: To merge a bit result into the carry flag, you most often use the rotate through
    carry instructions (`rcl` and `rcr`). These instructions move the carry flag into
    the L.O. or H.O. bits of their destination operand. These instructions are very
    useful for packing a set of bit results into a byte, word, or double-word value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要将位结果合并到进位标志中，通常使用旋转通过进位指令（`rcl`和`rcr`）。这些指令将进位标志移动到其目标操作数的低位（L.O.）或高位（H.O.）中。这些指令对于将一组位结果打包成字节、字或双字值非常有用。
- en: The `cmc` (complement carry) instruction lets you easily invert the result of
    some bit operation. You can also use the `clc` and `stc` instructions to initialize
    the carry flag prior to some string of bit operations involving the carry flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmc`（补码进位）指令可以轻松地反转某些位操作的结果。你也可以使用`clc`和`stc`指令，在进行一系列涉及进位标志的位操作之前初始化进位标志。'
- en: Instructions that test the carry flag are going to be very popular after a calculation
    that leaves a bit result in the carry flag. The `jc`, `jnc`, `setc`, and `setnc`
    instructions are quite useful here. You can also use the HLA `@c` and `@nc` operands
    in a boolean expression to test the result in the carry flag.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试进位标志的指令在计算后，如果进位标志中有位结果时，会非常常见。`jc`、`jnc`、`setc`和`setnc`指令在这种情况下非常有用。你也可以在布尔表达式中使用HLA的`@c`和`@nc`操作数来测试进位标志中的结果。
- en: If you have a sequence of bit calculations and you would like to test to see
    if the calculations produce a specific set of 1-bit results, the easiest way to
    do this is to clear a register or memory location and use the `rcl` or `rcr` instruction
    to shift each result into that location. Once the bit operations are complete,
    then you can compare the register or memory location holding the result against
    a constant value. If you want to test a sequence of results involving conjunction
    and disjunction (that is, strings of results involving `and`s and `or`s), then
    you could use the `setc` and `setnc` instruction to set a register to 0 or 1 and
    then use the `and`/`or` instructions to merge the results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一系列比特计算，并希望测试这些计算是否产生特定的1比特结果，最简单的方法是清空一个寄存器或内存位置，并使用`rcl`或`rcr`指令将每个结果移入该位置。比特操作完成后，你可以将存储结果的寄存器或内存位置与常数值进行比较。如果你想测试涉及合取与析取（即涉及`and`和`or`的结果字符串）的结果序列，那么你可以使用`setc`和`setnc`指令将寄存器设置为0或1，然后使用`and`/`or`指令合并结果。
- en: 10.4 Packing and Unpacking Bit Strings
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.4 打包与解包比特字符串
- en: A common bit operation is inserting a bit string into an operand or extracting
    a bit string from an operand. [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION")
    provided simple examples of packing and unpacking such data; now it is time to
    formally describe how to do this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的比特操作是将比特字符串插入操作数或从操作数中提取比特字符串。[第二章](ch02.html "第二章 数据表示")提供了打包和解包此类数据的简单示例；现在是时候正式描述如何执行此操作了。
- en: For our purposes we will assume that we're dealing with bit strings—that is,
    a contiguous sequence of bits. In [10.11 Extracting Bit Strings](ch10s11.html
    "10.11 Extracting Bit Strings") we'll look at how to extract and insert bit sets.
    Another simplification we'll make is that the bit string completely fits within
    a byte, word, or double-word operand. Large bit strings that cross object boundaries
    require additional processing; a discussion of bit strings that cross double-word
    boundaries appears later in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将假设正在处理比特字符串——即一串连续的比特。在[10.11 提取比特字符串](ch10s11.html "10.11 提取比特字符串")中，我们将探讨如何提取和插入比特集合。我们做的另一个简化假设是，比特字符串完全适配于一个字节、字或双字操作数。跨越对象边界的大型比特字符串需要额外的处理；关于跨双字边界的比特字符串的讨论将在本节后面出现。
- en: 'A bit string has two attributes that we must consider when packing and unpacking
    that bit string: a starting bit position and a length. The starting bit position
    is the bit number of the L.O. bit of the string in the larger operand. The length
    is the number of bits in the operand. To insert (pack) data into a destination
    operand, you start with a bit string of the appropriate length that is right justified
    (that is, starts in bit position 0) and is zero extended to 8, 16, or 32 bits.
    The task is to insert this data at the appropriate starting position in some other
    operand that is 8-, 16-, or 32-bits wide. There is no guarantee that the destination
    bit positions contain any particular value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 比特字符串有两个我们在打包和解包时必须考虑的属性：起始比特位置和长度。起始比特位置是该字符串在较大操作数中最低有效比特的位置。长度是操作数中的比特数。为了将数据插入（打包）到目标操作数中，首先需要有一个适当长度的比特字符串，该字符串右对齐（即从比特位置0开始），并被零扩展至8、16或32位。任务是将这些数据插入到另一个宽度为8、16或32位的操作数中，从适当的起始位置开始。目标比特位置的值没有任何保证。
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and to shift (a copy of) the bit string so that
    the L.O. bit begins at the appropriate bit position. The third step is to `or`
    the shifted result with the destination operand. This inserts the bit string into
    the destination operand (see [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand")).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前两步（可以按任意顺序发生）是清除目标操作数中相应的比特，并将（比特字符串的副本）移位，使最低有效比特开始于适当的比特位置。第三步是将移位后的结果与目标操作数进行`or`操作。这样就将比特字符串插入到了目标操作数中（参见[图10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "图10-3. 将比特字符串插入到目标操作数中")）。
- en: '![Inserting a bit string into a destination operand](tagoreillycom20100401nostarchimages578073.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![将比特字符串插入目标操作数](tagoreillycom20100401nostarchimages578073.png)'
- en: Figure 10-3. Inserting a bit string into a destination operand
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3. 将比特字符串插入目标操作数
- en: 'It takes only three instructions to insert a bit string of known length into
    a destination operand. The following three instructions demonstrate how to handle
    the insertion operation in [Figure 10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "Figure 10-3. Inserting a bit string into a destination operand"). These instructions
    assume that the source operand is in BX and the destination operand is AX:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要三条指令就能将已知长度的位串插入目标操作数。以下三条指令演示了如何在[图10-3](ch10s04.html#inserting_a_bit_string_into_a_destinatio
    "图10-3. 将位串插入目标操作数")中处理插入操作。这些指令假设源操作数在BX中，目标操作数在AX中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the length and the starting position aren''t known when you''re writing
    the program (that is, you have to calculate them at runtime), then bit-string
    insertion is a little more difficult. However, with the use of a lookup table
    it''s still an easy operation to accomplish. Let''s assume that we have two 8-bit
    values: a starting bit position for the field we''re inserting and a nonzero 8-bit
    length value. Also assume that the source operand is in EBX and the destination
    operand is in EAX. The code to insert one operand into another could take the
    following form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编写程序时无法知道长度和起始位置（即你必须在运行时计算它们），那么位串插入就会稍微困难一些。然而，通过使用查找表，这仍然是一个可以轻松完成的操作。假设我们有两个8位值：用于插入字段的起始位置和一个非零的8位长度值。还假设源操作数在EBX中，目标操作数在EAX中。将一个操作数插入到另一个操作数中的代码可以采用以下形式：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each entry in the `MaskByLen` table contains the number of 1 bits specified
    by the index into the table. Using the *`Length`* value as an index into this
    table fetches a value that has as many 1 bits as the *`Length`* value. The code
    above fetches an appropriate mask, shifts it to the left so that the L.O. bit
    of this run of ones matches the starting position of the field into which we want
    to insert the data, and then inverts the mask and uses the inverted value to clear
    the appropriate bits in the destination operand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaskByLen`表中的每个条目包含由表的索引指定的1位的数量。使用*`Length`*值作为索引从该表中获取一个值，该值具有与*`Length`*值相同数量的1位。上面的代码获取了一个适当的掩码，将其向左移动，以便该组1位的最低有效位与我们想要插入数据的字段的起始位置对齐，然后反转掩码并使用反转后的值清除目标操作数中适当的位。'
- en: 'Extracting a bit string from a larger operand is just as easy as inserting
    a bit string into some larger operand. All you have to do is mask out the unwanted
    bits and then shift the result until the L.O. bit of the bit string is in bit
    0 of the destination operand. For example, to extract the 4-bit field starting
    at bit position 5 in EBX and leave the result in EAX, you could use the following
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个较大的操作数中提取位串与将位串插入某个较大的操作数一样简单。你所需要做的就是屏蔽掉不需要的位，然后将结果移动，直到位串的最低有效位（L.O. bit）位于目标操作数的第0位。例如，要从EBX中提取从第5位开始的4位字段并将结果保存在EAX中，你可以使用以下代码：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you do not know the bit string''s length and starting position when you''re
    writing the program, you can still extract the desired bit string. The code is
    very similar to insertion (though a little simpler). Assuming you have the *`Length`*
    and *`StartingPosition`* values we used when inserting a bit string, you can extract
    the corresponding bit string using the following code (assuming source = EBX and
    dest = EAX):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编写程序时，你不知道位串的长度和起始位置，你仍然可以提取所需的位串。代码与插入操作非常相似（尽管稍微简单一些）。假设你拥有我们在插入位串时使用的*`Length`*和*`StartingPosition`*值，你可以使用以下代码提取相应的位串（假设源操作数为EBX，目标操作数为EAX）：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The examples up to this point all assume that the bit string appears completely
    within a double-word (or smaller) object. This will always be the case if the
    bit string is less than or equal to 32 bits in length. However, if the length
    of the bit string plus its starting position (modulo 8) within an object is greater
    than 32, then the bit string will cross a double-word boundary within the object.
    Extracting such bit strings requires up to three operations: one operation to
    extract the start of the bit string (up to the first double-word boundary), an
    operation that copies whole double words (assuming the bit string is so long that
    it consumes several double words), and a final operation that copies leftover
    bits in the last double word at the end of the bit string. The actual implementation
    of this operation is left as an exercise for the reader.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例都假设比特串完全出现在一个双字（或更小）对象中。如果比特串的长度小于或等于32位，这种情况总是成立。然而，如果比特串的长度加上其在对象中起始位置（模8运算）大于32，那么比特串就会跨越对象中的双字边界。提取这样的比特串需要最多三个操作：一个操作提取比特串的起始部分（直到第一个双字边界），一个操作复制整个双字（假设比特串很长，跨越多个双字），以及最后一个操作，复制位于比特串末尾的最后一个双字中的剩余比特。这个操作的具体实现留给读者作为练习。
- en: 10.5 Coalescing Bit Sets and Distributing Bit Strings
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.5 合并比特集与分配比特串
- en: 'Inserting and extracting bit sets is little different than inserting and extract
    bit strings if the "shape" of the bit set you''re inserting (or resulting bit
    set you''re extracting) is the same as the bit set in the main object. The shape
    of a bit set is the distribution of the bits in the set, ignoring the starting
    bit position of the set. So a bit set that includes bits 0, 4, 5, 6, and 7 has
    the same shape as a bit set that includes bits 12, 16, 17, 18, and 19 because
    the distribution of the bits is the same. The code to insert or extract this bit
    set is nearly identical to that of the previous section; the only difference is
    the mask value you use. For example, to insert this bit set starting at bit 0
    in EAX into the corresponding bit set starting at position 12 in EBX, you could
    use the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和提取比特集与插入和提取比特串的不同之处在于，如果你插入的比特集（或提取出的结果比特集）与主对象中的比特集形状相同，那么操作就没什么不同。比特集的“形状”是指比特集内比特位的分布，而忽略比特集的起始比特位置。因此，包含比特位0、4、5、6和7的比特集，其形状与包含比特位12、16、17、18和19的比特集相同，因为这些比特的分布是一样的。插入或提取这个比特集的代码几乎与上一节相同，唯一的区别是你使用的掩码值。例如，要将这个以EAX寄存器的比特位0开始的比特集插入到EBX寄存器的比特位12的位置，你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, suppose you have 5 bits in bit positions 0 through 4 in EAX and you
    want to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to
    distribute the bits in EAX prior to logically `or`ing the values into EBX. Given
    the fact that this particular bit set has only two runs of 1 bits, the process
    is somewhat simplified. The following code achieves this in a somewhat sneaky
    fashion:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设你在EAX寄存器的比特位置0到4之间有5个位，且你想将它们合并到EBX寄存器中的比特位12、16、17、18和19上。你必须以某种方式在将值通过逻辑`or`操作合并到EBX之前，分配EAX中的比特位。考虑到这个特定的比特集只有两段1比特，过程会相对简化。以下代码以一种有点“狡猾”的方式实现了这一点：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This trick with the `btr` (bit test and reset) instruction worked well because
    we had only 1 bit out of place in the original source operand. Alas, had the bits
    all been in the wrong location relative to one another, this scheme might not
    have worked quite as well. We'll see a more general solution in just a moment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用`btr`（位测试与重置）指令的技巧效果很好，因为我们在原始源操作数中只有1个比特位位置错误。可惜，如果比特位相对彼此的位置完全错乱，那么这个方案可能就不太有效了。我们稍后会看到一个更通用的解决方案。
- en: 'Extracting this bit set and collecting ("coalescing") the bits into a bit string
    is not quite as easy. However, there are still some sneaky tricks we can pull.
    Consider the following code that extracts the bit set from EBX and places the
    result into bits 0..4 of EAX:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提取这个比特集并将比特位“合并”成一个比特串并不容易。然而，我们依然可以利用一些巧妙的技巧。考虑以下代码，它从EBX中提取比特集，并将结果放入EAX的比特位0到4中：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code moves (original) bit 12 into bit position 7, the H.O. bit of AL. At
    the same time it moves bits 16..19 down to bits 11..14 (bits 3..6 of AH). Then
    the code shifts bits 3..6 in AH down to bit 0\. This positions the H.O. bits of
    the bit set so that they are adjacent to the bit left in AL. Finally, the code
    shifts all the bits down to bit 0\. Again, this is not a general solution, but
    it shows a clever way to attack this problem if you think about it carefully.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将（原始的）第 12 位移到第 7 位位置，即 AL 的高位。同时，它将第 16 到第 19 位移到第 11 到第 14 位（即 AH 的第 3
    到第 6 位）。然后，代码将 AH 中第 3 到第 6 位向下移到第 0 位。这将高位的位集合放置在 AL 中剩余的位旁边。最后，代码将所有位向下移到第 0
    位。这不是一种通用的解决方案，但它展示了如果仔细思考，这种问题可以用一种巧妙的方法来解决。
- en: 'The problem with the coalescing and distribution algorithms above is that they
    are not general. They apply only to their specific bit sets. Usually specific
    solutions will provide the most efficient solution. A generalized solution (perhaps
    one that lets you specify a mask, and the code distributes or coalesces the bits
    accordingly) is going to be a bit more difficult. The following code demonstrates
    how to distribute the bits in a bit string according to the values in a bit mask:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上面提到的合并和分配算法的问题在于它们不是通用的。它们仅适用于特定的位集合。通常，特定的解决方案会提供最有效的解决方案。一个通用的解决方案（也许是让你指定一个掩码，然后代码根据掩码分配或合并位）将会更加复杂。以下代码演示了如何根据位掩码中的值分配位：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the code above, if we load EDX with %1100_1001, then this code will copy
    bits 0..3 to bits 0, 3, 6, and 7 in EAX. Notice the short-circuit test that checks
    to see if we've exhausted the values in EDX (by checking for a 0 in EDX). Note
    that the rotate instructions do not affect the zero flag but the shift instructions
    do. Hence the `shr` instruction above will set the zero flag when there are no
    more bits to distribute (when EDX becomes 0).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，如果我们用 %1100_1001 加载 EDX，那么这段代码将会把 EDX 中的第 0 到第 3 位复制到 EAX 中的第 0、3、6
    和 7 位。注意到有一个短路测试，它检查 EDX 中的值是否已经用尽（通过检查 EDX 中是否有 0）。注意，旋转指令不会影响零标志位，而移位指令会。因此，上面的
    `shr` 指令在没有更多位可以分配时（当 EDX 变为 0 时）将设置零标志。
- en: 'The general algorithm for coalescing bits is a tad more efficient than distribution.
    Here''s the code that will extract bits from EBX via the bit mask in EDX and leave
    the result in EAX:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 合并位的通用算法比分配算法稍微高效一些。以下是将通过 EDX 中的位掩码从 EBX 中提取位，并将结果保留在 EAX 中的代码：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This sequence takes advantage of a sneaky trait of the shift and rotate instructions:
    the shift instructions affect the zero flag, whereas the rotate instructions do
    not. Therefore, the `shl( 1, edx );` instruction sets the zero flag when EDX becomes
    0 (after the shift). If the carry flag was also set, the code will make one additional
    pass through the loop in order to shift a bit into EAX, but the next time the
    code shifts EDX 1 bit to the left, EDX is still 0 and so the carry will be clear.
    On this iteration, the code falls out of the loop.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列利用了移位和旋转指令的一个巧妙特性：移位指令会影响零标志，而旋转指令则不会。因此，`shl( 1, edx );` 指令在 EDX 变为 0（移位后）时会设置零标志。如果进位标志也被设置，代码将会额外通过循环一次，将一个位移入
    EAX，但下次代码将 EDX 向左移 1 位时，EDX 依然是 0，因此进位标志会被清除。在这次迭代中，代码会跳出循环。
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don't get too large), you can use that byte's value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This might produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to the reader.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种合并位的方法是通过查表。通过一次抓取一个字节的数据（这样你的表格不会变得太大），你可以使用该字节的值作为查找表的索引，将所有位合并到第 0 位。最后，你可以将每个字节低位的位合并在一起。在某些情况下，这可能会产生一个更高效的合并算法。具体实现留给读者。
- en: 10.6 Packed Arrays of Bit Strings
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.6 位串的打包数组
- en: Although it is far more efficient to create arrays whose elements have an integral
    number of bytes, it is quite possible to create arrays of elements whose size
    is not a multiple of 8 bits. The drawback is that calculating the "address" of
    an array element and manipulating that array element involves a lot of extra work.
    In this section we'll take a look at a few examples of packing and unpacking array
    elements in an array whose elements are an arbitrary number of bits long.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建元素大小为整数字节数的数组要高效得多，但完全可以创建元素大小不是8位倍数的数组。缺点是，计算数组元素的“地址”并操作该数组元素需要额外的工作。在本节中，我们将看几个示例，展示如何在元素大小为任意位数的数组中打包和解包数组元素。
- en: 'Before proceeding, it''s probably worthwhile to discuss why you would want
    to bother with arrays of bit objects. The answer is simple: space. If an object
    consumes only 3 bits, you can get 2.67 times as many elements into the same space
    if you pack the data rather than allocating a whole byte for each object. For
    very large arrays, this can be a substantial savings. Of course, the cost of this
    space savings is speed: You have to execute extra instructions to pack and unpack
    the data, thus slowing down access to the data.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得讨论一下为什么你会想要使用位对象数组。答案很简单：空间。如果一个对象仅消耗3个位，使用数据打包的方式，你可以在相同的空间内存放2.67倍数量的元素，而不是为每个对象分配一个完整的字节。对于非常大的数组，这可以节省大量空间。当然，这种空间节省的代价是速度：你需要执行额外的指令来打包和解包数据，从而减慢了数据访问速度。
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access; it is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 计算在一大块位中定位数组元素的位偏移量与标准数组访问几乎相同；其公式为：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you calculate the element''s address in bits, you need to convert it to
    a byte address (because we have to use byte addresses when accessing memory) and
    extract the specified element. Because the base address of an array element (almost)
    always starts on a byte boundary, we can use the following equations to simplify
    this task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你计算出元素的位地址，你需要将其转换为字节地址（因为在访问内存时必须使用字节地址），并提取指定的元素。由于数组元素的基地址（几乎）总是从字节边界开始，我们可以使用以下公式来简化这个任务：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example, suppose we have an array of 200 3-bit objects that we declare
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个包含200个3位对象的数组，声明如下：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The constant expression in the dimension above reserves space for enough bytes
    to hold 600 bits (200 elements, each 3 bits long). As the comment notes, the expression
    adds 2 extra bytes at the end to ensure we don't lose any odd bits (that won't
    happen in this example because 600 is evenly divisible by 8, but in general you
    can't count on this; one extra byte usually won't hurt things) and also to allow
    us to access 1 byte beyond the end of the array (when storing data to the array).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面维度中的常量表达式为足够容纳600位（200个元素，每个元素3个位）预留了空间。如注释所示，该表达式在末尾添加了2个额外的字节，以确保我们不会丢失任何奇数位（在本示例中不会发生这种情况，因为600可以被8整除，但通常不能依赖这一点；通常添加一个额外字节不会造成问题），同时允许我们在数组的末尾访问1个字节（当向数组存储数据时）。
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits by using the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想访问该数组的第*i*个3位元素。你可以使用以下代码提取这些位：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inserting an element into the array is a bit more difficult. In addition to
    computing the base address and bit offset of the array element, you also have
    to create a mask to clear out the bits in the destination where you're going to
    insert the new data. The following code inserts the L.O. 3 bits of EAX into the
    *i*th element of the `AO3Bobjects` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组插入一个元素要稍微复杂一些。除了计算数组元素的基地址和位偏移量外，还必须创建一个掩码，以清除目标位置的位，供插入新数据使用。以下代码将EAX的低3位插入到`AO3Bobjects`数组的*i*元素中。
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice the use of a lookup table to generate the masks needed to clear out the
    appropriate position in the array. Each element of this array contains all ones
    except for three zeros in the position we need to clear for a given bit offset
    (note the use of the `!` operator to invert the constants in the table).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用查找表来生成所需的掩码，以清除数组中适当位置的位。该数组的每个元素都包含全1，除了我们需要清除的给定位偏移位置的三个零（注意使用`!`操作符来反转表中的常量）。
- en: 10.7 Searching for a Bit
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.7 查找位
- en: A very common bit operation is to locate the end of some run of bits. A special
    case of this operation is to locate the first (or last) set or clear bit in a
    16- or 32-bit value. In this section we'll explore ways to accomplish this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的位操作是定位一段位的结束。这个操作的一个特殊情况是定位16位或32位值中第一个（或最后一个）设置或清除的位。在本节中，我们将探讨实现这一目标的方法。
- en: Before describing how to search for the first or last bit of a given value,
    perhaps it's wise to discuss exactly what the terms *first* and *last* mean in
    this context. The term *first set bit* means the first bit in a value, scanning
    from bit 0 toward the high-order bit, which contains a 1\. A similar definition
    exists for the *first clear bit*. The *last set bit* is the first bit in a value,
    scanning from the high-order bit toward bit 0, which contains a 1\. A similar
    definition exists for the *last clear bit*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述如何搜索给定值的第一个或最后一个位之前，也许先讨论一下在这个上下文中*第一个*和*最后一个*的确切含义是明智的。术语*第一个设置位*是指从位0开始扫描，直到扫描到包含1的高位。*第一个清除位*有类似的定义。*最后一个设置位*是指从高位开始扫描，直到扫描到包含1的位0。*最后一个清除位*也有类似的定义。
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0) into
    the carry flag. The number of iterations specifies the position. Here''s some
    sample code that checks for the first set bit in EAX and returns that bit position
    in ECX:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描第一个或最后一个位的一个明显方法是使用移位指令在循环中，并计算在将1（或0）移入进位标志之前的迭代次数。迭代次数指定了位的位置。下面是一些示例代码，它检查EAX中第一个设置的位，并将该位位置返回到ECX中：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only thing tricky about this code is the fact that it runs the loop counter
    from −32 up to 0 rather than 32 down to 0\. This makes it slightly easier to calculate
    the bit position once the loop terminates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码唯一的复杂之处在于它将循环计数器从−32运行到0，而不是从32倒数到0。这样一来，一旦循环终止，计算位位置就稍微容易些。
- en: The drawback to this particular loop is that it's expensive. This loop repeats
    as many as 32 times depending on the original value in EAX. If the values you're
    checking often have lots of zeros in the L.O. bits of EAX, this code runs rather
    slowly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定循环的缺点是它比较昂贵。这个循环最多会重复32次，具体取决于EAX中的原始值。如果你检查的值在EAX的低位中有很多零，这段代码就会运行得比较慢。
- en: 'Searching for the first (or last) set bit is such a common operation that Intel
    added a couple of instructions on the 80386 specifically to accelerate this process.
    These instructions are `bsf` (bit scan forward) and `bsr` (bit scan reverse).
    Their syntax is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索第一个（或最后一个）设置位是一个非常常见的操作，因此英特尔在80386处理器上专门增加了一些指令来加速这个过程。这些指令是`bsf`（位扫描向前）和`bsr`（位扫描向后）。它们的语法如下：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The source and destinations operands must be the same size, and they must both
    be 16- or 32-bit objects. The destination operand has to be a register. The source
    operand can be a register or a memory location.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 源操作数和目标操作数必须具有相同的大小，并且它们必须都是16位或32位对象。目标操作数必须是寄存器。源操作数可以是寄存器或内存位置。
- en: 'The `bsf` instruction scans for the first set bit (starting from bit position
    0) in the source operand. The `bsr` instruction scans for the last set bit in
    the source operand by scanning from the H.O. bit toward the L.O. bit. If these
    instructions find a bit that is set in the source operand, then they clear the
    zero flag and put the bit position into the destination register. If the source
    register contains 0 (that is, there are no set bits), then these instructions
    set the zero flag and leave an indeterminate value in the destination register.
    Note that you should test the zero flag immediately after the execution of these
    instructions to validate the destination register''s value. Here''s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsf`指令从源操作数的第0位开始扫描第一个设置位。`bsr`指令通过从高位向低位扫描来扫描源操作数中的最后一个设置位。如果这些指令在源操作数中找到了一个已设置的位，它们将清除零标志并将该位位置存入目标寄存器。如果源寄存器包含0（即没有设置的位），这些指令将设置零标志，并将目标寄存器的值置为不确定。请注意，你应该在这些指令执行后立即测试零标志，以验证目标寄存器的值。下面是一个示例：'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You use the `bsr` instruction in an identical fashion except that it computes
    the bit position of the last set bit in an operand (that is, the first set bit
    it finds when scanning from the H.O. bit toward the L.O. bit).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你以相同的方式使用`bsr`指令，不同之处在于它计算操作数中最后一个设置位的位位置（即，它从高位向低位扫描时找到的第一个设置位）。
- en: The 80x86 CPUs do not provide instructions to locate the first bit containing
    a 0\. However, you can easily scan for a 0 bit by first inverting the source operand
    (or a copy of the source operand if you must preserve the source operand's value)
    and then search for the first 1 bit; this corresponds to the first 0 bit in the
    original operand value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU没有提供定位第一个包含0的比特的指令。然而，你可以通过首先反转源操作数（如果必须保留源操作数的值，可以反转其副本），然后搜索第一个1比特来轻松扫描0比特；这对应于原始操作数值中的第一个0比特。
- en: The `bsf` and `bsr` instructions are very complex 80x86 instructions. Therefore,
    these instructions may be slower than other instructions. Indeed, in some circumstances
    it may be faster to locate the first set bit using discrete instructions. However,
    because the execution time of these instructions varies widely from CPU to CPU,
    you should test the performance of these instructions prior to using them in time-critical
    code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsf`和`bsr`指令是非常复杂的80x86指令。因此，这些指令可能比其他指令慢。实际上，在某些情况下，使用离散指令定位第一个已设置的比特可能更快。然而，由于这些指令的执行时间因CPU而异，因此你应该在将它们用于时间关键型代码之前测试这些指令的性能。'
- en: 'Note that the `bsf` and `bsr` instructions do not affect the source operand.
    A common operation is to extract the first (or last) set bit you find in some
    operand. That is, you might want to clear the bit once you find it. If the source
    operand is a register (or you can easily move it into a register), then you can
    use the `btr` (or `btc`) instruction to clear the bit once you''ve found it. Here''s
    some code that achieves this result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bsf`和`bsr`指令不会影响源操作数。一个常见的操作是提取你在某个操作数中找到的第一个（或最后一个）已设置的比特。也就是说，你可能希望在找到比特后将其清除。如果源操作数是一个寄存器（或者你可以轻松地将其移入一个寄存器），那么你可以在找到比特后使用`btr`（或`btc`）指令清除该比特。下面是实现这一结果的代码：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At the end of this sequence, the zero flag indicates whether we found a bit
    (note that `btr` does not affect the zero flag). Alternately, you could add an
    `else` section to the `if` statement above that handles the case when the source
    operand (EAX) contains 0 at the beginning of this instruction sequence.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此序列的末尾，零标志指示我们是否找到一个比特（请注意，`btr`不会影响零标志）。或者，你可以在上面的`if`语句中添加一个`else`部分，处理源操作数（EAX）在此指令序列开始时为0的情况。
- en: Because the `bsf` and `bsr` instructions support only 16- and 32-bit operands,
    you will have to compute the first bit position of an 8-bit operand a little differently.
    There are a couple of reasonable approaches. First, of course, you can usually
    zero extend an 8-bit operand to 16 or 32 bits and then use the `bsf` or `bsr`
    instruction on this operand. Another alternative is to create a lookup table where
    each entry in the table contains the number of bits in the value you use as an
    index into the table; then you can use the `xlat` instruction to "compute" the
    first bit position in the value (note that you will have to handle the value 0
    as a special case). Another solution is to use the shift algorithm appearing at
    the beginning of this section; for an 8-bit operand, this is not an entirely inefficient
    solution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`bsf`和`bsr`指令仅支持16位和32位操作数，所以你需要稍微不同的方法来计算8位操作数的第一个比特位置。有几种合理的方式。首先，当然，你通常可以将8位操作数零扩展到16位或32位，然后在这个操作数上使用`bsf`或`bsr`指令。另一种选择是创建一个查找表，每个表项包含作为索引的值中比特的数量；然后你可以使用`xlat`指令来“计算”值中的第一个比特位置（注意，你需要将值为0的情况作为特殊情况处理）。另一种解决方案是使用本节开始时出现的移位算法；对于8位操作数，这并不是一个完全低效的解决方案。
- en: One interesting use of the `bsf` and `bsr` instructions is to fill in a character
    set with all the values from the lowest valued character in the set through the
    highest valued character. For example, suppose a character set contains the values
    `{'A', 'M', 'a'..'n', 'z'}`; if we filled in the gaps in this character set we
    would have the values `{'A'..'z'}`. To compute this new set we can use `bsf` to
    determine the ASCII code of the first character in the set and `bsr` to determine
    the ASCII code of the last character in the set. After doing this, we can feed
    those two ASCII codes to the HLA Standard Library `cs.rangeChar` function to compute
    the new set.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsf`和`bsr`指令的一个有趣应用是用它们来填充一个字符集，将该集中的所有字符按从最低值到最高值的顺序排列。例如，假设一个字符集包含值`{''A'',
    ''M'', ''a''..''n'', ''z''}`；如果我们填补这个字符集中的空白，就会得到`{''A''..''z''}`这些值。为了计算这个新集，我们可以使用`bsf`来确定集中的第一个字符的
    ASCII 码，再使用`bsr`来确定集中的最后一个字符的 ASCII 码。完成这一步后，我们可以将这两个 ASCII 码传递给 HLA 标准库的`cs.rangeChar`函数来计算新的字符集。'
- en: You can also use the `bsf` and `bsr` instructions to determine the size of a
    run of bits, assuming that you have a single run of bits in your operand. Simply
    locate the first and last bits in the run (as above) and then compute the difference
    (plus 1) of the two values. Of course, this scheme is valid only if there are
    no intervening zeros between the first and last set bits in the value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`bsf`和`bsr`指令来确定位段的大小，前提是操作数中有一个连续的位段。只需定位位段中的第一个和最后一个位（如上所述），然后计算这两个值的差（加
    1）。当然，这种方案仅在第一个和最后一个设置位之间没有中间零时有效。
- en: 10.8 Counting Bits
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.8 计数位
- en: 'The last example in the previous section demonstrates a specific case of a
    very general problem: counting bits. Unfortunately, that example has a severe
    limitation: It only counts a single run of 1 bits appearing in the source operand.
    This section discusses a more general solution to this problem.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的最后一个示例展示了一个非常通用问题的特定案例：计数位。不幸的是，那个示例有一个严重的限制：它仅计数源操作数中出现的一个连续的 1 位段。本节讨论了该问题的更通用解决方案。
- en: 'Hardly a week goes by that someone doesn''t ask on one of the Internet newsgroups
    how to count the number of bits in a register operand. This is a common request,
    undoubtedly, because many assembly language course instructors assign this task
    as a project to their students as a way to teach them about the shift and rotate
    instructions. Undoubtedly, the solution these instructors expect is something
    like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每周都会有人在某个互联网新闻组上问如何计算寄存器操作数中的位数。这是一个常见的请求，无疑是因为许多汇编语言课程的讲师将这个任务作为项目布置给学生，以此来教授移位和旋转指令。无疑，讲师们期望的解决方案大致如下：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The "trick" worth noting here is that this code uses the `adc` instruction to
    add the value of the carry flag into the BL register. Because the count is going
    to be less than 32, the result will fit comfortably into BL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的“技巧”是，这段代码使用了`adc`指令将进位标志的值加到 BL 寄存器中。因为计数将小于 32，结果将很适合存储在 BL 中。
- en: 'Tricky code or not, this instruction sequence is not particularly fast. As
    you can tell with just a small amount of analysis, the loop above always executes
    32 times, so this code sequence executes 130 instructions (4 instructions per
    iteration plus 2 extra instructions). You might ask if there is a more efficient
    solution; the answer is yes. The following code, taken from the AMD Athlon optimization
    guide, provides a faster solution (see the comments for a description of the algorithm):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不管代码是否复杂，这个指令序列的速度并不特别快。通过简单分析就能看出，上面的循环总是执行 32 次，因此该代码序列执行了 130 条指令（每次迭代 4
    条指令，再加 2 条额外指令）。你可能会问是否有更高效的解决方案；答案是肯定的。下面的代码，来自 AMD Athlon 优化指南，提供了一个更快的解决方案（请参阅注释以了解算法描述）：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 10.9 Reversing a Bit String
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.9 反转位串
- en: 'Another common programming project instructors assign, and a useful function
    in its own right, is a program that reverses the bits in an operand. That is,
    it swaps the L.O. bit with the H.O. bit, bit 1 with the next-to-H.O. bit, and
    so on. The typical solution an instructor probably expects for this assignment
    is the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的编程项目，通常由讲师布置，并且本身是一个有用的函数，是一个反转操作数中位的程序。也就是说，它将最低有效位（L.O. bit）与最高有效位（H.O.
    bit）交换，位 1 与次高有效位交换，以此类推。讲师可能期望的典型解决方案如下：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As with the previous examples, this code suffers from the fact that it repeats
    the loop 32 times, for a grand total of 129 instructions. By unrolling the loop
    you can get it down to 64 instructions, but this is still somewhat expensive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，这段代码的缺点是它重复执行32次循环，总共需要129条指令。通过展开循环，你可以将指令数减少到64条，但这仍然算是比较昂贵的。
- en: As usual, the best solution to an optimization problem is often a better algorithm
    rather than attempting to tweak your code by trying to choose faster instructions
    to speed up some code. However, a little intelligence goes a long way when manipulating
    bits. In the last section, for example, we were able to speed up counting the
    bits in a string by substituting a more complex algorithm for the simplistic "shift
    and count" algorithm. In the example above, we are once again faced with a very
    simple algorithm with a loop that repeats for 1 bit in each number. The question
    is "Can we discover an algorithm that doesn't execute 129 instructions to reverse
    the bits in a 32-bit register?" The answer is yes, and the trick is to do as much
    work as possible in parallel.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，优化问题的最佳解决方案往往是选择更好的算法，而不是试图通过选择更快的指令来调整代码以加速某些操作。然而，在操作位时，一点小聪明可以带来很大效果。例如，在上一节中，我们通过替换一个更复杂的算法，成功地加速了字符串中位的计数，替代了简单的“移位计数”算法。在上面的示例中，我们再次面临一个非常简单的算法，它的循环会针对每个数字的1个位重复执行。问题是：“我们能否发现一个不需要执行129条指令来反转32位寄存器中的位的算法？”答案是可以的，诀窍是尽可能并行地处理工作。
- en: 'Suppose that all we wanted to do was swap the even and odd bits in a 32-bit
    value. We can easily swap the even and odd bits in EAX using the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想做的只是交换一个32位值中的偶数位和奇数位。我们可以使用以下代码轻松地交换EAX寄存器中的偶数位和奇数位：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, swapping the even and odd bits, while somewhat interesting, does
    not solve our larger problem of reversing all the bits in the number. But it does
    take us part of the way there. For example, if after executing the preceding code
    sequence you swap adjacent pairs of bits, you''ve managed to swap the bits in
    all the nibbles in the 32-bit value. Swapping adjacent pairs of bits is done in
    a manner very similar to the above; the code is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，交换偶数位和奇数位虽然有点有趣，但并没有解决我们更大的问题——反转数字中的所有位。不过，它确实将我们带到了一定的进展。例如，如果在执行上述代码序列之后你交换了相邻的位对，你就成功地交换了32位值中所有半字节的位。交换相邻位对的方式与上述类似，代码如下：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After completing the preceding sequence, you swap the adjacent nibbles in the
    32-bit register. Again, the only difference is the bit mask and the length of
    the shifts. Here''s the code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述序列后，你可以交换32位寄存器中的相邻半字节。再一次，唯一的区别是位掩码和移位的长度。代码如下：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can probably see the pattern developing and can figure out that in the
    next two steps you have to swap the bytes and then the words in this object. You
    can use code like the above, but there is a better way: Use the `bswap` instruction.
    The `bswap` (byte swap) instruction uses the following syntax:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到这个模式，并且可以推断出，在接下来的两个步骤中，你需要交换这个对象中的字节和字。你可以像上面那样使用代码，但有一种更好的方法：使用`bswap`指令。`bswap`（字节交换）指令的语法如下：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This instruction swaps bytes 0 and 3, and it swaps bytes 1 and 2 in the specified
    32-bit register. The principle use of this instruction is to convert data between
    the so-called little-endian and big-endian data formats.^([[127](#ftn.CHP-10-FN-2)])
    Although you don''t specifically use this instruction for this purpose here, the
    bswap instruction does swap the bytes and words in a 32-bit object exactly the
    way you want them when reversing bits. Rather than sticking in another 12 instructions
    to swap the bytes and then the words, you can simply use a `bswap( eax );` instruction
    to complete the job after the instructions above. The final code sequence is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令交换了指定32位寄存器中的字节0和3，并交换了字节1和2。该指令的主要用途是将数据在所谓的小端和大端数据格式之间进行转换。^([[127](#ftn.CHP-10-FN-2)])
    虽然在这里你并没有专门使用这条指令来做这个，但`bswap`指令确实按照你反转位时所需的方式交换了32位对象中的字节和字。你可以简单地在上述指令后面使用`bswap(
    eax );`指令来完成任务，而不必插入额外的12条指令来交换字节和字。最终代码序列如下：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This algorithm requires only 19 instructions, and it executes much faster than
    the bit-shifting loop appearing earlier. Of course, this sequence does consume
    a little more memory. If you're trying to save memory rather than clock cycles,
    the loop is probably a better solution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ^([[127](#CHP-10-FN-2)]) In the little-endian system, which is the native 80x86
    format, the L.O. byte of an object appears at the lowest address in memory. In
    the big-endian system, which various RISC processors use, the H.O. byte of an
    object appears at the lowest address in memory. The `bswap` instruction converts
    between these two data formats.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 10.10 Merging Bit Strings
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common bit string operation is producing a single bit string by merging,
    or interleaving, bits from two different sources. The following example code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This particular example merged two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unrolling
    the loop is probably your best bet because this eliminates half the instructions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few slight modifications, we could also have merged four 8-bit values
    together, or we could have generated the result using other bit sequences. For
    example, the following code copies bits 0..5 from EAX, then bits 0..4 from EBX,
    then bits 6..11 from EAX, then bits 5..15 from EBX, and finally bits 12..15 from
    EAX:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 10.11 Extracting Bit Strings
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we can easily accomplish the converse of merging two bit streams;
    that is, we can extract and distribute bits in a bit string among multiple destinations.
    The following code takes the 32-bit value in EAX and distributes alternate bits
    among the BX and DX registers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This sequence executes 99 instructions. This isn't terrible, but we can probably
    do a little better by using an algorithm that extracts bits in parallel. Employing
    the technique we used to reverse bits in a register, we can come up with the following
    algorithm that relocates all the even bits to the L.O. word of EAX and all the
    odd bits to the H.O. word of EAX.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This sequence requires 30 instructions. At first blush it looks like a winner
    because the original loop executes 64 instructions. However, this code isn't quite
    as good as it looks. After all, if we're willing to write this much code, why
    not unroll the loop above 16 times? That sequence requires only 64 instructions.
    So the complexity of the previous algorithm may not gain much on instruction count.
    As to which sequence is faster, well, you'll have to time them to figure this
    out. However, the `shrd` instructions are not particularly fast on all processors
    and neither are the instructions in the other sequence. This example appears here
    not to show you a better algorithm but rather to demonstrate that writing really
    tricky code doesn't always provide a big performance boost.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Extracting other bit combinations is left as an exercise for the reader.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 10.12 Searching for a Bit Pattern
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.12 搜索位模式
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of %1011 starting at some particular position in
    a bit string. In this section we'll explore some simple algorithms to accomplish
    this task.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能需要的与位相关的操作是能够在位字符串中搜索特定的位模式。例如，你可能希望从某个特定位置开始，在位字符串中找到第一次出现的%1011的位索引。在本节中，我们将探讨一些简单的算法来完成这个任务。
- en: 'To search for a particular bit pattern we''re going to need to know four things:
    (1) the pattern to search for (the *pattern*), (2) the length of the pattern we''re
    searching for, (3) the bit string that we''re going to search through (the *source*),
    and (4) the length of the bit string to search through. The basic idea behind
    the search is to create a mask based on the length of the pattern and mask a copy
    of the source with this value. Then we can directly compare the pattern with the
    masked source for equality. If they are equal, you''re finished; if they''re not
    equal, then increment a bit position counter, shift the source one position to
    the right, and try again. You repeat this operation `length(`*`source`*`) - length(`*`pattern`*`)`
    times. The algorithm fails if it does not detect the bit pattern after this many
    attempts (because we will have exhausted all the bits in the source operand that
    could match the pattern''s length). Here''s a simple algorithm that searches for
    a 4-bit pattern throughout the EBX register:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定的位模式，我们需要知道四个事项：（1）要搜索的模式（*pattern*），（2）要搜索的模式的长度，（3）我们要搜索的位字符串（*source*），以及（4）要搜索的位字符串的长度。搜索的基本思路是基于模式的长度创建一个掩码，并用该值对源字符串的副本进行掩码处理。然后，我们可以直接将模式与掩码后的源字符串进行比较。如果它们相等，搜索结束；如果不相等，则递增位位置计数器，将源字符串右移一位，并重试。这个操作将重复`length(`*`source`*`)
    - length(`*`pattern`*`)`次。如果在这些尝试后仍未找到位模式，则算法失败（因为我们已经耗尽了源操作数中所有可能与模式长度匹配的位）。以下是一个简单的算法，用于在EBX寄存器中搜索一个4位模式：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Bit-string scanning is a special case of string matching. String matching is
    a well-studied problem in computer science, and many of the algorithms you can
    use for string matching are applicable to bit-string matching as well. Such algorithms
    are beyond the scope of this chapter, but to give you a preview of how this works,
    you compute some function (like `xor` or `sub`) between the pattern and the current
    source bits and use the result as an index into a lookup table to determine how
    many bits you can skip. Such algorithms let you skip several bits rather than
    shifting only once for each iteration of the scanning loop (as is done by the
    previous algorithm).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 位字符串扫描是字符串匹配的特殊情况。字符串匹配是计算机科学中研究得较为深入的问题，许多用于字符串匹配的算法同样适用于位字符串匹配。这类算法超出了本章的范围，但为了让你预览其工作原理，你可以计算模式和当前源位之间的一些函数（如`xor`或`sub`），并使用结果作为查找表的索引，来确定可以跳过多少位。这类算法允许你跳过多个位，而不是像前面的算法那样每次扫描循环只右移一次。
- en: 10.13 The HLA Standard Library Bits Module
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.13 HLA标准库位模块
- en: The HLA Standard Library provides the `bits.hhf` module that provides several
    bit-related functions, including built-in functions for many of the algorithms
    we've studied in this chapter. This section describes some of the functions available
    in the HLA Standard Library.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库提供了`bits.hhf`模块，该模块提供了多个与位操作相关的函数，包括本章所研究的许多算法的内置函数。本节将介绍HLA标准库中一些可用的函数。
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This procedure returns the number of 1 bits present in the `b` parameter. It
    returns the count in the EAX register. To count the number of 0 bits in the parameter
    value, invert the value of the parameter before passing it to `bits.cnt`. If you
    want to count the number of bits in a 16-bit operand, simply zero extend it to
    32 bits prior to calling this function. Here are a couple of examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程返回`b`参数中1位的数量。它将结果存储在EAX寄存器中。要统计参数值中0位的数量，可以在将参数传递给`bits.cnt`之前，先对参数的值取反。如果你想统计16位操作数中的位数，只需在调用此函数之前将其零扩展到32位。以下是几个示例：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to compute the number of bits in an 8-bit operand, it's probably
    faster to write a simple loop that rotates all the bits in the source operand
    and adds the carry into the accumulating sum. Of course, if performance isn't
    an issue, you can zero extend the byte to 32 bits and call the `bits.cnt` procedure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算一个 8 位操作数的位数，可能更快的方法是编写一个简单的循环，旋转源操作数中的所有位并将进位加到累积和中。当然，如果性能不是问题，你可以将字节零扩展到
    32 位并调用 `bits.cnt` 过程。
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function takes the L.O. *n* bits of `source`, where *n* is the number of
    1 bits in `mask`, and inserts these bits into `dest` at the bit positions specified
    by the 1 bits in `mask` (that is, the same as the distribute algorithm appearing
    earlier in this chapter). This function does not change the bits in `dest` that
    correspond to the zeros in the `mask` value. This function does not affect the
    value of the actual `dest` parameter; it returns the new value in the EAX register.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数提取 `source` 的最低 *n* 位，其中 *n* 是 `mask` 中 1 位的数量，并将这些位插入到 `dest` 中，位置由 `mask`
    中的 1 位指定（即，与本章前面出现的分发算法相同）。该函数不会更改 `dest` 中对应于 `mask` 中零的位。该函数不会影响实际的 `dest` 参数值；它将在
    EAX 寄存器中返回新值。
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function is the converse of `bits.distribute`. It extracts all the bits
    in source whose corresponding positions in `mask` contain a 1\. This function
    coalesces (right justifies) these bits in the L.O. bit positions of the result
    and returns the result in EAX.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是 `bits.distribute` 的反向操作。它提取 `source` 中所有在 `mask` 中对应位置为 1 的位。该函数将这些位合并（右对齐）到结果的最低有效位位置，并将结果返回在
    EAX 寄存器中。
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function extracts the first set bit in `d` searching from bit 0 and returns
    the index of this bit in the EAX register; the function also returns the zero
    flag clear in this case. This function also clears that bit in the operand. If
    `d` contains 0, then this function returns the zero flag set and EAX will contain
    −1.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从第 0 位开始搜索 `d` 中的第一个设置位，并在 EAX 寄存器中返回该位的索引；此时，函数还会清除零标志。该函数还会清除该操作数中的该位。如果
    `d` 为 0，则该函数返回零标志设置，并且 EAX 将包含 -1。
- en: Note that HLA actually implements this function as a macro, not a procedure.
    This means that you can pass any double-word operand as a parameter (a memory
    or a register operand). However, the results are undefined if you pass EAX as
    the parameter (because this function computes the bit number in EAX).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA 实际上是将此功能实现为宏，而不是过程。这意味着你可以将任何双字操作数作为参数（内存或寄存器操作数）。然而，如果将 EAX 作为参数传递，结果将是未定义的（因为此函数计算的是
    EAX 中的位数）。
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These three routines return their parameter value with its bits reversed in
    the accumulator register (AL/AX/EAX). Call the routine appropriate for your data
    size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种例程返回其参数值，并在累加器寄存器（AL/AX/EAX）中反转其位。根据数据大小调用适合的例程。
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These routines merge two streams of bits to produce a value whose size is the
    combination of the two parameters. The bits from the `even` parameter occupy the
    even bit positions in the result; the bits from the `odd` parameter occupy the
    odd bit positions in the result. Notice that these functions return 16, 32, or
    64 bits based on byte, word, and double-word parameter values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程将两个位流合并，生成一个其大小为两个参数合并后的值。`even` 参数的位占据结果中的偶数位，`odd` 参数的位占据结果中的奇数位。请注意，这些函数根据字节、字和双字参数值返回
    16、32 或 64 位。
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These routines extract each nibble from the parameter and place those nibbles
    into individual bytes. The `bits.nibbles8` function extracts the two nibbles from
    the `b` parameter and places the L.O. nibble in AL and the H.O. nibble in AH.
    The `bits.nibbles16` function extracts the four nibbles in `w` and places them
    in each of the 4 bytes of EAX. You can use the `bswap` or rox instructions to
    gain access to the nibbles in the H.O. word of EAX. The `bits.nibbles32` function
    extracts the eight nibbles in EAX and distributes them through the 8 bytes in
    EDX:EAX. Nibble 0 winds up in AL and nibble 7 winds up in the H.O. byte of EDX.
    Again, you can use `bswap` or the rotate instructions to access the upper bytes
    of EAX and EDX.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程从参数中提取每个半字节，并将这些半字节放入单独的字节中。`bits.nibbles8` 函数从 `b` 参数中提取两个半字节，并将最低有效半字节放入
    AL，将最高有效半字节放入 AH。`bits.nibbles16` 函数提取 `w` 中的四个半字节，并将它们放入 EAX 的四个字节中。你可以使用 `bswap`
    或旋转指令访问 EAX 中高字的半字节。`bits.nibbles32` 函数从 EAX 中提取八个半字节，并将它们分布到 EDX:EAX 中的 8 个字节。半字节
    0 会出现在 AL 中，半字节 7 会出现在 EDX 的最高字节中。同样，你可以使用 `bswap` 或旋转指令访问 EAX 和 EDX 的上半部分字节。
- en: 10.14 For More Information
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.14 更多信息
- en: The electronic edition of The Art of Assembly Language at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    and [http://www.artofasm.com/](http://www.artofasm.com/) contains some additional
    information you may find useful when developing bit-manipulation algorithms. In
    particular, the chapter on digital design discusses boolean algebra, a subject
    that you will find essential when working with bits. The HLA Standard Library
    reference manual contains more information about the HLA Standard Library bit-manipulation
    routines. See that documentation on the website for more information about those
    functions. As noted in the section on bit counting, the AMD Athlon optimization
    guide contains some useful algorithms for bit-based computations. Finally, to
    learn more about bit searching algorithms, you should pick up a textbook on data
    structures and algorithms and study the section on string-matching algorithms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 《汇编语言艺术》的电子版可在[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)和[http://www.artofasm.com/](http://www.artofasm.com/)找到，里面包含了一些在开发位操作算法时可能会用到的附加信息。特别是关于数字设计的章节讨论了布尔代数，这是你在处理位操作时必须掌握的一个重要内容。HLA标准库参考手册包含了更多关于HLA标准库位操作例程的信息。有关这些函数的更多信息，请查阅网站上的文档。正如在位计数章节中所提到的，AMD
    Athlon优化指南中包含了一些用于位运算的有用算法。最后，为了了解更多关于位搜索算法的内容，你应该阅读一本数据结构与算法的教材，并深入学习其中的字符串匹配算法部分。
