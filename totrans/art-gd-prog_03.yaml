- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2D Graphics and Animation
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 27: Saving an Image and Adjusting Transparency'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to write a sketch that will allow the user to select a color in
    an image that will become transparent, and then save the image as a GIF. We can
    save any `PImage` in a file, just as most image files can be read into a `PImage`.
    If `img` is a `PImage` variable, we can save it as a file using this function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter is the name of the file to be created. In the situation above,
    it will create a file named *image.jpg* and save the pixels of the `PImage` in
    JPEG format. The format is conveniently determined by the last three letters of
    the filename: *.jpg* for a JPEG file, *.gif* for a GIF file, *.png* for a PNG
    file, and so on. If no `PImage` variable is given, Processing saves the image
    that appears in the sketch window.'
  prefs: []
  type: TYPE_NORMAL
- en: For this sketch, the first step is to read and display the image. Next, we position
    the mouse over a pixel with the color we want to make transparent, and click the
    button. Finally, we save the image in a format that allows transparency (GIF).
  prefs: []
  type: TYPE_NORMAL
- en: In Sketch 2 I mentioned transparent colors. We can set a fourth color component,
    referred to as alpha, to a value between 0 (completely transparent) and 255 (completely
    opaque), as long as the `PImage` color format allows transparency; the format
    that does this is `ARGB`. In this sketch, when the image is read in, we make a
    copy as in the previous sketch, but using `ARGB` as the color format. When we
    click the mouse button, the program looks at the pixel at the cursor’s coordinates
    and adds an alpha value of 0 to the color coordinates. Then the color in the `PImage`
    is updated with the new alpha value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original image that we read from the file is a variable named `img1`; the
    copy that includes alpha values is `img2`. Processing makes a copy of the image
    using the following statement, as we do at 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates an empty image of the correct size, and now we must copy all of
    the pixels from `img1` into `img2`. When we do so, the pixels in `img2` have the
    alpha component, because it was specified in the `createImage()` call. When a
    mouse click specifies a background color, all pixels of that color are given an
    alpha value of 0 1. Then `img2` is saved in a file named *out.gif*.
  prefs: []
  type: TYPE_NORMAL
- en: The program ends with a call to `exit()`, because otherwise it would continue
    to save the same file again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important to set a transparent background for an image? Computer games!
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 28: Bouncing an Object in a Window'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch illustrates a good way to check whether an object is within a sketch
    window (though it is only completely accurate when the object is circular). The
    object here is a circle, or a ball if you prefer. The program moves the ball,
    and when the ball reaches the window boundary (the “wall”), it bounces, or reverses
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: A simple test establishes whether the ball has exceeded the boundary. In the
    case of the right boundary wall, for example, it’s whether `x + radius > width`
    2, where `x` is the ball’s center position, `radius` is the ball’s radius, and
    `width` is the width of the window. If the ball is moving slowly enough, we can
    simply reverse the direction of motion when the ball passes this test by changing
    `dx` (the amount the ball moves horizontally between each frame) to `-dx`. However,
    this approach isn’t completely accurate, and it gets worse when the ball moves
    at high speeds. Why? Because the ball will move past the boundary before the program
    determines that it has reached the boundary. Consider the situation in [Figure
    28-1](#figure28-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f28001](Images/f28001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-1: A fast-moving ball might overshoot a boundary before you can tell
    it to bounce back.'
  prefs: []
  type: TYPE_NORMAL
- en: If the chosen `dx` value has the ball moving several diameters per frame, it
    can easily be on the left of the wall in one frame and on the right of the wall
    in the next. At some time in between, it must have collided with the wall. In
    that case, the amount the ball has overshot the wall should be found, and the
    ball should be placed an equivalent distance to the left of the wall, to simulate
    a bounce. We calculate that distance as `delta` (Δ), and it equals `(x + radius)
    - width` 1 for a circle. Given this distance, the ball’s new, post-bounce x position
    is `width - delta - radius` 3, as shown at the bottom of [Figure 28-1](#figure28-1).
  prefs: []
  type: TYPE_NORMAL
- en: At the left side of the window, we know the ball has overshot the boundary when
    `x < radius` 4. In this case, we reposition the ball by setting `x` to `(2 * radius)
    - x` 5, and we reverse the ball’s direction of motion.
  prefs: []
  type: TYPE_NORMAL
- en: The vertical (*y*) situation is symmetrical 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 29: Basic Sprite Graphics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can combine the previous two sketches to show how programmers move sprites
    about in computer games. A sprite is a relatively low-resolution graphic that
    represents an object in a game. Sprites are usually primitive shapes or imported
    images. If the latter, the sprite image must have a transparent color so that
    we can see the background behind the sprite; otherwise the sprite would look like
    a rectangle of solid color with an image within it.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch uses the rocket of Sketch 27 as the sprite and the code of Sketch
    28 to move it about in the window. The rocket will move over a background image
    of stars to complete the game-like appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test to see whether the rocket has reached a side differs from the circle
    example because the sprite is a rectangular image drawn from the upper-left corner,
    and the distance to the boundary differs between left/right and up/down. The test
    against the left edge is nearly the same as before, but the offset by the radius
    is missing because the x-coordinate is on the left side of the sprite and not
    at its center 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The test on the right is different because the entire width of the sprite is
    also to the right of the coordinate `px` 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So `px+sprite.width` is the coordinate for the right side of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: The checks are symmetrical for the y-coordinate 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 30: Detecting Sprite-Sprite Collisions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a relatively simple matter to decide whether a sprite is still within
    a window, because the size of the window remains fixed and the window doesn’t
    move. But what if there were many sprites moving at the same time? How would we
    determine if any two had collided when both were moving? The situation of circular
    objects is the simplest and is a general solution, so this sketch will handle
    an arbitrary number of circular objects (balls) that will bounce off the boundaries
    and each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of each ball will be stored in the `xpos[]` and `ypos[]` arrays
    1. Drawing object `i` is simple 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Any two objects collide if they get nearer to each other than twice the radius,
    or in this case 10 pixels. These are the steps in the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: Define positions and speeds (`dx`, `dy`) for each of `nballs` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each step (frame) is defined by a call to `draw()`. First, draw a circle at
    each location `xpos[i]`, `ypos[i]` 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the position: `xpos[i] = xpos[i] + dx[i]`, and the same for `y` 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for a collision with the boundary (bounce), and if there is one, implement
    the reaction to the collision. A bounce? An explosion? 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each ball, check the distance between it and every other ball. If the distance
    is less than twice the radius, then change the direction of both balls (implementing
    a collision as a bounce) 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And that’s it. The `bounce()` function 6 is a little different from the previous
    one, but it effectively does the same thing. The `distance()` function calculates
    the Euclidean distance between the two balls, as you saw in Sketch 24\. If two
    balls overlap after bouncing, they could stick together until they collide with
    another ball.
  prefs: []
  type: TYPE_NORMAL
- en: '![f30001](Images/f30001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 30-1: The enclosing circle for a rectangular object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 31: Animation—Generating TV Static'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used random numbers before, in Sketches 8 and 30\. Random numbers serve
    a few important functions in games, simulations, and other software:'
  prefs: []
  type: TYPE_NORMAL
- en: Nature uses unpredictable forms and shapes. Placing trees in a forest in a two-dimensional
    grid is a giveaway that there was a mind at work in the planting. This does not
    happen in nature. Instead, trees in a forest have an average distance from each
    other and seem otherwise to form a random collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent creatures do not behave predictably. Cars on a freeway that all
    behave in the same manner look very odd. Cars have random distances from each
    other, random speeds, and random behaviors within a possible range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When playing poker or craps, the cards and dice ought to display random values,
    or the game is simply no fun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sketch draws a television set that looks as if it were tuned to a vacant
    channel. What is seen on the screen used to be called *snow*, and it is really
    pixels created by random voltages from signals received from space and various
    local electronic and electrical devices. We cannot predict what the TV will receive
    at any particular moment, so we draw a 2D set of random grey pixel values. This
    set of values changes every time the screen updates. There is an impression of
    random motion, rapid flashing of spots on the screen, but no organized images.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we display a background image of a TV set 1 and then set the pixels
    within the screen section to random black/white values each time `draw()` is called
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it appear as though a channel were poorly tuned in, we could display
    an image faintly over the static by setting the alpha for the image to a low value,
    perhaps 30 or so. The static would be visible through the image. The `tint()`
    function changes the color and transparency of whatever is drawn from then on,
    so we could use it to change the transparency of the channel image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The parameters to `tint()` are color coordinates, the first three being RGB
    and the fourth transparency (alpha). In the preceding example, the color is white
    (no actual tint) but the transparency is 127, which is half transparent.
  prefs: []
  type: TYPE_NORMAL
- en: In the code for this sketch, the tint and TV image are commented out. To see
    the image, remove the comment characters from those two lines 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 32: Frame Animation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animation involves displaying a sequence of still images on the screen at such
    a rate that the human visual system interpolates changes in position in the images
    and perceives motion. It is an illusion, in much the same way that any motion
    picture is an illusion. The previous sketch animated a display in a very basic
    manner, creating the illusion of random TV images by generating them with code.
    Most animations require that an image sequence be created by an artist and then
    displayed as a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: For a Processing sketch to display an animation, the program has to read in
    the images (frames) to be displayed and then display them one after the other.
    The set of frames can be stored in an array of `PImage` values, one per frame.
  prefs: []
  type: TYPE_NORMAL
- en: The two examples in this sketch use an image sequence that represents the gait
    of a human; the 11 images compose one entire cycle of a single step, and repeating
    them makes it appear as if the character is walking.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eleven images, named *a000.bmp* through *a010.bmp*, represent the animation.
    The program reads the images into consecutive elements of the `frames` array 1.
    The `draw()` function displays the next image in sequence each time it’s called,
    increasing an index variable `n` from 0 to 10 and decreasing it to 0 again repeatedly
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Example A we needed to know in advance how many images belonged to the animation.
    In Example B we only require that the names of the files begin with *a000.bmp*
    and that the number increases by one for consecutive images. When the program
    fails to read an image file, as indicated by the fact that `loadImage()` returns
    `null`, the program presumes that all of the images have been loaded 1. The program
    counts the images as they are read and then displays them as before.
  prefs: []
  type: TYPE_NORMAL
- en: The loop within which the images are loaded has a `break` 2 statement in it
    to escape the loop when `null` is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 33: Flood Fill—Filling in Complex Shapes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a rectangle or ellipse that is filled with a particular color is easy
    to do in Processing. You simply specify a fill color using the `fill()` function
    and then draw the shape. However, there’s no function for filling an arbitrary
    shape or region, so let’s make one. It has the advantage of showing you how filling
    is done in general.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch reads an image with a white background that contains regions outlined
    with black (though you can use other colors). The regions do not have to be regular
    polygons, but they should be closed, in that there is an inside and an outside,
    with no gaps in the edges. When the user clicks on a pixel, the region surrounding
    that pixel will be filled with a random color.
  prefs: []
  type: TYPE_NORMAL
- en: The pixel that is clicked on has a color, the background color (`bgcolor` in
    the sketch). A random color will be selected for the fill color (variable `fillColor`).
    The goal is to set all of the pixels within the region that currently have the
    background color value to the fill color. The first step is to set the selected
    pixel to the fill color, followed by setting all neighboring pixels repeatedly,
    until no more candidates remain.
  prefs: []
  type: TYPE_NORMAL
- en: After the first pixel is changed, every background-colored pixel that is a neighbor
    of it is also set to the fill color 1. A neighbor is defined as a pixel that is
    immediately adjacent either vertically or horizontally. Then all of the pixels
    are scanned again, and any background pixel that is a neighbor of a fill-colored
    pixel is set to the fill color. The process is shown in [Figure 33-1](#figure33-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f33001](Images/f33001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 33-1: Filling in neighboring pixels'
  prefs: []
  type: TYPE_NORMAL
- en: The process is repeated until no change is made. The process stops at the boundary
    because boundary pixels do not have the background color and are not changed.
    This is not the only method for implementing a fill, nor is it the fastest, but
    it is probably the easiest to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: The `mouseReleased()` function sets the values of the `bgColor` and `fillColor`
    variables and sets the first (seed) pixel to the fill color 3. The `nay()` function
    returns true if the pixel indicated by the parameters is a neighbor to a fill-colored
    pixel 2. Each time `draw()` is called (once per frame), it displays one iteration
    of the filling process, so the process appears animated.
  prefs: []
  type: TYPE_NORMAL
