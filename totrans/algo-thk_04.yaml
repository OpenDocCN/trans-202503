- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADVANCED MEMOIZATION AND DYNAMIC PROGRAMMING
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’re going to continue with memoization and dynamic programming.
    You don’t need to read this chapter to continue through the book. But there’s
    more to learn if you’d like to deepen your understanding. We’ll see how to make
    a dynamic-programming problem easier through a change in perspective, work with
    more than two dimensions in our subproblem arrays, and stretch our skills to go
    beyond the “optimize the solution” problems we’ve seen thus far. We’ll also get
    a bit more practice with the fundamentals. You’ll be a dynamic-programming rock
    star after this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: The Jumper'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start this chapter with a dynamic-programming problem that’s solvable
    using what we learned in [Chapter 3](ch03.xhtml). As in that chapter, we’ll be
    able to solve the problem by focusing on what the end of the optimal solution
    must look like. We’ll see, though, that this isn’t the only way to do it. In particular,
    we’ll see that we can instead focus not on the *end* of the optimal solution,
    but on its *beginning*. You may find this second approach more intuitive than
    the first, if not for this problem then perhaps for other problems. And once you
    learn this change in perspective, you’ll have two approaches to throw at your
    next dynamic-programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `crci07p2`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Nikola is playing a game on a row of *n* squares. The leftmost square is Square
    1 and the rightmost square is Square *n*. Nikola starts on Square 1 and wants
    to get to Square *n*. To do so, she makes one or more jumps. Her first jump is
    required to be from Square 1 to Square 2\. After that, the jumping rules are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Nikola can jump to the right by exactly one more than the number of squares
    on her previous jump. For example, if Nikola jumped 3 squares on her previous
    jump, then she can jump to the right by 4 squares now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nikola can jump to the left by exactly the same number of squares as on her
    previous jump. For example, if Nikola jumped 3 squares on her previous jump, then
    she can jump 3 squares to the left now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll use the term *jump distance* to refer to the number of squares moved on
    a given jump.
  prefs: []
  type: TYPE_NORMAL
- en: The valid squares here are those from 1 to *n*. Therefore, if a jump would take
    Nikola to the left of square 1 or to the right of square *n*, that jump is not
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Each square has an entry cost. Whenever Nikola jumps, she pays the entry cost
    of the square in which she lands.
  prefs: []
  type: TYPE_NORMAL
- en: We want to determine the minimum total cost for Nikola to get from Square 1
    to Square *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of squares in the row. *n* is between 2 and
    1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each giving the entry cost for a square. The first of these lines
    is the entry cost for Square 1, the second is the entry cost for Square 2, and
    so on. Each entry cost is an integer between 1 and 500.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum total cost for Nikola to get from Square 1 to Square *n*.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Through an Example*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s work through one test case to make sure we know exactly what we are being
    asked to do. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Nikola starts on Square 1 and has to get to Square 7\. Remembering that the
    first jump has to be to Square 2, here’s one possible route:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 1 to Square 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 5.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 2 to Square 4**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 9.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 4 to Square 7**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 3.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 3.
  prefs: []
  type: TYPE_NORMAL
- en: We made it to Square 7! The total cost is 5 + 9 + 3 = 17\. This is *not* the
    minimum total cost, though. Try to find it before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can get the minimum total cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 1 to Square 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 5.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 2 to Square 1**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 3.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance remains 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 1 to Square 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 1.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 3 to Square 6**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 2.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 6 to Square 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 1.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance remains 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Square 3 to Square 7**'
  prefs: []
  type: TYPE_NORMAL
- en: Cost 3.
  prefs: []
  type: TYPE_NORMAL
- en: Most recent jump distance is now 4.
  prefs: []
  type: TYPE_NORMAL
- en: The total cost this time is 5 + 3 + 1 + 2 + 1 + 3 = 15.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Backward Formulation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we can write any code, we need to settle on our subproblems and how to
    use these subproblems to characterize the structure of an optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Subproblems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How many subproblem parameters do we need? Could we get away with just one?
  prefs: []
  type: TYPE_NORMAL
- en: If we have only one subproblem parameter, then we could use it to keep track
    of which square Nikola is on. But then how would we know which jumps were allowed
    for a given subproblem? Think about the end of an optimal solution for getting
    from Square 1 to Square 4\. To get closer to a base case, we’d need to know which
    square Nikola was on prior to Square 4 so that we could make a recursive call
    to that earlier square. For example, if we knew that Nikola used a jump distance
    of 2 to get to Square 4, then we would know that prior to Square 4 she must have
    been on Square 2 or Square 6\. But we don’t know the jump distance that Nikola
    used—it’s not one of our subproblem parameters. This isn’t going to work.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try one more time with just one subproblem parameter. What if we use it
    to keep track of the most recent jump distance? Well, then we won’t have a subproblem
    parameter available to tell us which square Nikola is on! And without knowing
    where Nikola is, we won’t have a way to know when we’ve reached the base case
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like we need two subproblem parameters: one to tell us the square
    that Nikola is on and one to tell us the jump distance that she used to get to
    that square.'
  prefs: []
  type: TYPE_NORMAL
- en: For each of these parameters, we need to decide whether to use “exactly.” In
    [Chapter 3](ch03.xhtml), we saw examples of using “exactly” subproblems when we
    solved Burger Fervor and Moneygrubbers. We also saw an example of *not* using
    “exactly” when we solved Hockey Rivalry. Had we used “exactly” in Hockey Rivalry,
    our subproblems would have forced specific games to be matched as rivalry games,
    which wasn’t needed for that problem.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it makes sense that we’d want to know *exactly* which square Nikola is
    on. We could use that to figure out exactly which square she was on prior to the
    most recent jump . . . well, not quite. We’d also need to know *exactly* the jump
    distance that she used to get to the current square. We could then use both the
    current square and jump distance to figure out exactly where Nikola must have
    come from. That is, we need “exactly” for both subproblem parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem description specifies that we have no choice for the first jump:
    it has to be from Square 1 to Square 2\. Instead of worrying about maintaining
    that condition in our subproblems, we’ll just ignore it: our subproblems will
    tell us the minimum cost to get from Square 2 to some other square. Later, we’ll
    add the cost of jumping from Square 1 to Square 2, and that’ll give us our final
    solution.'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t use any old sequence of jumps from Square 2, though. Think about what
    would happen if our solution from Square 2 started with a jump of distance 3\.
    We need to jump from Square 1 to Square 2 first and, uh-oh, a jump distance of
    3 is not allowed to follow that! We need to ensure that our subproblems solve
    only for solutions that are feasible given that we’ll prepend the jump from Square
    1 to Square 2\. We’ll call such solutions *connectible*.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now we’re ready for the subproblems! The subproblem with parameters *i*
    and *j* will tell us the minimum cost of a connectible solution from Square 2
    to exactly Square *i* using a final jump distance of exactly *j*.
  prefs: []
  type: TYPE_NORMAL
- en: That subproblem definition is quite a mouthful. Let’s use the test case from
    the prior section to nail down a few examples of how the definition works.
  prefs: []
  type: TYPE_NORMAL
- en: What is the solution for the subproblem when *i* = 7 and *j* = 3? This is asking
    us for the best connectible solution that starts at Square 2, ends at Square 7,
    and has a final jump distance of 3\. The answer is 12, witnessed by Nikola jumping
    from Square 2 to Square 4 (cost 9), to Square 7 (cost 3). (Remember we’re ignoring
    the cost of jumping from Square 1 to Square 2 in these subproblems.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the solution for the subproblem with *i* = 7 and *j* = 4? The answer
    is 10: Nikola can jump from Square 2 to Square 1 (cost 3), then to Square 3 (cost
    1), to Square 6 (cost 2), to Square 3 (cost 1), and finally to Square 7 (cost
    3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about *i* = 7 and *j* = 2? Try it, and you should find that achieving
    this is impossible: there’s no way to find a connectible solution that gets from
    Square 2 to Square 7 with a final jump distance of 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more: *i* = 2 and *j* = 1\. We’re already at Square 2 here. Furthermore,
    *j* = 1 means that we need a jump of distance 1 to get us to Square 2\. No problem:
    the jump from square 1 to Square 2 that we’re going to prepend is exactly this
    kind of jump! The answer here is therefore 0\. Hmm, I think we may have just found
    a base case.'
  prefs: []
  type: TYPE_NORMAL
- en: Characterizing Optimal Solutions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider a subproblem with some value of *i* and some value of *j*. What might
    the optimal solution look like for this subproblem?
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  prefs: []
  type: TYPE_NORMAL
- en: One option is that this optimal solution ends with a jump to the right. The
    *j* value gives us the distance of this jump, so we know that this jump must have
    been from Square *i* – *j*. In order to jump to the right by *j*, Nikola must
    have gotten to her previous square with a jump distance of *j* – 1\. (Why *j*
    – 1? Because a jump to the right is required to have a jump distance that’s one
    more than the jump distance of the previous jump.) So the solution for this option
    is the solution to the subproblem for Square *i* – *j* and jump distance *j* –
    1, plus the entry cost of Square *i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yikes—it can be confusing thinking about the solution backward like this! For
    example, we’re talking about jumping to the right, yet we’re using a Square *i*
    – *j* that’s to the left. But remember: we’re looking for the square that Nikola
    came from, so if she jumped to the right from that square, then she indeed came
    from a smaller-numbered square.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is that this optimal solution ends with a jump to the left.
    The *j* value gives us the distance of this jump, so we know that this jump must
    have been from Square *i* + *j*. In order to jump to the left by *j*, Nikola must
    have gotten to her previous square with a jump distance of *j*. So the solution
    for this option is the solution to the subproblem for Square *i* + *j* and jump
    distance *j*, plus the entry cost of Square *i*.
  prefs: []
  type: TYPE_NORMAL
- en: Solving One Subproblem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s skip the bare recursive solution and work on a memoized solution. To
    do so, we’ll start by writing the code for the following `solve_ij` function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function solves the subproblem for the given values of `i` and `j`. Here’s
    what each parameter is for:'
  prefs: []
  type: TYPE_NORMAL
- en: cost   The array of entry costs. The entry cost for Square 1 is `cost[1]`, the
    entry cost for Square 2 is `cost[2]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: n   The number of squares in the row.
  prefs: []
  type: TYPE_NORMAL
- en: i   The ending square for this subproblem.
  prefs: []
  type: TYPE_NORMAL
- en: j   The final jump distance for this subproblem.
  prefs: []
  type: TYPE_NORMAL
- en: memo   The memoization array.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this function is given in [Listing 4-1](ch04.xhtml#ch04ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Solving one subproblem*'
  prefs: []
  type: TYPE_NORMAL
- en: As we did when solving Burger Fervor in [Chapter 3](ch03.xhtml), we use `-2`
    in the `memo` array ➊ to indicate that a subproblem hasn’t been solved yet. The
    typical value to use here would be `-1`, but we’ll use `-1` to indicate that we’ve
    already tried to solve a subproblem but that it has no solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discovered in the previous section, an important base case is when we’re
    on square 2 and need to get to that square with a jump of distance 1 ➋. In this
    case, we return `0`: there’s no cost to get from Square 2 to Square 2!'
  prefs: []
  type: TYPE_NORMAL
- en: Next we try each of the two options for an optimal solution. We use the variable
    `first` to hold the value for Option 1 and `second` to hold the value for Option
    2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the option where Nikola jumps to the right to get to Square `i`. To
    use this option, we need to ensure that Nikola would have come from a valid square.
    We also need to ensure that `j` is at least `2` ➌, which guarantees that she got
    to the previous square with a jump distance of at least 1\. After all, it wouldn’t
    make sense to say that Nikola got to a prior square using a jump of distance 0!
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the option where Nikola jumps to the left to get to Square `i`. As in
    the previous option, we need to ensure that Nikola came from a valid square ➍.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible for one or both options to fail to find a solution; in those cases
    we use a value of `-1`. If both options fail, then we return `-1` ➎. The rest
    of the code determines which of the two options is best, and returns that plus
    `cost[i]` as the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Where’s the Optimal Solution?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we can solve any subproblem we want. So, what call of `solve_ij` should
    we make to find the solution to the original problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'Trick question: one call won’t be enough! We’re going to need to do some searching,
    much as we did when we solved Burger Fervor and Money-grubbers in [Chapter 3](ch03.xhtml).
    But why?'
  prefs: []
  type: TYPE_NORMAL
- en: We know for sure that we need to end exactly on Square *n*, so we don’t need
    any searching there. What we *don’t* know is the jump distance that we should
    have used as the final jump. Should we have ended with a jump distance of 2? 3?
    4? Who knows? We need to try them all and pick the best one. See [Listing 4-2](ch04.xhtml#ch04ex02)
    for the code to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: This function is where we set up the `memo` array ➊ so that it’s shared across
    all calls to `solve_ij`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `best` variable holds the best solution that we’ve found thus far. It begins
    at `-1` ➋ and is updated whenever we find a better solution ➍ ➎. Be careful: we
    need to add `cost[2]` here in order to reincorporate the jump from Square 1 to
    Square 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re looping through the final jump distances between `1` and `n`
    ➌. There’s no point trying any final distance larger than `n` because they can’t
    lead to a valid square. That is, we’re guaranteed to find the best final jump
    distance because we’re trying all of the valid possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s time to wrap up this solution. All we need is a `main` function to read
    the input and call `solve`. The code is in [Listing 4-3](ch04.xhtml#ch04ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge, you should pass all test cases within the
    time limit.
  prefs: []
  type: TYPE_NORMAL
- en: But we can still do better.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Forward Formulation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s first talk about why Solution 1 is fast, and then discuss why we can still
    improve it.
  prefs: []
  type: TYPE_NORMAL
- en: How Fast is Solution 1?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Solution 1 is an *O*(*n*²) algorithm. It’d be easier to see that from a bottom-up
    dynamic-programming solution, with its telltale two nested loops, but we can still
    make an argument using our memoized solution. Our `solve_ij` function ([Listing
    4-1](ch04.xhtml#ch04ex01)) fills in each of the *n*² elements of `memo` at most
    once. To fill in each such element, our code makes two recursive calls. We can
    therefore say that our code makes at most 2*n*² recursive calls. Beyond that,
    each recursive call of `solve_ij` performs a constant number of steps to decide
    whether to use `first` or `second` in the optimal solution. So `solve_ij` takes
    *O*(*n*²) time throughout all recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of squares in a row is 1,000\. Our *O*(*n*²) algorithm is
    therefore performing something like 1,000² = 1,000,000 steps. We can do that easily
    within our 0.6-second time limit.
  prefs: []
  type: TYPE_NORMAL
- en: All right, so Solution 1 is fast. What could we possibly want to improve, then?
  prefs: []
  type: TYPE_NORMAL
- en: Backward vs. Forward
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Perhaps you’ve been bothered by an incongruity between the way that Nikola’s
    jumps are described in the problem description and the way that we thought about
    jumps in our memoized solution. The problem description tells us what Nikola can
    do on each jump starting from the first jump. That is, it focuses on where Nikola
    is right now and what she can do next. Our memoized solution, by contrast, focuses
    on where Nikola got to and how she got there. For example, rather than thinking,
    “Nikola jumped from Square 2 to Square 4,” we have to think, “Nikola got to Square
    4 by jumping from Square 2.” We have to think about the problem backward!
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to those extra mental gymnastics, our backward formulation has
    a consequence on the amount of code we have to write as well. Remember how we
    had to search through all possible final jump distances in [Listing 4-2](ch04.xhtml#ch04ex02)?
    The reason we needed that is because we don’t know how the optimal solution ends.
    Maybe it ends with a jump distance of 2, or a jump distance of 3, or a jump distance
    of 4, and so on. But we *do* know exactly how it begins: with a jump distance
    of 1 from Square 1 to Square 2! As long as we keep track of the most recent jump
    distance, we’ll never have to guess what it might be. That is, if we solve the
    problem forward (keeping track of where we are) rather than backward (keeping
    track of where we ended up), we’ll be able to entirely avoid the jump-distance
    search. We’ll get to the end of the optimal solution with whatever we need the
    final jump distance to be.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Subproblems, Again
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll stick with our earlier idea of using two subproblem parameters. That’s
    because we need one to tell us the square that Nikola is on and one to tell us
    the jump distance that she used to get to that square.
  prefs: []
  type: TYPE_NORMAL
- en: This time, the subproblem with parameters *i* and *j* is going to tell us the
    minimum cost of a solution from exactly Square *i* to Square *n* given that Square
    *i* was reached with a jump distance of exactly *j*.
  prefs: []
  type: TYPE_NORMAL
- en: We need some examples of this! We’ll again use the test case from “Working Through
    an Example” on [page 127](ch04.xhtml#sec58).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the subproblem with *i* = 2 and *j* = 1\. This is asking us
    for the best solution that starts at Square 2, ends at Square 7, and got to Square
    2 using a jump distance of 1\. (Notice that we don’t care at all about the jump
    distance that ultimately takes us to Square *n*. It could be anything!) The answer
    here is 10: Nikola can jump from Square 2 to Square 1 (cost 3), to Square 3 (cost
    1), to Square 6 (cost 2), to Square 3 (cost 1), to Square 7 (cost 3). Hey, that’s
    the same answer as for the *i* = 7, *j* = 4 subproblem from the backward formulation!
    But in the backward formulation, we would have to try all final jump distances
    to confirm that this is the optimal one. No longer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think about any subproblem with *i* = *n*. What’s the answer? It’s 0: we’re
    already on square *n*! We don’t care what *j* is, because we don’t care how we
    got to Square *n*. We’ve found our base case again.'
  prefs: []
  type: TYPE_NORMAL
- en: Characterizing Optimal Solutions, Again
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to redo our optimal substructure work from Solution 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  prefs: []
  type: TYPE_NORMAL
- en: One option is that Nikola next makes a jump to the right. The *j* value gives
    us the jump distance to the current square. The jump to the right will have distance
    *j* + 1, and Nikola will therefore land on Square *i* + *j* + 1\. So the solution
    for this option is the entry cost of Square *i* + *j* + 1, plus the solution to
    the subproblem for Square *i* + *j* + 1 and jump distance *j* + 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is that Nikola next makes a jump to the left. That jump to
    the left will have distance *j*, and Nikola will therefore land on Square *i*–*j*.
    So the solution for this option is the entry cost of Square *i*–*j*, plus the
    solution to the subproblem for Square *i* – *j* and jump distance *j*.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Needed Subproblem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we can write a `solve` function that solves a subproblem of our choice.
    See [Listing 4-4](ch04.xhtml#ch04ex04) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Solution 2*'
  prefs: []
  type: TYPE_NORMAL
- en: As in our backward formulation ([Listing 4-1](ch04.xhtml#ch04ex01)), we need
    to implement each of the two options for an optimal solution. In each case, we
    first check that the next square is a valid square ❶ ➋ prior to considering the
    jump.
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What call of `solve` should we make in order to find the solution to the original
    problem?
  prefs: []
  type: TYPE_NORMAL
- en: That’s not a trick question this time—we know exactly which subproblem we need
    to solve! We need to solve the subproblem with *i* = 2 (starting on square 2)
    and *j* = 1 (getting to square 2 with a jump of distance 1). We can incorporate
    this in our `main` function that reads the input. Check out the code in [Listing
    4-5](ch04.xhtml#ch04ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, I prefer the forward solution, but you may instead prefer
    the backward solution—it’s an individual choice!
  prefs: []
  type: TYPE_NORMAL
- en: When I’m working on a memoization or dynamic-programming solution, I always
    start by trying to formulate a backward solution. Backward solutions often feel
    more natural to me because they more closely model the way that I think about
    recursion. If I get stuck for too long, though, or when there’s friction between
    the forward nature of the problem description and the backward formulation, I’ll
    give it a whirl with a forward solution. Keep both of these complementary approaches
    in your dynamic-programming toolbox!
  prefs: []
  type: TYPE_NORMAL
- en: What About Dynamic Programming?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have a perfectly good forward memoized solution for this problem. Still,
    you might want to develop a dynamic-programming solution. If you do, there’s a
    bit of a surprise waiting in there!
  prefs: []
  type: TYPE_NORMAL
- en: 'Think back to how we solved Hockey Rivalry in [Chapter 3](ch03.xhtml) with
    dynamic programming. In “Solution 3: Dynamic Programming” on [page 119](ch03.xhtml#sec55),
    we learned that we need to figure out the order in which to solve the subproblems.
    In Hockey Rivalry, we did this by solving all of the subproblems in row 0 from
    left to right, then all of the subproblems in row 1 from left to right, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: But that order won’t work for us now.
  prefs: []
  type: TYPE_NORMAL
- en: What do we need in order to solve `dp[i][j]`? From Option 1, we need to have
    already solved `dp[i + j + 1][j + 1]`; that is, we need something from a higher-numbered
    column. From Option 2, we need to have already solved `dp[i - j][j]`; that is,
    we need something from a lower-numbered row in the current column. Taken together,
    we need to solve all of the subproblems in column `n`, then all of the subproblems
    in column `n - 1`, and so on. And within each column, we need to solve the subproblem
    in row 1, then row 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the double `for` loop that we can use to solve the subproblems in the
    right order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Always be careful with the order that you solve the subproblems!
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to see the full dynamic-programming solution, please check the
    online resources for this book. Otherwise, we’re ready to continue here with another
    dynamic-programming problem. A real doozy. You’re so ready for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Ways to Build'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The four dynamic-programming problems that we’ve solved so far (three in [Chapter
    3](ch03.xhtml) and one in this chapter) asked us to maximize (Burger Fervor and
    Hockey Rivalry) or minimize (Moneygrubbers and The Jumper) the value of a solution.
    I’d like to end this chapter with a problem of a slightly different flavor: rather
    than find an optimal solution, we’ll count the number of possible solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: One other difference that will arise is in the number of dimensions of our subproblem
    array. In the four earlier problems, we used a one- or two-dimensional array of
    subproblem solutions. We’re going to need more dimensions than that to solve this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `noip15p5`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re given a source string *a*, a target string *b*, and an integer *k*. We
    want to build *b* from *a* by putting together *k* substrings of *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some rules that we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to use the substrings of *a* in the same order that they occur in *a*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re not allowed to use any empty substrings—each one has to have at least
    one character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’re not allowed to use substrings that overlap: if we use some character
    from *a* in one of our substrings, then we are not allowed to use that character
    in some other substring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to use exactly *k* substrings of *a* to build *b*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, let’s say that *a* is `xxyzxyz`, *b* is `xxyz`, and *k* is `3`.
    One way to build *b* by putting together three substrings of *a* is to take the
    `x` from the beginning of *a*, the `xy` to the right of that, and the `z` from
    the end of *a*. Putting those substrings together gives us `xxyz`, exactly the
    string *b* that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there may be many different ways to build *b* from *a*. But notice that
    as long as we follow the rules it doesn’t matter how we build *b*—each way is
    just as good as the others. It therefore doesn’t make sense to talk about the
    optimal way to build *b*. What we’re asked to determine for this problem, then,
    is not the best way to build *b*, but the total number of ways that we can build
    *b*. In the previous example, there are 11 ways. Can you find them all?
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, the information for which is spread over
    three lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line contains three numbers: the length of String *a*, the length
    of String *b*, and the integer *k* giving the number of substrings that we must
    take from *a* to build *b*. The length of String *a* is between 1 and 1,000, the
    length of String *b* is between 1 and 200, and *k* is between 0 and 200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains the String *a*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains the String *b*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the number of ways we can build *b* using exactly *k* substrings of *a*.
  prefs: []
  type: TYPE_NORMAL
- en: This number may be huge. To spare us from integer overflow worries, the problem
    specifies that we output this number mod 1,000,000,007.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Through an Example*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Were you able to find all 11 ways to build *b* for the example that I gave in
    the problem description? Let’s make sure you have them all, as we’ll be using
    this as a running example for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the example in the form of a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For quick reference, here are the indices for the characters of *a*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How can we build `xxyz` from `xxyzxyz` using exactly three substrings? In the
    following, I’ll indicate each substring of *a* using a range of indices; for example,
    0-0 refers to the substring of *a* that consists of the character at index 0,
    and 1-2 refers to the substring of *a* consisting of the characters at indices
    1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are five ways to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 5-5 (`y`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-1 (`x`), 4-5 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 4-5 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 2-2 (`y`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-2 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice in each of these ways that our final substring is the final character
    *z* from *a*. That is, we’ve fixed the final substring to be that `z` and then
    searched for ways to take two substrings from `xxyzxy` to build `xxy`. We are
    starting to see how we can find solutions to the initial problem by finding solutions
    to smaller subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six remaining ways. Let’s get those down:'
  prefs: []
  type: TYPE_NORMAL
- en: 1-1 (`x`), 4-4 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 4-4 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-1 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 2-2 (`y`), 3-3 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-2 (`xy`), 3-3 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-1 (`x`), 2-3 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding up the five ways from before, we now have a total of 5 + 6 = 11 ways
    to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Using “Exactly” Subproblems*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to identify our subproblems and then use them to find all optimal solutions.
    We’ll try for a backward formulation.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Subproblems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How many subproblem parameters will we need this time?
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep track of where we are in String *a* and keep track of where
    we are in String *b*. That’s a good start, but it isn’t quite enough. We also
    need a subproblem parameter to tell us how many more substrings to take. For the
    first time, we’re going to use three subproblem parameters!
  prefs: []
  type: TYPE_NORMAL
- en: We did well using “exactly” subproblem parameters when we solved The Jumper
    earlier in this chapter. As usual, we need to decide whether to use it for each
    of our subproblem parameters here. It makes sense to use “exactly” for the parameter
    that tracks how many more substrings to take, because we need to use exactly that
    number of substrings (not, for instance, at most that number of substrings). It’s
    less clear what to do for the subproblem parameters that keep track of where we
    are in *a* and where we are in *b*. Let’s just start with “exactly” parameters
    for those, too, and see what happens. In what follows, we’ll use the notation
    *s*[*i*..*j*] to refer to the characters from index *i* up to and including index
    *j* of String *s*.
  prefs: []
  type: TYPE_NORMAL
- en: The subproblem with parameters *i*, *j*, and *k* is going to tell us the number
    of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build exactly
    *b*[0..*j*], with the restriction that the rightmost substring ends with exactly
    the character *a*[*i*].
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our running example to clarify how these subproblems work. What’s
    our answer for the subproblem with *i* = 6, *j* = 3, and *k* = 3? (Don’t answer
    “11” too quickly!)
  prefs: []
  type: TYPE_NORMAL
- en: Since *a*[0..6] is all of *a*, and *b*[0..3] is all of *b*, this subproblem
    is asking about the full *a* and *b* strings. So we’re looking for all ways to
    choose exactly three substrings from *a* to build *b*, with the restriction that
    the rightmost substring ends with exactly the `z` at *a*[6].
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is 8! Here they are—the first five are the ones that use the final
    `z` in *a* as its own substring, and the remaining three use the final `yz` in
    *a* as its own substring:'
  prefs: []
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 5-5 (`y`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-1 (`x`), 4-5 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 4-5 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 2-2 (`y`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-2 (`xy`), 6-6 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-1 (`x`), 4-4 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 4-4 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-1 (`x`), 5-6 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But why can’t we include the missing solutions, like 0-1 (`xx`), 2-2 (`y`),
    3-3 (`z`)? Shouldn’t those count?
  prefs: []
  type: TYPE_NORMAL
- en: The reason we can’t use them here is because they don’t use that final `z` at
    *a*[6]. They don’t satisfy the requirements of the type of “exactly” subproblem
    that we’re using.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we have eight ways so far, and we do need to get to 11\. Looking
    at the *i* = 6, *j* = 3, *k* = 3 subproblem therefore isn’t enough. We can find
    the three missing ways by looking at the subproblem *i* = 3, *j* = 3, *k* = 3\.
    Those ways are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 0-1 (`xx`), 2-2 (`y`), 3-3 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-2 (`xy`), 3-3 (`z`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0-0 (`x`), 1-1 (`x`), 2-3 (`yz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in our backward formulation of The Jumper in this chapter and Burger Fervor
    and Moneygrubbers in [Chapter 3](ch03.xhtml), we’ll need to do some postprocessing
    to find what we need. In those other problems, we searched the relevant subproblems
    to discover the optimal one; here, we’ll search the relevant subproblems to find
    all possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Characterizing the Ways
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider an *i*, *j*, *k* subproblem as described in the previous section. There
    are two categories of ways to satisfy this subproblem. In each category, we require
    that *a*[*i*] is the same character as *b*[*j*]—if it isn’t, then the requirements
    of the subproblem are not met and the answer is zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 1**'
  prefs: []
  type: TYPE_NORMAL
- en: One category of ways involves using *a*[*i*] as the final substring. If we use
    up one substring on *a*[*i*], then we have *k* – 1 substrings to go, so we’ll
    continue by solving subproblems with *k* – 1 as the third parameter. Similarly,
    we’ll continue with *j* – 1 as the second parameter, because we just used character
    *b*[*j*].
  prefs: []
  type: TYPE_NORMAL
- en: What about the first parameter—what do we do there? Do we just do the same thing
    that we did with *j* and *k* and continue with *i* – 1?
  prefs: []
  type: TYPE_NORMAL
- en: Not necessarily! It’s true that continuing with *i* – 1 is one possibility,
    but there are others. We need to be able to skip some characters from *a* and
    continue at an earlier point. That is, we might want to match *b*[*j* – 1] with
    *a*[*i* – 2] or *a*[*i* – 3] or some even earlier character. We’re going to need
    a loop in here that tries all values of the first parameter up to *i* – 1, while
    fixing *j* – 1 for the second parameter and *k* – 1 for the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using our running example, consider again the subproblem with *i* = 6, *j* =
    3, and *k* = 3\. We know that the answer for this subproblem is 8\. Of those 8,
    there are 5 that fall into Category 1\. We get 3 of those 5 from the subproblem
    with *i* = 5, *j* = 2, and *k* = 2 and the other 2 from the subproblem with *i*
    = 2, *j* = 2, and *k* = 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 2**'
  prefs: []
  type: TYPE_NORMAL
- en: The other category of ways involves using at least two characters for the final
    substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a neat trick that we can use for this one. Imagine that we solve the
    subproblem with parameters *i* – 1, *j* – 1, and *k* (that’s right: the third
    parameter is *k*, not *k* – 1!). It turns out that this is the only subproblem
    that we need to solve!'
  prefs: []
  type: TYPE_NORMAL
- en: That subproblem uses all *k* substrings to find solutions that end by matching
    *a*[*i* – 1] with *b*[*j* – 1]. But each of those solutions can be extended to
    a solution that matches *a*[*i*] with *b*[*j*] by just tacking *a*[*i*] (or *b*[*j*]—they’re
    the same) on to the final substring. Similarly, any solution in this category
    that matches *a*[*i*] with *b*[*j*] and uses *k* substrings corresponds to a solution
    to the subproblem that matches *a*[*i* – 1] with *b*[*j* – 1] and uses *k* substrings.
    In conclusion, the number of solutions here is exactly the same as it is for the
    *i* – 1, *j* – 1, *k* subproblem.
  prefs: []
  type: TYPE_NORMAL
- en: In our running example, the subproblem with *i* = 6, *j* = 3, and *k* = 3 has
    three solutions in this category. We get that by looking up the answer to the
    subproblem with *i* = 5, *j* = 2, and *k* = 3.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there can not be any other categories besides these two. Category
    1 uses the single-character string *a*[*i*] as the final substring; Category 2
    uses a longer string that ends with *a*[*i*] as the final substring. There can’t
    be anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Solving One Subproblem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we did when solving The Jumper earlier in this chapter, we’ll skip the unadorned
    recursive solution and jump right to a memoized one. We need a function to tell
    us the answer for the subproblem with the given `i`, `j`, and `k` values. That
    function will have the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `a` is the source string; `b` is the target string; `i`, `j`, and `k`
    are the three subproblem parameters; and `memo` is the memoization array.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this function is given in [Listing 4-6](ch04.xhtml#ch04ex06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Solving one subproblem*'
  prefs: []
  type: TYPE_NORMAL
- en: When we solved Hockey Rivalry in [Chapter 3](ch03.xhtml), we started indexing
    our arrays at 1 rather than 0, and that simplified our solution a little. Here,
    however, I’ve decided to index starting at 0\. You could indeed use the Hockey
    Rivalry indexing trick here as well; I’ve chosen not to in order to spare us the
    trouble of defining what subproblems mean when the empty string is in play.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through the code, starting with the base cases.
  prefs: []
  type: TYPE_NORMAL
- en: Our first base case is when `j` is `0`, `k` is `1`, and `a[i]` and `b[j]` are
    the same character ➊. What we’re being asked for here is the number of ways to
    build the one-character string `b[0]` using `a[i]` given that `a[i]` matches `b[0]`.
    The answer is `1`, because we can use `a[i]` as a match!
  prefs: []
  type: TYPE_NORMAL
- en: Now, in any other case where `i` is `0`, or `j` is `0`, or `k` is `0` ➋, the
    answer is `0`. For example, if `i` is `0` and `j` is greater than `0`, then we’re
    being asked to choose substrings from a one-character string to build a string
    with more than one character. That would be impossible!
  prefs: []
  type: TYPE_NORMAL
- en: There’s actually one more base case here ➌, and it kicks in when characters
    `a[i]` and `b[j]` are not equal. In this case, we return `0` right away, because
    there’s no way to use that final character `a[i]` to match `b[j]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we arrive at the code for implementing each of the two categories. Each
    one adds its contribution to the `total` variable.
  prefs: []
  type: TYPE_NORMAL
- en: For Category 1, we need a loop ➍ that tries each relevant ending point of `a`,
    adding the subproblem answers to `total` ➎. We use the mod operator here as required
    by the problem description.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Category 2, we don’t need a loop: we just solve the one subproblem that
    directly gives us the answer ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the Solutions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to call `solve_ijk` using all values of `i`. That’s because any character
    of `a` might match the rightmost character of `b`. The code that calls `solve_ijk`
    in the needed ways is in [Listing 4-7](ch04.xhtml#ch04ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: In our prior dynamic-programming problems, we used `min` or `max` to find the
    best solution. But notice in [Listing 4-6](ch04.xhtml#ch04ex06) and [Listing 4-7](ch04.xhtml#ch04ex07)
    that we’re not doing that. Instead, because we want to find the total number of
    solutions, we are adding everything together using `+`.
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `main` function for this solution is in [Listing 4-8](ch04.xhtml#ch04ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a complete solution to this problem. Feel free to submit to the
    judge.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare to be disappointed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Adding More Subproblems*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the first time in this book, we have received a “Time-Limit Exceeded” error
    when using memoization. The thing is, even if we use memoization or dynamic programming,
    we may still have to be concerned with the efficiency of our algorithm. Some problems
    admit multiple such solutions that, while faster than exponential time, may still
    differ from each other in terms of their efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime of Solution 1
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s use *m* for the length of the source string, *n* for the length of the
    target string, and *k* for the number of substrings we need to take. There are
    a total of about *mnk* subproblems that our solution may end up solving. For each,
    we get hammered by Category 1 solutions, which require that we loop through the
    source string, adding another factor of *m* to our runtime. What we have, then,
    is an algorithm that takes a number of steps proportional to *m*²*nk*. To see
    how bad this is, let’s substitute the maximum values for these variables here:
    1,000 for *m*, 200 for *n*, and 200 for *k*. This will give us 1,000² × 200 ×
    200 = 40,000,000,000\. Forty billion! And we need to get all of this done with
    a two-second time limit? Not gonna happen. We need to do better. As we’ll see,
    we’ll be able to drop one of the factors of *m* and solve this thing in just *O*(*mnk*)
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two general strategies we might consider at this point. The first
    is to throw our existing subproblems away and try again with new subproblems.
    I tried doing that; you can check the online resources for this book to see what
    I came up with. It didn’t help.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing those subproblems away in this case is a needlessly drastic move. After
    all, we have a correct and reasonably efficient solution; the only hitch is the
    loop that we need for each subproblem in Category 1.
  prefs: []
  type: TYPE_NORMAL
- en: The second strategy, and the one that we will succeed with here, is to add new
    subproblems to our existing subproblems. This second strategy may seem counterintuitive.
    You might reason that if our program is already too slow, adding and solving more
    subproblems would just slow us down even further. But what if our new subproblems
    in fact helped us solve our existing subproblems faster? In particular, what if
    they gave us a way to solve subproblems from Category 1 without the need of a
    loop? And what if we could also solve those new subproblems efficiently? Then
    we’d be golden! We’ll be solving more subproblems, yes, but we’ll make up for
    it bigtime with how efficiently we can solve each subproblem. Let’s try!
  prefs: []
  type: TYPE_NORMAL
- en: The New Subproblems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Remember this bit of code from [Listing 4-6](ch04.xhtml#ch04ex06)?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That’s the loop that adds up all of the ways in Category 1\. It’s the loop we
    need to eliminate.
  prefs: []
  type: TYPE_NORMAL
- en: This `q` loop keeps `j - 1` and `k - 1` fixed, and varies the first subproblem
    parameter from `0` to `i - 1`. That is, it solves the 0, *j* – 1, *k* – 1 subproblem,
    then the 1, *j* – 1, *k* – 1 subproblem, then the 2, *j* – 1, *k* – 1 subproblem,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'How awesome would it be if we could look up, in one shot, the sum of all of
    these subproblem answers? Then we wouldn’t need the `q` loop at all. This is what
    our new subproblems are going to do for us. For example, a new subproblem with
    parameters *i* = 4, *j*, and *k* will be the sum of five of our old subproblems:
    the ones with the same *j* and *k* values, but where *i* is 0, 1, 2, 3, or 4\.
    That is, the new subproblems drop the requirement that *a*[*i*] is the same character
    as *b*[*j*]. Here are the definitions for both our old and new subproblems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Old**'
  prefs: []
  type: TYPE_NORMAL
- en: The old subproblem with parameters *i*, *j*, and *k* is going to tell us the
    number of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build
    exactly *b*[0..*j*], with the restriction that the rightmost substring ends with
    exactly the character *a*[*i*].
  prefs: []
  type: TYPE_NORMAL
- en: '**New**'
  prefs: []
  type: TYPE_NORMAL
- en: The new subproblem with parameters *i*, *j*, and *k* is going to tell us the
    number of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build
    exactly *b*[0..*j*].
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with these new subproblems, let’s return to our running example. What’s
    our answer for the new subproblem with *i* = 6, *j* = 3, and *k* = 3? This time
    it really is 11! The subproblem is asking, with no restrictions, for all the ways
    that we can choose exactly three substrings from *a* to build *b*. And we know
    that there are 11 of them. Notice, as a nice side bonus here, that we no longer
    need to solve multiple subproblems as in [Listing 4-7](ch04.xhtml#ch04ex07). All
    we need is the answer to one subproblem: the one that includes all characters
    of *a*, all characters of *b*, and the number of substrings *k*.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Needed Subproblem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s jump to the new code. For each triple of values `i`, `j`, and `k`, we’re
    going to store answers not for one, but for two subproblems. We’ll use a C struct
    to collect both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `end_at_i` member will store the number of solutions for our old subproblems
    (the ones from Solution 1), and the `total` member will store the number of solutions
    for our new subproblems. Our `memo` array stays as a three-dimensional array,
    with each element now consisting of both `end_at_i` and `total`. Other possible
    designs include two separate three-dimensional memo arrays or a four-dimensional
    array where the new dimension is of length 2.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write the code that will solve both our old and new subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: In all of our memoization and dynamic-programming code thus far, we had to figure
    out one answer for each setting of the subproblem parameters. But here we need
    to figure out two, one for each member of the struct. Look out for that as you
    read through the code. Check it out in [Listing 4-9](ch04.xhtml#ch04ex09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: Solution 2*'
  prefs: []
  type: TYPE_NORMAL
- en: As in Solution 1, a critical case here is when `j` is `0` and `k` is `1`. There
    are two important subcases to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the one where `a[i]` and `b[j]` are different characters ➊.
    We know that the `end_at_i` number of solutions is `0` here, as it would be in
    Solution 1\. But the `total` number of solutions might not be 0\. For example,
    if `i` were `4` and each of the first three characters of `a` were the same as
    `b[0]`, then our answer would be `3` here. To get them all, we make a recursive
    call to find the total number of matches using the characters from `a` up to index
    `i - 1` ➋. We then store in our `memo` array both the `total` answer that we calculated
    and the `end_at_i` answer of `0` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Our handling of the subcase where `a[i]` and `b[j]` are the same character is
    similar; we just need to add 1 to both `end_at_i` and `total` to account for the
    match between `a[i]` and `b[j]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s work on how to solve the current `end_at_i` subproblem. Recall that
    Category 1 involves using *a*[*i*] as the final substring, and Category 2 involves
    using at least two characters for the final substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easier to talk through Category 2, so let’s do that one first. That code
    is nearly the same as before: we retrieve the number of `end_at_i` solutions using
    the subproblem parameters `i - 1`, `j - 1`, and `k` ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: What about our new code for Category 1? This is our moment of victory, because
    we can solve such a subproblem in a single step ➍ by looking up the needed `total`
    subproblem directly!
  prefs: []
  type: TYPE_NORMAL
- en: There’s one final thing that we need to do. After all, we have those new `total`
    subproblems now. It’s our responsibility to solve those, too, so that they’re
    correct when we look them up. Fortunately, we’ll be able to solve each `total`
    subproblem quickly as well. To do it, we make use of the fact that we just found
    the number of solutions that use `a[i]`. We can just add that to the old total
    for `i - 1` to get our final total ➏.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a nice interplay here between the `end_at_i` subproblems and the `total`
    subproblems in that we use each to efficiently solve the other. This is the core
    reason why adding our new `total` subproblems helped us: they speed up the computation
    of the `end_at_i` subproblems and, having quickly solved the relevant `end_at_i`
    subproblem, we can repay the favor and quickly solve the `total` subproblem as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: The main Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: All we need now is our `main` function. See the code in [Listing 4-10](ch04.xhtml#ch04ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: If you submit this solution to the judge, you should be able to pass all test
    cases in time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned that dynamic-programming problems can be solved
    forward or backward, and that sometimes it matters a great deal which we choose.
    We’ve also learned that our initial solution approach may not be fast enough,
    at which point we need to reconsider our subproblems or add new subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: Can’t get enough of this? You may be happy to know that ideas related to dynamic
    programming often make cameos in other algorithms. In the next chapter, for example,
    you’ll see that we’ll once again store results for later lookup. And in [Chapter
    7](ch07.xhtml), you’ll see a problem in which dynamic programming plays a supporting
    role, speeding up computation required by the main algorithm of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Jumper is originally from the 2007 Croatian Regional Competition in Informatics.
    Ways to Build is originally from the 2015 National Olympiad in Informatics in
    Provinces.
  prefs: []
  type: TYPE_NORMAL
