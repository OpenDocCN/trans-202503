- en: '**20  MSP430 Paparazzi Attack**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Early MSP430 families, such as the MSP430F1xx, F2xx, and F4xx, are vulnerable
    to a semi-invasive attack, first publicly documented in Thomas (2014), in which
    a camera flash is used to fake out the fuse check while a JTAG debugger attempts
    to attach in a tight loop.
  prefs: []
  type: TYPE_NORMAL
- en: These chips have two access controls. JTAG is protected by a metal migration
    fuse; this is a thin trace of metal on the die that permanently breaks when too
    much current flows through it. Entirely unrelated to the fuse is a 32-byte password
    that is required to access the serial bootstrap loader (BSL). This password is
    the interrupt vector table (IVT) at the end of memory, and without it, the BSL
    allows little more than erasing all of memory. Because the BSL cannot read the
    protection fuse, you can exploit the chip by first dumping the last 32 bytes of
    flash memory and then presenting them to the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand is that all of the transistors within the chip
    are actually phototransistors. If a sufficiently bright light hits one of these
    transistors, it will conduct electricity even if electrically it should be in
    a non-conducting state. CMOS technology gains its power efficiency by balancing
    each conducting transistor against a non-conducting transistor, and a bright camera
    flash throws all of the design constraints out the window. The Raspberry Pi 2
    was famous for this, crashing violently when photographed because of an exposed
    die on the PCB.^([1](footnotes.xhtml#ch20fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0186-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: MSP430F449'
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to understand is that the MSP430’s JTAG port is locked by a
    hardware fuse, at least in devices prior to the MSP430F5xx family. When you connect
    a JTAG debugger, it tests the fuse by running a little current into it from the
    TDI pin. If the test is successful, JTAG unlocks and the chip may be read. If
    the test is not successful, a “no harm no foul” policy allows more fuse read attempts
    in all but the very earliest chips.
  prefs: []
  type: TYPE_NORMAL
- en: To unlock these chips, we’ll first remove the opaque packaging by performing
    a live decapsulation using the red fuming nitric acid (RFNA) drip method. After
    exposing the die, we’ll attach the chip to a GoodFET for JTAG debugging, modifying
    the GoodFET to repeatedly attempt JTAG fuse checks until success. By flashing
    a camera on the exposed die, we’ll then bypass the fuse check and enable debugging
    on a locked chip, allowing the firmware to be freely dumped.
  prefs: []
  type: TYPE_NORMAL
- en: '**Live Decapsulation with RFNA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The live decapsulation procedure presented here is conceptually similar to the
    full decapsulation that we covered in [Chapter 18](ch18.xhtml#ch18), but with
    some key differences to keep the bond wires and some of the packaging intact,
    so that the chip still functions despite the die being visible. If you do not
    have a chemistry lab available, and are not crazy enough to build your own, you
    can hire a failure analysis laboratory to perform the procedure for you.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the 65% nitric acid that sometimes dissolves bonding wires, we’ll
    be using red fuming nitric acid (RFNA), which is a minimum of 90% nitric acid
    and a maximum of 2% water. This is strong stuff that reacts violently with nitrile
    gloves and isopropyl alcohol, so be sure to work in a fume hood, with full safety
    gear.
  prefs: []
  type: TYPE_NORMAL
- en: Begin with your target chip soldered to a carrier PCB, with no other components.
    Heat it to about 100 °C, well beneath the melting point of the solder but hot
    enough for the acid to attack the packaging.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0188-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Live Decapsulated MSP430F2418'
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to expose the die in the center without spilling acid onto the
    pins or the PCB. At the beginning, the chip’s packaging has a flat surface, so
    any significant amount of acid will spill off. Begin with a little RFNA in a cold
    beaker and use a pipette with a very narrow tip to drip just the smallest possible
    amount of acid onto the dead center of the chip package.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick but important note on acid volume: if a droplet forms at the tip of
    the pipette, you’re about to use too much acid. You really want as little acid
    for your first drop as possible. Imagine that you are using the pipette as a fountain
    pen to write on paper.'
  prefs: []
  type: TYPE_NORMAL
- en: The acid will first appear to soak into the surface of the chip, and then it
    will begin to bubble a little bit. After allowing for a little bubbling to break
    apart packaging material, use a squirt of acetone to clean off the acid and leave
    the remainder of the packaging. Repeating this a few times will give you a sort
    of bowl-shaped cavity within the package, and you can begin to use a little more
    acid to speed up the etching.
  prefs: []
  type: TYPE_NORMAL
- en: After each acetone rinse, carefully inspect the package under bright light.
    When you begin to see the bonding wires glinting in the otherwise black packaging,
    you are getting close to the bare die. At this stage you should rinse a little
    sooner, to ensure that the acid doesn’t boil away and leave ugly plastic markings
    that obscure the die.
  prefs: []
  type: TYPE_NORMAL
- en: If this procedure is successful, you should have a package whose pins and their
    surrounding packaging are intact, while the die and its bonding wires are exposed.
    The die will not be quite so clean as one prepared by the bath methods, but the
    little bit of dirt that remains on the surface won’t interfere with this attack.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to carefully rinse the chip and board with first acetone and then isopropyl
    alcohol and deionized water to prevent any leftover acid from dissolving traces
    on the board or oxidizing the pins. This final cleaning should be the only use
    of isopropyl alcohol in your experiment, because the alcohol violently reacts
    with RFNA, and unintentional lab explosions are generally frowned upon. Similarly,
    water will remove the metal salts that protect bond wires and the frame from HNO[3],
    so you should avoid it until the very last cleaning.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fuse Check Sequence**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve opened the packaging on our target chip, the next step is to
    trigger the fault. To do this yourself, you will need a JTAG programmer with source
    code available, such as Good-speed (2009), and also the JTAG specification of
    the MSP430 chips, Texas Instruments (2010).
  prefs: []
  type: TYPE_NORMAL
- en: I suppose we might use a laser with fine pulse control to fire at exactly the
    right spot and exactly the right time.^([2](footnotes.xhtml#ch20fn2)) Thankfully,
    this is unnecessary if we modify our JTAG programmer a little. For this example,
    we’ll be using my open source GoodFET programmer, even though it’s a little out
    of date.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20.3](ch20.xhtml#ch20fig3) shows the hardware fuse check sequence for
    the MSP430F1xx, F2xx, and F4xx devices. The check is performed by toggling the
    TMS pin at least twice; if the fuse is not blown, two milliamps of current will
    flow into the TDI pin. [Figure 20.4](ch20.xhtml#ch20fig4) is an example implementation
    of the JTAG fuse check sequence in C from my GoodFET project.'
  prefs: []
  type: TYPE_NORMAL
- en: Devices with the original MSP430 CPU and the CPUX extension have an erratum
    in which they might fail the fuse test when powering up, requiring another power
    cycle before the fuse may be tested again. CPUXv2 devices clear the fuse check
    result as the JTAG TAP is reset, and this might complicate exploitation when you
    are faking the fuse check with a camera flash.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0191-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: MSP430 JTAG Fuse Check Sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0191-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: MSP430 Fuse Check in Goodspeed (2009)'
  prefs: []
  type: TYPE_NORMAL
- en: MSP430F5xx and F6xx devices have done away with the hardware fuse check, instead
    implementing their readout protection with a software mechanism. This chapter’s
    attack is not expected to apply to those devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a functioning target chip with an exposed die, exploitation consists
    of repeatedly attempting a fuse check, then looking to see whether it has been
    accepted, at the same time that camera flashes are applied to the die. The sequence
    from [Figure 20.3](ch20.xhtml#ch20fig3) can be modified in two ways: either the
    sequence can be repeated until the check is successful or the number of cycles
    on the TMS pin can be extended to make more attempts at passing the test.'
  prefs: []
  type: TYPE_NORMAL
- en: On the hardware end, the target chip consumes quite a bit of power when a camera
    flash appears over the die. We are not attempting voltage glitching, so the transient
    power consumption should be handled by decoupling capacitors and perhaps also
    a bench power supply.
  prefs: []
  type: TYPE_NORMAL
- en: When the entire arrangement is in place, roughly one camera flash in four should
    unlock the target and allow a JTAG connection to be established. Be very careful
    in your setup to hold this connection open, never resetting the chip in a way
    that would require a fresh fuse check.
  prefs: []
  type: TYPE_NORMAL
- en: You should also expect that after a connection is established, the flash memory
    might have read errors from the camera flash for a little while until it settles
    down to the permanently stored values. I resolve this by repeatedly reading all
    flash memory a few times, saving the early reads in case I need them but relying
    on the latter reads for the real program contents. This effect of the memory being
    stunned might also be used to temporarily corrupt the password of the resident
    serial bootstrap loader (BSL) that resides in ROM and ignores the JTAG protection
    fuse.
  prefs: []
  type: TYPE_NORMAL
