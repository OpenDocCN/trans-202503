- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: DESCRIBING MOTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 描述运动
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: The description of the motion of an object in terms of its position, velocity,
    and acceleration is called *kinematics*. In this chapter, we’ll give a succinct
    review of one-dimensional kinematics while showing how the Haskell language naturally
    encodes its ideas and equations. We’ll use the Haskell functions introduced in
    [Chapter 2](ch02.xhtml) and the types we introduced in [Chapter 3](ch03.xhtml).
    The equations of kinematics, being largely definitional, have an almost one-to-one
    correspondence with Haskell functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过位置、速度和加速度来描述物体的运动被称为*运动学*。在本章中，我们将简要回顾一维运动学，并展示Haskell语言如何自然地编码其思想和方程。我们将使用在[第2章](ch02.xhtml)中介绍的Haskell函数，以及在[第3章](ch03.xhtml)中介绍的类型。由于运动学方程大多是定义性的，它们几乎与Haskell函数一一对应。
- en: Position and Velocity on an Air Track
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空气轨道上的位置和速度
- en: Have you ever seen an air track? An air track is a fun toy, or, if you’re feeling
    more serious, a piece of experimental equipment. It consists of a long horizontal
    rail (maybe 2 or 3 meters long) with little holes that allow air to shoot upward
    out of the rail. A small car (maybe 5 cm wide and 10 cm long) with no wheels rides
    atop this air track. The air eliminates most of the friction that would exist
    between the car and the rail as the car slides along the rail, so the car can
    slide freely along the air track. The cross section of the rail is shaped so that
    the car can only slide back and forth along the length of the rail; the car cannot
    slide sideways or move up or down.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你见过空气轨道吗？空气轨道是一个有趣的玩具，或者，如果你更严肃一些，它也是一件实验设备。它由一条长水平轨道（大约2或3米长）组成，轨道上有小孔，可以让空气从轨道中喷出。一个没有轮子的小车（大约5厘米宽、10厘米长）沿着这条空气轨道滑行。空气减少了小车与轨道之间的摩擦，使得小车可以在空气轨道上自由滑动。轨道的横截面设计使得小车只能沿轨道的长度来回滑动；小车不能横向滑动或上下移动。
- en: We can make marks on the air track to allow us to talk about the *position*
    of the car. Let’s imagine that we have an air track that has already been carefully
    marked in meters. For a particular motion of the car on the air track, we define
    *x* to be the function that associates each time *t* with the position of the
    car at that time. We say that *x*(*t*) is the position of the car at time *t*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在空气轨道上做标记，以便讨论小车的*位置*。假设我们有一条已经用米标记过的空气轨道。对于小车在空气轨道上的特定运动，我们定义*x*为一个函数，将每个时间*t*与该时刻小车的位置关联起来。我们说*x*(*t*)是小车在时刻*t*的位置。
- en: '*Velocity* is defined to be the rate at which position changes. The *average
    velocity* over the time interval that starts at time *t*[0] and ends at time *t*[1]
    is'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度*被定义为位置变化的速率。某个时间区间内的*平均速度*，该时间区间从时间*t*[0]开始，到时间*t*[1]结束，为：'
- en: '![Image](Images/036equ01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/036equ01.jpg)'
- en: Average velocity is change in position divided by change in time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 平均速度是位置变化除以时间变化。
- en: 'One of the advantages of using the Haskell programming language is that there
    is almost a one-to-one correspondence between the equations of physics and the
    code we write to describe them. In Haskell, the following lines, which could appear
    in a source code file, have the same meaning as Equation 4.1:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Haskell编程语言的一个优点是，物理方程与我们用来描述它们的代码几乎可以一一对应。在Haskell中，以下几行代码出现在源文件中，它们的意义与方程4.1相同：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line of Haskell code is a type signature saying that `averageVelocity`
    is a function that takes a time, a second time, and a position function as input
    and gives a velocity as output. We can use the arrow (`->`) to chain together
    inputs. The last term is the output type, and all of the other terms are input
    types. There is a deeper reason for this notation that we will explore in [Chapters
    6](ch06.xhtml) and [9](ch09.xhtml).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行Haskell代码是一个类型签名，表示`averageVelocity`是一个函数，它接受两个时间和一个位置函数作为输入，并输出一个速度。我们可以使用箭头（`->`）将输入连接起来。最后一个术语是输出类型，其他所有术语都是输入类型。这个符号表示法有一个更深层的原因，我们将在[第6章](ch06.xhtml)和[第9章](ch09.xhtml)中进行探讨。
- en: The second line of Haskell code above is the definition for the function `averageVelocity`.
    The definition says that if we call `t0` the first time, `t1` the second time,
    and `x` the position function, the velocity will be given by the expression on
    the right of the equal sign. The inputs `t0` and `t1` are numbers, but the input
    `x` is a function. The practice of using functions as inputs to other functions
    is common in Haskell; we will discuss this in much more detail in [Chapter 6](ch06.xhtml).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 Haskell 代码的第二行是函数 `averageVelocity` 的定义。该定义表明，如果我们将 `t0` 作为第一个时间，`t1` 作为第二个时间，`x`
    作为位置函数，则速度由等号右边的表达式给出。输入 `t0` 和 `t1` 是数字，而输入 `x` 是一个函数。在 Haskell 中，将函数作为输入传递给其他函数是一种常见做法；我们将在
    [第六章](ch06.xhtml) 中详细讨论这一点。
- en: '[Table 4-1](ch04.xhtml#ch4tab1) shows a comparison of mathematical notation
    and Haskell notation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](ch04.xhtml#ch4tab1) 显示了数学符号和 Haskell 符号的对比。'
- en: '**Table 4-1:** Comparison of Mathematical Notation and Haskell Notation'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 数学符号与 Haskell 符号的对比'
- en: '| **Mathematical notation** | **Haskell notation** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **数学符号** | **Haskell 符号** |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *t*[0] | `t0` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| *t*[0] | `t0` |'
- en: '| *t*[1] | `t1` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| *t*[1] | `t1` |'
- en: '| *x* | `x` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| *x* | `x` |'
- en: '| *x*(*t*[0]) | `x t0` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *x*(*t*[0]) | `x t0` |'
- en: '| *x*(*t*[1]) | `x t1` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *x*(*t*[1]) | `x t1` |'
- en: '| ![Image](Images/036equ02.jpg) | `averageVelocity` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](Images/036equ02.jpg) | `averageVelocity` |'
- en: As we saw in [Chapter 1](ch01.xhtml), parentheses are not required to apply
    a function to an argument. The `x` in the code is a function, just like the *x*
    in Equation 4.1\. When we write *x*(*t*[0]), we mean the function *x* applied
    to (or evaluated at) the time *t*[0]. Similarly, when we write `x t0`, we mean
    the function `x` applied to (or evaluated at) the time `t0`. Functions play such
    a central role in Haskell that juxtaposition of names implies that the first is
    a function and the second is an argument, and that the function is to be applied
    to the argument.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第一章](ch01.xhtml) 中看到的，应用函数到参数时不需要括号。代码中的 `x` 是一个函数，就像方程 4.1 中的 *x* 一样。当我们写
    *x*(*t*[0]) 时，我们的意思是将函数 *x* 应用到时间 *t*[0]（或在 *t*[0] 处求值）。类似地，当我们写 `x t0` 时，我们的意思是将函数
    `x` 应用到时间 `t0`（或在 `t0` 处求值）。函数在 Haskell 中扮演着如此核心的角色，以至于名称的并列意味着第一个是函数，第二个是参数，而该函数将应用于这个参数。
- en: The notation ![Image](Images/037equ01.jpg) explicitly shows that average velocity
    depends on the initial time *t*[0] and the final time *t*[1] of the time interval,
    but the dependence on the position function is implicit and not shown in Equation
    4.1\. Haskell code shows all dependencies explicitly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该符号 ![Image](Images/037equ01.jpg) 明确表示平均速度依赖于时间间隔的初始时间 *t*[0] 和最终时间 *t*[1]，但对位置函数的依赖是隐含的，并未在方程
    4.1 中显示。Haskell 代码显式地展示了所有依赖关系。
- en: Types for Physical Quantities
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理量的类型
- en: It makes our thinking simpler if we can talk about velocity at a single time
    rather than over a time interval. We can take a step in this direction by labeling
    the average velocity with the time at the center of the interval and the length
    of the interval, rather than with the beginning and ending times.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以在某一时刻讨论速度，而不是在时间间隔内讨论速度，这将使我们的思维更简洁。我们可以通过使用时间间隔中心的时间和间隔长度来标记平均速度，而不是使用开始和结束时间，从而朝着这个方向迈出一步。
- en: '![Image](Images/037equ02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/037equ02.jpg)'
- en: 'In Haskell, Equation 4.2 looks like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，方程 4.2 看起来如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we do need to enclose `t + dt/2` in parentheses so that adding `t` to
    `dt/2` takes place before the function `x` is applied.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确实需要将 `t + dt/2` 括起来，以便在应用函数 `x` 之前先进行 `t` 和 `dt/2` 的加法运算。
- en: Notice that in the code above, the types from the type signature match up with
    the arguments in the definition in the same order, as emphasized in [Table 4-2](ch04.xhtml#ch4tab2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的代码中，类型签名中的类型与定义中的参数按相同顺序匹配，如 [表 4-2](ch04.xhtml#ch4tab2) 中所强调。
- en: '**Table 4-2:** Matching of Arguments and Types for the Function `average Velocity2`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 函数 `average Velocity2` 的参数与类型匹配'
- en: '| **Argument** | **Type** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **类型** |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t` | `Time` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `t` | `时间` |'
- en: '| `dt` | `TimeInterval` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `dt` | `时间间隔` |'
- en: '| `x` | `PositionFunction` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `x` | `位置函数` |'
- en: At this point, we’re only dealing with motion in one dimension, so time, position,
    and velocity are all represented by numbers. We tell the Haskell compiler this
    with the following lines, which are called *type synonyms*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们只处理一维运动，因此时间、位置和速度都由数字表示。我们通过以下几行告诉 Haskell 编译器这一点，这些行被称为 *类型同义词*。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only type in the lines above that Haskell understands by default is `Double`.
    I prefer to think of this as the type of real numbers (not every real number can
    be represented by a `Double`, but we are willing to do approximate calculation),
    so I like the name `R` better than `Double`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上面几行中Haskell默认能理解的唯一类型是`Double`。我更倾向于把它看作实数类型（并非每个实数都能用`Double`表示，但我们愿意进行近似计算），因此我更喜欢使用`R`而不是`Double`这个名称。
- en: The first line says that whenever I use the type `R`, it means the same thing
    as `Double`. The next four lines say that time, time interval, position, and velocity
    are all just real numbers at this point. Finally, the last two lines define function
    types. The type `PositionFunction` is the type of a function that takes time as
    input and gives position as output. Recall that the argument `x` above was a function
    with this type. Since `Time` is the same as `R` and `Position` is the same as
    `R`, the type `PositionFunction` is the same as `R -> R`, which takes a real number
    as input and produces a real number as output. For a similar reason, the type
    `VelocityFunction` is also the same as the function type `R -> R`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示，每当我使用类型`R`时，它和`Double`的含义是相同的。接下来的四行表示时间、时间间隔、位置和速度在这一点上都只是实数。最后的两行定义了函数类型。类型`PositionFunction`是一个函数类型，它接受时间作为输入并返回位置作为输出。回忆一下，上面的参数`x`是一个具有此类型的函数。由于`Time`和`R`是相同的，`Position`和`R`也是相同的，因此`PositionFunction`类型等同于`R
    -> R`，它接受一个实数作为输入并输出一个实数。出于类似的原因，`VelocityFunction`类型也与函数类型`R -> R`相同。
- en: A type synonym merely gives an additional name to an existing type. The compiler
    sees `Double`, `R`, `Position`, and `Velocity` as identical and is unable to warn
    us if we attempt to use a `Velocity` where a `Position` is called for. In [Chapter
    10](ch10.xhtml), we will introduce a way to define a new type that is distinct
    from all existing types and allows the compiler to check that we haven’t confused
    one type with another. There is also a Haskell package called `units` ([*https://hackage.haskell.org/package/units*](https://hackage.haskell.org/package/units))
    specifically designed to allow physical units such as meters per second to be
    attached to numerical quantities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类型同义词只是为现有类型提供了一个额外的名称。编译器会把`Double`、`R`、`Position`和`Velocity`视为相同，并且在我们尝试在需要`Position`的地方使用`Velocity`时，不会发出警告。在[第10章](ch10.xhtml)中，我们将介绍一种定义新类型的方法，这种新类型与所有现有类型不同，并允许编译器检查我们是否混淆了不同的类型。此外，还有一个Haskell包叫做`units`（[*https://hackage.haskell.org/package/units*](https://hackage.haskell.org/package/units)），专门用于将物理单位（如米每秒）附加到数值量上。
- en: Introducing Derivatives
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入导数
- en: If in making the time interval Δ*t* shorter and shorter we find that the average
    velocity converges to a particular value, we call this value the *instantaneous
    velocity*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使时间间隔Δ*t*变得越来越短时，我们发现平均速度趋向于某个特定值，那么我们就称这个值为*瞬时速度*。
- en: '![Image](Images/038equ01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/038equ01.jpg)'
- en: 'A limit of a ratio of differences occurs often enough that it gets awarded
    the name *derivative*. Given a function *x* of one variable, the derivative of
    *x*, denoted *Dx*, *x*’, or ![Image](Images/xdot.jpg), is the function of one
    variable defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 差商的极限出现得很频繁，以至于它被赋予了*导数*这个名称。给定一个一元函数*x*，它的导数，记作*Dx*、*x*'或 ![图片](Images/xdot.jpg)，是一个一元函数，定义如下：
- en: '![Image](Images/038equ02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/038equ02.jpg)'
- en: '**HANDLING CONTINUOUS TIME**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理连续时间**'
- en: The mathematical definitions of limit and derivative require a continuity of
    real numbers that may not be present in the physical world. There’s a bit of idealization
    when we imagine time to be continuous. Time certainly seems to be continuous,
    and no one has made any direct measurements that suggest a discreteness to time,
    but there are quantum theoretical reasons to believe that at some very short scale,
    time may not behave as a perfect continuum.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 极限和导数的数学定义要求实数的连续性，而这种连续性在物理世界中可能并不存在。当我们假设时间是连续的时候，实际上有些理想化的成分。时间确实看起来是连续的，没有任何直接的测量结果表明时间是离散的，但基于量子理论，有理由相信在某些极短的尺度上，时间可能并不像完美的连续体那样表现。
- en: 'To make a guess at a time scale when quantum effects are likely to disturb
    the continuity of time, we can use *dimensional analysis*, which means combining
    parameters that are relevant to the situation to construct a quantity with dimensions
    of time. We haven’t said anything at all about the situation, so all we have to
    work with are fundamental constants of physics, namely the Newtonian constant
    of gravitation *G*, Planck’s constant ![Image](Images/hbar.jpg), and the speed
    of light in a vacuum *c*. There is only one way to multiply powers of these fundamental
    constants to produce a result with dimensions of time. The resulting time is called
    the *Planck time*, and it looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推测量子效应可能干扰时间连续性的时间尺度，我们可以使用*维度分析*，即将与情况相关的参数结合，构造出具有时间维度的量。我们还没有提到任何关于情况的内容，因此我们唯一能用的就是物理学中的基本常数，即牛顿引力常数*G*，普朗克常数![Image](Images/hbar.jpg)，以及真空中的光速*c*。只有一种方法可以将这些基本常数的幂相乘，得出一个具有时间维度的结果。得到的时间被称为*普朗克时间*，其表达式如下：
- en: '![Image](Images/039equ01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/039equ01.jpg)'
- en: The Planck time is many, many orders of magnitude smaller than the smallest
    time scales that can currently be probed. For the physics that is experimentally
    accessible today, time appears continuous, and the derivative is in no danger
    of becoming obsolete.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 普朗克时间比目前可以探测到的最小时间尺度小得多，数量级上相差很多。对于今天实验上可探测的物理，时间表现为连续的，导数也没有过时的危险。
- en: We can say that instantaneous velocity is the derivative of position.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，瞬时速度是位置的导数。
- en: '![Image](Images/039equ02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/039equ02.jpg)'
- en: 'Note that Equation 4.5 is an equality of functions: the instantaneous velocity
    function is on the left of the equality and the derivative of the position function
    is on the right. When two functions are equal, they give equal results for equal
    inputs, so we can also write'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方程式4.5是一个函数的等式：瞬时速度函数位于等式左边，位置函数的导数位于右边。当两个函数相等时，对于相等的输入，它们会给出相等的结果，因此我们也可以写成
- en: '![Image](Images/039equ03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/039equ03.jpg)'
- en: for any time *t*. The right-hand side is the function *Dx* evaluated at the
    time *t*. We can think of the derivative operator as taking the entire position
    function as input and returning the velocity function as output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意时刻*t*，右侧是函数*Dx*在时刻*t*的值。我们可以将导数算子视为接受整个位置函数作为输入并返回速度函数作为输出。
- en: It’s more common to see the notation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的表示法是
- en: '![Image](Images/039equ04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/039equ04.jpg)'
- en: to define velocity. Equation 4.5 is more succinct, but Equations 4.5, 4.6, and
    4.7 all mean the same thing. We say that *v*(*t*) is the velocity of the car at
    time *t*. Note that the velocity of the car on the air track can be negative (meaning
    the position is decreasing) or positive (meaning the position is increasing).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用以定义速度。方程式4.5更加简洁，但方程式4.5、4.6和4.7的含义是相同的。我们说*v*(*t*)是时刻*t*的车速。请注意，空气轨道上车速可以是负的（意味着位置在减少）或正的（意味着位置在增加）。
- en: Derivatives in Haskell
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haskell中的导数
- en: A derivative takes a function as input and gives a function as output. In other
    words, a derivative is a function from functions to functions. A function that
    takes another function as input or returns a function as output is called a *higher-order
    function*. If the idea of functions as inputs and outputs of other functions is
    new to you, it will take some practice and examples to get used to, but I assure
    you that it is worth the effort. There are many ideas in physics, the derivative
    being just one, that are naturally expressed as higher-order functions. [Chapter
    6](ch06.xhtml) is entirely devoted to such higher-order functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导数将一个函数作为输入，并返回一个函数作为输出。换句话说，导数是从函数到函数的映射。一个接受另一个函数作为输入或返回一个函数作为输出的函数被称为*高阶函数*。如果函数作为其他函数的输入和输出这一概念对你来说是新的，需要通过一些练习和示例来适应，但我向你保证，这是值得的。在物理学中，有许多概念，导数只是其中之一，它们自然地表现为高阶函数。[第六章](ch06.xhtml)完全讲解了这种高阶函数。
- en: 'One possible type synonym for a derivative looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 导数的一种可能的类型同义词如下所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since arrows are right associative, with the rightmost arrow having highest
    precedence, the type `(R -> R) -> R -> R` is the same as `(R -> R) -> (R -> R)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于箭头是右结合的，最右边的箭头具有最高优先级，类型`(R -> R) -> R -> R`与`(R -> R) -> (R -> R)`是等价的。
- en: 'We can write a numerical derivative in Haskell like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样在Haskell中编写数值导数：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This numerical derivative does not take a limit but instead uses a small interval,
    `dt`, supplied by the user. If the interval is small enough, the result should
    be a good approximation to the derivative.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数值导数并不采用极限，而是使用由用户提供的小间隔`dt`。如果间隔足够小，结果应该是导数的良好近似值。
- en: 'Let’s play the matching game with arguments and types for the function `derivative`
    like we did for the function `averageVelocity2`. At first glance, it seems that
    `dt` has type `R`, `x` has type `Derivative`, and `t` is left with no type at
    all. This does not make any sense; the trouble is that we need to expand the `Derivative`
    type. When fully expanded, `derivative` has the following type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像处理函数`averageVelocity2`一样，通过参数和类型来玩匹配游戏，看看`derivative`函数。乍一看，似乎`dt`的类型是`R`，`x`的类型是`Derivative`，而`t`则没有类型。这是没有意义的；问题在于我们需要展开`Derivative`类型。展开后，`derivative`具有以下类型：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, `dt` has type `R`, `x` has type `R -> R`, `t` has type `R`, and the final
    `R` is the return type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`dt`的类型是`R`，`x`的类型是`R -> R`，`t`的类型是`R`，最终的`R`是返回类型。
- en: In playing the matching game, we are thinking of `derivative` as a function
    with three inputs and one output. The arrow notation may seem a strange way to
    specify a function with three inputs. There is a deeper meaning to the notation
    that we will discuss briefly now and treat more fully in [Chapter 6](ch06.xhtml).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行匹配游戏时，我们认为`derivative`是一个具有三个输入和一个输出的函数。箭头符号可能看起来是指定一个具有三个输入的函数的一种奇怪方式。这个符号有更深的含义，我们将在这里简要讨论，并在[第6章](ch06.xhtml)中进行更详细的阐述。
- en: 'Since arrows associate to the right, the following three types are the same
    to the compiler:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于箭头右结合，编译器认为以下三种类型是相同的：
- en: '`R -> (R -> R) -> R -> R`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R -> (R -> R) -> R -> R`'
- en: '`R -> (R -> R) -> (R -> R)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R -> (R -> R) -> (R -> R)`'
- en: '`R -> ((R -> R) -> (R -> R))`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R -> ((R -> R) -> (R -> R))`'
- en: Using the thinking from the matching game, it appears that the first type takes
    three inputs, the second type takes two inputs, and the third type takes one input.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匹配游戏中的思维方式，似乎第一个类型需要三个输入，第二个类型需要两个输入，第三个类型需要一个输入。
- en: 'There are three ways to think about the function `derivative`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式来思考`derivative`函数：
- en: '`derivative` takes three inputs, with types `R`, `R -> R`, and `R`, and produces
    one output with type `R`. In this way of thinking, `derivative` takes a time interval,
    a position function, and a time and returns the numeric velocity at that time.
    This was our thinking in the matching game.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derivative`接受三个输入，类型分别为`R`、`R -> R`和`R`，并产生一个类型为`R`的输出。通过这种思维方式，`derivative`接受一个时间间隔、一个位置函数和一个时间，然后返回该时刻的数值速度。这是我们在匹配游戏中的思维方式。'
- en: '`derivative` takes two inputs, with types `R` and `R -> R`, and produces one
    output with type `R -> R`. In this way of thinking, `derivative` takes a time
    interval and a position function and returns a velocity function.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derivative`接受两个输入，类型分别为`R`和`R -> R`，并产生一个类型为`R -> R`的输出。通过这种思维方式，`derivative`接受一个时间间隔和一个位置函数，并返回一个速度函数。'
- en: '`derivative` takes one input with type `R` (namely `dt`) and produces one output
    with type `(R -> R) -> R -> R` (or type `Derivative`). This is the way the compiler
    thinks of it.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derivative`接受一个类型为`R`的输入（即`dt`），并生成一个类型为`(R -> R) -> R -> R`（或者类型为`Derivative`）的输出。这是编译器的理解方式。'
- en: These three ways of thinking are mathematically equivalent, but they seem to
    sit differently with the brain. The second way of thinking is my favorite because
    I like to think of a derivative as something that takes a function as input and
    gives a function as output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种思维方式在数学上是等价的，但它们在大脑中的感觉方式不同。第二种思维方式是我最喜欢的，因为我喜欢将导数看作是一个接受函数作为输入并返回函数作为输出的过程。
- en: Transforming a function with two inputs into a function with one input whose
    output is a function is called *currying*, named after the logician Haskell Curry
    (who donates his first name to the programming language we are using). Currying
    is discussed more fully in [Chapters 6](ch06.xhtml) and [9](ch09.xhtml). Currying
    allows the compiler to treat all functions as having a single input and a single
    output, with the understanding that the input and/or the output might be a function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个具有两个输入的函数转换为一个具有一个输入的函数，并且其输出为另一个函数，这种方式被称为*柯里化*，以逻辑学家哈斯凯尔·柯里（他将自己的名字赠予了我们所使用的编程语言）命名。柯里化在[第6章](ch06.xhtml)和[第9章](ch09.xhtml)中有更详细的讨论。柯里化允许编译器将所有函数视为只有一个输入和一个输出，前提是输入和/或输出可能是一个函数。
- en: Modeling the Car’s Position and Velocity
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟汽车的位置和速度
- en: Suppose we have a car position function
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个汽车位置函数
- en: '![Image](Images/041equ01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/041equ01.jpg)'
- en: 'in which *t* is in seconds and *x[C]* is in meters. The corresponding Haskell
    code is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t* 以秒为单位，*x[C]* 以米为单位。相应的 Haskell 代码如下：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using Equation 4.5, we can find the velocity function for the car.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程 4.5，我们可以找到汽车的速度函数。
- en: '![Image](Images/041equ02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/041equ02.jpg)'
- en: 'The corresponding Haskell code could be something like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 Haskell 代码可能如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the Haskell code, `derivative 0.01` is playing the role of the derivative
    operator *D* in the mathematical expression. These are not exactly the same thing
    because *D* is a true mathematical derivative and `derivative 0.01` is only a
    numerical derivative, but we can get decent approximate results by using it, and
    we can improve our results to the degree that we like by using a number smaller
    than `0.01`. Moreover, `derivative 0.01 sin` is a perfectly valid function with
    type `R -> R` in the Haskell language and is every bit as legitimate as the function
    `cos` (also type `R -> R`) that it approximates. It can be evaluated, graphed,
    differentiated, integrated, or used anywhere that a function with type `R -> R`
    can be used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 代码中，`derivative 0.01`扮演着数学表达式中导数算符*D*的角色。这两者不完全相同，因为*D*是真正的数学导数，而`derivative
    0.01`只是一个数值导数，但通过使用它，我们可以得到不错的近似结果，而且我们可以通过使用小于`0.01`的数字来提高结果的精度。此外，`derivative
    0.01 sin`是一个完全有效的函数，其类型为`R -> R`，在 Haskell 语言中与函数`cos`（同样类型为`R -> R`）一样合法。它可以被求值、绘制图形、求导、积分，或者在任何需要类型为`R
    -> R`的函数的地方使用。
- en: Equation 4.9 is an equality of functions, and the corresponding Haskell code
    defines the function `carVelocity` without using any function arguments. This
    is the point-free style introduced in [Chapter 2](ch02.xhtml).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 4.9 是函数的等式，相应的 Haskell 代码定义了函数`carVelocity`，且不使用任何函数参数。这就是在[第 2 章](ch02.xhtml)中介绍的点自由风格。
- en: 'It’s just as valid to write Haskell code based on Equation 4.6\. The mathematical
    equation would then look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基于方程 4.6 编写 Haskell 代码也是有效的。此时，数学方程看起来会像下面这样：
- en: '![Image](Images/042equ01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/042equ01.jpg)'
- en: 'And the Haskell code would look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 Haskell 代码如下所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use a prime to denote an alternate way of writing the function. As far as
    the computer is concerned, `carVelocity` and `carVelocity'` mean the same thing.
    The difference is one of notational preference. We’ll often use primes in code
    to indicate an alternate way of writing something. This prime has nothing to do
    with the derivative.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用撇号来表示写函数的另一种方式。对计算机而言，`carVelocity`和`carVelocity'`表示相同的含义。区别只在于符号的偏好。在代码中，我们经常使用撇号来表示另一种写法。这个撇号与导数无关。
- en: The position function for the car is given analytically, so we can take the
    derivative analytically and write an explicit equation for the velocity of the
    car.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车的位置函数是通过解析给出的，因此我们可以通过解析求导，并写出汽车速度的显式方程。
- en: '![Image](Images/042equ02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/042equ02.jpg)'
- en: We can also write this in Haskell as
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用 Haskell 编写如下代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: but in this book we’re not asking the computer to do symbolic algebra or to
    take derivatives analytically. The function `carVelocityAnalytic` is *not* the
    same function as `carVelocity` or `carVelocity'`. The numeric value of `carVelocity
    2` is close to, but not exactly the same as, the numeric value of `carVelocityAnalytic`
    `2`. In this book, we’ll only ask the computer to do things that a scientific
    calculator can do. Nevertheless, we’ll find that Haskell’s notation will aid our
    thinking through attention to the types of expressions, through the concision
    allowed by higher-order functions and through the simplicity of writing language
    that avoids mutable state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但在本书中，我们并不要求计算机做符号代数运算或解析求导。函数`carVelocityAnalytic`*并不是*与`carVelocity`或`carVelocity'`相同的函数。`carVelocity
    2`的数值接近但不完全等于`carVelocityAnalytic` `2`的数值。在本书中，我们仅要求计算机完成科学计算器能做的任务。然而，我们会发现，Haskell
    的符号会通过关注表达式的类型、高阶函数带来的简洁性以及避免可变状态的简洁语言帮助我们进行思考。
- en: There is an even better way to express Equation 4.5 in Haskell. The function
    `velFromPos` accepts any position function as input and supplies the corresponding
    velocity function as output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更好的方式来用 Haskell 表达方程 4.5。函数`velFromPos`接受任何位置函数作为输入，并提供相应的速度函数作为输出。
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see that the function to find velocity from position is none other than the
    derivative function we defined earlier. Note also that we can split a type signature
    across multiple lines. This is often good practice, and it gives the code writer
    the opportunity to give a short comment about the meaning of each type in the
    signature.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，求取速度从位置的函数实际上就是我们之前定义的导数函数。还需要注意的是，我们可以将类型签名分布在多行上。这通常是一个好习惯，它给了代码编写者一个机会，在签名的每个类型旁边添加简短的注释，以解释其含义。
- en: If the velocity happens to be constant, say *v*[0], we can integrate both sides
    of Equation 4.5 or 4.7 to obtain
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度恰好是恒定的，比如*v*[0]，我们可以对方程4.5或4.7的两边进行积分，得到：
- en: '*v*[0]*t* = *x*(*t*) – *x*(0)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*v*[0]*t* = *x*(*t*) – *x*(0)'
- en: If velocity is constant, position is a linear function of time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度恒定，则位置是时间的线性函数。
- en: '*x*(*t*) = *v*[0]*t* + *x*(0)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*(*t*) = *v*[0]*t* + *x*(0)'
- en: 'Here is the corresponding Haskell code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应的 Haskell 代码：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `CV` at the end of the name is an abbreviation for constant velocity. Notice
    again the different ways to read the type: we can think of `positionCV` as a function
    that takes three arguments and returns a `Position`, as a function that takes
    two arguments and returns a function `Time -> Position`, or as a function that
    takes one argument and returns a function `Velocity -> Time ->` `Position`. The
    expression `positionCV 5 10 2` is the `Position` of an object at time 2 s, if
    it moves with a constant velocity of 10 m/s and started at a position of 5 m when
    time was 0\. The expression `positionCV 5 10` is the `PositionFunction` that describes
    an object moving with a constant velocity of 10 m/s that started at a position
    of 5 m when time was 0.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 名字末尾的`CV`是“恒定速度”（constant velocity）的缩写。再次注意，我们可以有不同的方式来理解类型：我们可以将`positionCV`看作一个接受三个参数并返回`Position`的函数，也可以看作一个接受两个参数并返回一个函数`Time
    -> Position`，或者看作一个接受一个参数并返回一个函数`Velocity -> Time -> Position`。表达式`positionCV
    5 10 2`表示一个物体在时间2秒时的位置，如果它以10米/秒的恒定速度移动，且在时间为0时的位置为5米。表达式`positionCV 5 10`表示描述一个物体以10米/秒的恒定速度移动、且在时间为0时位置为5米的`PositionFunction`。
- en: In everyday speech we often use the terms *velocity* and *speed* interchangeably.
    The language of physics makes a technical distinction between these two terms.
    *Speed* is the magnitude (absolute value) of velocity. Speed is never negative.
    Although speed (that is, how fast something is going) is the simpler idea to understand,
    velocity is much more important to the theory of motion. Velocity contains more
    information than speed because it tells the direction of travel as well as the
    speed. The velocity of a rock thrown straight upward makes a continuous regular
    change, both while the rock travels upward and while it travels downward. Speed,
    on the other hand, decreases on the way up and increases on the way down, unnecessarily
    making it seem like the situation needs to be thought of as two processes. There
    will be times when it is convenient to speak about speed, and it is certainly
    worth having a concept and a word for it. When we discuss motion in more than
    one dimension, velocity will require a vector for its description, while speed
    will remain a number.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常语言中，我们经常将*速度*和*速率*这两个术语互换使用。物理学语言对这两个术语做了技术性的区分。*速率*是速度的大小（绝对值）。速率永远不会是负数。虽然速率（即物体的移动速度）是一个更容易理解的概念，但速度在运动理论中要重要得多。速度包含了比速率更多的信息，因为它不仅告诉我们物体的移动速度，还能提供物体的运动方向。一个被垂直向上抛的石头，其速度会在向上运动和向下运动时都发生规律性的变化。而速率则在向上运动时减小，在向下运动时增大，这使得我们不必要地将其看作两个独立的过程。有时候，讨论速率是方便的，并且为其定义一个概念和一个术语是非常值得的。当我们讨论多维运动时，速度需要用一个向量来描述，而速率则依然只是一个数值。
- en: Modeling Acceleration
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建模加速度
- en: '*Acceleration* is defined to be the rate at which velocity changes. We define
    *a* to be the function that associates with each time *t* the rate at which the
    velocity is changing at time *t*. In the language of calculus, we can write'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*加速度*被定义为速度变化的速率。我们定义*a*为一个函数，它将每个时间*t*与该时刻的速度变化速率相联系。用微积分的语言，我们可以写出：'
- en: '![Image](Images/044equ01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/044equ01.jpg)'
- en: or
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![Image](Images/044equ02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/044equ02.jpg)'
- en: to define acceleration. Equation 4.12 is more succinct, but the two equations
    mean the same thing. We say that *a*(*t*) is the acceleration of the car at time
    *t*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 定义加速度。方程4.12更简洁，但这两个方程的含义是相同的。我们说* a *(*t*)是汽车在时间*t*时的加速度。
- en: We’re only dealing with one-dimensional motion in this chapter, so we represent
    acceleration with a number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只处理一维运动，因此我们用一个数字表示加速度。
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Equation 4.12 can be encoded in a function `accFromVel` that produces an acceleration
    function from a velocity function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 4.12 可以通过一个名为 `accFromVel` 的函数进行编码，该函数根据速度函数生成加速度函数。
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, this function is just the derivative. Here, we use point-free style to
    emphasize the equality of the two functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个函数只是导数。在这里，我们使用无点风格来强调这两个函数的相等性。
- en: If the acceleration happens to be constant, say *a*[0], we can integrate both
    sides of Equation 4.12 or 4.13 to obtain
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度恰好是常数，比如 *a*[0]，我们可以对方程 4.12 或 4.13 的两边进行积分，得到：
- en: '*a*[0]*t* = *v*(*t*) – *v*(0)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[0]*t* = *v*(*t*) – *v*(0)'
- en: If acceleration is constant, velocity is a linear function of time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度是常数，则速度是时间的线性函数。
- en: '![Image](Images/044equ03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/044equ03.jpg)'
- en: 'Here is the Haskell code for Equation 4.14:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方程式 4.14 的 Haskell 代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `CA` at the end of the name is an abbreviation for constant acceleration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 名称末尾的 `CA` 是“恒定加速度”的缩写。
- en: To believe that we really know what is happening with an object in motion, we
    want an expression that gives the position of the object as a function of time.
    Since position is the antiderivative or integral of velocity, we can obtain such
    a relationship by integrating both sides of Equation 4.14 to obtain
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了相信我们真正了解一个运动物体的情况，我们需要一个表达式来给出物体的位置随时间变化的关系。由于位置是速度的反导数或积分，我们可以通过对方程式 4.14
    两边进行积分，得到这种关系：
- en: '![Image](Images/044equ04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/044equ04.jpg)'
- en: If acceleration is constant, position is a quadratic function of time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度是常数，则位置是时间的二次函数。
- en: '![Image](Images/045equ01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/045equ01.jpg)'
- en: 'Here is the Haskell code for Equation 4.15:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方程式 4.15 的 Haskell 代码：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Equations 4.14 and 4.15 are known as *constant acceleration equations*. They
    are used over and over again in a typical introductory physics course. Later we
    will learn some techniques to deal with situations in which acceleration is not
    constant.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 4.14 和 4.15 被称为*恒定加速度方程*。它们在典型的入门物理课程中反复使用。稍后我们将学习一些技术来处理加速度不是常数的情况。
- en: The relationships between time, position, velocity, and acceleration are known
    as *kinematics*, or the description of motion. These are the quantities required
    to give a description of how a car on an air track is moving. We will need to
    introduce additional ideas, like force and mass, before we have a theory that
    can account for the causes of motion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 时间、位置、速度和加速度之间的关系被称为*运动学*，即运动的描述。这些是描述气轨上汽车运动所需的量。在我们有一个能解释运动原因的理论之前，我们需要引入其他概念，如力和质量。
- en: Approximate Algorithms and Finite Precision
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近似算法和有限精度
- en: In mathematics, the derivative is defined by the limit in Equation 4.4\. In
    many cases, a mathematical derivative of an explicitly specified function can
    be calculated exactly. The numerical `derivative` we defined in this chapter does
    not take a limit, relying instead on a small but finite *ϵ*. For this reason,
    the numerical derivative calculates an approximation to the derivative of a function.
    We call the rule for computing the derivative from a finite value of *ϵ* an *approximate
    algorithm*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，导数由方程 4.4 中的极限定义。在许多情况下，可以精确地计算出一个显式指定函数的数学导数。本章中定义的数值`derivative`并不采用极限，而是依赖于一个小但有限的*ϵ*。因此，数值导数计算的是函数导数的近似值。我们将从有限的*ϵ*值计算导数的规则称为*近似算法*。
- en: The use of approximate algorithms is the second source of inexactness in our
    computations. In [Chapter 1](ch01.xhtml), we saw that numbers with type `R`, or
    `Double`, are generally not represented exactly by the computer. Some numbers
    can be represented exactly, but even a number as seemingly innocent as 0.1 is
    not represented exactly as an `R`. This is because, like the number 0.2 in [Table
    1-4](ch01.xhtml#ch1tab4), 0.1 requires an infinite binary expansion (0.0001100110011\.
    . .), which the computer truncates at some point. This is usually not a problem
    because an `R` provides about 15 significant figures of precision, which is enough
    for our purposes but still *finite precision*. If we add a very small number to
    a very big number,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 近似算法的使用是我们计算中不精确性的第二个来源。在[第1章](ch01.xhtml)中，我们看到`R`类型或`Double`类型的数字通常不能被计算机精确表示。有些数字可以精确表示，但即使是看似无害的数字0.1在计算机中也不能精确表示为`R`。这是因为像[表
    1-4](ch01.xhtml#ch1tab4)中的数字0.2一样，0.1需要无限的二进制扩展（0.0001100110011...），而计算机会在某个点截断它。这通常不会成为问题，因为`R`提供大约15位有效数字的精度，足以满足我们的需求，但仍然是*有限精度*。如果我们将一个非常小的数加到一个非常大的数中，
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: the computer just throws away the very small number.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机直接丢弃了这个非常小的数字。
- en: Even if the computer doesn’t go to the extreme of throwing away a small number,
    the relative precision with which the small number is represented gets worse when
    it is added to a big number. For example, each of the numbers from 1/3 down to
    1/3 × 10^(18) in [Table 4-3](ch04.xhtml#ch4tab3) has about 15 decimal digits of
    precision, as indicated by the number of threes in its expression.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 即使计算机没有极端地丢弃一个小数，当它被加到一个大数时，小数的相对精度也会变差。例如，[表 4-3](ch04.xhtml#ch4tab3)中的每个数字，从1/3到1/3
    × 10^(18)，都有大约15位小数的精度，这通过它的表达式中的三的个数得以指示。
- en: '**Table 4-3:** Fractions Evaluated to About 15 Decimal Digits of Precision'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 分数精确到约 15 位小数的计算结果'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `1/3` | ⇝ | `0.3333333333333333` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `1/3` | ⇝ | `0.3333333333333333` |'
- en: '| `1/3000` | ⇝ | `3.333333333333333e-4` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `1/3000` | ⇝ | `3.333333333333333e-4` |'
- en: '| `1/3e6` | ⇝ | `3.3333333333333335e-7` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `1/3e6` | ⇝ | `3.3333333333333335e-7` |'
- en: '| `1/3e9` | ⇝ | `3.333333333333333e-10` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `1/3e9` | ⇝ | `3.333333333333333e-10` |'
- en: '| `1/3e12` | ⇝ | `3.3333333333333334e-13` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `1/3e12` | ⇝ | `3.3333333333333334e-13` |'
- en: '| `1/3e15` | ⇝ | `3.333333333333333e-16` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `1/3e15` | ⇝ | `3.333333333333333e-16` |'
- en: '| `1/3e18` | ⇝ | `3.3333333333333334e-19` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `1/3e18` | ⇝ | `3.3333333333333334e-19` |'
- en: However, when each of these numbers is added to the relatively large number
    1, a different number of threes is kept, as shown in [Table 4-4](ch04.xhtml#ch4tab4),
    depending on the relative size of the two numbers being added. When adding 1/3
    × 10⁹, for example, only 6 of its 15 threes are retained.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这些数值与相对较大的数字1相加时，保留的三的个数会有所不同，如[表 4-4](ch04.xhtml#ch4tab4)所示，这取决于被加的两个数的相对大小。例如，当加上1/3
    × 10⁹时，只有它的15个三位数中的6个被保留。
- en: '**Table 4-4:** How Adding a Small Number to a Relatively Big Number Reduces
    the Relative Precision of the Small Number'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4：** 将小数加到相对较大的数字上时，如何减少小数的相对精度'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `1 + 1/3` | ⇝ | `1.3333333333333333` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3` | ⇝ | `1.3333333333333333` |'
- en: '| `1 + 1/3000` | ⇝ | `1.0003333333333333` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3000` | ⇝ | `1.0003333333333333` |'
- en: '| `1 + 1/3e6` | ⇝ | `1.0000003333333334` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3e6` | ⇝ | `1.0000003333333334` |'
- en: '| `1 + 1/3e9` | ⇝ | `1.0000000003333334` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3e9` | ⇝ | `1.0000000003333334` |'
- en: '| `1 + 1/3e12` | ⇝ | `1.0000000000003333` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3e12` | ⇝ | `1.0000000000003333` |'
- en: '| `1 + 1/3e15` | ⇝ | `1.0000000000000004` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3e15` | ⇝ | `1.0000000000000004` |'
- en: '| `1 + 1/3e18` | ⇝ | `1.0` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 1/3e18` | ⇝ | `1.0` |'
- en: The process of adding a small number to a big number is central to the idea
    of a derivative. We would like *ϵ* to be small, but the fact that an `R` is only
    an approximation to a real number means we don’t want it to be too small.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个小数加到一个大数上的过程是导数概念的核心。我们希望*ϵ*很小，但`R`仅是一个近似值，意味着我们不希望它太小。
- en: '[Table 4-5](ch04.xhtml#ch4tab5) shows the relative error in a numerical derivative
    of the function *f*, where *f* (*x*) = *x*⁴/4\. The exact derivative is *Df* (*x*)
    = *x*³. The derivative is evaluated at *x* = 1, so the exact result is 1\. Each
    row of the table shows the relative error for values of *ϵ* that range from 1
    down to 10^(–18).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-5](ch04.xhtml#ch4tab5)展示了函数*f*的数值导数的相对误差，其中*f*(*x*) = *x*⁴/4。精确的导数是*Df*(*x*)
    = *x*³。导数在*x* = 1时求值，因此精确结果是1。表中的每一行显示了*ϵ*的相对误差，其范围从1到10^(–18)。'
- en: '**Table 4-5:** Relative Error of a Numerical Derivative That Decreases as *ϵ*
    Gets Smaller and Increases as *ϵ* Gets Smaller Still'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-5：** 数值导数的相对误差，随着*ϵ*变小而减小，随着*ϵ*进一步减小而增大'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `derivative 1 (\x -> x**4 / 4) 1 - 1` | ⇝ | `0.25` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1 (\x -> x**4 / 4) 1 - 1` | ⇝ | `0.25` |'
- en: '| `derivative 1e-3 (\x -> x**4 / 4) 1 - 1` | ⇝ | `2.499998827953931e-7` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-3 (\x -> x**4 / 4) 1 - 1` | ⇝ | `2.499998827953931e-7` |'
- en: '| `derivative 1e-6 (\x -> x**4 / 4) 1 - 1` | ⇝ | `1.000088900582341e-12` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-6 (\x -> x**4 / 4) 1 - 1` | ⇝ | `1.000088900582341e-12` |'
- en: '| `derivative 1e-9 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.274037099909037e-8` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-9 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.274037099909037e-8` |'
- en: '| `derivative 1e-12 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.890058234101161e-5` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-12 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.890058234101161e-5` |'
- en: '| `derivative 1e-15 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-7.992778373592246e-4` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-15 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-7.992778373592246e-4` |'
- en: '| `derivative 1e-18 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-1.0` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `derivative 1e-18 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-1.0` |'
- en: As *ϵ* decreases from 1 down to 10^(–6), the error gets smaller. For these values
    of *ϵ*, the approximate nature of the derivative algorithm is a larger contribution
    to the error than the finite precision used by the computer. But as *ϵ* continues
    to decrease, the error in the table gets larger. For these values of *ϵ*, the
    finite precision used in the calculation and representation of numbers is a larger
    contribution to the error than the approximate algorithm for computing the derivative.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 随着*ϵ*从 1 下降到 10^(–6)，误差变小。在这些*ϵ*值下，导数算法的近似性质对误差的贡献大于计算机使用的有限精度。但随着*ϵ*继续减小，表中的误差变大。在这些*ϵ*值下，计算和表示数字时使用的有限精度对误差的贡献大于计算导数的近似算法。
- en: In the case of the numerical derivative, finite precision wants *ϵ* to be large
    so its relative precision is maintained, but the algorithm wants *ϵ* to be small
    to approach the true derivative. The best results are obtained somewhere in the
    middle, around *ϵ* = 10^(–6) for the situation in [Table 4-5](ch04.xhtml#ch4tab5).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值导数的情况下，有限精度希望*ϵ*较大，以保持其相对精度，但算法希望*ϵ*较小，以逼近真实的导数。最佳结果出现在中间值附近，对于[表 4-5](ch04.xhtml#ch4tab5)中的情况，*ϵ*
    = 10^(–6)。
- en: These two sources of inaccuracy, finite precision and approximate algorithms,
    are going to be with us throughout our journey in computational physics. The algorithms
    for solving differential equations that we introduce later are also approximate
    algorithms, relying on small but finite steps to solve differential equations
    that are continuous. We will introduce rules of thumb for choosing such small
    finite parameters. Our attitude in this book is not to deeply study the interesting
    subject of numerical analysis, or to take an alarmist view toward inaccuracy,
    but rather simply to be aware of the nature of approximate calculation so we can
    produce meaningful results.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种不准确来源——有限精度和近似算法——将在我们计算物理学的旅程中一直伴随我们。稍后我们介绍的求解微分方程的算法也是近似算法，它依赖于小但有限的步骤来求解连续的微分方程。我们将介绍一些经验法则来选择这些小的有限参数。本书的态度并非深入研究数值分析这一有趣的学科，也不是对不准确性采取警惕的立场，而是简单地意识到近似计算的本质，以便我们能够得出有意义的结果。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小结
- en: This chapter introduced the notions of position, velocity, acceleration, and
    time, as well as their relationships, which are articulated by the mathematical
    idea of a derivative. We saw how various kinematic equations can be encoded in
    Haskell. In the next chapter, we take a look at lists, which play a role almost
    as central as functions in functional programming because they are the basis of
    most of our iteration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了位置、速度、加速度和时间的概念，以及它们之间的关系，这些关系通过导数的数学概念来表述。我们看到如何将各种运动学方程编码为 Haskell 语言。在下一章，我们将介绍列表，它们在函数式编程中的作用几乎与函数同等重要，因为它们是大多数迭代的基础。
- en: Exercises
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: '**Exercise 4.1.** Consider the following function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 4.1：** 考虑以下函数：'
- en: '![Image](Images/047equ01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/047equ01.jpg)'
- en: The derivative of this function is *Df* (*x*) = *x*. In this case, *Df* is the
    identity function on real numbers. Because
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的导数是*Df*(*x*) = *x*。在这种情况下，*Df*是实数上的恒等函数。因为
- en: '![Image](Images/047equ02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/047equ02.jpg)'
- en: even before we take the limit, our numerical `derivative` should give exact
    results for any *ϵ* that we use. Write Haskell code to take the derivative of
    *f* using `derivative 10`, `derivative 1`, and `derivative 0.1`. You should find
    that `derivative 10` and `derivative 1` produce the identity function exactly
    and that `derivative 0.1` comes very close but is not exact. Why does `derivative
    0.1` not produce exactly the identity function on real numbers?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们取极限之前，我们的数值 `derivative` 应该对我们使用的任何 *ϵ* 都给出精确的结果。编写 Haskell 代码，使用 `derivative
    10`、`derivative 1` 和 `derivative 0.1` 来计算 *f* 的导数。你应该会发现，`derivative 10` 和 `derivative
    1` 会准确地得到恒等函数，而 `derivative 0.1` 接近但并不完全准确。为什么 `derivative 0.1` 在实数上无法精确产生恒等函数？
- en: '**Exercise 4.2.** Consider the following function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.2.** 考虑以下函数：'
- en: '*f*(*x*) = *x*³'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *x*³'
- en: The derivative of this function is *Df* (*x*) = 3*x*². The error introduced
    by the numerical derivative at a particular value of *x* is the absolute value
    of the difference between the numerical derivative evaluated at *x* and the exact
    derivative evaluated at *x*. Write Haskell code to take the derivative of *f*
    using `derivative 1`. By evaluating the derivative at different values of *x*,
    see if you can find a pattern for the error introduced by the numerical derivative.
    After you find the pattern for this error, extend your exploration to `derivative
    a` for different values of `a`. Can you give an expression for the error in terms
    of `a`?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的导数为 *Df* (*x*) = 3*x*²。在特定的 *x* 值下，由数值导数引入的误差是数值导数在 *x* 处的计算值与精确导数在 *x*
    处的计算值之间的绝对差。编写 Haskell 代码，使用 `derivative 1` 计算 *f* 的导数。通过在不同的 *x* 值下计算导数，看看你能否找到数值导数引入误差的规律。在你找到这种误差的规律后，扩展你的探索，考虑对不同的
    `a` 值使用 `derivative a`。你能给出一个关于误差的表达式，涉及 `a` 吗？
- en: When *x* = 4, *Df* (4) = 48\. What value of `a` produces an error of 1 percent
    at *x* = 4? When *x* = 0.1, *Df* (0.1) = 0.03\. What value of `a` produces an
    error of 1 percent at *x* = 0.1?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x* = 4 时，*Df* (4) = 48。什么值的 `a` 会在 *x* = 4 时产生 1% 的误差？当 *x* = 0.1 时，*Df*
    (0.1) = 0.03。什么值的 `a` 会在 *x* = 0.1 时产生 1% 的误差？
- en: '**Exercise 4.3.** Find a function and a value of its independent variable so
    that `derivative 0.01` produces at least a 10 percent error compared to the exact
    derivative.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.3.** 找一个函数和其自变量的一个值，使得使用`derivative 0.01`时与精确导数相比产生至少 10% 的误差。'
- en: '**Exercise 4.4.** Consider the cosine function, `cos`, and its numerical derivative
    `derivative a cos`. For what values of the independent variable (let’s call it
    `t`) is the numerical derivative most sensitive to the value of `a`? For what
    values is it least sensitive? You should be able to find some values of `t` where
    `a` can be made very large and the numerical derivative is still a good approximation.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.4.** 考虑余弦函数 `cos` 及其数值导数 `derivative a cos`。对于哪些自变量值（我们称之为 `t`）数值导数对
    `a` 的值最为敏感？对于哪些值最不敏感？你应该能够找到一些 `t` 值，使得 `a` 可以非常大，而数值导数仍然是一个很好的近似值。'
- en: '**Exercise 4.5.** Consider the following position function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 4.5.** 考虑以下位置函数：'
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Write functions
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: and
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: for the corresponding velocity and acceleration functions by taking an analytic
    derivative of the position function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对位置函数进行解析导数，得到对应的速度和加速度函数。
- en: The `undefined` function can be used as a placeholder for code not yet written.
    The compiler will accept `undefined` and happily compile the code, but if you
    try to use a function based on `undefined`, you will get a runtime error.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined` 函数可以用作尚未编写的代码的占位符。编译器会接受`undefined`并愉快地编译代码，但如果你尝试使用基于`undefined`的函数，你将会遇到运行时错误。'
- en: Write functions
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: for the corresponding velocity and acceleration functions by taking a numerical
    derivative of the position function using `derivative 0.01`. Can you find any
    values of `t` where `vel1Analytic t` and `vel1Numerical t` differ substantially?
    Can you find any values of `t` where `acc1Analytic t` and `acc1Numerical t` differ
    substantially?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对位置函数使用`derivative 0.01`进行数值导数，可以得到对应的速度和加速度函数。你能找到`vel1Analytic t`和`vel1Numerical
    t`显著不同的`t`值吗？你能找到`acc1Analytic t`和`acc1Numerical t`显著不同的`t`值吗？
