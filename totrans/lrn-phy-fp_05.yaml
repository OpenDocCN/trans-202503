- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DESCRIBING MOTION
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The description of the motion of an object in terms of its position, velocity,
    and acceleration is called *kinematics*. In this chapter, we’ll give a succinct
    review of one-dimensional kinematics while showing how the Haskell language naturally
    encodes its ideas and equations. We’ll use the Haskell functions introduced in
    [Chapter 2](ch02.xhtml) and the types we introduced in [Chapter 3](ch03.xhtml).
    The equations of kinematics, being largely definitional, have an almost one-to-one
    correspondence with Haskell functions.
  prefs: []
  type: TYPE_NORMAL
- en: Position and Velocity on an Air Track
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever seen an air track? An air track is a fun toy, or, if you’re feeling
    more serious, a piece of experimental equipment. It consists of a long horizontal
    rail (maybe 2 or 3 meters long) with little holes that allow air to shoot upward
    out of the rail. A small car (maybe 5 cm wide and 10 cm long) with no wheels rides
    atop this air track. The air eliminates most of the friction that would exist
    between the car and the rail as the car slides along the rail, so the car can
    slide freely along the air track. The cross section of the rail is shaped so that
    the car can only slide back and forth along the length of the rail; the car cannot
    slide sideways or move up or down.
  prefs: []
  type: TYPE_NORMAL
- en: We can make marks on the air track to allow us to talk about the *position*
    of the car. Let’s imagine that we have an air track that has already been carefully
    marked in meters. For a particular motion of the car on the air track, we define
    *x* to be the function that associates each time *t* with the position of the
    car at that time. We say that *x*(*t*) is the position of the car at time *t*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Velocity* is defined to be the rate at which position changes. The *average
    velocity* over the time interval that starts at time *t*[0] and ends at time *t*[1]
    is'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/036equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Average velocity is change in position divided by change in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the advantages of using the Haskell programming language is that there
    is almost a one-to-one correspondence between the equations of physics and the
    code we write to describe them. In Haskell, the following lines, which could appear
    in a source code file, have the same meaning as Equation 4.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line of Haskell code is a type signature saying that `averageVelocity`
    is a function that takes a time, a second time, and a position function as input
    and gives a velocity as output. We can use the arrow (`->`) to chain together
    inputs. The last term is the output type, and all of the other terms are input
    types. There is a deeper reason for this notation that we will explore in [Chapters
    6](ch06.xhtml) and [9](ch09.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The second line of Haskell code above is the definition for the function `averageVelocity`.
    The definition says that if we call `t0` the first time, `t1` the second time,
    and `x` the position function, the velocity will be given by the expression on
    the right of the equal sign. The inputs `t0` and `t1` are numbers, but the input
    `x` is a function. The practice of using functions as inputs to other functions
    is common in Haskell; we will discuss this in much more detail in [Chapter 6](ch06.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](ch04.xhtml#ch4tab1) shows a comparison of mathematical notation
    and Haskell notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Comparison of Mathematical Notation and Haskell Notation'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mathematical notation** | **Haskell notation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *t*[0] | `t0` |'
  prefs: []
  type: TYPE_TB
- en: '| *t*[1] | `t1` |'
  prefs: []
  type: TYPE_TB
- en: '| *x* | `x` |'
  prefs: []
  type: TYPE_TB
- en: '| *x*(*t*[0]) | `x t0` |'
  prefs: []
  type: TYPE_TB
- en: '| *x*(*t*[1]) | `x t1` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Image](Images/036equ02.jpg) | `averageVelocity` |'
  prefs: []
  type: TYPE_TB
- en: As we saw in [Chapter 1](ch01.xhtml), parentheses are not required to apply
    a function to an argument. The `x` in the code is a function, just like the *x*
    in Equation 4.1\. When we write *x*(*t*[0]), we mean the function *x* applied
    to (or evaluated at) the time *t*[0]. Similarly, when we write `x t0`, we mean
    the function `x` applied to (or evaluated at) the time `t0`. Functions play such
    a central role in Haskell that juxtaposition of names implies that the first is
    a function and the second is an argument, and that the function is to be applied
    to the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The notation ![Image](Images/037equ01.jpg) explicitly shows that average velocity
    depends on the initial time *t*[0] and the final time *t*[1] of the time interval,
    but the dependence on the position function is implicit and not shown in Equation
    4.1\. Haskell code shows all dependencies explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Types for Physical Quantities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It makes our thinking simpler if we can talk about velocity at a single time
    rather than over a time interval. We can take a step in this direction by labeling
    the average velocity with the time at the center of the interval and the length
    of the interval, rather than with the beginning and ending times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/037equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Haskell, Equation 4.2 looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do need to enclose `t + dt/2` in parentheses so that adding `t` to
    `dt/2` takes place before the function `x` is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the code above, the types from the type signature match up with
    the arguments in the definition in the same order, as emphasized in [Table 4-2](ch04.xhtml#ch4tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Matching of Arguments and Types for the Function `average Velocity2`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Argument** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | `Time` |'
  prefs: []
  type: TYPE_TB
- en: '| `dt` | `TimeInterval` |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | `PositionFunction` |'
  prefs: []
  type: TYPE_TB
- en: At this point, we’re only dealing with motion in one dimension, so time, position,
    and velocity are all represented by numbers. We tell the Haskell compiler this
    with the following lines, which are called *type synonyms*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only type in the lines above that Haskell understands by default is `Double`.
    I prefer to think of this as the type of real numbers (not every real number can
    be represented by a `Double`, but we are willing to do approximate calculation),
    so I like the name `R` better than `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: The first line says that whenever I use the type `R`, it means the same thing
    as `Double`. The next four lines say that time, time interval, position, and velocity
    are all just real numbers at this point. Finally, the last two lines define function
    types. The type `PositionFunction` is the type of a function that takes time as
    input and gives position as output. Recall that the argument `x` above was a function
    with this type. Since `Time` is the same as `R` and `Position` is the same as
    `R`, the type `PositionFunction` is the same as `R -> R`, which takes a real number
    as input and produces a real number as output. For a similar reason, the type
    `VelocityFunction` is also the same as the function type `R -> R`.
  prefs: []
  type: TYPE_NORMAL
- en: A type synonym merely gives an additional name to an existing type. The compiler
    sees `Double`, `R`, `Position`, and `Velocity` as identical and is unable to warn
    us if we attempt to use a `Velocity` where a `Position` is called for. In [Chapter
    10](ch10.xhtml), we will introduce a way to define a new type that is distinct
    from all existing types and allows the compiler to check that we haven’t confused
    one type with another. There is also a Haskell package called `units` ([*https://hackage.haskell.org/package/units*](https://hackage.haskell.org/package/units))
    specifically designed to allow physical units such as meters per second to be
    attached to numerical quantities.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Derivatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If in making the time interval Δ*t* shorter and shorter we find that the average
    velocity converges to a particular value, we call this value the *instantaneous
    velocity*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/038equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A limit of a ratio of differences occurs often enough that it gets awarded
    the name *derivative*. Given a function *x* of one variable, the derivative of
    *x*, denoted *Dx*, *x*’, or ![Image](Images/xdot.jpg), is the function of one
    variable defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/038equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**HANDLING CONTINUOUS TIME**'
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical definitions of limit and derivative require a continuity of
    real numbers that may not be present in the physical world. There’s a bit of idealization
    when we imagine time to be continuous. Time certainly seems to be continuous,
    and no one has made any direct measurements that suggest a discreteness to time,
    but there are quantum theoretical reasons to believe that at some very short scale,
    time may not behave as a perfect continuum.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a guess at a time scale when quantum effects are likely to disturb
    the continuity of time, we can use *dimensional analysis*, which means combining
    parameters that are relevant to the situation to construct a quantity with dimensions
    of time. We haven’t said anything at all about the situation, so all we have to
    work with are fundamental constants of physics, namely the Newtonian constant
    of gravitation *G*, Planck’s constant ![Image](Images/hbar.jpg), and the speed
    of light in a vacuum *c*. There is only one way to multiply powers of these fundamental
    constants to produce a result with dimensions of time. The resulting time is called
    the *Planck time*, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/039equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Planck time is many, many orders of magnitude smaller than the smallest
    time scales that can currently be probed. For the physics that is experimentally
    accessible today, time appears continuous, and the derivative is in no danger
    of becoming obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that instantaneous velocity is the derivative of position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/039equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that Equation 4.5 is an equality of functions: the instantaneous velocity
    function is on the left of the equality and the derivative of the position function
    is on the right. When two functions are equal, they give equal results for equal
    inputs, so we can also write'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/039equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for any time *t*. The right-hand side is the function *Dx* evaluated at the
    time *t*. We can think of the derivative operator as taking the entire position
    function as input and returning the velocity function as output.
  prefs: []
  type: TYPE_NORMAL
- en: It’s more common to see the notation
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/039equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to define velocity. Equation 4.5 is more succinct, but Equations 4.5, 4.6, and
    4.7 all mean the same thing. We say that *v*(*t*) is the velocity of the car at
    time *t*. Note that the velocity of the car on the air track can be negative (meaning
    the position is decreasing) or positive (meaning the position is increasing).
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives in Haskell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A derivative takes a function as input and gives a function as output. In other
    words, a derivative is a function from functions to functions. A function that
    takes another function as input or returns a function as output is called a *higher-order
    function*. If the idea of functions as inputs and outputs of other functions is
    new to you, it will take some practice and examples to get used to, but I assure
    you that it is worth the effort. There are many ideas in physics, the derivative
    being just one, that are naturally expressed as higher-order functions. [Chapter
    6](ch06.xhtml) is entirely devoted to such higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible type synonym for a derivative looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since arrows are right associative, with the rightmost arrow having highest
    precedence, the type `(R -> R) -> R -> R` is the same as `(R -> R) -> (R -> R)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a numerical derivative in Haskell like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This numerical derivative does not take a limit but instead uses a small interval,
    `dt`, supplied by the user. If the interval is small enough, the result should
    be a good approximation to the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s play the matching game with arguments and types for the function `derivative`
    like we did for the function `averageVelocity2`. At first glance, it seems that
    `dt` has type `R`, `x` has type `Derivative`, and `t` is left with no type at
    all. This does not make any sense; the trouble is that we need to expand the `Derivative`
    type. When fully expanded, `derivative` has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, `dt` has type `R`, `x` has type `R -> R`, `t` has type `R`, and the final
    `R` is the return type.
  prefs: []
  type: TYPE_NORMAL
- en: In playing the matching game, we are thinking of `derivative` as a function
    with three inputs and one output. The arrow notation may seem a strange way to
    specify a function with three inputs. There is a deeper meaning to the notation
    that we will discuss briefly now and treat more fully in [Chapter 6](ch06.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since arrows associate to the right, the following three types are the same
    to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R -> (R -> R) -> R -> R`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R -> (R -> R) -> (R -> R)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R -> ((R -> R) -> (R -> R))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the thinking from the matching game, it appears that the first type takes
    three inputs, the second type takes two inputs, and the third type takes one input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to think about the function `derivative`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`derivative` takes three inputs, with types `R`, `R -> R`, and `R`, and produces
    one output with type `R`. In this way of thinking, `derivative` takes a time interval,
    a position function, and a time and returns the numeric velocity at that time.
    This was our thinking in the matching game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`derivative` takes two inputs, with types `R` and `R -> R`, and produces one
    output with type `R -> R`. In this way of thinking, `derivative` takes a time
    interval and a position function and returns a velocity function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`derivative` takes one input with type `R` (namely `dt`) and produces one output
    with type `(R -> R) -> R -> R` (or type `Derivative`). This is the way the compiler
    thinks of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three ways of thinking are mathematically equivalent, but they seem to
    sit differently with the brain. The second way of thinking is my favorite because
    I like to think of a derivative as something that takes a function as input and
    gives a function as output.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a function with two inputs into a function with one input whose
    output is a function is called *currying*, named after the logician Haskell Curry
    (who donates his first name to the programming language we are using). Currying
    is discussed more fully in [Chapters 6](ch06.xhtml) and [9](ch09.xhtml). Currying
    allows the compiler to treat all functions as having a single input and a single
    output, with the understanding that the input and/or the output might be a function.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the Car’s Position and Velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we have a car position function
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/041equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'in which *t* is in seconds and *x[C]* is in meters. The corresponding Haskell
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using Equation 4.5, we can find the velocity function for the car.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/041equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding Haskell code could be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the Haskell code, `derivative 0.01` is playing the role of the derivative
    operator *D* in the mathematical expression. These are not exactly the same thing
    because *D* is a true mathematical derivative and `derivative 0.01` is only a
    numerical derivative, but we can get decent approximate results by using it, and
    we can improve our results to the degree that we like by using a number smaller
    than `0.01`. Moreover, `derivative 0.01 sin` is a perfectly valid function with
    type `R -> R` in the Haskell language and is every bit as legitimate as the function
    `cos` (also type `R -> R`) that it approximates. It can be evaluated, graphed,
    differentiated, integrated, or used anywhere that a function with type `R -> R`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 4.9 is an equality of functions, and the corresponding Haskell code
    defines the function `carVelocity` without using any function arguments. This
    is the point-free style introduced in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s just as valid to write Haskell code based on Equation 4.6\. The mathematical
    equation would then look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/042equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the Haskell code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use a prime to denote an alternate way of writing the function. As far as
    the computer is concerned, `carVelocity` and `carVelocity'` mean the same thing.
    The difference is one of notational preference. We’ll often use primes in code
    to indicate an alternate way of writing something. This prime has nothing to do
    with the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: The position function for the car is given analytically, so we can take the
    derivative analytically and write an explicit equation for the velocity of the
    car.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/042equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also write this in Haskell as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: but in this book we’re not asking the computer to do symbolic algebra or to
    take derivatives analytically. The function `carVelocityAnalytic` is *not* the
    same function as `carVelocity` or `carVelocity'`. The numeric value of `carVelocity
    2` is close to, but not exactly the same as, the numeric value of `carVelocityAnalytic`
    `2`. In this book, we’ll only ask the computer to do things that a scientific
    calculator can do. Nevertheless, we’ll find that Haskell’s notation will aid our
    thinking through attention to the types of expressions, through the concision
    allowed by higher-order functions and through the simplicity of writing language
    that avoids mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: There is an even better way to express Equation 4.5 in Haskell. The function
    `velFromPos` accepts any position function as input and supplies the corresponding
    velocity function as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We see that the function to find velocity from position is none other than the
    derivative function we defined earlier. Note also that we can split a type signature
    across multiple lines. This is often good practice, and it gives the code writer
    the opportunity to give a short comment about the meaning of each type in the
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: If the velocity happens to be constant, say *v*[0], we can integrate both sides
    of Equation 4.5 or 4.7 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '*v*[0]*t* = *x*(*t*) – *x*(0)'
  prefs: []
  type: TYPE_NORMAL
- en: If velocity is constant, position is a linear function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*t*) = *v*[0]*t* + *x*(0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the corresponding Haskell code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CV` at the end of the name is an abbreviation for constant velocity. Notice
    again the different ways to read the type: we can think of `positionCV` as a function
    that takes three arguments and returns a `Position`, as a function that takes
    two arguments and returns a function `Time -> Position`, or as a function that
    takes one argument and returns a function `Velocity -> Time ->` `Position`. The
    expression `positionCV 5 10 2` is the `Position` of an object at time 2 s, if
    it moves with a constant velocity of 10 m/s and started at a position of 5 m when
    time was 0\. The expression `positionCV 5 10` is the `PositionFunction` that describes
    an object moving with a constant velocity of 10 m/s that started at a position
    of 5 m when time was 0.'
  prefs: []
  type: TYPE_NORMAL
- en: In everyday speech we often use the terms *velocity* and *speed* interchangeably.
    The language of physics makes a technical distinction between these two terms.
    *Speed* is the magnitude (absolute value) of velocity. Speed is never negative.
    Although speed (that is, how fast something is going) is the simpler idea to understand,
    velocity is much more important to the theory of motion. Velocity contains more
    information than speed because it tells the direction of travel as well as the
    speed. The velocity of a rock thrown straight upward makes a continuous regular
    change, both while the rock travels upward and while it travels downward. Speed,
    on the other hand, decreases on the way up and increases on the way down, unnecessarily
    making it seem like the situation needs to be thought of as two processes. There
    will be times when it is convenient to speak about speed, and it is certainly
    worth having a concept and a word for it. When we discuss motion in more than
    one dimension, velocity will require a vector for its description, while speed
    will remain a number.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Acceleration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Acceleration* is defined to be the rate at which velocity changes. We define
    *a* to be the function that associates with each time *t* the rate at which the
    velocity is changing at time *t*. In the language of calculus, we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/044equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/044equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to define acceleration. Equation 4.12 is more succinct, but the two equations
    mean the same thing. We say that *a*(*t*) is the acceleration of the car at time
    *t*.
  prefs: []
  type: TYPE_NORMAL
- en: We’re only dealing with one-dimensional motion in this chapter, so we represent
    acceleration with a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Equation 4.12 can be encoded in a function `accFromVel` that produces an acceleration
    function from a velocity function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, this function is just the derivative. Here, we use point-free style to
    emphasize the equality of the two functions.
  prefs: []
  type: TYPE_NORMAL
- en: If the acceleration happens to be constant, say *a*[0], we can integrate both
    sides of Equation 4.12 or 4.13 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '*a*[0]*t* = *v*(*t*) – *v*(0)'
  prefs: []
  type: TYPE_NORMAL
- en: If acceleration is constant, velocity is a linear function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/044equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell code for Equation 4.14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `CA` at the end of the name is an abbreviation for constant acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: To believe that we really know what is happening with an object in motion, we
    want an expression that gives the position of the object as a function of time.
    Since position is the antiderivative or integral of velocity, we can obtain such
    a relationship by integrating both sides of Equation 4.14 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/044equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If acceleration is constant, position is a quadratic function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/045equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell code for Equation 4.15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Equations 4.14 and 4.15 are known as *constant acceleration equations*. They
    are used over and over again in a typical introductory physics course. Later we
    will learn some techniques to deal with situations in which acceleration is not
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: The relationships between time, position, velocity, and acceleration are known
    as *kinematics*, or the description of motion. These are the quantities required
    to give a description of how a car on an air track is moving. We will need to
    introduce additional ideas, like force and mass, before we have a theory that
    can account for the causes of motion.
  prefs: []
  type: TYPE_NORMAL
- en: Approximate Algorithms and Finite Precision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In mathematics, the derivative is defined by the limit in Equation 4.4\. In
    many cases, a mathematical derivative of an explicitly specified function can
    be calculated exactly. The numerical `derivative` we defined in this chapter does
    not take a limit, relying instead on a small but finite *ϵ*. For this reason,
    the numerical derivative calculates an approximation to the derivative of a function.
    We call the rule for computing the derivative from a finite value of *ϵ* an *approximate
    algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: The use of approximate algorithms is the second source of inexactness in our
    computations. In [Chapter 1](ch01.xhtml), we saw that numbers with type `R`, or
    `Double`, are generally not represented exactly by the computer. Some numbers
    can be represented exactly, but even a number as seemingly innocent as 0.1 is
    not represented exactly as an `R`. This is because, like the number 0.2 in [Table
    1-4](ch01.xhtml#ch1tab4), 0.1 requires an infinite binary expansion (0.0001100110011\.
    . .), which the computer truncates at some point. This is usually not a problem
    because an `R` provides about 15 significant figures of precision, which is enough
    for our purposes but still *finite precision*. If we add a very small number to
    a very big number,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: the computer just throws away the very small number.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the computer doesn’t go to the extreme of throwing away a small number,
    the relative precision with which the small number is represented gets worse when
    it is added to a big number. For example, each of the numbers from 1/3 down to
    1/3 × 10^(18) in [Table 4-3](ch04.xhtml#ch4tab3) has about 15 decimal digits of
    precision, as indicated by the number of threes in its expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** Fractions Evaluated to About 15 Decimal Digits of Precision'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3` | ⇝ | `0.3333333333333333` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3000` | ⇝ | `3.333333333333333e-4` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3e6` | ⇝ | `3.3333333333333335e-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3e9` | ⇝ | `3.333333333333333e-10` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3e12` | ⇝ | `3.3333333333333334e-13` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3e15` | ⇝ | `3.333333333333333e-16` |'
  prefs: []
  type: TYPE_TB
- en: '| `1/3e18` | ⇝ | `3.3333333333333334e-19` |'
  prefs: []
  type: TYPE_TB
- en: However, when each of these numbers is added to the relatively large number
    1, a different number of threes is kept, as shown in [Table 4-4](ch04.xhtml#ch4tab4),
    depending on the relative size of the two numbers being added. When adding 1/3
    × 10⁹, for example, only 6 of its 15 threes are retained.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** How Adding a Small Number to a Relatively Big Number Reduces
    the Relative Precision of the Small Number'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3` | ⇝ | `1.3333333333333333` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3000` | ⇝ | `1.0003333333333333` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3e6` | ⇝ | `1.0000003333333334` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3e9` | ⇝ | `1.0000000003333334` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3e12` | ⇝ | `1.0000000000003333` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3e15` | ⇝ | `1.0000000000000004` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 1/3e18` | ⇝ | `1.0` |'
  prefs: []
  type: TYPE_TB
- en: The process of adding a small number to a big number is central to the idea
    of a derivative. We would like *ϵ* to be small, but the fact that an `R` is only
    an approximation to a real number means we don’t want it to be too small.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-5](ch04.xhtml#ch4tab5) shows the relative error in a numerical derivative
    of the function *f*, where *f* (*x*) = *x*⁴/4\. The exact derivative is *Df* (*x*)
    = *x*³. The derivative is evaluated at *x* = 1, so the exact result is 1\. Each
    row of the table shows the relative error for values of *ϵ* that range from 1
    down to 10^(–18).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-5:** Relative Error of a Numerical Derivative That Decreases as *ϵ*
    Gets Smaller and Increases as *ϵ* Gets Smaller Still'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1 (\x -> x**4 / 4) 1 - 1` | ⇝ | `0.25` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-3 (\x -> x**4 / 4) 1 - 1` | ⇝ | `2.499998827953931e-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-6 (\x -> x**4 / 4) 1 - 1` | ⇝ | `1.000088900582341e-12` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-9 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.274037099909037e-8` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-12 (\x -> x**4 / 4) 1 - 1` | ⇝ | `8.890058234101161e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-15 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-7.992778373592246e-4` |'
  prefs: []
  type: TYPE_TB
- en: '| `derivative 1e-18 (\x -> x**4 / 4) 1 - 1` | ⇝ | `-1.0` |'
  prefs: []
  type: TYPE_TB
- en: As *ϵ* decreases from 1 down to 10^(–6), the error gets smaller. For these values
    of *ϵ*, the approximate nature of the derivative algorithm is a larger contribution
    to the error than the finite precision used by the computer. But as *ϵ* continues
    to decrease, the error in the table gets larger. For these values of *ϵ*, the
    finite precision used in the calculation and representation of numbers is a larger
    contribution to the error than the approximate algorithm for computing the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the numerical derivative, finite precision wants *ϵ* to be large
    so its relative precision is maintained, but the algorithm wants *ϵ* to be small
    to approach the true derivative. The best results are obtained somewhere in the
    middle, around *ϵ* = 10^(–6) for the situation in [Table 4-5](ch04.xhtml#ch4tab5).
  prefs: []
  type: TYPE_NORMAL
- en: These two sources of inaccuracy, finite precision and approximate algorithms,
    are going to be with us throughout our journey in computational physics. The algorithms
    for solving differential equations that we introduce later are also approximate
    algorithms, relying on small but finite steps to solve differential equations
    that are continuous. We will introduce rules of thumb for choosing such small
    finite parameters. Our attitude in this book is not to deeply study the interesting
    subject of numerical analysis, or to take an alarmist view toward inaccuracy,
    but rather simply to be aware of the nature of approximate calculation so we can
    produce meaningful results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced the notions of position, velocity, acceleration, and
    time, as well as their relationships, which are articulated by the mathematical
    idea of a derivative. We saw how various kinematic equations can be encoded in
    Haskell. In the next chapter, we take a look at lists, which play a role almost
    as central as functions in functional programming because they are the basis of
    most of our iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 4.1.** Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/047equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The derivative of this function is *Df* (*x*) = *x*. In this case, *Df* is the
    identity function on real numbers. Because
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/047equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: even before we take the limit, our numerical `derivative` should give exact
    results for any *ϵ* that we use. Write Haskell code to take the derivative of
    *f* using `derivative 10`, `derivative 1`, and `derivative 0.1`. You should find
    that `derivative 10` and `derivative 1` produce the identity function exactly
    and that `derivative 0.1` comes very close but is not exact. Why does `derivative
    0.1` not produce exactly the identity function on real numbers?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.2.** Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*x*) = *x*³'
  prefs: []
  type: TYPE_NORMAL
- en: The derivative of this function is *Df* (*x*) = 3*x*². The error introduced
    by the numerical derivative at a particular value of *x* is the absolute value
    of the difference between the numerical derivative evaluated at *x* and the exact
    derivative evaluated at *x*. Write Haskell code to take the derivative of *f*
    using `derivative 1`. By evaluating the derivative at different values of *x*,
    see if you can find a pattern for the error introduced by the numerical derivative.
    After you find the pattern for this error, extend your exploration to `derivative
    a` for different values of `a`. Can you give an expression for the error in terms
    of `a`?
  prefs: []
  type: TYPE_NORMAL
- en: When *x* = 4, *Df* (4) = 48\. What value of `a` produces an error of 1 percent
    at *x* = 4? When *x* = 0.1, *Df* (0.1) = 0.03\. What value of `a` produces an
    error of 1 percent at *x* = 0.1?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.3.** Find a function and a value of its independent variable so
    that `derivative 0.01` produces at least a 10 percent error compared to the exact
    derivative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.4.** Consider the cosine function, `cos`, and its numerical derivative
    `derivative a cos`. For what values of the independent variable (let’s call it
    `t`) is the numerical derivative most sensitive to the value of `a`? For what
    values is it least sensitive? You should be able to find some values of `t` where
    `a` can be made very large and the numerical derivative is still a good approximation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 4.5.** Consider the following position function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Write functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: for the corresponding velocity and acceleration functions by taking an analytic
    derivative of the position function.
  prefs: []
  type: TYPE_NORMAL
- en: The `undefined` function can be used as a placeholder for code not yet written.
    The compiler will accept `undefined` and happily compile the code, but if you
    try to use a function based on `undefined`, you will get a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Write functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: for the corresponding velocity and acceleration functions by taking a numerical
    derivative of the position function using `derivative 0.01`. Can you find any
    values of `t` where `vel1Analytic t` and `vel1Numerical t` differ substantially?
    Can you find any values of `t` where `acc1Analytic t` and `acc1Numerical t` differ
    substantially?
  prefs: []
  type: TYPE_NORMAL
