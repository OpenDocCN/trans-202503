- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling Built-in MySQL Functions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: MySQL has hundreds of prewritten functions that perform a variety of tasks.
    In this chapter, you’ll review some common functions and learn how to call them
    from your queries. You’ll work with aggregate functions, which return a single
    value summary based on many rows of data in the database, and functions that help
    perform mathematical calculations, process strings, deal with dates, and much
    more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](c11.xhtml), you’ll learn to create your own functions, but for
    now you’ll focus on calling MySQL’s most useful built-in functions. For an up-to-date
    list of all the built-in functions, the best source is the MySQL reference manual.
    Search online for “MySQL built-in function and operator reference,” and bookmark
    the web page in your browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Function?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *function* is a set of saved SQL statements that performs some task and returns
    a value. For example, the `pi()` function determines the value of pi and returns
    it. Here’s a simple query that calls the `pi()` function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the queries you’ve seen thus far include a `from` clause that specifies
    which table to use. In this query, you aren’t selecting from any table, so you
    can call the function without `from`. It returns the following result:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For common tasks such as this, it makes more sense to use MySQL’s built-in function
    rather than having to remember the value every time you need it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments to a Function
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you just saw, functions return a value. Some functions also let you pass
    values to them. When you call the function, you can specify a value that it should
    use. The values you pass to a function are called *arguments*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how arguments work, you’ll call the `upper()` function, which allows
    you to accept one argument: a string value. The function determines what the uppercase
    equivalent of that string is and returns it. The following query calls `upper()`
    and specifies an argument of the text `rofl`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function translated each letter to uppercase and returned `ROFL`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'In some functions, you can specify more than one argument. For example, `datediff()`
    allows you to specify two dates as arguments and then returns the difference in
    days between them. Here you call `datediff()` to find out how many days there
    are between Christmas and Thanksgiving in 2024:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you called the `datediff()` function, you specified two arguments, the
    date of Christmas and the date of Thanksgiving, and separated them by commas.
    The function calculated the difference in days and returned that value (`27`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Functions accept different numbers and types of values. For example, `upper()`
    accepts one string value, while `datediff()` accepts two `date` values. As you’ll
    see in this chapter, other functions accept values that are an integer, a boolean,
    or another data type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Optional Arguments
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some functions accept an optional argument, in which you can supply another
    value for a more specific result when you call the function. The `round()` function,
    for example, which rounds decimal numbers, accepts one argument that must be provided
    and a second argument that is optional. If you call `round()` with the number
    you want rounded as the only argument, it will round the number to zero places.
    Try calling the `round()` function with one argument of `2.71828`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数接受一个可选参数，在调用函数时，你可以提供另一个值来获取更具体的结果。例如，`round()`函数，它用于四舍五入小数，接受一个必须提供的参数和一个可选的第二个参数。如果你只传入一个要四舍五入的数字作为唯一参数，它会将数字四舍五入到零位。尝试使用`2.71828`作为唯一参数调用`round()`函数：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `round()` function returns your rounded number with zero digits after the
    decimal point, which also removes the decimal point itself:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`round()`函数将返回四舍五入后的数字，去掉小数点后的位数：'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you supply `round()` with its optional argument, you can specify how many
    places after the decimal point you want it to round. Try calling `round()` with
    a first argument of `2.71828` and a second argument of `2`, separating the arguments
    with a comma:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为`round()`提供了可选参数，你可以指定四舍五入小数点后保留的位数。尝试使用`2.71828`作为第一个参数，`2`作为第二个参数，并用逗号分隔参数调用`round()`：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now the result is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果是：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time, `round()` returns a rounded number with two digits after the decimal
    point.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`round()`返回一个四舍五入到小数点后两位的数字。
- en: Calling Functions Within Functions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数内调用函数
- en: You can use the results of one function in a call to another function by wrapping,
    or nesting, functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过包装或嵌套函数来将一个函数的结果用作另一个函数的参数。
- en: 'Say you want to get the rounded value of pi. You can wrap your call to the
    `pi()` function within a call to the `round()` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想获取 pi 的四舍五入值。你可以将对`pi()`函数的调用包装在对`round()`函数的调用中：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The innermost function gets executed first and the results are passed to the
    outer function. The call to the `pi()` function returns `3.141593`, and that value
    is passed as an argument to the `round()` function, which returns `3`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最内层的函数首先执行，结果传递给外层函数。对`pi()`函数的调用返回`3.141593`，该值作为参数传递给`round()`函数，`round()`返回`3`。
- en: 'You can modify your query and round pi to two digits by specifying a value
    in the `round()` function’s optional second argument, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改查询，通过指定`round()`函数可选的第二个参数，将 pi 四舍五入到两位小数，如下所示：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This call to the `pi()` function returns `3.141593`, which is passed to `round()`
    as the function’s first argument. The statement evaluates to `round(3.141593,2)`,
    which returns `3.14`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对`pi()`函数的调用返回`3.141593`，这个值作为函数的第一个参数传递给`round()`。这个语句的计算为`round(3.141593,2)`，返回`3.14`。
- en: Calling Functions from Different Parts of Your Query
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从查询的不同部分调用函数
- en: 'You can call functions in the `select` list of your query and also in the `where`
    clause. For example, take a look at the `movie` table, which contains the following
    data about movies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在查询的`select`列表中调用函数，也可以在`where`子句中调用。例如，看看`movie`表，它包含以下关于电影的数据：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `star_rating` column holds the average number of stars that viewers rated
    the movie on a scale of 1 to 5\. You’ve been asked to write a query to display
    movies that have more than 3 stars and a release date in 2024\. You also need
    to display the movie name in uppercase and round the star rating:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`star_rating`列保存了观众给电影打的平均星级，评分范围是1到5。你被要求写一个查询，显示评分超过3星且发布年份为2024年的电影。你还需要将电影名称转换为大写并四舍五入星级评分：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, you use the `upper()` and `round()` functions in the `select` list of
    the query. You wrap the movie name values in the `upper()` function and wrap the
    star rating value in the `round()` function. You then specify that you’re pulling
    data from the `movie` table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在查询的`select`列表中，你使用`upper()`和`round()`函数。你将电影名称值包裹在`upper()`函数中，并将星级评分值包裹在`round()`函数中。然后你指定从`movie`表中提取数据。
- en: 'In the `where` clause, you call the `year()` function and specify one argument:
    the `release_date` from the `movie` table. The `year()` function returns the year
    of the movie’s release, which you compare (`=`) to `2024` to display only movies
    with a release date in 2024.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`where`子句中，你调用`year()`函数并指定一个参数：`movie`表中的`release_date`。`year()`函数返回电影的发布年份，你将其与`2024`进行比较（`=`），从而只显示发布年份为2024年的电影。
- en: 'The results are:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Aggregate Functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合函数
- en: 'An *aggregate* function is a type of function that returns a single value based
    on multiple values in the database. Common aggregate functions include `count()`,
    `max()`, `min()`, `sum()`, and `avg()`. In this section, you’ll see how to call
    these functions with the following `continent` table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合*函数是一种基于数据库中多个值返回单一值的函数类型。常见的聚合函数包括`count()`、`max()`、`min()`、`sum()`和`avg()`。在本节中，你将看到如何使用以下`continent`表来调用这些函数：'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: count()
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: count()
- en: The `count()` function returns the number of rows returned from a query, and
    can help answer questions about your data like “How many customers do you have?”
    or “How many complaints did you get this year?”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`函数返回查询结果中的行数，可以帮助回答有关数据的问题，例如“你有多少顾客？”或“你今年收到了多少投诉？”'
- en: 'You can use the `count()` function to determine how many rows are in the `continent`
    table, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`count()`函数来确定`continent`表中有多少行，像这样：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you call the `count()` function, you use an asterisk (or a wildcard) between
    the parentheses to count all rows. The asterisk selects all rows from a table,
    including all of each row’s column values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`count()`函数时，你在括号中使用星号（或通配符）来计算所有行。星号选择表中的所有行，包括每行的所有列值。
- en: 'The result is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use a `where` clause to select all continents with a population of more than
    1 billion:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`where`子句选择所有人口超过10亿的大陆：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The query returns `2` because only two continents, Asia and Africa, have more
    than 1 billion people.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回`2`，因为只有亚洲和非洲这两个大陆的人口超过了10亿。
- en: max()
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: max()
- en: The `max()` function returns the maximum value in a set of values, and can help
    answer questions like “What was the highest yearly inflation rate?” or “Which
    salesperson sold the most cars this month?”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`函数返回一组值中的最大值，可以帮助回答诸如“最高的年度通货膨胀率是多少？”或“哪个销售员本月卖出了最多的车？”等问题。'
- en: 'Here you use the `max()` function to find the maximum population for any continent
    in the table:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用`max()`函数来查找表中任何大陆的最大人口：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you call the `max()` function, it returns the number of people who live
    in the most populated continent. The row in the table with the highest population
    for any continent is Asia, with a population of 4,641,054,775.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`max()`函数时，它返回人口最多的大陆的居民数。表中人口最多的大陆是亚洲，人口为4,641,054,775。
- en: 'Aggregate functions like `max()` can be particularly useful in subqueries.
    Step away from the `continent` table for a moment, and turn your attention to
    the `train` table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像`max()`这样的聚合函数在子查询中尤其有用。暂时离开`continent`表，将注意力转向`train`表：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here you’ll use `max()` to help determine which train in the `train` table
    has traveled the most miles:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你将使用`max()`来帮助确定`train`表中行驶里程最多的火车：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the inner query, you select the maximum number of miles that any train in
    your table has traveled. In the outer query, you display all the columns for trains
    that have traveled that number of miles.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部查询中，你选择表中任何火车所行驶的最大里程数。在外部查询中，你显示所有行驶了该里程数的火车的列。
- en: 'The result is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: min()
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: min()
- en: The `min()` function returns the minimum value in a set of values, and can help
    answer questions such as “What is the cheapest price for gas in town?” or “Which
    metal has the lowest melting point?”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`函数返回一组值中的最小值，可以帮助回答诸如“市区汽油的最低价格是多少？”或“哪种金属的熔点最低？”等问题。'
- en: 'Let’s return to the `continent` table. Use the `min()` function to find the
    population of the least populated continent:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`continent`表。使用`min()`函数来查找人口最少的大陆：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you call the `min()` function, it returns the minimum population value
    in the table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`min()`函数时，它返回表中的最小人口值：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The row in the table with the lowest population is Antarctica, with `0`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表中人口最少的行是南极洲，人口为`0`。
- en: sum()
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sum()
- en: The `sum()` function calculates the sum of a set of numbers, and helps answer
    questions like “How many bikes are there in China?” or “What were your total sales
    this year?”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数计算一组数字的总和，并帮助回答诸如“中国有多少辆自行车？”或“你今年的总销售额是多少？”等问题。'
- en: 'Use the `sum()` function to get the total population of all the continents,
    like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sum()`函数来计算所有大陆的总人口，像这样：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you call the `sum()` function, it returns the sum total of the population
    for every continent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`sum()`函数时，它返回所有大陆人口的总和。
- en: 'The result is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: avg()
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: avg()
- en: The `avg()` function returns the average value based on a set of numbers, and
    can help answer questions including “What is the average amount of snow in Wisconsin?”
    or “What is the average salary for a doctor?”
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `avg()` function to find the average population of the continents:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you call the `avg()` function, it returns the average population value
    of the continents in the table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: MySQL arrives at 1,113,604,661.4286 by totaling the population of every continent
    (7,795,232,630) and dividing that result by the number of continents (7).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the `avg()` function in a subquery to display all continents that
    are less populated than the average continent:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The inner query selects the average population size for all of continents:
    1,113,604,661.4286 people. The outer query selects all columns from the `continent`
    table for continents with populations less than that value.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: group by
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `group by` clause tells MySQL how you want your results grouped, and can
    be used only in queries with aggregate functions. To see how `group by` works,
    take a look at the `sale` table, which stores a company’s sales:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can use the `sum()` aggregate function to add the sales amounts, but do
    you want to calculate one grand total for all sales, sum the amounts by customer,
    sum the amounts by salesperson, or calculate the totals that each salesperson
    sold to each customer?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: To display amounts summed by customer, you `group by` the `customer_name` column,
    as in [Listing 8-1](#listing8-1).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 8-1: A query to sum amounts by customer'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The sum total of the amount spent by customer Bill McKenna is $39.60; for Carlos
    Souza, it’s $28.28; and for Jane Bird, it’s $34.44\. The results are ordered alphabetically
    by the customer’s first name.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may want to see sum totals of the amounts by salesperson.
    [Listing 8-2](#listing8-2) shows you how to use `group by` on the `salesperson_name`
    column.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 8-2: A query to sum amounts by salesperson'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Your results are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The total amount sold by Sally is $58.16, and for Tom it’s $44.16.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Because `sum()` is an aggregate function, it can operate on any number of rows
    and will return one value. The `group by` statement tells MySQL which rows you
    want `sum()` to operate on, so the syntax `group by salesperson_name` sums up
    the amounts for each salesperson.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Now say that you want to see just one row with a sum of every `amount` in the
    table. In this case, you don’t need to use `group by`, since you aren’t summing
    up by any group. Your query should look like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result should be:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `group by` clause works with all aggregate functions. For example, you could
    use `group by` with `count()` to return the count of sales for each salesperson,
    as in [Listing 8-3](#listing8-3).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 8-3: A query to count rows for each salesperson'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The query counted three rows in the `sales` table for Sally and two rows for
    Tom.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Or you can use `avg()` to get the average sale amount and group by `salesperson_name`
    to return the average sale amount per salesperson, as shown in [Listing 8-4](#listing8-4).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 8-4: A query to get the average amount sold by each salesperson'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The results show that the average amount of each sale for Sally was $19.386667,
    and the average amount of each sale for Tom was $22.08.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When looking at these results, however, it’s not immediately clear which salesperson’s
    average was $19.386667 and which salesperson’s was $22.08\. To clarify that, let’s
    modify the query to display more information in the result set. In [Listing 8-5](#listing8-5),
    you select the salesperson’s name as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 8-5: A query to display the salesperson’s name and their average amount
    sold'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of your modified query are:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Your averages appear with the same values, but now the salesperson’s name appears
    next to them. Adding this extra information makes your results much easier to
    understand.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve written several queries that use aggregate functions and `group
    by`, you might notice that you usually group by the same columns that you selected
    in the query. For example, in [Listing 8-5](#listing8-5), you selected the `salesperson_name`
    column and also grouped by the `salesperson_name` column.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To help you determine which column(s) to group by, look at the *select list*,
    or the part of the query between the words `select` and `from`. The select list
    contains the items you want to select from the database table; you almost always
    want to group by this same list. The only part of the select list that shouldn’t
    be part of the `group by` statement are the aggregate functions called.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at this `theme_park` table, which contains data from
    six different theme parks, including their country, state, and the city where
    they are located:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Say you want to select the country, state, and the number of parks for those
    countries and states. You might start to write your SQL statement like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This query is incomplete, however, and running it will return an error message
    or incorrect results, depending on your configuration settings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'You should group by everything you’ve selected *that is not an aggregate function*.
    In this query, the columns you’ve selected, `country` and `state`, are not aggregate
    functions, so you will use `group by` with them:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The results are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, the query now returns the correct results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: String Functions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides several functions to help you work with character strings and
    perform tasks such as comparing, formatting, and combining strings. Let’s take
    a look at the most useful string functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: concat()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `concat()` function *concatenates*, or joins, two or more strings together.
    For example, say you have the following `phone_book` table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can write a query to display first and last names together, separated by
    a space character:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The results should be as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The names appear as one string, separated by a space.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 名字作为一个字符串显示，以空格分隔。
- en: format()
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: format()
- en: 'The `format()` function formats a number by adding commas and showing the requested
    number of decimal points. For example, let’s revisit the `continent` table and
    select the population of Asia as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 函数通过添加逗号和显示所请求的小数位数来格式化数字。例如，我们重新访问 `continent` 表并选择亚洲人口，如下所示：'
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result is:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It’s difficult to tell whether the population of Asia is about 4.6 billion
    or 464,000,000\. To make the results more readable, you can format the `population`
    column with commas using the `format()` function like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 很难判断亚洲人口是约46亿人还是4.64亿人。为了使结果更易读，你可以使用 `format()` 函数为 `population` 列添加逗号格式，如下所示：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `format()` function takes two arguments: a number to format and the number
    of positions to show after the decimal point. You called `format()` with two arguments:
    the `population` column and the number `0`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 函数接受两个参数：一个数字来格式化和显示小数点后位数的数量。你使用了两个参数调用 `format()`：`population`
    列和数字 `0`。'
- en: 'Now that the `population` column has been formatted with commas, it’s clear
    in the result that Asia has around 4.6 billion people:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `population` 列已经用逗号格式化，结果中清楚地显示亚洲大约有46亿人口：
- en: '[PRE58]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now call the `format()` function to format the number 1234567.89 with five
    digits after the decimal point:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用 `format()` 函数将数字 1234567.89 格式化为小数点后五位：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `format()` function accepts `1234567.89` as the number to be formatted in
    the first argument, adds commas, and add trailing zeros so that the result is
    displayed with five decimal positions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 函数接受 `1234567.89` 作为第一个参数中的数字进行格式化，添加逗号，并且添加尾随零，使得结果显示五位小数。'
- en: left()
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: left()
- en: 'The `left()` function returns some number of characters from the left side
    of a value. Consider the following `taxpayer` table:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`left()` 函数从值的左侧返回若干字符。考虑以下 `taxpayer` 表：'
- en: '[PRE61]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To select last names from the `taxpayer` table, and also select the first three
    characters of the `last_name` column, you can write the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `taxpayer` 表中选择姓氏，并且还要选择 `last_name` 列的前三个字符，你可以写如下查询：
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The result is:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `left()` function is helpful in cases when you want to disregard the characters
    on the right.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`left()` 函数在你想忽略右侧字符的情况下非常有用。'
- en: right()
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: right()
- en: 'The `right()` function returns some number of characters from the right side
    of a value. Continue using the `taxpayer` table to select the last four digits
    of the taxpayers’ Social Security numbers:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`right()` 函数从值的右侧返回若干字符。继续使用 `taxpayer` 表选择税务员社会安全号码的最后四位数字：'
- en: '[PRE64]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The result is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE65]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `right()` function selects the rightmost characters without the characters
    on the left.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`right()` 函数选择最右边的字符，忽略左边的字符。'
- en: lower()
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lower()
- en: 'The `lower()` function returns the lowercase version of a string. Select the
    taxpayers’ last names in lowercase:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()` 函数返回字符串的小写版本。选择税务员的姓氏并将其转换为小写：'
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE67]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: upper()
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: upper()
- en: 'The `upper()` function returns the uppercase version of a string. Select the
    taxpayers’ last names in uppercase:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()` 函数返回字符串的大写版本。选择税务员的姓氏并将其转换为大写：'
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The result is:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE69]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: substring()
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: substring()
- en: 'The `substring()` function returns part of a string and takes three arguments:
    a string, the starting character position of the substring you want, and the ending
    character position of the substring you want.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 函数返回字符串的一部分，接受三个参数：一个字符串、你想要的子字符串的起始字符位置和结束字符位置。'
- en: 'You can extract the substring `gum` from the string `gumbo` by using this query:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下查询从字符串 `gumbo` 中提取子字符串 `gum`：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The result is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE71]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In `gumbo`, `g` is the first character, `u` is the second character, and `m`
    is the third. Selecting a substring starting at character 1 and going to character
    3 returns those first three characters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gumbo` 中，`g` 是第一个字符，`u` 是第二个字符，`m` 是第三个字符。从第1个字符开始，选择到第3个字符，会返回这前三个字符。
- en: 'The second argument to the `substring()` function can accept a negative number.
    If you pass a negative number to it, the beginning position of your substring
    will be calculated by counting backward from the end of the string. For example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 函数的第二个参数可以接受负数。如果你传递负数，它会从字符串的末尾向回计数来确定子字符串的起始位置。例如：'
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The result is:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE73]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The string `gumbo` has five characters. You asked `substring()` to start your
    substring at the end of the string minus three character positions, which is position
    3\. Your third argument was 2, so your substring will start at the third character
    3 and go for two characters, yielding the `mb` substring.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument to the `substring()` function is optional. You can provide
    just the first two arguments—a string and the starting character position—to return
    the set of characters between the starting position until the end of the string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The result is:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `substring()` function returned all the characters starting at the third
    character of the string `MySQL`, going all the way to the end of the string, resulting
    in `SQL`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL provides an alternate syntax for `substring()` that uses the `from` and
    `for` keywords. For example, to select the first three characters of the word
    `gumbo`, use the following syntax:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This substring starts at the first character and continues for three characters.
    The result is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This result is the same as the first substring example you saw, but you might
    find this syntax easier to read.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: trim()
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `trim()` function strips any number of leading or trailing characters from
    a string. You can specify the characters you want removed, as well as whether
    you want the leading characters removed, the trailing characters removed, or both.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have the string `**instructions**`, you could use `trim()`
    to return the string with the asterisks removed like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In `column1`, you trim the `leading` asterisks. In `column2`, you trim the `trailing`
    asterisks. In `column3`, you trim `both` the leading and trailing asterisks. When
    you don’t specify `leading`, `trailing`, or `both`, as in `column4`, MySQL defaults
    to trimming both.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'By default, `trim()` removes space characters. This means that if you have
    space characters around a string, you can use `trim()` without having to specify
    the character you want to strip:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The result is the string `asteroid` with no spaces on either side:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `trim()` function removes spaces from both sides of a string by default.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: ltrim()
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ltrim()` function removes leading spaces from the left side of a string:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result is the string `asteroid` with no spaces on the left side of it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The spaces to the right are unaffected.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: rtrim()
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rtrim()` function removes trailing spaces from the right side of a string:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The result is the string `asteroid` with no spaces on the right side of it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The spaces to the left are unaffected.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time Functions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides date-related functions that help you perform tasks like getting
    the current date and time, selecting a part of the date, and calculating how many
    days there are between two dates.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 4](c04.xhtml), MySQL provides the `date`, `time`, and
    `datetime` data types, where `date` contains a month, day, and year; `time` contains
    hours, minutes, and seconds; and `datetime` has all of those parts because it
    comprises both a date and a time. These are the formats MySQL uses to return many
    of the results of the functions you’ll see here.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: curdate()
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `curdate()` function returns the current date in the `date` format:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Your result should look similar to the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Both `current_date()` and `current_date` are synonyms for `curdate()` and will
    produce identical results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: curtime()
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `curtime()` function returns the current time in the `time` format:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Your result should look similar to the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: For me, the current time is 9:02 AM and 41 seconds. Both `current_time()` and
    `current_time` are synonyms for `curtime()` and will produce identical results.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: now()
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `now()` function returns the current date and time in a `datetime` format:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Your results should look similar to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Both `current_timestamp()` and `current_timestamp` are synonyms for `now()`
    and will produce identical results.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: date_add()
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `date_add()` function adds some amount of time to a `date` value. To add
    (or subtract) from date values, you use an *interval*, a value that you can use
    to perform calculations on dates and times. With an interval, you can supply a
    number and a unit of time, like `5 day`, `4 hour`, or `2 week`. Consider the following
    table called `event`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To select the `eclipse_datetime` date from the `event` table and add 5 days,
    4 hours, and 2 weeks to the date, you use `date_add()` with `interval` as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Your results should look similar to this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The results show that the intervals of 5 days, 4 hours, and 2 weeks were added
    to the eclipse date and time and have been listed in the columns you specified.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: date_sub()
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `date_sub()` function subtracts a time interval from a `date` value. For
    example, here you subtract the same time intervals in the previous example from
    the `eclipse_datetime` column of the `event` table:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The results are:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The results show that the intervals of 5 days, 4 hours, and 2 weeks were subtracted
    from the eclipse date and time and have been listed in the columns you specified.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: extract()
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extract()` function pulls out specified parts of a `date` or a `datetime`
    value. It uses the same units of time as `date_add()` and `date_sub()`, like `day`,
    `hour`, and `week`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you select some parts of your `eclipse_datetime` column:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `extract()` function takes the `eclipse_datetime` value from the `event`
    table and displays the individual parts requested by the column names you specify.
    The results are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'MySQL provides other functions you can use for the same purpose as `extract()`,
    including `year()`, `month()`, `day()`, `week()`, `hour()`, `minute()`, and `second()`.
    This query achieves the same result as the preceding one:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can also use the `date()` and `time()` functions to select just the `date`
    or `time` portion of a `datetime` value:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The results are:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As you can see, the `date()` and `time()` functions provide a quick way to extract
    just the date or the time from a `datetime` value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: datediff()
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `datediff()` function returns the number of days between two dates. Say
    you want to check how many days there are between New Year’s Day and Cinco de
    Mayo in 2024:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The result is 125 days:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: If the date argument on the left is more recent than the date argument on the
    right, `datediff()` will return a positive number. If the date on the right is
    more recent, `datediff()` will return a negative number. If the two dates are
    the same, `0` will be returned.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: date_format()
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `date_format()` function formats a date according to a format string that
    you specify. The format string is made up of characters that you add and *specifiers*
    that start with a percent sign. The most common specifiers are listed in [Table
    8-1](#table8-1).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Common Specifiers'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `%a` | Abbreviated weekday name (`Sun`–`Sat`) |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| `%b` | Abbreviated month name (`Jan`–`Dec`) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Month, numeric (`1`–`12`) |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Day of the month with suffix (`1st`, `2nd`, `3rd`, . . .) |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Day of the month, two digits with a leading zero where applicable
    (`01`–`31`) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| `%e` | Day of the month (`1`–`31`) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Hour with leading zero where applicable (`00`–`23`) |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `%h` | Hour (`01`–`12`) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `%i` | Minutes (`00`–`59`) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `%k` | Hour (`0`–`23`) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `%l` | Hour (`1`–`12`) |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Month name (`January`–`December`) |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Month (`00`–`12`) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `%p` | `AM` or `PM` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `%r` | Time, 12-hour (`hh:mm:ss` followed by `AM` or `PM`) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Seconds (`00`–`59`) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| `%T` | Time, 24-hour (`hh:mm:ss`) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Weekday name (`Sunday`–`Saturday`) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Day of the week (`0` = Sunday – `6` = Saturday) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Year, four digits |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| `%y` | Year, two digits |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: 'The datetime `2024-02-02 01:02:03` represents February 2, 2024, at 1:02 AM
    and 3 seconds. Try experimenting with some different formats for that `datetime`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The result is:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The column you aliased as `format6` shows how the format specifiers can be combined.
    In that format string, you added a comma and the word `at` in addition to four
    specifiers for the date and time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: str_to_date()
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `str_to_date()` function converts a string value to a date based on the
    format you provide. You use the same specifiers that you used for `date_format()`,
    but the two functions take opposite actions: `date_format()` converts a date to
    a string, while `str_to_date()` converts a string to a date.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the format you provide, `str_to_date()` can convert a string
    to a `date`, a `time`, or a `datetime`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The result is:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The last column, `time_format`, can also be converted with the function of the
    same name. We’ll look at it next.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: time_format()
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name implies, the `time_format()` function formats time. You can use
    the same specifiers as `date_format()` for `time_format()`. For example, here’s
    how to get the current time and format it in some different ways:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Expressed in military time, the current time for me is `21:09:55`, which is
    9:09 PM and 55 seconds. Your results should look similar to the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The column you aliased as `format2` shows the hour with a leading `0` because
    you used the `%H` specifier, but the `format3` column does not because you used
    the `%h` specifier. In columns 1–3, you added colon characters to the format string.
    In `format4` you added the word `hours`, a comma, the word `minutes`, the word
    `and`, and the word `seconds`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators and Functions
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides many functions to perform calculations. There are also arithmetic
    operators available, like `+` for addition, `-` for subtraction, `*` for multiplication,
    `/` and `div` for division, and `%` and `mod` for modulo. You’ll start reviewing
    some queries that use these operators, and then you’ll use parentheses to control
    the order of operations. Afterward, you’ll use mathematical functions to perform
    various tasks, including raising a number to a power, calculating standard deviation,
    and rounding and truncating numbers.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll start by performing some mathematical calculations using the data from
    the `payroll` table:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Try out some of the arithmetic operators as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this example, you use mathematical operators to get the employee’s salary
    minus their deductions, add their bonus to their salary, multiply their salary
    by their tax rate, and see their monthly salary by dividing their annual salary
    by 12, respectively.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Notice that in the two columns on the right, `salary / 12` and `salary div 12`,
    you received different results when using the `/` and the `div` operators. This
    is because `div` discards any fractional amount and `/` does not.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Modulo
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MySQL provides two operators for modulo: the percent sign (`%`) and the `mod`
    operator. *Modulo* takes one number, divides it by another, and returns the remainder.
    Consider a table called `roulette_winning_number`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'You can use modulo to determine if a number is odd or even by dividing it by
    2 and checking the remainder, like so:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Anything with a remainder of 1 is an odd number. The results are as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The results show `1` for odd numbers and `0` for even numbers. In the first
    row, `21 % 2` evaluates to `1` because 21 divided by 2 is 10 with a remainder
    of 1.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `mod` or `%` produces the same results. Modulo is also available as the
    `mod()` function. All of these queries return the same results:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Operator Precedence
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When there is more than one arithmetic operator used in a mathematical expression,
    `*`, `/`, `div`, `%`, and `mod` are evaluated first; `+` and `-` are evaluated
    last. This is called *operator precedence*. The following query (which uses the
    `payroll` table) was written to calculate the taxes employees will pay based on
    their salary, bonus, and tax rate, but the query is returning the wrong tax amount:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The results are:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The column on the right should represent the amount of taxes the employees have
    to pay, but it seems to be too high. If Max Bain’s salary is $80,000 and his bonus
    is $10,000, it doesn’t seem reasonable that he would be required to pay $82,400
    in taxes.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The query is returning the wrong value because you expected MySQL to add `salary`
    and `bonus` first, and then multiply the result by the `tax_rate`. Instead, MySQL
    multiplied `bonus` by `tax_rate` first and then added the `salary`. The multiplication
    happened first because multiplication has a higher operator precedence than addition.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct the problem, use parentheses to tell MySQL to consider `salary +`
    `bonus` as a group:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The results are:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Now the query returns $21,600 for Max Bain, which is the correct value. You
    should use parentheses frequently when performing calculations—not only because
    it gives you control over the order of operations, but also because it makes your
    SQL easier to read and understand.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Functions
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL provides many mathematical functions that can help with tasks like rounding
    numbers, getting the absolute value of a number, and dealing with exponents, as
    well as finding cosines, logarithms, and radians.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: abs()
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `abs()` function gets the absolute value of a number. The absolute value
    of a number is always positive. For example, the absolute value of 5 is 5, and
    the absolute value of –5 is 5.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you had a contest to guess the number of jelly beans in a jar. Write a
    query to see whose guess was closest to the actual number, 300:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here you’ve selected the guesser’s name and their guess from the `jelly_bean`
    table. You select `300` and alias the column as `actual` so it will appear in
    your results with that heading. Then you subtract the guess from 300 and alias
    that column as `difference`. The results are:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `difference` column shows how far off the guesses were from the actual value
    of 300, but the results are a bit hard to interpret. When the guess was higher
    than the actual amount of 300, your `difference` column appears as a negative
    number. When the guess was lower than the actual amount, your `difference` column
    appears as a positive number. For your contest, you don’t care whether the guess
    was higher or lower than 300, you only care about which guess was closest to 300.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `abs()` function to remove the negative numbers from the difference
    column:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The results are:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now you can easily see that Ike won your contest because his value in the `difference`
    column is the smallest.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: ceiling()
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ceiling()` function returns the smallest whole number that is greater
    than or equal to the argument. If you pay $3.29 for gas, and you want to round
    that number up to the next whole dollar amount, you’d write the following query:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The result is:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `ceiling()` function has a synonym, `ceil()`, that produces identical results.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: floor()
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `floor()` function returns the largest whole number that is less than or
    equal to the argument. To round $3.29 down to the next lowest whole dollar amount,
    you’d write the following query:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The result is:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: If the argument is already a whole number, then that number will be returned
    in both the `ceiling()` and `floor()` functions. For example, `ceiling(33)` and
    `floor(33)` both return `33`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: pi()
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `pi()` function returns the value of pi, as seen at the beginning of this
    chapter.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: degrees()
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `degrees()` function converts radians to degrees. You can convert pi to
    degrees using this query:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The result is:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: You got your answer by wrapping the `pi()` function in the `degrees()` function.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: radians()
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `radians()` function converts degrees to radians. You can convert 180 to
    radians using this query:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Your results are:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The function was sent an argument of `180` and returned a value of pi.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: exp()
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `exp()` function returns the natural logarithm base number *e* raised to
    the power of the number you provide as an argument (2, in this example):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The result is:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The function returned `7.38905609893065`, which is *e* (2.718281828459) squared.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: log()
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `log()` function returns the natural logarithm of the number you provide
    as an argument:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The result is:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: MySQL also provides the `log10()` function, which returns the base-10 logarithm,
    and `log2()`, which returns the base-2 logarithm.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log()` function can accept two arguments: the base of a number, then the
    number itself. For example, to find the log[2](8), enter the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The result is:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The function was sent two arguments, `2` and `8`, and returned a value of `3`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: mod()
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `mod()` function, as you saw earlier, is the modulo function. It takes one
    number, divides it by another, and returns the remainder.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The result is:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The `mod(7,2)` function evaluates to `1` because 7 divided by 2 is 3 with a
    remainder of 1\. Modulo is also available as the `%` operator and the `mod` operator.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: pow()
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pow()` function returns a number raised to a power. To raise 5 to the
    power of 3, you could write this query:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The result is:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `pow()` function has a synonym, `power()`, that returns identical results.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: round()
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `round()` function, introduced earlier in the chapter, rounds decimal numbers.
    To round the number 9.87654321 to three digits after the decimal point, use the
    following query:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The result is:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'To round all of the fractional numbers, call `round()` with just one argument:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The result is:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Calling `round()` without the optional second argument causes it to default
    to 0 digits after the decimal point.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: truncate()
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `truncate()` function shortens a number to specified number of decimal
    places. To truncate the number 9.87654321 to three digits after the decimal point,
    use the following query:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The result is:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'To truncate all of the fractional numbers, call `truncate()` with `0` as the
    second argument:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The result is:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The `truncate()` function removes digits to convert the number to the requested
    number of digits after the decimal point. This differs from `round()`, which rounds
    numbers up or down before removing digits.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: sin()
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sin()` function returns the sine of a number given in radians. You can
    use this query to get the sine of 2:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The result is:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The function was sent an argument of `2` and returned a value of `0.9092974268256817`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: cos()
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `cos()` function returns the cosine of a number that is given in radians.
    Use the following query to get the cosine of 2:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The result is:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The function was sent an argument of `2` and returned a value of `-0.4161468365471424`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: sqrt()
  id: totrans-488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sqrt()` function returns the square root of a number. You can get the
    square root of 16like so:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The function was sent an argument of `16` and returned a value of `4`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: stddev_pop()
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `stddev_pop()` function returns the population standard deviation of the
    numbers provided. *Population standard deviation* is the standard deviation when
    all values of a dataset are taken into consideration. For example, look at the
    `test_score` table, which contains all of your test scores:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now write a query to get the population standard deviation of test scores:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The result is:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `std()` and `stddev()` functions are synonyms for `stddev_pop()` and will
    produce identical results.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: To get the standard deviation of a sample of values, rather than the entire
    population of a dataset, you can use `stddev_samp()` function.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: tan()
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `tan()` function accepts an argument in radians and returns the tangent.
    For example, you can get the tangent of 3.8 with the following query:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The result is:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The function was sent an argument of `3.8` and returned a value of `0.7735560905031258`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Other Handy Functions
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other useful functions include `cast()`, `coalesce()`, `distinct()`, `database()`,
    `if()`, and `version()`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: cast()
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cast()` function converts a value from one data type to a different data
    type. To call the `cast()` function, pass a value into `cast()` as the first argument,
    follow it with the `as` keyword, and then specify the data type you want to convert
    it to.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, select the `datetime` column `order_datetime` from the table called
    `online_order`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Your results show the following `datetime` values:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can select those values without their time portion by casting from a `datetime`
    data type to a `date` data type, like so:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Your results are:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The date part of the `datetime` now appears as a `date` value.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: coalesce()
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `coalesce()` function returns the first non-null value in a list. You could
    specify null values followed by a non-null value, and `coalesce()` would return
    the non-null value:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The result is:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The `coalesce()` function is also useful when you want to display a value in
    your result instead of `null`. For example, in the `candidate` table used in the
    following query, the `employer` column will sometimes store the candidate’s employer
    name, and other times that column will be `null`. In order to display the text
    `Between Jobs` instead of `null`, you’d enter the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The results are:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The query now displays `Between Jobs` rather than `null` for Jacob Davis, which
    is more informative, especially for nontechnical users who may not understand
    what `null` means.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: distinct()
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have duplicate values, you can use the `distinct()` function to display
    each value only once. For example, if you want to know which countries your customers
    are from, you could query the `customer` table like so:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The result is:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The query is returning the `country` column value for every row in the `customer`
    table. You can use the `distinct()` function to see each country in your result
    set just once:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now the result is:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `distinct()` function is also available as an operator. To use it, remove
    the parentheses like so:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The result set is identical:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The `distinct()` function is especially useful when combined with the `count()`
    function to find how many unique values you have. Here you write a query to count
    the number of distinct countries in your table:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The result is:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: You identified the distinct countries using the `distinct()` function and wrapped
    them in the `count()` function to get a count of them.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: database()
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `database()` function tells you which database you’re currently using.
    As you saw in [Chapter 2](c02.xhtml), the `use` command lets you select which
    database you want to use. Throughout your day, you might move between different
    databases and forget your current database. You can call the `database()` function
    like so:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The result is:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: If you’re not in the database you thought you were and you tried to query a
    table, MySQL would give an error saying the table doesn’t exist. Calling `database()`
    is a quick way to check.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: if()
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if()` function returns a different value depending upon whether a condition
    is `true` or `false`. The `if()` function accepts three arguments: the condition
    you want to test, the value to return if the condition is `true`, and the value
    to return if the condition is `false`.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a query that lists students and whether they passed or failed an
    exam. The `test_result` table contains the following data:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Your query to check if each student passed the exam should look similar to
    the following:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The condition you’re testing is whether the student’s `grade` is greater than
    `59`. If so, you return the text `pass`. If not, you return the text `fail`. The
    results are:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'MySQL also has a `case` operator that lets you perform more sophisticated logic
    than the `if()` function. The `case` operator lets you test more than one condition
    and returns the result for the first condition that is met. In the following query,
    you select the student name and add a comment to the student based on their grade:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The `case` operator uses a matching `end` keyword that marks the end of the
    `case` statement.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: For any students who received a grade less than 30, the `case` statement returns
    `Please retake this exam` and then control is passed to the `end` statement.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Students who received a grade of 30 or more aren’t handled by the first `when`
    condition of the `case` statement, so control drops to the next line.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: If a student received a grade of 30 or higher but less than 60, `Better luck
    next time` is returned and control passes to the `end` statement.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'If a student’s grade didn’t match either of the `when` conditions, meaning
    the student scored higher than 60, control drops to the `else` keyword, where
    `Good job` is returned. You use an `else` clause to capture any student grades
    that aren’t handled by the first two conditions. The results are:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Unlike the `if()` function—which returns a result if a condition is `true` or
    `false`—`case` lets you check several conditions and returns a result based on
    the first condition that is met.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: version()
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `version()` function returns the version of MySQL you are using:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The result is:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The version of MySQL installed on my server is 8.0.27\. Yours may be different.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you looked at how to call MySQL built-in functions and pass
    values, known as arguments, to those functions. You explored the most useful functions
    and saw how to locate the more obscure ones when necessary. In the next chapter,
    you’ll look at how to insert, update, and delete data from a MySQL database.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
