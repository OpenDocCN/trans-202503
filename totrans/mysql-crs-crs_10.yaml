- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling Built-in MySQL Functions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: MySQL has hundreds of prewritten functions that perform a variety of tasks.
    In this chapter, you’ll review some common functions and learn how to call them
    from your queries. You’ll work with aggregate functions, which return a single
    value summary based on many rows of data in the database, and functions that help
    perform mathematical calculations, process strings, deal with dates, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](c11.xhtml), you’ll learn to create your own functions, but for
    now you’ll focus on calling MySQL’s most useful built-in functions. For an up-to-date
    list of all the built-in functions, the best source is the MySQL reference manual.
    Search online for “MySQL built-in function and operator reference,” and bookmark
    the web page in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *function* is a set of saved SQL statements that performs some task and returns
    a value. For example, the `pi()` function determines the value of pi and returns
    it. Here’s a simple query that calls the `pi()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the queries you’ve seen thus far include a `from` clause that specifies
    which table to use. In this query, you aren’t selecting from any table, so you
    can call the function without `from`. It returns the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For common tasks such as this, it makes more sense to use MySQL’s built-in function
    rather than having to remember the value every time you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments to a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you just saw, functions return a value. Some functions also let you pass
    values to them. When you call the function, you can specify a value that it should
    use. The values you pass to a function are called *arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how arguments work, you’ll call the `upper()` function, which allows
    you to accept one argument: a string value. The function determines what the uppercase
    equivalent of that string is and returns it. The following query calls `upper()`
    and specifies an argument of the text `rofl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function translated each letter to uppercase and returned `ROFL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some functions, you can specify more than one argument. For example, `datediff()`
    allows you to specify two dates as arguments and then returns the difference in
    days between them. Here you call `datediff()` to find out how many days there
    are between Christmas and Thanksgiving in 2024:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you called the `datediff()` function, you specified two arguments, the
    date of Christmas and the date of Thanksgiving, and separated them by commas.
    The function calculated the difference in days and returned that value (`27`).
  prefs: []
  type: TYPE_NORMAL
- en: Functions accept different numbers and types of values. For example, `upper()`
    accepts one string value, while `datediff()` accepts two `date` values. As you’ll
    see in this chapter, other functions accept values that are an integer, a boolean,
    or another data type.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some functions accept an optional argument, in which you can supply another
    value for a more specific result when you call the function. The `round()` function,
    for example, which rounds decimal numbers, accepts one argument that must be provided
    and a second argument that is optional. If you call `round()` with the number
    you want rounded as the only argument, it will round the number to zero places.
    Try calling the `round()` function with one argument of `2.71828`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `round()` function returns your rounded number with zero digits after the
    decimal point, which also removes the decimal point itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you supply `round()` with its optional argument, you can specify how many
    places after the decimal point you want it to round. Try calling `round()` with
    a first argument of `2.71828` and a second argument of `2`, separating the arguments
    with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This time, `round()` returns a rounded number with two digits after the decimal
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions Within Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the results of one function in a call to another function by wrapping,
    or nesting, functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to get the rounded value of pi. You can wrap your call to the
    `pi()` function within a call to the `round()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The innermost function gets executed first and the results are passed to the
    outer function. The call to the `pi()` function returns `3.141593`, and that value
    is passed as an argument to the `round()` function, which returns `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify your query and round pi to two digits by specifying a value
    in the `round()` function’s optional second argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This call to the `pi()` function returns `3.141593`, which is passed to `round()`
    as the function’s first argument. The statement evaluates to `round(3.141593,2)`,
    which returns `3.14`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions from Different Parts of Your Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can call functions in the `select` list of your query and also in the `where`
    clause. For example, take a look at the `movie` table, which contains the following
    data about movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `star_rating` column holds the average number of stars that viewers rated
    the movie on a scale of 1 to 5\. You’ve been asked to write a query to display
    movies that have more than 3 stars and a release date in 2024\. You also need
    to display the movie name in uppercase and round the star rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, you use the `upper()` and `round()` functions in the `select` list of
    the query. You wrap the movie name values in the `upper()` function and wrap the
    star rating value in the `round()` function. You then specify that you’re pulling
    data from the `movie` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `where` clause, you call the `year()` function and specify one argument:
    the `release_date` from the `movie` table. The `year()` function returns the year
    of the movie’s release, which you compare (`=`) to `2024` to display only movies
    with a release date in 2024.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Aggregate Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *aggregate* function is a type of function that returns a single value based
    on multiple values in the database. Common aggregate functions include `count()`,
    `max()`, `min()`, `sum()`, and `avg()`. In this section, you’ll see how to call
    these functions with the following `continent` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: count()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `count()` function returns the number of rows returned from a query, and
    can help answer questions about your data like “How many customers do you have?”
    or “How many complaints did you get this year?”
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `count()` function to determine how many rows are in the `continent`
    table, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `count()` function, you use an asterisk (or a wildcard) between
    the parentheses to count all rows. The asterisk selects all rows from a table,
    including all of each row’s column values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `where` clause to select all continents with a population of more than
    1 billion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The query returns `2` because only two continents, Asia and Africa, have more
    than 1 billion people.
  prefs: []
  type: TYPE_NORMAL
- en: max()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `max()` function returns the maximum value in a set of values, and can help
    answer questions like “What was the highest yearly inflation rate?” or “Which
    salesperson sold the most cars this month?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you use the `max()` function to find the maximum population for any continent
    in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `max()` function, it returns the number of people who live
    in the most populated continent. The row in the table with the highest population
    for any continent is Asia, with a population of 4,641,054,775.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregate functions like `max()` can be particularly useful in subqueries.
    Step away from the `continent` table for a moment, and turn your attention to
    the `train` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you’ll use `max()` to help determine which train in the `train` table
    has traveled the most miles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the inner query, you select the maximum number of miles that any train in
    your table has traveled. In the outer query, you display all the columns for trains
    that have traveled that number of miles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: min()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `min()` function returns the minimum value in a set of values, and can help
    answer questions such as “What is the cheapest price for gas in town?” or “Which
    metal has the lowest melting point?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the `continent` table. Use the `min()` function to find the
    population of the least populated continent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call the `min()` function, it returns the minimum population value
    in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The row in the table with the lowest population is Antarctica, with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: sum()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sum()` function calculates the sum of a set of numbers, and helps answer
    questions like “How many bikes are there in China?” or “What were your total sales
    this year?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `sum()` function to get the total population of all the continents,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `sum()` function, it returns the sum total of the population
    for every continent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: avg()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `avg()` function returns the average value based on a set of numbers, and
    can help answer questions including “What is the average amount of snow in Wisconsin?”
    or “What is the average salary for a doctor?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `avg()` function to find the average population of the continents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call the `avg()` function, it returns the average population value
    of the continents in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: MySQL arrives at 1,113,604,661.4286 by totaling the population of every continent
    (7,795,232,630) and dividing that result by the number of continents (7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the `avg()` function in a subquery to display all continents that
    are less populated than the average continent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The inner query selects the average population size for all of continents:
    1,113,604,661.4286 people. The outer query selects all columns from the `continent`
    table for continents with populations less than that value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: group by
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `group by` clause tells MySQL how you want your results grouped, and can
    be used only in queries with aggregate functions. To see how `group by` works,
    take a look at the `sale` table, which stores a company’s sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `sum()` aggregate function to add the sales amounts, but do
    you want to calculate one grand total for all sales, sum the amounts by customer,
    sum the amounts by salesperson, or calculate the totals that each salesperson
    sold to each customer?
  prefs: []
  type: TYPE_NORMAL
- en: To display amounts summed by customer, you `group by` the `customer_name` column,
    as in [Listing 8-1](#listing8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: A query to sum amounts by customer'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The sum total of the amount spent by customer Bill McKenna is $39.60; for Carlos
    Souza, it’s $28.28; and for Jane Bird, it’s $34.44\. The results are ordered alphabetically
    by the customer’s first name.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may want to see sum totals of the amounts by salesperson.
    [Listing 8-2](#listing8-2) shows you how to use `group by` on the `salesperson_name`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: A query to sum amounts by salesperson'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The total amount sold by Sally is $58.16, and for Tom it’s $44.16.
  prefs: []
  type: TYPE_NORMAL
- en: Because `sum()` is an aggregate function, it can operate on any number of rows
    and will return one value. The `group by` statement tells MySQL which rows you
    want `sum()` to operate on, so the syntax `group by salesperson_name` sums up
    the amounts for each salesperson.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now say that you want to see just one row with a sum of every `amount` in the
    table. In this case, you don’t need to use `group by`, since you aren’t summing
    up by any group. Your query should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `group by` clause works with all aggregate functions. For example, you could
    use `group by` with `count()` to return the count of sales for each salesperson,
    as in [Listing 8-3](#listing8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: A query to count rows for each salesperson'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The query counted three rows in the `sales` table for Sally and two rows for
    Tom.
  prefs: []
  type: TYPE_NORMAL
- en: Or you can use `avg()` to get the average sale amount and group by `salesperson_name`
    to return the average sale amount per salesperson, as shown in [Listing 8-4](#listing8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: A query to get the average amount sold by each salesperson'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The results show that the average amount of each sale for Sally was $19.386667,
    and the average amount of each sale for Tom was $22.08.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at these results, however, it’s not immediately clear which salesperson’s
    average was $19.386667 and which salesperson’s was $22.08\. To clarify that, let’s
    modify the query to display more information in the result set. In [Listing 8-5](#listing8-5),
    you select the salesperson’s name as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: A query to display the salesperson’s name and their average amount
    sold'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of your modified query are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Your averages appear with the same values, but now the salesperson’s name appears
    next to them. Adding this extra information makes your results much easier to
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve written several queries that use aggregate functions and `group
    by`, you might notice that you usually group by the same columns that you selected
    in the query. For example, in [Listing 8-5](#listing8-5), you selected the `salesperson_name`
    column and also grouped by the `salesperson_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: To help you determine which column(s) to group by, look at the *select list*,
    or the part of the query between the words `select` and `from`. The select list
    contains the items you want to select from the database table; you almost always
    want to group by this same list. The only part of the select list that shouldn’t
    be part of the `group by` statement are the aggregate functions called.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at this `theme_park` table, which contains data from
    six different theme parks, including their country, state, and the city where
    they are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you want to select the country, state, and the number of parks for those
    countries and states. You might start to write your SQL statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This query is incomplete, however, and running it will return an error message
    or incorrect results, depending on your configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should group by everything you’ve selected *that is not an aggregate function*.
    In this query, the columns you’ve selected, `country` and `state`, are not aggregate
    functions, so you will use `group by` with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the query now returns the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: String Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides several functions to help you work with character strings and
    perform tasks such as comparing, formatting, and combining strings. Let’s take
    a look at the most useful string functions.
  prefs: []
  type: TYPE_NORMAL
- en: concat()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `concat()` function *concatenates*, or joins, two or more strings together.
    For example, say you have the following `phone_book` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write a query to display first and last names together, separated by
    a space character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The names appear as one string, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: format()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `format()` function formats a number by adding commas and showing the requested
    number of decimal points. For example, let’s revisit the `continent` table and
    select the population of Asia as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s difficult to tell whether the population of Asia is about 4.6 billion
    or 464,000,000\. To make the results more readable, you can format the `population`
    column with commas using the `format()` function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `format()` function takes two arguments: a number to format and the number
    of positions to show after the decimal point. You called `format()` with two arguments:
    the `population` column and the number `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `population` column has been formatted with commas, it’s clear
    in the result that Asia has around 4.6 billion people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now call the `format()` function to format the number 1234567.89 with five
    digits after the decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `format()` function accepts `1234567.89` as the number to be formatted in
    the first argument, adds commas, and add trailing zeros so that the result is
    displayed with five decimal positions.
  prefs: []
  type: TYPE_NORMAL
- en: left()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `left()` function returns some number of characters from the left side
    of a value. Consider the following `taxpayer` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To select last names from the `taxpayer` table, and also select the first three
    characters of the `last_name` column, you can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `left()` function is helpful in cases when you want to disregard the characters
    on the right.
  prefs: []
  type: TYPE_NORMAL
- en: right()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `right()` function returns some number of characters from the right side
    of a value. Continue using the `taxpayer` table to select the last four digits
    of the taxpayers’ Social Security numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `right()` function selects the rightmost characters without the characters
    on the left.
  prefs: []
  type: TYPE_NORMAL
- en: lower()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lower()` function returns the lowercase version of a string. Select the
    taxpayers’ last names in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: upper()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `upper()` function returns the uppercase version of a string. Select the
    taxpayers’ last names in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: substring()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `substring()` function returns part of a string and takes three arguments:
    a string, the starting character position of the substring you want, and the ending
    character position of the substring you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extract the substring `gum` from the string `gumbo` by using this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In `gumbo`, `g` is the first character, `u` is the second character, and `m`
    is the third. Selecting a substring starting at character 1 and going to character
    3 returns those first three characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument to the `substring()` function can accept a negative number.
    If you pass a negative number to it, the beginning position of your substring
    will be calculated by counting backward from the end of the string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The string `gumbo` has five characters. You asked `substring()` to start your
    substring at the end of the string minus three character positions, which is position
    3\. Your third argument was 2, so your substring will start at the third character
    3 and go for two characters, yielding the `mb` substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument to the `substring()` function is optional. You can provide
    just the first two arguments—a string and the starting character position—to return
    the set of characters between the starting position until the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `substring()` function returned all the characters starting at the third
    character of the string `MySQL`, going all the way to the end of the string, resulting
    in `SQL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL provides an alternate syntax for `substring()` that uses the `from` and
    `for` keywords. For example, to select the first three characters of the word
    `gumbo`, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This substring starts at the first character and continues for three characters.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This result is the same as the first substring example you saw, but you might
    find this syntax easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: trim()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `trim()` function strips any number of leading or trailing characters from
    a string. You can specify the characters you want removed, as well as whether
    you want the leading characters removed, the trailing characters removed, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have the string `**instructions**`, you could use `trim()`
    to return the string with the asterisks removed like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In `column1`, you trim the `leading` asterisks. In `column2`, you trim the `trailing`
    asterisks. In `column3`, you trim `both` the leading and trailing asterisks. When
    you don’t specify `leading`, `trailing`, or `both`, as in `column4`, MySQL defaults
    to trimming both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `trim()` removes space characters. This means that if you have
    space characters around a string, you can use `trim()` without having to specify
    the character you want to strip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the string `asteroid` with no spaces on either side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `trim()` function removes spaces from both sides of a string by default.
  prefs: []
  type: TYPE_NORMAL
- en: ltrim()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ltrim()` function removes leading spaces from the left side of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the string `asteroid` with no spaces on the left side of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The spaces to the right are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: rtrim()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rtrim()` function removes trailing spaces from the right side of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the string `asteroid` with no spaces on the right side of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The spaces to the left are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides date-related functions that help you perform tasks like getting
    the current date and time, selecting a part of the date, and calculating how many
    days there are between two dates.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 4](c04.xhtml), MySQL provides the `date`, `time`, and
    `datetime` data types, where `date` contains a month, day, and year; `time` contains
    hours, minutes, and seconds; and `datetime` has all of those parts because it
    comprises both a date and a time. These are the formats MySQL uses to return many
    of the results of the functions you’ll see here.
  prefs: []
  type: TYPE_NORMAL
- en: curdate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `curdate()` function returns the current date in the `date` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Your result should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Both `current_date()` and `current_date` are synonyms for `curdate()` and will
    produce identical results.
  prefs: []
  type: TYPE_NORMAL
- en: curtime()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `curtime()` function returns the current time in the `time` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Your result should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For me, the current time is 9:02 AM and 41 seconds. Both `current_time()` and
    `current_time` are synonyms for `curtime()` and will produce identical results.
  prefs: []
  type: TYPE_NORMAL
- en: now()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `now()` function returns the current date and time in a `datetime` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Your results should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Both `current_timestamp()` and `current_timestamp` are synonyms for `now()`
    and will produce identical results.
  prefs: []
  type: TYPE_NORMAL
- en: date_add()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `date_add()` function adds some amount of time to a `date` value. To add
    (or subtract) from date values, you use an *interval*, a value that you can use
    to perform calculations on dates and times. With an interval, you can supply a
    number and a unit of time, like `5 day`, `4 hour`, or `2 week`. Consider the following
    table called `event`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the `eclipse_datetime` date from the `event` table and add 5 days,
    4 hours, and 2 weeks to the date, you use `date_add()` with `interval` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Your results should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The results show that the intervals of 5 days, 4 hours, and 2 weeks were added
    to the eclipse date and time and have been listed in the columns you specified.
  prefs: []
  type: TYPE_NORMAL
- en: date_sub()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `date_sub()` function subtracts a time interval from a `date` value. For
    example, here you subtract the same time intervals in the previous example from
    the `eclipse_datetime` column of the `event` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The results show that the intervals of 5 days, 4 hours, and 2 weeks were subtracted
    from the eclipse date and time and have been listed in the columns you specified.
  prefs: []
  type: TYPE_NORMAL
- en: extract()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extract()` function pulls out specified parts of a `date` or a `datetime`
    value. It uses the same units of time as `date_add()` and `date_sub()`, like `day`,
    `hour`, and `week`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you select some parts of your `eclipse_datetime` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extract()` function takes the `eclipse_datetime` value from the `event`
    table and displays the individual parts requested by the column names you specify.
    The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL provides other functions you can use for the same purpose as `extract()`,
    including `year()`, `month()`, `day()`, `week()`, `hour()`, `minute()`, and `second()`.
    This query achieves the same result as the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `date()` and `time()` functions to select just the `date`
    or `time` portion of a `datetime` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `date()` and `time()` functions provide a quick way to extract
    just the date or the time from a `datetime` value.
  prefs: []
  type: TYPE_NORMAL
- en: datediff()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `datediff()` function returns the number of days between two dates. Say
    you want to check how many days there are between New Year’s Day and Cinco de
    Mayo in 2024:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is 125 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: If the date argument on the left is more recent than the date argument on the
    right, `datediff()` will return a positive number. If the date on the right is
    more recent, `datediff()` will return a negative number. If the two dates are
    the same, `0` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: date_format()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `date_format()` function formats a date according to a format string that
    you specify. The format string is made up of characters that you add and *specifiers*
    that start with a percent sign. The most common specifiers are listed in [Table
    8-1](#table8-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Common Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%a` | Abbreviated weekday name (`Sun`–`Sat`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%b` | Abbreviated month name (`Jan`–`Dec`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Month, numeric (`1`–`12`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Day of the month with suffix (`1st`, `2nd`, `3rd`, . . .) |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Day of the month, two digits with a leading zero where applicable
    (`01`–`31`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%e` | Day of the month (`1`–`31`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Hour with leading zero where applicable (`00`–`23`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%h` | Hour (`01`–`12`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | Minutes (`00`–`59`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%k` | Hour (`0`–`23`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%l` | Hour (`1`–`12`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Month name (`January`–`December`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Month (`00`–`12`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%p` | `AM` or `PM` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r` | Time, 12-hour (`hh:mm:ss` followed by `AM` or `PM`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Seconds (`00`–`59`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%T` | Time, 24-hour (`hh:mm:ss`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Weekday name (`Sunday`–`Saturday`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Day of the week (`0` = Sunday – `6` = Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Year, four digits |'
  prefs: []
  type: TYPE_TB
- en: '| `%y` | Year, two digits |'
  prefs: []
  type: TYPE_TB
- en: 'The datetime `2024-02-02 01:02:03` represents February 2, 2024, at 1:02 AM
    and 3 seconds. Try experimenting with some different formats for that `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The column you aliased as `format6` shows how the format specifiers can be combined.
    In that format string, you added a comma and the word `at` in addition to four
    specifiers for the date and time.
  prefs: []
  type: TYPE_NORMAL
- en: str_to_date()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `str_to_date()` function converts a string value to a date based on the
    format you provide. You use the same specifiers that you used for `date_format()`,
    but the two functions take opposite actions: `date_format()` converts a date to
    a string, while `str_to_date()` converts a string to a date.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon the format you provide, `str_to_date()` can convert a string
    to a `date`, a `time`, or a `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The last column, `time_format`, can also be converted with the function of the
    same name. We’ll look at it next.
  prefs: []
  type: TYPE_NORMAL
- en: time_format()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name implies, the `time_format()` function formats time. You can use
    the same specifiers as `date_format()` for `time_format()`. For example, here’s
    how to get the current time and format it in some different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressed in military time, the current time for me is `21:09:55`, which is
    9:09 PM and 55 seconds. Your results should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The column you aliased as `format2` shows the hour with a leading `0` because
    you used the `%H` specifier, but the `format3` column does not because you used
    the `%h` specifier. In columns 1–3, you added colon characters to the format string.
    In `format4` you added the word `hours`, a comma, the word `minutes`, the word
    `and`, and the word `seconds`.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides many functions to perform calculations. There are also arithmetic
    operators available, like `+` for addition, `-` for subtraction, `*` for multiplication,
    `/` and `div` for division, and `%` and `mod` for modulo. You’ll start reviewing
    some queries that use these operators, and then you’ll use parentheses to control
    the order of operations. Afterward, you’ll use mathematical functions to perform
    various tasks, including raising a number to a power, calculating standard deviation,
    and rounding and truncating numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll start by performing some mathematical calculations using the data from
    the `payroll` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Try out some of the arithmetic operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you use mathematical operators to get the employee’s salary
    minus their deductions, add their bonus to their salary, multiply their salary
    by their tax rate, and see their monthly salary by dividing their annual salary
    by 12, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the two columns on the right, `salary / 12` and `salary div 12`,
    you received different results when using the `/` and the `div` operators. This
    is because `div` discards any fractional amount and `/` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Modulo
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MySQL provides two operators for modulo: the percent sign (`%`) and the `mod`
    operator. *Modulo* takes one number, divides it by another, and returns the remainder.
    Consider a table called `roulette_winning_number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use modulo to determine if a number is odd or even by dividing it by
    2 and checking the remainder, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything with a remainder of 1 is an odd number. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The results show `1` for odd numbers and `0` for even numbers. In the first
    row, `21 % 2` evaluates to `1` because 21 divided by 2 is 10 with a remainder
    of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `mod` or `%` produces the same results. Modulo is also available as the
    `mod()` function. All of these queries return the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Operator Precedence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When there is more than one arithmetic operator used in a mathematical expression,
    `*`, `/`, `div`, `%`, and `mod` are evaluated first; `+` and `-` are evaluated
    last. This is called *operator precedence*. The following query (which uses the
    `payroll` table) was written to calculate the taxes employees will pay based on
    their salary, bonus, and tax rate, but the query is returning the wrong tax amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The column on the right should represent the amount of taxes the employees have
    to pay, but it seems to be too high. If Max Bain’s salary is $80,000 and his bonus
    is $10,000, it doesn’t seem reasonable that he would be required to pay $82,400
    in taxes.
  prefs: []
  type: TYPE_NORMAL
- en: The query is returning the wrong value because you expected MySQL to add `salary`
    and `bonus` first, and then multiply the result by the `tax_rate`. Instead, MySQL
    multiplied `bonus` by `tax_rate` first and then added the `salary`. The multiplication
    happened first because multiplication has a higher operator precedence than addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct the problem, use parentheses to tell MySQL to consider `salary +`
    `bonus` as a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Now the query returns $21,600 for Max Bain, which is the correct value. You
    should use parentheses frequently when performing calculations—not only because
    it gives you control over the order of operations, but also because it makes your
    SQL easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL provides many mathematical functions that can help with tasks like rounding
    numbers, getting the absolute value of a number, and dealing with exponents, as
    well as finding cosines, logarithms, and radians.
  prefs: []
  type: TYPE_NORMAL
- en: abs()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `abs()` function gets the absolute value of a number. The absolute value
    of a number is always positive. For example, the absolute value of 5 is 5, and
    the absolute value of –5 is 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you had a contest to guess the number of jelly beans in a jar. Write a
    query to see whose guess was closest to the actual number, 300:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you’ve selected the guesser’s name and their guess from the `jelly_bean`
    table. You select `300` and alias the column as `actual` so it will appear in
    your results with that heading. Then you subtract the guess from 300 and alias
    that column as `difference`. The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `difference` column shows how far off the guesses were from the actual value
    of 300, but the results are a bit hard to interpret. When the guess was higher
    than the actual amount of 300, your `difference` column appears as a negative
    number. When the guess was lower than the actual amount, your `difference` column
    appears as a positive number. For your contest, you don’t care whether the guess
    was higher or lower than 300, you only care about which guess was closest to 300.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `abs()` function to remove the negative numbers from the difference
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Now you can easily see that Ike won your contest because his value in the `difference`
    column is the smallest.
  prefs: []
  type: TYPE_NORMAL
- en: ceiling()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ceiling()` function returns the smallest whole number that is greater
    than or equal to the argument. If you pay $3.29 for gas, and you want to round
    that number up to the next whole dollar amount, you’d write the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The `ceiling()` function has a synonym, `ceil()`, that produces identical results.
  prefs: []
  type: TYPE_NORMAL
- en: floor()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `floor()` function returns the largest whole number that is less than or
    equal to the argument. To round $3.29 down to the next lowest whole dollar amount,
    you’d write the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: If the argument is already a whole number, then that number will be returned
    in both the `ceiling()` and `floor()` functions. For example, `ceiling(33)` and
    `floor(33)` both return `33`.
  prefs: []
  type: TYPE_NORMAL
- en: pi()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `pi()` function returns the value of pi, as seen at the beginning of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: degrees()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `degrees()` function converts radians to degrees. You can convert pi to
    degrees using this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: You got your answer by wrapping the `pi()` function in the `degrees()` function.
  prefs: []
  type: TYPE_NORMAL
- en: radians()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `radians()` function converts degrees to radians. You can convert 180 to
    radians using this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Your results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent an argument of `180` and returned a value of pi.
  prefs: []
  type: TYPE_NORMAL
- en: exp()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `exp()` function returns the natural logarithm base number *e* raised to
    the power of the number you provide as an argument (2, in this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The function returned `7.38905609893065`, which is *e* (2.718281828459) squared.
  prefs: []
  type: TYPE_NORMAL
- en: log()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `log()` function returns the natural logarithm of the number you provide
    as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: MySQL also provides the `log10()` function, which returns the base-10 logarithm,
    and `log2()`, which returns the base-2 logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log()` function can accept two arguments: the base of a number, then the
    number itself. For example, to find the log[2](8), enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent two arguments, `2` and `8`, and returned a value of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: mod()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `mod()` function, as you saw earlier, is the modulo function. It takes one
    number, divides it by another, and returns the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The `mod(7,2)` function evaluates to `1` because 7 divided by 2 is 3 with a
    remainder of 1\. Modulo is also available as the `%` operator and the `mod` operator.
  prefs: []
  type: TYPE_NORMAL
- en: pow()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pow()` function returns a number raised to a power. To raise 5 to the
    power of 3, you could write this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The `pow()` function has a synonym, `power()`, that returns identical results.
  prefs: []
  type: TYPE_NORMAL
- en: round()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `round()` function, introduced earlier in the chapter, rounds decimal numbers.
    To round the number 9.87654321 to three digits after the decimal point, use the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'To round all of the fractional numbers, call `round()` with just one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Calling `round()` without the optional second argument causes it to default
    to 0 digits after the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: truncate()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `truncate()` function shortens a number to specified number of decimal
    places. To truncate the number 9.87654321 to three digits after the decimal point,
    use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'To truncate all of the fractional numbers, call `truncate()` with `0` as the
    second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The `truncate()` function removes digits to convert the number to the requested
    number of digits after the decimal point. This differs from `round()`, which rounds
    numbers up or down before removing digits.
  prefs: []
  type: TYPE_NORMAL
- en: sin()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sin()` function returns the sine of a number given in radians. You can
    use this query to get the sine of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent an argument of `2` and returned a value of `0.9092974268256817`.
  prefs: []
  type: TYPE_NORMAL
- en: cos()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `cos()` function returns the cosine of a number that is given in radians.
    Use the following query to get the cosine of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent an argument of `2` and returned a value of `-0.4161468365471424`.
  prefs: []
  type: TYPE_NORMAL
- en: sqrt()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sqrt()` function returns the square root of a number. You can get the
    square root of 16like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent an argument of `16` and returned a value of `4`.
  prefs: []
  type: TYPE_NORMAL
- en: stddev_pop()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `stddev_pop()` function returns the population standard deviation of the
    numbers provided. *Population standard deviation* is the standard deviation when
    all values of a dataset are taken into consideration. For example, look at the
    `test_score` table, which contains all of your test scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Now write a query to get the population standard deviation of test scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `std()` and `stddev()` functions are synonyms for `stddev_pop()` and will
    produce identical results.
  prefs: []
  type: TYPE_NORMAL
- en: To get the standard deviation of a sample of values, rather than the entire
    population of a dataset, you can use `stddev_samp()` function.
  prefs: []
  type: TYPE_NORMAL
- en: tan()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `tan()` function accepts an argument in radians and returns the tangent.
    For example, you can get the tangent of 3.8 with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: The function was sent an argument of `3.8` and returned a value of `0.7735560905031258`.
  prefs: []
  type: TYPE_NORMAL
- en: Other Handy Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other useful functions include `cast()`, `coalesce()`, `distinct()`, `database()`,
    `if()`, and `version()`.
  prefs: []
  type: TYPE_NORMAL
- en: cast()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cast()` function converts a value from one data type to a different data
    type. To call the `cast()` function, pass a value into `cast()` as the first argument,
    follow it with the `as` keyword, and then specify the data type you want to convert
    it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, select the `datetime` column `order_datetime` from the table called
    `online_order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Your results show the following `datetime` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select those values without their time portion by casting from a `datetime`
    data type to a `date` data type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Your results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: The date part of the `datetime` now appears as a `date` value.
  prefs: []
  type: TYPE_NORMAL
- en: coalesce()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `coalesce()` function returns the first non-null value in a list. You could
    specify null values followed by a non-null value, and `coalesce()` would return
    the non-null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The `coalesce()` function is also useful when you want to display a value in
    your result instead of `null`. For example, in the `candidate` table used in the
    following query, the `employer` column will sometimes store the candidate’s employer
    name, and other times that column will be `null`. In order to display the text
    `Between Jobs` instead of `null`, you’d enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The query now displays `Between Jobs` rather than `null` for Jacob Davis, which
    is more informative, especially for nontechnical users who may not understand
    what `null` means.
  prefs: []
  type: TYPE_NORMAL
- en: distinct()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have duplicate values, you can use the `distinct()` function to display
    each value only once. For example, if you want to know which countries your customers
    are from, you could query the `customer` table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The query is returning the `country` column value for every row in the `customer`
    table. You can use the `distinct()` function to see each country in your result
    set just once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distinct()` function is also available as an operator. To use it, remove
    the parentheses like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The result set is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distinct()` function is especially useful when combined with the `count()`
    function to find how many unique values you have. Here you write a query to count
    the number of distinct countries in your table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: You identified the distinct countries using the `distinct()` function and wrapped
    them in the `count()` function to get a count of them.
  prefs: []
  type: TYPE_NORMAL
- en: database()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `database()` function tells you which database you’re currently using.
    As you saw in [Chapter 2](c02.xhtml), the `use` command lets you select which
    database you want to use. Throughout your day, you might move between different
    databases and forget your current database. You can call the `database()` function
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not in the database you thought you were and you tried to query a
    table, MySQL would give an error saying the table doesn’t exist. Calling `database()`
    is a quick way to check.
  prefs: []
  type: TYPE_NORMAL
- en: if()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if()` function returns a different value depending upon whether a condition
    is `true` or `false`. The `if()` function accepts three arguments: the condition
    you want to test, the value to return if the condition is `true`, and the value
    to return if the condition is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a query that lists students and whether they passed or failed an
    exam. The `test_result` table contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Your query to check if each student passed the exam should look similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition you’re testing is whether the student’s `grade` is greater than
    `59`. If so, you return the text `pass`. If not, you return the text `fail`. The
    results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL also has a `case` operator that lets you perform more sophisticated logic
    than the `if()` function. The `case` operator lets you test more than one condition
    and returns the result for the first condition that is met. In the following query,
    you select the student name and add a comment to the student based on their grade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: The `case` operator uses a matching `end` keyword that marks the end of the
    `case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: For any students who received a grade less than 30, the `case` statement returns
    `Please retake this exam` and then control is passed to the `end` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Students who received a grade of 30 or more aren’t handled by the first `when`
    condition of the `case` statement, so control drops to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: If a student received a grade of 30 or higher but less than 60, `Better luck
    next time` is returned and control passes to the `end` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a student’s grade didn’t match either of the `when` conditions, meaning
    the student scored higher than 60, control drops to the `else` keyword, where
    `Good job` is returned. You use an `else` clause to capture any student grades
    that aren’t handled by the first two conditions. The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `if()` function—which returns a result if a condition is `true` or
    `false`—`case` lets you check several conditions and returns a result based on
    the first condition that is met.
  prefs: []
  type: TYPE_NORMAL
- en: version()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `version()` function returns the version of MySQL you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The version of MySQL installed on my server is 8.0.27\. Yours may be different.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you looked at how to call MySQL built-in functions and pass
    values, known as arguments, to those functions. You explored the most useful functions
    and saw how to locate the more obscure ones when necessary. In the next chapter,
    you’ll look at how to insert, update, and delete data from a MySQL database.
  prefs: []
  type: TYPE_NORMAL
