<html><head></head><body><section class="chapter" epub:type="chapter" id="into_the_real_world" title="Chapter&#xA0;3.&#xA0;Into the Real World"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Into the Real World</h2></div></div></div><div class="mediaobject"><a id="med_id00004"/><img alt="Into the Real World" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1248"/><a class="indexterm" id="iddle1584"/><a class="indexterm" id="iddle1588"/>The previous chapter demonstrated the configuration for basic packet filtering on a single machine. In this chapter, we’ll build on that basic setup but move into more conventional territory: the packet-filtering <span class="emphasis"><em>gateway</em></span>. Although most of the items in this chapter are potentially useful in a single-machine setup, our main focus is to set up a gateway that forwards a selection of network traffic and handles common network services for a basic local network.</p><div class="sect1" title="A Simple Gateway"><div class="titlepage"><div><div><h2 class="title" id="simple_gateway" style="clear: both">A Simple Gateway</h2></div></div></div><p>We’ll start with building what you probably associate with the term <span class="emphasis"><em>firewall</em></span>: a machine that acts as a gateway for at least one other machine. In addition to forwarding packets between its various networks, this machine’s mission will be to improve the signal-to-noise ratio in the network traffic it handles. That’s where our PF configuration comes in.</p><p><a class="indexterm" id="iddle1421"/><a class="indexterm" id="iddle1422"/><a class="indexterm" id="iddle1589"/><a class="indexterm" id="iddle1591"/><a class="indexterm" id="iddle1607"/><a class="indexterm" id="iddle1976"/>But before diving into the practical configuration details, we need to dip into some theory and flesh out some concepts. Bear with me; this will end up saving you some headaches I’ve seen on mailing lists, newsgroups, and Web forums all too often.</p><div class="sect2" title="Keep It Simple: Avoid the Pitfalls of in, out, and on"><div class="titlepage"><div><div><h3 class="title" id="keep_it_simple_avoid_the_pitfalls_of_inc">Keep It Simple: Avoid the Pitfalls of in, out, and on</h3></div></div></div><p>In the single-machine setup, life is relatively simple. Traffic you create should either pass out to the rest of the world or be blocked by your filtering rules, and you get to decide what you want to let in from elsewhere.</p><p>When you set up a gateway, your perspective changes. You go from the “It’s me versus the network out there” mindset to “I’m the one who decides what to pass to or from all the networks I’m connected to.” The machine has several, or at least two, network interfaces, each connected to a separate network, and its primary function (or at least the one we’re interested in here) is to forward network traffic between networks. Conceptually, the network would look something like <a class="xref" href="ch03.html#network_with_a_single_gateway" title="Figure 3-1. Network with a single gateway">Figure 3-1</a>.</p><div class="figure"><a id="network_with_a_single_gateway"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00005"/><img alt="Network with a single gateway" src="httpatomoreillycomsourcenostarchimages2127151.png.jpg"/></div></div><div class="figure-title">Figure 3-1. Network with a single gateway</div></div><p>It’s very reasonable to think that if you want traffic to pass from the network connected to <code class="literal">re1</code> to hosts on the network connected to <code class="literal">re0</code>, you’ll need a rule like the following:<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch03fn01" id="ch03fn01">13</a>]</sup></p><a id="pro_id00032"/><pre class="programlisting">pass in proto tcp on re1 from re1:network to re0:network \&#13;
                  port $ports keep state</pre><p>However, one of the most common and most complained-about mistakes in firewall configuration is not realizing that the <code class="literal">to</code> keyword doesn’t <a class="indexterm" id="iddle1055"/><a class="indexterm" id="iddle1610"/>in itself guarantee passage to the end point. The <code class="literal">to</code> keyword here means only that a packet or connection must have a destination address that matches those criteria in order to match the rule. The rule we just wrote lets the traffic pass <code class="literal">in</code> to just the gateway itself and <code class="literal">on</code> the specific interface named in the rule. To allow the packets in a bit further and to move on to the next network, we need a matching rule that says something like this:</p><a id="pro_id00033"/><pre class="programlisting">pass out proto tcp on re0 from re1:network to re0:network \&#13;
                     port $ports keep state</pre><p>But please stop and take a moment to read those rules one more time. This last rule allows only packets with a destination in the network directly connected to <code class="literal">re0</code> to pass, and nothing else. If that’s exactly what you want, fine. In other contexts, such rules are, while perfectly valid, more specific than the situation calls for. It’s very easy to let yourself dive deeply into specific details and lose the higher-level view of the configuration’s purpose—and maybe earn yourself a few extra rounds of debugging in the process.</p><p>If there are good reasons for writing very specific rules, like the preceding ones, you probably already know that you need them and why. By the time you have finished this book (if not a bit earlier), you should be able to articulate the circumstances when more specific rules are needed. However, for the basic gateway configurations in this chapter, it’s likely that you’ll want to write rules that are not interface-specific. In fact, in some cases, it isn’t useful to specify the direction either; you’d simply use a rule like the following to let your local network access the Internet:</p><a id="pro_id00034"/><pre class="programlisting">pass proto tcp from re1:network to port $ports keep state</pre><p>For simple setups, interface-bound <code class="literal">in</code> and <code class="literal">out</code> rules are likely to add more clutter to your rule sets than they’re worth. For a busy network admin, a readable rule set is a safer one. (And we’ll look at some additional safety measures, like <code class="literal">antispoof</code>, in <a class="xref" href="ch10.html" title="Chapter 10. Getting Your Setup Just Right">Chapter 10</a>.)</p><p>For the remainder of this book, with some exceptions, we’ll keep the rules as simple as possible for readability.</p></div><div class="sect2" title="Network Address Translation vs. IPv6"><div class="titlepage"><div><div><h3 class="title" id="network_address_translation_vsdot_ipv6">Network Address Translation vs. IPv6</h3></div></div></div><p>Once we start handling traffic between separate networks, it’s useful to look at how network addresses work and why you’re likely to come across several different addressing schemes. The subject of network addresses has been a rich source of both confusion and buzzwords over the years. The underlying facts are sometimes hard to establish, unless you go to the source and wade through a series of RFCs. Over the next few paragraphs, I’ll make an effort to clear up some of the confusion.</p><p>For example, a widely held belief is that if you have an internal network that uses a totally different address range from the one assigned to the interface attached to the Internet, you’re safe, and no one from the outside <a class="indexterm" id="iddle1387"/><a class="indexterm" id="iddle1410"/><a class="indexterm" id="iddle1411"/><a class="indexterm" id="iddle1415"/><a class="indexterm" id="iddle1416"/><a class="indexterm" id="iddle1516"/><a class="indexterm" id="iddle1517"/><a class="indexterm" id="iddle1552"/><a class="indexterm" id="iddle1553"/><a class="indexterm" id="iddle1592"/>can get at your network resources. This belief is closely related to the idea that the IP address of your firewall in the local network must be either <code class="literal">192.168.0.1</code> or <code class="literal">10.0.0.1</code>.</p><p>There’s an element of truth in both notions, and those addresses are common defaults. But the real story is that it’s possible to sniff one’s way past network address translation, although PF offers some tricks that make that task harder.</p><p>The real reason we use a specific set of internal address ranges and a different set of addresses for unique external address ranges isn’t primarily to address security concerns. Rather, it’s the easiest way to work around a design problem in the Internet protocols: a limited range of possible addresses.</p><p>In the 1980s, when the Internet protocols were formulated, most computers on the Internet (or ARPANET, as it was known at the time) were large machines with anything from several dozen to several thousand users each. At the time, a 32-bit address space with more than four billion addresses seemed quite sufficient, but several factors have conspired to prove that assumption wrong. One factor is that the address-allocation process led to a situation where the largest chunks of the available address space were already allocated before some of the world’s more populous nations even connected to the Internet. The other, and perhaps more significant, factor was that by the early 1990s, the Internet was no longer a research project, but rather a commercially available resource with consumers and companies of all sizes consuming IP address space at an alarming rate.</p><p>The long-term solution was to redefine the Internet to use a larger address space. In 1998, the specification for IPv6, with 128 bits of address space for a total of 2<sup>128</sup> addresses, was published as RFC 2460. But while we were waiting for IPv6 to become generally available, we needed a stopgap solution. That solution came as a series of RFCs that specified how a gateway could forward traffic with IP addresses translated so that a large local network would look like just one computer to the rest of the Internet. Certain previously unallocated IP address ranges were set aside for these private networks. These were free for anyone to use, on the condition that traffic in those ranges wouldn’t be allowed out on the Internet untranslated. Thus, <span class="emphasis"><em>network address translation (NAT)</em></span> was born in the mid-1990s and quickly became the default way to handle addressing in local networks.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch03fn02" id="ch03fn02">14</a>]</sup></p><p>PF supports IPv6 as well as the various IPv4 address translation tricks. (In fact, the BSDs were among the earliest IPv6 adopters, thanks to the efforts of the KAME project.<sup>[<a class="footnote" href="#ftn.ch03fn03" id="ch03fn03">15</a>]</sup>) All systems that have PF also support both the IPv4 and the IPv6 address families. If your IPv4 network needs a NAT <a class="indexterm" id="iddle1474"/><a class="indexterm" id="iddle1590"/><a class="indexterm" id="iddle1593"/>configuration, you can integrate the translation as needed in your PF rule set. In other words, if you’re using a system that supports PF, you can be reasonably sure that your IPv6 needs have been taken care of, at least on the operating-system level. However, some operating systems with a PF port use older versions of the code, and it’s important to be aware that the general rule that newer PF code is better applies equally to the IPv6 context.</p><p>The examples in this book use mainly IPv4 addresses and NAT where appropriate, but most of the material is equally relevant to networks that have implemented IPv6.</p></div><div class="sect2" title="Final Preparations: Defining Your Local Network"><div class="titlepage"><div><div><h3 class="title" id="final_preparations_defining_your_local_n">Final Preparations: Defining Your Local Network</h3></div></div></div><p>In <a class="xref" href="ch02.html" title="Chapter 2. PF Configuration Basics">Chapter 2</a>, we set up a configuration for a single, standalone machine. We’re about to extend that configuration to a gateway version, and it’s useful to define a few more macros to help readability and to conceptually separate the local networks where you have a certain measure of control from everything else. So how do you define your “local” network in PF terms?</p><p>Earlier in this chapter, you saw the <span class="emphasis"><em><code class="literal">interface</code></em></span><code class="literal">:network</code> notation. This is a nice piece of shorthand, but you can make your rule set even more readable and easier to maintain by taking the macro a bit further. For example, you could define a <code class="literal">$localnet</code> macro as the network directly attached to your internal interface (<code class="literal">re1:network</code> in our examples). Or you could change the definition of <code class="literal">$localnet</code> to an IP address/netmask notation to denote a network, such as <code class="literal">192.168.100.0/24</code> for a subnet of private IPv4 addresses or <code class="literal">2001:db8:dead:beef::/64</code> for an IPv6 range.</p><p>If your network environment requires it, you could define your <code class="literal">$localnet</code> as a list of networks. For example, a sensible <code class="literal">$localnet</code> definition combined with <code class="literal">pass</code> rules that use the macro, such as the following, could end up saving you a few headaches:</p><a id="pro_id00035"/><pre class="programlisting">pass proto { tcp, udp } from $localnet to port $ports</pre><p>We’ll stick to the convention of using macros such as <code class="literal">$localnet</code> for readability from here on.</p></div><div class="sect2" title="Setting Up a Gateway"><div class="titlepage"><div><div><h3 class="title" id="setting_up_a_gateway">Setting Up a Gateway</h3></div></div></div><p>We’ll take the single-machine configuration we built from the ground up in the previous chapter as our starting point for building our packet-filtering gateway. We assume that the machine has acquired another network card (or that you have set up a network connection from your local network to one or more other networks via Ethernet, PPP, or other means).</p><p>In our context, it isn’t too interesting to look at the details of how the interfaces are configured. We just need to know that the interfaces are up and running.</p><p><a class="indexterm" id="iddle1368"/><a class="indexterm" id="iddle1392"/><a class="indexterm" id="iddle1402"/><a class="indexterm" id="iddle1602"/><a class="indexterm" id="iddle1737"/><a class="indexterm" id="iddle1922"/>For the following discussion and examples, only the interface names will differ between a PPP setup and an Ethernet one, and we’ll do our best to get rid of the actual interface names as quickly as possible.</p><p>First, because packet forwarding is off by default in all BSDs, we need to turn it on in order to let the machine forward the network traffic it receives on one interface to other networks via one or more separate interfaces. Initially, we’ll do this on the command line with a <code class="literal">sysctl</code> command for traditional IPv4:</p><a id="pro_id00036"/><pre class="programlisting"># sysctl net.inet.ip.forwarding=1</pre><p>If we need to forward IPv6 traffic, we use this <code class="literal">sysctl</code> command:</p><a id="pro_id00037"/><pre class="programlisting"># sysctl net.inet6.ip6.forwarding=1</pre><p>This is fine for now. However, in order for this to work once you reboot the computer at some time in the future, you need to enter these settings into the relevant configuration files.</p><p>In OpenBSD and NetBSD, you do this by editing <span class="emphasis"><em>/etc/sysctl.conf</em></span> and adding IP-forwarding lines to the end of the file so the last lines look like this:</p><a id="pro_id00038"/><pre class="programlisting">net.inet.ip.forwarding=1&#13;
net.inet6.ip6.forwarding=1</pre><p>In FreeBSD, make the change by putting these lines in your <span class="emphasis"><em>/etc/rc.conf</em></span>:</p><a id="pro_id00039"/><pre class="programlisting">gateway_enable="YES" #for ipv4&#13;
ipv6_gateway_enable="YES" #for ipv6</pre><p>The net effect is identical; the FreeBSD <span class="emphasis"><em>rc</em></span> script sets the two values via <code class="literal">sysctl</code> commands. However, a larger part of the FreeBSD configuration is centralized into the <span class="emphasis"><em>rc.conf</em></span> file.</p><p>Now it’s time to check whether all of the interfaces you intend to use are up and running. Use <span class="strong"><strong><code class="literal">ifconfig -a</code></strong></span> or <span class="strong"><strong><code class="literal">ifconfig</code> <span class="emphasis"><em>interface_name</em></span></strong></span> to find out.</p><p>The output of <code class="literal">ifconfig -a</code> on one of my systems looks like this:</p><a id="pro_id00040"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig -a</strong></span>&#13;
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224&#13;
        groups: lo&#13;
        inet 127.0.0.1 netmask 0xff000000&#13;
        inet6 ::1 prefixlen 128&#13;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5&#13;
xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:60:97:83:4a:01&#13;
        groups: egress&#13;
        media: Ethernet autoselect (100baseTX full-duplex)&#13;
        status: active&#13;
        inet 194.54.107.18 netmask 0xfffffff8 broadcast 194.54.107.23&#13;
        inet6 fe80::260:97ff:fe83:4a01%xl0 prefixlen 64 scopeid 0x1&#13;
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:30:05:03:fc:41&#13;
        media: Ethernet autoselect (100baseTX full-duplex)&#13;
        status: active&#13;
        inet 194.54.103.65 netmask 0xffffffc0 broadcast 194.54.103.127&#13;
        inet6 fe80::230:5ff:fe03:fc41%fxp0 prefixlen 64 scopeid 0x2&#13;
pflog0: flags=141&lt;UP,RUNNING,PROMISC&gt; mtu 33224&#13;
enc0: flags=0&lt;&gt; mtu 1536</pre><p><a class="indexterm" id="iddle1393"/><a class="indexterm" id="iddle1482"/><a class="indexterm" id="iddle1511"/><a class="indexterm" id="iddle1521"/><a class="indexterm" id="iddle1547"/><a class="indexterm" id="iddle1671"/><a class="indexterm" id="iddle1672"/><a class="indexterm" id="iddle1964"/>Your setup is most likely somewhat different. Here, the physical interfaces on the gateway are <code class="literal">xl0</code> and <code class="literal">fxp0</code>. The logical interfaces <code class="literal">lo0</code> (the loopback interface), <code class="literal">enc0</code> (the encapsulation interface for IPSEC use), and <code class="literal">pflog0</code> (the PF logging device) are probably on your system, too.</p><p>If you’re on a dial-up connection, you probably use some variant of PPP for the Internet connection, and your external interface is the <code class="literal">tun0</code> pseudo-device. If your connection is via some sort of broadband connection, you may have an Ethernet interface to play with. However, if you’re in the significant subset of ADSL users who use PPP over Ethernet (PPPoE), the correct external interface will be one of the pseudo-devices <code class="literal">tun0</code> or <code class="literal">pppoe0</code> (depending on whether you use userland <code class="literal">pppoe(8)</code> or kernel mode <code class="literal">pppoe(4)</code>), not the physical Ethernet interface.</p><p>Depending on your specific setup, you may need to do some other device-specific configuration for your interfaces. After you have that set up, you can move on to the TCP/IP level and deal with the packet-filtering configuration.</p><p>If you still intend to allow any traffic initiated by machines on the inside, your <span class="emphasis"><em>/etc/pf.conf</em></span> for your initial gateway setup could look roughly like this:</p><a id="pro_id00041"/><pre class="programlisting">ext_if = "re0" # macro for external interface - use tun0 or pppoe0 for PPPoE&#13;
int_if = "re1" # macro for internal interface&#13;
localnet = $int_if:network&#13;
# ext_if IPv4 address could be dynamic, hence ($ext_if)&#13;
match out on $ext_if inet from $localnet nat-to ($ext_if) # NAT, match IPv4 only&#13;
block all&#13;
pass from { self, $localnet }</pre><p>Note the use of macros to assign logical names to the network interfaces. Here, Realtek Ethernet cards are used, but this is the last time we’ll find this of any interest whatsoever in our context.</p><p>In truly simple setups like this one, we may not gain very much by using macros like these, but once the rule sets grow a little larger, you’ll learn to appreciate the readability they add.</p><p>One possible refinement to this rule set would be to remove the macro <code class="literal">ext_if</code> and replace the <code class="literal">$ext_if</code> references with the string <code class="literal">egress</code>, which is the name of the interface group that contains the interface that has the default route. Interface groups are not macros, so you would write the name <code class="literal">egress</code> without a leading <code class="literal">$</code> character.</p><p>Also note the <code class="literal">match</code> rule with <code class="literal">nat-to</code>. This is where you handle NAT from the nonroutable address inside your local network to the sole official address assigned to you. If your network uses official, routable IPv4 <a class="indexterm" id="iddle1520"/><a class="indexterm" id="iddle1807"/>addresses, you simply leave this line out of your configuration. The <code class="literal">match</code> rules, which were introduced in OpenBSD 4.6, can be used to apply actions when a connection matches the criteria without deciding whether a connection should be blocked or passed.</p><p>The parentheses surrounding the last part of the <code class="literal">match</code> rule <code class="literal">($ext_if)</code> are there to compensate for the possibility that the IP address of the external interface may be dynamically assigned. This detail will ensure that your network traffic runs without serious interruptions, even if the interface’s IP address changes.</p><p>It’s time to sum up the rule set we’ve built so far: (1) We block all traffic originating outside our own network. (2) We make sure all IPv4 traffic initiated by hosts in our local network will pass into the outside world only with the source address rewritten to the routable address assigned to the gateway’s external interface. (3) Finally, we let all traffic from our local network (IPv4 and IPv6 both) and from the gateway itself pass. The keyword <code class="literal">self</code> in the final <code class="literal">pass</code> rule is a macro-ish reserved word in PF syntax that denotes all addresses assigned to all interfaces on the local host.</p><p>If your operating system runs a pre-OpenBSD 4.7 PF version, your first gateway rule set would look something like this:</p><a id="pro_id00042"/><pre class="programlisting">ext_if = "re0" # macro for external interface - use tun0 or pppoe0 for PPPoE&#13;
int_if = "re1" # macro for internal interface&#13;
localnet = $int_if:network&#13;
# ext_if IP address could be dynamic, hence ($ext_if)&#13;
nat on $ext_if inet from $localnet to any -&gt; ($ext_if) # NAT, match IPv4 only&#13;
block all&#13;
pass from { self, $localnet } to any keep state</pre><p>The <code class="literal">nat</code> rule here handles the translation much as does the <code class="literal">match</code> rule with <code class="literal">nat-to</code> in the previous example.</p><p>On the other hand, this rule set probably allows more traffic than you actually want to pass out of your network. In one of the networks where I’ve done a bit of work, the main part of the rule set is based on a macro called <code class="literal">client_out</code>:</p><a id="pro_id00043"/><pre class="programlisting">client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http,\&#13;
                https, 446, cvspserver, 2628, 5999, 8000, 8080 }"</pre><p>It has this <code class="literal">pass</code> rule:</p><a id="pro_id00044"/><pre class="programlisting">pass proto tcp from $localnet to port $client_out</pre><p>This may be a somewhat peculiar selection of ports, but it’s exactly what my colleagues there needed at the time. Some of the numbered ports were needed for systems that were set up for specific purposes at other sites. Your needs probably differ at least in some details, but this should cover some of the more useful services.</p><p><a class="indexterm" id="iddle1275"/><a class="indexterm" id="iddle1560"/><a class="indexterm" id="iddle1608"/><a class="indexterm" id="iddle1731"/><a class="indexterm" id="iddle1806"/><a class="indexterm" id="iddle1879"/><a class="indexterm" id="iddle2005"/>Here’s another <code class="literal">pass</code> rule that is useful to those who want the ability to administer machines from elsewhere:</p><a id="pro_id00045"/><pre class="programlisting">pass in proto tcp to port ssh</pre><p>Or use this form, if you prefer:</p><a id="pro_id00046"/><pre class="programlisting">pass in proto tcp to $ext_if port ssh</pre><p>When you leave out the <code class="literal">from</code> part entirely, the default is <code class="literal">from any</code>, which is quite permissive. It lets you log in from anywhere, which is great if you travel a lot and need SSH access from unknown locations around the world. If you’re not all that mobile—say you haven’t quite developed the taste for conferences in far-flung locations, or you feel your colleagues can fend for themselves while you’re on vacation—you may want to tighten up with a <code class="literal">from</code> part that includes only the places where you and other administrators are likely to log in from for legitimate reasons.</p><p>Our very basic rule set is still not complete. Next, we need to make the name service work for our clients. We start with another macro at the start of our rule set:</p><a id="pro_id00047"/><pre class="programlisting">udp_services = "{ domain, ntp }"</pre><p>This is supplemented with a rule that passes the traffic we want through our firewall:</p><a id="pro_id00048"/><pre class="programlisting">pass quick proto { tcp, udp } to port $udp_services</pre><p>Note the <code class="literal">quick</code> keyword in this rule. We’ve started writing rule sets that consist of several rules, and it’s time to revisit the relationships and interactions between them.</p><p>As noted in the previous chapter, the rules are evaluated from top to bottom in the sequence they’re written in the configuration file. For each packet or connection evaluated by PF, <span class="emphasis"><em>the last matching rule</em></span> in the rule set is the one that’s applied.</p><p>The <code class="literal">quick</code> keyword offers an escape from the ordinary sequence. When a packet matches a <code class="literal">quick</code> rule, the packet is treated according to the present rule. The rule processing stops without considering any further rules that might have matched the packet. As your rule sets grow longer and more complicated, you’ll find this quite handy. For example, it’s useful when you need a few isolated exceptions to your general rules.</p><p>This <code class="literal">quick</code> rule also takes care of NTP, which is used for time synchronization. Common to both the name service and time synchronization protocols is that they may, under certain circumstances, communicate alternately over TCP and UDP.</p></div><div class="sect2" title="Testing Your Rule Set"><div class="titlepage"><div><div><h3 class="title" id="testing_your_rule_set">Testing Your Rule Set</h3></div></div></div><p><a class="indexterm" id="iddle1201"/><a class="indexterm" id="iddle1210"/><a class="indexterm" id="iddle1332"/><a class="indexterm" id="iddle1333"/><a class="indexterm" id="iddle1594"/><a class="indexterm" id="iddle1796"/>You may not have gotten around to writing that formal test suite for your rule sets just yet, but there’s every reason to test that your configuration works as expected.</p><p>The same basic tests in the standalone example from the previous chapter still apply. But now you need to test from the other hosts in your network as well as from your packet-filtering gateway. For each of the services you specified in your <code class="literal">pass</code> rules, test that machines in your local network get meaningful results. From any machine in your local network, enter a command like this:</p><a id="pro_id00049"/><pre class="programlisting">$ <span class="strong"><strong>host nostarch.com</strong></span></pre><p>It should return exactly the same results as when you tested the stand-alone rule set in the previous chapter, and traffic for the services you have specified should pass<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch03fn04" id="ch03fn04">16</a>]</sup>.</p><p>You may not think it’s necessary, but it doesn’t hurt to check that the rule set works as expected from outside your gateway as well. If you’ve done exactly what this chapter says so far, it shouldn’t be possible to contact machines in your local network from the outside.</p><div class="sidebar"><a id="why_only_ip_addresses_em_dash_not_hostna"/><div class="sidebar-title">Why Only IP Addresses—Not Hostnames or Domain Names?</div><p>Looking at the examples up to this point, you’ve probably noticed that the rule sets all have macros that expand into IP addresses or address ranges but never into hostnames or domain names. You’re probably wondering why. After all, you’ve seen that PF lets you use service names in your rule set, so why not include hostnames or domain names?</p><p>The answer is that if you used domain names and hostnames in your rule set, the rule set would be valid only after the name service was running and accessible. In the default configuration, PF is loaded before any network services are running. This means that if you want to use domain names and hostnames in your PF configuration, you’ll need to change the system’s startup sequence (by editing <span class="emphasis"><em>/etc/rc.local</em></span>, perhaps) to load the name service–dependent rule set only after the name service is available. If you have only a limited number of hostnames or domain names you want to reference in your PF configuration, it’s likely at least as useful to add those as IP addresses to name-mapping entries in your <span class="emphasis"><em>/etc/hosts</em></span> file and leave the <span class="emphasis"><em>rc</em></span> scripts alone.</p></div></div></div><div class="sect1" title="That Sad Old FTP Thing"><div class="titlepage"><div><div><h2 class="title" id="that_sad_old_ftp_thing" style="clear: both">That Sad Old FTP Thing</h2></div></div></div><p><a class="indexterm" id="iddle1045"/><a class="indexterm" id="iddle1245"/><a class="indexterm" id="iddle1276"/><a class="indexterm" id="iddle1280"/><a class="indexterm" id="iddle1281"/><a class="indexterm" id="iddle1282"/><a class="indexterm" id="iddle1289"/><a class="indexterm" id="iddle1585"/><a class="indexterm" id="iddle1801"/><a class="indexterm" id="iddle1812"/><a class="indexterm" id="iddle1948"/><a class="indexterm" id="iddle1961"/>The short list of real-life TCP ports we looked at a few moments back contained, among other things, <span class="emphasis"><em>FTP</em></span>, the classic <span class="emphasis"><em>file transfer protocol</em></span>. FTP is a relic of the early Internet, when experiments were the norm and security was not really on the horizon in any modern sense. FTP actually predates TCP/IP,<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch03fn05" id="ch03fn05">17</a>]</sup> and it’s possible to track the protocol’s development through more than 50 RFCs. After more than 30 years, FTP is both a sad old thing and a problem child—emphatically so for anyone trying to combine FTP and firewalls. FTP is an old and weird protocol with a lot to dislike. Here are the most common points against it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Passwords are transferred in the clear.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch03fn06" id="ch03fn06">18</a>]</sup></p></li><li class="listitem"><p>The protocol demands the use of at least two TCP connections (control and data) on separate ports.</p></li><li class="listitem"><p>When a session is established, data is communicated via ports usually selected at random.</p></li></ul></div><p>All of these points make for challenges security-wise, even before considering any potential weaknesses in client or server software that may lead to security issues. As any network graybeard will tell you, these things tend to crop up when you need them the least.</p><p>Under any circumstances, other more modern and more secure options for file transfer exist, such as SFTP and SCP, which feature both authentication and data transfer via encrypted connections. Competent IT professionals should have a preference for some form of file transfer other than FTP.</p><p>Regardless of our professionalism and preferences, we sometimes must deal with things we would prefer not to use at all. In the case of FTP through firewalls, we can combat problems by redirecting the traffic to a small program that’s written specifically for this purpose. The upside for us is that handling FTP offers us a chance to look at two fairly advanced PF features: <span class="emphasis"><em>redirection</em></span> and <span class="emphasis"><em>anchors.</em></span></p><p>The easiest way to handle FTP in a default-to-block scenario such as ours is to have PF redirect the traffic for that service to an external application that acts as a <span class="emphasis"><em>proxy</em></span> for the service. The proxy maintains its own named sub–rule set (an <span class="emphasis"><em>anchor</em></span> in PF terminology), where it inserts or deletes rules as needed for the FTP traffic. The combination of redirection and the anchor provides a clean, well-defined interface between the packet-filtering subsystem and the proxy.</p><div class="sect2" title="If We Must: ftp-proxy with Divert or Redirect"><div class="titlepage"><div><div><h3 class="title" id="if_we_must_ftp-proxy_with_divert_or_redi">If We Must: ftp-proxy with Divert or Redirect</h3></div></div></div><p><a class="indexterm" id="iddle1188"/><a class="indexterm" id="iddle1279"/><a class="indexterm" id="iddle1285"/><a class="indexterm" id="iddle1286"/><a class="indexterm" id="iddle1287"/><a class="indexterm" id="iddle1288"/><a class="indexterm" id="iddle1586"/><a class="indexterm" id="iddle1739"/><a class="indexterm" id="iddle1748"/>Enabling FTP transfers through your gateway is amazingly simple, thanks to the FTP-proxy program included in the OpenBSD base system. The program is called—you guessed it—<code class="literal">ftp-proxy</code>.</p><p>To enable <code class="literal">ftp-proxy</code>, you need to add this line to your <span class="emphasis"><em>/etc/rc.conf.local</em></span> file on OpenBSD:</p><a id="pro_id00050"/><pre class="programlisting">ftpproxy_flags=""</pre><p>On FreeBSD, <span class="emphasis"><em>/etc/rc.conf</em></span> needs to contain at least the first of these two lines:</p><a id="pro_id00051"/><pre class="programlisting">ftpproxy_enable="YES"&#13;
ftpproxy_flags="" # and put any command line options here</pre><p>If you need to specify any command-line options to <code class="literal">ftp-proxy</code>, you put them in the <code class="literal">ftpproxy_flags</code> variable.</p><p>You can start the proxy manually by running <span class="emphasis"><em>/usr/sbin/ftp-proxy</em></span> if you like (or even better, use the <span class="emphasis"><em>/etc/rc.d/ftp-proxy</em></span> script with the <code class="literal">start</code> option on OpenBSD), and you may want to do this in order to check that the changes to the PF configuration you’re about to make have the intended effect.</p><p>For a basic configuration, you need to add only three elements to your <span class="emphasis"><em>/etc/pf.conf</em></span>: the anchor and two <code class="literal">pass</code> rules. The anchor declaration looks like this:</p><a id="pro_id00052"/><pre class="programlisting">anchor "ftp-proxy/*"</pre><p>In pre-OpenBSD 4.7 versions, two anchor declarations were needed:</p><a id="pro_id00053"/><pre class="programlisting">nat-anchor "ftp-proxy/*"&#13;
rdr-anchor "ftp-proxy/*"</pre><p>The proxy will insert the rules it generates for the FTP sessions here. Then, you also need a <code class="literal">pass</code> rule to let FTP traffic into the proxy:</p><a id="pro_id00054"/><pre class="programlisting">pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021</pre><p>Note the <code class="literal">divert-to</code> part. This redirects the traffic to the local port, where the proxy listens via the highly efficient, local-connections-only divert(4) interface. In OpenBSD versions 4.9 and older, the traffic diversion happened via an <code class="literal">rdr-to</code>. If you’re upgrading an existing pre-OpenBSD 5.0 configuration, you’ll need to update your <code class="literal">rdr-to</code> rules for the FTP proxy to use <code class="literal">divert-to</code> instead.</p><p>If your operating system uses a pre-OpenBSD 4.7 PF version, you need this version of the redirection rule:</p><a id="pro_id00055"/><pre class="programlisting">rdr pass on $int_if inet proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre><p><a class="indexterm" id="iddle1172"/><a class="indexterm" id="iddle1283"/><a class="indexterm" id="iddle1343"/><a class="indexterm" id="iddle1403"/><a class="indexterm" id="iddle1587"/><a class="indexterm" id="iddle1596"/><a class="indexterm" id="iddle1967"/><a class="indexterm" id="iddle1996"/>Finally, make sure your rule set contains a <code class="literal">pass</code> rule to let the packets pass from the proxy to the rest of the world, where <code class="literal">$proxy</code> expands to the address to which the proxy daemon is bound:</p><a id="pro_id00056"/><pre class="programlisting">pass out inet proto tcp from $proxy to any port ftp</pre><p>Reload your PF configuration:</p><a id="pro_id00057"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -f /etc/pf.conf</strong></span></pre><p>Before you know it, your users will thank you for making FTP work.</p></div><div class="sect2" title="Variations on the ftp-proxy Setup"><div class="titlepage"><div><div><h3 class="title" id="variations_on_the_ftp-proxy_setup">Variations on the ftp-proxy Setup</h3></div></div></div><p>The preceding example covers a basic setup where the clients in your local network need to contact FTP servers elsewhere. This configuration should work well with most combinations of FTP clients and servers.</p><p>You can change the proxy’s behavior in various ways by adding options to the <code class="literal">ftpproxy_flags=</code> line. You may bump into clients or servers with specific quirks that you need to compensate for in your configuration, or you may want to integrate the proxy in your setup in specific ways, such as assigning FTP traffic to a specific queue. For these and other finer points of <code class="literal">ftp-proxy</code> configuration, your best bet is to start by studying the man page.</p><p>If you’re interested in ways to run an FTP server protected by PF and <code class="literal">ftp-proxy</code>, you could look into running a separate <code class="literal">ftp-proxy</code> in reverse mode (using the <code class="literal">-R</code> option) on a separate port with its own redirecting <code class="literal">pass</code> rule. It’s even possible to set up the proxy to run in IPv6 mode, but if you’re ahead of the pack in running the modern protocol, you’re less likely to bother with FTP as your main file transfer protocol.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note01"/>Note</h3><p><span class="emphasis"><em>If your PF version predates the ones described here, you’re running on an outdated, unsupported operating system. I strongly urge you to schedule an operating system upgrade as soon as possible. If an upgrade is for some reason not an option, please look up the first edition of this book and study the documentation for your operating system for information on how to use some earlier FTP proxies.</em></span></p></div></div></div><div class="sect1" title="Making Your Network Troubleshooting-Friendly"><div class="titlepage"><div><div><h2 class="title" id="making_your_network_troubleshooting-frie" style="clear: both">Making Your Network Troubleshooting-Friendly</h2></div></div></div><p>Making your network troubleshooting-friendly is a potentially large subject. Generally, the debugging- or troubleshooting-friendliness of your TCP/IP network depends on how you treat the Internet protocol that was designed specifically with debugging in mind: ICMP.</p><p>ICMP is the protocol for sending and receiving <span class="emphasis"><em>control messages</em></span> between hosts and gateways, mainly to provide feedback to a sender about any unusual or difficult conditions en route to the target host.</p><p>There’s a lot of ICMP traffic, which usually happens in the background while you are surfing the Web, reading mail, or transferring files. Routers <a class="indexterm" id="iddle1219"/><a class="indexterm" id="iddle1348"/><a class="indexterm" id="iddle1351"/><a class="indexterm" id="iddle1352"/><a class="indexterm" id="iddle1597"/><a class="indexterm" id="iddle1612"/><a class="indexterm" id="iddle1670"/><a class="indexterm" id="iddle1997"/>(remember, you’re building one) use ICMP to negotiate packet sizes and other transmission parameters in a process often referred to as <span class="emphasis"><em>path MTU discovery</em></span>.</p><p>You may have heard admins refer to ICMP as either “evil” or, if their understanding runs a little deeper, “a necessary evil.” The reason for this attitude is purely historical. A few years back, it was discovered that the networking stacks of several operating systems contained code that could make the machine crash if it were sent a sufficiently large ICMP request.</p><p>One of the companies that was hit hard by this was Microsoft, and you can find a lot of material on the <span class="emphasis"><em>ping of death</em></span> bug by using your favorite search engine. However, this all happened in the second half of the 1990s, and all modern operating systems have thoroughly sanitized their network code since then (at least, that’s what we’re led to believe).</p><p>One of the early work-arounds was to simply block either ICMP echo (ping) requests or even all ICMP traffic. That measure almost certainly led to poor performance and hard-to-debug network problems. In some places, however, these rule sets have been around for almost two decades, and the people who put them there are still scared. There’s most likely little to no reason to worry about destructive ICMP traffic anymore, but here we’ll look at how to manage just what ICMP traffic passes to or from your network.</p><p>In modern IPv6 networks, the updated <code class="literal">icmp6</code> protocol plays a more crucial role than ever in parameter passing and even host configuration, and network admins are playing a high-stakes game while learning the finer points of blocking or passing <code class="literal">icmp6</code> traffic. To a large extent, issues that are relevant for IPv4 ICMP generally apply to IPv6 ICMP6 as well, but in addition, ICMP6 is used for several mechanisms that were handled differently in IPv4. We’ll dip into some of these issues after walking through the issues that are relevant for both IP protocol versions.</p><div class="sect2" title="Do We Let It All Through?"><div class="titlepage"><div><div><h3 class="title" id="do_we_let_it_all_throughquestion_mark">Do We Let It All Through?</h3></div></div></div><p>The obvious question becomes, “If ICMP is such a good and useful thing, shouldn’t we let it all through all the time?” The answer is that it depends.</p><p>Letting diagnostic traffic pass unconditionally makes debugging easier, of course, but it also makes it relatively easy for others to extract information about your network. So, a rule like the following might not be optimal if you want to cloak the internal workings of your IPv4 network:</p><a id="pro_id00058"/><pre class="programlisting">pass inet proto icmp</pre><p>If you want the same free flow of messages for your IPv6 traffic, the corresponding rule is this:</p><a id="pro_id00059"/><pre class="programlisting">pass inet6 proto icmp6</pre><p>In all fairness, it should also be said that you might find some ICMP and ICMP6 traffic quite harmlessly riding piggyback on your <code class="literal">keep state</code> rules.</p></div><div class="sect2" title="The Easy Way Out: The Buck Stops Here"><div class="titlepage"><div><div><h3 class="title" id="easy_way_out_the_buck_stops_here">The Easy Way Out: The Buck Stops Here</h3></div></div></div><p><a class="indexterm" id="iddle1349"/><a class="indexterm" id="iddle1353"/><a class="indexterm" id="iddle1599"/><a class="indexterm" id="iddle1668"/><a class="indexterm" id="iddle1669"/><a class="indexterm" id="iddle1977"/><a class="indexterm" id="iddle1978"/><a class="indexterm" id="iddle1998"/><a class="indexterm" id="iddle2000"/>The easiest solution could very well be to allow all ICMP and ICMP6 traffic from your local network through and to let probes from elsewhere stop at your gateway:</p><a id="pro_id00060"/><pre class="programlisting">pass inet proto icmp icmp-type $icmp_types from $localnet&#13;
pass inet6 proto icmp6 icmp6-type $icmp6_types from $localnet&#13;
pass inet proto icmp icmp-type $icmp_types to $ext_if&#13;
pass inet6 proto icmp6 icmp6-type $icmp6_types to $ext_if</pre><p>This is assuming, of course that you’ve identified the list of desirable ICMP and ICMP6 types to fill out your macro definitions. We’ll get back to those shortly. Stopping probes at the gateway might be an attractive option anyway, but let’s look at a few other options that’ll demonstrate some of PF’s flexibility.</p></div><div class="sect2" title="Letting ping Through"><div class="titlepage"><div><div><h3 class="title" id="letting_ping_through">Letting ping Through</h3></div></div></div><p>The rule set we have developed so far in this chapter has one clear disadvantage: Common troubleshooting commands, such as <code class="literal">ping</code> and <code class="literal">traceroute</code> (and their IPv6 equivalents, <code class="literal">ping6</code> and <code class="literal">traceroute6</code>), will not work. That may not matter too much to your users, and because it was the <code class="literal">ping</code> command that scared people into filtering or blocking ICMP traffic in the first place, there are apparently some people who feel we’re better off without it. However, you’ll find these troubleshooting tools useful. And with a couple of small additions to the rule set, they will be available to you.</p><p>The diagnostic commands <code class="literal">ping</code> and <code class="literal">ping6</code> rely on the ICMP and ICMP6 <span class="emphasis"><em>echo request</em></span> (and the matching <span class="emphasis"><em>echo reply</em></span>) types, and in order to keep our rule set tidy, we start by defining another set of macros:</p><a id="pro_id00061"/><pre class="programlisting">icmp_types = "echoreq"&#13;
icmp6_types = "echoreq"</pre><p>Then, we add rules that use the definitions:</p><a id="pro_id00062"/><pre class="programlisting">pass inet proto icmp icmp-type $icmp_types&#13;
pass inet6 proto icmp6 icmp6-type $icmp6_types</pre><p>The macros and the rules mean that ICMP and ICMP6 packets with type <span class="emphasis"><em>echo request</em></span> will be allowed through and matching <span class="emphasis"><em>echo replies</em></span> will be allowed to pass back due to PF’s stateful nature. This is all the <code class="literal">ping</code> and <code class="literal">ping6</code> commands need in order to produce their expected results.</p><p>If you need more or other types of ICMP or ICMP6 packets to go through, you can expand <code class="literal">icmp_types</code> and <code class="literal">icmp6_types</code> to lists of those packet types you want to allow.</p></div><div class="sect2" title="Helping traceroute"><div class="titlepage"><div><div><h3 class="title" id="helping_traceroute">Helping traceroute</h3></div></div></div><p><a class="indexterm" id="iddle1350"/><a class="indexterm" id="iddle1365"/><a class="indexterm" id="iddle1598"/><a class="indexterm" id="iddle1600"/><a class="indexterm" id="iddle1613"/><a class="indexterm" id="iddle1968"/><a class="indexterm" id="iddle1999"/><a class="indexterm" id="iddle2001"/><a class="indexterm" id="iddle2006"/>The <code class="literal">traceroute</code> command (and the IPv6 variant <code class="literal">traceroute6</code>) is useful when your users claim that the Internet isn’t working. By default, Unix <code class="literal">traceroute</code> uses UDP connections according to a set formula based on destination. The following rules work with the <code class="literal">traceroute</code> and <code class="literal">traceroute6</code> commands on all forms of Unix I’ve had access to, including GNU/Linux:</p><a id="pro_id00063"/><pre class="programlisting"># allow out the default range for traceroute(8):&#13;
# "base+nhops*nqueries-1" (33434+64*3-1)&#13;
pass out on egress inet proto udp to port 33433:33626 # For IPv4&#13;
pass out on egress inet6 proto udp to port 33433:33626 # For IPv6</pre><p>This also gives you a first taste of what port ranges look like. They’re quite useful in some contexts.</p><p>Experience so far indicates that <code class="literal">traceroute</code> and <code class="literal">traceroute6</code> implementations on other operating systems work roughly the same way. One notable exception is Microsoft Windows. On that platform, the <span class="emphasis"><em>tracert.exe</em></span> program and its IPv6 sister <span class="emphasis"><em>tracert6.exe</em></span> use ICMP echo requests for this purpose. So if you want to let Windows traceroutes through, you need only the first rule, much as when letting <code class="literal">ping</code> through. The Unix <code class="literal">traceroute</code> program can be instructed to use other protocols as well and will behave remarkably like its Microsoft counterpart if you use its <code class="literal">-I</code> command-line option. You can check the <code class="literal">traceroute</code> man page (or its source code, for that matter) for all the details.</p><p>This solution is based on a sample rule I found in an <code class="literal">openbsd-misc</code> post. I’ve found that list, and the searchable list archives (accessible among other places from <span class="emphasis"><em><a class="ulink" href="http://marc.info/" target="_top">http://marc.info/</a></em></span>), to be a valuable resource whenever you need OpenBSD or PF-related information.</p></div><div class="sect2" title="Path MTU Discovery"><div class="titlepage"><div><div><h3 class="title" id="path_mtu_discovery">Path MTU Discovery</h3></div></div></div><p>The last bit I’ll remind you about when it comes to troubleshooting is the path MTU discovery. Internet protocols are designed to be device-independent, and one consequence of device independence is that you cannot always predict reliably what the optimal packet size is for a given connection. The main constraint on your packet size is called the <span class="emphasis"><em>maximum transmission unit</em></span>, or <span class="emphasis"><em>MTU</em></span>, which sets the upper limit on the packet size for an interface. The <code class="literal">ifconfig</code> command will show you the MTU for your network interfaces.</p><p>Modern TCP/IP implementations expect to be able to determine the correct packet size for a connection through a process that simply involves sending packets of varying sizes within the MTU of the local link with the “do not fragment” flag set. If a packet then exceeds the MTU somewhere along the way to the destination, the host with the lower MTU will return an ICMP packet indicating “type 3, code 4” and quoting its local MTU when the local upper limit has been reached. Now, you don’t need to dive for the RFCs right away. Type 3 means <span class="emphasis"><em>destination unreachable</em></span>, and code 4 <a class="indexterm" id="iddle1344"/><a class="indexterm" id="iddle1354"/><a class="indexterm" id="iddle1404"/><a class="indexterm" id="iddle1423"/><a class="indexterm" id="iddle1527"/><a class="indexterm" id="iddle1528"/><a class="indexterm" id="iddle1775"/><a class="indexterm" id="iddle1776"/>is short for <span class="emphasis"><em>fragmentation needed, but the “do not fragment” flag is set</em></span>. So if your connections to other networks, which may have MTUs that differ from your own, seem suboptimal, you could try changing your list of ICMP types slightly to let the IPv4 destination-unreachable packets through:</p><a id="pro_id00064"/><pre class="programlisting">icmp_types = "{ echoreq, unreach }"</pre><p>As you can see, this means you do not need to change the <code class="literal">pass</code> rule itself:</p><a id="pro_id00065"/><pre class="programlisting">pass inet proto icmp icmp-type $icmp_types</pre><p>Now I’ll let you in on a little secret: In almost all cases, these rules aren’t necessary for purposes of path MTU discovery (but they don’t hurt either). However, even though the default PF <code class="literal">keep state</code> behavior takes care of most of the ICMP traffic you’ll need, PF does let you filter on all variations of ICMP types and codes. For IPv6, you’d probably want to let the more common ICMP6 diagnostics through, such as the following:</p><a id="pro_id00066"/><pre class="programlisting">icmp6_types = "{ echoreq unreach timex paramprob }"</pre><p>This means that we let echo requests and destination unreachable, time exceeded, and parameter problem messages pass for IPv6 traffic. Thanks to the macro definitions, you don’t need to touch the <code class="literal">pass</code> rule for the ICMP6 case either:</p><a id="pro_id00067"/><pre class="programlisting">pass inet6 proto icmp6 icmp6-type $icmp6_types</pre><p>But it’s worth keeping in mind that IPv6 hosts rely on ICMP6 messages for automatic configuration-related tasks, and you may want to explicitly filter in order to allow or deny specific ICMP6 types at various points in your network.</p><p>For example, you’ll want to let a router and its clients exchange router solicitation and router advertisement messages (ICMP6 type <code class="literal">routeradv</code> and <code class="literal">routersol</code>, respectively), while you may want to make sure that neighbor advertisements and neighbor solicitations (ICMP6 type <code class="literal">neighbradv</code> and <code class="literal">neighbrsol</code>, respectively) stay confined within their directly connected networks.</p><p>If you want to delve into more detail, the list of possible types and codes are documented in the <code class="literal">icmp(4)</code> and <code class="literal">icmp6(4)</code> man pages. The background information is available in the RFCs.<sup>[<a class="footnote" href="#ftn.ch03fn07" id="ch03fn07">19</a>]</sup></p></div></div><div class="sect1" title="Tables Make Your Life Easier"><div class="titlepage"><div><div><h2 class="title" id="tables_make_your_life_easier" style="clear: both">Tables Make Your Life Easier</h2></div></div></div><p><a class="indexterm" id="iddle1003"/><a class="indexterm" id="iddle1462"/><a class="indexterm" id="iddle1595"/><a class="indexterm" id="iddle1936"/><a class="indexterm" id="iddle1937"/><a class="indexterm" id="iddle1938"/>By now, you may be thinking that this setup gets awfully static and rigid. There will, after all, be some kinds of data relevant to filtering and redirection at a given time, but they don’t deserve to be put into a configuration file! Quite right, and PF offers mechanisms for handling those situations.</p><p><span class="emphasis"><em>Tables</em></span> are one such feature. They’re useful as lists of IP addresses that can be manipulated without reloading the entire rule set and also when fast lookups are desirable.</p><p>Table names are always enclosed in <code class="literal">&lt; &gt;</code>, like this:</p><a id="pro_id00068"/><pre class="programlisting">table &lt;clients&gt; persist { 192.168.2.0/24, !192.168.2.5 }</pre><p>Here, the network <code class="literal">192.168.2.0/24</code> is part of the table with one exception: The address <code class="literal">192.168.2.5</code> is excluded using the <code class="literal">!</code> operator (logical NOT). The keyword <code class="literal">persist</code> makes sure the table itself will exist, even if no rules currently refer to it.</p><p>It’s also possible to load tables from files where each item is on a separate line, such as the file <span class="emphasis"><em>/etc/clients</em></span>:</p><a id="pro_id00069"/><pre class="programlisting">192.168.2.0/24&#13;
!192.168.2.5</pre><p>This, in turn, is used to initialize the table in <span class="emphasis"><em>/etc/pf.conf</em></span>:</p><a id="pro_id00070"/><pre class="programlisting">table &lt;clients&gt; persist file "/etc/clients"</pre><p>So, for example, you can change one of our earlier rules to read like this to manage outgoing traffic from your client computers:</p><a id="pro_id00071"/><pre class="programlisting">pass inet proto tcp from &lt;clients&gt; to any port $client_out</pre><p>With this in hand, you can manipulate the table’s contents live, like this:</p><a id="pro_id00072"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -t clients -T add 192.168.1/16</strong></span></pre><p>Note that this changes the in-memory copy of the table only, meaning that the change will not survive a power failure or reboot, unless you arrange to store your changes.</p><p>You might opt to maintain the on-disk copy of the table with a <code class="literal">cron</code> job that dumps the table content to disk at regular intervals, using a command such as the following:</p><a id="pro_id00073"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -t clients -T show &gt;/etc/clients</strong></span></pre><p>Alternatively, you could edit the <span class="emphasis"><em>/etc/clients</em></span> file and replace the in-memory table contents with the file data:</p><a id="pro_id00074"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -t clients -T replace -f /etc/clients</strong></span></pre><p>For operations you’ll be performing frequently, sooner or later, you’ll end up writing shell scripts. It’s likely that routine operations on tables, such as inserting or removing items or replacing table contents, will be part of your housekeeping scripts in the near future.</p><p>One common example is to enforce network access restrictions via <code class="literal">cron</code> jobs that replace the contents of the tables referenced as <code class="literal">from</code> addresses in the <code class="literal">pass</code> rules at specific times. In some networks, you may even need different access rules for different days of the week. The only real limitations lie in your own needs and your creativity.</p><p>We’ll be returning to some handy uses of tables frequently over the next chapters, and we’ll look at a few programs that interact with tables in useful ways.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch03fn01"><p><sup>[<a class="para" href="#ch03fn01">13</a>] </sup>In fact, the <code class="literal">keep state</code> part denotes the default behavior and is redundant if you’re working with a PF version taken from OpenBSD 4.1 or later. However, there’s generally no need to remove the specification from existing rules you come across when upgrading from earlier versions. To ease the transition, the examples in this book will make this distinction when needed.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch03fn02"><p><sup>[<a class="para" href="#ch03fn02">14</a>] </sup>RFC 1631, “The IP Network Address Translator (NAT),” dated May 1994, and RFC 1918, “Address Allocation for Private Internets,” dated February 1996, provide the details about NAT.</p></div><div class="footnote" id="ftn.ch03fn03"><p><sup>[<a class="para" href="#ch03fn03">15</a>] </sup>To quote the project home page at <span class="emphasis"><em><a class="ulink" href="http://www.kame.net/" target="_top">http://www.kame.net/</a></em></span>, “The KAME project was a joint effort of six companies in Japan to provide a free stack of IPv6, IPsec, and Mobile IPv6 for BSD variants.” The main research and development activities were considered complete in March 2006, with only maintenance activity continuing now that the important parts have been incorporated into the relevant systems.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch03fn04"><p><sup>[<a class="para" href="#ch03fn04">16</a>] </sup>This is true unless, of course, the information changed in the meantime. Some sysadmins are fond of practical jokes, but most of the time changes in DNS zone information are due to real-world needs in that particular organization or network.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch03fn05"><p><sup>[<a class="para" href="#ch03fn05">17</a>] </sup>The earliest RFC describing the FTP protocol is RFC 114, dated April 10, 1971. The switch to TCP/IP happened with FTP version 5, as defined in RFCs 765 and 775, dated June and December 1980, respectively.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch03fn06"><p><sup>[<a class="para" href="#ch03fn06">18</a>] </sup>An encrypted version of the protocol, dubbed FTPS, is specified in RFC4217, but support remains somewhat spotty.</p></div><div class="footnote" id="ftn.ch03fn07"><p><sup>[<a class="para" href="#ch03fn07">19</a>] </sup>The main RFCs describing ICMP and some related techniques are 792, 950, 1191, 1256, 2521, and 6145. ICMP updates for IPv6 are in RFC 3542 and RFC 4443. These documents are available in a number of places on the Web, such as <span class="emphasis"><em><a class="ulink" href="http://www.ietf.org/" target="_top">http://www.ietf.org/</a></em></span> and <span class="emphasis"><em><a class="ulink" href="http://www.faqs.org/" target="_top">http://www.faqs.org/</a></em></span>, and probably also via your package system.</p></div></div></section></body></html>