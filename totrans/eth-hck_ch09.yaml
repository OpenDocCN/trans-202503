- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: FUZZING FOR ZERO-DAY VULNERABILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**为零日漏洞进行模糊测试**'
- en: '*Asking the right questions takes as much skill as giving the right answers.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*提出正确的问题和给出正确的答案一样需要技巧。*'
- en: –Robert Half
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 罗伯特·哈夫
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: What happens if an attacker scans a system and doesn’t find any known vulnerabilities?
    Can they still gain access? Yes, but they’ll need to discover a new, unknown vulnerability.
    These unknown vulnerabilities are called *zero-day* vulnerabilities, and useful
    ones can sell for millions of dollars.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者扫描一个系统并没有找到任何已知的漏洞，会发生什么？他们仍然能获得访问权限吗？是的，但他们需要发现一个新的、未知的漏洞。这些未知的漏洞被称为*零日*漏洞，而有价值的漏洞可以卖到数百万美元。
- en: 'Finding a zero-day vulnerability often begins with finding a software bug.
    Once a hacker discovers a bug, they can exploit it to their advantage. Attackers
    use bugs to steal data, crash programs, take control of systems, and install malware.
    Let’s start by exploiting a famous bug that led to the Heartbleed vulnerability
    that crippled the internet. Then we’ll explore three techniques used to discover
    bugs: fuzzing, symbolic execution, and dynamic symbolic execution.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 发现一个零日漏洞通常始于发现一个软件错误。一旦黑客发现了漏洞，他们就能利用它为自己谋利。攻击者利用漏洞窃取数据、崩溃程序、控制系统并安装恶意软件。让我们从利用一个著名的漏洞开始，这个漏洞导致了使互联网瘫痪的Heartbleed漏洞。然后，我们将探讨发现漏洞的三种技术：模糊测试、符号执行和动态符号执行。
- en: '**Case Study: Exploiting the Heartbleed OpenSSL Vulnerability**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：利用Heartbleed OpenSSL漏洞**'
- en: The *Heartbleed vulnerability* takes advantage of a software bug in an OpenSSL
    extension called Heartbeat. This extension allows a client to check if a server
    is still online by sending a Heartbeat request message. If the server is online,
    it replies with a Heartbeat response message.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Heartbleed漏洞*利用了一个在OpenSSL扩展“Heartbeat”中的软件错误。这个扩展允许客户端通过发送心跳请求消息来检查服务器是否在线。如果服务器在线，它会回复一个心跳响应消息。'
- en: After the server stores the Heartbeat request message in its memory, it responds
    by reading its memory and returning the same message in the Heartbeat response.
    It uses the stated length of the Heartbeat message to decide how much of its memory
    it should read and send back.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器将心跳请求消息存储到内存后，它会通过读取内存并返回相同的消息来响应。它使用心跳消息中声明的长度来决定应该读取多少内存并发送回去。
- en: Here’s the bug. If a hacker sends a Heartbeat request message with a length
    longer than the actual request, the server will include additional parts of its
    memory in the response, some of which may contain sensitive information. [Figure
    9-1](ch09.xhtml#ch9fig1) illustrates this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是漏洞。如果黑客发送一个心跳请求消息，其长度超过实际请求，服务器会在响应中包含其内存的其他部分，其中可能包含敏感信息。[图 9-1](ch09.xhtml#ch9fig1)展示了这一点。
- en: '![image](../images/ch09fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig01.jpg)'
- en: '*Figure 9-1: An overview of the Heartbleed vulnerability*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：Heartbleed漏洞概述*'
- en: The hacker was able to read the contents of the server’s memory, which included
    passwords and private keys. This type of attack is called a *buffer over-read*,
    as we can read beyond the bounds of the designated memory buffer. Similarly, in
    a buffer overflow attack, a hacker uses a bug to write beyond the bounds of a
    designated buffer. Hackers often use buffer overflow attacks to upload reverse
    shells that allow them to control the machine remotely. This process is called
    *remote code execution (RCE)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客能够读取服务器内存的内容，其中包括密码和私钥。这种攻击被称为*缓冲区过度读取*，因为我们可以读取超出指定内存缓冲区的内容。类似地，在缓冲区溢出攻击中，黑客利用漏洞写入超出指定缓冲区的内容。黑客常常利用缓冲区溢出攻击上传反向shell，允许他们远程控制机器。这个过程被称为*远程代码执行（RCE）*。
- en: Why can’t we fix this bug by making all heartbeat messages a fixed length? Because
    Heartbeat messages also measure the *maximum transmission unit (MTU)* of the client’s
    path to the server. The MTU is the maximum size of the packets sent along that
    path. As packets move through the network, they pass through a collection of routers.
    Depending on its design, each router handles packets up to a specific size. If
    a router receives a packet that is larger than its MTU, it breaks the packet into
    smaller packets, a process called *fragmentation*. These fragmented packets are
    then reassembled when they reach the server. By probing the network with Heartbeat
    request messages of different lengths, the client can discover the MTU, along
    with its path, and avoid fragmentation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能通过使所有心跳消息为固定长度来修复这个漏洞呢？因为心跳消息还会测量客户端到服务器路径的*最大传输单元（MTU）*。MTU是沿着该路径发送的数据包的最大大小。数据包在网络中传输时，会经过一系列路由器。根据路由器的设计，每个路由器只能处理一定大小的数据包。如果路由器收到一个大于其MTU的数据包，它会将数据包拆分成更小的数据包，这个过程称为*分片*。这些分片的数据包在到达服务器时会重新组装。通过发送不同长度的心跳请求消息来探测网络，客户端可以发现MTU以及其路径，从而避免分片。
- en: '***Creating an Exploit***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建利用工具***'
- en: 'After you’ve found a bug the next question is how to exploit it to your advantage.
    Exploiting a bug is an intricate process, as writing your own exploits requires
    a detailed understanding of the system. The bug you’ve discovered is most likely
    specific to a particular software version, so the exploit you write must also
    be specific to that software version. If the software developers fix the bug,
    you’ll no longer be able to exploit it. This is one of the reasons that state
    actors are so secretive about their capabilities. Knowledge of the bug will allow
    an adversary to fix it, after which the state actor’s exploit will no longer work.
    The cycle continues: old vulnerabilities are patched, and new vulnerabilities
    are found.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你发现漏洞之后，接下来的问题就是如何利用它为自己谋取利益。利用漏洞是一个复杂的过程，因为编写你自己的利用工具需要对系统有深入的理解。你发现的漏洞很可能特定于某个特定的软件版本，所以你编写的利用工具也必须针对该软件版本。如果软件开发者修复了这个漏洞，你将无法再利用它。这也是国家行为者对其能力保持高度保密的原因之一。漏洞的知识使得对手能够修复它，修复后国家行为者的利用工具将不再有效。这个循环持续着：旧的漏洞被修复，新的漏洞被发现。
- en: The Heartbleed bug predates the release of TLS 1.3, so TLS messages exchanged
    during the Heartbleed attack conform to the TLS 1.2 protocol. [Figure 9-2](ch09.xhtml#ch9fig2)
    shows the messages exchanged during the attack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed漏洞存在于TLS 1.3发布之前，因此Heartbleed攻击期间交换的TLS消息符合TLS 1.2协议。[图9-2](ch09.xhtml#ch9fig2)展示了攻击过程中交换的消息。
- en: '![image](../images/ch09fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig02.jpg)'
- en: '*Figure 9-2: Messages exchanged between a client and server during a Heartbleed
    attack*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：客户端和服务器在Heartbleed攻击期间交换的消息*'
- en: The client initiates the connection by sending a *Client Hello* message, and
    the server responds with several messages that end with a final *Server Done*
    message. As soon as we receive the *Server Done* message, we’ll respond with a
    malicious Heartbeat request, after which the server will send a collection of
    Heartbeat responses containing the leaked information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过发送*Client Hello*消息来发起连接，服务器则通过多个消息进行响应，最后以*Server Done*消息结束。一旦我们收到*Server
    Done*消息，我们会响应一个恶意的心跳请求，随后服务器将发送一系列包含泄露信息的心跳响应。
- en: '***Starting the Program***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动程序***'
- en: Let’s write a Python program that exploits the Heartbleed bug. The program will
    be longer than the programs we normally write, so instead of showing a single
    block of code, I’ll break the program up into sections and discuss each section
    individually. You can reconstruct the program by copying each section into a file
    called *heartbleed.py*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Python程序来利用Heartbleed漏洞。这个程序会比我们通常编写的程序要长，因此我将不展示一个完整的代码块，而是将程序分成多个部分，分别讨论每一部分。你可以通过将每一部分复制到一个名为*heartbleed.py*的文件中来重构这个程序。
- en: Before we begin coding, let’s discuss the general overview of the exploit. We’ll
    begin by establishing a socket connection to the server. Then, we’ll manually
    initiate a TLS connection by sending a client *hello* message. After we’ve sent
    the *hello* message, we’ll continue to receive packets until we receive the *Server
    Done* message. Once we’ve received this message, we’ll transmit an empty Heartbeat
    message with a stated length of 64KB. We chose 64KB because it’s the maximum possible
    length and will allow us to extract the most information. If the server is vulnerable,
    it will respond with 64KB of its memory. Because each Heartbeat packet can hold
    only 16KB of data, the 64KB response will be split across four packets. By printing
    the contents of these packets, we can read parts of the server’s memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，先讨论一下漏洞利用的总体概况。我们将首先与服务器建立套接字连接。然后，我们将手动启动TLS连接，发送客户端*hello*消息。在发送*hello*消息后，我们将继续接收数据包，直到收到*Server
    Done*消息。一旦收到此消息，我们将发送一个空的心跳消息，长度为64KB。我们选择64KB，因为这是可能的最大长度，并且将允许我们提取最多的信息。如果服务器存在漏洞，它将以64KB的内存数据作出响应。由于每个心跳数据包最多只能容纳16KB数据，64KB的响应将分为四个数据包发送。通过打印这些数据包的内容，我们可以读取服务器内存的部分内容。
- en: 'Let’s begin by importing the libraries we’ll use throughout the process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先导入在整个过程中使用的库：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll use command line arguments to pass options to our program, so we’ll need
    the `sys` library to read these arguments. Then we’ll use the `socket` and `select`
    libraries to establish a TCP socket connection to the vulnerable server. Lastly,
    we’ll use the `struct` and `array` libraries to extract and package the bytes
    associated with each field in the packets we receive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行参数将选项传递给程序，因此我们需要`sys`库来读取这些参数。然后，我们将使用`socket`和`select`库与易受攻击的服务器建立TCP套接字连接。最后，我们将使用`struct`和`array`库来提取和打包我们接收的数据包中每个字段的字节。
- en: '***Writing the Client Hello Message***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写客户端Hello消息***'
- en: Next, we’ll construct the client’s *hello* message, which is the first message
    sent by the TLS 1.2 protocol. (The IETF outlines the TLS 1.2 specification in
    RFC 5246\. We’ll use this specification to construct the packets that we’ll send
    in this chapter.) [Figure 9-3](ch09.xhtml#ch9fig3) represents the layout of each
    bit in the *Client Hello* packet. The numbers at the top present each bit, numbered
    from 0 to 31, and the labels represent the fields and their positions in the packet.
    You’ll commonly find diagrams like these in the IETF’s RFC documents, which describe
    protocols.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构造客户端的*hello*消息，这是TLS 1.2协议发送的第一个消息。（IETF在RFC 5246中概述了TLS 1.2的规范。我们将使用此规范来构建本章中要发送的数据包。）[图9-3](ch09.xhtml#ch9fig3)表示*Client
    Hello*数据包中每个比特的布局。顶部的数字表示每个比特，从0到31编号，标签表示数据包中各字段及其位置。你常常可以在IETF的RFC文档中看到这样的图示，这些文档描述了协议。
- en: '![image](../images/ch09fig03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig03.jpg)'
- en: '*Figure 9-3: The structure of a TLS handshake packet*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：TLS握手数据包的结构*'
- en: All packets in the TLS 1.2 protocol begin with a *Type* field. This field identifies
    the type of packet being sent. All messages associated with the TLS 1.2 handshake
    are assigned the type 0x16, indicating they are a part of the handshake record.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2协议中的所有数据包都以*类型*字段开始。该字段标识发送的数据包类型。与TLS 1.2握手相关的所有消息都被分配为类型0x16，表示它们是握手记录的一部分。
- en: The next 16 bits represent the *TLS Version*, and a value of 0x0303 represents
    version 1.2\. The 16 bits after that represent the *Packet Length*, which is the
    total length of the packet in bytes. Next is the 8-bit *Message Type* (see [Figure
    9-2](ch09.xhtml#ch9fig2) for a list of the types of messages exchanged during
    a TLS v1.2 handshake). A value of 0x01 represents a *Client Hello* message. Following
    that is 24 bits indicating the *Message Length*, that is, the number of bytes
    remaining in the packet. Then comes the 16-bit *Client TLS Version*, which is
    the version of TLS that the client is currently running, and the 32-bit *Client
    Random*, a nonce supplied during the TLS exchange.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的16个比特表示*TLS版本*，值为0x0303表示版本1.2。之后的16个比特表示*数据包长度*，即数据包的总字节长度。接下来是8位的*消息类型*（有关TLS
    v1.2握手过程中交换的消息类型列表，请参见[图9-2](ch09.xhtml#ch9fig2)）。值为0x01表示*Client Hello*消息。紧接着是24个比特，表示*消息长度*，即数据包中剩余的字节数。然后是16位的*客户端TLS版本*，表示客户端当前运行的TLS版本，以及32位的*客户端随机数*，这是TLS交换过程中提供的一个随机数。
- en: The next eight bits represent the *Session ID Length*. The Session ID identifies
    the session and is used to resume incomplete or failed sessions. We won’t use
    this field, and as you’ll see, we’ll set its length to 0x00\. The *Cipher Suite
    Length* is the length in bytes of the next field, which contains the *Cipher Suites*.
    In this case we will set the value of this field to 0x00,0x02 to indicate that
    the supported cipher suite information is two bytes long. As for the types of
    ciphers the client supports, we will use the value 0x00, 0x2f, indicating that
    the client supports RSA for key exchange and uses the 128-bit AES and a cipher
    block chaining mode for encryption (see [Chapter 5](ch05.xhtml#ch5) for more information
    on block cipher modes). The final 16 bits represent the *Extension Length*. We’re
    not using any extensions, so we’ll set this value to 0.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的八个比特表示*Session ID Length*。Session ID用于标识会话，并用于恢复未完成或失败的会话。我们不使用此字段，正如你将看到的，我们将其长度设置为0x00。*Cipher
    Suite Length*是下一个字段的字节长度，该字段包含*Cipher Suites*。在这种情况下，我们将该字段的值设置为0x00,0x02，表示支持的密码套件信息长为两个字节。至于客户端支持的密码类型，我们将使用值0x00,0x2f，表示客户端支持RSA密钥交换，并使用128位AES和密码块链接模式进行加密（有关块密码模式的更多信息，请参见[第5章](ch05.xhtml#ch5)）。最后16个比特表示*Extension
    Length*。我们不使用任何扩展，因此将该值设置为0。
- en: 'We can manually construct the packet by setting each of the bytes (sets of
    eight bits) ourselves. We’ll represent the values as hexadecimal numbers. Copy
    the following code snippet into your *heartbleed.py* file; I’ve pointed out each
    hexadecimal value using comments:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动设置每个字节（每组八位）来构造数据包。我们将以十六进制数表示这些值。将以下代码片段复制到你的*heartbleed.py*文件中；我已经用注释标出了每个十六进制值：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Great, we’ve constructed the *Client Hello* message. But before we send it,
    let’s discuss the structure of the packets we’ll receive in response.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经构造了*Client Hello*消息。但是在发送之前，让我们讨论一下我们将在响应中接收到的数据包结构。
- en: '***Reading the Server Response***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取服务器响应***'
- en: The server will transmit four packets, all of which have a similar structure
    to the *Client Hello* message. The type, version, packet length, and message type
    fields appear in the same location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将传输四个数据包，所有数据包的结构与*Client Hello*消息相似。类型、版本、数据包长度和消息类型字段出现在相同的位置。
- en: We can detect the *Server Done* message by inspecting the *Message Type*, located
    at the sixth byte. A hexadecimal value of 0x02 represents the *Server Hello*,
    whereas values of 0x0b, 0x0c and 0x0e represent the *Server Certificate* message,
    *Server Key Exchange* message, and *Server Done* message, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查第六个字节的*Message Type*来检测*Server Done*消息。十六进制值0x02表示*Server Hello*，而值0x0b、0x0c和0x0e分别表示*Server
    Certificate*消息、*Server Key Exchange*消息和*Server Done*消息。
- en: 'We’re not interested in actually establishing an encrypted connection, so we
    can ignore all the messages we receive from the server until we get the *Server
    Done* message. Once we’ve received this message, we’ll know that the server has
    completed its part of the handshake and we can now send our first Heartbeat message.
    Create a constant to hold the hexadecimal value representing the type *Server
    Done*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不关心实际建立加密连接，因此可以忽略从服务器收到的所有消息，直到收到*Server Done*消息。一旦我们收到该消息，就意味着服务器已经完成了握手的部分工作，我们现在可以发送第一个心跳消息。创建一个常量来保存表示类型*Server
    Done*的十六进制值：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s write a helper function that will ensure we correctly receive all
    the bytes associated with the TLS packet. This function will let us receive a
    fixed number of bytes from a socket. The function will wait for the operating
    system to finish loading bytes into the socket’s buffer and then will continue
    reading from the buffer until it has read the specified number of bytes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个辅助函数，确保我们正确接收与TLS数据包相关的所有字节。这个函数将使我们从套接字接收固定数量的字节。该函数将等待操作系统将字节加载到套接字的缓冲区中，然后继续从缓冲区读取，直到读取到指定数量的字节：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `select()` function to monitor the socket ➊. After the operating
    system has written to the buffer, the `select()` function will unblock and allow
    the program to progress to the next line. The `select()` function takes three
    parameters, which represent lists of communication channels to monitor. The first
    list contains channels that are readable, the second contains channels that are
    writable, and the third contains channels that should be monitored for errors.
    When a socket becomes readable or writable, or contains errors, it is returned
    by the `select()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`select()`函数来监控套接字 ➊。在操作系统将数据写入缓冲区后，`select()`函数将解除阻塞并允许程序继续执行到下一行。`select()`函数接受三个参数，表示要监控的通信通道的列表。第一个列表包含可读的通道，第二个包含可写的通道，第三个包含应监控错误的通道。当套接字变为可读或可写，或发生错误时，`select()`函数将返回该套接字。
- en: Then, the socket attempts to read the remaining bytes from the socket buffer
    ➋. The parameter represents the maximum number of bytes to read. If this is less
    than the maximum number of bytes available, the socket `recv()` function will
    read as many bytes as are available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，套接字尝试从套接字缓冲区读取剩余字节 ➋。该参数表示要读取的最大字节数。如果可用字节数小于最大字节数，套接字的`recv()`函数将读取所有可用的字节。
- en: 'The next function we’ll write will read packets from the socket and extract
    their type, version, and payload:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要编写的函数将从套接字中读取数据包，并提取其类型、版本和有效负载：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We read six bytes (0, 1, 2, 3, 4, and 5) from the socket ➊. These six bytes
    represent the header fields associated with TLS 1.2 packets discussed earlier:
    type, version, length, and message type.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从套接字 ➊中读取六个字节（0、1、2、3、4和5）。这六个字节表示与TLS 1.2数据包相关的头字段：类型、版本、长度和消息类型。
- en: Then, we’ll use the `struct` library to unpack the bytes into four variables
    ➋. The greater than sign (>) tells the `struct` library to interpret the bits
    in big-endian format. (In the big-endian format, the most significant byte is
    at the smallest address. Network packets are normally in big-endian format.) The
    `B` tells the `struct` library to extract the first byte (8 bits) as an unsigned
    char (a value between 0 and 255), and the `H` tells the `struct` library to extract
    the next two bytes (16 bits) as an unsigned short. We place the first 8-bit value
    into the `type` variable and the next two bytes into the `version` variable. Then
    we place the following two bytes in the `length` variable and the final byte in
    the `msgType` variable. The `length` field represents the length of the payload.
    If it’s greater than 0 ➌, we can read the remaining bytes associated with the
    packet from the socket.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`struct`库将字节解包成四个变量 ➋。大于符号（>）告诉`struct`库以大端格式解释这些字节。（在大端格式中，最重要的字节位于最小地址。网络数据包通常采用大端格式。）`B`告诉`struct`库提取第一个字节（8位）作为无符号字符（值在0到255之间），而`H`告诉`struct`库提取接下来的两个字节（16位）作为无符号短整数。我们将第一个8位值放入`type`变量，将接下来的两个字节放入`version`变量。然后，我们将接下来的两个字节放入`length`变量，最后一个字节放入`msgType`变量。`length`字段表示有效负载的长度。如果它大于0
    ➌，我们可以从套接字中读取与数据包相关的剩余字节。
- en: All messages have a similar structure, so we can reuse the same `readPacket`
    method for all subsequent packets we receive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息具有类似的结构，因此我们可以重用相同的`readPacket`方法来处理所有后续接收到的数据包。
- en: '***Crafting the Malicious Heartbeat Request***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造恶意心跳请求***'
- en: Once we’ve received the *Server Done* message, we can send the Heartbeat request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到*服务器完成*消息，我们就可以发送心跳请求。
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) represents the layout of a Heartbeat packet.
    Both the request and response packets follow this structure. The sixth byte identifies
    whether the packet is either a response or request.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch9fig4)表示了一个心跳包的布局。请求和响应包都遵循这个结构。第六个字节标识该包是响应包还是请求包。'
- en: '![image](../images/ch09fig04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig04.jpg)'
- en: '*Figure 9-4: A malicious Heartbeat packet*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：一个恶意心跳包*'
- en: 'Our malformed request message looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的格式错误的请求消息如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the discrepancy between the packet length ➊ of 3 bytes (which represents
    the remaining bytes in the packet) and the payload length ➋ of 64KB. Shouldn’t
    the packet length include payload length? How is it possible that the payload
    length is larger than the total packet size?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包长度 ➊（表示包中剩余字节）和有效负载长度 ➋（64KB）之间的差异。包长度不应该包括有效负载长度吗？怎么可能有效负载长度大于整个包的大小呢？
- en: This is the “malformed” aspect of the request. Remember from [Figure 9-1](ch09.xhtml#ch9fig1)
    that we’re specifying a payload length of 64KB, which is the largest we can specify
    with the allotted 16 bits, but that the actual payload size is 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是请求的“格式错误”部分。请记住从[图9-1](ch09.xhtml#ch9fig1)中看到的，我们指定了64KB的负载长度，这是我们可以在分配的16位中指定的最大值，但实际的负载大小为0。
- en: '***Reading the Leaked Memory Contents***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取泄露的内存内容***'
- en: 'As mentioned earlier, Heartbeat packets are limited to a maximum length of
    16KB. This means that the 64KB of memory the server sends in response will be
    split across four 16KB packets. Let’s write the function that will read all four
    packets from the socket and combine their payloads into a single 64KB payload:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，心跳数据包的最大长度为16KB。这意味着服务器响应的64KB内存将被分割成四个16KB的数据包。让我们编写一个函数，从套接字读取所有四个数据包，并将它们的负载合并成一个单一的64KB负载：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We call the `readPacket()` function four times to read the four Heartbeat responses
    we expect from the vulnerable server ➊. Then, we combine all the payloads of the
    four responses into a single payload ➋.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`readPacket()`函数四次，以读取我们预期从易受攻击的服务器获得的四个心跳响应 ➊。然后，我们将四个响应的所有负载合并成一个单一的负载
    ➋。
- en: '***Writing the Exploit Function***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写利用函数***'
- en: 'The following code snippet implements the `exploit()` function, which will
    send the malformed Heartbeat request and read the four Heartbeat response packets:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了`exploit()`函数，该函数将发送格式错误的心跳请求并读取四个心跳响应数据包：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The type value of `0x15` indicates a Heartbeat response packet ➊. Next, we send
    the malformed request ➋, and then we read the four response packets ➌. Lastly,
    we print the payload ➍.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x15`的类型值表示一个心跳响应数据包 ➊。接下来，我们发送格式错误的请求 ➋，然后读取四个响应数据包 ➌。最后，我们打印负载 ➍。'
- en: '***Putting It Together***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将所有内容结合起来***'
- en: 'In the program’s main method, we’ll create the socket, send the packets, and
    wait for the *Server Done* response. Copy the following code into your file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的主方法中，我们将创建套接字，发送数据包，并等待*服务器完成*响应。将以下代码复制到你的文件中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After we’ve created the socket, we can connect to the IP address that was passed
    as a command line argument ➊. We’ll connect on port 443 because it’s associated
    with the TLS protocol we’re attacking. Once connected, we initiate the TLS v1.2
    connection by sending the *Client Hello* message ➋. Then, we’ll listen for the
    response messages and inspect each type until we receive the *Server Done* message
    ➌. Lastly, we call the `exploit()` function ➍.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了套接字之后，我们可以连接到作为命令行参数传入的IP地址 ➊。我们将在443端口连接，因为它与我们正在攻击的TLS协议相关联。连接后，我们通过发送*客户端Hello*消息
    ➋来启动TLS v1.2连接。然后，我们将监听响应消息并检查每种类型，直到收到*服务器完成*消息 ➌。最后，我们调用`exploit()`函数 ➍。
- en: '**Fuzzing**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模糊测试**'
- en: How do hackers find bugs like Heartbleed? As you just saw, the process of exploiting
    this bug is so intricate that it’s amazing anyone could possibly discover it using
    efficient means. There’s even an entire team at Google, called Project Zero, dedicated
    to finding zero-day vulnerabilities. (In case you’re interested, the team posts
    new vulnerabilities they discover on its blog at *[https://googleprojectzero.blogspot.com/](https://googleprojectzero.blogspot.com/)*.)
    Let’s discuss some of the tools and techniques attackers and security researchers
    use to discover bugs like Heartbleed, beginning with a testing technique called
    *fuzzing*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客是如何发现像Heartbleed这样的漏洞的？正如你刚才看到的，利用这个漏洞的过程如此复杂，令人惊讶的是任何人能用高效的方法发现它。Google甚至有一个专门的团队，叫做Project
    Zero，专门负责发现零日漏洞。（如果你感兴趣，这个团队会在它的博客上发布它们发现的新漏洞，地址是* [https://googleprojectzero.blogspot.com/](https://googleprojectzero.blogspot.com/)*。）接下来，我们将讨论一些攻击者和安全研究人员用来发现像Heartbleed这样的漏洞的工具和技术，从一种名为*模糊测试*的测试技术开始。
- en: Fuzzing techniques attempt to generate inputs that explore all the possible
    paths in a program in the hopes of discovering one that will cause the program
    to crash or exhibit unintended behavior. Fuzzing was first proposed in 1988 by
    Barton Miller, a professor at the University of Wisconsin. Since then, companies
    like Google and Microsoft have developed their own fuzzers (tools for fuzzing)
    and use fuzzing to test their own systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试技术试图生成输入，探索程序中的所有可能路径，希望能发现一个导致程序崩溃或表现出非预期行为的路径。模糊测试最早由威斯康星大学的教授巴顿·米勒（Barton
    Miller）于1988年提出。从那时起，像Google和Microsoft这样的公司开发了自己的模糊测试工具，并使用模糊测试来测试他们的系统。
- en: '***A Simplified Example***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个简化的例子***'
- en: 'To understand the basic concept behind fuzzing, we’ll begin by considering
    the following example function, originally proposed by Jeff Foster at Tufts University:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解模糊测试的基本概念，我们将从考虑以下示例函数开始，该函数最初由塔夫茨大学的Jeff Foster提出：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the function accepts three parameters, `a`, `b`, and `c`, and
    it is considered to have executed correctly as long as its internal variables
    (`x`,`y`, and `z`) don’t add up to three. If they do, the program’s `assert` statement,
    which for the purposes of this example represents a critical failure, will be
    triggered.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数接受三个参数，`a`、`b`和`c`，只要它的内部变量（`x`、`y`和`z`）的总和不等于3，程序就认为执行正确。如果它们的总和为3，程序的`assert`语句将被触发，对于这个例子而言，`assert`语句代表一个关键失败。
- en: Our goal as fuzzers is to cause this failure. Can you identify the parameter
    values that will cause the `assert` statement to be triggered? One way to determine
    which inputs trigger the `assert` statement is to visualize the paths through
    the program as a tree. Every time we encounter an `if` statement, the tree branches
    to represent two possible options, one in which the branch is taken and the one
    in which it isn’t. [Figure 9-5](ch09.xhtml#ch9fig5) shows the paths in the preceding
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为模糊测试者的目标是引发这个失败。你能找出导致`assert`语句被触发的参数值吗？确定哪些输入会触发`assert`语句的一种方法是将程序的路径可视化为一棵树。每次遇到`if`语句时，树会分支，表示两种可能的选项：一种是分支被执行，另一种是没有执行。[图9-5](ch09.xhtml#ch9fig5)展示了前述函数的路径。
- en: '![image](../images/ch09fig05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig05.jpg)'
- en: '*Figure 9-5: A visualization of the execution paths in the test function*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：测试函数执行路径的可视化*'
- en: One of these paths triggers the `assert` statement. Consider what would happen
    if we supplied inputs of 0, 2, and 1 for `a`, `b`, and `c`. In Python, 0 is equivalent
    to `False`, whereas non-zero integers are considered `True`. Trace the path that
    the input takes through the tree. Notice that this path sets `x` to 0, `y` to
    1, and `z` to 2, which triggers the `assert` statement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径中的一条会触发`assert`语句。考虑如果我们为`a`、`b`和`c`提供输入值0、2和1会发生什么。在Python中，0等价于`False`，而非零整数被视为`True`。追踪这些输入在树中的路径。注意，这条路径将`x`设置为0，`y`设置为1，`z`设置为2，从而触发了`assert`语句。
- en: '***Writing Your Own Fuzzer***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写你自己的模糊测试器***'
- en: We had no trouble discovering a harmful input in the last example, but in larger
    programs, there could be millions of unique paths. Exploring them by hand would
    be very difficult.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们没有遇到发现有害输入的困难，但在更大的程序中，可能会有数百万条独特的路径。手动探索这些路径将非常困难。
- en: Could we write a program to generate test inputs? One approach would be to randomly
    generate inputs and wait for them to exercise all the paths in the program. This
    technique is called *random fuzzing*. Let’s write a basic random fuzzer. Our program
    will generate random integer values and pass those values to our test program’s
    parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否编写一个程序来生成测试输入？一种方法是随机生成输入，并等待它们执行程序中的所有路径。这种技术被称为*随机模糊测试*。让我们编写一个基础的随机模糊测试器。我们的程序将生成随机整数值，并将这些值传递给我们的测试程序的参数。
- en: 'Create a new file called *myFuzzer.py* and add the following contents:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*myFuzzer.py*的新文件，并添加以下内容：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the `testFunction()` function shown earlier into the file ➊. Our simple
    fuzzing program generates a random integer for each input variable ➋. Once we’ve
    generated a random value for each variable, we print the input to the screen before
    calling the function we’re testing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前显示的`testFunction()`函数复制到文件➊中。我们的简单模糊测试程序为每个输入变量生成一个随机整数➋。生成每个变量的随机值后，我们会在调用正在测试的函数之前，将输入打印到屏幕上。
- en: 'Save the file and then run the fuzzer using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后使用以下命令运行模糊测试工具：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fuzzer will cycle through random values until it finds one that stops the
    program. Experiment by increasing the range from 200 to 400\. The more random
    numbers the program needs to consider, the longer it will take to discover an
    input that crashes the program. This is one of the disadvantages of completely
    random fuzzing. You’ll need to cycle through many benign inputs to discover a
    useful one. Later in this chapter, we’ll look at ways to address this issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试工具将循环遍历随机值，直到找到一个能停止程序的值。试着将范围从200增加到400。程序需要考虑的随机数越多，发现一个能导致程序崩溃的输入就需要更长时间。这是完全随机模糊测试的一个缺点。你将需要循环遍历许多无害的输入，才能发现一个有用的输入。我们将在本章后面讨论如何解决这个问题。
- en: 'You might be wondering: Is generating input that crashes a program really that
    useful? Crashes are the first step to discovering bugs, which attackers can often
    exploit. But generating data that crashes a program can be very useful in its
    own right, too. If you can get an application to crash, you could execute a denial
    of service (DoS) attack. Imagine if you could discover input that crashes the
    Google DNS server or a cell tower. That would be pretty valuable.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：生成使程序崩溃的输入真的有那么有用吗？崩溃是发现漏洞的第一步，而攻击者通常可以利用这些漏洞。但生成使程序崩溃的数据本身也非常有用。如果你能让一个应用程序崩溃，你就能执行拒绝服务（DoS）攻击。想象一下，如果你能够发现一个输入，使得Google
    DNS服务器或一个手机塔崩溃，那将是非常有价值的。
- en: 'Or consider the following scenario: a hacker has fuzzed an intranet-connected
    traffic light control system. (Surprisingly, such devices are common.) The hacker
    discovers some input that crashes the system, thus disabling all of the traffic
    lights it controls. They’ve now discovered an input sequence that will allow them
    to disable traffic lights at will. This is very dangerous and is an excellent
    reminder of why it’s important for ethical hackers to penetration-test systems
    before they are deployed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者考虑以下场景：一个黑客对一个连接到内联网的交通信号灯控制系统进行模糊测试。（令人惊讶的是，这类设备很常见。）黑客发现某个输入导致系统崩溃，从而禁用了它控制的所有交通信号灯。现在，他们已经发现了一种能够随意禁用交通信号灯的输入序列。这非常危险，也很好地提醒我们为什么道德黑客需要在系统部署前进行渗透测试。
- en: '***American Fuzzy Lop***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***美国模糊测试工具***'
- en: Simply generating random input seems a bit wasteful as a larger search space
    will take longer to fuzz. Couldn’t we use information about the program’s paths
    to generate more focused, carefully crafted examples? Well, certain fuzzers *instrument*
    a program by inserting instructions that log the paths the program takes when
    it executes. These fuzzers attempt to generate new inputs that explore previously
    unexplored paths. Given a set of preexisting test cases, they’ll mutate the inputs
    by adding or subtracting some random information, keeping the new tests only if
    they explore new paths in the program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯生成随机输入似乎有点浪费，因为较大的搜索空间需要更长时间进行模糊测试。难道我们不能利用程序路径的信息来生成更有针对性、更精心设计的测试用例吗？实际上，某些模糊测试器通过插入指令来*注入*程序，以记录程序在执行时所经过的路径。这些模糊测试器试图生成新的输入，探索以前未被探索的路径。给定一组现有的测试用例，它们会通过添加或减去一些随机信息来变异输入，仅当新的测试用例探索程序中的新路径时，才会保留它们。
- en: The *American Fuzzy Lop (AFL)* is one such fuzzer. Originally written by Michal
    Zalewski at Google, AFL uses a *genetic algorithm* to mutate test cases and create
    new inputs that test unexplored paths. A genetic algorithm is a biologically inspired
    learning algorithm. It accepts inputs, such as a = 0, b = 2, and c = 1, and then
    encodes them as a vector [0, 2, 1] similar to a sequence of genes in someone’s
    DNA, like ATGCT. Armed with these vectors, the fuzzer keeps track of the number
    of paths explored when the program uses a particular input sequence, say, [0,
    2, 1]. Genes that are similar will explore similar paths, thus reducing the likelihood
    of exploring a new path.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*美国模糊测试工具（AFL）* 就是其中一个模糊测试工具。最初由谷歌的Michal Zalewski编写，AFL使用*遗传算法*来变异测试用例，并创建新的输入以测试未被探索的路径。遗传算法是一种生物启发的学习算法。它接受输入，例如a
    = 0，b = 2，c = 1，然后将它们编码为向量[0, 2, 1]，类似于某人DNA中的基因序列，如ATGCT。利用这些向量，模糊测试器跟踪当程序使用特定输入序列（如[0,
    2, 1]）时探索的路径数量。相似的基因将探索相似的路径，从而减少探索新路径的可能性。'
- en: The fuzzer creates new genetic input sequences by introducing randomness to
    the values of existing sequences. For example, the input sequence [0, 2, 1] may
    become [4, 0, 1]. Here, the genetic algorithm chose to mutate the first and second
    elements by randomly adding four and subtracting two, respectively. Genetic algorithm
    implementations often allow programs to choose how often mutations occur and whether
    to make large or small changes. The new sequence is then fed to the program. If
    the sequence explores a new path, the input is maintained, and if it doesn’t,
    it is deleted or mutated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试器通过引入随机性来创建新的遗传输入序列，修改现有序列的值。例如，输入序列[0, 2, 1]可能变成[4, 0, 1]。在这里，遗传算法选择通过随机地加上四和减去二来变异第一个和第二个元素。遗传算法的实现通常允许程序选择变异发生的频率，并决定是进行大幅度变化还是小幅度变化。然后，将新的序列输入到程序中。如果该序列探索了新路径，则保留输入，如果没有，则删除或再变异。
- en: There are plenty of other mutation strategies that you can explore. For example,
    crossovers mix sequences from two genes to create a new gene. You can read more
    about genetic algorithms in John Holland’s original paper, “Genetic Algorithms
    and Adaptation” (Adaptive Control of Ill-Defined Systems, 1984).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing AFL**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s run AFL to discover an input sequence that causes the `testFunction()`
    function to crash. You can download AFL from Google’s offical GitHub page. Clone
    the AFL repository by running the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, navigate to the *AFL* directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and install the program by running the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'AFL was originally designed to fuzz C and C++ programs. AFL instruments these
    programs by compiling the source code and instrumenting the binary. We won’t be
    fuzzing C programs, so we’ll need to install `python-afl`, a program that extends
    AFL’s functionality to Python programs. We’ll use `pip3` to install the module.
    If you don’t already have it, run the following command to install `pip`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, install `python-afl` by running the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that you’ve installed `python-afl`, let’s use it to fuzz the test function.
    Create a new Desktop folder called *Fuzzer*, and within the *Fuzzer* folder, create
    three folders called *TestInput*, *App*, and *Results*. We’ll store our test input
    files in the *TestInput* folder, and the results of our fuzz in the *Results*
    folder. We’ll store the code for the app that we want to fuzz in the *App* folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifying the Program**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `python-afl` fuzzer assumes that test inputs are read in from a file supplied
    via *std.in*, so we’ll need to modify the program to do so. The following program
    reads values for `a`, `b`, and `c` from *std.in*, which are then converted from
    strings to integers and passed to the test function. Create a file called *fuzzExample.py*
    in the *App* folder and add the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to copy the test function into the location specified by the comment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we read the contents from *std.in* ➊. We then strip trailing spaces and
    newline characters ➋. We also split up the line into three variables: `a`, `b`,
    and `c`. At ➌, we instruct the AFL library to begin instrumenting the program
    by calling `afl.init()`. Then, we execute our main method before exiting ➍. It’s
    good practice to call `os._exit(0)` so that you can quickly terminate the fuzzing
    run, but this isn’t required.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Test Cases**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Next, we need some test cases to pass to our program. Open a terminal and navigate
    to the *Fuzzer* folder on your Desktop by running this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the following command to create a *testInput1.txt* file in the *TestInput*
    folder that contains the values `0`, `1`, and `1`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Redirect* (<) these values into the program by running this command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you’ve done everything correctly, your program should run without printing
    anything. If something does print out, read the error message and ensure that
    you’ve followed the instructions carefully.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two additional test files by running the following commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Fuzzing the Program**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we’ve explored the code, let’s fuzz it. Here is the general format
    for running the `py-afl-fuzz` program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before fuzzing your Python program, disable the AFL Fork Server functionality.
    This performance optimization is problematic for the Python AFL fuzzer, so run
    the following command to deactivate it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can fuzz the Python file by running the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see the following screen, which should update in real time as the
    program is being fuzzed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To find the inputs that crashed your program, navigate to the *Crashes* folder
    inside the *Results* folder. This folder contains the input files that crashed
    the program. You’ll notice inputs like an empty file and a file with invalid characters.
    However, you should also notice a file with valid inputs that took the path discussed
    earlier, activating the assert statement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbolic Execution**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wouldn’t it be amazing if we could analyze a program without executing it? *Symbolic
    execution* is a technique that uses symbols instead of real data to perform static
    analysis on a program. As the symbolic execution engine explores paths in a program,
    it builds path equations that can be solved to determine when a particular branch
    will be taken. [Figure 9-6](ch09.xhtml#ch9fig6) shows the path constraints associated
    with the test function we explored earlier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: A computation tree that visualizes the execution paths and path
    constraints of the test function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'To programmatically solve these path constraints, we use something called a
    *theorem prover*. A theorem prover answers questions like: Is there a value for
    `x` such that `x` *×* 5 == 15? If so, what is the value? The Z3 theorem prover
    is a popular prover developed by Microsoft. A detailed discussion of theorem proving
    is beyond the scope of this book, but we’ll consider it in the context of our
    test program.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '***A Symbolic Execution of the Test Program***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The theorem prover helps discover inputs that activate each path by evaluating
    each path condition. Consider the path that leads to the failure state shown in
    [Figure 9-6](ch09.xhtml#ch9fig6). Let’s see how symbolic execution uses a theorem
    prover to identify that this is a reachable path.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: First, the symbolic engine begins by symbolically executing the program. The
    inputs `a`, `b`, and `c` are replaced by symbolic values *α*, *β*, and *λ*. When
    the engine encounters the `if` statement `if (a):`, it asks the theorem prover
    if there is a value of *α* that would evaluate to true. If there is, the theorem
    prover would return yes. Similarly, we ask the theorem prover to see if there
    is a value of *α* that evaluates to false, to which the theorem prover would return
    yes. This means that the symbolic execution engine must explore both paths.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the symbolic execution engine first explores the path where *α*
    evaluates to false, it will encounter another conditional: `if (b < 5):`. This
    will result in a new path condition where *α* is not true and *β* is less than
    five.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we ask the theorem prover if there exists a value for *α* and *β* for
    which this condition is either true or false, to which the theorem prover would
    return yes. Let’s assume that we explore the true branch. The symbolic engine
    will encounter the third and final conditional: `if (not a and c):`. This results
    in the final path constraint where *α* is not true, *β* is less than five, and
    *λ* is true. Now we can ask the theorem prover to return values of *α*, *β*, and
    *λ* for which this path condition is true. The theorem prover might very well
    return *α* = 0, *β* = 4 and *λ* = 1, the input that happens to get us to our failure
    state.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The symbolic execution engine will repeat this process for all possible paths
    and generate a collection of test cases to execute all the paths.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '***Limitations of Symbolic Execution***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'However, there are constraints that the theorem prover can’t solve. Consider
    our discussion of the Diffie-Hellman key exchange algorithm from [Chapter 6](ch06.xhtml#ch6).
    Recall that recovering a private key from a public key would require solving the
    discrete inverse log problem. Consider this example function originally proposed
    by Mayur Naik at the University of Pennsylvania:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Evaluating the condition ➊ would require finding a value for `x` that would
    make the condition true, thus solving the following equation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 2*^x* mod *c* = 17
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to solving the inverse log problem, and no one currently
    knows how to solve the inverse log problem efficiently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If the theorem prover can’t evaluate a condition, it assumes that both the true
    and false options are possible, and the symbolic engine will explore both paths.
    However, this result is incorrect as a value of `x` that makes this condition
    true does not exist. This limitation leads the symbolic execution engine to explore
    paths that aren’t feasible. For this reason and others, symbolic execution does
    not scale for large programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As the number of paths grows, so does the number of path equations, which makes
    symbolic execution less feasible for large programs. Instead, testers often use
    a hybrid approach, called *concolic execution* or *dynamic symbolic execution*.
    One of the earliest such projects was the Symbolic PathFinder (SPF) developed
    by a team at NASA. These techniques combine the dynamic execution of fuzzing with
    the static analysis techniques used by symbolic execution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Symbolic Execution**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic Symbolic Execution (DSE) combines dynamic execution techniques like
    fuzzing with ideas from symbolic execution. In addition to symbolic variables
    and path constraints, DSE keeps track of the concrete values supplied as the original
    input to the program, and it completely explores a path exercised by these concrete
    variables. The path constraints that result from this exploration are then used
    to generate new concrete variables that explore new paths. [Figure 9-7](ch09.xhtml#ch9fig7)
    shows an example path taken by the DSE engine when concrete variables `a` = 0,
    `b` = 4, and `c` = 0 are used.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig07.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: An example of a path taken by the DSE engine*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To truly understand the DSE engine’s inner workings, consider the state of the
    concrete variables, symbolic variables, and path constraints as the DSE engine
    executes each line of the test function. Each row of [Table 9-1](ch09.xhtml#ch9tab1)
    represents a step in the execution process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** The Concrete Variables, Symbolic Variables, and Path Constraints
    Collected on One Pass of the Concolic Engine'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '| Line | Code | Concrete vars | Symbolic vars | Path constraints |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 1 | `def testFunction(a,b,c):` | *a* = 0, *b* = 4, *c* = 0 |  |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 2 |     `x, y, z = 0, 0, 0` | *x* = 0, *y* = 0, *z* = 0 |  |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| 3 |     `if (a):` |  | *α* = *a* | *α* == *false* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| 4 |           `x = -2` |  |  |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| 5 |     `if (b < 5):` |  | *β* = *b* | *β* < 5 == true |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| 6 |           `if (not a and c):` |  | *λ* = *c* | (¬*α* ∧ *λ*) == *false*
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| 7 |                    `y = 1` |  |  |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| 8 |           `z = 2` | *z* = 2 |  |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| 9 |     `assert(x + y + z != 3)` |  |  |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: At line 1, the values of *a*, *b*, and *c* are randomly initialized with the
    values 0, 4, and 0, respectively. As the DSE engine executes, it keeps track of
    each new variable it encounters, so when it gets to line 2, it stores *x* = 0,
    *y* = 0, and *z* = 0 in the collection of concrete variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the DSE engine moves to line 3, where it encounters the first
    `if` statement. Each new conditional statement results in the creation of a new
    path constraint and, if necessary, new symbolic variables. Here the DSE engine
    creates a new symbolic variable *α* = *a* to represent the concrete variable *a*,
    which has the value 0\. Unlike a symbolic execution engine, which uses the theorem
    prover to decide whether to explore a branch, the DSE engine simply evaluates
    the condition by substituting the concrete variable. The condition `if(a)` reduces
    to `if(0)` because the value of *a* is 0\. This easily evaluates to false, so
    the DSE engine also adds the path constraint *α* == *false* and does not take
    the branch. Because the condition evaluated to false, the DSE engine doesn’t execute
    line 4.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: During the next step, the DSE engine encounters the second condition `if (b
    < 5):` at line 5\. Here, the DSE engine creates a symbolic variable *β* = *b*
    and uses the concrete value of *b* to determine whether to take the branch. In
    this case, *b* = 4, so the branch is taken. The DSE engine then adds the path
    constraint *β* less than five is true (*β* < 5 == *true*) and moves on to the
    third and final condition at line 6.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Here, the DSE engine encounters a new variable *c*. It creates a new symbolic
    variable *λ* = *c* and evaluates the condition `if (not a and c):` using the concrete
    variables *a* = 2 and *c* = 0\. In this case, the branch is not taken, so the
    DSE engine adds the path condition (*¬**α* *∧* λ) == *false*. The DSE engine then
    proceeds to line 8, where it updates the concrete variable *z* to store the value
    2, and ends at line 9\. In this case *z* = 2, *x* = 0, and *y* = 0, so the `assert`
    statement (`assert(x + y + z != 3)`) is not triggered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program gets to the end of a path, it backtracks to the last branch
    it took and negates the most recently added value in the path constraints. In
    our example, the new path condition would be *α* not true, *β* less than five,
    and *λ* is true, or in equation form:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: ¬*α* ∧ (*β* < 5) ∧ *λ*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Once the DSE engine has the new constraint, it uses the theorem prover to find
    the values for *α*, *β*, and *λ* that satisfy this equation. In this case, the
    solver might return *a* = 0, *b* = 4, and *c* = 1\. These new values will allow
    the DSE engine to explore the other branch. [Figure 9-8](ch09.xhtml#ch9fig8) illustrates
    backtracking to explore a new path.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch09fig08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: The process of backtracking to negate the last path constraint*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The DSE engine will then reset and repeat the process using new input values.
    When it gets to the end of the path with the new input, the DSE engine will negate
    the second most recently added constraint. This process continues recursively
    until the DSE engine has explored all the paths in the path tree. Here’s a challenge:
    see if you can construct the table that shows the concrete values, symbolic variables,
    and path constraints that would cause the DSE engine to identify the failure state.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s highlight the power of concolic execution by looking at an example
    that would be difficult to solve with symbolic execution alone ([Table 9-2](ch09.xhtml#ch9tab2)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we execute the program to the end of the path using concrete variables.
    When we get to the end, we take the inverse of the last constraint that was added.
    The inverse is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*f*^(–1)(*x* ≠ *sha*256(*y*[0])) *→* *x* = *sha*256(*y*[0])'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** The Concrete Variables, Symbolic Variables, and Path Constraints
    Collected in One Pass'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Concrete vars | Symbolic vars | Path constraints |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `from hashlib import sha256 def hashPass(x):     return sha256(x)` |  |  |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `def checkMatch(x,y):    z = hashPass(y)    if (x == z ):       assert(true)
    else:     assert(false)` | *x* = 2, *y* = 1 *z* = 6*b*....*b*4*b* | *x*[0] = *x*,
    *y*[0] = *y* *z* = *sha*256(*y*[0]) | *x*[0] ≠ *sha*256(*y*[0]) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: 'The SHA-256 hash function used in the code is a one-way function, so a solver
    won’t be able to solve for the values of *x* and *y* that satisfy this constraint.
    However, we can simplify the constraint by substituting our symbolic variable
    *y*[0] with its concrete value *y* = 1:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*x* == *sha*256(*y*[0]) *→* *x* == *sha*256(1) *→* *x* == 6*b*....*b*4*b*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We now have a satisfiable equation that we easily can solve.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: DSE is not perfect though. There are still instances when it doesn’t explore
    all paths in a program. But fuzzing and DSE are some of the best tools we have
    for discovering zero-day vulnerabilities. Let’s look at some programs that allow
    you to perform testing with DSE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Using DSE to Crack a Passcode**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s uncover a user’s password by using a concolic engine called *Angr*. Angr
    was created by Yan Shoshitaishvili and others, while they were members of Giovanni
    Vigna’s research team at University of Santa Barbara. Instead of analyzing a specific
    programming language, Angr analyzes the binaries that you get when you compile
    a program, which makes it language independent. We’ll practice using it in this
    section, but first we must create the program to test.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating an Executable Binary***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a folder on your Kali Linux Desktop called *Concolic* and create a new
    file within it called *simple.c*. This is the file we’ll compile.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following code into the file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This program is implemented in the C programming language. The program prompts
    the user to enter a password and then checks to see if the password matches `7857`
    (the correct value). If the password matches, the program prints `Access Granted`.
    Otherwise, it prints `Access Denied`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and navigate to the *Concolic* folder you created on your Desktop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile the *simple.c* program to create a binary (the file that contains the
    machine code) by running the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This program runs the `gcc` compiler that comes preinstalled on Kali Linux,
    which will compile the *simple.c* file and output (`-o`) a binary called *simple*.
    Test your new binary by running the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***Installing and Running Angr***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We recommend that you run Angr within a virtual Python environment. A virtual
    environment isolates the libraries that Angr uses from the libraries in your regular
    environment, which reduces errors caused by conflicting versions of libraries.
    Run the following command to install Python’s virtual environment wrapper (`virtualenvwrapper`)
    and its dependencies:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, configure the terminal and activate the virtual environment wrapper,
    which will allow you to create new virtual environments:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now create a new virtual environment called `angrEnv` and set it up to use
    Python 3:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, install Angr in this new environment:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you set everything up correctly, you should see the `angrEnv` label in your
    terminal as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angr is well documented, so before you continue, I recommend that you read the
    core concept section of the Angr documentation. Also try completing the Python
    interactive shell exercises listed at *[https://docs.angr.io/core-concepts/toplevel/](https://docs.angr.io/core-concepts/toplevel/)*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '***The Angr Program***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s write the Python program that will use Angr to automatically discover
    the passcode in the program we wrote. Create a new file on your Desktop called
    *angrSim.py* and save the following code snippet to it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We import the binary from the *simple.c* program as an Angr project ➊. Before
    we continue, keep in mind that the symbolic variables you’ll inspect will be bit
    vectors representing the contents of the symbolic registers. This is because you’re
    symbolic executing a binary rather than source code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Next, we obtain the initial entry state of the program ➋. We then pass this
    state to a simulation manager (`simgr`) that will manage the process of simulating
    program execution. If you wanted to manually simulate the program, you could run
    `simulation.step()`, which would allow you to inspect the state and path constraints
    at each execution step. The Angr documentation walks through this process with
    a simple example.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now, we define a function that identifies the success state ➌. If the state
    would output the string `Access Granted`, the function returns true. Next, we
    define the function that identifies a failure state ➍. If a state would output
    the string `Access Denied`, the function returns true.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start the concolic execution process. Then, we pass the function
    pointers to the success and failure functions ”. If the simulation reaches the
    failure state, it quickly terminates and restarts the search. However, if the
    simulation discovers the success state, it terminates and saves the state. Finally,
    we print the input that caused us to enter the success state, and voila, we have
    the password ➏.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the terminal, run the *angrSim.py* program:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will take some time to run. When it’s complete, you should see the following
    output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Congratulations, you’ve used the Angr concolic engine to discover the input
    that gets you to your success state.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These exercises are designed to round out your understanding of concolic execution
    and fuzzing. The exercises are listed in order of difficulty, and I recommend
    attempting the more difficult exercises to help you truly master these topics.
    Happy hunting.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '***Capture the Flag Games with Angr***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter, we looked at only a small fraction of what Angr is capable
    of. You can expand your understanding of this tool by completing the Angr *Capture
    the Flag* challenges created by Jake Springer. The repository of challenges at
    *[https://github.com/jakespringer/angr_ctf](https://github.com/jakespringer/angr_ctf)*
    also contains solutions, so feel free to check your work after attempting a challenge.
    Complete all 17 challenges to really master Angr.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '***Fuzzing Web Protocols***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve explored how to fuzz binaries. Now let’s look at an easy way to fuzz
    network protocols using the `spike` tool that comes preinstalled on your Kali
    Linux virtual machine. Here is the command’s general syntax:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Begin by specifying the host machines you want to fuzz (for example, the Metasploitable
    server). Next, specify the port used by the protocol you’d like to fuzz. For instance,
    you could try fuzzing the SMTP server running on port 25.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The spike fuzzer doesn’t know structure of the SMTP protocol, so you’ll need
    to supply a spike script that defines the message it needs to send. This script
    will consist of a collection of strings to send and the variables to mutate. You
    can write your own fuzzing scripts or use the scripts included in the directory
    */usr/share/spike/audits/*. We’ll look at an example script more closely later
    in this exercise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The `*[variable index]*` specifies the starting location in the script. For
    example, a variable index value of 0 would start fuzzing with the first variable
    in the script, whereas a value of 3 would leave the first three values unmutated
    and begin by mutating the fourth variable in script.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The spike fuzzer has a predefined array of string mutations, and the `*[string
    index]*` value specifies which of these to use first. For example, a value of
    0 would start with the first string mutation, whereas a value of 4 would start
    with the fifth mutation. The `*[variable index]*` and `*[string index*`*]* values
    are useful because they allow you to resume fuzzing at a specific point in the
    process if it terminates for any reason.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete command might look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To better understand the output, let’s look at the *smtp1.spk* script. This
    `spike` script describes the SMTP protocol and consists of a collection of commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `s_string()` command tells the fuzzer to send a string corresponding to
    part of an SMTP message. The fuzzer sends the `MAIL-FROM` command associated with
    the SMTP protocol ➊. The `s_string_variable()` command defines the string to mutate,
    which is `"bob"` in this case, and sends it ➋. For example, the fuzzer might send
    `"boo`. The next time it mutates `bob` it might send `bAAAAAA`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The `spike` script also supports other commands, such as `s_readline`, which
    displays a string representation of the response, and `printf()`, which writes
    to the local terminal (and is great for debugging). The `spike_send()` command
    flushes the buffer and sends all of its contents.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Try writing your own `spike` script for a different network protocol. If you
    find it useful, add it to the official `spike` Git repository at *[https://github.com/guilhermeferreira/spikepp.git](https://github.com/guilhermeferreira/spikepp.git)*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '***Fuzzing an Open Source Project***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s get some practice fuzzing a real program. In this exercise, try running
    the AFL-fuzzer you used in this chapter on your favorite open source project.
    Note that fuzzing open source programs is legal because it helps the developer
    community discover bugs that could potentially be exploited by attackers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: As you fuzz the program, remember to practice responsible disclosure. If you
    find a bug, send a secure email to the project’s creators. It’s also helpful if
    you explain how the bug could be exploited and include some sample exploitation
    code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: How can you quickly determine whether a bug is exploitable? The `gdb` exploitable
    plug-in allows you to determine if a bug that caused a crash might be malicious.
    You can download the plug-in from *[https://github.com/jfoote/exploitable](https://github.com/jfoote/exploitable)*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is a computationally intensive process, and we don’t recommend that
    you do this in your virtual machine. Instead, run the fuzzer on a remote server
    or on your local machine.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '***Implement Your Own Concolic Execution Engine***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The physicist Richard Feynman once said, “What I cannot create, I do not understand.”
    The best way to develop a deep understanding of something is to implement it yourself.
    Try implementing your own concolic execution engine in Python. This exercise,
    given to MIT computer security students, has been made available to the general
    public here: *[https://css.csail.mit.edu/6.858/2018/labs/lab3.html](https://css.csail.mit.edu/6.858/2018/labs/lab3.html)*.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Give it a try. You might be surprised by how much you learned in this chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
