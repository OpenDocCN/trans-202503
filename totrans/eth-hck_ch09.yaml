- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: FUZZING FOR ZERO-DAY VULNERABILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**为零日漏洞进行模糊测试**'
- en: '*Asking the right questions takes as much skill as giving the right answers.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*提出正确的问题和给出正确的答案一样需要技巧。*'
- en: –Robert Half
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 罗伯特·哈夫
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: What happens if an attacker scans a system and doesn’t find any known vulnerabilities?
    Can they still gain access? Yes, but they’ll need to discover a new, unknown vulnerability.
    These unknown vulnerabilities are called *zero-day* vulnerabilities, and useful
    ones can sell for millions of dollars.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者扫描一个系统并没有找到任何已知的漏洞，会发生什么？他们仍然能获得访问权限吗？是的，但他们需要发现一个新的、未知的漏洞。这些未知的漏洞被称为*零日*漏洞，而有价值的漏洞可以卖到数百万美元。
- en: 'Finding a zero-day vulnerability often begins with finding a software bug.
    Once a hacker discovers a bug, they can exploit it to their advantage. Attackers
    use bugs to steal data, crash programs, take control of systems, and install malware.
    Let’s start by exploiting a famous bug that led to the Heartbleed vulnerability
    that crippled the internet. Then we’ll explore three techniques used to discover
    bugs: fuzzing, symbolic execution, and dynamic symbolic execution.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 发现一个零日漏洞通常始于发现一个软件错误。一旦黑客发现了漏洞，他们就能利用它为自己谋利。攻击者利用漏洞窃取数据、崩溃程序、控制系统并安装恶意软件。让我们从利用一个著名的漏洞开始，这个漏洞导致了使互联网瘫痪的Heartbleed漏洞。然后，我们将探讨发现漏洞的三种技术：模糊测试、符号执行和动态符号执行。
- en: '**Case Study: Exploiting the Heartbleed OpenSSL Vulnerability**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：利用Heartbleed OpenSSL漏洞**'
- en: The *Heartbleed vulnerability* takes advantage of a software bug in an OpenSSL
    extension called Heartbeat. This extension allows a client to check if a server
    is still online by sending a Heartbeat request message. If the server is online,
    it replies with a Heartbeat response message.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Heartbleed漏洞*利用了一个在OpenSSL扩展“Heartbeat”中的软件错误。这个扩展允许客户端通过发送心跳请求消息来检查服务器是否在线。如果服务器在线，它会回复一个心跳响应消息。'
- en: After the server stores the Heartbeat request message in its memory, it responds
    by reading its memory and returning the same message in the Heartbeat response.
    It uses the stated length of the Heartbeat message to decide how much of its memory
    it should read and send back.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器将心跳请求消息存储到内存后，它会通过读取内存并返回相同的消息来响应。它使用心跳消息中声明的长度来决定应该读取多少内存并发送回去。
- en: Here’s the bug. If a hacker sends a Heartbeat request message with a length
    longer than the actual request, the server will include additional parts of its
    memory in the response, some of which may contain sensitive information. [Figure
    9-1](ch09.xhtml#ch9fig1) illustrates this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是漏洞。如果黑客发送一个心跳请求消息，其长度超过实际请求，服务器会在响应中包含其内存的其他部分，其中可能包含敏感信息。[图 9-1](ch09.xhtml#ch9fig1)展示了这一点。
- en: '![image](../images/ch09fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig01.jpg)'
- en: '*Figure 9-1: An overview of the Heartbleed vulnerability*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：Heartbleed漏洞概述*'
- en: The hacker was able to read the contents of the server’s memory, which included
    passwords and private keys. This type of attack is called a *buffer over-read*,
    as we can read beyond the bounds of the designated memory buffer. Similarly, in
    a buffer overflow attack, a hacker uses a bug to write beyond the bounds of a
    designated buffer. Hackers often use buffer overflow attacks to upload reverse
    shells that allow them to control the machine remotely. This process is called
    *remote code execution (RCE)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客能够读取服务器内存的内容，其中包括密码和私钥。这种攻击被称为*缓冲区过度读取*，因为我们可以读取超出指定内存缓冲区的内容。类似地，在缓冲区溢出攻击中，黑客利用漏洞写入超出指定缓冲区的内容。黑客常常利用缓冲区溢出攻击上传反向shell，允许他们远程控制机器。这个过程被称为*远程代码执行（RCE）*。
- en: Why can’t we fix this bug by making all heartbeat messages a fixed length? Because
    Heartbeat messages also measure the *maximum transmission unit (MTU)* of the client’s
    path to the server. The MTU is the maximum size of the packets sent along that
    path. As packets move through the network, they pass through a collection of routers.
    Depending on its design, each router handles packets up to a specific size. If
    a router receives a packet that is larger than its MTU, it breaks the packet into
    smaller packets, a process called *fragmentation*. These fragmented packets are
    then reassembled when they reach the server. By probing the network with Heartbeat
    request messages of different lengths, the client can discover the MTU, along
    with its path, and avoid fragmentation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能通过使所有心跳消息为固定长度来修复这个漏洞呢？因为心跳消息还会测量客户端到服务器路径的*最大传输单元（MTU）*。MTU是沿着该路径发送的数据包的最大大小。数据包在网络中传输时，会经过一系列路由器。根据路由器的设计，每个路由器只能处理一定大小的数据包。如果路由器收到一个大于其MTU的数据包，它会将数据包拆分成更小的数据包，这个过程称为*分片*。这些分片的数据包在到达服务器时会重新组装。通过发送不同长度的心跳请求消息来探测网络，客户端可以发现MTU以及其路径，从而避免分片。
- en: '***Creating an Exploit***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建利用工具***'
- en: 'After you’ve found a bug the next question is how to exploit it to your advantage.
    Exploiting a bug is an intricate process, as writing your own exploits requires
    a detailed understanding of the system. The bug you’ve discovered is most likely
    specific to a particular software version, so the exploit you write must also
    be specific to that software version. If the software developers fix the bug,
    you’ll no longer be able to exploit it. This is one of the reasons that state
    actors are so secretive about their capabilities. Knowledge of the bug will allow
    an adversary to fix it, after which the state actor’s exploit will no longer work.
    The cycle continues: old vulnerabilities are patched, and new vulnerabilities
    are found.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你发现漏洞之后，接下来的问题就是如何利用它为自己谋取利益。利用漏洞是一个复杂的过程，因为编写你自己的利用工具需要对系统有深入的理解。你发现的漏洞很可能特定于某个特定的软件版本，所以你编写的利用工具也必须针对该软件版本。如果软件开发者修复了这个漏洞，你将无法再利用它。这也是国家行为者对其能力保持高度保密的原因之一。漏洞的知识使得对手能够修复它，修复后国家行为者的利用工具将不再有效。这个循环持续着：旧的漏洞被修复，新的漏洞被发现。
- en: The Heartbleed bug predates the release of TLS 1.3, so TLS messages exchanged
    during the Heartbleed attack conform to the TLS 1.2 protocol. [Figure 9-2](ch09.xhtml#ch9fig2)
    shows the messages exchanged during the attack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed漏洞存在于TLS 1.3发布之前，因此Heartbleed攻击期间交换的TLS消息符合TLS 1.2协议。[图9-2](ch09.xhtml#ch9fig2)展示了攻击过程中交换的消息。
- en: '![image](../images/ch09fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig02.jpg)'
- en: '*Figure 9-2: Messages exchanged between a client and server during a Heartbleed
    attack*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：客户端和服务器在Heartbleed攻击期间交换的消息*'
- en: The client initiates the connection by sending a *Client Hello* message, and
    the server responds with several messages that end with a final *Server Done*
    message. As soon as we receive the *Server Done* message, we’ll respond with a
    malicious Heartbeat request, after which the server will send a collection of
    Heartbeat responses containing the leaked information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过发送*Client Hello*消息来发起连接，服务器则通过多个消息进行响应，最后以*Server Done*消息结束。一旦我们收到*Server
    Done*消息，我们会响应一个恶意的心跳请求，随后服务器将发送一系列包含泄露信息的心跳响应。
- en: '***Starting the Program***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动程序***'
- en: Let’s write a Python program that exploits the Heartbleed bug. The program will
    be longer than the programs we normally write, so instead of showing a single
    block of code, I’ll break the program up into sections and discuss each section
    individually. You can reconstruct the program by copying each section into a file
    called *heartbleed.py*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Python程序来利用Heartbleed漏洞。这个程序会比我们通常编写的程序要长，因此我将不展示一个完整的代码块，而是将程序分成多个部分，分别讨论每一部分。你可以通过将每一部分复制到一个名为*heartbleed.py*的文件中来重构这个程序。
- en: Before we begin coding, let’s discuss the general overview of the exploit. We’ll
    begin by establishing a socket connection to the server. Then, we’ll manually
    initiate a TLS connection by sending a client *hello* message. After we’ve sent
    the *hello* message, we’ll continue to receive packets until we receive the *Server
    Done* message. Once we’ve received this message, we’ll transmit an empty Heartbeat
    message with a stated length of 64KB. We chose 64KB because it’s the maximum possible
    length and will allow us to extract the most information. If the server is vulnerable,
    it will respond with 64KB of its memory. Because each Heartbeat packet can hold
    only 16KB of data, the 64KB response will be split across four packets. By printing
    the contents of these packets, we can read parts of the server’s memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，先讨论一下漏洞利用的总体概况。我们将首先与服务器建立套接字连接。然后，我们将手动启动TLS连接，发送客户端*hello*消息。在发送*hello*消息后，我们将继续接收数据包，直到收到*Server
    Done*消息。一旦收到此消息，我们将发送一个空的心跳消息，长度为64KB。我们选择64KB，因为这是可能的最大长度，并且将允许我们提取最多的信息。如果服务器存在漏洞，它将以64KB的内存数据作出响应。由于每个心跳数据包最多只能容纳16KB数据，64KB的响应将分为四个数据包发送。通过打印这些数据包的内容，我们可以读取服务器内存的部分内容。
- en: 'Let’s begin by importing the libraries we’ll use throughout the process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先导入在整个过程中使用的库：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll use command line arguments to pass options to our program, so we’ll need
    the `sys` library to read these arguments. Then we’ll use the `socket` and `select`
    libraries to establish a TCP socket connection to the vulnerable server. Lastly,
    we’ll use the `struct` and `array` libraries to extract and package the bytes
    associated with each field in the packets we receive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行参数将选项传递给程序，因此我们需要`sys`库来读取这些参数。然后，我们将使用`socket`和`select`库与易受攻击的服务器建立TCP套接字连接。最后，我们将使用`struct`和`array`库来提取和打包我们接收的数据包中每个字段的字节。
- en: '***Writing the Client Hello Message***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写客户端Hello消息***'
- en: Next, we’ll construct the client’s *hello* message, which is the first message
    sent by the TLS 1.2 protocol. (The IETF outlines the TLS 1.2 specification in
    RFC 5246\. We’ll use this specification to construct the packets that we’ll send
    in this chapter.) [Figure 9-3](ch09.xhtml#ch9fig3) represents the layout of each
    bit in the *Client Hello* packet. The numbers at the top present each bit, numbered
    from 0 to 31, and the labels represent the fields and their positions in the packet.
    You’ll commonly find diagrams like these in the IETF’s RFC documents, which describe
    protocols.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构造客户端的*hello*消息，这是TLS 1.2协议发送的第一个消息。（IETF在RFC 5246中概述了TLS 1.2的规范。我们将使用此规范来构建本章中要发送的数据包。）[图9-3](ch09.xhtml#ch9fig3)表示*Client
    Hello*数据包中每个比特的布局。顶部的数字表示每个比特，从0到31编号，标签表示数据包中各字段及其位置。你常常可以在IETF的RFC文档中看到这样的图示，这些文档描述了协议。
- en: '![image](../images/ch09fig03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig03.jpg)'
- en: '*Figure 9-3: The structure of a TLS handshake packet*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：TLS握手数据包的结构*'
- en: All packets in the TLS 1.2 protocol begin with a *Type* field. This field identifies
    the type of packet being sent. All messages associated with the TLS 1.2 handshake
    are assigned the type 0x16, indicating they are a part of the handshake record.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2协议中的所有数据包都以*类型*字段开始。该字段标识发送的数据包类型。与TLS 1.2握手相关的所有消息都被分配为类型0x16，表示它们是握手记录的一部分。
- en: The next 16 bits represent the *TLS Version*, and a value of 0x0303 represents
    version 1.2\. The 16 bits after that represent the *Packet Length*, which is the
    total length of the packet in bytes. Next is the 8-bit *Message Type* (see [Figure
    9-2](ch09.xhtml#ch9fig2) for a list of the types of messages exchanged during
    a TLS v1.2 handshake). A value of 0x01 represents a *Client Hello* message. Following
    that is 24 bits indicating the *Message Length*, that is, the number of bytes
    remaining in the packet. Then comes the 16-bit *Client TLS Version*, which is
    the version of TLS that the client is currently running, and the 32-bit *Client
    Random*, a nonce supplied during the TLS exchange.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的16个比特表示*TLS版本*，值为0x0303表示版本1.2。之后的16个比特表示*数据包长度*，即数据包的总字节长度。接下来是8位的*消息类型*（有关TLS
    v1.2握手过程中交换的消息类型列表，请参见[图9-2](ch09.xhtml#ch9fig2)）。值为0x01表示*Client Hello*消息。紧接着是24个比特，表示*消息长度*，即数据包中剩余的字节数。然后是16位的*客户端TLS版本*，表示客户端当前运行的TLS版本，以及32位的*客户端随机数*，这是TLS交换过程中提供的一个随机数。
- en: The next eight bits represent the *Session ID Length*. The Session ID identifies
    the session and is used to resume incomplete or failed sessions. We won’t use
    this field, and as you’ll see, we’ll set its length to 0x00\. The *Cipher Suite
    Length* is the length in bytes of the next field, which contains the *Cipher Suites*.
    In this case we will set the value of this field to 0x00,0x02 to indicate that
    the supported cipher suite information is two bytes long. As for the types of
    ciphers the client supports, we will use the value 0x00, 0x2f, indicating that
    the client supports RSA for key exchange and uses the 128-bit AES and a cipher
    block chaining mode for encryption (see [Chapter 5](ch05.xhtml#ch5) for more information
    on block cipher modes). The final 16 bits represent the *Extension Length*. We’re
    not using any extensions, so we’ll set this value to 0.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的八个比特表示*Session ID Length*。Session ID用于标识会话，并用于恢复未完成或失败的会话。我们不使用此字段，正如你将看到的，我们将其长度设置为0x00。*Cipher
    Suite Length*是下一个字段的字节长度，该字段包含*Cipher Suites*。在这种情况下，我们将该字段的值设置为0x00,0x02，表示支持的密码套件信息长为两个字节。至于客户端支持的密码类型，我们将使用值0x00,0x2f，表示客户端支持RSA密钥交换，并使用128位AES和密码块链接模式进行加密（有关块密码模式的更多信息，请参见[第5章](ch05.xhtml#ch5)）。最后16个比特表示*Extension
    Length*。我们不使用任何扩展，因此将该值设置为0。
- en: 'We can manually construct the packet by setting each of the bytes (sets of
    eight bits) ourselves. We’ll represent the values as hexadecimal numbers. Copy
    the following code snippet into your *heartbleed.py* file; I’ve pointed out each
    hexadecimal value using comments:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动设置每个字节（每组八位）来构造数据包。我们将以十六进制数表示这些值。将以下代码片段复制到你的*heartbleed.py*文件中；我已经用注释标出了每个十六进制值：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Great, we’ve constructed the *Client Hello* message. But before we send it,
    let’s discuss the structure of the packets we’ll receive in response.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经构造了*Client Hello*消息。但是在发送之前，让我们讨论一下我们将在响应中接收到的数据包结构。
- en: '***Reading the Server Response***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取服务器响应***'
- en: The server will transmit four packets, all of which have a similar structure
    to the *Client Hello* message. The type, version, packet length, and message type
    fields appear in the same location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将传输四个数据包，所有数据包的结构与*Client Hello*消息相似。类型、版本、数据包长度和消息类型字段出现在相同的位置。
- en: We can detect the *Server Done* message by inspecting the *Message Type*, located
    at the sixth byte. A hexadecimal value of 0x02 represents the *Server Hello*,
    whereas values of 0x0b, 0x0c and 0x0e represent the *Server Certificate* message,
    *Server Key Exchange* message, and *Server Done* message, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查第六个字节的*Message Type*来检测*Server Done*消息。十六进制值0x02表示*Server Hello*，而值0x0b、0x0c和0x0e分别表示*Server
    Certificate*消息、*Server Key Exchange*消息和*Server Done*消息。
- en: 'We’re not interested in actually establishing an encrypted connection, so we
    can ignore all the messages we receive from the server until we get the *Server
    Done* message. Once we’ve received this message, we’ll know that the server has
    completed its part of the handshake and we can now send our first Heartbeat message.
    Create a constant to hold the hexadecimal value representing the type *Server
    Done*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不关心实际建立加密连接，因此可以忽略从服务器收到的所有消息，直到收到*Server Done*消息。一旦我们收到该消息，就意味着服务器已经完成了握手的部分工作，我们现在可以发送第一个心跳消息。创建一个常量来保存表示类型*Server
    Done*的十六进制值：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s write a helper function that will ensure we correctly receive all
    the bytes associated with the TLS packet. This function will let us receive a
    fixed number of bytes from a socket. The function will wait for the operating
    system to finish loading bytes into the socket’s buffer and then will continue
    reading from the buffer until it has read the specified number of bytes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个辅助函数，确保我们正确接收与TLS数据包相关的所有字节。这个函数将使我们从套接字接收固定数量的字节。该函数将等待操作系统将字节加载到套接字的缓冲区中，然后继续从缓冲区读取，直到读取到指定数量的字节：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `select()` function to monitor the socket ➊. After the operating
    system has written to the buffer, the `select()` function will unblock and allow
    the program to progress to the next line. The `select()` function takes three
    parameters, which represent lists of communication channels to monitor. The first
    list contains channels that are readable, the second contains channels that are
    writable, and the third contains channels that should be monitored for errors.
    When a socket becomes readable or writable, or contains errors, it is returned
    by the `select()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`select()`函数来监控套接字 ➊。在操作系统将数据写入缓冲区后，`select()`函数将解除阻塞并允许程序继续执行到下一行。`select()`函数接受三个参数，表示要监控的通信通道的列表。第一个列表包含可读的通道，第二个包含可写的通道，第三个包含应监控错误的通道。当套接字变为可读或可写，或发生错误时，`select()`函数将返回该套接字。
- en: Then, the socket attempts to read the remaining bytes from the socket buffer
    ➋. The parameter represents the maximum number of bytes to read. If this is less
    than the maximum number of bytes available, the socket `recv()` function will
    read as many bytes as are available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，套接字尝试从套接字缓冲区读取剩余字节 ➋。该参数表示要读取的最大字节数。如果可用字节数小于最大字节数，套接字的`recv()`函数将读取所有可用的字节。
- en: 'The next function we’ll write will read packets from the socket and extract
    their type, version, and payload:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要编写的函数将从套接字中读取数据包，并提取其类型、版本和有效负载：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We read six bytes (0, 1, 2, 3, 4, and 5) from the socket ➊. These six bytes
    represent the header fields associated with TLS 1.2 packets discussed earlier:
    type, version, length, and message type.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从套接字 ➊中读取六个字节（0、1、2、3、4和5）。这六个字节表示与TLS 1.2数据包相关的头字段：类型、版本、长度和消息类型。
- en: Then, we’ll use the `struct` library to unpack the bytes into four variables
    ➋. The greater than sign (>) tells the `struct` library to interpret the bits
    in big-endian format. (In the big-endian format, the most significant byte is
    at the smallest address. Network packets are normally in big-endian format.) The
    `B` tells the `struct` library to extract the first byte (8 bits) as an unsigned
    char (a value between 0 and 255), and the `H` tells the `struct` library to extract
    the next two bytes (16 bits) as an unsigned short. We place the first 8-bit value
    into the `type` variable and the next two bytes into the `version` variable. Then
    we place the following two bytes in the `length` variable and the final byte in
    the `msgType` variable. The `length` field represents the length of the payload.
    If it’s greater than 0 ➌, we can read the remaining bytes associated with the
    packet from the socket.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`struct`库将字节解包成四个变量 ➋。大于符号（>）告诉`struct`库以大端格式解释这些字节。（在大端格式中，最重要的字节位于最小地址。网络数据包通常采用大端格式。）`B`告诉`struct`库提取第一个字节（8位）作为无符号字符（值在0到255之间），而`H`告诉`struct`库提取接下来的两个字节（16位）作为无符号短整数。我们将第一个8位值放入`type`变量，将接下来的两个字节放入`version`变量。然后，我们将接下来的两个字节放入`length`变量，最后一个字节放入`msgType`变量。`length`字段表示有效负载的长度。如果它大于0
    ➌，我们可以从套接字中读取与数据包相关的剩余字节。
- en: All messages have a similar structure, so we can reuse the same `readPacket`
    method for all subsequent packets we receive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息具有类似的结构，因此我们可以重用相同的`readPacket`方法来处理所有后续接收到的数据包。
- en: '***Crafting the Malicious Heartbeat Request***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造恶意心跳请求***'
- en: Once we’ve received the *Server Done* message, we can send the Heartbeat request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到*服务器完成*消息，我们就可以发送心跳请求。
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) represents the layout of a Heartbeat packet.
    Both the request and response packets follow this structure. The sixth byte identifies
    whether the packet is either a response or request.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch9fig4)表示了一个心跳包的布局。请求和响应包都遵循这个结构。第六个字节标识该包是响应包还是请求包。'
- en: '![image](../images/ch09fig04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig04.jpg)'
- en: '*Figure 9-4: A malicious Heartbeat packet*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：一个恶意心跳包*'
- en: 'Our malformed request message looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的格式错误的请求消息如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the discrepancy between the packet length ➊ of 3 bytes (which represents
    the remaining bytes in the packet) and the payload length ➋ of 64KB. Shouldn’t
    the packet length include payload length? How is it possible that the payload
    length is larger than the total packet size?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包长度 ➊（表示包中剩余字节）和有效负载长度 ➋（64KB）之间的差异。包长度不应该包括有效负载长度吗？怎么可能有效负载长度大于整个包的大小呢？
- en: This is the “malformed” aspect of the request. Remember from [Figure 9-1](ch09.xhtml#ch9fig1)
    that we’re specifying a payload length of 64KB, which is the largest we can specify
    with the allotted 16 bits, but that the actual payload size is 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是请求的“格式错误”部分。请记住从[图9-1](ch09.xhtml#ch9fig1)中看到的，我们指定了64KB的负载长度，这是我们可以在分配的16位中指定的最大值，但实际的负载大小为0。
- en: '***Reading the Leaked Memory Contents***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取泄露的内存内容***'
- en: 'As mentioned earlier, Heartbeat packets are limited to a maximum length of
    16KB. This means that the 64KB of memory the server sends in response will be
    split across four 16KB packets. Let’s write the function that will read all four
    packets from the socket and combine their payloads into a single 64KB payload:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，心跳数据包的最大长度为16KB。这意味着服务器响应的64KB内存将被分割成四个16KB的数据包。让我们编写一个函数，从套接字读取所有四个数据包，并将它们的负载合并成一个单一的64KB负载：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We call the `readPacket()` function four times to read the four Heartbeat responses
    we expect from the vulnerable server ➊. Then, we combine all the payloads of the
    four responses into a single payload ➋.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`readPacket()`函数四次，以读取我们预期从易受攻击的服务器获得的四个心跳响应 ➊。然后，我们将四个响应的所有负载合并成一个单一的负载
    ➋。
- en: '***Writing the Exploit Function***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写利用函数***'
- en: 'The following code snippet implements the `exploit()` function, which will
    send the malformed Heartbeat request and read the four Heartbeat response packets:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了`exploit()`函数，该函数将发送格式错误的心跳请求并读取四个心跳响应数据包：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The type value of `0x15` indicates a Heartbeat response packet ➊. Next, we send
    the malformed request ➋, and then we read the four response packets ➌. Lastly,
    we print the payload ➍.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x15`的类型值表示一个心跳响应数据包 ➊。接下来，我们发送格式错误的请求 ➋，然后读取四个响应数据包 ➌。最后，我们打印负载 ➍。'
- en: '***Putting It Together***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将所有内容结合起来***'
- en: 'In the program’s main method, we’ll create the socket, send the packets, and
    wait for the *Server Done* response. Copy the following code into your file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的主方法中，我们将创建套接字，发送数据包，并等待*服务器完成*响应。将以下代码复制到你的文件中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After we’ve created the socket, we can connect to the IP address that was passed
    as a command line argument ➊. We’ll connect on port 443 because it’s associated
    with the TLS protocol we’re attacking. Once connected, we initiate the TLS v1.2
    connection by sending the *Client Hello* message ➋. Then, we’ll listen for the
    response messages and inspect each type until we receive the *Server Done* message
    ➌. Lastly, we call the `exploit()` function ➍.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了套接字之后，我们可以连接到作为命令行参数传入的IP地址 ➊。我们将在443端口连接，因为它与我们正在攻击的TLS协议相关联。连接后，我们通过发送*客户端Hello*消息
    ➋来启动TLS v1.2连接。然后，我们将监听响应消息并检查每种类型，直到收到*服务器完成*消息 ➌。最后，我们调用`exploit()`函数 ➍。
- en: '**Fuzzing**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模糊测试**'
- en: How do hackers find bugs like Heartbleed? As you just saw, the process of exploiting
    this bug is so intricate that it’s amazing anyone could possibly discover it using
    efficient means. There’s even an entire team at Google, called Project Zero, dedicated
    to finding zero-day vulnerabilities. (In case you’re interested, the team posts
    new vulnerabilities they discover on its blog at *[https://googleprojectzero.blogspot.com/](https://googleprojectzero.blogspot.com/)*.)
    Let’s discuss some of the tools and techniques attackers and security researchers
    use to discover bugs like Heartbleed, beginning with a testing technique called
    *fuzzing*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客是如何发现像Heartbleed这样的漏洞的？正如你刚才看到的，利用这个漏洞的过程如此复杂，令人惊讶的是任何人能用高效的方法发现它。Google甚至有一个专门的团队，叫做Project
    Zero，专门负责发现零日漏洞。（如果你感兴趣，这个团队会在它的博客上发布它们发现的新漏洞，地址是* [https://googleprojectzero.blogspot.com/](https://googleprojectzero.blogspot.com/)*。）接下来，我们将讨论一些攻击者和安全研究人员用来发现像Heartbleed这样的漏洞的工具和技术，从一种名为*模糊测试*的测试技术开始。
- en: Fuzzing techniques attempt to generate inputs that explore all the possible
    paths in a program in the hopes of discovering one that will cause the program
    to crash or exhibit unintended behavior. Fuzzing was first proposed in 1988 by
    Barton Miller, a professor at the University of Wisconsin. Since then, companies
    like Google and Microsoft have developed their own fuzzers (tools for fuzzing)
    and use fuzzing to test their own systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试技术试图生成输入，探索程序中的所有可能路径，希望能发现一个导致程序崩溃或表现出非预期行为的路径。模糊测试最早由威斯康星大学的教授巴顿·米勒（Barton
    Miller）于1988年提出。从那时起，像Google和Microsoft这样的公司开发了自己的模糊测试工具，并使用模糊测试来测试他们的系统。
- en: '***A Simplified Example***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个简化的例子***'
- en: 'To understand the basic concept behind fuzzing, we’ll begin by considering
    the following example function, originally proposed by Jeff Foster at Tufts University:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解模糊测试的基本概念，我们将从考虑以下示例函数开始，该函数最初由塔夫茨大学的Jeff Foster提出：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the function accepts three parameters, `a`, `b`, and `c`, and
    it is considered to have executed correctly as long as its internal variables
    (`x`,`y`, and `z`) don’t add up to three. If they do, the program’s `assert` statement,
    which for the purposes of this example represents a critical failure, will be
    triggered.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数接受三个参数，`a`、`b`和`c`，只要它的内部变量（`x`、`y`和`z`）的总和不等于3，程序就认为执行正确。如果它们的总和为3，程序的`assert`语句将被触发，对于这个例子而言，`assert`语句代表一个关键失败。
- en: Our goal as fuzzers is to cause this failure. Can you identify the parameter
    values that will cause the `assert` statement to be triggered? One way to determine
    which inputs trigger the `assert` statement is to visualize the paths through
    the program as a tree. Every time we encounter an `if` statement, the tree branches
    to represent two possible options, one in which the branch is taken and the one
    in which it isn’t. [Figure 9-5](ch09.xhtml#ch9fig5) shows the paths in the preceding
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为模糊测试者的目标是引发这个失败。你能找出导致`assert`语句被触发的参数值吗？确定哪些输入会触发`assert`语句的一种方法是将程序的路径可视化为一棵树。每次遇到`if`语句时，树会分支，表示两种可能的选项：一种是分支被执行，另一种是没有执行。[图9-5](ch09.xhtml#ch9fig5)展示了前述函数的路径。
- en: '![image](../images/ch09fig05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig05.jpg)'
- en: '*Figure 9-5: A visualization of the execution paths in the test function*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：测试函数执行路径的可视化*'
- en: One of these paths triggers the `assert` statement. Consider what would happen
    if we supplied inputs of 0, 2, and 1 for `a`, `b`, and `c`. In Python, 0 is equivalent
    to `False`, whereas non-zero integers are considered `True`. Trace the path that
    the input takes through the tree. Notice that this path sets `x` to 0, `y` to
    1, and `z` to 2, which triggers the `assert` statement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径中的一条会触发`assert`语句。考虑如果我们为`a`、`b`和`c`提供输入值0、2和1会发生什么。在Python中，0等价于`False`，而非零整数被视为`True`。追踪这些输入在树中的路径。注意，这条路径将`x`设置为0，`y`设置为1，`z`设置为2，从而触发了`assert`语句。
- en: '***Writing Your Own Fuzzer***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写你自己的模糊测试器***'
- en: We had no trouble discovering a harmful input in the last example, but in larger
    programs, there could be millions of unique paths. Exploring them by hand would
    be very difficult.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们没有遇到发现有害输入的困难，但在更大的程序中，可能会有数百万条独特的路径。手动探索这些路径将非常困难。
- en: Could we write a program to generate test inputs? One approach would be to randomly
    generate inputs and wait for them to exercise all the paths in the program. This
    technique is called *random fuzzing*. Let’s write a basic random fuzzer. Our program
    will generate random integer values and pass those values to our test program’s
    parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否编写一个程序来生成测试输入？一种方法是随机生成输入，并等待它们执行程序中的所有路径。这种技术被称为*随机模糊测试*。让我们编写一个基础的随机模糊测试器。我们的程序将生成随机整数值，并将这些值传递给我们的测试程序的参数。
- en: 'Create a new file called *myFuzzer.py* and add the following contents:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*myFuzzer.py*的新文件，并添加以下内容：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the `testFunction()` function shown earlier into the file ➊. Our simple
    fuzzing program generates a random integer for each input variable ➋. Once we’ve
    generated a random value for each variable, we print the input to the screen before
    calling the function we’re testing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前显示的`testFunction()`函数复制到文件➊中。我们的简单模糊测试程序为每个输入变量生成一个随机整数➋。生成每个变量的随机值后，我们会在调用正在测试的函数之前，将输入打印到屏幕上。
- en: 'Save the file and then run the fuzzer using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后使用以下命令运行模糊测试工具：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fuzzer will cycle through random values until it finds one that stops the
    program. Experiment by increasing the range from 200 to 400\. The more random
    numbers the program needs to consider, the longer it will take to discover an
    input that crashes the program. This is one of the disadvantages of completely
    random fuzzing. You’ll need to cycle through many benign inputs to discover a
    useful one. Later in this chapter, we’ll look at ways to address this issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试工具将循环遍历随机值，直到找到一个能停止程序的值。试着将范围从200增加到400。程序需要考虑的随机数越多，发现一个能导致程序崩溃的输入就需要更长时间。这是完全随机模糊测试的一个缺点。你将需要循环遍历许多无害的输入，才能发现一个有用的输入。我们将在本章后面讨论如何解决这个问题。
- en: 'You might be wondering: Is generating input that crashes a program really that
    useful? Crashes are the first step to discovering bugs, which attackers can often
    exploit. But generating data that crashes a program can be very useful in its
    own right, too. If you can get an application to crash, you could execute a denial
    of service (DoS) attack. Imagine if you could discover input that crashes the
    Google DNS server or a cell tower. That would be pretty valuable.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：生成使程序崩溃的输入真的有那么有用吗？崩溃是发现漏洞的第一步，而攻击者通常可以利用这些漏洞。但生成使程序崩溃的数据本身也非常有用。如果你能让一个应用程序崩溃，你就能执行拒绝服务（DoS）攻击。想象一下，如果你能够发现一个输入，使得Google
    DNS服务器或一个手机塔崩溃，那将是非常有价值的。
- en: 'Or consider the following scenario: a hacker has fuzzed an intranet-connected
    traffic light control system. (Surprisingly, such devices are common.) The hacker
    discovers some input that crashes the system, thus disabling all of the traffic
    lights it controls. They’ve now discovered an input sequence that will allow them
    to disable traffic lights at will. This is very dangerous and is an excellent
    reminder of why it’s important for ethical hackers to penetration-test systems
    before they are deployed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者考虑以下场景：一个黑客对一个连接到内联网的交通信号灯控制系统进行模糊测试。（令人惊讶的是，这类设备很常见。）黑客发现某个输入导致系统崩溃，从而禁用了它控制的所有交通信号灯。现在，他们已经发现了一种能够随意禁用交通信号灯的输入序列。这非常危险，也很好地提醒我们为什么道德黑客需要在系统部署前进行渗透测试。
- en: '***American Fuzzy Lop***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***美国模糊测试工具***'
- en: Simply generating random input seems a bit wasteful as a larger search space
    will take longer to fuzz. Couldn’t we use information about the program’s paths
    to generate more focused, carefully crafted examples? Well, certain fuzzers *instrument*
    a program by inserting instructions that log the paths the program takes when
    it executes. These fuzzers attempt to generate new inputs that explore previously
    unexplored paths. Given a set of preexisting test cases, they’ll mutate the inputs
    by adding or subtracting some random information, keeping the new tests only if
    they explore new paths in the program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯生成随机输入似乎有点浪费，因为较大的搜索空间需要更长时间进行模糊测试。难道我们不能利用程序路径的信息来生成更有针对性、更精心设计的测试用例吗？实际上，某些模糊测试器通过插入指令来*注入*程序，以记录程序在执行时所经过的路径。这些模糊测试器试图生成新的输入，探索以前未被探索的路径。给定一组现有的测试用例，它们会通过添加或减去一些随机信息来变异输入，仅当新的测试用例探索程序中的新路径时，才会保留它们。
- en: The *American Fuzzy Lop (AFL)* is one such fuzzer. Originally written by Michal
    Zalewski at Google, AFL uses a *genetic algorithm* to mutate test cases and create
    new inputs that test unexplored paths. A genetic algorithm is a biologically inspired
    learning algorithm. It accepts inputs, such as a = 0, b = 2, and c = 1, and then
    encodes them as a vector [0, 2, 1] similar to a sequence of genes in someone’s
    DNA, like ATGCT. Armed with these vectors, the fuzzer keeps track of the number
    of paths explored when the program uses a particular input sequence, say, [0,
    2, 1]. Genes that are similar will explore similar paths, thus reducing the likelihood
    of exploring a new path.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*美国模糊测试工具（AFL）* 就是其中一个模糊测试工具。最初由谷歌的Michal Zalewski编写，AFL使用*遗传算法*来变异测试用例，并创建新的输入以测试未被探索的路径。遗传算法是一种生物启发的学习算法。它接受输入，例如a
    = 0，b = 2，c = 1，然后将它们编码为向量[0, 2, 1]，类似于某人DNA中的基因序列，如ATGCT。利用这些向量，模糊测试器跟踪当程序使用特定输入序列（如[0,
    2, 1]）时探索的路径数量。相似的基因将探索相似的路径，从而减少探索新路径的可能性。'
- en: The fuzzer creates new genetic input sequences by introducing randomness to
    the values of existing sequences. For example, the input sequence [0, 2, 1] may
    become [4, 0, 1]. Here, the genetic algorithm chose to mutate the first and second
    elements by randomly adding four and subtracting two, respectively. Genetic algorithm
    implementations often allow programs to choose how often mutations occur and whether
    to make large or small changes. The new sequence is then fed to the program. If
    the sequence explores a new path, the input is maintained, and if it doesn’t,
    it is deleted or mutated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试器通过引入随机性来创建新的遗传输入序列，修改现有序列的值。例如，输入序列[0, 2, 1]可能变成[4, 0, 1]。在这里，遗传算法选择通过随机地加上四和减去二来变异第一个和第二个元素。遗传算法的实现通常允许程序选择变异发生的频率，并决定是进行大幅度变化还是小幅度变化。然后，将新的序列输入到程序中。如果该序列探索了新路径，则保留输入，如果没有，则删除或再变异。
- en: There are plenty of other mutation strategies that you can explore. For example,
    crossovers mix sequences from two genes to create a new gene. You can read more
    about genetic algorithms in John Holland’s original paper, “Genetic Algorithms
    and Adaptation” (Adaptive Control of Ill-Defined Systems, 1984).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以探索许多其他的变异策略。例如，交叉操作通过混合来自两个基因的序列来创建一个新基因。你可以在约翰·霍兰德的原始论文《遗传算法与适应》（《不确定系统的自适应控制》，1984年）中阅读更多关于遗传算法的内容。
- en: '**Installing AFL**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**安装 AFL**'
- en: 'Let’s run AFL to discover an input sequence that causes the `testFunction()`
    function to crash. You can download AFL from Google’s offical GitHub page. Clone
    the AFL repository by running the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 AFL 来发现一个能让 `testFunction()` 函数崩溃的输入序列。你可以从 Google 的官方 GitHub 页面下载 AFL。通过运行以下命令克隆
    AFL 仓库：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, navigate to the *AFL* directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到 *AFL* 目录：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and install the program by running the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来编译和安装程序：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'AFL was originally designed to fuzz C and C++ programs. AFL instruments these
    programs by compiling the source code and instrumenting the binary. We won’t be
    fuzzing C programs, so we’ll need to install `python-afl`, a program that extends
    AFL’s functionality to Python programs. We’ll use `pip3` to install the module.
    If you don’t already have it, run the following command to install `pip`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: AFL 最初是为模糊 C 和 C++ 程序而设计的。AFL 通过编译源代码并对二进制文件进行插桩来实现对这些程序的模糊测试。我们不打算对 C 程序进行模糊测试，因此我们需要安装
    `python-afl`，一个将 AFL 功能扩展到 Python 程序的工具。我们将使用 `pip3` 来安装该模块。如果你还没有安装 `pip`，请运行以下命令来安装：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, install `python-afl` by running the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过运行以下命令安装 `python-afl`：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that you’ve installed `python-afl`, let’s use it to fuzz the test function.
    Create a new Desktop folder called *Fuzzer*, and within the *Fuzzer* folder, create
    three folders called *TestInput*, *App*, and *Results*. We’ll store our test input
    files in the *TestInput* folder, and the results of our fuzz in the *Results*
    folder. We’ll store the code for the app that we want to fuzz in the *App* folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 `python-afl`，让我们用它来模糊测试测试函数。创建一个名为 *Fuzzer* 的新文件夹，并在 *Fuzzer* 文件夹中创建三个文件夹，分别命名为
    *TestInput*、*App* 和 *Results*。我们将在 *TestInput* 文件夹中存储我们的测试输入文件，在 *Results* 文件夹中存储我们的模糊测试结果，并将我们要模糊测试的应用程序代码存储在
    *App* 文件夹中。
- en: '**Modifying the Program**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**修改程序**'
- en: 'The `python-afl` fuzzer assumes that test inputs are read in from a file supplied
    via *std.in*, so we’ll need to modify the program to do so. The following program
    reads values for `a`, `b`, and `c` from *std.in*, which are then converted from
    strings to integers and passed to the test function. Create a file called *fuzzExample.py*
    in the *App* folder and add the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`python-afl` 模糊测试器假设测试输入是从通过 *std.in* 提供的文件中读取的，因此我们需要修改程序来实现这一点。以下程序从 *std.in*
    中读取 `a`、`b` 和 `c` 的值，然后将它们从字符串转换为整数，并传递给测试函数。创建一个名为 *fuzzExample.py* 的文件，放在 *App*
    文件夹中，并添加以下代码：'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to copy the test function into the location specified by the comment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将测试函数复制到注释中指定的位置。
- en: 'Next, we read the contents from *std.in* ➊. We then strip trailing spaces and
    newline characters ➋. We also split up the line into three variables: `a`, `b`,
    and `c`. At ➌, we instruct the AFL library to begin instrumenting the program
    by calling `afl.init()`. Then, we execute our main method before exiting ➍. It’s
    good practice to call `os._exit(0)` so that you can quickly terminate the fuzzing
    run, but this isn’t required.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从 *std.in* 中读取内容 ➊。然后，我们去除末尾的空格和换行符 ➋。我们还将这一行分割成三个变量：`a`、`b` 和 `c`。在 ➌
    处，我们指示 AFL 库通过调用 `afl.init()` 来开始对程序进行插桩。然后，我们执行主方法并在 ➍ 处退出。调用 `os._exit(0)` 是一种良好的实践，这样可以快速终止模糊测试运行，但这并非必须的。
- en: '**Creating Test Cases**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建测试用例**'
- en: 'Next, we need some test cases to pass to our program. Open a terminal and navigate
    to the *Fuzzer* folder on your Desktop by running this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些测试用例来传递给程序。打开终端并通过运行此命令，导航到桌面上的 *Fuzzer* 文件夹：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the following command to create a *testInput1.txt* file in the *TestInput*
    folder that contains the values `0`, `1`, and `1`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，在 *TestInput* 文件夹中创建一个包含 `0`、`1` 和 `1` 的 *testInput1.txt* 文件：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Redirect* (<) these values into the program by running this command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此命令，将这些值 *重定向* (<) 到程序中：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you’ve done everything correctly, your program should run without printing
    anything. If something does print out, read the error message and ensure that
    you’ve followed the instructions carefully.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确完成了所有步骤，你的程序应该不会输出任何内容。如果有输出，请阅读错误信息，确保你仔细遵循了说明。
- en: 'Create two additional test files by running the following commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建两个额外的测试文件：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Fuzzing the Program**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**对程序进行模糊测试**'
- en: 'Now that we’ve explored the code, let’s fuzz it. Here is the general format
    for running the `py-afl-fuzz` program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了代码，接下来进行模糊测试。以下是运行`py-afl-fuzz`程序的一般格式：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before fuzzing your Python program, disable the AFL Fork Server functionality.
    This performance optimization is problematic for the Python AFL fuzzer, so run
    the following command to deactivate it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在对你的Python程序进行模糊测试之前，请禁用AFL Fork Server功能。这个性能优化对于Python AFL模糊测试工具来说是一个问题，所以请运行以下命令来停用它：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can fuzz the Python file by running the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令对Python文件进行模糊测试：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see the following screen, which should update in real time as the
    program is being fuzzed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下屏幕，程序在进行模糊测试时应实时更新：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To find the inputs that crashed your program, navigate to the *Crashes* folder
    inside the *Results* folder. This folder contains the input files that crashed
    the program. You’ll notice inputs like an empty file and a file with invalid characters.
    However, you should also notice a file with valid inputs that took the path discussed
    earlier, activating the assert statement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到导致程序崩溃的输入文件，进入*Results*文件夹中的*Crashes*文件夹。该文件夹包含导致程序崩溃的输入文件。你会注意到像空文件和包含无效字符的文件。然而，你还应该注意到一个包含有效输入的文件，这个文件执行了之前讨论的路径，激活了断言语句。
- en: '**Symbolic Execution**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**符号执行**'
- en: Wouldn’t it be amazing if we could analyze a program without executing it? *Symbolic
    execution* is a technique that uses symbols instead of real data to perform static
    analysis on a program. As the symbolic execution engine explores paths in a program,
    it builds path equations that can be solved to determine when a particular branch
    will be taken. [Figure 9-6](ch09.xhtml#ch9fig6) shows the path constraints associated
    with the test function we explored earlier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在不执行程序的情况下分析它，那该多好啊？*符号执行*是一种使用符号而不是实际数据对程序进行静态分析的技术。当符号执行引擎探索程序中的路径时，它构建出路径方程式，这些方程式可以被求解，从而确定何时会选择特定的分支。[图9-6](ch09.xhtml#ch9fig6)展示了我们之前探索的测试函数的路径约束。
- en: '![image](../images/ch09fig06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig06.jpg)'
- en: '*Figure 9-6: A computation tree that visualizes the execution paths and path
    constraints of the test function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：可视化测试函数执行路径和路径约束的计算树*'
- en: 'To programmatically solve these path constraints, we use something called a
    *theorem prover*. A theorem prover answers questions like: Is there a value for
    `x` such that `x` *×* 5 == 15? If so, what is the value? The Z3 theorem prover
    is a popular prover developed by Microsoft. A detailed discussion of theorem proving
    is beyond the scope of this book, but we’ll consider it in the context of our
    test program.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以编程方式解决这些路径约束，我们使用一种叫做*定理证明器*的工具。定理证明器可以回答这样的问题：是否存在一个`x`，使得`x` *×* 5 == 15？如果存在，`x`的值是多少？Z3定理证明器是微软开发的一个流行证明器。关于定理证明的详细讨论超出了本书的范围，但我们将在测试程序的上下文中讨论它。
- en: '***A Symbolic Execution of the Test Program***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试程序的符号执行***'
- en: The theorem prover helps discover inputs that activate each path by evaluating
    each path condition. Consider the path that leads to the failure state shown in
    [Figure 9-6](ch09.xhtml#ch9fig6). Let’s see how symbolic execution uses a theorem
    prover to identify that this is a reachable path.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定理证明器通过评估每个路径条件，帮助发现激活每个路径的输入。考虑导致故障状态的路径，如[图9-6](ch09.xhtml#ch9fig6)所示。让我们看看符号执行如何使用定理证明器来识别这是一个可达路径。
- en: First, the symbolic engine begins by symbolically executing the program. The
    inputs `a`, `b`, and `c` are replaced by symbolic values *α*, *β*, and *λ*. When
    the engine encounters the `if` statement `if (a):`, it asks the theorem prover
    if there is a value of *α* that would evaluate to true. If there is, the theorem
    prover would return yes. Similarly, we ask the theorem prover to see if there
    is a value of *α* that evaluates to false, to which the theorem prover would return
    yes. This means that the symbolic execution engine must explore both paths.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，符号引擎开始符号执行程序。输入`a`、`b`和`c`被替换为符号值*α*、*β*和*λ*。当引擎遇到`if`语句`if (a):`时，它会询问定理证明器是否存在一个使*α*为真值的值。如果存在，定理证明器将返回“是”。类似地，我们会询问定理证明器是否存在一个使*α*为假值的值，定理证明器也会返回“是”。这意味着符号执行引擎必须探索两个路径。
- en: 'Assuming that the symbolic execution engine first explores the path where *α*
    evaluates to false, it will encounter another conditional: `if (b < 5):`. This
    will result in a new path condition where *α* is not true and *β* is less than
    five.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设符号执行引擎首先探索*α*为假的路径，它会遇到另一个条件：`if (b < 5):`。这将导致一个新的路径条件，其中*α*为假，且*β*小于五。
- en: 'Again, we ask the theorem prover if there exists a value for *α* and *β* for
    which this condition is either true or false, to which the theorem prover would
    return yes. Let’s assume that we explore the true branch. The symbolic engine
    will encounter the third and final conditional: `if (not a and c):`. This results
    in the final path constraint where *α* is not true, *β* is less than five, and
    *λ* is true. Now we can ask the theorem prover to return values of *α*, *β*, and
    *λ* for which this path condition is true. The theorem prover might very well
    return *α* = 0, *β* = 4 and *λ* = 1, the input that happens to get us to our failure
    state.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们询问定理证明器，是否存在某个*α*和*β*的值，使得该条件为真或为假，定理证明器将返回“是”。假设我们探索了“真”的分支，符号引擎将遇到第三个也是最后一个条件：`if
    (not a and c):`。这将导致最终的路径约束，其中*α*为假，*β*小于五，且*λ*为真。现在我们可以要求定理证明器返回*α*、*β*和*λ*的值，使得这个路径条件为真。定理证明器很可能会返回*α*
    = 0，*β* = 4，*λ* = 1，这个输入恰好使我们进入失败状态。
- en: The symbolic execution engine will repeat this process for all possible paths
    and generate a collection of test cases to execute all the paths.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 符号执行引擎将对所有可能的路径重复这个过程，并生成一组测试用例来执行所有路径。
- en: '***Limitations of Symbolic Execution***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***符号执行的局限性***'
- en: 'However, there are constraints that the theorem prover can’t solve. Consider
    our discussion of the Diffie-Hellman key exchange algorithm from [Chapter 6](ch06.xhtml#ch6).
    Recall that recovering a private key from a public key would require solving the
    discrete inverse log problem. Consider this example function originally proposed
    by Mayur Naik at the University of Pennsylvania:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定理证明器有一些无法解决的限制。考虑我们在[第6章](ch06.xhtml#ch6)中讨论的Diffie-Hellman密钥交换算法。回想一下，从公钥恢复私钥需要解决离散对数问题。考虑这个最初由宾夕法尼亚大学的Mayur
    Naik提出的示例函数：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Evaluating the condition ➊ would require finding a value for `x` that would
    make the condition true, thus solving the following equation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 评估条件➊将需要找到一个`x`值，使得该条件为真，从而解出以下方程：
- en: 2*^x* mod *c* = 17
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2*^x* mod *c* = 17
- en: This is equivalent to solving the inverse log problem, and no one currently
    knows how to solve the inverse log problem efficiently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于解决逆对数问题，目前没有人知道如何有效地解决逆对数问题。
- en: If the theorem prover can’t evaluate a condition, it assumes that both the true
    and false options are possible, and the symbolic engine will explore both paths.
    However, this result is incorrect as a value of `x` that makes this condition
    true does not exist. This limitation leads the symbolic execution engine to explore
    paths that aren’t feasible. For this reason and others, symbolic execution does
    not scale for large programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定理证明器无法评估某个条件，它假设条件的真假两种情况都有可能，符号引擎将探索这两条路径。然而，这个结果是错误的，因为不存在能使条件为真的`x`值。这一限制导致符号执行引擎探索那些不可行的路径。由于这个原因和其他原因，符号执行无法在大型程序中扩展。
- en: As the number of paths grows, so does the number of path equations, which makes
    symbolic execution less feasible for large programs. Instead, testers often use
    a hybrid approach, called *concolic execution* or *dynamic symbolic execution*.
    One of the earliest such projects was the Symbolic PathFinder (SPF) developed
    by a team at NASA. These techniques combine the dynamic execution of fuzzing with
    the static analysis techniques used by symbolic execution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着路径数量的增加，路径方程的数量也会增加，这使得符号执行在大型程序中变得不太可行。相反，测试人员通常使用一种混合方法，称为*合成执行*或*动态符号执行*。其中一个最早的项目是由NASA团队开发的符号路径查找器（SPF）。这些技术将模糊测试的动态执行与符号执行中使用的静态分析技术结合在一起。
- en: '**Dynamic Symbolic Execution**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态符号执行**'
- en: Dynamic Symbolic Execution (DSE) combines dynamic execution techniques like
    fuzzing with ideas from symbolic execution. In addition to symbolic variables
    and path constraints, DSE keeps track of the concrete values supplied as the original
    input to the program, and it completely explores a path exercised by these concrete
    variables. The path constraints that result from this exploration are then used
    to generate new concrete variables that explore new paths. [Figure 9-7](ch09.xhtml#ch9fig7)
    shows an example path taken by the DSE engine when concrete variables `a` = 0,
    `b` = 4, and `c` = 0 are used.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 动态符号执行（DSE）结合了像模糊测试这样的动态执行技术与符号执行的思想。除了符号变量和路径约束外，DSE 还跟踪作为程序原始输入提供的具体值，并完全探索这些具体变量所执行的路径。由此探索产生的路径约束用于生成新的具体变量，以探索新的路径。[图
    9-7](ch09.xhtml#ch9fig7)展示了当具体变量 `a` = 0, `b` = 4, `c` = 0 时，DSE 引擎所经过的路径示例。
- en: '![image](../images/ch09fig07.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig07.jpg)'
- en: '*Figure 9-7: An example of a path taken by the DSE engine*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：DSE 引擎执行路径示例*'
- en: To truly understand the DSE engine’s inner workings, consider the state of the
    concrete variables, symbolic variables, and path constraints as the DSE engine
    executes each line of the test function. Each row of [Table 9-1](ch09.xhtml#ch9tab1)
    represents a step in the execution process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解 DSE 引擎的内部工作原理，考虑在 DSE 引擎执行测试函数的每一行时，具体变量、符号变量和路径约束的状态。每一行的[表 9-1](ch09.xhtml#ch9tab1)表示执行过程中的一步。
- en: '**Table 9-1:** The Concrete Variables, Symbolic Variables, and Path Constraints
    Collected on One Pass of the Concolic Engine'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：Concolic 引擎单次执行过程中的具体变量、符号变量和路径约束**'
- en: '| Line | Code | Concrete vars | Symbolic vars | Path constraints |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 行号 | 代码 | 具体变量 | 符号变量 | 路径约束 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | `def testFunction(a,b,c):` | *a* = 0, *b* = 4, *c* = 0 |  |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `def testFunction(a,b,c):` | *a* = 0, *b* = 4, *c* = 0 |  |  |'
- en: '| 2 |     `x, y, z = 0, 0, 0` | *x* = 0, *y* = 0, *z* = 0 |  |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 2 |     `x, y, z = 0, 0, 0` | *x* = 0, *y* = 0, *z* = 0 |  |  |'
- en: '| 3 |     `if (a):` |  | *α* = *a* | *α* == *false* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 3 |     `if (a):` |  | *α* = *a* | *α* == *false* |'
- en: '| 4 |           `x = -2` |  |  |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 4 |           `x = -2` |  |  |  |'
- en: '| 5 |     `if (b < 5):` |  | *β* = *b* | *β* < 5 == true |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 5 |     `if (b < 5):` |  | *β* = *b* | *β* < 5 == true |'
- en: '| 6 |           `if (not a and c):` |  | *λ* = *c* | (¬*α* ∧ *λ*) == *false*
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 6 |           `if (not a and c):` |  | *λ* = *c* | (¬*α* ∧ *λ*) == *false*
    |'
- en: '| 7 |                    `y = 1` |  |  |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 7 |                    `y = 1` |  |  |  |'
- en: '| 8 |           `z = 2` | *z* = 2 |  |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 8 |           `z = 2` | *z* = 2 |  |  |'
- en: '| 9 |     `assert(x + y + z != 3)` |  |  |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 9 |     `assert(x + y + z != 3)` |  |  |  |'
- en: At line 1, the values of *a*, *b*, and *c* are randomly initialized with the
    values 0, 4, and 0, respectively. As the DSE engine executes, it keeps track of
    each new variable it encounters, so when it gets to line 2, it stores *x* = 0,
    *y* = 0, and *z* = 0 in the collection of concrete variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行，*a*、*b* 和 *c* 的值随机初始化为 0、4 和 0。当 DSE 引擎执行时，它跟踪每一个遇到的新变量，因此当它执行到第 2 行时，它将
    *x* = 0、*y* = 0 和 *z* = 0 存储在具体变量集合中。
- en: At this point, the DSE engine moves to line 3, where it encounters the first
    `if` statement. Each new conditional statement results in the creation of a new
    path constraint and, if necessary, new symbolic variables. Here the DSE engine
    creates a new symbolic variable *α* = *a* to represent the concrete variable *a*,
    which has the value 0\. Unlike a symbolic execution engine, which uses the theorem
    prover to decide whether to explore a branch, the DSE engine simply evaluates
    the condition by substituting the concrete variable. The condition `if(a)` reduces
    to `if(0)` because the value of *a* is 0\. This easily evaluates to false, so
    the DSE engine also adds the path constraint *α* == *false* and does not take
    the branch. Because the condition evaluated to false, the DSE engine doesn’t execute
    line 4.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，DSE 引擎移动到第 3 行，遇到第一个 `if` 语句。每一个新的条件语句都会创建一个新的路径约束，并在必要时创建新的符号变量。在这里，DSE
    引擎创建了一个新的符号变量 *α* = *a* 来表示具体变量 *a*，其值为 0。与符号执行引擎不同，符号执行引擎使用定理证明器来决定是否探索某个分支，而
    DSE 引擎通过替换具体变量直接评估条件。条件 `if(a)` 简化为 `if(0)`，因为 *a* 的值是 0。这个条件轻松评估为 false，因此 DSE
    引擎也添加了路径约束 *α* == *false* 并不执行该分支。由于条件评估为 false，DSE 引擎不执行第 4 行。
- en: During the next step, the DSE engine encounters the second condition `if (b
    < 5):` at line 5\. Here, the DSE engine creates a symbolic variable *β* = *b*
    and uses the concrete value of *b* to determine whether to take the branch. In
    this case, *b* = 4, so the branch is taken. The DSE engine then adds the path
    constraint *β* less than five is true (*β* < 5 == *true*) and moves on to the
    third and final condition at line 6.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，DSE引擎遇到了第二个条件`if (b < 5):`，位于第5行。此时，DSE引擎创建了一个符号变量*β* = *b*，并使用*b*的具体值来决定是否采取该分支。在这种情况下，*b*
    = 4，因此该分支被执行。DSE引擎然后添加路径约束*β*小于五为真 (*β* < 5 == *true*)，并继续执行到第6行的第三个也是最后一个条件。
- en: Here, the DSE engine encounters a new variable *c*. It creates a new symbolic
    variable *λ* = *c* and evaluates the condition `if (not a and c):` using the concrete
    variables *a* = 2 and *c* = 0\. In this case, the branch is not taken, so the
    DSE engine adds the path condition (*¬**α* *∧* λ) == *false*. The DSE engine then
    proceeds to line 8, where it updates the concrete variable *z* to store the value
    2, and ends at line 9\. In this case *z* = 2, *x* = 0, and *y* = 0, so the `assert`
    statement (`assert(x + y + z != 3)`) is not triggered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，DSE引擎遇到了一个新变量*c*。它创建了一个新的符号变量*λ* = *c*，并使用具体变量*a* = 2 和 *c* = 0 来评估条件`if
    (not a and c):`。在这种情况下，分支没有被采取，因此DSE引擎添加了路径条件 (*¬**α* *∧* λ) == *false*。然后，DSE引擎继续执行到第8行，将具体变量*z*更新为存储值2，并在第9行结束。在这种情况下，*z*
    = 2，*x* = 0 和 *y* = 0，因此`assert`语句（`assert(x + y + z != 3)`）没有触发。
- en: 'When the program gets to the end of a path, it backtracks to the last branch
    it took and negates the most recently added value in the path constraints. In
    our example, the new path condition would be *α* not true, *β* less than five,
    and *λ* is true, or in equation form:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序到达路径的末端时，它会回溯到最后一个分支并否定路径约束中最近添加的值。在我们的示例中，新的路径条件将是*α*不为真，*β*小于五，并且*λ*为真，或者用方程式表示：
- en: ¬*α* ∧ (*β* < 5) ∧ *λ*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ¬*α* ∧ (*β* < 5) ∧ *λ*
- en: Once the DSE engine has the new constraint, it uses the theorem prover to find
    the values for *α*, *β*, and *λ* that satisfy this equation. In this case, the
    solver might return *a* = 0, *b* = 4, and *c* = 1\. These new values will allow
    the DSE engine to explore the other branch. [Figure 9-8](ch09.xhtml#ch9fig8) illustrates
    backtracking to explore a new path.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DSE引擎得到了新的约束，它就使用定理证明器来找到满足此方程的*α*、*β*和*λ*的值。在这种情况下，求解器可能返回 *a* = 0，*b* =
    4 和 *c* = 1。 这些新值将允许DSE引擎探索另一个分支。[图 9-8](ch09.xhtml#ch9fig8)展示了回溯以探索新路径。
- en: '![image](../images/ch09fig08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch09fig08.jpg)'
- en: '*Figure 9-8: The process of backtracking to negate the last path constraint*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：* 回溯过程以否定最后的路径约束'
- en: 'The DSE engine will then reset and repeat the process using new input values.
    When it gets to the end of the path with the new input, the DSE engine will negate
    the second most recently added constraint. This process continues recursively
    until the DSE engine has explored all the paths in the path tree. Here’s a challenge:
    see if you can construct the table that shows the concrete values, symbolic variables,
    and path constraints that would cause the DSE engine to identify the failure state.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，DSE引擎会重置并使用新的输入值重复此过程。当它到达新输入的路径末端时，DSE引擎会否定第二个最近添加的约束。这个过程会递归进行，直到DSE引擎已经探索完路径树中的所有路径。这里有一个挑战：看看你是否能构建出显示具体值、符号变量和路径约束的表格，导致DSE引擎识别失败状态。
- en: Now let’s highlight the power of concolic execution by looking at an example
    that would be difficult to solve with symbolic execution alone ([Table 9-2](ch09.xhtml#ch9tab2)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个例子来突出共符执行的优势，这个例子仅靠符号执行是难以解决的（[表 9-2](ch09.xhtml#ch9tab2)）。
- en: 'As before, we execute the program to the end of the path using concrete variables.
    When we get to the end, we take the inverse of the last constraint that was added.
    The inverse is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们使用具体变量执行程序直到路径末端。当我们到达末端时，我们取最后添加的约束的逆。逆约束如下：
- en: '*f*^(–1)(*x* ≠ *sha*256(*y*[0])) *→* *x* = *sha*256(*y*[0])'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^(–1)(*x* ≠ *sha*256(*y*[0])) *→* *x* = *sha*256(*y*[0])'
- en: '**Table 9-2:** The Concrete Variables, Symbolic Variables, and Path Constraints
    Collected in One Pass'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 一次遍历中收集的具体变量、符号变量和路径约束'
- en: '| Code | Concrete vars | Symbolic vars | Path constraints |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 具体变量 | 符号变量 | 路径约束 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `from hashlib import sha256 def hashPass(x):     return sha256(x)` |  |  |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `from hashlib import sha256 def hashPass(x):     return sha256(x)` |  |  |  |'
- en: '| `def checkMatch(x,y):    z = hashPass(y)    if (x == z ):       assert(true)
    else:     assert(false)` | *x* = 2, *y* = 1 *z* = 6*b*....*b*4*b* | *x*[0] = *x*,
    *y*[0] = *y* *z* = *sha*256(*y*[0]) | *x*[0] ≠ *sha*256(*y*[0]) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `def checkMatch(x,y):    z = hashPass(y)    if (x == z ):       assert(true)
    else:     assert(false)` | *x* = 2, *y* = 1 *z* = 6*b*....*b*4*b* | *x*[0] = *x*,
    *y*[0] = *y* *z* = *sha*256(*y*[0]) | *x*[0] ≠ *sha*256(*y*[0]) |'
- en: 'The SHA-256 hash function used in the code is a one-way function, so a solver
    won’t be able to solve for the values of *x* and *y* that satisfy this constraint.
    However, we can simplify the constraint by substituting our symbolic variable
    *y*[0] with its concrete value *y* = 1:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中使用的 SHA-256 哈希函数是一个单向函数，因此解算器无法求解出满足此约束的 *x* 和 *y* 的值。但是，我们可以通过将我们的符号变量 *y*[0]
    替换为它的具体值 *y* = 1 来简化约束：
- en: '*x* == *sha*256(*y*[0]) *→* *x* == *sha*256(1) *→* *x* == 6*b*....*b*4*b*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* == *sha*256(*y*[0]) *→* *x* == *sha*256(1) *→* *x* == 6*b*....*b*4*b*'
- en: We now have a satisfiable equation that we easily can solve.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以轻松求解的可满足方程。
- en: DSE is not perfect though. There are still instances when it doesn’t explore
    all paths in a program. But fuzzing and DSE are some of the best tools we have
    for discovering zero-day vulnerabilities. Let’s look at some programs that allow
    you to perform testing with DSE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DSE 不是完美的，仍然有些情况下它无法探索程序中的所有路径。但模糊测试（fuzzing）和 DSE 是我们发现零日漏洞的最佳工具之一。让我们看一些可以使用
    DSE 进行测试的程序。
- en: '**Using DSE to Crack a Passcode**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 DSE 破解密码**'
- en: Let’s uncover a user’s password by using a concolic engine called *Angr*. Angr
    was created by Yan Shoshitaishvili and others, while they were members of Giovanni
    Vigna’s research team at University of Santa Barbara. Instead of analyzing a specific
    programming language, Angr analyzes the binaries that you get when you compile
    a program, which makes it language independent. We’ll practice using it in this
    section, but first we must create the program to test.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个名为 *Angr* 的符号执行引擎来破解用户的密码。Angr 是由 Yan Shoshitaishvili 等人创建的，他们当时是 Giovanni
    Vigna 研究团队的一员，所在的机构是圣塔芭芭拉大学。Angr 不分析特定的编程语言，而是分析你在编译程序时得到的二进制文件，这使得它与编程语言无关。我们将在本节中练习使用它，但首先我们需要创建程序进行测试。
- en: '***Creating an Executable Binary***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建可执行二进制文件***'
- en: Create a folder on your Kali Linux Desktop called *Concolic* and create a new
    file within it called *simple.c*. This is the file we’ll compile.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Kali Linux 桌面上创建一个名为*Concolic*的文件夹，并在其中创建一个名为*simple.c*的新文件。这就是我们要编译的文件。
- en: 'Copy the following code into the file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到文件中：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This program is implemented in the C programming language. The program prompts
    the user to enter a password and then checks to see if the password matches `7857`
    (the correct value). If the password matches, the program prints `Access Granted`.
    Otherwise, it prints `Access Denied`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序是用 C 编程语言实现的。程序提示用户输入密码，并检查密码是否与 `7857`（正确的值）匹配。如果密码匹配，程序将打印 `Access Granted`。否则，它会打印
    `Access Denied`。
- en: 'Open a terminal and navigate to the *Concolic* folder you created on your Desktop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并导航到你在桌面上创建的 *Concolic* 文件夹：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile the *simple.c* program to create a binary (the file that contains the
    machine code) by running the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，将 *simple.c* 程序编译成一个二进制文件（包含机器代码的文件）：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This program runs the `gcc` compiler that comes preinstalled on Kali Linux,
    which will compile the *simple.c* file and output (`-o`) a binary called *simple*.
    Test your new binary by running the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序运行 Kali Linux 中预装的 `gcc` 编译器，将 *simple.c* 文件编译并输出（`-o`）一个名为 *simple* 的二进制文件。通过运行以下命令测试你新生成的二进制文件：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***Installing and Running Angr***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装与运行 Angr***'
- en: 'We recommend that you run Angr within a virtual Python environment. A virtual
    environment isolates the libraries that Angr uses from the libraries in your regular
    environment, which reduces errors caused by conflicting versions of libraries.
    Run the following command to install Python’s virtual environment wrapper (`virtualenvwrapper`)
    and its dependencies:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在一个虚拟的 Python 环境中运行 Angr。虚拟环境将 Angr 使用的库与常规环境中的库隔离开来，从而减少由库版本冲突导致的错误。运行以下命令来安装
    Python 的虚拟环境封装器（`virtualenvwrapper`）及其依赖项：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, configure the terminal and activate the virtual environment wrapper,
    which will allow you to create new virtual environments:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置终端并激活虚拟环境封装器，这样你就可以创建新的虚拟环境：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now create a new virtual environment called `angrEnv` and set it up to use
    Python 3:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`angrEnv`的新虚拟环境，并设置它使用 Python 3：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, install Angr in this new environment:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个新环境中安装 Angr：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you set everything up correctly, you should see the `angrEnv` label in your
    terminal as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确设置了一切，你应该会在终端中看到`angrEnv`标签，如下所示：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angr is well documented, so before you continue, I recommend that you read the
    core concept section of the Angr documentation. Also try completing the Python
    interactive shell exercises listed at *[https://docs.angr.io/core-concepts/toplevel/](https://docs.angr.io/core-concepts/toplevel/)*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Angr有很好的文档，因此在继续之前，我建议你先阅读Angr文档中的核心概念部分。还可以尝试完成* [https://docs.angr.io/core-concepts/toplevel/](https://docs.angr.io/core-concepts/toplevel/)
    *中的Python交互式Shell练习。
- en: '***The Angr Program***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Angr程序***'
- en: 'Now let’s write the Python program that will use Angr to automatically discover
    the passcode in the program we wrote. Create a new file on your Desktop called
    *angrSim.py* and save the following code snippet to it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个Python程序，使用Angr自动发现我们编写的程序中的密码。在桌面上创建一个名为*angrSim.py*的新文件，并将以下代码片段保存到该文件中：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We import the binary from the *simple.c* program as an Angr project ➊. Before
    we continue, keep in mind that the symbolic variables you’ll inspect will be bit
    vectors representing the contents of the symbolic registers. This is because you’re
    symbolic executing a binary rather than source code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将来自*simple.c*程序的二进制文件导入作为Angr项目 ➊。在继续之前，请记住，你将检查的符号变量将是表示符号寄存器内容的位向量。这是因为你正在符号执行二进制文件，而不是源代码。
- en: Next, we obtain the initial entry state of the program ➋. We then pass this
    state to a simulation manager (`simgr`) that will manage the process of simulating
    program execution. If you wanted to manually simulate the program, you could run
    `simulation.step()`, which would allow you to inspect the state and path constraints
    at each execution step. The Angr documentation walks through this process with
    a simple example.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取程序的初始入口状态 ➋。然后，我们将此状态传递给一个模拟管理器（`simgr`），该管理器将负责管理程序执行的模拟过程。如果你想手动模拟程序，你可以运行`simulation.step()`，这将允许你在每一步执行中检查状态和路径约束。Angr文档通过一个简单的示例演示了这个过程。
- en: Now, we define a function that identifies the success state ➌. If the state
    would output the string `Access Granted`, the function returns true. Next, we
    define the function that identifies a failure state ➍. If a state would output
    the string `Access Denied`, the function returns true.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个函数，用于识别成功状态 ➌。如果状态会输出字符串`Access Granted`，则该函数返回true。接下来，我们定义一个函数，用于识别失败状态
    ➍。如果状态会输出字符串`Access Denied`，则该函数返回true。
- en: Now we can start the concolic execution process. Then, we pass the function
    pointers to the success and failure functions ”. If the simulation reaches the
    failure state, it quickly terminates and restarts the search. However, if the
    simulation discovers the success state, it terminates and saves the state. Finally,
    we print the input that caused us to enter the success state, and voila, we have
    the password ➏.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始符号执行过程。然后，我们将函数指针传递给成功和失败函数。如果模拟达到失败状态，它会迅速终止并重新开始搜索。然而，如果模拟发现了成功状态，它会终止并保存状态。最后，我们打印出导致我们进入成功状态的输入，瞧，我们找到了密码
    ➏。
- en: 'Using the terminal, run the *angrSim.py* program:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端运行*angrSim.py*程序：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will take some time to run. When it’s complete, you should see the following
    output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程需要一些时间来运行。完成后，你应该能看到以下输出：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Congratulations, you’ve used the Angr concolic engine to discover the input
    that gets you to your success state.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经使用Angr符号执行引擎找到了让你进入成功状态的输入。
- en: '**Exercises**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: These exercises are designed to round out your understanding of concolic execution
    and fuzzing. The exercises are listed in order of difficulty, and I recommend
    attempting the more difficult exercises to help you truly master these topics.
    Happy hunting.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习旨在完善你对符号执行和模糊测试的理解。练习按难度顺序列出，我建议尝试更困难的练习，帮助你真正掌握这些主题。祝你好运。
- en: '***Capture the Flag Games with Angr***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Angr进行夺旗游戏***'
- en: In this chapter, we looked at only a small fraction of what Angr is capable
    of. You can expand your understanding of this tool by completing the Angr *Capture
    the Flag* challenges created by Jake Springer. The repository of challenges at
    *[https://github.com/jakespringer/angr_ctf](https://github.com/jakespringer/angr_ctf)*
    also contains solutions, so feel free to check your work after attempting a challenge.
    Complete all 17 challenges to really master Angr.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅查看了 Angr 能力的一小部分。你可以通过完成 Jake Springer 创建的 Angr *Capture the Flag* 挑战来拓展对这个工具的理解。挑战的仓库位于
    *[https://github.com/jakespringer/angr_ctf](https://github.com/jakespringer/angr_ctf)*，其中也包含了解决方案，因此在尝试挑战后，可以查看自己的答案。完成所有
    17 个挑战，真正掌握 Angr。
- en: '***Fuzzing Web Protocols***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模糊测试 Web 协议***'
- en: 'We’ve explored how to fuzz binaries. Now let’s look at an easy way to fuzz
    network protocols using the `spike` tool that comes preinstalled on your Kali
    Linux virtual machine. Here is the command’s general syntax:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何模糊测试二进制文件。现在，让我们看看如何使用 Kali Linux 虚拟机上预装的 `spike` 工具来模糊测试网络协议。以下是该命令的一般语法：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Begin by specifying the host machines you want to fuzz (for example, the Metasploitable
    server). Next, specify the port used by the protocol you’d like to fuzz. For instance,
    you could try fuzzing the SMTP server running on port 25.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先指定你想要模糊测试的主机（例如，Metasploitable 服务器）。接着，指定你希望模糊测试的协议所使用的端口。例如，你可以尝试模糊测试运行在
    25 端口的 SMTP 服务器。
- en: The spike fuzzer doesn’t know structure of the SMTP protocol, so you’ll need
    to supply a spike script that defines the message it needs to send. This script
    will consist of a collection of strings to send and the variables to mutate. You
    can write your own fuzzing scripts or use the scripts included in the directory
    */usr/share/spike/audits/*. We’ll look at an example script more closely later
    in this exercise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: spike 模糊器并不了解 SMTP 协议的结构，因此你需要提供一个 spike 脚本，定义它需要发送的消息。这个脚本将由要发送的字符串集合和要变异的变量组成。你可以编写自己的模糊测试脚本，也可以使用目录
    */usr/share/spike/audits/* 中包含的脚本。我们将在本练习后面更仔细地查看一个示例脚本。
- en: The `*[variable index]*` specifies the starting location in the script. For
    example, a variable index value of 0 would start fuzzing with the first variable
    in the script, whereas a value of 3 would leave the first three values unmutated
    and begin by mutating the fourth variable in script.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`*[variable index]*` 指定脚本中的起始位置。例如，变量索引值为 0 将从脚本中的第一个变量开始模糊，而值为 3 将跳过前面三个值，从第四个变量开始变异。'
- en: The spike fuzzer has a predefined array of string mutations, and the `*[string
    index]*` value specifies which of these to use first. For example, a value of
    0 would start with the first string mutation, whereas a value of 4 would start
    with the fifth mutation. The `*[variable index]*` and `*[string index*`*]* values
    are useful because they allow you to resume fuzzing at a specific point in the
    process if it terminates for any reason.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: spike 模糊器有一个预定义的字符串变异数组，`*[string index]*` 值指定首先使用其中的哪一个。例如，值为 0 会从第一个字符串变异开始，而值为
    4 则从第五个变异开始。`*[variable index]*` 和 `*[string index]*` 值非常有用，因为它们允许你在任何原因导致模糊测试终止时，从特定点恢复模糊测试。
- en: 'The complete command might look like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令可能如下所示：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To better understand the output, let’s look at the *smtp1.spk* script. This
    `spike` script describes the SMTP protocol and consists of a collection of commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解输出，让我们来看一下 *smtp1.spk* 脚本。这个 `spike` 脚本描述了 SMTP 协议，并由一组命令组成：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `s_string()` command tells the fuzzer to send a string corresponding to
    part of an SMTP message. The fuzzer sends the `MAIL-FROM` command associated with
    the SMTP protocol ➊. The `s_string_variable()` command defines the string to mutate,
    which is `"bob"` in this case, and sends it ➋. For example, the fuzzer might send
    `"boo`. The next time it mutates `bob` it might send `bAAAAAA`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`s_string()` 命令告诉模糊器发送与 SMTP 消息部分对应的字符串。模糊器发送与 SMTP 协议相关的 `MAIL-FROM` 命令 ➊。`s_string_variable()`
    命令定义要变异的字符串，在本例中为 `"bob"`，并将其发送 ➋。例如，模糊器可能会发送 `"boo`。下一次变异 `bob` 时，它可能会发送 `bAAAAAA`。'
- en: The `spike` script also supports other commands, such as `s_readline`, which
    displays a string representation of the response, and `printf()`, which writes
    to the local terminal (and is great for debugging). The `spike_send()` command
    flushes the buffer and sends all of its contents.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`spike` 脚本还支持其他命令，例如 `s_readline`，它显示响应的字符串表示，以及 `printf()`，它将内容写入本地终端（对于调试非常有用）。`spike_send()`
    命令刷新缓冲区并发送其所有内容。'
- en: Try writing your own `spike` script for a different network protocol. If you
    find it useful, add it to the official `spike` Git repository at *[https://github.com/guilhermeferreira/spikepp.git](https://github.com/guilhermeferreira/spikepp.git)*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 试着为另一种网络协议编写自己的 `spike` 脚本。如果你觉得有用，可以将它添加到官方的 `spike` Git 仓库中，地址为 *[https://github.com/guilhermeferreira/spikepp.git](https://github.com/guilhermeferreira/spikepp.git)*。
- en: '***Fuzzing an Open Source Project***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模糊测试开源项目***'
- en: Now let’s get some practice fuzzing a real program. In this exercise, try running
    the AFL-fuzzer you used in this chapter on your favorite open source project.
    Note that fuzzing open source programs is legal because it helps the developer
    community discover bugs that could potentially be exploited by attackers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来练习模糊测试一个真实的程序。在这个练习中，试着在你最喜欢的开源项目上运行你在这一章使用过的 AFL-fuzzer。需要注意的是，对开源程序进行模糊测试是合法的，因为它有助于开发者社区发现可能被攻击者利用的漏洞。
- en: As you fuzz the program, remember to practice responsible disclosure. If you
    find a bug, send a secure email to the project’s creators. It’s also helpful if
    you explain how the bug could be exploited and include some sample exploitation
    code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行模糊测试时，请记得遵循负责任的披露原则。如果你发现了一个漏洞，请通过安全邮件发送给项目的创建者。如果可能的话，解释一下这个漏洞如何被利用，并附上一些示例利用代码会很有帮助。
- en: How can you quickly determine whether a bug is exploitable? The `gdb` exploitable
    plug-in allows you to determine if a bug that caused a crash might be malicious.
    You can download the plug-in from *[https://github.com/jfoote/exploitable](https://github.com/jfoote/exploitable)*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速判断一个漏洞是否可以被利用？`gdb` 的 exploitable 插件可以帮助你判断导致崩溃的漏洞是否可能是恶意的。你可以从 *[https://github.com/jfoote/exploitable](https://github.com/jfoote/exploitable)*
    下载这个插件。
- en: Fuzzing is a computationally intensive process, and we don’t recommend that
    you do this in your virtual machine. Instead, run the fuzzer on a remote server
    or on your local machine.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试是一个计算密集型的过程，我们不建议在虚拟机中进行此操作。建议将模糊测试工具运行在远程服务器或本地计算机上。
- en: '***Implement Your Own Concolic Execution Engine***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现你自己的符号执行引擎***'
- en: 'The physicist Richard Feynman once said, “What I cannot create, I do not understand.”
    The best way to develop a deep understanding of something is to implement it yourself.
    Try implementing your own concolic execution engine in Python. This exercise,
    given to MIT computer security students, has been made available to the general
    public here: *[https://css.csail.mit.edu/6.858/2018/labs/lab3.html](https://css.csail.mit.edu/6.858/2018/labs/lab3.html)*.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学家理查德·费曼曾说过：“我无法创造的东西，我就不理解。”深入理解某样东西的最佳方式就是亲自实现它。试着用 Python 实现一个自己的符号执行引擎。这个练习曾经是麻省理工学院计算机安全课程的作业，现在公开给大家：
    *[https://css.csail.mit.edu/6.858/2018/labs/lab3.html](https://css.csail.mit.edu/6.858/2018/labs/lab3.html)*。
- en: Give it a try. You might be surprised by how much you learned in this chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看吧，你可能会惊讶于你在这一章学到的内容。
