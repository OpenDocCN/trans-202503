- en: Chapter 8. String Processing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章：字符串处理
- en: 'A string is a series of characters that is treated as a single unit. You can
    write programs to combine, compare, sort, encrypt, and otherwise manipulate strings.
    Here’s what you’ll learn in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一系列字符，作为一个整体单元来处理。你可以编写程序来组合、比较、排序、加密和以其他方式操作字符串。以下是你将在本章中学到的内容：
- en: How Scratch stores strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scratch 如何存储字符串
- en: How to use the string manipulation blocks available in Scratch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Scratch 中可用的字符串操作积木
- en: Several string processing techniques
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种字符串处理技巧
- en: How to write interesting programs that process strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写有趣的程序来处理字符串
- en: We’ll start with a detailed look at the string data type, and then we’ll write
    procedures to manage and manipulate strings. Those procedures will remove and
    replace characters, insert and extract substrings, and randomize character order.
    After that, we’ll use these procedures and apply these techniques to write some
    fun and practical applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从详细了解字符串数据类型开始，然后编写程序来管理和操作字符串。这些程序将移除和替换字符、插入和提取子字符串，以及随机化字符顺序。之后，我们将使用这些程序并应用这些技巧来编写一些有趣且实用的应用程序。
- en: Revisiting the String Data Type
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重温字符串数据类型
- en: 'As I mentioned in [Chapter 5](ch05.html "Chapter 5. Variables"), Scratch has
    three data types: *Boolean*, *number*, and *string*. At its simplest, a string
    is just an ordered sequence of characters. These characters can include letters
    (both upper- and lowercase), digits, and other symbols that you can type on your
    keyboard (+, -, &, @, and so on). You can use strings in your programs to store
    names, addresses, phone numbers, book titles, and more.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [第 5 章](ch05.html "Chapter 5. Variables")中提到的，Scratch 有三种数据类型：*布尔值*、*数字*和*字符串*。从最简单的角度来看，字符串只是一个有序的字符序列。这些字符可以包括字母（大写和小写）、数字以及其他你可以在键盘上输入的符号（如
    +、-、&、@ 等）。你可以在程序中使用字符串来存储名字、地址、电话号码、书名等信息。
- en: In Scratch, the characters of a string are stored sequentially. For example,
    if you have a variable called `name`, executing the command **set name to Karen**
    would store the characters as illustrated in [Figure 8-1](ch08.html#string_is_stored_as_a_sequence_of_charac
    "Figure 8-1. A string is stored as a sequence of characters.").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scratch 中，字符串的字符是按顺序存储的。例如，如果你有一个名为`name`的变量，执行命令**将 name 设置为 Karen**会按图 [Figure 8-1](ch08.html#string_is_stored_as_a_sequence_of_charac
    "Figure 8-1. A string is stored as a sequence of characters.") 所示的方式存储这些字符。
- en: '![A string is stored as a sequence of characters.](httpatomoreillycomsourcenostarchimages2134877.png.jpg)Figure 8-1. A
    string is stored as a sequence of characters.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![字符串作为字符序列存储](httpatomoreillycomsourcenostarchimages2134877.png.jpg)Figure 8-1.
    字符串作为字符序列存储。'
- en: You can access individual characters of a string with the **letter of** operator.
    For example, the block **letter 1 of name** returns the letter `K`, and **letter
    5 of name** returns the letter `n`. Scratch also provides the **length of** operator,
    which returns the number of characters in a string. If you use these two operators
    with **repeat** blocks, you can count characters, examine multiple characters,
    and do many other useful things, as I’ll demonstrate in the following subsections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**letter of**操作符访问字符串中的单个字符。例如，**letter 1 of name**块返回字母`K`，而**letter 5
    of name**块返回字母`n`。Scratch 还提供了**length of**操作符，它返回字符串中的字符数。如果你将这两个操作符与**repeat**积木一起使用，你可以计数字符、检查多个字符并做许多其他有用的事情，正如我将在接下来的小节中演示的那样。
- en: Counting Special Characters in a String
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计字符串中的特殊字符
- en: Our first example script, shown in [Figure 8-2](ch08.html#vowel-counting_program
    "Figure 8-2. Vowel-counting program"), counts how many vowels are in an input
    string. It asks the user to enter a string, and then it counts and displays the
    number of vowels in that string.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例脚本，如图 [Figure 8-2](ch08.html#vowel-counting_program "Figure 8-2. Vowel-counting
    program") 所示，用于统计输入字符串中有多少个元音。它要求用户输入一个字符串，然后统计并显示该字符串中的元音数量。
- en: '*VowelCount.sb2*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*VowelCount.sb2*'
- en: '![Vowel-counting program](httpatomoreillycomsourcenostarchimages2134879.png.jpg)Figure 8-2. Vowel-counting
    program'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![元音计数程序](httpatomoreillycomsourcenostarchimages2134879.png.jpg)Figure 8-2.
    元音计数程序'
- en: The program checks each letter in the input string one by one and looks for
    vowels. Every time it finds a vowel, it increments a variable named `vowelCount`
    by 1\. The script uses a variable named `pos` (short for *position*) to track
    the position of the character being checked. Let’s explore this script in more
    detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序逐个检查输入字符串中的每个字母，并查找元音字母。每次找到一个元音字母时，它都会将名为`vowelCount`的变量加1。脚本使用名为`pos`（*position*的缩写）的变量来跟踪正在检查的字符的位置。让我们更详细地探讨这个脚本。
- en: First, the script asks the user to enter a sentence ①. Scratch should save the
    user’s string automatically in the built-in `answer` variable. Then it sets `vowelCount`
    to 0 (since it hasn’t seen any vowels yet) and sets `pos` to 1 to access the first
    letter of the input string.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本要求用户输入一个句子①。Scratch会自动将用户的字符串保存在内置的`answer`变量中。然后，它将`vowelCount`设置为0（因为尚未看到任何元音字母），并将`pos`设置为1以访问输入字符串的第一个字母。
- en: Next, a **repeat** loop ② checks every letter in the input string. The **length
    of** operator reports the number of characters in the input string, which is how
    many times the loop should repeat.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**repeat**循环②检查输入字符串中的每个字母。**length of**运算符报告输入字符串中的字符数，这决定了循环应重复多少次。
- en: On each pass, the loop uses `ch` (short for character) to check one character
    of the input string ③. In the first iteration of the loop, `ch` is set to the
    first letter of **answer**. The second iteration sets `ch` to the second letter,
    and so on, until the loop reaches the end of the string. The `pos` variable is
    used to access the desired character.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，循环使用`ch`（字符的缩写）检查输入字符串的一个字符③。在循环的第一次迭代中，`ch`被设置为**answer**的第一个字母。第二次迭代将`ch`设置为第二个字母，依此类推，直到循环到达字符串的末尾。`pos`变量用于访问所需的字符。
- en: The **if** block then checks whether the examined character is a vowel ④. If
    the character is a vowel, whether capital or lowercase, `vowelCount` is increased
    by 1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**if**模块接着检查所检查的字符是否为元音字母④。如果字符是元音字母，无论是大写还是小写，`vowelCount`都会加1。'
- en: After checking one character, the loop increments `pos` by 1 ⑤ and starts over
    to read the next character. When all the letters in the input string have been
    checked, the loop terminates, and the program displays the number of vowels it
    counted using the **say** block.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完一个字符后，循环将`pos`加1⑤并重新开始读取下一个字符。当输入字符串中的所有字母都被检查完后，循环结束，程序会使用**say**模块显示它计数的元音字母数量。
- en: The techniques used in this example will be applied many times in the rest of
    this chapter. Load the script *VowelCount.sb2*, run it several times, and make
    sure you understand it thoroughly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的技术将在本章的其余部分多次应用。加载脚本*VowelCount.sb2*，运行几次，并确保你完全理解它。
- en: Comparing String Characters
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较字符串字符
- en: Our second example checks whether an integer entered by the user is a palindrome.
    A *palindrome* is a number (or text string) that reads the same backward and forward.
    For example, 1234321 and 1122332211 are palindromes. Likewise, Racecar, Hannah,
    and Bob are a few text palindromes. To illustrate our palindrome-testing algorithm,
    let’s say that the input number is 12344321, as illustrated in [Figure 8-3](ch08.html#using_two_variables_to_check_whether_or
    "Figure 8-3. Using two variables to check whether or not a number is a palindrome").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个例子检查用户输入的整数是否为回文数。*回文数*是一个数字（或文本字符串），无论是从前往后还是从后往前读都相同。例如，1234321和1122332211是回文数。同样，Racecar、Hannah和Bob也是一些文本回文数。为了说明我们的回文检测算法，假设输入的数字是12344321，如[图8-3](ch08.html#using_two_variables_to_check_whether_or
    "图8-3. 使用两个变量检查数字是否为回文数")所示。
- en: '*Palindrome.sb2*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*Palindrome.sb2*'
- en: '![Using two variables to check whether or not a number is a palindrome](httpatomoreillycomsourcenostarchimages2134881.png)Figure 8-3. Using
    two variables to check whether or not a number is a palindrome'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用两个变量检查数字是否为回文数](httpatomoreillycomsourcenostarchimages2134881.png)图8-3.
    使用两个变量检查数字是否为回文数'
- en: To check whether the number is a palindrome, we need to compare the first and
    eighth digits, the second and seventh digits, the third and sixth digits, and
    so on. If any comparison produces a false result (meaning that the two digits
    are not equal), then the number is not a palindrome. A program that implements
    this palindrome test algorithm is shown in [Figure 8-4](ch08.html#this_program_tests_whether_an_integer_in
    "Figure 8-4. This program tests whether an integer input by the user is a palindrome.").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个数字是否是回文数，我们需要比较第一个和第八个数字，第二个和第七个数字，第三个和第六个数字，依此类推。如果任何一次比较结果为假（即两个数字不相等），那么该数字就不是回文数。实现此回文数测试算法的程序如[图8-4](ch08.html#this_program_tests_whether_an_integer_in
    "图8-4. 该程序测试用户输入的整数是否为回文数。")所示。
- en: '![This program tests whether an integer input by the user is a palindrome.](httpatomoreillycomsourcenostarchimages2134883.png.jpg)Figure 8-4. This
    program tests whether an integer input by the user is a palindrome.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![该程序测试用户输入的整数是否为回文数。](httpatomoreillycomsourcenostarchimages2134883.png.jpg)图8-4.
    该程序测试用户输入的整数是否为回文数。'
- en: The script accesses the digits to be compared with two variables (`pos1` and
    `pos2` in [Figure 8-3](ch08.html#using_two_variables_to_check_whether_or "Figure 8-3. Using
    two variables to check whether or not a number is a palindrome")) that move in
    opposite directions. The first variable (`pos1`) starts at the first digit and
    moves forward, while the second variable (`pos2`) starts at the last digit and
    moves backward. The number of required comparisons is at most one-half the digits
    in the input number. With an input of 12344321, we need at most four comparisons
    because the input number has eight digits. (The same logic applies if the input
    integer has an odd number of digits, since the digit in the middle of the number
    need not be compared.) Once the program determines whether or not the user’s number
    is a palindrome, it displays a message with the result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用两个变量（[图8-3](ch08.html#using_two_variables_to_check_whether_or "图8-3. 使用两个变量检查数字是否为回文数")中的`pos1`和`pos2`）来访问需要比较的数字，这两个变量分别朝相反的方向移动。第一个变量（`pos1`）从第一个数字开始并向前移动，而第二个变量（`pos2`）从最后一个数字开始并向后移动。所需的比较次数最多为输入数字的数字个数的一半。对于输入的数字12344321，我们最多需要进行四次比较，因为该数字有八个数字。（如果输入的整数有奇数个数字，逻辑也是相同的，因为中间的数字不需要进行比较。）一旦程序确定用户的数字是否为回文数，它会显示一个包含结果的消息。
- en: Try It Out 8-1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试 8-1
- en: Load *Palindrome.sb2* and run it to understand how it works. Because of the
    way Scratch handles decimal repeat counts, if the input number has an odd number
    of digits, the script performs one extra comparison of the two digits that surround
    the middle digit. Try to fix the program to perform the correct number of repeats
    when the input number has an odd number of digits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*Palindrome.sb2*并运行它，以了解其工作原理。由于 Scratch 处理小数重复次数的方式，如果输入数字的位数是奇数，脚本会多进行一次比较，比较围绕中间数字的两个数字。尝试修复程序，在输入数字为奇数位时执行正确的重复次数。
- en: '*Palindrome.sb2*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Palindrome.sb2*'
- en: In the next section, we’ll explore some of the most common operations on strings
    and see some strategies for writing string manipulation procedures in Scratch.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索一些最常见的字符串操作，并了解在 Scratch 中编写字符串操作过程的一些策略。
- en: String Manipulation Examples
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作示例
- en: The **letter of** operator only lets you read the individual characters of a
    string. If you want to insert characters into (or remove characters from) a string,
    you have to do all the work yourself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**letter of** 操作符只能读取字符串的单个字符。如果你想在字符串中插入字符（或删除字符），你必须自己完成所有的工作。'
- en: In Scratch, you can’t alter the characters in a string, so the only way to change
    a string is to create a new one. For example, if you want to capitalize the first
    letter in the string “jack”, you need to create a new string that contains the
    letter *J* followed by the rest of the letters, *ack*. The idea is to use the
    **letter of** operator to read the letters of the original string and append theses
    letters to the new string, as needed, using the **join** operator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scratch 中，你不能更改字符串中的字符，因此改变字符串的唯一方法是创建一个新字符串。例如，如果你想把字符串“jack”的第一个字母大写，你需要创建一个新的字符串，其中包含字母*J*，然后是剩下的字母*ack*。这个思路是使用**letter
    of** 操作符来读取原始字符串中的字母，并根据需要使用**join**操作符将这些字母附加到新字符串中。
- en: In this section, we’ll develop some simple applications that demonstrate common
    string manipulation techniques.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一些简单的应用程序，展示常见的字符串操作技巧。
- en: Igpay Atinlay
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Igpay Atinlay
- en: What if our sprites could speak a secret language? In this section, we’ll teach
    them a coded language called *pig latin*. Our rules for creating pig latin words
    will be simple. To convert a word into pig latin, move the first letter to the
    end and add the letters *ay*. So, the word *talk* becomes *alktay*, *fun* becomes
    *unfay*, and so on. Now that you know the rules, can you tell what the title of
    this section originally said?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的精灵能够说一种秘密语言呢？在这一节中，我们将教它们一种名为*猪拉丁语*的编码语言。我们创建猪拉丁语单词的规则很简单。要将一个单词转换为猪拉丁语，将第一个字母移到单词的末尾并加上*ay*。因此，单词*talk*变成*alktay*，*fun*变成*unfay*，依此类推。现在你知道规则了，你能猜出这一节的标题最初是什么吗？
- en: '*PigLatin.sb2*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*PigLatin.sb2*'
- en: The strategy we’ll use to convert a word into pig latin is illustrated in [Figure 8-5](ch08.html#how_to_translate_an_english_word_into_pi
    "Figure 8-5. How to translate an English word into pig latin"), using the word
    *scratch*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来将单词转换为猪拉丁语的策略在[图8-5](ch08.html#how_to_translate_an_english_word_into_pi
    "图8-5. 如何将英文单词转换为猪拉丁语")中进行了说明，使用的单词是*scratch*。
- en: '![How to translate an English word into pig latin](httpatomoreillycomsourcenostarchimages2134885.png.jpg)Figure 8-5. How
    to translate an English word into pig latin'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![如何将英文单词转换为猪拉丁语](httpatomoreillycomsourcenostarchimages2134885.png.jpg)图8-5.
    如何将英文单词转换为猪拉丁语'
- en: We’ll first append all the letters (except the first), one by one, from the
    input word to the output word ①. We then add the first letter in the input word
    to the output ②, followed by *ay* ③. Our **PigLatin** procedure that implements
    these steps is shown in [Figure 8-6](ch08.html#piglatin_procedure "Figure 8-6. The
    PigLatin procedure").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先会一个一个地将输入单词中的所有字母（除了第一个字母）附加到输出单词中 ①。然后，我们将输入单词的第一个字母添加到输出中 ②，接着是*ay* ③。我们的**PigLatin**过程实现了这些步骤，如[图8-6](ch08.html#piglatin_procedure
    "图8-6. PigLatin过程")所示。
- en: The procedure uses three variables to create our coded words. The variable `outWord`
    holds the output string as it’s assembled. A counter called `pos` (for position)
    tells the script which character from the original string to append to `outWord`.
    Finally, a variable named `ch` holds one character from the input string. The
    procedure takes the word you want to translate into pig latin as a parameter,
    named `word`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程使用三个变量来创建我们的编码单词。变量`outWord`保存组装中的输出字符串。一个名为`pos`（表示位置）的计数器告诉脚本从原始字符串中哪个字符应该附加到`outWord`。最后，一个名为`ch`的变量保存输入字符串中的一个字符。该过程将你想要翻译成猪拉丁语的单词作为参数，命名为`word`。
- en: '![The PigLatin procedure](httpatomoreillycomsourcenostarchimages2134887.png.jpg)Figure 8-6. The
    PigLatin procedure'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![PigLatin过程](httpatomoreillycomsourcenostarchimages2134887.png.jpg)图8-6. PigLatin过程'
- en: First, the procedure creates an empty string for `outWord` and sets `pos` to
    2 ①. (An *empty string* is string that does not contain any characters; its length
    is 0.) The procedure then uses a **repeat** block to append all letters but the
    first from the input string (`word`) to the output string (`outWord`) ②. We skipped
    the first character, so the repeat count is one less than the length of the input
    string. For each loop iteration, one character of `word` is appended to `outWord`.
    At the end of the loop, the first letter of `word` is appended to `outWord` ③,
    along with the letters `ay` ④.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序创建一个空字符串作为`outWord`，并将`pos`设置为2 ①。（*空字符串*是一个不包含任何字符的字符串；它的长度为0。）然后，程序使用**repeat**块将输入字符串（`word`）中除了第一个字母之外的所有字母附加到输出字符串（`outWord`）中
    ②。由于我们跳过了第一个字符，因此重复次数比输入字符串的长度少一个。在每次循环迭代中，`word`的一个字符被附加到`outWord`。循环结束时，`word`的第一个字母被附加到`outWord`
    ③，后面跟着字母`ay` ④。
- en: Try It Out 8-2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试 8-2
- en: 'Load *PigLatin.sb2* and run it to test this procedure. The application asks
    for an input word and then says its pig latin translation. Modify it to translate
    a phrase, like “Would you like some juice?” into pig latin. (Hint: Call **PigLatin**
    for each word to assemble the output phrase.) As another challenge, write a procedure
    that takes a pig latin word as input and shows its original English word.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*PigLatin.sb2*并运行它来测试这个过程。应用程序会要求输入一个单词，然后输出它的猪拉丁语翻译。修改它以翻译一个短语，比如“Would you
    like some juice?”（提示：对于每个单词调用**PigLatin**，以拼凑输出短语。）作为另一个挑战，编写一个过程，输入一个猪拉丁语单词并显示其原始英文单词。
- en: '*PigLatin.sb2*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*PigLatin.sb2*'
- en: Fix My Spelling
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修正我的拼写
- en: In this section, we’ll develop a simple game that generates misspelled words
    and asks the player to enter the correct spelling. The game will create misspelled
    words by inserting a random letter at a random position in an English word. Of
    course, there could be more than one correct spelling of misspelled simple words.
    For example, if the original word is *wall* and the game produces *mwall*, either
    *mall* or *wall* would be correct. To keep our game simple, we’ll ignore that
    possibility and insist on a particular spelling for the correct answer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的游戏，该游戏生成拼写错误的单词，并要求玩家输入正确的拼写。该游戏通过在英文单词的随机位置插入一个随机字母来生成拼写错误的单词。当然，拼写错误的简单单词可能有多个正确拼写。例如，如果原始单词是*wall*，而游戏生成了*mwall*，那么*mall*或*wall*都是正确的。为了保持游戏的简单性，我们将忽略这种可能性，并坚持特定的拼写作为正确答案。
- en: '*FixMySpelling.sb2*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*FixMySpelling.sb2*'
- en: 'First, let’s make a general procedure to insert characters at a specific position
    in a string. This procedure, called **Insert**, takes three parameters: the input
    word (`strIn`), the string (or character) to insert (`strAdd`), and the position
    where you want those new characters (`charPos`). The procedure generates a new
    string (`strOut`) with `strAdd` inserted into `strIn` at the correct position,
    as illustrated in the example of [Figure 8-7](ch08.html#illustrating_the_insert_procedure
    "Figure 8-7. Illustrating the Insert procedure").'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个通用的过程，在字符串的特定位置插入字符。这个过程叫做**Insert**，它有三个参数：输入的单词（`strIn`）、要插入的字符串（或字符）（`strAdd`）以及你想要插入这些新字符的位置（`charPos`）。该过程生成一个新字符串（`strOut`），其中`strAdd`被插入到`strIn`的正确位置，就像[图8-7](ch08.html#illustrating_the_insert_procedure
    "图8-7. 插入过程示意图")中的例子所示。
- en: '![Illustrating the Insert procedure](httpatomoreillycomsourcenostarchimages2134889.png)Figure 8-7. Illustrating
    the Insert procedure'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![插入过程示意图](httpatomoreillycomsourcenostarchimages2134889.png)图8-7. 插入过程示意图'
- en: We’ll add the characters from `strIn`, one by one, into `strOut`. When we reach
    `charPos`, we’ll just add the character(s) from `strAdd` to `strOut` before appending
    the letter at `charPos` from `strIn`. The complete procedure is shown in [Figure 8-8](ch08.html#insert_procedure
    "Figure 8-8. The Insert procedure").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个一个地将`strIn`中的字符添加到`strOut`中。当我们到达`charPos`时，我们将在`strOut`中添加`strAdd`中的字符，然后再附加`strIn`中`charPos`位置的字母。完整的过程如[图8-8](ch08.html#insert_procedure
    "图8-8. 插入过程")所示。
- en: '![The Insert procedure](httpatomoreillycomsourcenostarchimages2134891.png.jpg)Figure 8-8. The
    Insert procedure'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![插入过程](httpatomoreillycomsourcenostarchimages2134891.png.jpg)图8-8. 插入过程'
- en: First, the procedure initializes `strOut` to an empty string and sets `pos`
    to 1 to access the first letter of the input string ①. It then starts a **repeat**
    loop to append the letters of `strIn`, one by one, to `strOut` ②. Each iteration
    grabs the next letter of `strIn` and places it in the `ch` variable ③. If the
    position of the current character matches `charPos`, the procedure appends `strAdd`
    to `strOut` ④. In all cases, `ch` is appended to `strOut` ⑤, and `pos` is incremented
    to access the next letter of `strIn` ⑥.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，过程将`strOut`初始化为空字符串，并将`pos`设置为1，以访问输入字符串的第一个字母①。然后，它开始一个**repeat**循环，将`strIn`的字母一个一个地附加到`strOut`中②。每次迭代都会获取`strIn`的下一个字母，并将其放入`ch`变量中③。如果当前字符的位置与`charPos`匹配，过程会将`strAdd`附加到`strOut`中④。在所有情况下，`ch`都会被附加到`strOut`中⑤，`pos`会增加以访问`strIn`的下一个字母⑥。
- en: Now that we have our **Insert** procedure, let’s look at the main script of
    the game, shown in [Figure 8-9](ch08.html#main_script_for_the_fix_my_spelling_game
    "Figure 8-9. The main script for the Fix My Spelling game").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了**Insert**过程，让我们看一下游戏的主脚本，如[图8-9](ch08.html#main_script_for_the_fix_my_spelling_game
    "图8-9. Fix My Spelling游戏的主脚本")所示。
- en: '![The main script for the Fix My Spelling game](httpatomoreillycomsourcenostarchimages2134893.png.jpg)Figure 8-9. The
    main script for the Fix My Spelling game'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![Fix My Spelling游戏的主脚本](httpatomoreillycomsourcenostarchimages2134893.png.jpg)图8-9.
    Fix My Spelling游戏的主脚本'
- en: The `alpha` string contains all the letters of the alphabet. It will provide
    the random letter to insert into the word we want to misspell ①. The script randomly
    picks a word from a premade list and saves that word as `inWord` ②. You’ll learn
    more about lists in the next chapter; for now, just think of this list as a word
    bank. The script then selects a random letter (`randChar`) from `alpha` ③ and
    a random position (`randPos`) to place this letter into `inWord` ④. The script
    then calls our **Insert** procedure to create the misspelled word (`strOut`) ⑤.
    After that, the script starts a loop to get the player’s answer ⑥. Inside the
    loop, the script asks the player to enter the correct spelling ⑦, and it uses
    an **if/else** block to check the answer ⑧. If the player’s answer matches the
    original word (`inWord`), the game ends; otherwise, the player has to try again.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpha`字符串包含所有字母的字母表。它将提供随机字母来插入到我们要拼写错误的单词中①。脚本从预制的单词列表中随机挑选一个单词，并将该单词保存为`inWord`②。你将在下一章学习更多关于列表的内容；目前，只需将此列表看作一个单词库。接下来，脚本从`alpha`中随机选择一个字母（`randChar`）③，并选择一个随机位置（`randPos`）将这个字母插入到`inWord`中④。然后，脚本调用我们的**Insert**过程来创建拼错的单词（`strOut`）⑤。之后，脚本启动一个循环来获取玩家的答案⑥。在循环中，脚本会要求玩家输入正确的拼写⑦，并使用**if/else**块来检查答案⑧。如果玩家的答案与原始单词（`inWord`）匹配，则游戏结束；否则，玩家需要重新尝试。'
- en: Try It Out 8-3
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试它 8-3
- en: Load *FixMySpelling.sb2* and play it several times to understand how it works.
    Can you modify the game such that the corrupt word contains two additional letters
    instead of just one?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*FixMySpelling.sb2*并多次播放，以理解它是如何工作的。你能修改游戏，使得混淆的词包含两个额外字母，而不仅仅是一个吗？
- en: '*FixMySpelling.sb2*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*FixMySpelling.sb2*'
- en: Unscramble
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解开混乱
- en: Our last example presents another word game that is a little more challenging
    to play. We’ll start with an English word, scramble its letters, and ask the player
    to guess the original word.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个示例展示了另一个稍微更具挑战性的单词游戏。我们将从一个英文单词开始，打乱其字母，并要求玩家猜出原始单词。
- en: '*Unscramble.sb2*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unscramble.sb2*'
- en: Let’s start by creating a procedure that rearranges the characters of a given
    string in random order. The caller sets the input string (`strIn`), and the procedure,
    named **Randomize**, modifies it so that its characters are shuffled around, as
    illustrated in [Figure 8-10](ch08.html#illustrating_the_randomize_procedure "Figure 8-10. Illustrating
    the Randomize procedure").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个过程，将给定字符串的字符按随机顺序重新排列。调用者设置输入字符串（`strIn`），而名为**Randomize**的过程则修改该字符串，将其字符打乱，如[图8-10](ch08.html#illustrating_the_randomize_procedure
    "图8-10. 展示Randomize过程")中所示。
- en: '![Illustrating the Randomize procedure](httpatomoreillycomsourcenostarchimages2134895.png.jpg)Figure 8-10. Illustrating
    the Randomize procedure'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Illustrating the Randomize procedure](httpatomoreillycomsourcenostarchimages2134895.png.jpg)图8-10.
    展示Randomize过程'
- en: We’ll pick a random letter from `strIn` and append that letter to a *temporary
    string*, `str1`. (This temporary string, which starts off empty, is where we’ll
    store the scrambled word as we build it.) We’ll then remove that letter from `strIn`
    so we don’t reuse it and repeat the whole process until `strIn` is empty. The
    **Randomize** procedure implements these steps as shown in [Figure 8-11](ch08.html#randomize_procedure
    "Figure 8-11. The Randomize procedure").
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`strIn`中随机挑选一个字母，并将该字母附加到*临时字符串* `str1`中。（这个临时字符串从一开始就是空的，我们将在构建混淆词时将其存储在这里。）然后，我们会从`strIn`中移除该字母，以避免重复使用，直到`strIn`为空，整个过程才会结束。**Randomize**过程按照[图8-11](ch08.html#randomize_procedure
    "图8-11. Randomize过程")中所示的步骤来实现这些操作。
- en: '![The Randomize procedure](httpatomoreillycomsourcenostarchimages2134897.png.jpg)Figure 8-11. The
    Randomize procedure'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![The Randomize procedure](httpatomoreillycomsourcenostarchimages2134897.png.jpg)图8-11.
    Randomize过程'
- en: First, **Randomize** sets `len` to the length of the input string, `strIn`,
    and empties the temporary string, `str1` ①. The procedure then starts a **repeat**
    loop to assemble the scrambled word ②. The repeat count equals the length of the
    input string. For each loop iteration, we pick a random position in `strIn` ③
    and append that letter to `str1` ④. Note that we used **length of** in step ③
    because `strIn` and its length will change inside the loop. After that, we call
    a procedure named **Remove** to delete the character we just used from `strIn`
    ⑤. When the loop finishes shuffling letters around, `strIn` is set to the scrambled
    word (`str1`) ⑥.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**Randomize**将`len`设置为输入字符串`strIn`的长度，并清空临时字符串`str1`①。接下来，过程开始一个**重复**循环来组装打乱的单词②。重复次数等于输入字符串的长度。每次循环迭代，我们从`strIn`中随机选择一个位置③，并将该字母追加到`str1`中④。请注意，我们在步骤③中使用了**长度**，因为`strIn`及其长度会在循环内部发生变化。之后，我们调用名为**删除**的过程来删除我们刚刚使用的字符⑤。当循环结束时，`strIn`被设置为打乱后的单词（`str1`）⑥。
- en: The **Remove** procedure, which lets us avoid adding the same letter to our
    scrambled word twice, is shown in [Figure 8-12](ch08.html#remove_procedure "Figure 8-12. The
    Remove procedure"). It removes a character from `strIn` at the position you specify
    with the `charPos` parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**过程，如[图8-12](ch08.html#remove_procedure "图8-12。删除过程")所示，允许我们避免将同一个字母添加到已经打乱的单词中两次。它会从`strIn`中删除你通过`charPos`参数指定的位置的字符。'
- en: '![The Remove procedure](httpatomoreillycomsourcenostarchimages2134899.png.jpg)Figure 8-12. The
    Remove procedure'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![删除过程](httpatomoreillycomsourcenostarchimages2134899.png.jpg)图8-12。删除过程'
- en: This procedure uses another temporary string, named `str2`, to build the new
    string we want to create. It starts by emptying `str2` and setting a loop counter,
    `n`, to 1 to access the first character of `strIn` ①. The procedure then starts
    a **repeat** loop to assemble the output string ②. If we don’t want to delete
    the current character, we append it to `str2` ③. The loop counter is then incremented
    to access the next letter of `strIn` ④. When the procedure finishes, `strIn` is
    set to the new word (`str2`) ⑤.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程使用了另一个临时字符串，名为`str2`，来构建我们想要创建的新字符串。它首先清空`str2`并设置一个循环计数器`n`为1，以访问`strIn`的第一个字符①。然后，过程开始一个**重复**循环，来组装输出字符串②。如果我们不想删除当前字符，就将它追加到`str2`中③。接着，循环计数器增加1，访问`strIn`的下一个字母④。当过程结束时，`strIn`被设置为新单词（`str2`）⑤。
- en: Now we are ready to explore the main script of the game, shown in [Figure 8-13](ch08.html#main_script_of_the_unscramble_game
    "Figure 8-13. The main script of the Unscramble game").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备探索游戏的主要脚本，如[图8-13](ch08.html#main_script_of_the_unscramble_game "图8-13。Unscramble游戏的主要脚本")所示。
- en: '![The main script of the Unscramble game](httpatomoreillycomsourcenostarchimages2134901.png.jpg)Figure 8-13. The
    main script of the Unscramble game'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Unscramble游戏的主要脚本](httpatomoreillycomsourcenostarchimages2134901.png.jpg)图8-13。Unscramble游戏的主要脚本'
- en: The script selects a word randomly from a list and saves that word in `inWord`
    ①. It then sets `strIn` equal to `inWord` ② and calls **Randomize** to shuffle
    the characters of `strIn` ③. After that, the script starts a loop to get the player’s
    answer ④. Inside the loop, the script asks the player to enter the unscrambled
    word ⑤ and uses an **if/else** block to check that answer ⑥. This part is identical
    to what we did in the Fix My Spelling game in the previous section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从列表中随机选择一个单词，并将该单词保存到`inWord`中①。然后，它将`strIn`设置为`inWord`②，并调用**Randomize**来打乱`strIn`中的字符③。接着，脚本开始一个循环以获取玩家的答案④。在循环内部，脚本要求玩家输入未打乱的单词⑤，并使用**if/else**块来检查答案⑥。这个部分与我们在上一节的Fix
    My Spelling游戏中所做的完全相同。
- en: The previous examples were just a small set of the different operations you
    can do on strings. Try using the same techniques to change strings in your own
    projects!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子只是你可以对字符串执行的不同操作的一小部分。尝试使用相同的技巧在你自己的项目中修改字符串！
- en: In the rest of this chapter, we’ll explore some programs that use strings to
    solve interesting problems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将探索一些使用字符串来解决有趣问题的程序。
- en: Scratch Projects
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch 项目
- en: The procedures you just saw demonstrated the basics of processing strings. In
    this section, we’ll apply what we’ve learned to write several practical applications.
    Along the way, you’ll learn some new programming tricks that you can use in your
    own creations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的过程演示了处理字符串的基础知识。在本节中，我们将应用所学的内容，编写几个实际应用。在这个过程中，你将学到一些新的编程技巧，可以用在你自己的创作中。
- en: Shoot
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shoot
- en: This game is intended to teach the concept of relative motion in a fun and engaging
    way. The object of the game is to estimate the turn angle and moving distance
    between two objects on the Stage. The user interface for the game is illustrated
    in [Figure 8-14](ch08.html#user_interface_of_the_shoot_game "Figure 8-14. The
    user interface of the Shoot game").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏旨在通过有趣和富有吸引力的方式教授相对运动的概念。游戏的目标是估算舞台上两个物体之间的转角和移动距离。游戏的用户界面如 [图8-14](ch08.html#user_interface_of_the_shoot_game
    "图8-14. 射击游戏的用户界面") 所示。
- en: '*Shoot.sb2*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shoot.sb2*'
- en: '![The user interface of the Shoot game](httpatomoreillycomsourcenostarchimages2134903.png.jpg)Figure 8-14. The
    user interface of the Shoot game'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![射击游戏的用户界面](httpatomoreillycomsourcenostarchimages2134903.png.jpg)图8-14. 射击游戏的用户界面'
- en: When the game starts, it positions the `Player` and the `Target` sprites at
    random locations on the Stage. Next it prompts the player to estimate the turn
    angle and the distance the `Player` sprite would need to move to hit the `Target`.
    The `Player` sprite is then moved according to the numbers entered by the player.
    If the sprite stops within a certain radius of the `Target`, the player wins the
    game. Otherwise, the `Player` sprite returns to its initial position, and the
    player can try again. When the green flag icon is clicked to start the game, the
    `Player` sprite runs the script shown in [Figure 8-15](ch08.html#player_sprite_script_that_runs_when_the
    "Figure 8-15. The Player sprite script that runs when the green flag icon is clicked").
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，系统会将 `Player` 和 `Target` 精灵随机放置在舞台上的某个位置。接下来，它会提示玩家估算转角和 `Player` 精灵需要移动的距离，以便击中
    `Target`。然后，`Player` 精灵会根据玩家输入的数字进行移动。如果精灵停在 `Target` 周围的某个半径范围内，玩家就赢得游戏。否则，`Player`
    精灵将返回初始位置，玩家可以再次尝试。当点击绿色旗帜图标开始游戏时，`Player` 精灵运行 [图8-15](ch08.html#player_sprite_script_that_runs_when_the
    "图8-15. 点击绿色旗帜图标时运行的玩家精灵脚本") 中所示的脚本。
- en: '![The Player sprite script that runs when the green flag icon is clicked](httpatomoreillycomsourcenostarchimages2134905.png.jpg)Figure 8-15. The
    `Player` sprite script that runs when the green flag icon is clicked'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![点击绿色旗帜图标时运行的玩家精灵脚本](httpatomoreillycomsourcenostarchimages2134905.png.jpg)图8-15.
    点击绿色旗帜图标时运行的 `Player` 精灵脚本'
- en: 'The script broadcasts `NewGame` to instruct the `Helper` sprite to assign new
    locations for the `Player` and the `Target` sprites ①. The `Helper` sprite runs
    a simple procedure (not shown) that updates the following five variables with
    random numbers that will keep `Player` and `Target` visible (and separated by
    a certain distance) on the Stage:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本广播 `NewGame` 来指示 `Helper` 精灵为 `Player` 和 `Target` 精灵分配新的位置①。`Helper` 精灵运行一个简单的过程（未显示），该过程使用随机数更新以下五个变量，以确保
    `Player` 和 `Target` 在舞台上可见（并且保持一定距离）：
- en: '| `XPlayer` and `YPlayer` | The *x*- and *y*-coordinates of the `Player` sprite
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `XPlayer` 和 `YPlayer` | `Player` 精灵的 *x* 和 *y* 坐标 |'
- en: '| `XTarget` and `YTarget` | The *x*- and *y*-coordinates of the `Target` sprite
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `XTarget` 和 `YTarget` | `Target` 精灵的 *x* 和 *y* 坐标 |'
- en: '| `initAngle` | The initial direction of the `Player` sprite |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `initAngle` | `Player` 精灵的初始方向 |'
- en: Once the script has new positions for `Player` and `Target`, it broadcasts `StartGame`
    to move the `Target` sprite to its new location ②. (The script for the `Target`
    sprite is not shown here.) Then the script enters an infinite loop to give the
    player multiple chances to hit the target ③. The loop will be terminated by a
    **stop all** command (in the **CheckAnswers** procedure) when the player hits
    the target.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本为 `Player` 和 `Target` 设定了新位置，它会广播 `StartGame` 来将 `Target` 精灵移动到新的位置②。（`Target`
    精灵的脚本未在此显示。）接着，脚本进入一个无限循环，为玩家提供多次机会击中目标③。该循环将在玩家击中目标时通过 **stop all** 命令（在 **CheckAnswers**
    过程里）终止。
- en: Each loop iteration sets the initial position and direction of the `Player`
    sprite and clears all pen marks from the Stage ④ to delete the trace left behind
    from the previous guess. The script then broadcasts `GetAnswers` ⑤, and in response,
    the `Helper` sprite prompts the player to enter an answer, as shown in [Figure 8-16](ch08.html#getanswers_script
    "Figure 8-16. The GetAnswers script"). The `Helper` sprite then splits the answer
    into two parts (before and after the comma) and updates `angle` and `distance`
    accordingly. Follow along with the comments on [Figure 8-16](ch08.html#getanswers_script
    "Figure 8-16. The GetAnswers script") to see how this script works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代都会设置 `Player` 精灵的初始位置和方向，并清除舞台 ④ 上所有的画笔痕迹，以删除之前猜测所留下的轨迹。脚本接着广播 `GetAnswers`
    ⑤，响应时，`Helper` 精灵提示玩家输入答案，如[图 8-16](ch08.html#getanswers_script "图 8-16. GetAnswers
    脚本")所示。然后，`Helper` 精灵将答案拆分为两部分（逗号前后），并相应更新 `angle` 和 `distance`。跟随[图 8-16](ch08.html#getanswers_script
    "图 8-16. GetAnswers 脚本")上的注释，了解这个脚本如何工作。
- en: The `Player` sprite is then moved, with its pen down, as directed by the player
    ⑥. This leaves a visual trace of the movement route that the player can use to
    refine his or her estimate for the next round.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Player` 精灵在玩家的指示下移动，且其画笔处于下压状态⑥。这样，玩家可以看到一条视觉轨迹，帮助他们在下一轮中更好地估计位置。
- en: '![The GetAnswers script](httpatomoreillycomsourcenostarchimages2134907.png.jpg)Figure 8-16. The
    `GetAnswers` script'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![GetAnswers 脚本](httpatomoreillycomsourcenostarchimages2134907.png.jpg)图 8-16.
    `GetAnswers` 脚本'
- en: Finally, the `Player` sprite executes the **CheckAnswers** procedure to see
    whether it is close enough to the target. The game ends only if the `Player` sprite
    comes within a very close distance of the target. [Figure 8-17](ch08.html#checkanswers_procedure_of_the_player_spr
    "Figure 8-17. The CheckAnswers procedure of the Player sprite.") shows how the
    `Player` sprite checks its distance from the target.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Player` 精灵执行**CheckAnswers**程序，检查它是否足够接近目标。游戏仅在 `Player` 精灵与目标非常接近时结束。[图
    8-17](ch08.html#checkanswers_procedure_of_the_player_spr "图 8-17. `Player` 精灵的
    CheckAnswers 程序") 展示了 `Player` 精灵如何检查与目标的距离。
- en: The `Player` sprite uses the **distance to** block to check how close it is
    to the `Target` sprite. If the distance is less than 20 steps, the game considers
    this a hit and says, “You won!” Otherwise, the shooting trial is considered a
    miss, the **forever** loop starts again, and the player gets another chance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 精灵使用**distance to**积木检查它与 `Target` 精灵的距离。如果距离小于 20 步，游戏认为这是一次命中，并显示：“你赢了！”否则，射击尝试被视为未命中，**forever**
    循环重新开始，玩家获得下一次机会。'
- en: '![The CheckAnswers procedure of the Player sprite.](httpatomoreillycomsourcenostarchimages2134909.png.jpg)Figure 8-17. The
    CheckAnswers procedure of the `Player` sprite.Try It Out 8-4'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![`Player` 精灵的 CheckAnswers 程序](httpatomoreillycomsourcenostarchimages2134909.png.jpg)图
    8-17. `Player` 精灵的 CheckAnswers 程序。试试 8-4'
- en: Modify the Shoot game to keep track of the number of times it takes the player
    to hit the target and assign the player a score accordingly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 Shoot 游戏，记录玩家击中目标的次数，并根据此为玩家分配相应的分数。
- en: Binary to Decimal Converter
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制转十进制转换器
- en: 'Binary (base-2) numbers have only two possible digits: 0 and 1\. Most computers
    operate and communicate with binary numbers. Humans, however, prefer to work with
    numbers in the decimal (base-10) system. In this section, you’ll develop an application
    that converts binary numbers to their decimal equivalents. Later, you could use
    it as a game to test your ability to perform such conversions.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制（基数 2）数字只有两个可能的数字：0 和 1。大多数计算机使用二进制数字进行操作和通信。然而，人类更喜欢使用十进制（基数 10）系统进行计算。在这一部分，你将开发一个应用程序，将二进制数字转换为其十进制等效值。以后，你可以将其作为游戏来测试你进行这种转换的能力。
- en: '*BinaryToDecimal.sb2*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*BinaryToDecimal.sb2*'
- en: Let’s first discuss how to convert from binary to decimal. [Figure 8-18](ch08.html#converting_a_binary_number_to_a_decimal
    "Figure 8-18. Converting a binary number to a decimal number") shows an example
    using the binary number 10011011.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论如何将二进制转换为十进制。[图 8-18](ch08.html#converting_a_binary_number_to_a_decimal
    "图 8-18. 将二进制数字转换为十进制")展示了一个使用二进制数字 10011011 的示例。
- en: '![Converting a binary number to a decimal number](httpatomoreillycomsourcenostarchimages2134911.png)Figure 8-18. Converting
    a binary number to a decimal number'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![将二进制数字转换为十进制数字](httpatomoreillycomsourcenostarchimages2134911.png)图 8-18.
    将二进制数字转换为十进制数字'
- en: All we have to do is multiply each binary digit by its corresponding positional
    value and add the resulting products. *Positional values* correspond to increasing
    powers of the base from right to left, with the first position having a power
    of 0\. Since binary is base 2, the rightmost digit has a positional value of 2⁰
    = 1, so you’d multiply the digit by 1\. You’d multiply the next digit by 2¹ =
    2, the next by 2² = 4, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是将每个二进制位乘以其对应的位置值，并将结果相加。*位置值*对应于从右到左基数的逐次幂，第一个位置的幂为0。由于二进制是基数为2，因此最右边的数字具有位置值2⁰
    = 1，所以你将该数字乘以1。接着，下一位乘以2¹ = 2，再下一位乘以2² = 4，以此类推。
- en: '[Figure 8-19](ch08.html#binary-to-decimal_conversion_program "Figure 8-19. Binary-to-decimal
    conversion program") illustrates the user interface of the binary-to-decimal conversion
    application. The program asks the user to input an 8-bit binary number. It then
    shows the input number on the Stage with the `Bit` sprite, which uses two costumes
    to represent 0 and 1\. The program also computes the equivalent decimal number,
    and the `Driver` sprite, which has a computer costume, displays that value to
    the user.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-19](ch08.html#binary-to-decimal_conversion_program "图8-19。二进制到十进制转换程序")展示了二进制到十进制转换应用程序的用户界面。该程序要求用户输入一个8位的二进制数。然后，它将在舞台上显示输入的数字，并用`Bit`精灵展示，`Bit`精灵使用两种服装来表示0和1。程序还会计算等效的十进制数字，并且`Driver`精灵（其服装为计算机样式）将该值展示给用户。'
- en: '![Binary-to-decimal conversion program](httpatomoreillycomsourcenostarchimages2134913.png.jpg)Figure 8-19. Binary-to-decimal
    conversion programTry It Out 8-5'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![二进制到十进制转换程序](httpatomoreillycomsourcenostarchimages2134913.png.jpg)图8-19。二进制到十进制转换程序
    试一试 8-5'
- en: 'To check your understanding, practice the following binary-to-decimal conversions:
    (a) 1010100, (b) 1101001, and (c) 1100001.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查你的理解，练习以下二进制转十进制的转换： (a) 1010100，(b) 1101001，和 (c) 1100001。
- en: The program starts when the green flag icon is clicked. This event is trapped
    by the `Driver` sprite, which executes the script shown and described in [Figure 8-20](ch08.html#script_for_the_driver_sprite
    "Figure 8-20. The script for the Driver sprite").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当绿色旗帜图标被点击时，程序开始运行。该事件由`Driver`精灵捕获，`Driver`精灵执行[图8-20](ch08.html#script_for_the_driver_sprite
    "图8-20。`Driver`精灵的脚本")中所示的脚本。
- en: '![The script for the Driver sprite](httpatomoreillycomsourcenostarchimages2134915.png.jpg)Figure 8-20. The
    script for the `Driver` sprite'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![驱动精灵的脚本](httpatomoreillycomsourcenostarchimages2134915.png.jpg)图8-20。`Driver`精灵的脚本'
- en: This script prepares the Stage and asks the user to input a binary number so
    the `Bit` sprite can begin a new round of conversion. When the `Bit` sprite completes
    its work, the `Driver` sprite shows the user the decimal value, which is computed
    and stored by the `Bit` sprite in a shared variable named `decimal`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本准备舞台，并要求用户输入一个二进制数字，以便`Bit`精灵开始新的转换轮次。当`Bit`精灵完成任务后，`Driver`精灵将显示计算出的十进制值，该值由`Bit`精灵在一个名为`decimal`的共享变量中计算并存储。
- en: The script that the `Bit` sprite runs in response to the `Initialize` message
    is illustrated in [Figure 8-21](ch08.html#initialize_script_for_the_bit_sprite
    "Figure 8-21. The Initialize script for the Bit sprite").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bit`精灵在接收到`Initialize`消息后执行的脚本如[图8-21](ch08.html#initialize_script_for_the_bit_sprite
    "图8-21。`Bit`精灵的初始化脚本")所示。'
- en: '![The Initialize script for the Bit sprite](httpatomoreillycomsourcenostarchimages2134917.png.jpg)Figure 8-21. The
    `Initialize` script for the `Bit` sprite'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![`Bit`精灵的初始化脚本](httpatomoreillycomsourcenostarchimages2134917.png.jpg)图8-21。`Bit`精灵的`Initialize`脚本'
- en: This script draws a bit pattern representing eight zeros on the Stage. As you’ll
    see in a moment, wherever a binary 1 appears in the user’s input string, the script
    should stamp a costume of digit 1 over the corresponding bit. When the user enters
    the binary number to be converted, the `Bit` sprite should receive the `BinaryToDecimal`
    message and execute the script shown in [Figure 8-22](ch08.html#binarytodecimal_script_for_the_bit_sprit
    "Figure 8-22. The BinaryToDecimal script for the Bit sprite").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本绘制了一个表示八个零的位模式。在稍后的说明中，你将看到，每当用户输入的字符串中出现二进制1时，脚本会在相应的位上盖上数字1的服装。当用户输入需要转换的二进制数字时，`Bit`精灵应该接收`BinaryToDecimal`消息，并执行[图8-22](ch08.html#binarytodecimal_script_for_the_bit_sprit
    "图8-22。`Bit`精灵的`BinaryToDecimal`脚本")中所示的脚本。
- en: '![The BinaryToDecimal script for the Bit sprite](httpatomoreillycomsourcenostarchimages2134919.png.jpg)Figure 8-22. The
    `BinaryToDecimal` script for the `Bit` sprite'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![`Bit`精灵的BinaryToDecimal脚本](httpatomoreillycomsourcenostarchimages2134919.png.jpg)图8-22。`Bit`精灵的`BinaryToDecimal`脚本'
- en: 'First, the conversion procedure initializes all of the variables it will use
    ①:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转换程序初始化它将使用的所有变量①：
- en: '`length` is the number of bits in the user’s binary number.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length` 是用户输入的二进制数字的位数。'
- en: '`pos` points to the rightmost digit of the input number.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pos` 指向输入数字的最右边的数字。'
- en: '`weight` starts at the positional value of the rightmost binary digit.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weight` 从最右边二进制数字的位值开始。'
- en: '`decimal` is set to 0 but will hold the result of the conversion at the end.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal` 设置为0，但将在最后存储转换结果。'
- en: '`xPos` begins at the *x*-coordinate of the image of the rightmost binary digit.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xPos` 从图像最右边二进制数字的 *x* 坐标开始。'
- en: Inside the `repeat` loop ②, the procedure checks each digit to see whether it
    is a 1 or a 0\. If the loop finds a 1 ③, it adds the current value of `weight`
    to `decimal` and stamps the digit-1 costume on top of the digit-0 image.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`repeat`循环②内部，程序检查每个数字，看看它是1还是0。如果循环发现是1③，它将当前`weight`的值加到`decimal`中，并在数字0的图像上盖上数字1的服装。
- en: 'At the end of the loop, the script updates several variables before moving
    to the next iteration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的末尾，脚本在进入下一次迭代之前更新几个变量：
- en: '`pos` is updated to point to the digit to the left of the one we just processed.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pos` 更新为指向我们刚处理的数字左侧的数字。'
- en: '`xPos` is aligned with the center of the image of the next digit, just in case
    we need to stamp a new image.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xPos` 对齐到下一个数字图像的中心，以防我们需要盖上新的图像。'
- en: '`weight` is multiplied by 2, which means it will take on the values 1, 2, 4,
    8, 16, and so on as the loop iterates.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weight` 乘以2，这意味着随着循环的迭代，它将取值为1、2、4、8、16等。'
- en: Try It Out 8-6
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 8-6
- en: Make the `Driver` sprite validate the number entered by the user before broadcasting
    the `BinaryToDecimal` message to the `Bit` sprite. You should verify that (1)
    the number entered by the user is a binary number (that is, it only contains ones
    and zeros) and (2) the length of the input is at most eight digits.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让`Driver`角色在广播`BinaryToDecimal`消息给`Bit`角色之前，验证用户输入的数字。你需要验证：（1）用户输入的数字是一个二进制数字（即，它只包含1和0），以及（2）输入的长度最多为八位。
- en: Hangman
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刽子手
- en: In this section, we’ll write a classic Hangman game. [Figure 8-23](ch08.html#user_interface_for_the_hangman_game
    "Figure 8-23. The user interface for the Hangman game") shows the game in action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个经典的刽子手游戏。[图 8-23](ch08.html#user_interface_for_the_hangman_game
    "图 8-23. 刽子手游戏的用户界面")展示了游戏的实际操作。
- en: '*Hangman.sb2*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hangman.sb2*'
- en: '![The user interface for the Hangman game](httpatomoreillycomsourcenostarchimages2134921.png.jpg)Figure 8-23. The
    user interface for the Hangman game'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![刽子手游戏的用户界面](httpatomoreillycomsourcenostarchimages2134921.png.jpg)图 8-23.
    刽子手游戏的用户界面'
- en: 'The program randomly selects a secret six-letter word and shows one question
    mark for each letter. The player has eight chances to guess the letters in the
    word. If the player guesses a letter correctly, the program shows all occurrences
    of that letter in the secret word. Otherwise, the program shows a new part of
    a hanging figure (the head, body, left arm, and so on). After eight wrong guesses,
    the program finishes the figure, and the player loses the game. If the player
    guesses the secret word in eight attempts or fewer, the result is victory. This
    application has the following four sprites:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 程序随机选择一个秘密的六个字母的单词，并为每个字母显示一个问号。玩家有八次机会猜测单词中的字母。如果玩家猜对了字母，程序会显示该字母在单词中所有出现的位置。否则，程序会展示刽子手形象的一部分（头、身体、左臂等等）。经过八次错误的猜测后，程序完成刽子手的形象，玩家输掉游戏。如果玩家在八次尝试或更少的次数内猜对了秘密单词，则结果为胜利。该应用包含以下四个角色：
- en: '**Driver** This sprite hides itself when the game starts, prompts the player
    to enter guesses, and processes the player’s answers. When the game ends, the
    sprite shows one of the following two costumes:'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Driver** 这个角色在游戏开始时隐藏自己，提示玩家输入猜测，并处理玩家的答案。当游戏结束时，角色显示以下两种服装之一：'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134923.png.jpg)'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2134923.png.jpg)'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Hangman** This sprite displays the evolving image of the hangman. It has
    a total of nine costumes, each one showing an additional part of the hangman’s
    body, as depicted in [Figure 8-24](ch08.html#nine_costumes_of_the_hangman_sprite
    "Figure 8-24. The nine costumes of the Hangman sprite").'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**刽子手** 这个角色展示了刽子手逐步形成的图像。它总共有九个服装，每个服装展示了刽子手身体的一个新增部位，如[图 8-24](ch08.html#nine_costumes_of_the_hangman_sprite
    "图 8-24. 刽子手角色的九个服装")所示。'
- en: '![The nine costumes of the Hangman sprite](httpatomoreillycomsourcenostarchimages2134925.png.jpg)Figure 8-24. The
    nine costumes of the `Hangman` sprite'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![`Hangman`角色的九个服装](httpatomoreillycomsourcenostarchimages2134925.png.jpg)图8-24.
    `Hangman`角色的九个服装'
- en: '**New** This sprite displays the `New` button on the Stage.'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**New** 这个角色在舞台上显示`New`按钮。'
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Helper** This invisible sprite displays the letters guessed by the player
    as well as the number of remaining attempts. It uses seven variables with monitors
    configured as large displays and positioned at the correct locations on the Stage.
    Using a different sprite to update the display separates the game logic from the
    user interface. You can, for example, change this sprite to show more fancy letters
    on the Stage without affecting the rest of the application.'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Helper** 这个不可见的角色显示玩家猜测的字母以及剩余的猜测次数。它使用七个带有监视器的变量，监视器配置为大显示屏并放置在舞台上的正确位置。通过使用不同的角色来更新显示，将游戏逻辑与用户界面分开。例如，您可以更改此角色，在舞台上显示更花哨的字母，而不会影响应用程序的其他部分。'
- en: When the player presses the `New` sprite (the `New` button), it broadcasts a
    `NewGame` message to alert the `Driver` sprite that a new game has started. When
    the `Driver` sprite receives this message, it executes the script shown in [Figure 8-25](ch08.html#newgame_script_of_the_driver_sprite
    "Figure 8-25. The NewGame script of the Driver sprite").
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下`New`角色（`New`按钮）时，它会广播`NewGame`消息，通知`Driver`角色游戏开始了。当`Driver`角色接收到此消息时，它会执行[图8-25](ch08.html#newgame_script_of_the_driver_sprite
    "图8-25. `Driver`角色的`NewGame`脚本")中显示的脚本。
- en: '![The NewGame script of the Driver sprite](httpatomoreillycomsourcenostarchimages2134927.png.jpg)Figure 8-25. The
    `NewGame` script of the `Driver` sprite'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![`Driver`角色的`NewGame`脚本](httpatomoreillycomsourcenostarchimages2134927.png.jpg)图8-25.
    `Driver`角色的`NewGame`脚本'
- en: The script resets the game’s user interface ① and starts a loop ② to read in
    letter guesses. Another procedure called by the `Driver` sprite will terminate
    this loop via a **stop all** block when the game’s end condition is detected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本重置游戏的用户界面①，并启动一个循环②来读取字母猜测。另一个由`Driver`角色调用的过程将在检测到游戏结束条件时，通过**stop all**块终止此循环。
- en: In each iteration of the loop, the `Driver` sprite asks the player to guess
    a letter and waits for input ③. When the player enters a guess, the script calls
    **ProcessAnswer**, which will update a flag (named `gotLetter`) to indicate whether
    the letter was right or wrong.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，`Driver`角色会要求玩家猜一个字母并等待输入③。当玩家输入猜测时，脚本调用**ProcessAnswer**，该过程会更新一个标志（名为`gotLetter`），用于指示字母是否正确。
- en: When **ProcessAnswer** returns, the script checks the `gotLetter` flag ④ and
    acts based on whether the player’s guess was correct or not. I’ll explain the
    procedures called by `NewGame` next, starting with the scripts in [Figure 8-26](ch08.html#scripts_triggered_from_the_initialize_pr
    "Figure 8-26. Scripts triggered from the Initialize procedure").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当**ProcessAnswer**返回时，脚本检查`gotLetter`标志④，并根据玩家的猜测是否正确采取行动。我接下来将解释`NewGame`调用的过程，从[图8-26](ch08.html#scripts_triggered_from_the_initialize_pr
    "图8-26. 从初始化过程触发的脚本")中的脚本开始。
- en: '![Scripts triggered from the Initialize procedure](httpatomoreillycomsourcenostarchimages2134929.png.jpg)Figure 8-26. Scripts
    triggered from the Initialize procedure'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![从初始化过程触发的脚本](httpatomoreillycomsourcenostarchimages2134929.png.jpg)图8-26.
    从初始化过程触发的脚本'
- en: During initialization, the `Driver` sprite hides itself, initializes `displayWord`
    to a string with six question marks, and sets `remAttempts` (how many guesses
    the player has left) to 8\. It then selects the `secretWord` from a predefined
    list of six-letter words. Next the procedure broadcasts `Update` so the `Helper`
    sprite will assign its variables (whose monitors are visible on the Stage) to
    the correct values. The last instruction broadcasts the `Reset` message to the
    `Hangman` sprite. When the `Hangman` sprite receives this message, it switches
    to its `start` costume, which shows an empty gallows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化期间，`Driver`角色会隐藏自己，将`displayWord`初始化为包含六个问号的字符串，并将`remAttempts`（玩家剩余猜测次数）设置为8。然后，它会从预定义的六个字母单词列表中选择`secretWord`。接下来，过程广播`Update`，以便`Helper`角色将其变量（在舞台上可见的监视器）赋值为正确的数值。最后的指令广播`Reset`消息给`Hangman`角色。当`Hangman`角色接收到此消息时，它会切换到其`start`服装，显示一个空的绞刑架。
- en: Now let’s consider a simple example to help us understand what the **ProcessAnswer**
    procedure does (see [Figure 8-27](ch08.html#processanswer_procedure "Figure 8-27. The
    ProcessAnswer procedure")). Assume the secret word is *across* and that this is
    the first round of the game (which means that `displayWord` is “??????”). If the
    player’s first guess is `r`, **ProcessAnswer** should set `gotLetter` to 1 to
    indicate a correct guess, set `displayWord` to “??r???” to show the letter’s position,
    and set `qmarkCount` (the number of question marks in the updated display string)
    to 5. When `qmarkCount` reaches 0, the player has guessed all the letters in the
    secret word. **ProcessAnswer** belongs to the `Driver` sprite, and you can see
    the full script in [Figure 8-27](ch08.html#processanswer_procedure "Figure 8-27. The
    ProcessAnswer procedure") (left).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个简单的例子，帮助我们理解**ProcessAnswer**过程的作用（见[图8-27](ch08.html#processanswer_procedure
    "图8-27. ProcessAnswer过程")）。假设秘密单词是*across*，这是游戏的第一轮（也就是说`displayWord`是“??????”）。如果玩家的第一次猜测是`r`，那么**ProcessAnswer**应该将`gotLetter`设置为1，表示猜对了，将`displayWord`设置为“??r???”，显示字母的位置，并将`qmarkCount`（更新后的显示字符串中的问号数量）设置为5。当`qmarkCount`为0时，玩家已经猜出了秘密单词中的所有字母。**ProcessAnswer**属于`Driver`精灵，完整的脚本可以在[图8-27](ch08.html#processanswer_procedure
    "图8-27. ProcessAnswer过程")（左）中看到。
- en: '**ProcessAnswer** starts by resetting both the `gotLetter` flag and `qmarkCount`
    to 0\. It will increase `qmarkCount` by 1 for every unknown letter in the secret
    word. The temporary variable, `temp`, which is used to construct the display string
    after every guess, is initialized to an empty string. The `pos` variable is used
    as a loop counter.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProcessAnswer**开始时将`gotLetter`标志和`qmarkCount`都重置为0。它会在每个未知字母出现时，将`qmarkCount`增加1。临时变量`temp`用于在每次猜测后构建显示字符串，初始化为空字符串。`pos`变量用作循环计数器。'
- en: '![The ProcessAnswer procedure](httpatomoreillycomsourcenostarchimages2134931.png.jpg)Figure 8-27. The
    ProcessAnswer procedure'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![ProcessAnswer过程](httpatomoreillycomsourcenostarchimages2134931.png.jpg)图8-27. ProcessAnswer过程'
- en: The loop examines each letter of `secretWord`, using `pos` as an index. If the
    examined letter (saved in `char`) equals the guessed letter (saved in Scratch’s
    built-in `answer` variable), the `gotLetter` flag is set to 1\. Otherwise, the
    `char` variable is set to the letter at the corresponding position in the `displayWord`
    variable. Either way, the script adds `char` to the end of `temp`, as illustrated
    in [Figure 8-27](ch08.html#processanswer_procedure "Figure 8-27. The ProcessAnswer
    procedure") (right).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 循环检查`secretWord`的每个字母，使用`pos`作为索引。如果检查到的字母（保存在`char`中）等于猜测的字母（保存在Scratch的内置`answer`变量中），则将`gotLetter`标志设置为1。否则，`char`变量会被设置为`displayWord`变量中对应位置的字母。不论哪种情况，脚本都会将`char`添加到`temp`的末尾，如[图8-27](ch08.html#processanswer_procedure
    "图8-27. ProcessAnswer过程")（右）所示。
- en: When the loop terminates, the `displayWord` variable will contain the six letters
    to be displayed on the Stage, taking the user’s most recent guess into account.
    The loop also tracks the number of question marks in the display string. If there
    are none, then the user has successfully guessed the secret word.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，`displayWord`变量将包含六个字母，这些字母将在舞台上显示，并考虑到用户最近的猜测。该循环还会跟踪显示字符串中问号的数量。如果没有问号，则说明用户已经成功猜出秘密单词。
- en: When **ProcessAnswer** returns, the `NewGame` message handler checks `gotLetter`
    to see whether the player guessed correctly. If not, it will call **ProcessWrongGuess**,
    shown in [Figure 8-28](ch08.html#processwrongguess_procedure "Figure 8-28. The
    ProcessWrongGuess procedure").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当**ProcessAnswer**返回时，`NewGame`消息处理程序会检查`gotLetter`，以查看玩家是否猜对了。如果没有，它将调用**ProcessWrongGuess**，如[图8-28](ch08.html#processwrongguess_procedure
    "图8-28. ProcessWrongGuess过程")所示。
- en: This procedure broadcasts `WrongGuess` to notify the `Hangman` sprite to show
    its next costume, and then it decrements the number of remaining guesses by 1\.
    If the user is out of guesses, the script reveals the secret word and ends the
    game. Otherwise, it broadcasts an `Update` message to show how many trials the
    player has left.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程广播`WrongGuess`，通知`Hangman`精灵显示其下一个服装，然后将剩余猜测次数减1。如果用户已经没有猜测机会，脚本会揭示秘密单词并结束游戏。否则，脚本广播`Update`消息，显示玩家剩余的猜测次数。
- en: '![The ProcessWrongGuess procedure](httpatomoreillycomsourcenostarchimages2134933.png.jpg)Figure 8-28. The
    ProcessWrongGuess procedure'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![ProcessWrongGuess过程](httpatomoreillycomsourcenostarchimages2134933.png.jpg)图8-28. ProcessWrongGuess过程'
- en: If the player’s letter was correct, the **ProcessCorrectGuess** shown in [Figure 8-29](ch08.html#processcorrectguess_procedure
    "Figure 8-29. The ProcessCorrectGuess procedure") should be called instead of
    **ProcessWrongGuess**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的字母正确，则应调用[图 8-29](ch08.html#processcorrectguess_procedure "图 8-29. ProcessCorrectGuess
    程序")中显示的 **ProcessCorrectGuess**，而不是 **ProcessWrongGuess**。
- en: '![The ProcessCorrectGuess procedure](httpatomoreillycomsourcenostarchimages2134935.png.jpg)Figure 8-29. The
    ProcessCorrectGuess procedure'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![ProcessCorrectGuess 程序](httpatomoreillycomsourcenostarchimages2134935.png.jpg)图
    8-29. ProcessCorrectGuess 程序'
- en: '**ProcessCorrectGuess** broadcasts `Update` to show the letter the player guessed
    correctly. It then checks the value of `qmarkCount`. If `qmarkCount` is 0, the
    player has guessed all of the letters correctly, so the `Driver` sprite shows
    its `win` costume and ends the game.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProcessCorrectGuess** 广播 `Update` 消息，显示玩家正确猜出的字母。接着，它检查 `qmarkCount` 的值。如果
    `qmarkCount` 为 0，说明玩家已正确猜出了所有字母，于是 `Driver` 精灵显示其 `win` 服装并结束游戏。'
- en: Try It Out 8-7
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 8-7
- en: The Hangman program doesn’t validate the user input; you could enter a non-alphabetic
    character or even an entire word. Modify the program so that it rejects any invalid
    input by the user.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Hangman 程序不验证用户输入；你可以输入一个非字母字符甚至是整个单词。修改程序，使其拒绝用户的任何无效输入。
- en: Fraction Tutor
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数导师
- en: For our last example, we’ll present an educational game for teaching fractions.
    The interface for this game is shown in [Figure 8-30](ch08.html#user_interface_for_the_fraction_tutor_ap
    "Figure 8-30. The user interface for the Fraction Tutor application"). The player
    can select an operation (+, –, ×, or ÷) and click the `New` button to create a
    new problem. When the player enters an answer and clicks the `Check` button, the
    `Teacher` sprite (image of a woman) checks that answer and provides an appropriate
    feedback message.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们将展示一个教学分数的教育游戏。该游戏的界面如[图 8-30](ch08.html#user_interface_for_the_fraction_tutor_ap
    "图 8-30. 分数导师应用程序的用户界面")所示。玩家可以选择一个运算符（+、–、× 或 ÷），并点击 `New` 按钮创建一个新问题。当玩家输入答案并点击
    `Check` 按钮时，`Teacher` 精灵（一个女性形象）会检查答案并提供适当的反馈消息。
- en: '*FractionTutor.sb2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*FractionTutor.sb2*'
- en: '![The user interface for the Fraction Tutor application](httpatomoreillycomsourcenostarchimages2134937.png.jpg)Figure 8-30. The
    user interface for the Fraction Tutor application'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![分数导师应用程序的用户界面](httpatomoreillycomsourcenostarchimages2134937.png.jpg)图 8-30.
    分数导师应用程序的用户界面'
- en: The application contains six sprites. `Operation` allows the player to choose
    a mathematical operation. `Read` shows the answer entry button, `New` shows the
    `New` button, and `Check` shows the `Check` button. The `Teacher` sprite checks
    the player’s answer, and an invisible sprite named `Digit` stamps the numbers
    that correspond to the current problem on the Stage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序包含六个精灵。`Operation` 允许玩家选择数学运算。`Read` 显示答案输入按钮，`New` 显示 `New` 按钮，`Check`
    显示 `Check` 按钮。`Teacher` 精灵检查玩家的答案，而一个名为 `Digit` 的隐形精灵在舞台上打印出与当前问题对应的数字。
- en: When the player clicks the `New` sprite (the `New` button), it executes the
    script shown in [Figure 8-31](ch08.html#script_for_the_new_sprite "Figure 8-31. The
    script for the New sprite"). The script assigns random values between 1 and 9
    to the numerator and denominator of both operands, which are represented by the
    four variables `num1`, `den1`, `num2`, and `den2`. It then broadcasts a `NewProblem`
    message to tell the `Digit` sprite to stamp these numbers on the Stage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击 `New` 精灵（`New` 按钮）时，它会执行[图 8-31](ch08.html#script_for_the_new_sprite "图
    8-31. New 精灵的脚本")中显示的脚本。该脚本将 1 到 9 之间的随机值分配给两个操作数的分子和分母，这些值由四个变量 `num1`、`den1`、`num2`
    和 `den2` 表示。然后，它广播一个 `NewProblem` 消息，告诉 `Digit` 精灵在舞台上打印这些数字。
- en: '![The script for the New sprite](httpatomoreillycomsourcenostarchimages2134939.png.jpg)Figure 8-31. The
    script for the `New` sprite'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![New 精灵的脚本](httpatomoreillycomsourcenostarchimages2134939.png.jpg)图 8-31.
    `New` 精灵的脚本'
- en: The `Digit` sprite has 12 costumes (named `d1` through `d12`), as shown in [Figure 8-32](ch08.html#function_of_the_digit_sprite
    "Figure 8-32. The function of the Digit sprite") (right). When this sprite receives
    the `NewProblem` broadcast, it stamps costumes representing the numerators and
    denominators of the two operands. [Figure 8-32](ch08.html#function_of_the_digit_sprite
    "Figure 8-32. The function of the Digit sprite") also shows the procedure that
    does the actual stamping.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Digit`精灵有12个服装（命名为`d1`至`d12`），如[图8-32](ch08.html#function_of_the_digit_sprite
    "图8-32。Digit精灵的功能")（右图）所示。当该精灵接收到`NewProblem`广播时，它会盖上代表两个操作数的分子和分母的服装。[图8-32](ch08.html#function_of_the_digit_sprite
    "图8-32。Digit精灵的功能")还展示了执行实际盖图过程的步骤。'
- en: '![The function of the Digit sprite](httpatomoreillycomsourcenostarchimages2134941.png.jpg)Figure 8-32. The
    function of the `Digit` sprite'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![Digit精灵的功能](httpatomoreillycomsourcenostarchimages2134941.png.jpg)图8-32。`Digit`精灵的功能'
- en: The procedure uses nested **if/else** blocks to determine which costume corresponds
    to the digit to be stamped. Note how the costume name for digits 1 through 9 is
    formed using the **join** operator. After switching to the correct costume, the
    `Digit` sprite moves to the specified (*x*,*y*) position and stamps the image
    of the costume at that location.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程使用嵌套的**if/else**块来确定哪个服装对应于要盖上的数字。注意，数字1到9的服装名称是通过**join**运算符组合而成的。切换到正确的服装后，`Digit`精灵会移动到指定的(*x*,*y*)位置，并在该位置盖上服装的图像。
- en: When the new problem is shown, the user can click the `Read` button to enter
    an answer. The script associated with this button is illustrated in [Figure 8-33](ch08.html#script_of_the_read_sprite
    "Figure 8-33. The script of the Read sprite"). The part of the script that parses
    the player’s answer into two tokens (numerator and denominator) is similar to
    the one presented in [Figure 8-16](ch08.html#getanswers_script "Figure 8-16. The
    GetAnswers script") for extracting the `angle` and `distance` from `answer` in
    the Shoot game and, therefore, is not shown here. Check the *FractionTutor.sb2*
    file for the complete procedure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当新问题显示时，用户可以点击`Read`按钮输入答案。与此按钮关联的脚本如[图8-33](ch08.html#script_of_the_read_sprite
    "图8-33。Read精灵的脚本")所示。脚本中将玩家的答案解析为两个标记（分子和分母）的部分与[图8-16](ch08.html#getanswers_script
    "图8-16。GetAnswers脚本")中提取`Shoot`游戏中`answer`的`angle`和`distance`部分类似，因此此处不再显示。有关完整过程，请查看*FractionTutor.sb2*文件。
- en: '![The script of the Read sprite](httpatomoreillycomsourcenostarchimages2134943.png.jpg)Figure 8-33. The
    script of the `Read` sprite'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![Read精灵的脚本](httpatomoreillycomsourcenostarchimages2134943.png.jpg)图8-33。`Read`精灵的脚本'
- en: First, the user is asked to enter an answer in fraction form (for example, 3/5
    or –7/8). The script then extracts the numerator and the denominator of the answer
    string (which are separated by the division sign) and assigns them to the `num3`
    and `den3` variables, respectively. For example, if the user enters –23/15, `num3`
    will be set to –23 and `den3` will be set to 15. After that, the script broadcasts
    a `GotAnswer` message to tell the `Digit` sprite to show the user’s answer on
    the Stage. When the `Digit` sprite receives this message, it stamps the digits
    of `num3` and `den3` at the correct positions on the Stage in the same way it
    displayed the numerators and denominators of the two operands. You can check the
    file *FractionTutor.sb2* for the details.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户被要求输入一个分数形式的答案（例如，3/5或–7/8）。然后，脚本提取答案字符串的分子和分母（它们由除号分隔），并分别将它们赋值给`num3`和`den3`变量。例如，如果用户输入–23/15，`num3`将被设置为–23，`den3`将被设置为15。之后，脚本广播一个`GotAnswer`消息，告诉`Digit`精灵在舞台上展示用户的答案。当`Digit`精灵接收到该消息时，它会以与显示两个操作数分子和分母相同的方式，在舞台上正确的位置盖上`num3`和`den3`的数字。您可以查看*FractionTutor.sb2*文件了解详情。
- en: After entering an answer, the user can click the `Check` button to see if the
    answer is correct. The script for the `Check` sprite broadcasts a `CheckAnswer`
    message to inform the other sprites of the user’s request. This message is trapped
    and processed by the `Teacher` sprite, which will execute the script shown in
    [Figure 8-34](ch08.html#checkanswer_script "Figure 8-34. The CheckAnswer script").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输入答案后，用户可以点击`Check`按钮查看答案是否正确。`Check`精灵的脚本广播一个`CheckAnswer`消息，通知其他精灵用户的请求。该消息由`Teacher`精灵捕获并处理，`Teacher`精灵将执行[图8-34](ch08.html#checkanswer_script
    "图8-34。CheckAnswer脚本")所示的脚本。
- en: '![The CheckAnswer script](httpatomoreillycomsourcenostarchimages2134945.png.jpg)Figure 8-34. The
    `CheckAnswer` script'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![CheckAnswer脚本](httpatomoreillycomsourcenostarchimages2134945.png.jpg)图8-34.
    `CheckAnswer`脚本'
- en: The current costume of the `Operation` sprite tells which operation procedure
    (**Add**, **Subtract**, **Multiply**, or **Divide**) to execute ①. The operations
    take `num1`, `den1`, `num2`, and `den2` as inputs and set the values of `ansNum`
    and `ansDen`, which represent the numerator and denominator of the correct answer,
    respectively. The four procedures are shown in [Figure 8-35](ch08.html#addcomma_subtractcomma_multiplycomma_and
    "Figure 8-35. The Add, Subtract, Multiply, and Divide procedures of the Teacher
    sprite").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当前`Operation`精灵的服装告诉我们需要执行哪种操作过程（**加法**、**减法**、**乘法**或**除法**）①。操作以`num1`、`den1`、`num2`和`den2`为输入，设置`ansNum`和`ansDen`的值，分别代表正确答案的分子和分母。这四个过程如[图8-35](ch08.html#addcomma_subtractcomma_multiplycomma_and
    "图8-35. Teacher精灵的加法、减法、乘法和除法过程")所示。
- en: After finding the answer, `CheckAnswer` needs to put it in its simplest form.
    For example, 2/4 should be simplified to 1/2\. To perform this reduction, the
    script first finds the greatest common divisor (GCD), also known as the greatest
    common factor, of the numerator and denominator ②. (We’ll look at this procedure
    in a moment.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到答案后，`CheckAnswer`需要将其简化。例如，2/4应该简化为1/2。为了执行此简化，脚本首先找到分子和分母的最大公约数（GCD），也称为最大公因数②。（稍后我们将看这个过程。）
- en: '![The Add, Subtract, Multiply, and Divide procedures of the Teacher sprite](httpatomoreillycomsourcenostarchimages2134947.png.jpg)Figure 8-35. The
    Add, Subtract, Multiply, and Divide procedures of the `Teacher` sprite'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![Teacher精灵的加法、减法、乘法和除法过程](httpatomoreillycomsourcenostarchimages2134947.png.jpg)图8-35.
    `Teacher`精灵的加法、减法、乘法和除法过程'
- en: After finding the GCD, the script divides `ansNum` and `ansDen` by that value
    ③ and calls **GiveFeedback** ④ to display whether or not the user’s answer was
    correct.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 找到GCD后，脚本将`ansNum`和`ansDen`分别除以该值③，并调用**GiveFeedback**④来显示用户的答案是否正确。
- en: Now let’s look more closely at the details of these procedures, starting with
    the four operation procedures shown in [Figure 8-35](ch08.html#addcomma_subtractcomma_multiplycomma_and
    "Figure 8-35. The Add, Subtract, Multiply, and Divide procedures of the Teacher
    sprite").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看这些过程的细节，从[图8-35](ch08.html#addcomma_subtractcomma_multiplycomma_and
    "图8-35. Teacher精灵的加法、减法、乘法和除法过程")中展示的四个操作过程开始。
- en: These procedures compute the result of performing an operation of the form
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程计算执行类似以下形式的操作结果：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134949.png.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134949.png.jpg)'
- en: and store the result in two variables (`ansNum` and `ansDen`) corresponding
    to the answer’s numerator and denominator, respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并将结果存储在两个变量中（`ansNum`和`ansDen`），分别对应答案的分子和分母。
- en: Let’s now move on to the **FindGCD** procedure, shown in [Figure 8-36](ch08.html#findgcd_procedure_of_the_teacher_sprite
    "Figure 8-36. The FindGCD procedure of the Teacher sprite").
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讲解**FindGCD**过程，如[图8-36](ch08.html#findgcd_procedure_of_the_teacher_sprite
    "图8-36. Teacher精灵的FindGCD过程")所示。
- en: '![The FindGCD procedure of the Teacher sprite](httpatomoreillycomsourcenostarchimages2134951.png.jpg)Figure 8-36. The
    FindGCD procedure of the `Teacher` sprite'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![Teacher精灵的FindGCD过程](httpatomoreillycomsourcenostarchimages2134951.png.jpg)图8-36.
    `Teacher`精灵的FindGCD过程'
- en: Let’s trace the operation of **FindGCD** when `num1` = –10 and `num2` = 6\.
    We need to find the largest positive integer that divides `num1` and `num2` without
    a remainder. The procedure starts by setting `gcd`, the result, to the lesser
    absolute value of the two numbers, –6 in our example. A loop then tests the numbers
    6, 5, 4, and so on, until both `num1` and `num2` divide evenly by the checked
    number. This is the result we are after. In this example, `gcd` will be set to
    2 since both numbers (–10 and 6) divide by 2 without a remainder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪**FindGCD**的操作，当`num1` = –10且`num2` = 6时。我们需要找到一个最大的正整数，它能整除`num1`和`num2`而没有余数。过程从将`gcd`（结果）设置为两个数的较小绝对值开始，在本例中为–6。然后，循环测试数字6、5、4，以此类推，直到`num1`和`num2`都能被检查的数字整除。这就是我们要找的结果。在本例中，`gcd`将被设置为2，因为两个数（–10和6）都能被2整除且没有余数。
- en: The last procedure to examine is the **GiveFeedback** procedure, which compares
    the user’s answer with the correct answer and displays an appropriate message,
    as shown in [Figure 8-37](ch08.html#givefeedback_procedure_of_the_teacher_sp "Figure 8-37. The
    GiveFeedback procedure of the Teacher sprite"). The figure also shows some examples
    that demonstrate the different cases of the **if/else** structure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要检查的过程是**GiveFeedback**过程，它将用户的答案与正确答案进行比较，并显示适当的信息，如[图 8-37](ch08.html#givefeedback_procedure_of_the_teacher_sp
    "图 8-37. Teacher精灵的GiveFeedback过程")所示。该图还展示了一些示例，演示了**if/else**结构的不同情况。
- en: '![The GiveFeedback procedure of the Teacher sprite](httpatomoreillycomsourcenostarchimages2134953.png.jpg)Figure 8-37. The
    GiveFeedback procedure of the `Teacher` spriteTry It Out 8-8'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![Teacher精灵的GiveFeedback过程](httpatomoreillycomsourcenostarchimages2134953.png.jpg)图
    8-37. `Teacher` 精灵的 GiveFeedback 过程 尝试 8-8'
- en: Modify the fraction tutor program to keep track of the number of correct and
    incorrect answers. Devise a scheme for calculating a score and showing it to the
    user.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 修改分数辅导程序，以跟踪正确和错误答案的数量。设计一个计算分数并显示给用户的方案。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: String processing is an important programming skill. In this chapter, you learned
    how to access individual characters of a string to combine them, compare them,
    remove them, and shuffle them around.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串处理是一个重要的编程技能。在本章中，你学习了如何访问字符串的单个字符，以便将它们组合、比较、删除和重新排列。
- en: We started with a detailed look at the string data type and how strings are
    stored as sequences of characters. We then wrote several procedures that demonstrated
    basic string manipulation techniques. After that, we used these techniques to
    write several interesting and practical applications. The concepts developed in
    these projects can be applied in many other areas, and I certainly hope they’ll
    help you think of your own projects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从详细了解字符串数据类型以及字符串如何作为字符序列存储开始。然后我们编写了几个程序，演示了基本的字符串操作技术。之后，我们使用这些技术编写了几个有趣且实用的应用程序。这些项目中发展出的概念可以应用于许多其他领域，我真心希望它们能帮助你想到自己的项目。
- en: In the next chapter, you’ll learn about lists and how to use them to store and
    manipulate a bunch of values. Equipped with this new data structure, you’ll have
    all the tools you need to write professional programs in Scratch.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于列表的内容，以及如何使用它们来存储和操作一组值。掌握了这一新的数据结构后，你将拥有编写专业程序所需的所有工具。
- en: Problems
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. Write a program that asks the user to enter a word and then
    says that word *N* times, where *N* is the number of letters in the input word.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 1\. 编写一个程序，要求用户输入一个单词，然后输出该单词 *N* 次，其中 *N* 是输入单词中字符的数量。 |'
- en: '| **Q:** | 2\. Write a program that asks the user to enter a word. The program
    then determines the number of occurrences of the letter *a* in the input word.
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 2\. 编写一个程序，要求用户输入一个单词。程序随后确定字母 *a* 在输入单词中的出现次数。 |'
- en: '| **Q:** | 3\. Write a program that reads a singular English noun from the
    user. The program then produces the plural form of that noun. (Hint: Check the
    last letter and the second from the last letter of the input word.) To keep the
    program simple, consider only the following rule: If the word ends in *ch*, *x*,
    or *s*, add *es* for the plural, otherwise just add an *s*. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 3\. 编写一个程序，读取用户输入的一个单数英语名词。程序随后生成该名词的复数形式。（提示：检查输入单词的最后一个字母和倒数第二个字母。）为了保持程序简单，仅考虑以下规则：如果单词以
    *ch*、*x* 或 *s* 结尾，则加 *es* 构成复数，否则只加 *s*。 |'
- en: '| **Q:** | 4\. Write a program that reads a single character (between *a* and
    *z*) from the user and outputs the position of that character in the alphabet
    (*a* = 1, *b* = 2, *c* = 3, and so on). Uppercase letters and lowercase letters
    should be treated the same. (Hint: Define a variable named `alpha` that holds
    the letters of the alphabet, as we did in [Figure 8-9](ch08.html#main_script_for_the_fix_my_spelling_game
    "Figure 8-9. The main script for the Fix My Spelling game"), and then use a loop
    to find the position of the input character within the variable *alpha*.) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 4\. 编写一个程序，读取用户输入的一个字符（介于 *a* 和 *z* 之间），并输出该字符在字母表中的位置（*a* = 1，*b*
    = 2，*c* = 3，依此类推）。大写字母和小写字母应当视为相同。（提示：定义一个名为 `alpha` 的变量，存储字母表中的字母，正如我们在[图 8-9](ch08.html#main_script_for_the_fix_my_spelling_game
    "图 8-9. 修复拼写游戏的主脚本")中所做的，然后使用循环查找输入字符在变量 *alpha* 中的位置。） |'
- en: '| **Q:** | 5\. Write a program that asks the user to enter a letter of the
    alphabet and then displays the letter that precedes the input letter. (Hint: Use
    the same technique used in the previous problem.) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 5\. 编写一个程序，要求用户输入一个字母，然后显示该字母前面的字母。（提示：使用与上一问题中相同的技巧。） |'
- en: '| **Q:** | 6\. Write a program that reads a positive integer from the user
    then finds and displays the sum of its digits. For example, if the user enters
    `3582`, the program should display `18` (3 + 5 + 8 + 2). |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 6\. 编写一个程序，读取用户输入的正整数，然后找到并显示其各位数字的和。例如，如果用户输入`3582`，程序应该显示`18`（3
    + 5 + 8 + 2）。 |'
- en: '| **Q:** | 7\. Write a program that reads a word from the user and then displays
    the letters in reverse using the **say** block. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 7\. 编写一个程序，读取用户输入的一个单词，然后使用**说**积木以反向顺序显示字母。 |'
- en: '| **Q:** | 8\. Write a program that gets a number from the user and then inserts
    a space between each pair of digits. For example, if the input number is `1234`,
    the output string should be `1 2 3 4`. (Hint: Construct the output variable by
    joining the individual letters from the input number with white spaces.) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 8\. 编写一个程序，从用户那里获取一个数字，并在每对数字之间插入一个空格。例如，如果输入数字是`1234`，则输出字符串应为`1
    2 3 4`。（提示：通过在输入数字的每个单独数字之间加入空格来构建输出变量。） |'
- en: '| **Q:** | 9\. In this problem, you’ll create a game that lets players compare
    fractions. The user interface is shown on the right. When the `New` button is
    clicked, the game randomly picks two fractions to compare. The user selects less
    than (<), greater than (>), or equal to (=) by clicking the operator button. When
    the user clicks the `Check` button, the game checks the answer and provides feedback.
    Open the file *CompareFractions.sb2* and add the necessary scripts to complete
    the game.*Compare Fractions.sb2*![image with no caption](httpatomoreillycomsourcenostarchimages2134955.png.jpg)
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 9\. 在这个问题中，您将创建一个游戏，让玩家比较分数。用户界面如下所示。当点击`新建`按钮时，游戏会随机选择两个分数进行比较。用户通过点击运算符按钮选择小于(<)、大于(>)或等于(=)。当用户点击`检查`按钮时，游戏会检查答案并提供反馈。打开文件*CompareFractions.sb2*并添加必要的脚本来完成游戏。*Compare
    Fractions.sb2*![image with no caption](httpatomoreillycomsourcenostarchimages2134955.png.jpg)
    |'
