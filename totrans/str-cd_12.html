<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_243"/><span class="big">9</span><br/>PIET</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Piet (pronounced “Pete”) is a visual esolang. It’s a perfect example of what an esolang aims to be: a novel way to embody the process of coding. Piet programs are executable pictures. The language is named after Dutch artist Piet Mondrian (1872–1944) because Piet programs often appear similar to his abstract, rectangular paintings. In Piet, art meets code. People talk about elegance in source code, and Piet takes this idea to an entirely new level.</p>&#13;
<p class="indent">Piet is a stack-based language with a minimal instruction set. In Piet, blocks of the same color represent positive integers, and transitions from one color to another specify the executed instruction. Piet programs are 2D, with code running whichever way is desired: left, right, up, or down.</p>&#13;
<p class="indent">In this chapter, we’ll first walk through the language to understand how to turn a picture into code. Next, we’ll go finger painting and get messy with some example programs. Along the way, we’ll learn how to use the interpreter and its visual tracing abilities.</p>&#13;
<p class="indent">After that, we’ll explore the <code>npiet</code> visual editor to create a simple tribute to Mondrian by turning one of his iconic paintings into code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>Piet’s popularity has created many implementations, associated tools, and even assemblers to generate Piet pictures from more traditional, text-based assembly code. We’ll take a quick look at the Piet universe to point you toward the resources you’ll need if you want to spend more time with Piet. Lastly, as always, we’ll conclude the chapter with a brief discussion.</p>&#13;
<h3 class="h3" id="lev1sec65"><strong>Installation</strong></h3>&#13;
<p class="noindent">Piet’s creator, David Morgan-Mar, has a helpful page at <em><a href="https://www.dangermouse.net/esoteric/piet.html">https://www.dangermouse.net/esoteric/piet.html</a></em>. The page includes background information and an explanation of Piet’s operation. There’s also a nice collection of example programs and a link to third-party tools. Do take a look.</p>&#13;
<p class="indent">To work with Piet, we need an interpreter. We’ll use Erik Schoenfelder’s <code>npiet</code>. It’s written in C and is fast enough for our purposes.</p>&#13;
<p class="indent">To install and build <code>npiet</code>, first go to <em><a href="http://www.bertnase.de/npiet/">http://www.bertnase.de/npiet/</a></em> and download <em>npiet-1.3f.tar.gz</em> (or any later version you see). The site includes a compiled executable for Windows users. The command sequence below, if <code>libgd</code> is available, should be (largely) appropriate for macOS.</p>&#13;
<p class="indent">Once you have <em>npiet-1.3f.tar.gz</em> enter the following commands:</p>&#13;
<pre>&gt; <span class="codestrong1">tar xzf npiet-1.3f.tar.gz</span>&#13;
&gt; <span class="codestrong1">cd npiet-1.3f/</span>&#13;
&gt; <span class="codestrong1">sudo apt-get install libgd-dev</span>&#13;
&gt; <span class="codestrong1">./configure</span>&#13;
&gt; <span class="codestrong1">make</span></pre>&#13;
<p class="noindent">After a few warnings, there should be three executable files in the <em>npiet-1.3f</em> directory: <code>npiet</code>, <code>npietedit</code>, and <code>npiet-foogol</code>. The first is the interpreter. The second is a simple editor we’ll use to make our example programs. The third translates <code>foogol</code> programs into Piet. Foogol is an ALGOL-like language.</p>&#13;
<p class="indent">You may need to install additional packages like <code>groff</code> and <code>tk</code>. If so, this should be close to what you need:</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install groff</span>&#13;
&gt; <span class="codestrong1">sudo apt-get install tk</span></pre>&#13;
<p class="indent">The book’s GitHub repo includes a <em>Piet</em> directory with example programs. I suggest copying <code>npiet</code> to the <em>examples</em> directory, or one level up, to simplify execution.</p>&#13;
<p class="indent">To test <code>npiet</code>, try</p>&#13;
<pre>&gt; <span class="codestrong1">npiet examples/hi.png</span>&#13;
Hi</pre>&#13;
<p class="noindent">If you see our favorite greeting, <code>npiet</code> is working correctly.</p>&#13;
<h3 class="h3" id="lev1sec66"><span epub:type="pagebreak" id="page_245"/><strong>Understanding Piet</strong></h3>&#13;
<p class="noindent">Piet is unlike any of the languages we’ve previously encountered. Of course, we should expect a language using pictures as programs to be unusual. This section seeks to understand Piet, meaning how Piet represents numbers, programs, commands, and program flow. As a language, Piet is relatively simple. There are only 17 commands, four of which are solely for input and output. However, program flow in Piet is more complex than in traditional languages.</p>&#13;
<p class="indent">We’ll begin with colors, as Piet programs are all about colors. Then we’ll learn how to represent numbers and programs. Next, we’ll discuss the command set and the unique way Piet implies commands using transitions between colors. Color transitions lead naturally to program flow.</p>&#13;
<h4 class="h4" id="lev2sec74"><strong><em>Piet Colors</em></strong></h4>&#13;
<p class="noindent">We have a problem at the start. Piet uses color images to represent programs, but this book is printed in grayscale. Therefore, referring to the GitHub examples is essential. That said, we’ll do what we can without color. For instance, <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> presents the specific colors Piet uses as shades of gray along with HTML-style hex codes representing the color. A color version of this chart is in the file <em>piet_colors.png</em>. Lack of color won’t stop us, but be aware that color is critical to Piet and how it functions.</p>&#13;
<div class="image"><img id="ch09fig1" src="Images/09fig01.jpg" alt="Image" width="680" height="173"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Piet color chart</em></p>&#13;
<p class="indent">Our Piet programs use only the colors in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> along with black (<code>#000000</code>) and white (<code>#FFFFFF</code>). Some interpreters treat unknown colors as white, but we’ll restrict ourselves to only approved colors. The hex color codes specify the mix of red, green, and blue that make up the color.</p>&#13;
<h4 class="h4" id="lev2sec75"><strong><em>Representing Numbers</em></strong></h4>&#13;
<p class="noindent">Piet is stack based, like Forth. Numbers are represented as blocks of the same color and the number of pixels in the block specifies the color. Therefore, a 3×5 pixel block represents 3 × 5 = 15, whereas a square with 5 pixel sides is 25. Note that the blocks need not be rectangular or square, but only connected on the edges. A block may even contain holes. If that sounds very abstract, don’t worry. We’ll see examples below.</p>&#13;
<h4 class="h4" id="lev2sec76"><span epub:type="pagebreak" id="page_246"/><strong><em>Representing Programs</em></strong></h4>&#13;
<p class="noindent">Each pixel of the program is significant. However, if we attempt to look at the program at the pixel level, we’ll be hard-pressed to see anything. Therefore, we’ll present programs as magnified images. When images are magnified, each pixel becomes a square of pixels. The square of pixels mapping to the original pixel is called a <em>codel</em>. For example, if the image is magnified by a factor of 10, each pixel becomes a 10×10 square; therefore, the codels are each a 10×10 pixel region.</p>&#13;
<p class="indent">Consider the example program <em>add.png</em>, shown in grayscale in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>.</p>&#13;
<div class="image"><img id="ch09fig2" src="Images/09fig02.jpg" alt="Image" width="679" height="304"/></div>&#13;
<p class="figcap"><em>Figure 9-2: Adding two numbers, 2 + 2 = 4</em></p>&#13;
<p class="indent">The original image is 9 pixels wide and 4 pixels high. The version shown in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> is magnified by 200, so each pixel becomes a 200×200 pixel square, a codel. For this example, I added grid lines to explicitly mark the codel boundaries.</p>&#13;
<p class="indent">Typesetting alters the codel to pixel mapping, but knowing that <em>add.png</em> is 4 pixels high helps us look at <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> and understand the codels. For example, from bottom to top, the leftmost column is two black codels and two light red codels. Piet treats black as a wall, so the two light red codels form a 2×1 rectangle, that is, the number 2. We’ll walk through <em>add.png</em> below. For now, just focus on the mapping between blocks, pixels, and codels.</p>&#13;
<h4 class="h4" id="lev2sec77"><strong><em>Piet Commands</em></strong></h4>&#13;
<p class="noindent">Look again at <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>. Beginning with the upper-left corner and moving to the right transitions the colors from red to yellow to green to cyan to blue, and, wrapping around from the right to the left, back to red. Moving along the rows in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>, we see a change in the hue (that is, the color) without a change in lightness. Each move along the top row of <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> changes a single C0<sub>16</sub> to FF<sub>16</sub> or vice versa. Similarly, for the middle row, values change from 00<sub>16</sub> to FF<sub>16</sub>, and for the bottom row, from 00<sub>16</sub> to C0<sub>16</sub>.</p>&#13;
<p class="indent">Moving up and down the columns changes the lightness of the color while preserving the hue. From top to middle, C0<sub>16</sub> becomes 00<sub>16</sub>, whereas from middle to bottom, FF<sub>16</sub> becomes C0<sub>16</sub>. As with rows, moving from the <span epub:type="pagebreak" id="page_247"/>darkest color in a column to the lightest is also a single transition step. This all means that movement along the color table is cyclic.</p>&#13;
<p class="indent">Why all this concern about hue and lightness? It’s because Piet does not represent commands uniquely. There isn’t a single color that means “push a number” or “add.” Instead, it’s the number of hue or lightness steps taken between regions that specifies the command. The colors themselves do not matter. The color table is cyclic, so it’s possible to move from any initial color to any ending color. This means that any command can be specified from any starting color.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09tab1">Table 9-1</a> lists Piet’s commands according to the hue and lightness change that causes the command to execute. Here, the rows represent a change in hue by that many steps and the columns a similar change in lightness.</p>&#13;
<p class="tabcap" id="ch09tab1"><strong>Table 9-1:</strong> Piet Commands as Specified by Transitions in Hue (Row) and Lightness (Column) Between Blocks</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>0</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>1</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>2</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>0</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">none</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">push</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">pop</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>1</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">+</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>–</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">×</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>2</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">÷</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">mod</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">not</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><strong>3</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">&gt;</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">pointer</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">switch</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><strong>4</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">dup</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">roll</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">inN</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>5</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">inC</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">outN</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">outC</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, to push a number on the stack, the transition between blocks must involve a lightness change of one step but no change in hue. Therefore, any block transition from a particular row of <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> to the row below that keeps the column constant results in a <code>push</code> command. The number pushed on the stack is the number of codels (pixels) in the block just exited. Recall that moving from the darkest to the lightest for any color is also a lightness transition of one.</p>&#13;
<p class="indent">Similarly, to execute an <code>outC</code> instruction to output the top stack item as an ASCII character, the block transition must change lightness by two and hue by five. For example, moving from a block that is light red to one that is dark magenta will execute <code>outC</code>. Likewise, moving from a cyan block to a light green block will also execute <code>outC</code>. Count the hue and lightness changes necessary using <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> to convince yourself that moving from a cyan block to a light green block will indeed specify an <code>outC</code> command.</p>&#13;
<p class="indent">Many of the commands in <a href="ch09.xhtml#ch09tab1">Table 9-1</a> are familiar to us after our investigation of Forth in <a href="ch04.xhtml#ch04">Chapter 4</a>. This is especially true of the math operators, greater-than, and <code>dup</code>, which duplicates the top stack item. Also, <code>push</code> was described in the previous paragraph. Lastly, <code>pop</code> is intuitive: drop the top stack item (this is <code>DROP</code> in Forth).</p>&#13;
<p class="indent">Using Forth-style stack effect comments helps to illuminate this set of Piet commands.</p>&#13;
<span epub:type="pagebreak" id="page_248"/>&#13;
<div class="imagec"><img src="Images/f0248-02.jpg" alt="Image" width="179" height="155"/></div>&#13;
<p class="indent">The input and output commands, <code>inN</code>, <code>inC</code>, <code>outN</code>, and <code>outC</code>, are similarly straightforward. The <code>N</code> versions accept a number or output a number. The <code>C</code> versions accept a character or output the top stack item as an ASCII character. For example, <code>outC</code> prints <code>A</code> if the top stack item is 65—the ASCII code for capital <em>A</em>.</p>&#13;
<p class="indent">The remaining instructions, <code>not</code>, <code>pointer</code>, <code>switch</code>, and <code>roll</code>, need some explanation. The simplest of these is <code>not</code>. In this instruction we pop the top stack item, and push a 1 on the stack if the item is not 0 and push 0 on the stack otherwise. The net effect is to toggle the truth value where 0 is false, and anything else is true, as in C. The <code>npiet</code> interpreter is written in C, so this behavior is natural.</p>&#13;
<p class="indent">The <code>pointer</code> command rotates the direction pointer (DP) clockwise the number of times specified by the top stack item. The <code>switch</code> command pops the stack and toggles the codel chooser (CC) that many times, ignoring the sign. We’ll cover the DP and CC in detail in the next section. For now, just know that <code>pointer</code> affects the DP and <code>switch</code> affects the CC.</p>&#13;
<p class="indent">Piet’s most complex command is <code>roll</code>, which is used to manipulate the stack by rolling a set number of items a given number of times. Let’s look at an example to see what this means.</p>&#13;
<p class="indent">The file <em>roll32.png</em> contains a program that places the numbers 1 through 5 on the stack and sets up a call to <code>roll</code> to rotate the top three items two times. Visually, <em>roll32.png</em> looks like this:</p>&#13;
<div class="imagec"><img src="Images/f0248-01.jpg" alt="Image" width="532" height="169"/></div>&#13;
<p class="indent">The program flows from left to right, column by column, to push 1, then 2, 3, 4, and 5 on the stack. The following two columns push 3 and then 2. The remainder of the code calls <code>roll</code> to rotate the top three stack items two times and dump the stack by repeated calls to <code>outN</code>.</p>&#13;
<p class="indent">Before the call to <code>roll</code>, the stack, from left to right, is</p>&#13;
<p class="equationc"><span epub:type="pagebreak" id="page_249"/><code>1 2 3 4 5 3 2</code></p>&#13;
<p class="indent">The call to <code>roll</code> first pops 2, then 3. The 2 is the number of times to roll the top 3 items. A roll rotates the items so that <code>3 4 5</code> becomes <code>5 3 4</code>. Therefore, two rolls are</p>&#13;
<p class="equationc"><code>3 4 5</code> → <code>5 3 4</code> → <code>4 5 3</code></p>&#13;
<p class="noindent">and the final stack is</p>&#13;
<p class="equationc"><code>1 2 4 5 3</code></p>&#13;
<p class="noindent">The stack being popped from right to left implies that the output of <em>roll32 .png</em> should be <code>35421</code>, as no spaces are printed. Indeed, this is the output, so <code>roll</code> behaves as we think it should.</p>&#13;
<h4 class="h4" id="lev2sec78"><strong><em>Program Flow</em></strong></h4>&#13;
<p class="noindent">Program flow in most languages is straightforward. Unless a branch, goto, or equivalent happens, statements are executed sequentially. Thinking now of low-level machine code, there is a single program counter, something that points to the next instruction. In Piet, program flow is more complex. Flow moves from a block of the same color to the next block, beginning with the top leftmost block. The direction is controlled by the <em>direction pointer (DP</em>). When a Piet program begins, the DP is to the right.</p>&#13;
<p class="indent">At first, we might think we need only a DP; however, there is a minor issue. Piet moves from block to block, but to determine the next block, it needs to know how far to move along which edge of the current block. This introduces the <em>codel chooser (CC)</em>. The CC is initially to the left, but it can also be to the right. Whose left or right? The DP’s left or right. Therefore, when a Piet program begins, the DP is to the right and the CC is to the left, meaning the next block is the one to the topmost right edge of the current block. In fact, it is to the furthest right extent of the block. Thus, Piet selects the next block by going as far as possible in the current block in the direction of the DP and then respecting the current value of CC.</p>&#13;
<p class="indent">For example, consider the image below.</p>&#13;
<div class="imagec"><img src="Images/f0249-01.jpg" alt="Image" width="178" height="178"/></div>&#13;
<p class="noindent">The program is currently in the left block, 2×1 codels, and the DP is pointing to the right. Which block should be considered next? The top or the bottom of the second column? If the CC is to the left, Piet moves to the right from the top of the 2×1 block to select the top block of the right column, which is the darker block. If the CC were to the right, we would choose the lower block instead.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig3">Figure 9-3</a> presents the relationship between the DP and CC in two different ways.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_250"/><img id="ch09fig3" src="Images/09fig03.jpg" alt="Image" width="442" height="324"/></div>&#13;
<p class="figcap"><em>Figure 9-3: The relationship between the direction pointer (DP) and the codel chooser (CC)</em></p>&#13;
<p class="indent">The diagram on the right shows the DP as arrows leading up, down, left, or right, with the CC for each direction marked as <em>L</em> or <em>R</em>. The numbers correspond to the rows of the table on the left of the figure. The table shows DP and CC with arrows. The two complementary presentations should clarify how to use DP and CC to control program flow.</p>&#13;
<p class="indent">Piet moves from colored block to colored block based on DP and CC, but there are two special colors we must also consider: black and white. Black, as stated above, acts like a wall or the edge of the image. When Piet encounters black or an edge, it begins adjusting the DP and CC to try to find an escape, that is, a way out to continue the program. If it can’t find an escape, the program ends. Specifically, Piet uses the following steps to move through the image:</p>&#13;
<ol>&#13;
<li class="noindent">From the current position, move as far as possible in the direction of  the DP until you encounter either a color change or the edge of the  image.</li>&#13;
<li class="noindent">From the position found in Step 1, move as far as possible to the left  or right depending on the CC direction. This selects the first codel  of the next block.</li>&#13;
<li class="noindent">If the steps above encounter a black block or image edge, we toggle  the CC from left to right or right to left and repeat the steps above.  If this process fails, the DP is rotated clockwise and CC toggling  repeats. This process continues until a path is found to a new block  or all moves fail.</li>&#13;
<li class="noindent">If all DP and CC adjustments fail, the program terminates.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>The steps above handle colored blocks, black blocks, and image edges. To further complicate matters, Piet also allows white blocks. White blocks are no-operation blocks called <em>no-ops.</em> The interpreter passes through white blocks like any other block, but the transition does not imply a command. This allows the programmer to change from one colored block to another without executing a command, and, as we’ll see below, the arrangement of black and white blocks can act as a control structure to enforce desired program flow.</p>&#13;
<h3 class="h3" id="lev1sec67"><strong>Piet in Action</strong></h3>&#13;
<p class="noindent">In this section, we’ll get our hands dirty and work through four examples: <em>add.png</em>, <em>hi.png</em>, <em>countdown.png</em>, and <em>random.png</em>. The first prints the sum of 2 + 2; the second, which we saw above, prints <code>Hi</code>; the third is a countdown loop; and the fourth is a simple pseudorandom number generator.</p>&#13;
<h4 class="h4" id="lev2sec79"><strong><em>Proving 2 + 2 = 4</em></strong></h4>&#13;
<p class="noindent">Our first example, <em>add.png</em> has a direct analog in the following Forth code:</p>&#13;
<pre>2 2 + .</pre>&#13;
<p class="noindent">The number 2 is pushed on the stack, followed by another 2, then + pops the top two stack items, adds them, and pushes the sum onto the stack which is then printed as a number. Let’s walk through the execution of <em>add.png</em> to understand how it works.</p>&#13;
<p class="indent">First, run <em>add.png</em> using <code>npiet</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">npiet examples/add.png</span>&#13;
4</pre>&#13;
<p class="indent">If all <code>npiet</code> did was run the program given, we’d be hard-pressed to understand program flow, let alone debug it if necessary. Fortunately for us, <code>npiet</code> can dump an output image and show an execution trace. For example, the following command produces an output file, <em>npiet-trace.png</em>, as shown in <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>.</p>&#13;
<pre>&gt; <span class="codestrong1">npiet -tpic -tpf 80 examples/add.png</span></pre>&#13;
<p class="indent">The <code>-tpic</code> option produces the trace and <code>-tpf 80</code> scales the output so the text is easier to read, at least in the output image file if not on the printed page.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_252"/><img id="ch09fig4" src="Images/09fig04.jpg" alt="Image" width="626" height="471"/></div>&#13;
<p class="figcap"><em>Figure 9-4: Tracing</em> add.png</p>&#13;
<p class="indent">The top part of <a href="ch09.xhtml#ch09fig4">Figure 9-4</a> is <code>npiet</code>’s output in grayscale. The bottom part of the figure traces the program flow to make it easier to follow in the book. The file <em>add.png</em> consists of five blocks, each 2×1 codels, corresponding to the first five circles marked 0 through 4. Recall that Piet commands are specified by hue and lightness transitions, so the commands are printed above the arrows moving from block to block.</p>&#13;
<p class="indent">The Forth code above is duplicated by the Piet code:</p>&#13;
<p class="equationc"><code>push(2)</code> → <code>push(2)</code> → <code>add</code> → <code>outN</code></p>&#13;
<p class="noindent">After <code>outN</code> is a white region, which represents a no-op, so Piet flows through the white area following the flow rules above. First, as DP is to the right, Piet moves to the end of the first part of the block and encounters a black codel. The CC is right, and Piet can’t move further to the right because of the black block, so DP rotates to face downward and moves into the light colored block at the lower right. This block is surrounded by black or the edge of the image. As it moves to the edges of the current block, Piet can find no way out even after rotating DP all the way around, so the interpreter gives up and the program ends.</p>&#13;
<p class="indent">If you look at the <em>npiet-trace.png</em> image <code>npiet</code> created via the <code>-tpic</code> option, you’ll see color and small substeps showing how CC changes as DP changes. Please do look at the trace image, as it is too hard to read the substep indications in <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>.</p>&#13;
<h4 class="h4" id="lev2sec80"><strong><em>Saying Hi</em></strong></h4>&#13;
<p class="noindent">We tested our Piet installation with <em>hi.png</em>. Now let’s walk through the code to learn more about how Piet applies flow control rules to select where to <span epub:type="pagebreak" id="page_253"/>move next. Unlike <em>add.png</em>, <em>hi.png</em> doesn’t use simple blocks, so some thought is required to understand why the Piet interpreter does what it does.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig5">Figure 9-5</a> shows us a trace of <em>hi.png</em> with the program flow below it.</p>&#13;
<div class="image"><img id="ch09fig5" src="Images/09fig05.jpg" alt="Image" width="553" height="1059"/></div>&#13;
<p class="figcap"><em>Figure 9-5: Tracing</em> hi.png</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>In this case, the blocks have irregular shapes, and it might not be obvious why the interpreter selects the path it does. The irregular blocks in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a> have been outlined in white to make them easier to see.</p>&#13;
<p class="indent">The transition from Step 0 to Step 1 is simple enough: Block 0 is a square, the DP begins to the right, and CC is to the left (top), so the only place to go is Block 1. However, the transition from Step 1 to Step 2 isn’t immediately obvious. Inside Block 1 we expect the flow to move to the right along the top edge of the block. Although it is not clearly visible in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>, the top block is black and acts as a barrier. Therefore, according to Piet’s flow rules, CC is toggled to be to the right or bottom of the block as DP is to the right. This alone might imply rotating DP to face down and selecting the large, light-colored irregular block. However, Piet’s flow rules apply to the maximum extent of a block in the direction DP is facing. For Block 1, this means the bottom of the block, as it is furthest to the right and not stopped by the black square at the top. So, Piet moves from Block 1 to the small, light-colored square of Step 2.</p>&#13;
<p class="indent">Flow from Step 2 to Step 10 is straightforward. To go from Step 10 to Step 11, we use the same set of rules as going from Step 1 to Step 2, but this time DP is facing to the left, so we select the leftmost edge of Block 10 and flow moves to Block 12, the terminal block. Block 12 is a trap. DP is to the left and the leftmost part of the block is at the bottom, but once there, Piet will find no way to move to a new block, thereby ending the program.</p>&#13;
<p class="indent">As for the code implied by <em>hi.png</em>, it’s quite simple:</p>&#13;
<pre>push(9)&#13;
push(8)&#13;
mul&#13;
dup&#13;
outC        -- "H"&#13;
push(11)&#13;
push(3)&#13;
mul&#13;
add&#13;
outC        -- "i"&#13;
push(10)&#13;
outC        -- "\n"</pre>&#13;
<p class="noindent">with 9 × 8 = 72, the ASCII code for <em>H</em>, and 72 + 11 × 3 = 105, the code for <em>i</em>, followed by ASCII 10 for the final newline character.</p>&#13;
<h4 class="h4" id="lev2sec81"><strong><em>Countdown</em></strong></h4>&#13;
<p class="noindent">The file <em>countdown.png</em> contains a program to count down from 10 to 1. To make our lives easier, as far as tracing goes, we’ll work with the slightly edited version in <em>countdown3.png</em>, which counts down from 3.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>Running <em>countdown3.png</em> produces the following:</p>&#13;
<pre>&gt; <span class="codestrong1">npiet -tpic -tpf 80 examples/countdown3.png</span>&#13;
3&#13;
2&#13;
1</pre>&#13;
<p class="indent">I admit the output of <em>countdown3.png</em> is not particularly interesting, but this example shows us how to work with loops in Piet, which is. The top part of <a href="ch09.xhtml#ch09fig6">Figure 9-6</a> is a trace of <em>countdown3.png</em>. As printed, it won’t be possible to see the flow properly. So as with <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>, refer instead to the flow diagram at the bottom of <a href="ch09.xhtml#ch09fig6">Figure 9-6</a> and review the file <em>npiet-trace.png</em> that <code>npiet</code> made for us when executing <em>countdown3.png</em>.</p>&#13;
<div class="image"><img id="ch09fig6" src="Images/09fig06.jpg" alt="Image" width="688" height="698"/></div>&#13;
<p class="figcap"><em>Figure 9-6: Tracing</em> countdown3.png</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>We might write <em>countdown3.png</em> as in <a href="ch09.xhtml#ch09list1">Listing 9-1</a>.</p>&#13;
<pre>      push(3)&#13;
<span class="ent">➊</span> loop  dup&#13;
      outN&#13;
    <span class="ent">➋</span> push(5)&#13;
      dup&#13;
      add&#13;
      outC&#13;
    <span class="ent">➌</span> push(1)&#13;
      sub&#13;
      dup&#13;
    <span class="ent">➍</span> push(1)&#13;
      not&#13;
      if (tos &gt; 0) goto loop&#13;
      end</pre>&#13;
<p class="caption" id="ch09list1"><em>Listing 9-1: countdown3.png as text</em></p>&#13;
<p class="indent">The code pushes the limit, 3, onto the stack, and then the loop begins by duplicating the top stack item so it can be printed as a number <span class="ent">➊</span>. The next block of code pushes 10 on the stack and outputs it as a character. For Unix systems, ASCII 10 is newline <span class="ent">➋</span>.</p>&#13;
<p class="indent">The counter value is still on the stack, so it’s decremented by 1 <span class="ent">➌</span>. The final <code>dup</code> in this section of the code sets up for the comparison to see whether the countdown is 0.</p>&#13;
<p class="indent">Piet uses the number of pixels in a block to represent numbers. Therefore, it isn’t possible to directly represent 0 and push it on the stack. However, <span class="ent">➍</span> shows us a useful Piet idiom: get a 0 on the stack by pushing a 1 and calling <code>not</code>. The stack is now set up with two copies of the counter value and a 0. The top two stack items are consumed by <code>&gt;</code>, leaving a 0 or 1 on the stack.</p>&#13;
<p class="indent">Here’s where things get interesting. Piet has no explicit branch instruction, that is, no direct analog of the <code>if</code> statement shown in <a href="ch09.xhtml#ch09list1">Listing 9-1</a>. Instead, Piet uses the <code>pointer</code> instruction to rotate the DP, which at this point in <em>countdown3.png</em> is facing left. The <code>pointer</code> instruction uses the top stack value to rotate DP clockwise by that many steps. The result from <code>&gt;</code> is a 0 or 1. If 1, it means that the counter value is greater than 0, so we want the loop to continue. In that case, <code>pointer</code> will rotate DP one position clockwise so that it is now facing up. Moving directly up from this part of <em>countdown3.png</em> puts us right at the beginning of the loop, <span class="ent">➊</span> in <a href="ch09.xhtml#ch09list1">Listing 9-1</a>. The direction pointer is facing up, but there is nowhere to go, so Piet, following the flow rules, rotates DP clockwise, so it is now facing right, and the loop continues.</p>&#13;
<p class="indent">If <code>&gt;</code> leaves 0 on the stack, the DP is unaffected by <code>pointer</code>, and flow continues to the left, ultimately landing in the trap where Piet is unable to find an exit, so the program ends.</p>&#13;
<h4 class="h4" id="lev2sec82"><span epub:type="pagebreak" id="page_257"/><strong><em>A Pseudorandom Number Generator</em></strong></h4>&#13;
<p class="noindent">The final example in this section is <em>random.png</em>, a simple pseudorandom number generator. The program implements a <em>linear congruential</em> pseudorandom number generator, which is a simple way to generate a sequence of integers that appears random. We’ll work with this type of generator again in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>&#13;
<p class="indent">The generator itself is the single equation</p>&#13;
<p class="equationc"><em>s</em><sub><em>i</em>+1</sub> ← <em>a</em><em>s</em><em><sub>i</sub></em> mod <em>m</em></p>&#13;
<p class="noindent">for some initial seed value, <em>s</em><sub>0</sub>. Both <em>a</em> and <em>m</em> are integer constants. If <em>a</em> and <em>m</em> are properly selected, then the sequence of <em>s</em><sub><em>i</em></sub> values generated by taking the output and using it as the new input will pass statistical tests for randomness, or so we hope.</p>&#13;
<p class="indent">We can break the equation down into steps: first, multiply the current seed value (<em>s</em><sub><em>i</em></sub>) by the multiplier, <em>a</em>. Then, calculate the remainder when dividing that product by <em>m</em> and set that as the new seed value (<em>s</em><sub><em>i</em>+1</sub>). The modulo operation (mod) gives the remainder and, fortunately for us, is one of the math operations Piet supports.</p>&#13;
<p class="indent">Of course, we need to select <em>a</em> and <em>m</em>. Good values are large, but we don’t want to work with large integers, as they correspond to large uniform blocks in the program image. Linear congruential generators have been studied for decades, and many sets of constants have been found. We’ll use <em>a</em> = 209 and <em>m</em> = 2<sup>12</sup> <em>–</em> 3 = 4093 because they are small values.</p>&#13;
<p class="indent">Okay, we now need a program to take an initial seed value, apply the equation, output the new seed value, and repeat. Piet’s stack will hold the current seed value. The initial seed value will be pushed onto the stack, after which we’ll calculate the new seed, print it, and leave it on the stack for the next pass through the loop. We’ll want to capture the sequence of integers, so we’ll loop forever and use CTRL-C to stop the program when we’ve generated all the numbers we care to output.</p>&#13;
<p class="indent">In text, we might write the program as</p>&#13;
<pre>      push(1)&#13;
loop  push(209)&#13;
      mul&#13;
      push(4093)&#13;
      mod&#13;
      dup&#13;
      outN&#13;
      push(10)&#13;
      outC&#13;
      goto loop</pre>&#13;
<p class="indent">where <code>goto loop</code> will be achieved by arranging a sequence of white and black regions to force program flow back to the top of the loop.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>We could make an image like the program, but notice the <code>push(4093)</code>. That’s a rather large block by Piet standards, so let’s replace both <code>push(209)</code> and <code>push(4093)</code> with a set of calculations that end with the proper number on the stack. For example, <code>push(209)</code> is the same as</p>&#13;
<pre>push(10), dup, mul, push(2), mul, push(9), add</pre>&#13;
<p class="noindent">and <code>push(4093)</code> is</p>&#13;
<pre>push(10), dup, dup, mul, mul, push(4),&#13;
mul, push(10), push(9), mul, push(3), &#13;
add, add</pre>&#13;
<p class="indent">It’s not pretty as text, but it is easy to implement as a picture. <a href="ch09.xhtml#ch09fig7">Figure 9-7</a> shows the resulting program (see <em>random.png</em>). The program flow is below, where adjacent labeled circles are connected in a clockwise direction.</p>&#13;
<div class="image"><img id="ch09fig7" src="Images/09fig07.jpg" alt="Image" width="680" height="270"/></div>&#13;
<p class="figcap"><em>Figure 9-7: Tracing</em> random.png</p>&#13;
<p class="indent">The transition from Step 0 to Step 1 pushes the initial seed (1) on the stack. Steps 2 through Step 24 generate the next seed value and display it as an integer. Steps 25 through 27 print the newline. The white region causes the program to flow back to Step 2 to generate the next seed. The loop runs until we press CTRL-C to quit the interpreter.</p>&#13;
<p class="indent">Let’s run <em>random.png</em> and capture the output so we can analyze it.</p>&#13;
<pre>&gt; <span class="codestrong1">npiet examples/random.png &gt;examples/random.txt</span></pre>&#13;
<p class="indent">Let the code run for 10 to 20 seconds and then stop it with CTRL-C. My run produced 2,333,347 values, which is quite sufficient for our purposes.</p>&#13;
<p class="indent">The sequence begins with the following numbers:</p>&#13;
<pre>209&#13;
2751&#13;
1939&#13;
44<span epub:type="pagebreak" id="page_259"/>&#13;
1010&#13;
2347</pre>&#13;
<p class="noindent">This seems “random,” but how can we know? Of course, we know the sequence cannot possibly be random, as it was generated deterministically. However, suppose we didn’t know that. In that case, we could perform tests to help us decide if the sequence is or isn’t worth calling “random.” The entire point of developing high-quality pseudorandom number generators is to create deterministic sequences that pass all known randomness tests.</p>&#13;
<p class="indent">Before we can apply randomness tests, we must convert the text file of integers into a binary file of double-precision floating-point numbers in the range [0,1), meaning from 0 up to, but not including, 1. For that, we’ll use <em>random_double.py</em>.</p>&#13;
<pre>import struct&#13;
v = [float(i[:-1])/4093.0 for i in open("random.txt")]&#13;
s = struct.pack('d'*len(v), *v)&#13;
with open("random.dat","wb") as f:&#13;
    f.write(s)</pre>&#13;
<p class="noindent">Here, <em>random_double.py</em> produces <em>random.dat</em> from <em>random.txt</em> by dividing each value by 4,093, which is one more than the largest possible integer the generator outputs.</p>&#13;
<p class="indent">One way to check for randomness is to build a <em>histogram</em>. A histogram partitions the range of possible integers—in this case, [1,4092]—into several equal-sized bins, say 10. Then we locate the bin each number falls into and increment the count for the bin. When all the random values have been tallied, the histogram shows us how many have fallen into each bin. If we divide the count per bin by the number of values tallied, which in this case is 2,333,347, the counts become frequencies telling us the fraction of numbers we can expect in each bin. If we want, we can interpret the frequencies as the probability a random value will land in that bin.</p>&#13;
<p class="indent">If the values are randomly distributed, each bin is equally likely, so we expect the fraction in each bin to be roughly the same. So, for example, if we have 10 bins, we expect about 10 percent of the values to fall into each of them.</p>&#13;
<p class="indent">To perform the tallies, we need a bit of Python code and access to the NumPy library. The actual code is in the file <em>random_histogram.py</em>, but you need not install NumPy to run it. The histogram gives us the following:</p>&#13;
<pre>10.019,9.996,9.996,9.995,9.995,9.996,9.995,9.995,9.995,10.019</pre>&#13;
<p class="noindent">Here I’ve rounded the percentages to three decimals. The first number tells us the percent of samples in the range [0,0<em>.</em>1), the second the percent in [0<em>.</em>1,0<em>.</em>2), and so on. The percentages are virtually identical. So that’s a good sign that <em>random.png</em> is giving us well-distributed values.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>Does that mean <em>random.png</em> is a good pseudorandom number generator? Not quite. If <em>random.png</em> were generating 1, 2, 3, 4, and so on modulo 4093, we’d still get the histogram above with enough samples. To be a good pseudorandom generator, the <em>i</em>th value and the <em>i</em> + 1th value must not be correlated. In other words, there should be no easy way to predict the next value generated from the previous.</p>&#13;
<p class="indent">To check if there is a correlation between one value and the next, we can use the code in <em>corr_test.c</em>. This program reads <em>random.dat</em> and calculates the <em>correlation coefficient</em>, a single number. If the values are not correlated one to the next, the correlation coefficient will be very close to 0 to indicate there is no relationship between them.</p>&#13;
<p class="indent">Compile <em>corr_test.c</em> using the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">gcc corr_test.c -o corr_test -lm</span></pre>&#13;
<p class="noindent">Then run it on <em>random.dat</em>.</p>&#13;
<pre>&gt; <span class="codestrong1">corr_test 3 random.dat</span>&#13;
corr = 0.00047 (n=2333347), expected 95% CI=[-0.00131, 0.00131], &#13;
       test PASSED</pre>&#13;
<p class="noindent">The <code>3</code> in the command line tells <code>corr_test</code> that <em>random.dat</em> is a binary file of double precision floating-point values.</p>&#13;
<p class="indent">The output has the word <code>PASSED</code> in it, in all caps to boot. So <em>corr_test</em> believes <em>random.dat</em> is not correlated. The correlation coefficient is close to 0. The <code>CI</code> part of the output is a <em>confidence interval</em>. We can read the confidence interval as meaning there’s a 95 percent chance the true correlation coefficient is between the given limits. Notice that the range includes 0, another good sign.</p>&#13;
<p class="indent">Therefore, <em>random.png</em> is a good pseudorandom generator, right? Still, not quite. We only checked for correlations between one value and the next. There might be correlations between a value and some other, later value. You begin to see the issue with testing pseudorandom generators. Real generators are tested against large test suites that include many different kinds of tests, all of which only the best pseudorandom generators pass.</p>&#13;
<p class="indent">We’ll do one more straightforward test of the output in <em>random.dat</em>. Let’s take successive pairs of values and plot them as a point. Then, we’ll look at the resulting plot to see if any pattern jumps out at us. For example, the first two values in <em>random.dat</em> are 0.05106279 and 0.67212314. So we’ll plot a point at (0.05106279, 0.67212314), then do the same for the next pair. We’ll stop after plotting 1,000 points to avoid cluttering the plot.</p>&#13;
<p class="indent">Take a look at <a href="ch09.xhtml#ch09fig8">Figure 9-8</a>. Does anything jump out at you?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_261"/><img id="ch09fig8" src="Images/09fig08.jpg" alt="Image" width="530" height="410"/></div>&#13;
<p class="figcap"><em>Figure 9-8: Plotting pairs of pseudorandom values</em></p>&#13;
<p class="indent">The points often lie along a diagonal from upper left to lower right. This is a strong indication of longer-range correlations in the sequence. At last we can now make a statement about the output of <em>random.dat</em>: it’s a lousy pseudorandom generator. However, it does fill the space. There are no obvious regions in <a href="ch09.xhtml#ch09fig8">Figure 9-8</a> where there are no points. So the output of <em>random.png</em> is sufficient for a simple video game, but don’t make policy decisions related to climate change based on simulations using it.</p>&#13;
<p class="indent">Pseudorandom number generation will show up again later in the book. For now, let’s return to Piet’s artistic roots and create a small tribute to Piet Mondrian.</p>&#13;
<h3 class="h3" id="lev1sec68"><strong>A Tribute to Piet Mondrian</strong></h3>&#13;
<p class="noindent">Piet Mondrian was an important member of a group of Dutch artists and architects who developed what has come to be known as the <em>De Stijl</em> movement. De Stijl, literally “the style,” uses abstract forms with basic elements. One of Mondrian’s most widely recognized works is his unexpectedly satisfying <em>Composition II in Red, Blue, and Yellow</em>. The painting is an excellent example of the De Stijl movement. As a tribute to Mondrian, let’s make an executable copy of <em>Composition II</em>. In the process, we’ll learn how to use <code>npiet</code>’s editor, <code>npietedit</code>.</p>&#13;
<p class="indent">Duplicating the original painting with a modern graphics program is straightforward. <a href="ch09.xhtml#ch09fig9">Figure 9-9</a> shows the result.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_262"/><img id="ch09fig9" src="Images/09fig09.jpg" alt="Image" width="444" height="457"/></div>&#13;
<p class="figcap"><em>Figure 9-9: A re-creation of Mondrian’s</em> Composition II</p>&#13;
<p class="indent">The largest block is red, the smaller block on the left is blue, and the smallest block on the right is yellow. The remainder of the painting is black and white.</p>&#13;
<p class="indent">The original painting is signed on the lower left with <em>P M 30</em> for Piet Mondrian, 1930. We’ll make the copy executable by embedding a simple program to output <code>PM30</code> in place of the signature. The code that we need isn’t particularly challenging, but it is helpful as an exercise in learning to use <code>npietedit</code>.</p>&#13;
<p class="indent">One of the immediate challenges in writing code for Piet is working with colors and transitions to get the desired commands. Although we might work with pencil and paper, counting from color to new color to get the correct number of hue and lightness changes to cause the desired command to execute, we need not be so primitive. Instead, the clever <code>npietedit</code> program lets us color the program image as needed while also calculating the proper color transitions.</p>&#13;
<p class="indent">To output <code>PM30</code>, we need to push the ASCII values for each character on the stack before calling <code>outC</code>. We’ll add a final newline as well to put <code>PM30</code> on its own line. Therefore, we need a program to output five characters. However, we must embed the program in the larger <em>Composition II</em> image in a way that isn’t too conspicuous. Fortunately for us, the way Piet runs and the <span epub:type="pagebreak" id="page_263"/>structure of <em>Composition II</em> match nicely. For example, Piet begins in the upper leftmost pixel of the image with the DP to the right and CC to the left. As that portion of the image is white, Piet will run across to the first black pixel, the beginning of the large vertical black bar. We’ll embed our code in this bar, knowing Piet will find it. Additionally, we’ll orient the program vertically, with DP moving down.</p>&#13;
<p class="indent">Of course, we must have a program to embed, so let’s use <code>npietedit</code> to create it. Launch <code>npietedit</code> with no arguments.</p>&#13;
<pre>&gt; <span class="codestrong1">npietedit</span></pre>&#13;
<p class="indent">The interface is in <a href="ch09.xhtml#ch09fig10">Figure 9-10</a>.</p>&#13;
<div class="image"><img id="ch09fig10" src="Images/09fig10.jpg" alt="Image" width="649" height="411"/></div>&#13;
<p class="figcap"><em>Figure 9-10: The</em> <span class="codeitalic1">npietedit</span> <em>editor</em></p>&#13;
<p class="indent">The interface consists of a color selector, a command selector, and a drawing area showing individual pixels. Select a color and click in the drawing area to set that pixel. The command selector is the most valuable part of the editor. For example, to push the number 5 on the stack, select any desired color, say light red, the top leftmost color. Then, fill in five pixels to make a block, say five rows tall and one column wide. Then, as DP will be to the right, select the topmost pixel of the block and then select <strong>Push</strong>. The editor, knowing the current color is light red, switches the color to red, one lightness level darker.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>Changing the lightness by 1 is how Piet specifies <code>push</code>, so this is the correct color. Click the top pixel to the immediate right of the light red block to place a single red pixel. Given how DP is pointed, Piet will correctly push 5 on the stack. In this way, it is possible to draw any sequence of commands, with a little practice and attention paid to selecting the proper color before clicking the command to arrive at the necessary hue and lightness change.</p>&#13;
<p class="indent">Use the buttons at the top of the interface to control <code>npietedit</code>. They are largely self explanatory. However, Save and Load will not bring up the usual file selection dialog. Instead, they write and read a fixed filename, <code>npietedit-filename.ppm</code>. So, use Save to dump the drawing and then rename <code>npietedit-filename.ppm</code> to something else to preserve the program. Likewise, copy a saved version of a program to the same filename to then load it into <code>npietedit</code>. The <em>.ppm</em> file format is a portable pixmap image. The <code>npiet</code> interpreter will use these files as they are. Most graphics programs will load and display portable pixmap images as well. If you wish to change to another filetype, use something like <code>gimp</code> or <code>convert</code>, a command line tool that is part of ImageMagick (<em><a href="https://imagemagick.org/index.php">https://imagemagick.org/index.php</a></em>). ImageMagick is included in the base Ubuntu installation.</p>&#13;
<p class="indent">Our program needs to push ASCII values on the stack and then call <code>outC</code>. The Forth equivalent of this is as follows:</p>&#13;
<pre>8 10 * emit 11 7 * emit 10 5 * 1 + emit 6 8 * emit 5 5 + emit</pre>&#13;
<p class="noindent">The Forth word <code>emit</code> has the same effect as Piet’s <code>outC</code> command, and multiplication of smaller numbers is used to prevent large blocks of one color.</p>&#13;
<p class="indent">Let’s translate the Forth code into Piet using <code>npietedit</code>. The only twist is that we want the code to run vertically so we can embed it in the black part of the larger <em>Composition II</em> image. To do this, we must rotate DP downward from the right. This is easily done by a white region with a 90-degree turn.</p>&#13;
<p class="indent">The file <em>composition.ppm</em> contains the necessary Piet code as a direct translation of the Forth above. If you run it, you’ll see that it produces the desired output.</p>&#13;
<pre>&gt; <span class="codestrong1">npiet examples/composition.ppm</span>&#13;
PM30</pre>&#13;
<p class="indent">To see the code in <code>npietedit</code>, copy <em>composition.ppm</em> to <em>npietedit-filename.ppm</em> in the same directory as <code>npietedit</code>, launch the editor, and click <strong>Load</strong>. The result is <a href="ch09.xhtml#ch09fig11">Figure 9-11</a>. The code runs from top to bottom.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_265"/><img id="ch09fig11" src="Images/09fig11.jpg" alt="Image" width="371" height="886"/></div>&#13;
<p class="figcap"><em>Figure 9-11: Code to output <span class="codeitalic1">PM30</span></em></p>&#13;
<p class="indent">We’re almost finished with our tribute. All that remains is to embed <em>composition.ppm</em> in the redrawn <em>Composition II</em>, which is in the file <em>mondrian</em> <em>.png</em>. To do the embedding, I use <code>gimp</code> to load both images, select the actual image portion of <em>composition.ppm</em>, copy it, and paste it into <em>mondrian.png</em>, moving it over to the central vertical black region.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_266"/>The Piet interpreter will pass over the white region on the upper left, so we need to add a single white pixel after positioning the code so that the vertical bar is now</p>&#13;
<div class="imagec"><img src="Images/f0266-01.jpg" alt="Image" width="295" height="322"/></div>&#13;
<p class="noindent">with arrows showing how DP changes direction to execute the code vertically.</p>&#13;
<p class="indent">The resulting combined image is in <em>compositionII_pm30.png</em>. If you run it with <code>npiet</code>, you get the expected <code>PM30</code> output. Take a look at the image itself. It looks like <em>Composition II</em> with a splash of color toward the top.</p>&#13;
<h3 class="h3" id="lev1sec69"><strong>The Piet Universe</strong></h3>&#13;
<p class="noindent">A successful esolang engenders a following. People use it, share it, modify it, build tools for it, and create websites about it. By this measure, Piet is successful. What follows are links to excellent Piet code examples, tools, and generally anything else worth noting about Piet. The list is by no means exhaustive, and worthy entries have doubtless been missed.</p>&#13;
<h4 class="h4" id="lev2sec83"><strong><em>About Piet</em></strong></h4>&#13;
<p class="noindent">Piet has generated a collection of blog posts and many online discussions. The short list here explores more about the language itself and includes some interesting (unusual) Piet experiments.</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Main Piet site</strong>  The main Piet page by creator David Morgan-Mar. Start here to learn more about the language. (<em><a href="https://www.dangermouse.net/esoteric/piet.html">https://www.dangermouse.net/esoteric/piet.html</a></em>)</p>&#13;
<p class="noindent"><strong>Piet tutorial</strong>  This is a nice, basic tutorial to programming in Piet and works well as an adjunct to what we’ve discussed in this chapter. (<em><a href="https://www.youtube.com/watch?v=4kH4T8uwHMw/">https://www.youtube.com/watch?v=4kH4T8uwHMw/</a></em>)</p>&#13;
<p class="noindent"><strong>Piet in the literature</strong>  Piet is an example in this paper about code visualization. Alex McLean’s dissertation is also online and similarly mentions Piet. See “Visualisation of live code," Electronic Visualisation and the Arts (EVA 2010), 26–30.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_267"/><strong>Running classic paintings as Piet programs</strong>  This is an experiment in mixing Piet and classic works of art. Piet fans are nothing if not creative. (<em><a href="http://omnigatherum.ca/wp/?p=57/">http://omnigatherum.ca/wp/?p=57/</a></em>)</p>&#13;
<p class="noindent"><strong>Piet meets poetry</strong>  An experiment with Piet and poetry. The final product, <em>bark.png</em>, generates a haiku. (<em><a href="http://theorangeduck.com/page/making-poetry-piet/">http://theorangeduck.com/page/making-poetry-piet/</a></em>)</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec84"><strong><em>Code</em></strong></h4>&#13;
<p class="noindent">The best way to learn a language is to review examples in that language. Therefore, should Piet draw you further in, the examples here will help you improve your Piet prowess.</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Main Piet examples page</strong>  The best place for Piet examples is off the main Piet site. Not all of these examples work with <code>npiet</code>, but most do. The works of the great masters are here; check them out. (<em><a href="https://www.dangermouse.net/esoteric/piet/samples.html">https://www.dangermouse.net/esoteric/piet/samples.html</a></em>)</p>&#13;
<p class="noindent"><strong>FizzBuzz</strong>  Historically, a common programming interview question was to write code to generate the numbers from 1 to 100 but replace multiples of 3 with “Fizz,” multiples of 5 with “Buzz,” and multiples of 3 and 5 with “FizzBuzz.” FizzBuzz is a simple program and therefore a favorite target for esolangs. A Piet version of FizzBuzz is at <em><a href="http://www.toothycat.net/~sham/fizzbuzz.png">http://www.toothycat.net/~sham/fizzbuzz.png</a></em>, and, should you feel like diving into far too much detail about FizzBuzz, you can read Tom Dalling’s blog post at <em><a href="https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/">https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/</a></em>.</p>&#13;
<p class="noindent"><strong>Tic-tac-toe</strong>  A fully interactive, unbeatable Piet version of tic-tac-toe (naughts and crosses) is worth a bit of your time. (<em><a href="https://freesoft.dev/program/9705871/">https://freesoft.dev/program/9705871/</a></em>)</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec85"><strong><em>Implementations and Tools</em></strong></h4>&#13;
<p class="noindent">Computer people love to build things. The description of Piet on the main page mentioned earlier is begging to be written up in some language or another. The implementations here are in many different languages, like C++, Python, Rust, and even Haskell. Not every implementation can run every example program, but most perform reasonably well.</p>&#13;
<div class="bq5">&#13;
<p class="noindent">A Python interpreter, <em><a href="https://www.dangermouse.net/esoteric/piet/Piet_py.txt">https://www.dangermouse.net/esoteric/piet/Piet_py.txt</a></em></p>&#13;
<p class="noindent">Another Python interpreter, <em><a href="https://github.com/JensBouman/Piet_interpreter/">https://github.com/JensBouman/Piet_interpreter/</a></em></p>&#13;
<p class="noindent">An interpreter in Haskell, <em><a href="https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html">https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html</a></em></p>&#13;
<p class="noindent">An interpreter in C++, <em><a href="https://www.matthias-ernst.eu/fpiet.html">https://www.matthias-ernst.eu/fpiet.html</a></em></p>&#13;
<p class="noindent">An interpreter in Rust, <em><a href="https://github.com/dfockler/rustpiet/">https://github.com/dfockler/rustpiet/</a></em></p>&#13;
<p class="noindent">A browser-based interpreter and IDE in TypeScript, <em><a href="https://gitlab.hsrw.eu/thomas.richter/piet-ide/">https://gitlab.hsrw.eu/thomas.richter/piet-ide/</a></em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>Several projects have gone the other way to produce assemblers or compilers from a text-based language to Piet. That is, the output is an image implementing the program in Piet. Again, computer people are a creative bunch.</p>&#13;
<div class="bq5">&#13;
<p class="noindent">GitHub repositories devoted to Piet, <em><a href="https://github.com/topics/piet/">https://github.com/topics/piet/</a></em></p>&#13;
<p class="noindent">An assembler and compiler producing Piet code, <em><a href="https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/">https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/</a></em></p>&#13;
<p class="noindent">The PietC compiler, which produces Piet code as output, <em><a href="https://github.com/cjayross/pietc/">https://github.com/cjayross/pietc/</a></em></p>&#13;
<p class="noindent">Another assembler generating Piet output, <em><a href="https://github.com/sl236/Piet/">https://github.com/sl236/Piet/</a></em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec70"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Piet is a procedural language with arbitrary-sized programs. There are no variables, but the stack is unlimited. So we might suspect that Piet is Turing complete. In fact, Piet is definitely Turing complete because a clever individual has written a Brainfuck (BF) interpreter in Piet and BF is known to be Turing complete as we’ll see next in <a href="ch10.xhtml#ch10">Chapter 10</a>. The BF interpreter (<em><a href="https://lutter.cc/piet/">https://lutter.cc/piet/</a></em>) is worth a look, perhaps after reading <a href="ch10.xhtml#ch10">Chapter 10</a>. To test it, don’t forget to add a pipe (<code>|</code>) at the end of the BF code even if the code itself does not accept any input. I tried it with “Hello, world!” and <code>npiet</code> and it works. Don’t forget to add the <code>-q</code> command line option to suppress the input prompt.</p>&#13;
<p class="indent">Okay, Piet is a Turing complete language. What else can we say about it? Programming in Piet is quite a challenge, perhaps because it is so alien to standard text-based programming or even standard visual programming languages that ty the drag-and-drop of components.</p>&#13;
<p class="indent">I find it fascinating that loops in Piet are, literally, loops—the image structure itself controls the flow of the program, so a loop really does find its way back to the starting point. For example, the loop in <em>random.png</em> is implemented by a long white block along the bottom of the program image followed by a 90-degree turn to force DP to point in the right direction to encounter the beginning of the loop. Also, Piet’s flow control rules make it such that the DP will rotate again to the right to be pointing in the proper direction to repeat the loop endlessly, all without a single bit of standard syntax. In a way, Piet has no syntax, just flow rules; the image itself becomes the syntax. In that sense, Piet programs are not unique, as multiple, nearly infinite, ways to draw the required flow exist.</p>&#13;
<p class="indent">Piet’s method for implying commands using hue and lightness changes, as opposed to assigning specific colors to the commands, is equally clever and again magnifies the number of possible Piet programs considerably. Even if we choose the same layout, sequence of blocks, and image size, we get many options simply by selecting a different starting color. Piet’s instruction set is small, so learning the necessary transitions for each command isn’t too difficult. If you experiment with Piet for any length of time, you’ll <span epub:type="pagebreak" id="page_269"/>begin to pick up on these transitions. For example, changing lightness by 1 is <code>push</code>, which is a command you’ll learn quickly.</p>&#13;
<p class="indent">It’s also interesting that Piet separates block size and commands. For example, if we want to execute <code>push(4)</code> and know that the next instruction is <code>push(3)</code>, we might make the first block 2×2 pixels, say light red, and make the second block three vertical pixels of red. The transition from light red to red implies <code>push</code> with the argument, 4, from the size of the light red block. The push command does not care about the size of the new block, only that it is red, one lightness level darker. The fact that the new block is of size 3 is useful to push 3 when transitioning to the next block, which must be dark red, so we combine a number with a color transition, thereby making the code more compact. Of course, color transitions are commands, so it might sometimes be necessary to use a white block to change color without executing a command.</p>&#13;
<p class="indent">In the end, Piet is a fun esolang and an excellent example of a novel way to think about coding. Some forethought is necessary when designing a program, as it isn’t easy, even with tools like <code>npietedit</code>, to suddenly add new code by moving an existing block to make room, but editors capable of such actions are certainly possible.</p>&#13;
<p class="indent">Piet is Turing complete, but extensions to the language might be of interest. For example, the ability to access the stack as an array adds variables. Also, some kind of subroutine ability would make coding easier. All of these are exercises for the ambitious reader.</p>&#13;
<h3 class="h3" id="lev1sec71"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter introduced us to Piet, the language where pictures are programs. First, we walked through the elements of the language to understand how it works and how to code with colors. Next, we went finger painting and got messy learning how specific programs worked, step by step. This led us to a simple tribute to Piet Mondrian, whose style and name inspired Piet’s creation. Piet has grown in popularity, at least as far as esolangs go, to the point where many program examples, implementations, and ancillary tools are now available. We cataloged several of them should you wish to explore further. Then, as always, we ended the chapter with some thoughts on the language and its capabilities.</p>&#13;
<p class="indent">Our next esolang is perhaps the best known of all. We’re simply calling it <em>BF</em>. If Piet is a local celebrity, BF is a superstar.<span epub:type="pagebreak" id="page_270"/></p>&#13;
</div></body></html>