- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll acquire background knowledge of WebAssembly and explore
    the tools you’ll need to start working with WebAssembly and its textual representation,
    WebAssembly Text (WAT). We’ll discuss the benefits of WebAssembly, including improved
    performance, legacy library integration, portability, security, and its use as
    an alternative to JavaScript. We’ll consider JavaScript’s relationship with WebAssembly
    and what WebAssembly is and isn’t. You’ll learn the WAT inline and S-expression
    syntax. We’ll introduce the concepts of the embedding environment and discuss
    embedding WebAssembly in web browsers, Node.js, and the WebAssembly System Interface
    (WASI).
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll discuss the benefits of using Visual Studio Code as a development
    environment for WAT. You’ll learn the basics of Node.js and how to use it as an
    embedding environment for WebAssembly. We’ll show you how to use npm to install
    the wat-wasm tool, which provides you with everything you need to build WebAssembly
    applications from WAT. In addition, we’ll write our first WebAssembly app and
    execute it with Node.js as the embedding environment.
  prefs: []
  type: TYPE_NORMAL
- en: What Is WebAssembly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebAssembly is a technology that will massively improve the performance of web
    applications over the next several years. Because WebAssembly is new and requires
    some explanation, many people misunderstand it and how to use it. This book teaches
    you what WebAssembly is and how to use it to make high-performing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*WebAssembly* is a virtual *Instruction Set Architecture (ISA)* for a stack
    machine. Generally, an ISA is a binary format designed to execute on a specific
    machine. However, WebAssembly is designed to run on a *virtual* machine, meaning
    it’s not designed for physical hardware. The virtual machine allows WebAssembly
    to run on a variety of computer hardware and digital devices. The WebAssembly
    ISA was designed to be compact, portable, and secure, with small binary files
    to reduce download times when deployed as part of a web application. It’s easy
    to port the bytecode to a variety of computer hardware, and it has a secure platform
    for deploying code over the web.'
  prefs: []
  type: TYPE_NORMAL
- en: All major browser vendors have adopted WebAssembly. According to the Mozilla
    Foundation, WebAssembly code runs between 10 percent and 800 percent faster than
    the equivalent JavaScript code. One eBay WebAssembly project executed 50 times
    faster than the original JavaScript version. Later in the book we’ll build a collision
    detection program that we can use to measure performance. When we ran it, our
    performance benchmarking found that our WebAssembly collision detection code ran
    more than four times faster than JavaScript in Chrome and more than two times
    faster than JavaScript in Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly offers the most significant performance improvement the web has
    seen since the introduction of the just-in-time (JIT) JavaScript compilers. Modern
    browser JavaScript engines can parse and download the WebAssembly binary format
    an order of magnitude faster than JavaScript. The fact that WebAssembly is a binary
    target, not a programming language like JavaScript, allows the developer to choose
    the programming language that best suits their application’s needs. The saying
    “JavaScript is the assembly language of the web” might have become fashionable
    recently, but the JavaScript format is a terrible compilation target. Not only
    is JavaScript less efficient than a binary format like WebAssembly, but any JavaScript
    target code also has to handle the specifics of the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly offers tremendous web application performance improvements in two
    areas. One is startup speed. Currently, the most compact JavaScript format is
    minified JavaScript, which improves application download sizes but must parse,
    interpret, JIT compile, and optimize the JavaScript code. These steps are unnecessary
    with a WebAssembly binary, which is also more compact. WebAssembly still needs
    to be parsed, but it’s faster because it’s a bytecode format rather than text.
    Web engines still do optimization passes on WebAssembly, but it’s much faster
    because the language is more cleanly designed.
  prefs: []
  type: TYPE_NORMAL
- en: The other significant performance improvement WebAssembly offers is in throughput.
    WebAssembly makes it easier for the browser engine to optimize. JavaScript is
    a highly dynamic and flexible programming language, which is helpful to a JavaScript
    developer, but creates a code optimization nightmare. WebAssembly doesn’t make
    any web-specific assumptions (despite its name) and can be used beyond the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, WebAssembly might be able to do everything JavaScript can. Unfortunately,
    the current version, its MVP (Minimum Viable Product) release version 1.0, cannot.
    In the MVP release, WebAssembly can do certain tasks very well. It’s not intended
    to be a drop-in replacement for JavaScript or a framework, such as Angular, React,
    or Vue. If you want to work with WebAssembly right now, you should have a specific
    computationally intensive project that requires very high performance. Online
    games, WebVR, 3D math, and crypto are effective ways people currently use WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons to Use WebAssembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we take a closer look at WebAssembly, let’s consider a few reasons you
    might be interested in using it. These explanations should also give you an idea
    of what WebAssembly is and why and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Better Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript requires software engineers to make choices that will affect how
    they design the JavaScript engine. For example, you can optimize a JavaScript
    engine for peak performance using a JIT optimizing compiler, which can execute
    code faster but requires more startup time. Alternatively, you can use an interpreter,
    which starts running code right away but won’t reach the peak performance of a
    JIT optimizing compiler. The solution most JavaScript engine designers use in
    their web browsers is to implement both, but that requires a much larger memory
    footprint. Every decision you make is a trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly allows for a faster startup time and higher peak performance without
    all of the memory bloat. Unfortunately, you can’t just rewrite your JavaScript
    in AssemblyScript, Rust, or C++ and expect this to happen without a little extra
    work. WebAssembly isn’t magic, and merely porting JavaScript to another language
    and compiling it without understanding what WebAssembly is doing at a lower level
    can lead to some disappointing results. Writing C++ code and compiling it to WebAssembly
    using optimization flags will usually be a bit faster than JavaScript. Occasionally,
    programmers will complain that they’ve spent all day rewriting their app in C++
    and it only runs 10 percent faster. If that’s the case, it’s likely that these
    apps wouldn’t benefit from converting to WebAssembly, and their C++ gets compiled
    into mostly JavaScript. Take the time to learn WebAssembly, not C++, and make
    your web applications run lightning fast.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Legacy Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two popular libraries for porting existing libraries to WebAssembly are *wasm-pack*
    for Rust and *Emscripten* for C/C++. Using WebAssembly is ideal for when you have
    existing code written in C/C++ or Rust that you want to make available to web
    applications, or want to port entire existing desktop applications to make them
    available on the web. The Emscripten toolchain is particularly efficient at porting
    existing C++ desktop applications to the web using WebAssembly. If this is your
    path, you’ll likely want your app to perform as closely as possible to the native
    speed of your existing application, which should be feasible as long as the application
    isn’t a resource hog. However, you might also have an app that needs performance
    tuning to make it run as it does on the desktop. By the end of this book, you’ll
    be able to evaluate the WebAssembly module your toolchain generates from your
    existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Portability and Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We combined the portability and security features into one section because they
    frequently go together. WebAssembly started as a technology to run in the browser
    but is quickly expanding to become a sandboxed environment to run anywhere. From
    server-side WASI code to WebAssembly for embedded systems and the internet of
    things (IoT), the WebAssembly working group is creating a highly secure runtime
    that prevents bad actors from compromising your code. I recommend listening to
    Lin Clark’s excellent talk about WebAssembly security and package reuse at the
    first WebAssembly Summit ([https://www.youtube.com/watch?v=IBZFJzGnBoU/](https://www.youtube.com/watch?v=IBZFJzGnBoU/)).
  prefs: []
  type: TYPE_NORMAL
- en: Even though the WebAssembly working group focuses on security, no system is
    entirely secure. Learning to understand WebAssembly at a low level will prepare
    you for any future security risks.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Skeptics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some people simply dislike JavaScript and would rather that JavaScript not be
    the dominant web programming language. Unfortunately, WebAssembly isn’t in a position
    to dethrone JavaScript. Today, JavaScript and WebAssembly must coexist and play
    well together, as shown in [Figure 1-1](#figure1-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is good news for the JavaScript skeptics in the world: WebAssembly
    toolchains offer many options for writing web applications without having to write
    JavaScript. For example, Emscripten allows you to write web applications in C/C++
    with very little, if any, JavaScript. You can also write entire web applications
    using Rust and wasm-pack. Not only do these toolchains generate WebAssembly, but
    they also create copious JavaScript glue code for your application. The reason
    is that currently, there are limits to WebAssembly’s capabilities, and the toolchains
    fill these gaps with JavaScript code. The beauty of mature toolchains like Emscripten
    is that they do this for you. If you’re developing with one of these toolchains,
    it’s helpful to understand when your code will turn into WebAssembly and when
    it will be JavaScript. This book helps you know when this will happen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01001](Images/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: JavaScript and WebAssembly can coexist in harmony.'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly’s Relationship with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to clarify how WebAssembly is used with and compares to JavaScript.
    WebAssembly isn’t a direct replacement for JavaScript; rather, WebAssembly:'
  prefs: []
  type: TYPE_NORMAL
- en: Is faster to download, compile, and execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to write applications for the web in languages other than JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can provide near-native speed for your application when used properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works *with* JavaScript to improve the performance of your web applications
    when appropriately used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isn’t an assembly language, although there is a pseudo assembly language associated
    with it (WAT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isn’t only for the web but can execute from non-browser JavasScript engines,
    such as Node.js, or can execute using runtimes that implement the WASI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isn’t yet a one-size-fits-all solution for creating web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebAssembly is the result of all major browser vendors collaborating to create
    a new platform for distributing applications over the internet. The JavaScript
    language evolved from the needs of web browsers in the late 1990s to the mature
    scripting language it is today. Although JavaScript has become a reasonably fast
    language, web developers have noticed that it sometimes performs inconsistently.
    WebAssembly is a solution to many of the performance problems associated with
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Even though WebAssembly can’t do everything JavaScript can, it can execute certain
    operations much faster than JavaScript while consuming less memory. Throughout
    this book, we compare JavaScript code with the corresponding WebAssembly. We’ll
    repeatedly benchmark and profile the code for comparison. By the end of this book,
    you’ll be able to judge when you should use WebAssembly and when it makes sense
    to continue using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Why Learn WAT?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many WebAssembly books and tutorials focus on specific toolchains, such as the
    aforementioned wasm-pack for Rust or Emscripten for C/C++. Toolchains for other
    languages like AssemblyScript (a subset of TypeScript) and Go are currently in
    development. These toolchains are a major reason programmers turn to WebAssembly,
    and more WebAssembly language toolchains are continually becoming available. In
    the future, web developers will be able to choose the language they use to develop
    based on project needs rather than language availability.
  prefs: []
  type: TYPE_NORMAL
- en: One factor that is useful across any of these languages is understanding what
    WebAssembly does at its lowest level. A deep understanding of WAT tells you why
    the code might not run as fast as you thought it would. It can help you comprehend
    how WebAssembly interacts with its embedding environment. Writing a module in
    WAT is the best way to work as close to the metal (low-level) as possible in a
    web browser. Knowledge of WAT can help you make the highest-performing web applications
    possible and allows you to disassemble and evaluate any web application written
    for the WebAssembly platform. It helps you assess any potential future security
    risks. In addition, it enables you to write code that is as close to native speed
    as possible without writing native code.
  prefs: []
  type: TYPE_NORMAL
- en: So what is WAT? WAT is like an assembly language for the WebAssembly virtual
    machine. Let’s look at what this means in a practical sense. Writing WebAssembly
    programs in a language like Rust or C++ uses a toolchain, which, as mentioned
    earlier, compiles a WebAssembly binary file as well as JavaScript glue code and
    HTML that embeds the WebAssembly module. A WebAssembly file is very similar to
    machine code because it includes sections, opcodes, and data all stored as a series
    of binary numbers. When you have an executable file in machine code, you can disassemble
    that file into that machine’s *assembly language,* the lowest level of programming
    languages. Assembly replaces the numeric opcodes in the binary with mnemonic codes
    that are intended to be readable by a human being. WAT acts as the assembly language
    for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: WAT Coding Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two primary styles of WAT coding to choose from. One style is the
    *linear instruction list* style. This coding style requires the developer to mentally
    keep track of items on the stack. Most WAT instructions push items onto a stack,
    pop them off a stack, or both. If you choose to write in the linear instruction
    style, there is an implicit stack where the parameters of your instructions must
    be placed before the instruction is called. The other coding style is called *S-Expressions*.
    S-Expressions are a tree-like coding structure where parameters are passed into
    the tree in a way that looks a bit more like function calls in JavaScript. If
    you have trouble visualizing the stack and the items being pushed onto and off
    of it, the S-Expression syntax might be more your style. You can also mix the
    two styles depending on the implicit stack for less complicated instructions and
    use an S-Expression when the number of parameters become challenging to keep track
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Example Using Linear Instruction List Style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the simple addition function in [Listing 1-1](#listing1-1), which is
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: JavaScript code adding `a_val` and `b_val` variables'
  prefs: []
  type: TYPE_NORMAL
- en: After executing these lines, the value in the `c_val` variable is now `3`, which
    is the result of adding `a_val` and `b_val`. To do the same task in WAT, you would
    need quite a few lines of code. [Listing 1-2](#listing1-2) shows the same program
    using WAT.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: WebAssembly adding `$a_val` to `$b_val`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-2](#listing1-2) contains more lines of code because WAT must be
    more explicit than JavaScript. JavaScript has no idea whether the types in the
    previous two examples are floating-point data, integers, strings, or a mix until
    the code runs. The WebAssembly is compiled into a bytecode ahead of time and must
    be made aware of the types it’s using when it’s compiled. The JavaScript must
    be parsed and tokenized before the JIT compiler can turn it into bytecode. Once
    the optimizing compiler begins working on that bytecode, the compiler must watch
    to see whether the variables are consistently integers. If they are, the JIT can
    create a bytecode that makes that assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: However, JavaScript is never quite sure whether it will end up with string data
    or floating-point data when it expected integers; so at any time, it must be ready
    to throw out its optimized code and start over again. The WAT code might be harder
    to write and to understand, but it’s much easier for the web browser to run. WebAssembly
    moves a lot of work from the browser to the toolchain compiler or the developer.
    Not having to do as much work makes for happy browsers and faster applications.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Machines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, WebAssembly is a virtual stack machine. Let’s explore
    what this means. Think of a stack as a stack of dishes. Each dish in this metaphor
    is a piece of data. When you add a dish to the stack, you place it on top of the
    dishes already there. When you take a dish off the stack, you don’t take it from
    the bottom, you take it off the top. For this reason, the last dish you put on
    the stack is the first dish you remove. In computer science, this is called *last-in,
    first-out* (*LIFO*). Adding data to a stack is called a *push*, and taking data
    off a stack is called a *pop*. When you use a stack machine, almost all commands
    perform some interaction with the stack, either adding more data to the top of
    the stack with a push or removing data from the top with a pop. [Figure 1-2](#figure1-2)
    shows a depiction of stack interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01002](Images/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: A stack machine pops values off and pushes values onto the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier, the first two lines of the `$main` function in [Listing
    1-2](#listing1-2) push `$a_val` on the top of the stack 1 and then push `$b_val`
    on top of that 2. The result is a stack with two values on it. The bottom of the
    stack has the value in `$a_val` because we added it first, and the top has the
    value in `$b_val` because it was added last.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to make the distinction between an ISA for a stack machine, like
    WebAssembly, and an ISA for a register machine, such as x86, ARM, MIPS, PowerPC,
    or any other popular hardware architecture of the past 30 years. Register machines
    must move data from memory into CPU registers to perform mathematical operations
    on them. WebAssembly is a virtual stack machine that must run on register machines.
    As we write WAT formatted code, you’ll see this interaction up close.
  prefs: []
  type: TYPE_NORMAL
- en: Stack machines push data onto and off of a stack to perform calculations. Hardware
    stack machines are a rare breed of computer. Virtual stack machines like WebAssembly
    are more common; examples include Java’s JVM, Adobe Flash player’s AVM2, Ethereum’s
    EVM, and the CPython bytecode interpreter. The advantage of virtual stack machines
    is that they create smaller bytecode sizes, which is handy for any bytecode intended
    to be downloaded or streamed over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Stack machines make no assumptions about the number of general-purpose registers
    available to the embedding environment. That allows the hardware to choose which
    registers to use and when. The WAT code can be a little confusing if you’re not
    aware of how a stack machine works, so let’s take another look at the first two
    lines of the function `$main` with the stack in mind ([Listing 1-3](#listing1-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-3: Retrieving `$a_val` and `$b_val`, and then pushing them on the
    stack'
  prefs: []
  type: TYPE_NORMAL
- en: The first line gets the value of `$a_val`, which we define as a global value,
    and the second line gets the global variable `$b_val`. Both items end up on the
    stack waiting to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: The function `i32.add` takes two 32-bit integer variables off the stack, adds
    them together, and then pushes the result back onto the top of the stack. Once
    the two values are on the stack, we can call `i32.add`. If you run a function
    that pops more values off the stack than were available, the tools you use to
    convert your WAT into a WebAssembly binary won’t allow this and will throw a compiler
    error. We use the final line in the `$main` function to set the `$c_val` variable
    to the value on the stack. That value is the result of the `i32.add` function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Example Using S-Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: S-Expressions are a nested tree structure coding style used in programming languages,
    such as Lisp. In [Listing 1-3](#listing1-3), we used the linear instruction list
    style for writing WAT. The linear instruction style implicitly uses the stack
    for each call statement and expression called. For those with some assembly language
    experience, this method might feel comfortable for you. But if you come to WebAssembly
    from a high-level language, like JavaScript, the S-Expression syntax for WAT is
    likely to feel more familiar. S-Expressions organize your calls to WAT statements
    and expressions in a nested structure. The linear style requires you to mentally
    push items onto the stack and pop them off as you write your code. The S-Expressions
    look more like JavaScript function calls than the linear style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 1-2](#listing1-2), we set `c_val` to `a_val` + `b_val` using the
    stack. The code in [Listing 1-4](#listing1-4) is the fragment of code in [Listing
    1-2](#listing1-2) where we added those values together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-4: Adding and setting `$c_val` in WebAssembly'
  prefs: []
  type: TYPE_NORMAL
- en: We push two 32-bit integer variables onto the stack that we retrieved from global
    variables using `global.get` 1. We then popped those two values off the stack
    with a call to `i32.add`. After adding those two values together, the `i32.add`
    2 function pushed the resulting value back onto the stack. That’s how the stack
    machine works. Each instruction either pushes a value onto the stack, pops a value
    off, or both.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](#listing1-5) shows the same function using the alternative S-Expression
    syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-5: WebAssembly module to add two values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t let the parentheses confuse you: they work the same way as the `{}` characters
    do in many languages to create code blocks. When writing a WAT function, we enclose
    the function in parentheses. When you bring a matching parenthesis below the opening
    parenthesis with the same indentation, it looks similar to the way you would indent
    the `{` and `}` characters in a language like JavaScript. For instance, look at
    the indentation of the `(` before the `global.set` 1 call and match it up by eye
    with the closing `)` below it.'
  prefs: []
  type: TYPE_NORMAL
- en: This code looks more like a conventional programming language than [Listing
    1-2](#listing1-2), because it appears to pass parameters into a function instead
    of pushing and popping values with a stack. To be clear, this code compiles into
    the same binary. If you write your code in an S-Expressions style, you’re still
    pushing items on and off the stack. This style of writing WAT is just *syntactic
    sugar* (syntax to make code easier to read). When you’re comfortable disassembling
    WebAssembly files into WAT, you’ll find that the S-Expression syntax isn’t provided
    by disassemblers, such as *wasm2wat*.
  prefs: []
  type: TYPE_NORMAL
- en: The Embedding Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, WebAssembly doesn’t run directly on hardware. You must
    embed the WebAssembly binary in a host environment that controls the loading and
    initializing of a WebAssembly module. In this book, we work with JavaScript engines,
    such as Node.js, and web browsers as embedding environments. Other environments
    include WASI, such as wasmtime (defined shortly). But even though we discuss WASI,
    we won’t use it in this book because it’s still very new and under development.
    It’s up to the embedding environment to implement the stack machine. Because modern
    hardware is typically a register machine, the embedding environment manages the
    stack using the hardware registers.
  prefs: []
  type: TYPE_NORMAL
- en: The Browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a good chance that you’re interested in WebAssembly because you want
    it to improve the performance of your web applications. All modern browser JavaScript
    engines implement WebAssembly. Currently, Chrome and Firefox have the best tools
    for debugging WebAssembly, so we suggest choosing one of those browsers for development.
    Your WAT applications should also run just fine in Microsoft Edge, but Internet
    Explorer is no longer adding features. Unfortunately, Internet Explorer doesn’t
    support WebAssembly and never will.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re writing WAT for a web browser, it’s crucial to understand which
    parts of an application you can write in WAT and which you must write in JavaScript.
    There might also be cases where the performance improvement you gain with WebAssembly
    might not be worth the additional development time. If you understand WAT and
    WebAssembly, you’ll be able to make these decisions. When you’re working with
    WebAssembly, you must frequently trade performance for development time, or sacrifice
    CPU cycles for memory, or vice versa. Performance optimization is about choices.
  prefs: []
  type: TYPE_NORMAL
- en: WASI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*WASI* is a runtime specification for WebAssembly applications and is a standard
    for WebAssembly interaction with the operating system. It allows WebAssembly to
    use the filesystem, make system calls, and handle input and output. The Mozilla
    Foundation has created a WebAssembly runtime called *wasmtime* that implements
    the WASI standard. With WASI, WebAssembly can do everything that a native application
    can do but in a secure and platform-independent way. It does it all with performance
    similar to native apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js can also run a WASI experimental preview using the `--experimental-wasi-unstable-preview1`
    flag. You can use it to run WebAssembly applications that interact with the operating
    system outside of a web browser. Windows, macOS, Linux, or any other operating
    system can implement a WASI runtime, because it’s designed to make WebAssembly
    portable, secure, and eventually universal.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Visual Studio Code (VS Code)* is an open source integrated development environment
    (IDE), and the one I used to write the examples in this book. VS Code is available
    for Windows, macOS, and Linux at[https://code.visualstudio.com/download](https://code.visualstudio.com/download).
    We use VS Code with the WebAssembly extension written by Dmitriy Tsvettsikh, which
    is available at [https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm](https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm).
    The extension provides code coloring for the WAT format, as well as several other
    useful menu items. For example, if you have a WebAssembly file, you can disassemble
    it into WAT by right-clicking the file and choosing the **Show WebAssembly** menu
    option. This is very useful if you want to look at WebAssembly code you didn’t
    write or code that was compiled using a toolchain. The extension can also compile
    your WAT files into a WebAssembly binary. You can right-click the *.wat* file
    and choose **Save as WebAssembly binary file**. A save file prompt appears, allowing
    you to specify the filename where you want to save the WebAssembly file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-3](#figure1-3) shows a screenshot of the extension.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01003](Images/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Installing the WebAssembly extension for VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Node.js* is an excellent tool for testing the performance of WebAssembly modules
    against existing JavaScript modules and is the JavaScript runtime environment
    we use in much of this book. Node.js comes with *npm (Node Package Manager),*
    which you can use to easily install packages of code. WebAssembly is a great alternative
    to writing a native module in Node.js, which locks you into using specific hardware.
    If you want to create an npm module for general use, writing for WebAssembly can
    give you the performance of a native module with the portability and security
    of a JavaScript module. We’ll execute many of the applications we write in this
    book using Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is our preferred development tool for executing WebAssembly, whether
    it be from JavaScript or through a web server. We’ll begin by using Node.js to
    execute WebAssembly modules from JavaScript, and in Chapter 7, we’ll write a simple
    web server to serve WebAssembly web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js comes with the npm, which makes it easy to install some tools you can
    use to develop WebAssembly. In this section, we’ll show you how to use npm to
    install the *wat-wasm* module, a tool for compiling, optimizing, and disassembling
    WebAssembly. We’ll also show you how to use Node.js to write a simple WebAssembly
    application. Many readers might already be familiar with Node.js, but if not,
    there is a mountain of Node.js documentation available if you want to learn more
    than the short introduction and setup we discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You must have Node.js installed to complete the code examples in this book.
    Fortunately, the installation isn’t complicated. If you’re using Windows or macOS,
    installers are available for both operating systems at [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Ubuntu Linux, you can install Node using the following `apt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have Node installed, run the following command from a command prompt
    (on any platform) to make sure everything installed as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is installed, you should see the version of Node.js installed
    as output. When we run the command `node -v` on our Windows machine, it produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means that we’re running version 12.14.0.
  prefs: []
  type: TYPE_NORMAL
- en: Installing wat-wasm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many tools are available for converting WAT code to a WebAssembly binary. In
    fact, while writing this book, I used many of these tools. In the end, I wrote
    *wat-wasm* on top of *WABT.js* and *Binaryen.js*to reduce the number of packages
    needed for the features I wanted to demonstrate. To install `wat-wasm`, execute
    the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-g` flag installs `wat-wasm` globally. Throughout this book we’ll use
    command line tools like `wat2wasm` in the terminal window. To use the tools for
    more than just the current project, you need to install it globally. Once you
    have `wat-wasm` installed, make sure you can run it by running the `wat2wasm`
    command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should then see the `wat-wasm` usage logged to your console. This will show
    you a variety of flags that you’ll learn about later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test `wat2wasm` by creating the simplest possible WAT module, as shown
    in [Listing 1-6](#listing1-6). Create a new file called *file.wat* and enter the
    following code into that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-6: The simplest possible WebAssembly module'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `wat-wasm`installed, you can use the command in [Listing 1-7](#listing1-7)
    to compile *file.wat* file to *file.wasm*, which is the WebAssembly binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-7: Assembling the *file.**wat* file with `wat2wasm`'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Node.js throughout this book to run WebAssembly command line apps
    and serve WebAssembly web apps to open in a browser. In the next section, we’ll
    write the first WebAssembly app that we’ll execute using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Our First Node.js WebAssembly App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll begin the book by using Node.js as the embedding environment instead of
    the web browser so as to remove the need for HTML and CSS in the code examples
    and keep them simple. Later, once you have the basics, we’ll explore using the
    browser as the embedding environment.
  prefs: []
  type: TYPE_NORMAL
- en: The WAT code in our Node.js apps will work the same as they do in the browser.
    The WebAssembly engine inside Node.js is the same as the one inside Chrome, and
    the WebAssembly part of the app is completely unaware of the environment it’s
    running in.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by creating a simple WAT file and compiling it using `wat2wasm`.
    Create a file called *AddInt.wat* and add the WAT code in [Listing 1-8](#listing1-8)
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**AddInt.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-8: WebAssembly module with a function that adds two integers'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be able to understand this code. Take some time to look it
    over until you’re comfortable with the logic. This is a straightforward WebAssembly
    module with a single function `AddInt` that we export to the embedding environment.
    Now compile *AddInt.wat* into *AddInt.wasm* using `wat2wasm`, as shown in [Listing
    1-9](#listing1-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-9: Compiling *AddInt.wat* into *AddInt.wasm*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to write the JavaScript portion of our first Node.js app.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the WebAssembly Module from Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can call the WebAssembly module from Node.js using JavaScript. Create a file
    called *AddInt.js* and add the JavaScript code in [Listing 1-10](#listing1-10).
  prefs: []
  type: TYPE_NORMAL
- en: '**AddInt.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-10: Calling the `AddInt` WebAssembly function from an asynchronous
    IIFE'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js can read the WebAssembly file directly from the hard drive where the
    application is running using the built-in module called `fs` 1 that reads files
    from local storage. We load this module using Node.js’s `require` function. We
    use the `fs` module to read in the *AddInt.wasm* file using the `readFileSync`
    function. We also take in two arguments from the command line using the `process.argv`
    2 array. The `argv` array has all the arguments passed in from the command line
    to Node.js. We’ll run the function from the command line; `process.argv[0]` will
    contain the command `node` and `process.argv[1]` will contain the name of the
    JavaScript file *AddInt.js*. When we run the program, we pass in two numbers on
    the command line, which will set `process.argv[2]` and `process.argv[3]`.
  prefs: []
  type: TYPE_NORMAL
- en: We use an asynchronous *immediately invoked function expression (IIFE)* to instantiate
    the WebAssembly module, call the WebAssembly function, and output the results
    to the console. For those unfamiliar with the IIFE syntax, it’s a means by which
    JavaScript is able to wait for a promise before executing the rest of the code.
    When you do tasks like instantiate a WebAssembly module, it takes time, and you
    don’t want to tie up the browser or node while waiting for that process to finish.
    The `(async () => {})();` 3 syntax tells the JavaScript engine that there is a
    promise object coming, so go do something else while waiting for the result. Inside
    the IIFE, we call `WebAssembly.instantiate` 4 passing the `bytes` we retrieved
    from the WebAssembly file earlier with the call to `readFileSync`. After instantiating
    the module, we call the `AddInt` 5 function exported from the WAT code. We then
    call a `console.log` 6 statement to output the values we’re adding and the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the WebAssembly module and the JavaScript file, we can run
    the app from the command line using the call to Node.js, as shown in [Listing
    1-11](#listing1-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-11: Running *AddInt.js* using Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The addition of the two integers happens in WebAssembly. Before we move on,
    we’ll quickly show you how to use the `.then` syntax as an alternative to the
    asynchronous IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: The .then Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other widely used syntax to wait for the return of promises is the `.then`
    syntax. We prefer to use the IIFE syntax in [Listing 1-10](#listing1-10), but
    either syntax is perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called *AddIntThen.js* and add the code in [Listing 1-12](#listing1-12)
    to replace the asynchronous IIFE syntax in [Listing 1-10](#listing1-10) with the
    `.then`code.
  prefs: []
  type: TYPE_NORMAL
- en: '**AddIntThen.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-12: Using the `.then` syntax to call a WebAssembly function'
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference here lies in the `WebAssembly.instantiate` 1 function,
    followed by `.then` 2, and containing an arrow function callback that passes in
    an object `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: The Time Is Now
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now is a great time to learn WAT. At the time of writing this, the current
    release of WebAssembly 1.0 has a relatively small instruction set with a total
    of 172 different opcodes in the WebAssembly binary, although you don’t need to
    remember all of them. WebAssembly supports four different data types: `i32`, `i64`,
    `f32`, and `f64`, and many of the opcodes are duplicate commands for each type
    (for example, `i32.add`and `i64.add`). If you eliminate the duplicate opcodes,
    you only need to know about 50 different mnemonics to know the entire language.
    The number of opcodes supported by WebAssembly will increase over time. Starting
    WebAssembly now in its early days gives you a leg up. In the future, remembering
    every opcode will become difficult or impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, writing your modules in WAT is the best way to work as
    close to the metal as possible within a web browser. The way JavaScript is implemented
    in the browser today can create performance inconsistencies depending on a wide
    variety of factors. WebAssembly can eliminate these inconsistencies, and WAT can
    help you streamline your code to make it as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a toolchain like Emscripten with only a minimal understanding of
    the WebAssembly platform. However, using the toolchains this way might result
    in minimal performance improvements in your application and mislead you to conclude
    that WebAssembly isn’t worth the effort. You would be wrong. If you want to get
    the highest possible performance from your web application, you must learn as
    much as you can about WebAssembly. You need to know what it can and cannot do.
    You must understand what it’s good at and what you should do in JavaScript. The
    best way to gain this knowledge is to write WAT code. In the end, you might not
    write your application in WAT, but knowing the language helps you comprehend WebAssembly
    and the web browser.
  prefs: []
  type: TYPE_NORMAL
