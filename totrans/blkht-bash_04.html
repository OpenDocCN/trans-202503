<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch4">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">4</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">RECONNAISSANCE</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">Every hacking engagement starts with some form of information gathering. In this chapter, we’ll perform reconnaissance on targets by writing bash scripts to run various hacking tools. You’ll learn how to use bash to automate tasks and chain multiple tools into a single workflow.</p>&#13;
<p class="TX">In the process, you’ll develop an important bash-scripting skill: parsing the output of various tools to extract only the information you need. Your scripts will interact with tools that figure out what hosts are online, what ports are open on those hosts, and what services they are running, then deliver this information to you in the format you require.</p>&#13;
<p class="TX">Perform all hacking activities in your Kali environment against the vulnerable network you set up in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-28"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/><span class="SANS_Futura_Std_Bold_B_11">Creating Reusable Target Lists</span></h2>&#13;
<p class="TNI1">A <i>scope</i> is a list of systems or resources you’re allowed to target. In penetration testing or bug-hunting engagements, the target company might provide you with various types of scopes:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Individual IP addresses, such as 172.16.10.1 and 172.16.10.2</li>&#13;
<li class="ListBullet">Networks, such as 172.16.10.0/24 and 172.16.10.1–172.16.10.254</li>&#13;
<li class="ListBullet">Individual domain names, such as <i>lab.example.com</i></li>&#13;
<li class="ListBullet">A parent domain name and all its subdomains, such as <i>*.example.com</i></li>&#13;
</ul>&#13;
<p class="TX">When working with tools such as port and vulnerability scanners, you’ll often need to run the same type of scan against all hosts in your scope. This can be hard to do efficiently, however, as each tool uses its own syntax. For instance, one tool might allow you to specify an input file containing a list of targets, while other tools may require individual addresses.</p>&#13;
<p class="TX">When working with tools that don’t let you provide a wide range of targets, you can use bash to automate this process. In this section, we’ll use bash to create IP- and DNS-based target lists that you could feed to scanners.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-58"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Consecutive IP Addresses</span></h3>&#13;
<p class="TNI1">Imagine that you need to create a file containing a list of IP addresses from 172.16.10.1 to 172.16.10.254. While you could write all 254 addresses by hand, this would be time-consuming. Let’s use bash to automate the job! We’ll consider three strategies: using the <span class="SANS_TheSansMonoCd_W5Regular_11">seq</span> command in a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, using brace expansion with <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span>, and using brace expansion with <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span>.</p>&#13;
<p class="TX">In the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop shown in <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>, we use <span class="SANS_TheSansMonoCd_W5Regular_11">seq</span> to iterate through numbers ranging from 1 to 254 and assign each number to the <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span> variable. After each iteration, we use <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> to write the IP address to a dedicated file on disk, <i>172-16-10-hosts.txt</i>.</p>&#13;
<span id="Lis4-1"/><pre><code>#!/bin/bash&#13;
&#13;
# Generate IP addresses from a given range.&#13;
for ip in $(seq 1 254); do&#13;
  echo "172.16.10.${ip}" &gt;&gt; 172-16-10-hosts.txt&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-1: Creating a list of IP addresses with the seq command and a for loop</span></p>&#13;
<p class="TX">You can run this code directly from the command line or save it in a script and then run it. The generated file should look like the following:</p>&#13;
<pre><code>$ <b>cat 172-16-10-hosts.txt</b>&#13;
172.16.10.1&#13;
172.16.10.2&#13;
172.16.10.3&#13;
172.16.10.4&#13;
172.16.10.5&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>As in most cases, you can use multiple approaches to achieve the same task in bash. We can generate the IP address list by using a simple <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command, without running any loops. In <a href="chapter4.xhtml#Lis4-2">Listing 4-2</a>, we use <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> with brace expansion to generate the strings.</p>&#13;
<span id="Lis4-2"/><pre><code>$ <b>echo 10.1.0.{1..254}</b>&#13;
&#13;
10.1.0.1 10.1.0.2 10.1.0.3 10.1.0.4 ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-2: Performing brace expansion with echo</span></p>&#13;
<p class="TX">You’ll notice that this command outputs a list of IP addresses on a single line, separated by spaces. This isn’t ideal, as what we really want is each IP address on a separate line. In <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>, we use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to replace spaces with newline characters (<span class="SANS_TheSansMonoCd_W5Regular_11">\n</span>).</p>&#13;
<span id="Lis4-3"/><pre><code>$ <b>echo 10.1.0.{1..254} | sed 's/ /\n/g'</b>&#13;
&#13;
10.1.0.1&#13;
10.1.0.2&#13;
10.1.0.3&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-3: Generating a list of IP addresses with echo and sed</span></p>&#13;
<p class="TX">Alternatively, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span> command to generate the same list. Using <span class="SANS_TheSansMonoCd_W5Regular_11">printf</span> won’t require piping to <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span>, producing a cleaner output:</p>&#13;
<pre><code>$ <b>printf "10.1.0.%d\n" {1..254}</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">%d</span> is an integer placeholder, which will be swapped with the numbers defined in the brace expansion to produce a list of IP addresses from 10.1.0.1 to 10.1.0.254. You can redirect the output to a new file and then use it as an input file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-59"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Possible Subdomains</span></h3>&#13;
<p class="TNI1">Say you’re performing a penetration test against a company with the parent domain <i>example.com</i>. In this engagement, you’re not restricted to any specific IP address or domain name, which means that any asset you find on this parent domain during the information-gathering stage is considered in scope.</p>&#13;
<p class="TX">Companies tend to host their services and applications on dedicated subdomains. These subdomains can be anything, but more often than not, companies use names that make sense to humans and are easy to enter into a web browser. For example, you might find the help-desk portal at <i>helpdesk.example.com</i>, the monitoring system at <i>monitoring.example.com</i>, the continuous integration system at <i>jenkins.example.com</i>, the email server at <i>mail.example.com</i>, and the file transfer server at <i>ftp.example.com</i>.</p>&#13;
<p class="TX">How can we generate a list of possible subdomains for a target? Bash makes this easy. First, we’ll need a list of common subdomains. You can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>find such a list built into Kali at <i>/usr/share/wordlists/amass/subdomains-top1mil-110000.txt</i> or <i>/usr/share/wordlists/amass/bitquark_subdomains_top100K.txt</i>. To look for wordlists on the internet, you could use the following Google search query to search for files on GitHub provided by community members: <b>subdomain wordlist site:gist.github.com</b>. This will search GitHub for code snippets (also called <i>gists</i>) containing the words <i>subdomain wordlist</i>.</p>&#13;
<p class="TX">For the purposes of this example, we’ll use <i>subdomains-1000.txt</i>, which is included with this chapter’s files in the book’s GitHub repository. Download this subdomain list and save it in your home directory. The file contains one subdomain per line without an associated parent domain. You’ll have to join each subdomain with the target’s parent domain to form a fully qualified domain name. As in the previous section, we’ll show multiple strategies for accomplishing this task: using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop and using <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download this chapter’s resources from</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04</a></span>.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#Lis4-4">Listing 4-4</a> accepts a parent domain and a wordlist from the user, then prints a list of fully qualified subdomains by using the wordlist you downloaded earlier.</p>&#13;
<span id="Lis4-4"/><pre><code>#!/bin/bash&#13;
DOMAIN="${1}"&#13;
FILE="${2}"&#13;
&#13;
# Read the file from standard input and echo the full domain.&#13;
while read -r subdomain; do&#13;
  echo "${subdomain}.${DOMAIN}"&#13;
done &lt; "${FILE}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-4: Using a while loop to generate a list of subdomains</span></p>&#13;
<p class="TX">The script uses a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop to read the file and assign each line to the <span class="SANS_TheSansMonoCd_W5Regular_11">subdomain</span> variable in turn. The <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command then concatenates these two strings together to form a full domain name. Save this script as <i>generate_subdomains.sh</i> and provide it with two arguments:</p>&#13;
<pre><code>$ <b>./generate_subdomains.sh example.com subdomains-1000.txt</b>&#13;
&#13;
www.example.com&#13;
mail.example.com&#13;
ftp.example.com&#13;
localhost.example.com&#13;
webmail.example.com&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The first argument is the parent domain, and the second is the path to the file containing all possible subdomains.</p>&#13;
<p class="TX">We can use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to write content to the end of each line in a file. In <a href="chapter4.xhtml#Lis4-5">Listing 4-5</a>, the command uses the <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> sign to find the end of a line, then <span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>replace it with the target domain prefixed with a dot (<i>.example.com</i>) to complete the domain name.</p>&#13;
<span id="Lis4-5"/><pre><code>$ <b>sed 's/$/.example.com/g' subdomains-1000.txt</b>&#13;
&#13;
relay.example.com&#13;
files.example.com&#13;
newsletter.example.com&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-5: Using sed to generate a list of subdomains</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> at the beginning of the argument to <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> stands for <i>substitute</i>, and <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> means that <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> will replace all matches in the file, not just the first match. So, in simple terms, we substitute the end of each line in the file with <i>.example.com</i>. If you save this code to a script, the output should look the same as in the previous example.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h1-29"/><span class="SANS_Futura_Std_Bold_B_11">Host Discovery</span></h2>&#13;
<p class="TNI1">When testing a range of addresses, one of the first things you’ll likely want to do is find out information about them. Do they have any open ports? What services are behind those ports, and are they vulnerable to any security flaws? Answering these questions manually is possible, but this can be challenging if you need to do it for hundreds or thousands of hosts. Let’s use bash to automate network enumeration tasks.</p>&#13;
<p class="TX">One way to identify live hosts is by attempting to send them network packets and wait for them to return responses. In this section, we’ll use bash and additional network utilities to perform host discovery.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-60"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ping</span></h3>&#13;
<p class="TNI1">At its most basic form, the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command takes one argument: a target IP address or domain name. Run the following command to see its output:</p>&#13;
<pre><code>$ <b>ping 172.16.10.10</b>&#13;
&#13;
PING 172.16.10.10 (172.16.10.10) 56(84) bytes of data.&#13;
64 bytes from 172.16.10.10: icmp_seq=1 ttl=64 time=0.024 ms&#13;
64 bytes from 172.16.10.10: icmp_seq=2 ttl=64 time=0.029 ms&#13;
64 bytes from 172.16.10.10: icmp_seq=3 ttl=64 time=0.029 ms&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command will run forever, so press <small>CTRL</small>-C to stop its execution.</p>&#13;
<p class="TX">If you read the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> manual page (by running <span class="SANS_TheSansMonoCd_W5Regular_11">man ping</span>), you’ll notice that there is no way to run the command against multiple hosts at once. But using bash, we can do this quite easily. <a href="chapter4.xhtml#Lis4-6">Listing 4-6</a> pings all hosts on the network 172.16.10.0/24.</p>&#13;
<span id="Lis4-6"/><pre><code>#!/bin/bash&#13;
FILE="${1}"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label="74"/><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> while read -r host; do&#13;
   <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if ping -c 1 -W 1 -w 1 "${host}" &amp;&gt; /dev/null; then&#13;
    echo "${host} is up."&#13;
  fi&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> <span class="SANS_TheSansMonoCd_W5Regular_11">done &lt; "${FILE}"</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-6: Using a while loop to ping multiple hosts</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we run a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop that reads from the file passed to the script on the command line. This file is assigned to the variable <span class="SANS_TheSansMonoCd_W5Regular_11">FILE</span>. We read each line from the file and assign it to the <span class="SANS_TheSansMonoCd_W5Regular_11">host</span> variable. We then run the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command, using the <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> argument with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> at <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which tells <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> to send a ping request only once and exit. By default on Linux, <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> sends ping requests indefinitely until you stop it manually by sending a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGHUP</span> signal (<small>CTRL</small>-C).</p>&#13;
<p class="TX">We also use the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">-W 1</span> (to set a timeout in seconds) and <span class="SANS_TheSansMonoCd_W5Regular_11">-w 1</span> (to set a deadline in seconds) to limit the amount of time <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> will wait to receive a response. This is important because we don’t want <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> to get stuck on an unresponsive IP address; we want it to continue reading from the file until all 254 hosts are tested.</p>&#13;
<p class="TX">Finally, we use the standard input stream to read the file and “feed” the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop with its contents <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Save this code to <i>multi_host_ping.sh</i> and run it while passing in the <i>hosts</i> file. You should see that the code picks up a few live hosts:</p>&#13;
<pre><code>$ <b>./multi_host_ping.sh 172-16-10-hosts.txt</b>&#13;
&#13;
172.16.10.1 is up.&#13;
172.16.10.10 is up.&#13;
172.16.10.11 is up.&#13;
172.16.10.12 is up.&#13;
172.16.10.13 is up.&#13;
</code></pre>&#13;
<p class="TX">The caveat to this host-discovery approach is that certain hosts, especially hardened ones, might not reply to <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> commands at all. So, if we rely solely on this method for discovery, we might miss out on live hosts on the network.</p>&#13;
<p class="TX">Also note that commands that run forever by default, such as <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span>, could pose a challenge when integrated into a bash script. In this example, we’ve explicitly set a few special flags to ensure that our bash script won’t hang when it executes <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span>. This is why it’s important to first test commands in the terminal before integrating them into your scripts. More often than not, tools have special options to ensure they don’t execute forever, such as timeout options.</p>&#13;
<p class="TX">For tools that don’t provide a timeout option, the <span class="SANS_TheSansMonoCd_W5Regular_11">timeout</span> command allows you to run commands and exit after a certain amount of time has passed. You can prepend <span class="SANS_TheSansMonoCd_W5Regular_11">timeout</span> to any Linux utility, passing it an interval (in the <i>seconds, minutes, hours</i> format)—for example, <span class="SANS_TheSansMonoCd_W5Regular_11">timeout 5s ping 8.8.8.8</span>. After the time has elapsed, the entire command exits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-61"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nmap</span></h3>&#13;
<p class="TNI1">The Nmap port scanner has a special option called <span class="SANS_TheSansMonoCd_W5Regular_11">-sn</span> that performs a <i>ping sweep</i>. This simple technique finds live hosts on a network by sending them a <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command and waiting for a positive response (called a <i>ping response</i>). Since many operating systems respond to <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> by default, this technique has proved valuable. The ping sweep in Nmap will essentially make Nmap send Internet Control Message Protocol packets over the network to discover running hosts:</p>&#13;
<pre><code>$ <b>nmap -sn 172.16.10.0/24</b>&#13;
&#13;
Nmap scan report for 172.16.10.1&#13;
Host is up (0.00093s latency).&#13;
Nmap scan report for 172.16.10.10&#13;
Host is up (0.00020s latency).&#13;
Nmap scan report for 172.16.10.11&#13;
Host is up (0.00076s latency).&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">This output has a lot of text. With a bit of bash magic, we can get a cleaner output by using the <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> commands to extract only the IP addresses that were identified as being alive (<a href="chapter4.xhtml#Lis4-7">Listing 4-7</a>).</p>&#13;
<span id="Lis4-7"/><pre><code>$ <b>nmap -sn 172.16.10.0/24 | grep "Nmap scan" | awk -F'report for ' '{print $2}'</b>&#13;
&#13;
172.16.10.1&#13;
172.16.10.10&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-7: Parsing Nmap’s ping scan output</span></p>&#13;
<p class="TX">Using Nmap’s built-in ping sweep scan may be more useful than manually wrapping the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> utility with bash, because you don’t have to worry about checking for conditions such as whether the command was successful. Moreover, in penetration tests, you may drop an Nmap binary on more than one type of operating system, and the same syntax will work consistently whether the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> utility exists or not.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-62"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">arp-scan</span></h3>&#13;
<p class="TNI1">We can perform penetration testing remotely, from a different network, or from within the same network as the target. In this section, we’ll highlight the use of <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> as a way to find hosts on a network when the test is done locally.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> utility sends Address Resolution Protocol (ARP) packets to hosts on a network and displays any responses it gets back. <i>ARP</i> maps <i>media access control (MAC)</i> addresses, which are unique 12-digit hexadecimal addresses assigned to network devices, to the IP addresses on a network. Because ARP is a Layer 2 protocol in the Open Systems Interconnection <span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/>(OSI) model, it is useful only when you’re on a local network; ARP can’t be used to perform a remote scan over the internet.</p>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> requires root privileges to run; this is because it uses functions to read and write packets that require elevated privileges. At its most basic form, you can run it by executing the <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> command and passing a single IP address as an argument:</p>&#13;
<pre><code>$ <b>sudo arp-scan 172.16.10.10 -I br_public</b></code></pre>&#13;
<p class="TX">We also need to tell <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> which network interface to send packets on, as Kali has a few network interfaces. To achieve this, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">-I</span> argument. The <span class="SANS_TheSansMonoCd_W5Regular_11">br_public</span> interface corresponds to the 172.16.10.0/24 network in the lab.</p>&#13;
<p class="TX">To scan entire networks, you can pass <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> a CIDR range, such as <i>/24</i>. For example, the following command scans all IP addresses from 172.16.10.1 to 172.16.10.254:</p>&#13;
<pre><code>$ <b>sudo arp-scan 172.16.10.0/24 -I br_public</b></code></pre>&#13;
<p class="TX">Finally, you can use the hosts file you created in <span class="Xref">“Consecutive IP Addresses” on <a href="#pg_70">page 70</a></span> as input to <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span>:</p>&#13;
<pre><code>$ <b>sudo arp-scan -f 172-16-10-hosts.txt -I br_public</b></code></pre>&#13;
<p class="TX">The output generated by <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> should look like the following:</p>&#13;
<pre><code>172.16.10.10  02:42:ac:10:0a:0a     (Unknown: locally administered)&#13;
172.16.10.11  02:42:ac:10:0a:0b     (Unknown: locally administered)&#13;
172.16.10.12  02:42:ac:10:0a:0c     (Unknown: locally administered)&#13;
172.16.10.13  02:42:ac:10:0a:0d     (Unknown: locally administered)&#13;
</code></pre>&#13;
<p class="TX">This output consists of three fields: the IP address, the MAC address, and vendor details, identified by the first three octets of the MAC address. In this scan, the tool identified four hosts on the network that responded to ARP packets.</p>&#13;
<p class="HeadAExercise"><span id="exe-3"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 3: Receiving Alerts About New Hosts</span></p>&#13;
<p class="TNI1">Imagine that you want to be notified whenever a new host appears on the network. For example, maybe you want to know when new laptops or IT assets have connected. This could be useful if you’re testing a target in a different time zone, where device users might not be online when you are.</p>&#13;
<p class="TX">You can use bash to send yourself an email whenever your script discovers new assets. <a href="chapter4.xhtml#Lis4-9">Listing 4-9</a> runs a continuous scan to identify new online hosts, adds these to the <i>172-16-10-hosts.txt</i> file created in <span class="Xref">“Consecutive IP Addresses” on <a href="#pg_70">page 70</a></span>, and notifies you of the discovery.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/>Because this script is more involved than the previous ones, we’ll walk through an example solution (<a href="chapter4.xhtml#Lis4-8">Listing 4-8</a>), then discuss ways to improve it on your own.</p>&#13;
<span id="Lis4-8"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">host_monitor _notification.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
# Sends a notification upon new host discovery&#13;
KNOWN_HOSTS="172-16-10-hosts.txt"&#13;
NETWORK="172.16.10.0/24"&#13;
INTERFACE="br_public"&#13;
FROM_ADDR="kali@blackhatbash.com"&#13;
TO_ADDR="security@blackhatbash.com"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> while true; do&#13;
  echo "Performing an ARP scan against ${NETWORK}..."&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> sudo arp-scan -x -I ${INTERFACE} ${NETWORK} | while read -r line; do&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> host=$(echo "${line}" | awk '{print $1}')&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if ! grep -q "${host}" "${KNOWN_HOSTS}"; then&#13;
      echo "Found a new host: ${host}!"&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> echo "${host}" &gt;&gt; "${KNOWN_HOSTS}"&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> sendemail -f "${FROM_ADDR}" \&#13;
        -t "${TO_ADDR}" \&#13;
        -u "ARP Scan Notification" \&#13;
        -m "A new host was found: ${host}"&#13;
    fi&#13;
  done&#13;
&#13;
  sleep 10&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-8: Using sendemail to receive notifications about new arp-scan discoveries</span></p>&#13;
<p class="TX">First, we set a few variables. We assign the file containing the hosts to look for, <i>172-16-10-hosts.txt</i>, to the <span class="SANS_TheSansMonoCd_W5Regular_11">KNOWN_HOSTS</span> variable, and the target network 172.16.10.0/24 to the <span class="SANS_TheSansMonoCd_W5Regular_11">NETWORK</span> variable. We also set the <span class="SANS_TheSansMonoCd_W5Regular_11">FROM_ADDR</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">TO_ADDR</span> variables, which we’ll use to send the notification email.</p>&#13;
<p class="TX">We then use <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> to run an infinite loop <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This loop won’t end unless we intentionally break out of it. Within the loop, we run <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span> with the options <span class="SANS_TheSansMonoCd_W5Regular_11">-x</span> to display a plain output (so it’s easier to parse) and <span class="SANS_TheSansMonoCd_W5Regular_11">-I</span> to define the network interface <span class="SANS_TheSansMonoCd_W5Regular_11">br_public</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In the same line, we use a <span class="SANS_TheSansMonoCd_W5Regular_11">while read</span> loop to iterate through the output of <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span>. We use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to parse each IP address in the output and assign it to the <span class="SANS_TheSansMonoCd_W5Regular_11">host</span> variable <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we use an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">host</span> variable (which represents a host discovered by <span class="SANS_TheSansMonoCd_W5Regular_11">arp-scan</span>) exists in our <i>hosts</i> file. If it does, we don’t do anything, but if it doesn’t, we write it to the file <span class="CodeAnnotation" aria-label="annotation5">❺</span> and send an email notification <span class="CodeAnnotation" aria-label="annotation6">❻</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">sendemail</span> command. Notice that each line in the <span class="SANS_TheSansMonoCd_W5Regular_11">sendemail</span> command ends with a backslash (<span class="SANS_TheSansMonoCd_W5Regular_11">\</span>). When lines are long, bash allows us to separate them in this way while still treating them as a single command. Breaking long code lines makes them easier to read. At the end of this process, we use <span class="SANS_TheSansMonoCd_W5Regular_11">sleep 10</span> to wait 10 seconds before running this discovery again.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/>If you run this script, you should receive an email whenever a new host is discovered. To properly send email messages, you’ll need to configure a mail transfer agent such as Postfix on the system. Refer to the documentation at <i><a href="https://www.postfix.org/documentation.html">https://www.postfix.org/documentation.html</a></i> for more information on doing so.</p>&#13;
<p class="TX">Note that the continuous network probing the script performs isn’t very stealthy. To probe the network more covertly, try modifying the script in one of the following ways:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Slow the probing so it triggers every few hours or after an arbitrary number of minutes. You can even randomize this interval to make it less predictable.</li>&#13;
<li class="ListBullet">Instead of sending notifications over the network, try writing the results to memory if you’re running the script from within a compromised network.</li>&#13;
<li class="ListBullet">Upload the results to an innocent-looking third-party website. The Living Off Trusted Sites (LOTS) Project at <i><a href="https://lots-project.com">https://lots-project.com</a></i> maintains an inventory of legitimate websites that corporate networks often allow. Attackers commonly use these to carry out activities such as data exfiltration so that their traffic blends with other legitimate traffic, making it harder for analysts to spot.</li>&#13;
</ul>&#13;
<p class="TX">Now that you know the hosts available on the 172.16.10.0/24 network, we recommend removing any unresponsive IP addresses from the <i>172-16-10-hosts.txt</i> file to make your future scans faster.</p>&#13;
<p class="TX">To go even further, we encourage you to experiment with other notification delivery methods, such as Slack, Discord, Microsoft Teams, or any other messaging system you use on a daily basis. Platforms such as Slack, for example, use a <i>webhook</i>, which enables a script to make an HTTP POST request to a special uniform resource locator (URL) to deliver a custom message to a channel of choice.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h1-30"/><span class="SANS_Futura_Std_Bold_B_11">Port Scanning</span></h2>&#13;
<p class="TNI1">Once you’ve discovered hosts on the network, you can run a port scanner to find their open ports and the services they’re running. Let’s explore port scanning by using three tools: Nmap, RustScan, and Netcat.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-63"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nmap</span></h3>&#13;
<p class="TNI1">Nmap allows us to perform port scanning against single targets or multiple targets at the same time. In the following example, we use Nmap to perform a port scan of the domain <i>scanme.nmap.org</i>:</p>&#13;
<pre><code>$ <b>nmap scanme.nmap.org</b></code></pre>&#13;
<p class="TX">Nmap also accepts IP addresses, like so:</p>&#13;
<pre><code>$ <b>nmap 172.16.10.1</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/>When we provide Nmap with no special options on the command line, it will use the following default settings:</p>&#13;
<p class="RunInPara1"><b>Perform a SYN scan </b>Nmap will use a synchronization (SYN) scan to discover open ports on a target. Also called a <i>half-open scan</i>, a <i>SYN scan</i> involves sending a SYN packet and waiting for a response. Nmap won’t complete the full TCP handshake (meaning <span class="SANS_TheSansMonoCd_W5Regular_11">ACK</span> won’t be sent back), which is why we call this scan <i>half open</i>.</p>&#13;
<p class="RunInPara"><b>Scan the top 1,000 ports </b>Nmap will scan only popular ports known to be frequently in use, such as TCP ports 21, 22, 80, and 443. It won’t scan the entire port range of 0–65,534, to conserve resources.</p>&#13;
<p class="RunInPara2"><b>Scan TCP ports </b>Nmap will scan only TCP ports, not User Datagram Protocol (UDP) ports.</p>&#13;
<p class="TX">Nmap allows you to scan multiple targets by passing them on the command line. In the following example, we scan both <i>localhost</i> and <i>scanme.nmap.org</i>:</p>&#13;
<pre><code>$ <b>nmap localhost scanme.nmap.org</b></code></pre>&#13;
<p class="TX">Nmap can also read targets from a given file when passed the <span class="SANS_TheSansMonoCd_W5Regular_11">-iL</span> option. The targets must be separated by newlines. Let’s use the <i>172-16-10-hosts.txt</i> file with Nmap to scan multiple targets:</p>&#13;
<pre><code>$<b> nmap -sV -iL 172-16-10-hosts.txt</b>&#13;
&#13;
<var>--snip--</var>&#13;
Nmap scan report for 172.16.10.1&#13;
Host is up (0.00028s latency).&#13;
PORT   STATE SERVICE VERSION&#13;
22/tcp open  ssh     OpenSSH 9.0p1 Debian 1+b2 (protocol 2.0)&#13;
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel&#13;
<var>--snip--</var>&#13;
&#13;
Nmap scan report for 172.16.10.10&#13;
Host is up (0.00029s latency).&#13;
PORT     STATE SERVICE          VERSION&#13;
8081/tcp open  blackice-icecap?&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">This scan may take some time to complete because of the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">-sV</span> option, which detects the version of services on each port. As you can see, Nmap returns a few IP addresses and their open ports, including their services and even information related to the operating system running on the host. If we wanted to filter, say, only the open ports, we could do by using <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span>:</p>&#13;
<pre><code>$ <b>nmap -sV -iL 172-16-10-hosts.txt | grep open</b>&#13;
&#13;
22/tcp open  ssh&#13;
8081/tcp open  blackice-icecap&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/>21/tcp open  ftp&#13;
80/tcp open  http&#13;
80/tcp open  http&#13;
22/tcp open  ssh&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Nmap is able to identify services on several open TCP ports, such as the File Transfer Protocol (FTP) on port 21, Secure Shell (SSH) on port 22, and HTTP on port 80. Later in this chapter, we’ll take a closer look at each of these services.</p>&#13;
<p class="TX">Nmap also allows you to pass the <span class="SANS_TheSansMonoCd_W5Regular_11">--open</span> flag on the command line to show only the ports that were found open:</p>&#13;
<pre><code>$ <b>nmap -sV -iL 172-16-10-hosts.txt --open</b></code></pre>&#13;
<p class="TX">Kali’s own interface IP (172.16.10.1) will be captured in this port scan, since it is part of the <span class="note_Italic">hosts</span> file. You can use Nmap’s <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--</span><span class="SANS_TheSansMonoCd_W5Regular_11">exclude</span> option to exclude this specific IP when performing a network-wide scan: <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--</span><span class="SANS_TheSansMonoCd_W5Regular_11">exclude</span> <span class="SANS_TheSansMonoCd_W5Regular_11">172.16.10.1</span>. You can also remove it manually from the file for convenience.</p>&#13;
<p class="TX">Use <span class="SANS_TheSansMonoCd_W7Bold_B_11">man nmap</span> to learn more about Nmap’s scanning and filtering capabilities.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-64"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RustScan</span></h3>&#13;
<p class="TNI1">RustScan is becoming more popular in the bug-bounty and penetration-testing spaces because of its speed and extensibility. The following <span class="SANS_TheSansMonoCd_W5Regular_11">rustscan</span> command runs a port scan. The <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> (address) argument accepts a single address or an address range:</p>&#13;
<pre><code>$ <b>rustscan -a 172.16.10.0/24</b>&#13;
&#13;
Open 172.16.10.11:21&#13;
Open 172.16.10.1:22&#13;
Open 172.16.10.13:22&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">RustScan’s output is fairly easy to parse with bash. Lines starting with <span class="SANS_TheSansMonoCd_W5Regular_11">Open</span> indicate that an open port was found on a specific IP address. These are followed by the IP address and port, separated by a colon.</p>&#13;
<p class="TX">When you run RustScan, you may notice that the initial output contains banners, author credits, and additional information not directly related to the scan results. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">-g</span> (greppable) option to show only the scanning information. The following command uses the greppable output mode to scan 172.16.10.0/24 on the first 1,024 ports (also called <i>privileged ports</i>) with the <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> (range) option:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/>$ <b>rustscan -g -a 172.16.10.0/24 -r 1-1024</b>&#13;
&#13;
172.16.10.11 -&gt; [80]&#13;
172.16.10.12 -&gt; [80]&#13;
</code></pre>&#13;
<p class="TX">Now the output is more <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> friendly. To parse it, all we need to do is pass the delimiter <span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span>, which separates the IP address and port, with <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>:</p>&#13;
<pre><code>$ <b>rustscan -g -a 172.16.10.0/24 -r 1-1024 | awk -F'-&gt;' '{print $1,$2}'</b></code></pre>&#13;
<p class="TX">This command outputs two fields: the IP address and the port. To get rid of the <span class="SANS_TheSansMonoCd_W5Regular_11">[]</span> surrounding the port number, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">tr</span> command and the <span class="SANS_TheSansMonoCd_W5Regular_11">-d</span> (delete) argument followed by the characters to delete:</p>&#13;
<pre><code>$ <b>rustscan -g -a 172.16.10.0/24 -r 1-1024 | awk -F'-&gt;' '{print $1,$2}' | tr -d '[]'</b></code></pre>&#13;
<p class="TX">This should return a cleaner output.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">WARNING</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Remember that running port scanners in aggressive modes increases the chances of getting caught, especially if the target implements an intrusion detection system or endpoint detection and response system. Also, if you scan at a rapid pace, you may cause a denial of service as a result of the network flood.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-65"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Netcat</span></h3>&#13;
<p class="TNI1">You can also use Netcat for port scanning activities. People often use this tool when they want to check the state of a single port (such as whether it’s open or closed), but Netcat also enables you to scan multiple ports with a single command. Let’s see how this can be achieved.</p>&#13;
<p class="TX">Run the following command to scan TCP ports 1–1024 on 172.16.10.11:</p>&#13;
<pre><code>$ <b>nc -zv 172.16.10.11 1-1024</b>&#13;
&#13;
<var>--snip--</var>&#13;
&#13;
(UNKNOWN) [172.16.10.11] 80 (http) open&#13;
(UNKNOWN) [172.16.10.11] 21 (ftp) open&#13;
</code></pre>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-z</span> flag (zero input/output, or I/O, mode, which won’t send any data) and the <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> (verbose) flag, followed by the target IP and the port range separated by a hyphen (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>). As you can see in the output, two ports were found open.</p>&#13;
<p class="HeadAExercise"><span id="exe-4"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 4: Organizing Scan Results</span></p>&#13;
<p class="TNI1">Sorting your scan results into categories of interest is often useful. For example, you could dump results for each IP address into a dedicated file or organize the results based on the versions of the software found. In this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/>exercise, you’ll organize your scan results based on port numbers. Write a script that does the following:</p>&#13;
<p class="NLF">  1.  Runs Nmap against hosts in a file</p>&#13;
<p class="NL">  2.  Uses bash to create individual files whose filenames are open ports</p>&#13;
<p class="NLL">  3.  In each file, writes the IP address on which the corresponding port was open</p>&#13;
<p class="TX">At the end of this exercise, you should have a bunch of files, such as <i>port-22.txt</i>, <i>port-80.txt</i>, and <i>port-8080.txt</i>, and in each file, you should see one or more IP addresses at which that port was found to be open. This can be useful when you have a large number of target hosts and want to attack them in clusters by targeting specific protocols associated with given ports.</p>&#13;
<p class="TX">To get you started, <a href="chapter4.xhtml#Lis4-9">Listing 4-9</a> shows an example solution.</p>&#13;
<span id="Lis4-9"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">nmap_to _portfiles.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
HOSTS_FILE="172-16-10-hosts.txt"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> RESULT=$(nmap -iL ${HOSTS_FILE} --open | grep "Nmap scan report\|tcp open")&#13;
&#13;
# Read the nmap output line by line.&#13;
while read -r line; do&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if echo "${line}" | grep -q "report for"; then&#13;
    ip=$(echo "${line}" | awk -F'for ' '{print $2}')&#13;
  else&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> port=$(echo "${line}" | grep open | awk -F'/' '{print $1}')&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> file="port-${port}.txt"&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> echo "${ip}" &gt;&gt; "${file}"&#13;
  fi&#13;
done &lt;&lt;&lt; "${RESULT}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-9: Using bash to organize scan results by port</span></p>&#13;
<p class="TX">We assign the output of the <span class="SANS_TheSansMonoCd_W5Regular_11">nmap</span> command to the variable <span class="SANS_TheSansMonoCd_W5Regular_11">NMAP_RESULT</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In this command, we also filter for specific lines containing the words <span class="SANS_TheSansMonoCd_W5Regular_11">Nmap scan report</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">tcp open</span>. These lines are part of Nmap’s standard port scan output, and they indicate that open ports were found on an IP address.</p>&#13;
<p class="TX">We use a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop to read <span class="SANS_TheSansMonoCd_W5Regular_11">NMAP_RESULT</span> line by line, checking whether each line contains the string <span class="SANS_TheSansMonoCd_W5Regular_11">report for</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This line will hold the IP address where ports are found open. If such a line exists, we assign it to the <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span> variable. Then we parse the line to extract the port that is found open <span class="CodeAnnotation" aria-label="annotation3">❸</span>. At <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we create the <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> variable to hold the file we’ll create on disk with the naming scheme <i>port-NUMBER.txt</i>. Finally, we append the IP address to the file <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Save the script to a file named <i>nmap_to_portfiles.sh</i> and run it. Next, run <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> to see what files were created, and use <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> to view their contents:</p>&#13;
<pre><code>$ <b>ls -l</b>&#13;
&#13;
total 24&#13;
-rw-r--r-- 1 kali kali 3448 Mar  6 22:18 172-16-10-hosts.txt&#13;
-rw-r--r-- 1 kali kali   13 Mar  8 22:34 port-21.txt&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>-rw-r--r-- 1 kali kali   25 Mar  8 22:34 port-22.txt&#13;
<var>--snip--</var>&#13;
&#13;
$ <b>cat port-21.txt</b>&#13;
&#13;
172.16.10.11&#13;
</code></pre>&#13;
<p class="TX">As you’ve seen, Nmap’s standard output format is a little challenging to parse but not impossible.</p>&#13;
<p class="TX">To improve the script shown here, consider using one of Nmap’s additional output format options, which can make parsing easier, especially for scripting purposes. One of these options is the <span class="SANS_TheSansMonoCd_W5Regular_11">-oG</span> flag, for the greppable output format, which is <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> friendly:</p>&#13;
<pre><code>$ <b>nmap -iL 172-16-10-hosts.txt --open -oG -</b>&#13;
&#13;
Host: 172.16.10.1 ()    Status: Up&#13;
Host: 172.16.10.1 ()    Ports: 22/open/tcp//ssh///  Ignored State: closed (999)&#13;
Host: 172.16.10.10 ()   Status: Up&#13;
Host: 172.16.10.10 ()   Ports: 8081/open/tcp//blackice-icecap///  Ignored State: closed (999)&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The output now prints the IP address and its open ports on the same line.</p>&#13;
<p class="TX">You can also tell Nmap to generate Extensible Markup Language (XML) output by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-oX</span> option. Open ports in an XML Nmap output look like the following:</p>&#13;
<pre><code>$ <b>nmap -iL 172-16-10-hosts.txt --open -oX -</b>&#13;
&#13;
<var>--snip--</var>&#13;
&lt;port protocol="tcp" portid="22"&gt;&lt;state state="open" reason="syn-ack" reason_ttl="0"/&gt;&lt;service&#13;
name="ssh" method="table" conf="3"/&gt;&lt;/port&gt;&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">As an extra challenge, try putting together a one-liner bash script that extracts the open ports from XML output.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h2 class="H1" id="sec12"><span id="h1-31"/><span class="SANS_Futura_Std_Bold_B_11">Detecting New Open Ports</span></h2>&#13;
<p class="TNI1">What if you want to monitor a host until it opens a certain port? You may find this useful if you’re testing an environment in which hosts come up and down frequently. We can do this quite easily with a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop.</p>&#13;
<p class="TX">In <a href="chapter4.xhtml#Lis4-10">Listing 4-10</a>, we continuously check whether a port is open, waiting five seconds between each execution. Once we find an open port, we pass this information to Nmap to perform a service discovery and write the output to a file.</p>&#13;
<span id="Lis4-10"/>&#13;
<p class="CodeLabel"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/><span class="codelabel_Italic">port _watchdog.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
LOG_FILE="watchdog.log"&#13;
IP_ADDRESS="${1}"&#13;
WATCHED_PORT="${2}"&#13;
&#13;
service_discovery(){&#13;
  local host&#13;
  local port&#13;
  host="${1}"&#13;
  port="${2}"&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> nmap -sV -p "${port}" "${host}" &gt;&gt; "${LOG_FILE}"&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> while true; do&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> port_scan=$(docker run --network=host -it --rm \&#13;
             --name rustscan rustscan/rustscan:2.1.1 \&#13;
             -a "${IP_ADDRESS}" -g -p "${WATCHED_PORT}")&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if [[-n "${port_scan}"]]; then&#13;
    echo "${IP_ADDRESS} has started responding on port ${WATCHED_PORT}!"&#13;
    echo "Performing a service discovery..."&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if service_discovery "${IP_ADDRESS}" "${WATCHED_PORT}"; then&#13;
      echo "Wrote port scan data to ${LOG_FILE}"&#13;
      break&#13;
    fi&#13;
  else&#13;
    echo "Port is not yet open, sleeping for 5 seconds..."&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> sleep 5&#13;
  fi&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-10: A watchdog script for newly opened ports</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we start an infinite <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop. The loop runs RustScan, passing it the <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> (address) argument containing an IP address we receive on the command line <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We also pass RustScan the <span class="SANS_TheSansMonoCd_W5Regular_11">-g</span> (greppable) option to produce a format that is <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> friendly, and the port option (<span class="SANS_TheSansMonoCd_W5Regular_11">-p</span>) to scan a particular port, which we also receive on the command line and assign the result to the <span class="SANS_TheSansMonoCd_W5Regular_11">port_scan</span> variable.</p>&#13;
<p class="TX">We check the result of the scan <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the result is not empty, we pass the IP address and the port to the <span class="SANS_TheSansMonoCd_W5Regular_11">service_discovery</span> function <span class="CodeAnnotation" aria-label="annotation5">❺</span>, which does an Nmap service-version discovery scan (<span class="SANS_TheSansMonoCd_W5Regular_11">-sV</span>) and writes the result to the logfile <i>watchdog.log</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the port scan fails, which means the port is closed, we sleep for five seconds <span class="CodeAnnotation" aria-label="annotation6">❻</span>. As a result, the process will repeat every five seconds until the port is found open.</p>&#13;
<p class="TX">Save the script and then run it with the following arguments:</p>&#13;
<pre><code>$ <b>./port_watchdog.sh 127.0.0.1 3337</b></code></pre>&#13;
<p class="TX">Since nothing should be running on this port of your localhost, the script should run forever. We can simulate a port-opening event by using Python’s built-in <i>http.server</i> module, which starts a simple HTTP server:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/>$ <b>python3 -m http.server 3337</b></code></pre>&#13;
<p class="TX">Now the <i>port_watchdog.sh</i> script should show the following:</p>&#13;
<pre><code>Port is not yet open, sleeping for 5 seconds...&#13;
127.0.0.1 has started responding on port 3337!&#13;
Performing a service discovery...&#13;
Wrote port scan data to watchdog.log&#13;
</code></pre>&#13;
<p class="TX">You can view the results of the scan by opening the <i>watchdog.log</i> file:</p>&#13;
<pre><code>$ <b>cat watchdog.log</b>&#13;
Starting Nmap (https://nmap.org)&#13;
Nmap scan report for 172.16.10.10&#13;
Host is up (0.000099s latency).&#13;
&#13;
PORT     STATE SERVICE          VERSION&#13;
3337/tcp open  SimpleHTTPServer&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Using this script, you should be able to identify four IP addresses on the network with open ports: 172.16.10.10 (belonging to the <i>p-web-01</i> machine) running 8081/TCP; 172.16.10.11 (belonging to the <i>p-ftp-01</i> machine) running both 21/TCP and 80/TCP; 172.16.10.12 (belonging to the <i>p-web-02</i> machine) running 80/TCP; and 172.16.10.13 (belonging to the <i>p-jumpbox-01</i> machine) running 22/TCP.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-32"/><span class="SANS_Futura_Std_Bold_B_11">Banner Grabbing</span></h2>&#13;
<p class="TNI1">Learning about the software running on a remote server is a crucial step in a penetration test. In the remainder of this chapter, we’ll look at how to identify what’s behind a port and a service—for example, what web server is running on port 8081, and what technologies does it use to serve content to clients?</p>&#13;
<p class="TX"><i>Banner grabbing</i> is the process of extracting the information published by remote network services when a connection is established between two parties. Services often transmit these banners to “greet” clients, which can use the information provided in various ways, such as to ensure they’re connecting to the right target. Banners could also include a system admin message of the day or the service’s specific running version.</p>&#13;
<p class="TX"><i>Passive banner grabbing</i> uses third-party websites to look up banner information. For example, websites such as Shodan (<i><a href="https://shodan.io">https://shodan.io</a></i>), ZoomEye (<i><a href="https://zoomeye.org">https://zoomeye.org</a></i>), and Censys (<i><a href="https://censys.io">https://censys.io</a></i>) perform scans to map the internet, grabbing banners, versions, website pages, and ports, then create an inventory using this data. We can use such websites to look up banner information without ever interacting with the target server ourselves.</p>&#13;
<p class="TX"><i>Active banner grabbing</i> is the opposite; it establishes a connection to a server and interacts with it directly to receive its banner information. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label="86"/>Examples of network services that tend to advertise themselves by using banners include web servers, SSH servers, FTP servers, Telnet servers, network printers, Internet of Things devices, and message queues.</p>&#13;
<p class="TX">Keep in mind that banners are generally free-form text fields, and they can be changed to mislead clients. For example, an Apache web server could present itself as another type of web server, such as nginx. Some organizations even create <i>honeypot servers</i> to lure threat actors (or penetration testers). Honeypots use deception technologies to masquerade as vulnerable servers, but their real purpose is to detect and analyze attacker activity. More often than not, however, banners transmit default settings that system administrators haven’t bothered to change.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-66"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Active Banner Grabbing</span></h3>&#13;
<p class="TNI1">To demonstrate what active banner grabbing looks like, we’ll use the following Netcat command to connect to port 21 (FTP) running on IP address 172.16.10.11 (<i>p-ftp-01</i>):</p>&#13;
<pre><code>$ <b>nc 172.16.10.11 -v 21</b>&#13;
&#13;
172.16.10.11: inverse host lookup failed: Unknown host&#13;
(UNKNOWN) [172.16.10.11] 21 (ftp) open&#13;
220 (<b>vsFTPd 3.0.5</b>)&#13;
</code></pre>&#13;
<p class="TX">As you can see, 172.16.10.11 is running the FTP server vsFTPd version 3.0.5. This information may change if the vsFTPd version gets upgraded or downgraded, or if the system administrator decides to disable banner advertisement completely in the FTP server’s configuration.</p>&#13;
<p class="TX">Netcat is a good example of a tool that doesn’t natively support probing multiple IP addresses. So, knowing a bit of bash scripting can help us out here. <a href="chapter4.xhtml#Lis4-11">Listing 4-11</a> will use Netcat to grab banners on port 21 from multiple hosts saved in a file.</p>&#13;
<span id="Lis4-11"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">netcat_banner _grab.sh</span></p>&#13;
<pre><code>#!/bin/bash&#13;
FILE="${1}"&#13;
PORT="${2}"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if [["$#" -ne 2]]; then&#13;
  echo "Usage: ${0} &lt;file&gt; &lt;port&gt;"&#13;
  exit 1&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if [[! -f "${FILE}"]]; then&#13;
  echo "File: ${FILE} was not found."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if [[! "${PORT}" =~ ^[0-9]+$]]; then&#13;
  echo "${PORT} must be a number."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/><span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> while read -r ip; do&#13;
  echo "Running netcat on ${ip}:${PORT}"&#13;
  result=$(echo -e "\n" | nc -v "${ip}" -w 1 "${PORT}" 2&gt; /dev/null)&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if [[-n "${result}"]]; then&#13;
    echo "==================="&#13;
    echo "+ IP Address: ${ip}"&#13;
    echo "+ Banner: ${result}"&#13;
    echo "==================="&#13;
  fi&#13;
done &lt; "${FILE}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-11: Banner grabbing using Netcat</span></p>&#13;
<p class="TX">This script accepts two parameters on the command line: <span class="SANS_TheSansMonoCd_W5Regular_11">FILE</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PORT</span>. We use an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to check whether two arguments were indeed passed on the command line <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if not, we exit with a status code of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (fail) and print a usage message indicating how to run the script. We then use another <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition with the <span class="SANS_TheSansMonoCd_W5Regular_11">-f</span> test to check whether the file provided by the user actually exists on disk <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we check that the port provided by the user is a number. Anything other than a number will fail. Then we read the host file line by line and run the <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> (Netcat) command on the given port for each <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We use another <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to check whether the command result is not empty <span class="CodeAnnotation" aria-label="annotation5">❺</span>, meaning a port was found open, and print the IP address and data that returned from the server.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h2-67"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting HTTP Responses</span></h3>&#13;
<p class="TNI1">You’ll often find the popular <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> HTTP client on production systems. To perform banner grabbing on HTTP responses, we can use <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to send an HTTP request using the HEAD method. The HEAD method allows us to read response headers without fetching the entire response payload from the web server.</p>&#13;
<p class="TX">Web servers often advertise themselves by setting the <span class="SANS_TheSansMonoCd_W5Regular_11">Server</span> HTTP response header to their name. Sometimes you may also encounter the running version advertised there. The following <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command sends an HTTP HEAD request to the <i>p-web-01</i> machine (172.16.10.10:8081):</p>&#13;
<pre><code>$ <b>curl --head 172.16.10.10:8081</b>&#13;
&#13;
HTTP/1.1 200 OK&#13;
Server: Werkzeug/2.2.3 Python/3.11.1&#13;
<var>--snip--</var>&#13;
Content-Length: 7176&#13;
Connection: close&#13;
</code></pre>&#13;
<p class="TX">As you can see, the server returns a bunch of headers in the response, one of which is the <span class="SANS_TheSansMonoCd_W5Regular_11">Server</span> header. This header reveals that the remote server is running a Python-based web framework named Werkzeug version 2.2.3, powered by Python version 3.11.1.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/><a href="chapter4.xhtml#Lis4-12">Listing 4-12</a> incorporates this <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command into a larger script that prompts the user for information with the bash <span class="SANS_TheSansMonoCd_W5Regular_11">read</span> command, then presents the user with a banner.</p>&#13;
<span id="Lis4-12"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">curl_banner _grab.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
DEFAULT_PORT="80"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> read -r -p "Type a target IP address: " ip&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> read -r -p "Type a target port (default: 80): " port&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if [[-z "${ip}"]]; then&#13;
  echo "You must provide an IP address."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if [[-z "${port}"]]; then&#13;
  echo "You did not provide a specific port, defaulting to ${DEFAULT_PORT}"&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> port="${DEFAULT_PORT}"&#13;
fi&#13;
&#13;
echo "Attempting to grab the Server header of ${ip}..."&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> result=$(curl -s --head "${ip}:${port}" | grep Server | awk -F':' \&#13;
        '{print $2}')&#13;
&#13;
echo "Server header for ${ip} on port ${port} is: ${result}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-12: Extracting the server response header from web servers</span></p>&#13;
<p class="TX">This interactive script asks the user to provide details about the target on the command line. First, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">read</span> command to prompt the user to enter an IP address and assign this value to the <span class="SANS_TheSansMonoCd_W5Regular_11">ip_address</span> variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We then ask the user for the desired port number and save that to the <span class="SANS_TheSansMonoCd_W5Regular_11">port</span> variable <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">ip_address</span> variable length is zero by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-z</span> test and exit if this condition is true. Next, we do the same check on the <span class="SANS_TheSansMonoCd_W5Regular_11">port</span> variable <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This time, if the user didn’t provide a port, we use the default HTTP port, 80 <span class="CodeAnnotation" aria-label="annotation5">❺</span>. At <span class="CodeAnnotation" aria-label="annotation6">❻</span>, we store the output to the <span class="SANS_TheSansMonoCd_W5Regular_11">result</span> variable. We use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to parse the result of <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> and extract the <span class="SANS_TheSansMonoCd_W5Regular_11">Server</span> header.</p>&#13;
<p class="TX">Run the script, and when prompted, provide the IP address 172.16.10.10 and port 8081:</p>&#13;
<pre><code>$ <b>./curl_banner_grab</b>&#13;
&#13;
Type a target IP address: <b>172.16.10.10</b>&#13;
Type a target port (default: 80): <b>8081</b>&#13;
Attempting to grab the Server header of 172.16.10.10...&#13;
Server header for 172.16.10.10 on port 8081 is: Werkzeug/2.2.3 Python/3.11.1&#13;
</code></pre>&#13;
<p class="TX">As you can see, the script returns the correct information from the target IP address and port. If we didn’t specify a port in the terminal, it would have defaulted to port 80. Note that we could have used Netcat to send <span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/>HTTP HEAD requests too, but it’s useful to know more than one method to achieve a given task.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-68"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Nmap Scripts</span></h3>&#13;
<p class="TNI1">Nmap is more than just a port scanner; we can transform it into a full-fledged vulnerability assessment tool. The <i>Nmap Scripting Engine (NSE)</i> allows penetration testers to write scripts in the Lua language to extend Nmap’s capabilities. Nmap comes preinstalled with some Lua scripts, as you can see here:</p>&#13;
<pre><code>$ <b>ls -l /usr/share/nmap/scripts</b>&#13;
&#13;
-rw-r--r-- 1 root root  3901 Oct  6 10:43 acarsd-info.nse&#13;
-rw-r--r-- 1 root root  8749 Oct  6 10:43 address-info.nse&#13;
-rw-r--r-- 1 root root  3345 Oct  6 10:43 afp-brute.nse&#13;
-rw-r--r-- 1 root root  6463 Oct  6 10:43 afp-ls.nse&#13;
-rw-r--r-- 1 root root  3345 Oct  6 10:43 afp-brute.nse&#13;
-rw-r--r-- 1 root root  6463 Oct  6 10:43 afp-ls.nse&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The <i>banner.nse</i> script in the <i>/usr/share/nmap/scripts</i> folder allows you to grab the banners from many hosts simultaneously. The following bash command uses this script to perform a banner grab and service discovery (<span class="SANS_TheSansMonoCd_W5Regular_11">-sV</span>):</p>&#13;
<pre><code>$ <b>nmap -sV --script=banner.nse -iL 172-16-10-hosts.txt</b>&#13;
&#13;
Nmap scan report for 172.16.10.12&#13;
<var>--snip--</var>&#13;
PORT   STATE SERVICE VERSION&#13;
80/tcp open  http    Apache httpd 2.4.54 ((Debian))&#13;
|_http-server-header: Apache/2.4.54 (Debian)&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">When the banner-grabbing script finds a banner, the output line containing that banner will begin with a special character sequence (<span class="SANS_TheSansMonoCd_W5Regular_11">|_</span>). We can filter for this sequence to extract banner information, like so:</p>&#13;
<pre><code>$ <b>nmap -sV --script=banner.nse -iL 172-16-10-hosts.txt | grep "|_banner\||_http-server-header"</b></code></pre>&#13;
<p class="TX">You may have noticed that, in the case of 172.16.10.10 port 8081 (the <i>p-web-01</i> machine), Nmap responds with the following:</p>&#13;
<pre><code>PORT     STATE SERVICE          VERSION&#13;
8081/tcp open  blackice-icecap?&#13;
| fingerprint-strings:&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">blackice-icecap?</span> value indicates that Nmap is unable to definitively discover the identity of the service. But if you look closely at the <span class="SANS_TheSansMonoCd_W5Regular_11">fingerprint -strings</span> dump, you’ll see some HTTP-related information that reveals the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>same response headers we found when banner grabbing manually using <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>. Specifically, note the Werkzeug web server banner. With a bit of googling, you’ll find that this server runs on Flask, a Python-based web framework.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-69"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Operating Systems</span></h3>&#13;
<p class="TNI1">Nmap can also guess the target server’s running operating system by using <i>TCP/IP fingerprinting</i>, which is part of its operating system detection scan. This technique identifies the implementation of the operating system’s TCP/IP stack by crafting packets in various ways and analyzing the returned responses. Each operating system (such as Linux, Windows, and macOS) implements the TCP/IP stack slightly differently, and Nmap analyzes these subtle differences to identify the running system. In some cases, Nmap may also be able to identify the running kernel version.</p>&#13;
<p class="TX">To run an operating system detection scan, use the <span class="SANS_TheSansMonoCd_W5Regular_11">-O</span> flag in Nmap. Note that this scan requires <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> privileges:</p>&#13;
<pre><code>$ <b>sudo nmap -O -iL 172-16-10-hosts.txt</b>&#13;
&#13;
<var>--snip--</var>&#13;
21/tcp open  ftp&#13;
80/tcp open  http&#13;
MAC Address: 02:42:AC:10:0A:0B (Unknown)&#13;
Device type: general purpose&#13;
Running: Linux 4.X|5.X&#13;
OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5&#13;
OS details: Linux 4.15 - 5.6&#13;
Network Distance: 1 hop&#13;
</code></pre>&#13;
<p class="TX">Let’s create a bash script that can parse this output and sort it by IP address and operating system (<a href="chapter4.xhtml#Lis4-13">Listing 4-13</a>).</p>&#13;
<span id="Lis4-13"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">os_detection.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
HOSTS="$*"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if [["${EUID}" -ne 0]]; then&#13;
  echo "The Nmap OS detection scan type (-O) requires root privileges."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if [["$#" -eq 0]]; then&#13;
  echo "You must pass an IP or an IP range"&#13;
  exit 1&#13;
fi&#13;
&#13;
echo "Running an OS Detection Scan against ${HOSTS}..."&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> nmap_scan=$(sudo nmap -O ${HOSTS} -oG -)&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> while read -r line; do&#13;
  ip=$(echo "${line}" | awk '{print $2}')&#13;
  os=$(echo "${line}" | awk -F'OS: ' '{print $2}' | sed 's/Seq.*//g')&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if [[-n "${ip}"]] &amp;&amp; [[-n "${os}"]]; then&#13;
    echo "IP: ${ip} OS: ${os}"&#13;
  fi&#13;
done &lt;&lt;&lt; "${nmap_scan}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 4-13: Parsing an operating system detection scan</span></p>&#13;
<p class="TX">Because this scan requires root privileges, we check for the effective user’s ID <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the user ID isn’t equal to zero, we exit because there is no point in continuing if the user isn’t using root privileges. We then check whether the user passed target hosts as arguments on the command line <span class="CodeAnnotation" aria-label="annotation2">❷</span>. At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we run the Nmap operating system detection scan against these targets, which we’ve assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">HOSTS</span> variable.</p>&#13;
<p class="TX">We use a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop <span class="CodeAnnotation" aria-label="annotation4">❹</span> to iterate through the scan results, parsing each line and assigning the IP address in the output to the <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span> variable. We then parse the line a second time to extract the operating system information from Nmap. We use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to clean the output so it shows only the operating system, removing everything after the word <span class="SANS_TheSansMonoCd_W5Regular_11">Seq</span>. Next, we check whether both the <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">os</span> variables are set <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If they are, this means we’ve parsed the output correctly and can finish the script by printing the IP address and the operating system type.</p>&#13;
<p class="TX">To understand why we parse the output the way we do, using <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span>, run the following command in a separate terminal:</p>&#13;
<pre><code>$ <b>sudo nmap -O 172.16.10.0/24 -oG -</b>&#13;
&#13;
<var>--snip--</var>&#13;
Host: 172.16.10.10 () Ports: 8081/open/tcp//blackice-icecap/// Ignored State: closed (999) OS:&#13;
Linux 4.15 - 5.6   Seq Index: 258   IP ID Seq: All zeros&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">As you can see, the output is separated by whitespaces. The IP address is found immediately after the first space, and the operating system type comes after the word <span class="SANS_TheSansMonoCd_W5Regular_11">OS:</span> but before the word <span class="SANS_TheSansMonoCd_W5Regular_11">Seq</span>, which is why we needed to extract the text between these two. You can do this parsing in other ways too, such as with regular expressions; this is just one way of achieving the task.</p>&#13;
<p class="TX">Use the following command to save and run the script:</p>&#13;
<pre><code>$ <b>sudo ./os_detection.sh 172.16.10.0/24</b>&#13;
&#13;
Running an OS Detection Scan against 172.16.10.0/24...&#13;
IP: 172.16.10.10 OS: Linux 4.15 - 5.6&#13;
IP: 172.16.10.11 OS: Linux 4.15 - 5.6&#13;
IP: 172.16.10.12 OS: Linux 4.15 - 5.6&#13;
IP: 172.16.10.13 OS: Linux 4.15 - 5.6&#13;
IP: 172.16.10.1 OS: Linux 2.6.32&#13;
</code></pre>&#13;
<p class="TX">At this point, we’ve identified a couple of HTTP servers, an FTP server, and an SSH server. Let’s take a closer look at the HTTP servers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h2-70"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Websites and JSON</span></h3>&#13;
<p class="TNI1">Let’s use WhatWeb to see the services running on the web applications in the 172.16.10.0/24 network. We’ll begin by looking at 172.16.10.10 (<i>p-web-01</i>) on port 8081:</p>&#13;
<pre><code>$ <b>whatweb 172.16.10.10:8081</b>&#13;
&#13;
http://172.16.10.10:8081 [200 OK] Country[RESERVED][ZZ], HTML5,&#13;
HTTPServer[Werkzeug/2.3.7 Python/3.11.4], IP[172.16.10.10],&#13;
Python[3.11.4], Title[Menu], Werkzeug[2.3.7], X-UA-Compatible[ie=edge]&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">WhatWeb’s output is printed to standard output by default, separated by spaces and commas. As you can see, it found some information about the technology running on this web server.</p>&#13;
<p class="TX">We could parse this output quite easily with tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span>, but to introduce you to new techniques, we’ll instead explore how to parse <i>JavaScript Object Notation (JSON)</i> output. JSON is a data format composed of keys and values. To parse it, it’s helpful to use a tool like jq to traverse the JSON structure and extract the information we need.</p>&#13;
<p class="TX">WhatWeb can format the output in JSON with the <span class="SANS_TheSansMonoCd_W5Regular_11">--log-json</span> parameter, which expects a filename passed as its value. But what if we want to send the output to the screen without writing it to the disk? We can provide the parameter with the <i>/dev/stdout</i> file, forcing it to send its output to standard output:</p>&#13;
<pre><code>$ <b>whatweb 172.16.10.10:8081 --log-json=/dev/stdout --quiet | jq</b>&#13;
&#13;
[&#13;
  {&#13;
<var>--snip--</var>&#13;
    "plugins": {&#13;
      "Country": {&#13;
        "string": [&#13;
          "RESERVED"&#13;
        ],&#13;
        "module": [&#13;
          "ZZ"&#13;
        ]&#13;
      },&#13;
      "HTML5": {},&#13;
      "HTTPServer": {&#13;
        "string": [&#13;
          "Werkzeug/2.3.7 Python/3.11.4"&#13;
        ]&#13;
      },&#13;
      "IP": {&#13;
        "string": [&#13;
          "172.16.10.10"&#13;
        ]&#13;
      },&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>      "Python": {&#13;
        "version": [&#13;
          "3.11.4"&#13;
        ]&#13;
      },&#13;
      "Title": {&#13;
        "string": [&#13;
          "Menu"&#13;
        ]&#13;
      },&#13;
      "Werkzeug": {&#13;
        "version": [&#13;
          "2.3.7"&#13;
        ]&#13;
      },&#13;
      "X-UA-Compatible": {&#13;
        "string": [&#13;
          "ie=edge"&#13;
        ]&#13;
      }&#13;
    }&#13;
  }&#13;
]&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Now the output is printed to standard output and formatted in JSON. As you can see, we get the same information as when we ran the basic <span class="SANS_TheSansMonoCd_W5Regular_11">whatweb</span> command, without the special formatting.</p>&#13;
<p class="TX">The output is an array of objects, and we can use a tool such as jq to extract the relevant information. For example, let’s extract the value of <span class="SANS_TheSansMonoCd_W5Regular_11">HTTPServer</span>:</p>&#13;
<pre><code>$ <b>whatweb 172.16.10.10:8081 --log-json=/dev/stdout --quiet |</b>&#13;
<b>jq '.[0].plugins.HTTPServer.string[0]'</b>&#13;
&#13;
"Werkzeug/2.3.7 Python/3.11.4"&#13;
</code></pre>&#13;
<p class="TX">The jq syntax might seem a little odd at first, so let’s dissect it. We place the pattern to extract between two single quotes (<span class="SANS_TheSansMonoCd_W5Regular_11">'</span>). Here, we select the first element in the array (<span class="SANS_TheSansMonoCd_W5Regular_11">.[0]</span>), which contains various objects composed of keys and values. Then we select the <span class="SANS_TheSansMonoCd_W5Regular_11">plugins</span> key, followed by the <span class="SANS_TheSansMonoCd_W5Regular_11">HTTPServer</span> key. Within the <span class="SANS_TheSansMonoCd_W5Regular_11">HTTPServer</span> key, there is another key named <span class="SANS_TheSansMonoCd_W5Regular_11">string</span>, which is an array. We select the first element in that array by using <span class="SANS_TheSansMonoCd_W5Regular_11">string[0]</span>, which holds the value <span class="SANS_TheSansMonoCd_W5Regular_11">Werkzeug/2.3.7 Python/3.11.4</span>.</p>&#13;
<p class="TX">Similarly, we can extract the IP address. Just swap the <span class="SANS_TheSansMonoCd_W5Regular_11">HTTPServer</span> key with the <span class="SANS_TheSansMonoCd_W5Regular_11">IP</span> key:</p>&#13;
<pre><code>$ <b>whatweb 172.16.10.10:8081 --log-json=/dev/stdout --quiet | jq '.[0].plugins.IP.string[0]'</b>&#13;
&#13;
"172.16.10.10"&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>Go ahead and run WhatWeb against every web server we’ve identified to see the technologies they run.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h1-33"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, we put bash to use in many ways. We created dynamic target host lists; used multiple tools to perform host discovery, port scanning, and banner grabbing; created an automated script to notify us of newly discovered hosts; and parsed various tool results. In the next chapter, we’ll run vulnerability scanners and fuzzers against these targets.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>