<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_155"/><strong><span class="big">8</span><br/>MISCELLANEOUS UML DIAGRAMS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindents">This chapter finishes up the book’s discussion of UML by describing five additional diagrams that are useful for UML documentation: component, package, deployment, composite structure, and statechart diagrams.</p>
<h3 class="h3" id="lev-8.1"><strong>8.1 Component Diagrams</strong></h3>
<p class="noindent">UML uses <em>component diagrams</em> to encapsulate reusable components such as libraries and frameworks. Though components are generally larger and have more responsibilities than classes, they support much of the same functionality as classes, including:</p>
<ul>
<li class="noindent">Generalization and association with other classes and components</li>
<li class="noindent">Operations</li>
<li class="noindent">Interfaces</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_156"/>UML defines components using a rectangle with the «component» stereo­type (see <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>). Some users (and CASE tools) also use the stereotype «subsystem» to denote components.</p>
<div class="image"><a id="ch8fig1"/><img src="Images/fig8-1.jpg" alt="image" width="214" height="71"/></div>
<p class="figcap"><em>Figure 8-1: A UML component</em></p>
<p class="indent">Components use interfaces (or protocols) to encourage encapsulation and loose coupling. This improves the usability of a component by making its design independent of external objects. The component and the rest of the system communicate via two types of predefined interfaces: provided and required. A <em>provided</em> interface is one that the component provides and that external code can use. A <em>required</em> interface must be provided for the component by external code. This could be an external function that the component invokes.</p>
<p class="indent">As you would expect from UML by now, there’s more than one way to draw components: using <em>stereotype notation</em> (of which there are two versions) or <em>ball and socket notation</em>.</p>
<p class="indent">The most compact way to represent a UML component with interfaces is probably the simple form of stereotype notation shown in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>, which lists the interfaces inside the component.</p>
<div class="image"><a id="ch8fig2"/><img src="Images/fig8-2.jpg" alt="image" width="214" height="236"/></div>
<p class="figcap"><em>Figure 8-2: A simple form of stereotype notation</em></p>
<p class="indent"><a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows a more complete (though bulkier) version of stereotype notation with individual <code>interface</code> objects in the diagram. This option is better when you want to list the individual attributes of the interfaces.</p>
<div class="image"><a id="ch8fig3"/><span epub:type="pagebreak" id="page_157"/><img src="Images/fig8-3.jpg" alt="image" width="538" height="522"/></div>
<p class="figcap"><em>Figure 8-3: A more complete form of stereotype notation</em></p>
<p class="indent">Ball and socket notation provides an alternative to the stereotype notation, using a circle icon (the <em>ball</em>) to represent a provided interface and a half-circle (the <em>socket</em>) to represent required interfaces (see <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>).</p>
<div class="image"><a id="ch8fig4"/><img src="Images/fig8-4.jpg" alt="image" width="588" height="156"/></div>
<p class="figcap"><em>Figure 8-4: Ball and socket notation</em></p>
<p class="indent">The nice thing about ball and socket notation is that connecting components can be visually appealing (see <a href="ch08.xhtml#ch8fig5">Figure 8-5</a>).</p>
<div class="image"><a id="ch8fig5"/><img src="Images/fig8-5.jpg" alt="image" width="511" height="72"/></div>
<p class="figcap"><em>Figure 8-5: Connecting two ball and socket components</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_158"/>As you can see, the required interface of <code>component1</code> connects nicely with the provided interface of <code>component2</code> in this diagram. But while ball and socket notation can be more compact and attractive than the stereotype notation, it doesn’t scale well beyond a few interfaces. As you add more provided and required interfaces, the stereotyped notation is often a better solution.</p>
<h3 class="h3" id="lev-8.2"><strong>8.2 Package Diagrams</strong></h3>
<p class="noindent">A UML package is a container for other UML items (including other packages). A UML package is the equivalent of a subdirectory in a filesystem, a namespace in C++ and C#, or packages in Java and Swift. To define a package in UML, you use a file folder icon with the package name attached (see <a href="ch08.xhtml#ch8fig6">Figure 8-6</a>).</p>
<div class="image"><a id="ch8fig6"/><img src="Images/fig8-6.jpg" alt="image" width="201" height="96"/></div>
<p class="figcap"><em>Figure 8-6: A UML package</em></p>
<p class="indent">For a more concrete example, let’s return to the pool monitor application. One useful package might be <code>sensors</code>, to contain classes/objects associated with, say, pH and salinity sensors. <a href="ch08.xhtml#ch8fig7">Figure 8-7</a> shows what this package might look like in UML. The <em>+</em> prefix on the <code>phSensors</code> and <code>saltSensor</code> objects indicates that these are public objects accessible outside the package.<sup><a href="ch19_footnote.xhtml#ch08fn1" id="ch08fn1a">1</a></sup></p>
<div class="image"><a id="ch8fig7"/><img src="Images/fig8-7.jpg" alt="image" width="202" height="108"/></div>
<p class="figcap"><em>Figure 8-7: The <span class="codeitalic">sensors</span> package</em></p>
<p class="indent">To reference (public) objects outside of a package, you use a name of the form <span class="codeitalic">packageName</span><code>::</code><span class="codeitalic">objectName</span>. For example, outside the <code>sensors</code> package you would use <code>sensors::pHSensor</code> and <code>sensors::saltSensor</code> to access the internal objects. If you have one package nested inside another, you could access objects in the innermost package using a sequence like <span class="codeitalic">outsidePackage</span><code>::</code><span class="codeitalic">internalPackage</span><code>::</code><span class="codeitalic">object</span>. For example, suppose you have two nuclear power channels named NP and NPP (from the use case examples in <a href="ch04.xhtml">Chapter 4</a>). You could create a package named <code>instruments</code> to hold the two packages <code>NP</code> and <code>NPP</code>. The <code>NP</code> and <code>NPP</code> packages could contain the objects directly associated with the NP and NPP instruments (see <a href="ch08.xhtml#ch8fig8">Figure 8-8</a>).</p>
<div class="image"><a id="ch8fig8"/><span epub:type="pagebreak" id="page_159"/><img src="Images/fig8-8.jpg" alt="image" width="381" height="143"/></div>
<p class="figcap"><em>Figure 8-8: Nested packages</em></p>
<p class="indent">Note that the <code>NP</code> and <code>NPP</code> packages both contain functions named <code>calibrate()</code> and <code>pctPwr()</code>. There is no ambiguity about which function you’re calling because outside these individual packages you have to use <em>qualified names</em> to access these functions. For example, outside the <code>instruments</code> package you’d have to use names like <code>instruments::NP::calibrate</code> and <code>instruments::NPP::calibrate</code> so that there is no confusion.</p>
<h3 class="h3" id="lev-8.3"><strong>8.3 Deployment Diagrams</strong></h3>
<p class="noindent">Deployment diagrams present a physical view of a system. Physical objects include PCs, peripherals like printers and scanners, servers, plug-in interface boards, and displays.</p>
<p class="indent">To represent physical objects, UML uses <em>nodes</em>, a 3D box image. Inside the box you place the stereotype «device» plus the name of the node. <a href="ch08.xhtml#ch8fig9">Figure 8-9</a> provides a simple example from the DAQ data acquisition system. It shows a host PC connected to a DAQ_IF and a Plantation Productions’ PPDIO96 96-channel digital I/O board.</p>
<div class="image"><a id="ch8fig9"/><img src="Images/fig8-9.jpg" alt="image" width="422" height="235"/></div>
<p class="figcap"><em>Figure 8-9: A deployment diagram</em></p>
<p class="indent">One thing missing from this figure is the actual software installed on the system. In this system, there are likely to be at least two application programs running: a program running on the host PC that communicates with the DAQ_IF module (let’s call it <em>daqtest.exe</em>) and the firmware program (<em>frmwr.hex</em>) running on the DAQ_IF board (which is likely the true software system the deployment diagram describes). <a href="ch08.xhtml#ch8fig10">Figure 8-10</a> shows an expanded version with small icons denoting the software installed on the machines. Deployment diagrams use the stereotype «artifact» to denote binary machine code.</p>
<div class="image"><a id="ch8fig10"/><span epub:type="pagebreak" id="page_160"/><img src="Images/fig8-10.jpg" alt="image" width="465" height="256"/></div>
<p class="figcap"><em>Figure 8-10: An expanded deployment diagram</em></p>
<p class="indent">Note that the PPDIO96 board is directly controlled by the DAQ_IF board: there is no CPU on the PPDIO96 board and, therefore, there is no software loaded onto the PPDIO96.</p>
<p class="indent">There is actually quite a bit more to deployment diagrams, but this discussion will suffice for those we’ll need in this book. If you’re interested, see “<a href="ch08.xhtml#lev-8.7">For More Information</a>” on <a href="ch08.xhtml#page_165">page 165</a> for references that explain deployment diagrams in more detail.</p>
<h3 class="h3" id="lev-8.4"><strong>8.4 Composite Structure Diagrams</strong></h3>
<p class="noindent">In some instances, class and sequence diagrams cannot accurately depict the relationships and actions between components in some classes. Consider <a href="ch08.xhtml#ch8fig11">Figure 8-11</a>, which illustrates a class for the PPDIO96.</p>
<div class="image"><a id="ch8fig11"/><img src="Images/fig8-11.jpg" alt="image" width="388" height="179"/></div>
<p class="figcap"><em>Figure 8-11: PPDIO96 class composition</em></p>
<p class="indent">This class composition diagram tells us that the <code>PPDIO96</code> class contains (is composed of) two subclasses: <code>portInitialization</code> and <code>writePort</code>. What it does <em>not</em> tell us is how these two subclasses of <code>PPDIO96</code> interact with each other. For example, when you initialize a port via the <code>portInitialization</code> class, perhaps the <code>portInitialization</code> class also invokes a method in <code>writePort</code> to initialize that port with some default value (such as <code>0</code>). The bare class <span epub:type="pagebreak" id="page_161"/>diagrams don’t show this, nor should they. Having <code>portIntialization</code> write a default value via a <code>writePort</code> invocation is probably only one of many different operations that could arise within <code>PPDIO96</code>. Any attempt to show allowed and possible internal communications within <code>PPDIO96</code> would produce a very messy, illegible diagram.</p>
<p class="indent">Composite structure diagrams provide a solution by focusing only on those communication links of interest (it could be just one communication link, or a few, but generally not so many that the diagram becomes incomprehensible).</p>
<p class="indent">A first (but problematic) attempt at a composite structure diagram is shown in <a href="ch08.xhtml#ch8fig12">Figure 8-12</a>.</p>
<div class="image"><a id="ch8fig12"/><img src="Images/fig8-12.jpg" alt="image" width="388" height="179"/></div>
<p class="figcap"><em>Figure 8-12: Attempted composite structure diagram</em></p>
<p class="indent">The problem with this diagram is that it doesn’t explicitly state which <code>writePort</code> object <code>portInitialization</code> is communicating with. Remember, classes are just generic <em>types</em>, whereas the actual communication takes place between explicitly instantiated <em>objects</em>. In an actual system the intent of <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> is probably better conveyed by <a href="ch08.xhtml#ch8fig13">Figure 8-13</a>.</p>
<div class="image"><a id="ch8fig13"/><img src="Images/fig8-13.jpg" alt="image" width="420" height="183"/></div>
<p class="figcap"><em>Figure 8-13: Instantiated composite structure diagram</em></p>
<p class="indent">However, neither <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> nor <a href="ch08.xhtml#ch8fig13">Figure 8-13</a> implies that the <code>port</code><code>Initialization</code> and <code>writePort</code> instantiated objects belong specifically to the <code>PPDIO96</code> object. For example, if there are two sets of <code>PPDIO96</code>, <code>portInitialization</code>, and <code>writePort</code> objects, the topology in <a href="ch08.xhtml#ch8fig14">Figure 8-14</a> is perfectly valid based on the class diagram in <a href="ch08.xhtml#ch8fig12">Figure 8-12</a>.</p>
<div class="image"><a id="ch8fig14"/><span epub:type="pagebreak" id="page_162"/><img src="Images/fig8-14.jpg" alt="image" width="650" height="271"/></div>
<p class="figcap"><em>Figure 8-14: Weird, but legal, communication links</em></p>
<p class="indent">In this example, <code>i1</code> (which belongs to object <code>d1</code>) calls <code>w2</code> (which belongs to object <code>d2</code>) to write the digital value to its port; <code>i2</code> (which belongs to <code>d2</code>) calls <code>w1</code> to write its initial value to its port. This probably isn’t what the original designer had in mind, even though the generic composition structure diagram in <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> technically allows it. Although any reasonable programmer would immediately realize that <code>i1</code> should be invoking <code>w1</code> and <code>i2</code> should be invoking <code>w2</code>, the composite structure diagram doesn’t make this clear. Obviously, we want to eliminate as much ambiguity as possible in our designs.</p>
<p class="indent">To correct this shortcoming, UML 2.0 provides (true) composite structure diagrams that incorporate the member attributes directly within the encapsulating class diagram, as shown in <a href="ch08.xhtml#ch8fig15">Figure 8-15</a>.</p>
<div class="image"><a id="ch8fig15"/><img src="Images/fig8-15.jpg" alt="image" width="451" height="122"/></div>
<p class="figcap"><em>Figure 8-15: Composite structure diagram</em></p>
<p class="indent">This diagram makes it clear that an instantiated object of <code>PPDIO96</code> will constrain the communication between the <code>portInitialization</code> and <code>writePort</code> classes to objects associated with that same instance.</p>
<p class="indent">The small squares on the sides of the <code>portInitialization</code> and <code>writePort</code> are <em>ports</em>. This term is unrelated to the <code>writePort</code> object or hardware ports on the PPDIO96 in general; this is a UML concept referring to an interaction point between two objects in UML. Ports can appear in composite structure diagrams and in component diagrams (see “<a href="ch08.xhtml#lev-8.1">Component Diagrams</a>” on <a href="ch08.xhtml#page_155">page 155</a>) to specify required or provided interfaces to an object. In <a href="ch08.xhtml#ch8fig15">Figure 8-15</a> the port on the <code>portInitialization</code> side is (probably) a required interface and the port on the <code>writePort</code> side of the connection is (probably) a provided interface.</p>
<div class="note">
<p class="notet"><strong><span class="notes">Note</span></strong></p>
<p class="notep"><em>On either side of a connection, one port will generally be a required interface and the other will be a provided interface.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_163"/>In <a href="ch08.xhtml#ch8fig15">Figure 8-15</a> the ports are <em>anonymous</em>. However, in many diagrams (particularly where you are listing the interfaces to a system) you can attach names to the ports (see <a href="ch08.xhtml#ch8fig16">Figure 8-16</a>).</p>
<div class="image"><a id="ch8fig16"/><img src="Images/fig8-16.jpg" alt="image" width="484" height="123"/></div>
<p class="figcap"><em>Figure 8-16: Named ports</em></p>
<p class="indent">You can also use the ball and socket notation to indicate which side of a communication link is the provider and which side has the required interface (remember, the socket side denotes the required interface; the ball side denotes the provided interface). You can even name the communication link if you so desire (see <a href="ch08.xhtml#ch8fig17">Figure 8-17</a>). A typical communication link takes the form <span class="codeitalic">name</span><code>:</code><span class="codeitalic">type</span> where <span class="codeitalic">name</span> is a unique name (within the component) and <span class="codeitalic">type</span> is the type of the communication link.</p>
<div class="image"><a id="ch8fig17"/><img src="Images/fig8-17.jpg" alt="image" width="484" height="123"/></div>
<p class="figcap"><em>Figure 8-17: Indicating provided and required interfaces</em></p>
<h3 class="h3" id="lev-8.5"><strong>8.5 Statechart Diagrams</strong></h3>
<p class="noindent">UML statechart (or state machine) diagrams are very similar to activity diagrams in that they show the flow of control through a system. The main difference is that a statechart diagram simply shows the various states possible for a system and how the system transitions from one state to the next.</p>
<p class="indent">Statechart diagrams do not introduce any new diagramming symbols; they use existing elements from activity diagrams—specifically the start state, end state, state transitions, state symbols, and (optionally) decision symbols, as shown in <a href="ch08.xhtml#ch8fig18">Figure 8-18</a>.</p>
<div class="image"><a id="ch8fig18"/><img src="Images/fig8-18.jpg" alt="image" width="443" height="227"/></div>
<p class="figcap"><em>Figure 8-18: Elements of a statechart diagram</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_164"/>A given statechart diagram will have exactly one <em>start</em> <em>state</em> symbol; this is where activity begins. The state symbols in a statechart diagram always have an associated state name (which, obviously, indicates the current state). A statechart diagram can have more than one <em>end state</em> symbol, which is a special state that marks the end of activity (entry into any end state symbol stops the state machine). Transition arrows show the flow between states in the machine (see <a href="ch08.xhtml#ch8fig19">Figure 8-19</a>).</p>
<div class="image"><a id="ch8fig19"/><img src="Images/fig8-19.jpg" alt="image" width="224" height="305"/></div>
<p class="figcap"><em>Figure 8-19: A simple statechart diagram</em></p>
<p class="indent">Transitions usually occur in response to some external events, or triggers, in the system. <em>Triggers</em> are stimuli that cause the transition from one state to another in the system. You attach guard conditions to a transition, as shown in <a href="ch08.xhtml#ch8fig19">Figure 8-19</a>, to indicate the trigger that causes the transition to take place.</p>
<p class="indent">Transition arrows have a head and a tail. When activity occurs in a statechart diagram, transitions always occur from the state attached to the arrow tail to the state pointed at by the arrowhead.</p>
<p class="indent">If you are in a particular state and some event occurs for which there is no transition out of that state, the state machine ignores that event.<sup><a href="ch19_footnote.xhtml#ch08fn2" id="ch08fn2a">2</a></sup> For example, in <a href="ch08.xhtml#ch8fig19">Figure 8-19</a>, if you’re already in the “System is active” state and an <code>on</code> <code>button</code> event occurs, the system remains in the “System is active” state.</p>
<p class="indent">If two transitions out of a state have the same guard condition, then the state machine is <em>nondeterministic</em>. This means that the choice of transition arrow is arbitrary (and could be randomly chosen). Nondeterminism is a bad thing in UML statechart diagrams, as it introduces ambiguity. When creating UML statechart diagrams, you should always strive to keep them deterministic by ensuring that the transitions all have mutually exclusive guard conditions. In theory, you should have exactly one exiting transition from a state for every possible event that could occur; however, most system <span epub:type="pagebreak" id="page_165"/>designers assume that, as mentioned before, if an event occurs for which there is no exit transition, then the state ignores that event.</p>
<p class="indent">It is possible to have a transition from one state to another without a guard condition attached; this implies that the system can arbitrarily move from the first state (at the transition’s tail) to the second state (at the head). This is useful when you’re using decision symbols in a state machine (see <a href="ch08.xhtml#ch8fig20">Figure 8-20</a>). Decision symbols aren’t necessary in a statechart diagram—just as for activity diagrams, you could have multiple transitions directly out of a state (such as the “System is active” state in <a href="ch08.xhtml#ch8fig20">Figure 8-20</a>)—but you can sometimes clean up your diagrams by using them.</p>
<div class="image"><a id="ch8fig20"/><img src="Images/fig8-20.jpg" alt="image" width="448" height="415"/></div>
<p class="figcap"><em>Figure 8-20: A decision symbol in a statechart</em></p>
<h3 class="h3" id="lev-8.6"><strong>8.6 More UML</strong></h3>
<p class="noindent">As has been a constant theme, this is but a brief introduction to UML. There are more diagrams and other features, such as the <em>Object Constraint Language (OCL)</em>, that this book won’t use, so this chapter doesn’t discuss them. However, if you’re interested in using UML to document your software projects, you should spend more time learning about it. See the next section for recommended reading.</p>
<h3 class="h3" id="lev-8.7"><strong>8.7 For More Information</strong></h3>
<p class="ref">Bremer, Michael. <em>The User Manual Manual: How to Research, Write, Test, Edit, and Produce a Software Manual</em>. Grass Valley, CA: UnTechnical Press, 1999. A sample chapter is available at <em><a href="http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf">http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf</a></em>.</p>
<p class="ref"><span epub:type="pagebreak" id="page_166"/>Larman, Craig. <em>Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development</em>. 3rd ed. Upper Saddle River, NJ: Prentice Hall, 2004.</p>
<p class="ref">Miles, Russ, and Kim Hamilton. <em>Learning UML 2.0: A Pragmatic Introduction to UML</em>. Sebastopol, CA: O’Reilly Media, 2003.</p>
<p class="ref">Pender, Tom. <em>UML Bible</em>. Indianapolis: Wiley, 2003.</p>
<p class="ref">Pilone, Dan, and Neil Pitman. <em>UML 2.0 in a Nutshell: A Desktop Quick Reference</em>. 2nd ed. Sebastopol, CA: O’Reilly Media, 2005.</p>
<p class="ref">Roff, Jason T. <em>UML: A Beginner’s Guide</em>. Berkeley, CA: McGraw-Hill Education, 2003.</p>
<p class="ref">Tutorials Point. “UML Tutorial.” <em><a href="https://www.tutorialspoint.com/uml/">https://www.tutorialspoint.com/uml/</a></em>.</p>
</div>



  </body></html>