- en: '**7**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FORENSIC IMAGE MANAGEMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers various aspects of managing forensic image files after acquisition.
    Disk images are enormous compared to typical files on a disk, and moving, copying,
    and converting large image files can be cumbersome and time-consuming. You’ll
    learn a number of techniques for managing large image files to help overcome various
    challenges. These techniques include compressing and splitting images for easier
    handling, securing images with encryption, and converting images between formats.
    In addition, I describe procedures for read-only mounting of an image for safe
    local browsing and demonstrate forensic cloning (or disk duplication). I also
    discuss the secure, reliable storage and network transfer of large image files.
    The chapter ends with a description of secure wiping and disposal of images and
    files. I’ll begin with the topic of managing image compression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage Image Compression**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Raw disk images are always the same size as the total number of sectors they
    contain. The number of files or amount of data on the drive is irrelevant and
    does not affect the size of an uncompressed raw image. With the current widespread
    use of multiterabyte disks, maneuvering images within time and disk capacity constraints
    can be a challenge. Even simply copying an image can take many hours to complete.
    You can reduce this problem somewhat by keeping images compressed.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing images in a forensic context involves sector-by-sector compression
    of the entire drive (as opposed to compressing each file on the disk). Disks with
    many gigabytes or terabytes of space that have never been written to over the
    life of the drive will compress better, because much of the drive still consists
    of untouched sectors filled with zeros. Well-used disks won’t compress as well
    if most sectors on the drive have been allocated over the lifetime of the drive
    and still contain residual data. Disk images with large numbers of audio and video
    files will compress poorly as well, because these files are already compressed
    with their own algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to choose the most appropriate and efficient compression tool
    and technique. Some tools might have file size limitations, either for the original
    source file or the compressed destination file. Other tools may be inefficient
    or use temporary files during compression, causing memory exhaustion or creating
    disk space issues. To solve some of these problems when you’re performing compression
    activity, you can use piping and redirection.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful features of working with a compressed forensic image
    is the ability to use forensic tools against it without having to uncompress the
    entire image. But this is problematic with some compression tools, because they’re
    not able to seek within a compressed file. *Seeking* allows a program to randomly
    access any point in a file. Forensic formats are designed to allow analysis programs
    on-the-fly, random access to compressed images. The popular forensic formats all
    support image compression, which usually occurs during acquisition, although not
    all tools compress by default.
  prefs: []
  type: TYPE_NORMAL
- en: '***Standard Linux Compression Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Commonly used compression tools in the open source world today are zip, gzip,
    and bzip (version 1 or 2). The examples in this section use gzip, but you can
    use other compression tools as well. To attempt better compression at the expense
    of time and CPU cycles, you can adjust the level of compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given enough disk space, you can simply compress a disk image file in place,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the file *image.raw.gz* and deletes the original file on
    completion. Enough space needs to be available for the compressed and uncompressed
    files to coexist during the compression process. The same applies for uncompressing
    files using gunzip.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also compress images on the fly during acquisition using piping and
    redirection. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here the input file is a raw disk device. Not specifying an output file for
    dcfldd sends the image data stream to stdout, which is piped into gzip, which
    is finally redirected into a compressed file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compressed file can be uncompressed to a raw image file, where you can
    use forensic tools to directly operate on it. Alternatively, you can pipe an uncompressed
    stream into some programs using stdout and stdin. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here zcat uncompresses the image and pipes it into a program to produce a sha256
    cryptographic hash. It’s worth noting that the gzip file format contains additional
    metadata, such as a creation timestamp, original filename, and other information.
    The hash of a gzip container (*image.raw.gz*) will be different each time it’s
    created, even though the hash of the compressed file inside will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: '***EnCase EWF Compressed Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ewfacquire tool provides flags to control compression during the acquisition
    process. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `-c` flag can specify a compression algorithm together
    with a compression level. Here, the algorithm was bzip2 configured with the best
    possible compression level. Because only EWFv2 formats support bzip2, the format
    version `encase7-v2` was specified as a parameter. Note that ewftools needs to
    be compiled with bzip2 support.^([1](footnote.xhtml#fn39))
  prefs: []
  type: TYPE_NORMAL
- en: '***FTK SMART Compressed Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command line ftkimager tool supports compressed images during acquisition,
    as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here the `--s01` flag specifies the creation of a SMART ew-compressed image,
    and the `--compress` flag sets the highest compression level. You can use the
    `--help` flag to get more information about compression options for ftkimager.
  prefs: []
  type: TYPE_NORMAL
- en: '***AFFlib Built-In Compression***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although AFFv3 has been deprecated (*[http://forensicswiki.org/wiki/AFF](http://forensicswiki.org/wiki/AFF)*)
    and the use of aimage is discouraged (*[http://forensicswiki.org/wiki/Aimage](http://forensicswiki.org/wiki/Aimage)*),
    aimage’s use of AFFv3 compression is mentioned here for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates imaging a disk using aimage and specifying
    the LZMA compression algorithm (rather than the zlib default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Sleuth Kit forensics software provides integrated support for AFFlib compressed
    images. AFFv4 introduces the aff4imager tool, which adds additional features.
    This can be fournd at *[https://github.com/google/aff4/](https://github.com/google/aff4/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***SquashFS Compressed Evidence Containers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that using SquashFS as a forensic evidence container was described in
    [Chapter 6](ch06.xhtml#ch06). When you’re creating a SquashFS file, you can tune
    several compression parameters. Three compression algorithms (gzip, lzo, xz) are
    available, various metadata from SquashFS can be compressed (inode table, extended
    attributes), and other tweaks can be made as well. See the squashfs(1) manual
    page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, a raw image file was converted to a compressed SquashFS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-comp` flag sets the compression algorithm to lzo (gzip is the default),
    and the `-noI` flag prevents compression of the inodes (of the SquashFS container,
    not the evidence image).
  prefs: []
  type: TYPE_NORMAL
- en: The sfsimage shell script manages the creation of SquashFS forensic evidence
    containers with a few added forensic features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of compression is fundamental when you’re working with large forensic
    images. However, even compressed images can still be very large to manage. There
    is another method that makes this process easier: you can split forensic images
    into multiple smaller pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage Split Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Managing acquired disk images can be problematic due to their large file sizes.
    Breaking an image into smaller, easier-to-handle pieces can help solve this problem.
    Consider the following examples in which a split image can be beneficial:'
  prefs: []
  type: TYPE_NORMAL
- en: • Network transfers over unstable connections can be done with multiple smaller
    downloads using split images.
  prefs: []
  type: TYPE_NORMAL
- en: • A large image might exceed the maximum file size for a software tool. Splitting
    the image offers a workaround.
  prefs: []
  type: TYPE_NORMAL
- en: • Storage media, such as tapes, CDs, or DVDs, have a fixed maximum capacity.
    Split images allow you to use a set of these media.
  prefs: []
  type: TYPE_NORMAL
- en: • Some filesystems (notably FAT) have a relatively small maximum file size.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of split images in digital forensics is for the transfer
    and storage of evidence. Historically, this has been done by burning the image
    to a set of CDs or DVDs.
  prefs: []
  type: TYPE_NORMAL
- en: '***The GNU split Command***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Standard Unix and Linux systems have the split tool for breaking a large file
    into several smaller files. The following example uses the `split` command to
    break an existing image into DVD-sized chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` flag specifies that a numeric extension should be added to *image.raw.*
    (note the trailing dot); the `-b` flag specifies the size of the chunks made from
    the *image.raw* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a combination of piping between several tools, you can combine compressing
    and splitting during acquisition to save time and space. Here’s an example of
    a single command acquiring an image with dd, compressing it with gzip, and splitting
    it into CD-sized chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `split` command’s input file is *-*, which specifies stdin, and it splits
    the compressed byte stream into pieces. It’s important to note that the parts
    are not individually gzipped and cannot be individually uncompressed. The split
    parts must be reassembled before they can be uncompressed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Split Images During Acquisition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can split an imaged hard disk into parts during the acquisition process
    rather than in a separate step at a later date. Before acquiring a large disk,
    consider whether you might need a split image in the future and what fragment
    size would make the most sense. Starting with the right split image could save
    you time and disk space during an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Split images are common in digital forensics and therefore are well supported
    by forensic acquisition and analysis tools. Typically, flags can set the fragment
    size and customize the extension of a split image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dcfldd tool provides built-in splitting functionality. For example, if
    you’ll later transfer an image to a third party via a set of 16GB USB sticks,
    you can use dcfldd to acquire an image using the `split=16G` flag before the output
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The default extension is a three-digit number appended to the output filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the dc3dd tool, you can split images during acquisition by specifying
    the output size with `ofsz=`. The file extensions are numerical, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Be sure the file extension has enough zeros, or else dc3dd will fail to complete
    and generate an error message, such as `[!!] file extensions exhausted for image.raw.0`.
    The last file in the set will usually be smaller than the others (unless the image
    size is perfectly divisible by the split file size).
  prefs: []
  type: TYPE_NORMAL
- en: 'EnCase tools typically default to splitting images during acquisition. You
    can acquire a disk to a split EnCase image using ewfacquire by specifying a maximum
    segment file size using the `-S` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The commercial EnCase forensic suite can then use these images directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ftkimager tool provides the `--frag` flag to save an image into parts during
    acquisition, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here the disk is acquired with a maximum fragment size set at 20GB, and the
    format is a SMART compressed image. Notice the addition of the **.txt* file containing
    the metadata. Unlike some forensic formats, this is not embedded into FTK split
    files created by ftkimager.
  prefs: []
  type: TYPE_NORMAL
- en: '***Access a Set of Split Image Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Forensic tools, such as Sleuth Kit, provide support for operating directly
    on a set of split images without needing to reassemble them first. To list the
    supported images in Sleuth Kit, use the `-i list` flag with any Sleuth Kit image-processing
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there is support for split raw images (including Unix split
    files), split AFF images, and split EnCase files (though this is not explicitly
    stated, split EnCase files are supported). Some of these image format types might
    need to be explicitly included when compiling the Sleuth Kit software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an EWF image is split into 54 pieces. Running the
    `img_stat` command on the first file provides information about the complete set
    of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using various tools, you can operate on split images directly. Most Sleuth Kit
    commands will work with a set of split raw files when you specify the first file
    of the split image type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of Sleuth Kit will automatically check for sets of split files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier versions of Sleuth Kit may require that you specify a split image type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a set of split files is recognized, the `img_stat` command
    will show the total bytes recognized, and for raw types, the byte offset ranges
    for each piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An alternative method for determining whether split files are supported is to
    run the command or tool with `strace -e open` and see if it opens each of the
    split file pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting files and working with a set of split files are useful, but sometimes
    you need to reassemble them into a single image. This is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reassemble a Split Image***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reassembling split forensic formats is generally not needed, because tools that
    are compatible with a particular forensic format (EWF, SMART, or AFF) should support
    split files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because no header or meta information is contained in a raw image, reassembly
    is simply a matter of concatenating the set of image fragments into a single image.
    Doing this carefully should be a two-step process, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `ls -1` flag will list the files recognized by the shell-globbing pattern.
    Be sure to confirm that this is a complete and ordered list before using it to
    concatenate the files into a single image. If split pieces are missing or the
    file order is wrong, the assembled parts will not create the correct forensic
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve received a stack of DVDs, each containing a fragment of a compressed
    raw image, you can reassemble them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, DVDs are repeatedly inserted and mounted on `/dvd`, and split parts are
    added until the image file is restored. Note that `>` in the initial cat command
    creates the image file, and `>>` in the subsequent commands appends the data (not
    overwriting it). After all parts have been appended to the destination file, the
    cryptographic hash of the uncompressed image should match the one taken during
    acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also uncompress and assemble a set of split files from a compressed
    image by piping all the split files into zcat and redirecting the output to a
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful method provided by AFFlib allows for the *virtual reassembly* of a
    set of fragments using a FUSE filesystem. The affuse tool can present a set of
    split files as a fully assembled raw image file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, a directory full of raw files is represented as a single disk image file
    and is found in the */mnt* virtual filesystem. You can directly operate on this
    raw file using forensic tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verify the Integrity of a Forensic Image**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Verifying the cryptographic hash of an image is fundamental to performing digital
    forensics, and it’s the basis of preserving digital evidence. This section provides
    examples of verifying an image’s cryptographic hashes and signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the preservation of evidence involves confirming that a current cryptographic
    hash of an image is identical to a hash taken at an earlier point in time. You
    can use hashing to verify a successful operation on a disk or image (acquisition,
    conversion, transfer, backup, and so on). You can also use it to verify that a
    disk or image file has not been tampered with over a longer period of time (months
    or even years).
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for hashing (procedures and algorithms) depend on the legal
    jurisdiction where they are used and on the organizational policies governing
    a forensic lab. Thus, no hashing recommendations are provided here.
  prefs: []
  type: TYPE_NORMAL
- en: '***Verify the Hash Taken During Acquisition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After acquiring a disk, if you need to validate the acquisition hash, it’s
    a simple (but possibly time-consuming) task of piping the contents of the disk
    into a cryptographic hashing program. Using a different program to validate a
    disk’s hash provides an independent verification at the tool level. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the img_stat output indicates the MD5 acquisition hash recorded by an
    EnCase imaging tool. A second tool, regular dd, is then used to recalculate the
    hash from the raw disk device. In this example, the two MD5 hashes match, confirming
    that the evidence integrity has been preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '***Recalculate the Hash of a Forensic Image***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each of the forensic formats and the dd-based forensic tools can record or
    log a hash value of a disk image. To validate the recorded hash, you can recalculate
    the disk image’s hash. In the following example, the hash was recorded during
    acquisition with dc3dd and stored in the *hashlog.txt*. The hash can be verified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The hashes match, confirming that the evidence file and the hash log are consistent
    and thus indicating that the evidence integrity has been preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example validates the image stored in the metadata of the EnCase
    format. In this example, a dedicated tool, ewfverify, is used to validate the
    hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the recalculated hash matches, confirming the consistency of the EWF image
    file. This tool will automatically validate the hash of a set of split files in
    the EnCase forensic format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The affinfo tool performs similar validity checking for AFF files. In this
    example, the SHA1 hash is validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This output confirms that the hash of the image contained inside the AFF file
    is the same as the hash recorded in the AFF metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cryptographic Hashes of Split Raw Images***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Calculating the cryptographic hash of a set of raw split files is straightforward,
    and you can do this by piping the concatenated parts into a hashing program. This
    example calculates the sha256 hash of a set of split raw files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example assumes the filenames of the parts can be sorted in the correct
    order (can be verified in this example with `ls -1 image.raw.*`). The `cat` command
    is necessary here, as it is concatenating (assembling) all of the pieces before
    they are piped into sha256sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the cryptographic hash of an image that has been compressed
    and split into pieces by forming a command pipeline of several programs. In the
    following example, cat assembles the image and pipes it into zcat for uncompression.
    The output of zcat is sent to the hashing program, which produces a hash value
    upon completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `cat` command is necessary because it is concatenating all the split
    pieces before passing to zcat. Using `zcat image.raw.gz.*` will fail because it
    will try to uncompress each piece rather than the assembled image.
  prefs: []
  type: TYPE_NORMAL
- en: In the Unix community, *useless use of cat (UUOC)* describes using the `cat`
    command to send a file to command when `<` could be used instead. Traditional
    Unix communities have given out UUOC awards to encourage more efficient use of
    shell command redirection. However, the examples in this section do need `cat`
    because they perform a concatenation function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify Mismatched Hash Windows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As disks age, or as they are transported and handled, there’s a risk of damage,
    possibly introducing bad sectors. If an original evidence disk produces unreadable
    sector errors since it was first imaged, the cryptographic checksum for the disk
    will fail to match. Hash windows become valuable in this case, because you can
    use them to identify more precisely which part of the disk failed to match. More
    important, hash windows can show which areas of a disk are still preserved, even
    though the hash for the entire disk has failed to match.
  prefs: []
  type: TYPE_NORMAL
- en: The specified size of a hash window determines how often a new hash is written
    during the acquisition of a disk or when you’re verifying disk hash windows. When
    you’re comparing two lists of hashes for verification, both lists must use the
    same size of hash window. To find the mismatching areas, you can compare the two
    hash logs using the Unix diff tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a disk was imaged with dcfldd and a hash log with
    a 10M hash window size was saved. A subsequent verification failed to match the
    MD5 for the entire disk and provided a new hash log, also with a 10M hash window
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This output reveals mismatched hashes for the full image and also for the range
    of bytes between 20971520 and 31457280\. Dividing by the 512-byte sector size
    identifies the sector range between 40960 and 61440 where the hash mismatch occurred.
    The hashes on the rest of the disk are still good; only the sectors with mismatched
    hashes have not been forensically preserved. Content (blocks, files, portions
    of files, and so on) residing on a hash-mismatched sector range can be excluded
    from the presented evidence at a later stage. If two cryptographic hashes of a
    full image are a match, you can assume that all the hash windows also match.
  prefs: []
  type: TYPE_NORMAL
- en: The cryptographic hashes of forensic images preserve the integrity of collected
    evidence. However, the hash values themselves are not protected against malicious
    or accidental modification. Confirming the integrity of the calculated hashes
    can be preserved using cryptographic signing and time-stamping. Confirming the
    validity of signatures and timestamps is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Verify Signature and Timestamp***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The previous chapter demonstrated the use of GnuPG to sign a disk’s hashes.
    You can verify the signature without having the signing private key. The original
    person who signed the evidence is not needed; only their public key is needed.
    This example verifies the gpg signature of the person who signed the acquired
    disk image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the contents of the signed message (the acquisition output and hash) are
    displayed together with a gpg message indicating that the signature is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'For S/MIME signed messages, a similar command will validate (or invalidate)
    the signature from a PEM file and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 6](ch06.xhtml#ch06) discussed using timestamping services to generate
    RFC-3161 timestamps from a timestamp authority. Validating a timestamp is similar
    to validating a signature with S/MIME and requires the correct chain of certificate
    authority (CA) certificates to be installed for verification to be successful.
    This example verifies the previous timestamp created with FreeTSA (*[http://freetsa.org/](http://freetsa.org/)*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the timestamping service’s CA certificate is not installed on your system,
    it can be manually fetched. The TSA certificate should have been returned as part
    of the timestamp when the request was made (because of the `-cert` flag). For
    this example, the CA cert is fetched from FreeTSA as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming CA and TSA certificates are available to OpenSSL and valid, you can
    validate the timestamp as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `openssl ts` command is used to verify the timestamp. The timestamp query
    (`tsq`) and timestamp reponse (`tsr`) are provided, and in this example, the file
    containing the timestamp server’s CA certificate is specified. The third-party
    timestamp is valid (`Verification: OK`), indicating that the file (and the forensic
    acquisition hashes it contains) has not been modified since the specified time.
    If a particular timestamp authority is expected to be used permanently, you can
    add the CA certificates to the OS’s trusted CA store.'
  prefs: []
  type: TYPE_NORMAL
- en: AFFlib also has provisions for signing and validating signatures for acquired
    images using X.509 certificates.
  prefs: []
  type: TYPE_NORMAL
- en: This section did not discuss the web-of-trust or the public key infrastructure
    (PKI) needed to trust the keys being used to sign images and verify timestamps.
    The examples assume this trust is already established.
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert Between Image Formats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting between forensic image formats can be advantageous for various reasons.
    If a lab has new software or infrastructure and the current format is unsupported
    or less efficient, converting to another format could be an option. If you’ll
    be transferring an image to a third party, they might have a preferred image format.
    If you are receiving an image from a third party, you might want to convert it
    to your preferred format. This section provides examples of converting between
    formats on the command line. Conversion from a few source formats is shown, including
    EnCase, FTK, AFF, and raw images. In addition, the examples demonstrate converting
    various formats into SquashFS evidence containers.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re converting between image formats, it’s preferable to use pipes and
    redirection. Avoid tools that use temporary files. During the conversion process,
    two copies of an image might coexist (one or both might be compressed). To prepare
    for the conversion process, do some capacity planning.
  prefs: []
  type: TYPE_NORMAL
- en: After conversion, check the hash values from the original image and the destination
    to ensure a match.
  prefs: []
  type: TYPE_NORMAL
- en: '***Convert from Raw Images***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Converting a raw image to another format is usually straightforward, because
    you can use regular disk-imaging functionality. Instead of a raw device name,
    the filename of the raw image is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show a raw image file being converted into EnCase and
    FTK formats. The first example uses `ewfacquire` to convert *image.raw* to EnCase
    Expert Witness format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the specified source file is the raw image; `-t` is the base name of the
    EnCase target **.e01* files. EnCase version 7 was specified, and when the command
    is executed, a series of questions is asked. Because the raw file has no case
    metadata, you need to enter it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting from a raw image to FTK SMART is similar: you specify the raw image
    as a source and manually add the case metadata. Using ftkimage, you specify the
    case metadata on the command line, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `--s01` flag specifies that a SMART compressed image will be created. The
    base filename is specified simply as `image`, and appropriate file extensions
    will be automatically added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting an image to a SquashFS forensic evidence container is also just
    a simple command if you use the sfsimage script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the raw image file was specified together with the destination SquashFS
    container filename. The sfsimage script builds the required SquashFS pseudo device
    and adds the log and hash information as regular text files. You can append additional
    case metadata to the evidence container manually (with `sfsimage -a`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t directly access a gzip compressed raw image using typical forensic
    tools because of the inability to seek (randomly access any block within the file)
    within a gzip file. It’s best to convert such files into compressed formats that
    are seekable. Then you can operate on them directly using forensic analysis tools.
    In this example, a gzipped raw image file is converted into a SquashFS compressed
    file using sfsimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The original file remains in raw form, but it’s now inside a compressed filesystem.
    You can mount the resulting **.sfs* file to access the raw image, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert a raw image file into an AFF file by using a simple `affconvert`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then you can add the case metadata with a separate tool, such as affsegment.
    The affconvert tool provides sensible defaults for compression, and the resulting
    file has the **.aff* extension with the basename of the raw file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following and final example shows the conversion of a raw image inside
    a SquashFS forensic evidence container to an AFF file using the `affconvert` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Because SquashFS is read-only, you need to tell `affconvert` to write the output
    file to a different directory that is writable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Convert from EnCase/E01 Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The libewf package contains the ewfexport tool for converting EnCase EWF (**.E0**)
    files to other formats. This includes the ability to read one or more files and
    pipe them into other programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is a bug in some older versions of ewfexport that appends the line*
    `ewfexport: SUCCESS` *to the end of an image after an export to stdout. This added
    string will cause a mismatch in the image MD5 hashes. The string is a fixed length
    of 19 bytes, so you can suppress it by piping it through* `tail -c 19`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual Creation of a SquashFS Container**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Throughout the book, you’ve seen examples of the sfsimage shell script. But
    it’s useful to see one example of creating a SquashFS file without the script.
    This next example will make it easier to understand how sfsimage works internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following EnCase acquisition contains 54 **.E0* files that will be assembled
    into a single raw image and placed into a SquashFS evidence container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To begin, you need a mksquashfs pseudo definition file to define the commands
    that will create files inside the SquashFS container. The pseudo definition file
    contains the target filename, file type, permissions, ownership, and command to
    be executed. The output of that command will become the contents of the defined
    filename inside the SquashFS filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a file named *pseudo_files.txt* has been created
    that contains two definitions. The first extracts the EnCase metadata with ewfinfo
    and places it into *image.txt* (this metadata would otherwise be lost). The second
    definition exports a raw image from the **.E0* files into *image.raw*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `ewfexport` flag `-u` allows the conversion to execute unattended (otherwise
    it prompts the user with questions). The `-t` flag specifies the target, which
    in this example is stdout or the dash `-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition file, you can create the compressed filesystem containing
    the generated files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting SquashFS filesystem *image.sfs* will contain three files: the
    raw image file *image.raw*, *image.txt* containing the metadata, and the *pseudo_files.txt*
    file containing the definitions with the executed commands. The mksquashfs(1)
    manual page has more information about the flags and options for creating SquashFS
    file systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the contents of a SquashFS file with the `unsquashfs` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to verify the preservation of evidence by comparing MD5 hash
    values. The `ewfinfo` command provides the MD5 hash calculated during the original
    EnCase acquisition. A second MD5 checksum can be calculated with md5sum on the
    newly converted raw image inside the SquashFS container. To do this, you need
    to mount the SquashFS filesystem first. The following example shows each of these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The result shows that the two MD5 hashes match, indicating a successfully preserved
    evidence conversion from EnCase to a raw image inside a SquashFS container. A
    third matching MD5 hash can be seen in the ewfexport output that was calculated
    during the conversion process. The ewfexport tool can also convert, or export,
    to other EnCase formats.
  prefs: []
  type: TYPE_NORMAL
- en: When the mounted SquashFS filesystem *image.sfs.d* is no longer needed, it can
    be unmounted with `umount image.sfs.d`. The sfsimage script manages these steps
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert Files from EnCase to FTK**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The ftkimager tool can convert from EnCase to FTK. In this example, a set of
    EnCase **.e01* files are converted to SMART ew-compressed files with the same
    name but with the **.s01* extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Hashes are checked and added to the new FTK file. The original case metadata
    is not added to the newly converted files. Instead, it’s extracted from the original
    format and saved as a separate file with the same name but with a **.txt* extension
    (*image.s01.txt* in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '***Convert from FTK Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command line ftkimager tool converts between EnCase and FTK formats, and
    it allows you to use stdin and stdout for conversion with raw image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a set of compressed FTK SMART **.s01* files are converted
    to the EnCase EWF *E01 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The case metadata is not transferred to the new format but is automatically
    saved to a separate file (*image.E01.txt*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The ftkimager can convert SMART **.s01* files to stdout, where you can redirect
    them to raw image files or pipe them into other programs. In the following example,
    a set of FTK SMART files are converted into a SquashFS forensic evidence container
    using ftkimager output piped into sfsimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When you’re converting from an FTK format into a raw disk image, the case metadata
    is not transferred. You need to manually save the case metadata, which is usually
    found in a separate text file. You can add this to the SquashFS container as shown
    in the previous example with the `sfsimage -a` command.
  prefs: []
  type: TYPE_NORMAL
- en: After performing a format conversion of any kind, you should verify the hash
    value separately on the destination format to ensure the evidence integrity has
    been preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '***Convert from AFF Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The affconvert tool can convert AFF images to a raw image (and from a raw image
    to the AFF format). The affconvert tool does not use stdin or stdout; instead,
    it reads or creates stand-alone files. The following simple example shows converting
    an AFF file to a raw image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To convert a raw image to an AFF format, simply use `affconvert image.raw`,
    and the corresponding *image.aff* file will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use piping and redirection with AFF files, you can use the affcat tool.
    The previous example can be also be done with `affcat` and redirected to a file
    (without any status or completion information, which is useful for scripts) as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert an AFF image to EnCase or FTK, the affcat tool can pipe an image
    via stdout or stdin into the appropriate tool, creating a new image in the desired
    format. For example, you can convert from AFF to a compressed FTK SMART image
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-` represents the stdin file descriptor receiving the raw image data,
    `image` is the base filename, and the final flag `--s01` specifies the compressed
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can convert to various EnCase formats using efwacquirestream.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the previous AFF conversion examples, the case metadata (case name, examiner
    name, acquisition times, hashes, and so on) is not preserved in the conversion
    from AFF to other formats. But you can export this information using affinfo and
    then add or save it manually to the destination format. Depending on the tool,
    you can also include metadata as command line flags as seen in the previous example
    with `-C 42 -E 1 -e "S. Holmes" -D "Data theft case"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This final example demonstrates converting an AFF file to a compressed SquashFS
    forensic evidence container using sfsimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can extract the metadata from AFF files using affinfo and then add it to
    the SquashFS forensic evidence container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Once the image is converted, compare the hash values of the original image and
    the destination to ensure a match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure an Image with Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important but often neglected component of digital forensics is information
    security. You should consider the information you acquire and extract during an
    investigation as sensitive and adequately protect its security.
  prefs: []
  type: TYPE_NORMAL
- en: The loss of data confidentiality may have undesired consequences. For example,
    it may violate organizational policy requirements, jeopardize legal and regulatory
    compliance, raise victim privacy issues, and do damage to the reputation of the
    investigating organization. Failing to adequately protect acquired evidence could
    result in damage to any of the parties involved, including the investigators and
    their employer, the victim, the defendant, and other participating parties. Leaked
    information could also interfere with or compromise an ongoing investigation.
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on methods for ensuring that information is protected,
    in particular, maintaining security during data transfer and storage (both long-
    and short-term storage). Adding security to images increases the complexity and
    the time needed to encrypt and then later decrypt the images, but the examples
    you’ll see here attempt to keep this process as simple and efficient as possible.
    Basic symmetric encryption is used instead of more complex PKI or web-of-trust
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the methods shown in this section, the ZIP archive format could
    be used for encryption. Newer versions with the ZIP64 extensions support file
    sizes larger than 4GB. ZIP has the advantage of high compatability with other
    platforms such as Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '***GPG Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using symmetric encryption, you can easily encrypt disk images for protection
    during network transfer or storage. GNU Privacy Guard (GPG) encryption provides
    a free implementation of the OpenPGP standard defined by RFC-4880\. It’s an alternative
    to the traditional PGP encryption created by PhilZimmerman in the early 1990s.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s useful to start the agent when you’re using GPG. (The agent is started
    automatically when using gpg2.) This is typically done at login with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For all the examples that follow, the `-v` flag is used to increase verbosity.
    This makes the output more useful for documentation purposes (both in this book
    and for creating formal forensic reports describing the steps taken).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using GPG to encrypt an existing image is very simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A passphrase is requested, and the image is encrypted with the default symmetric
    encryption algorithm, creating a new file with the extension *.gpg*. The size
    of the image is smaller because GPG compresses as it encrypts. This can be seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example showed encrypting a file in place. But you can also encrypt
    on the fly during acquisition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, dcfldd acquires the attached disk via */dev/sde* and pipes it directly
    into the GPG program. The encrypted output of GPG is then redirected to a file.
    The `sudo` command escalates privileges to root in order to read the raw device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypting a GPG-encrypted image is just as simple as encrypting one. The only
    differences are the use of the decryption flag and the requirement to specify
    an output file (by default, it outputs to stdout). In the following example, a
    GPG-encrypted image file is decrypted to a regular (unprotected) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates symmetric encryption without signing. You can also
    use GPG public and private keys to encrypt, decrypt, and sign images. The integrity
    is verified by comparing the hash of the GPG-encrypted image with the hash of
    the raw image file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When you’re decrypting an image, you need to do some capacity planning. After
    decryption, two copies of the image will exist (one or both will be compressed).
  prefs: []
  type: TYPE_NORMAL
- en: A GPG-encrypted file is not seekable, so you cannot operate on its contents
    directly with forensic analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: '***OpenSSL Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Other cryptographic systems can also provide security for disk images. The
    OpenSSL toolkit (*[http://www.openssl.org/](http://www.openssl.org/)*) provides
    a number of algorithms you can use to encrypt files. For example, to password
    encrypt an image with 256-bit AES using cipher block chaining mode, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenSSL is flexible regarding cipher types and modes, providing dozens of choices.
    Also supported are piping and redirection, and you can easily perform encryption
    during acquisition, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Decrypting an OpenSSL-encrypted file is also relatively straightforward, provided
    you know the encryption algorithm, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The addition of the `-d` flag signifies this is a decryption operation (`enc`
    specifies that symmetric ciphers are being used). Because OpenSSL doesn’t provide
    an automatic method to detect which symmetric encryption was used, it’s important
    to document how the file was encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless specifically compiled with zlib, OpenSSL doesn’t compress files. To
    add compression on the fly during an acquisition, add gzip to the pipeline, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the cryptographic hash of the image, you can run a similar command
    pipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, the decryption command takes the compressed and encrypted file as input
    and pipes the decrypted output to gunzip, which outputs the raw image to the hashing
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Some implementations of ZIP also support built-in encryption and can be used
    to secure images and other evidence files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forensic Format Built-In Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GPG and OpenSSL are well-known tools for performing various encryption tasks,
    providing compatibility and interoperability with other tools. However, they’re
    not designed for digital forensics, and encrypted image files cannot be used directly
    by standard forensic tools (they must be decrypted first). Some versions of the
    popular forensic formats discussed throughout this book support randomly accessible
    encrypted images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ftkimager program can protect image files using a password or a certificate.
    An example of encrypting with a password (*monkey99*) during acquisition is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Including a password in command parameters is generally bad practice. The
    password is visible in the shell history, and anyone can view the password in
    the process table.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to access an encrypted image without a password, or with the incorrect
    password, will generate the following error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Operating on an encrypted image requires including the password on the command
    line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Some versions of the EWF format support encryption, and as of this writing,
    libewf support was at various stages of development. Refer to the latest source
    code for current encrypted-format support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AFFlibsuite allows you to directly access encrypted images via the Advanced
    Forensics Format (AFF) library. From the start, AFFlib was developed with information
    security in mind. It has a number of encryption possibilities for protecting forensic
    images, including password-based (symmetric) and certificate-based (X.509) encryption.
    You can add the protection to an existing acquired image using the affcrypto tool.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Recent versions of dd_rescue implement a plugin interface and (at the time
    of this writing) had plugins for LZO compression, cryptographic hashing, and symmetric
    encryption (AES). The following example shows imaging a disk (*/dev/sdc*) and
    saving the output in encrypted form using the AES plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If examiners in a forensics lab expect high volumes of encryption, signing,
    and timestamping of images and evidence, it’s worth investing the use of a PKI.
    This could be an in-house PKI system or an external commercial PKI provider.
  prefs: []
  type: TYPE_NORMAL
- en: '***General Purpose Disk Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The examples in the previous sections focused on protecting individual files
    or file containers. An alternative is to protect the entire drive where the image
    files reside. You can do this with filesystem encryption, in hardware, in user
    space, or in the kernel. You’ll see several examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: There are high-capacity secure external drives on the market that can be used
    to safely transport image files, such as Lenovo’s ThinkPad Secure Hard Drives,
    one of which is shown in [Figure 7-1](ch07.xhtml#ch7fig1). These drives are OS
    independent and encrypt drive contents with a pin entered in a physical keypad
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f07-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: ThinkPad Secure Hard Drive*'
  prefs: []
  type: TYPE_NORMAL
- en: 'TrueCrypt was once the most popular free and cross-platform filesystem software
    available. But in May 2014, an unexpected and unexplained announcement from the
    developers recommended people find alternatives to TrueCrypt because development
    was stopped. A number of forks and compatible projects resulted, several of which
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '• VeraCrypt: *[https://veracrypt.codeplex.com/](https://veracrypt.codeplex.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• tc-play: *[https://github.com/bwalex/tc-play/](https://github.com/bwalex/tc-play/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• CipherShed: *[https://ciphershed.org/](https://ciphershed.org/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• zuluCrypt: *[http://mhogomchungu.github.io/zuluCrypt/](http://mhogomchungu.github.io/zuluCrypt/)*
    (not an implementation of TrueCrypt but a TrueCrypt manager worth mentioning)'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the examples in this section use VeraCrypt. As of this writing,
    VeraCrypt was under active development and gaining in popularity as an alternative
    to TrueCrypt.
  prefs: []
  type: TYPE_NORMAL
- en: The following example encrypts an empty external drive in its entirety. You
    can then use the encrypted container for secure transfer or storage of evidence
    data. The veracrypt tool asks a number of questions regarding the setup of the
    encrypted container. Note that in this example, */dev/sda* is an examiner’s drive,
    not a subject drive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The drive has now been initialized as a VeraCrypt container (this can take
    a long time, depending on the speed of the PC and the size of the drive). To mount
    a VeraCrypt volume, you use a simple command that includes the source device and
    the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Safely removing the device requires “dismounting” the VeraCrypt volume and
    is also done using a simple command that specifies the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can physically detach the drive from the system. The encrypted
    drive in this example is an entire raw device, but it’s also possible to use a
    VeraCrypt container file. The mount point in this example is */mnt*, but it can
    be anywhere in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: There are other full-disk encryption systems that can be used to secure forensic
    image files and other data. You can use self-encrypting drives (SEDs), discussed
    in detail in “[Identify and Unlock Opal Self-Encrypting Drives](ch05.xhtml#ch05lev2sec12)”
    on [page 128](ch05.xhtml#page_128), with the `sedutil-cli` command to create an
    encrypted drive for storage and transport. Filesystem encryption, such as Linux
    LUKS and dm-crypt, offers similar levels of protection. Although these encryption
    systems will secure evidence data on a drive, they might not be interoperable
    with other OSes (Windows or OS X, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '**Disk Cloning and Duplication**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some situations, a clone or duplicate copy of a disk is preferred to an
    image file. Each duplicate is an exact sector-by-sector copy of the original disk.
    A newly cloned disk will have a cryptographic checksum that matches the original.
    A cloned disk can be useful for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: • To use analysis tools and methods that require writing to disk
  prefs: []
  type: TYPE_NORMAL
- en: • To boot a PC with the disk clone
  prefs: []
  type: TYPE_NORMAL
- en: • To reconstruct RAID arrays using proprietary controllers
  prefs: []
  type: TYPE_NORMAL
- en: Cloning disks is a straightforward process; it is basically acquisition in reverse.
    Be sure to exercise caution during the duplication process, because you could
    destroy data if the wrong device is mistakenly used as the destination.
  prefs: []
  type: TYPE_NORMAL
- en: '***Prepare a Clone Disk***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The size (number of sectors) of the destination, or clone, disk must be equal
    to or larger than the original disk. Because cloning involves a sector-by-sector
    copy, the destination disk must have the capacity to hold all sectors of the original
    disk. In some cases, having a larger destination disk is not a problem, because
    the PC and OS will be limited to what was defined in the partition table and ignore
    the rest of the disk. In other cases, duplicating the exact number of sectors
    of the disk is important, as software and tools may have certain sector number
    expectations. Some examples include the analysis of GPT partitions (where a backup
    is stored at the end of a disk) and RAID systems, and the analysis of certain
    strains of malware that partly reside in the final sectors of the disk.
  prefs: []
  type: TYPE_NORMAL
- en: Securely wiping (with zeroed sectors) the destination disk before cloning is
    critical to remove traces of previous data and reduce the risk of contaminating
    the clone.
  prefs: []
  type: TYPE_NORMAL
- en: '***Use HPA to Replicate Sector Size***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The HPA can be used to simulate the same number of sectors on the cloned disk
    as on the original.^([2](footnote.xhtml#fn40)) Setting the HPA on a cloned disk
    is beneficial if there is an expectation of the exact same number of sectors as
    the original. This is especially important when you’re reconstructing a RAID system
    with a proprietary controller or duplicating a disk with data expected in the
    final sectors of the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should know the exact sector count of the original drive (this was determined
    when the drive was attached to the examination host) before setting the HPA with
    the hdparm tool.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the HPA on a 500GB disk is set to duplicate a 120GB drive.
    The original disk reports 234441648 512-byte sectors, which you can use to set
    the *maximum visible sectors* on the clone drive. Use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The first `hdparm -N` command shows the initial state with 500GB of accessible
    sectors and a disabled HPA. The second `hdparm` command requires the `--yes-i-know-what-i-am-doing`
    flag to configure dangerous settings, such as changing the sector size. The `-N
    p234441648` specifies the number of sectors. It is prefixed with the letter `p`
    so the change is permanent across drive restarts. The final `hdparm` command checks
    whether the drive is now reporting the new sector size, which is now the same
    as that of the clone (120GB).
  prefs: []
  type: TYPE_NORMAL
- en: '***Write an Image File to a Clone Disk***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write an image to a new disk, use the same tools as when you acquire a disk
    but in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a disk clone directly from the original suspect disk or from
    a previously acquired image file using the standard dd utilities. This example
    shows writing a raw image file to a clone disk using dc3dd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now you can verify the cryptographic hash against the original. If the sector
    count of the original and clone disks don’t match, either an error is generated
    (if the clone doesn’t have enough sectors to complete the duplication activity)
    or the hash values won’t match.
  prefs: []
  type: TYPE_NORMAL
- en: You can write a set of split images, compressed images, or encrypted images
    back to a clone disk without creating a regular image file first.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use non-raw formats, such as AFF, EnCase EWF, or FTK SMART, to
    create clone disks. If a particular forensic tool cannot write an image back to
    a device, it might be able to pipe a raw image into a dd program, which can.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image Transfer and Storage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Managing the transfer and long-term storage of forensic images safely and successfully
    requires some thought and planning. Often, situations occur in which you need
    to transfer an image to another party, such as another department within a large
    organization, an independent third-party forensics firm, or a law enforcement
    agency.
  prefs: []
  type: TYPE_NORMAL
- en: Several factors influence how transfers are completed, primarily the size of
    the data and the security of that data. In addition, depending on the organization,
    you might have to consider legal and regulatory requirements, as well as organizational
    policy requirements. For example, a global bank might not be able to transfer
    some disk images across national borders due to banking regulations prohibiting
    the transfer of client data outside the country.
  prefs: []
  type: TYPE_NORMAL
- en: Storing images for the long term also requires some thought and plan-ning. If
    an image will be reopened several years later, different staff, tools, and infrastructure
    could be in place. It is important to document what has been stored and maintain
    backward compatibility with the software used in the past.
  prefs: []
  type: TYPE_NORMAL
- en: '***Write to Removable Media***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the past, a stack of CDs or DVDs were used in the transfer of acquired drive
    images. With compression and splitting, using these media was a cheap and feasible
    transfer method. Today, 4TB and 6TB disks are common, and 10TB disks are already
    on the consumer market. Optical discs are no longer a practical transfer medium
    for today’s larger image sizes, even with compression. However, for completeness,
    several examples are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: The following simple example shows burning a SquashFS file to CDROM. The `mkisofs`
    command is a symlink to genisoimage and is used to create the filesystem to be
    burned to a disk with the wodim tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here is a simple example of burning an image to a DVD. The growisofs tool began
    as a frontend to genisoimage and developed into a generalpurpose DVD and Blu-ray
    burning tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows burning an image to a Blu-ray disc using the `growisofs`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Burning large images to optical discs under Linux can be quirky. Depending on
    the drive and the media used, unexpected or inconsistent behavior might be observed.
    Be sure to test the compatibility of drives and media before using them in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inexpensive Disks for Storage and Transfer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a stack of optical discs from a set of split and compressed images
    requires a systematic process that can be time-consuming and error prone. The
    maximum capacity of Blu-ray discs is currently 100GB (BD-R XL). The cost per gigabyte
    of Blu-ray discs is more than the cost per gigabyte for cheap hard disks.
  prefs: []
  type: TYPE_NORMAL
- en: When you factor in human effort, risk of error, time required to burn data to
    optical discs, and cost per gigabtye, simply buying and using cheap hard disks
    becomes an attractive possibility for offline storage and transfer of forensic
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '***Perform Large Network Transfers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of the issues concerning acquiring images via a network were already discussed
    in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Large network transfers of acquired images may take long periods of time to
    complete and might saturate a corporate internal network or internet link. Dropped
    connections and timeouts might also occur during such long network transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring large forensic images between hosts on a network is not nearly
    as fast as transferring them between disks on a local machine. To put network
    bandwidth speeds into perspective, it helpful to compare them to common disk speeds.
    [Table 7-1](ch07.xhtml#ch7table1) compares two fast drive interfaces to two fast
    network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Transfer Speeds of Common Interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Speed** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NVME | 4000MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| SATA III | 600MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| Gigibit Ethernet | 125MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| Fast Ethernet | 12.5MB/s |'
  prefs: []
  type: TYPE_TB
- en: For a more detailed comparison of different bandwidths, see the Wikipedia page
    at *[https://en.wikipedia.org/wiki/List_of_device_bit_rates](https://en.wikipedia.org/wiki/List_of_device_bit_rates)*.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the network bandwidth and the image size, the physical delivery
    of a storage container with the acquired subject image(s) could be faster than
    a network transfer.
  prefs: []
  type: TYPE_NORMAL
- en: But in some situations, secure network data transfer is necessary. Ensuring
    security during a transfer may have certain side effects, such as increased complexity
    or performance penalties. For network data transfer over untrusted or unknown
    networks, you can use several standard secure protocols, including SSL/TLS, ssh/sftp,
    or IPSEC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple example shows the transfer of a forensic image file using
    scp (secure copy) from the OpenSSH software package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, an image file (*image.raw*) is copied over an insecure network to a specific
    data directory on a remote server. Using scp has several advantages, including
    strong encryption algorithms, built-in compression, real-time progress status,
    estimated completion time, and strong authentication possibilities. Most important
    for forensic investigators, scp allows for very large file sizes (assuming the
    software binary was compiled with 64-bit large file size support) and is easily
    capable of transferring large disk images.
  prefs: []
  type: TYPE_NORMAL
- en: If an image file is already encrypted, the underlying security might be less
    of a concern, and you can use traditional file transfer protocols, such as File
    Transfer Protocol (FTP) or Windows Server Message Block (SMB). However, when you’re
    using insecure and weakly authenticated protocols to transfer encrypted files,
    you should confirm the file integrity by verifying the cryptographic hash after
    the transfer is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Wiping and Data Disposal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you discard or reuse a disk, or you no longer need temporary files,
    take diligent steps to properly erase the contents. Several command line wiping
    and secure deletion methods are available for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dispose of Individual Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some situations, you’ll need to securely erase individual files but not the
    entire disk. For example, you might need to dispose of temporary acquired images
    on the acquisition host. In this scenario, using a file shredder/wiper is sensible
    because it reduces the risk of destroying other data on the examiner’s workstation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Linux coreutils package includes the shred tool, which attempts
    to securely delete files, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: A software package called the secure_deletion toolkit provides a suite of tools
    that attempts to erase swap, cache, memory, inodes, and files. In particular,
    srm will wipe an individual file. Another command line tool called wipe also will
    erase files.
  prefs: []
  type: TYPE_NORMAL
- en: Wiping individual files is a complex process and depends on many variables related
    to the OS and filesystem used. There are no guarantees that all fragments of a
    wiped or shredded file have been completely destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Wipe a Storage Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wiping entire physical drives involves writing zeros or random bytes to every
    user-accessible sector on the drive. This does not guarantee that all hidden or
    user-inaccessible areas of a physical drive are wiped. Sectors protected by an
    HPA or DCO (which can be removed), remapped bad sectors, overprovisioned areas
    of flash drives, and inaccessible system areas of a drive are not user accessible
    and therefore cannot be wiped with normal Linux tools. In spite of this, wiping
    all user-accessible sectors still provides a reasonable level of assurance, so
    this is a diligent method of data disposal for reusing drives within a lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on a particular organization’s risk appetite and policies, data disposal
    might require one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • No wiping at all, just common reformatting
  prefs: []
  type: TYPE_NORMAL
- en: • Wiping all visible sectors with one pass of zeros
  prefs: []
  type: TYPE_NORMAL
- en: • Wiping all visible sectors with multiple passes of random data
  prefs: []
  type: TYPE_NORMAL
- en: • Physically degaussing drives
  prefs: []
  type: TYPE_NORMAL
- en: • Physically shredding drives
  prefs: []
  type: TYPE_NORMAL
- en: The disposal method required is a risk-based decision that depends on the sensitivity
    of the data on the drive, who might have an interest in recovering the data, cost
    and effort for recovery, and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first example uses dc3dd to write zeros to each visible sector on the
    disk. The dc3dd tool has built-in wiping functionality, and you can use it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You could also complete this task using dd with */dev/zero* as the input file,
    but dc3dd is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm the disk has been wiped with zeros, you can use dd to read the disk
    into a hexdump program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If the entire disk is full of zeros, the hexdump (hd) tool will display one
    line of zeros followed by an asterisk (`[*]`), indicating a repeated pattern across
    the entire disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If the result shows only zeros, the user-accessible sectors of the drive have
    been successfully wiped.
  prefs: []
  type: TYPE_NORMAL
- en: The following example uses the nwipe tool, a fork of Darik’s Boot and Nuke (dban)
    tool. The nwipe tool can specify different wiping standards, randomicity, and
    number of rounds, and it will provide a log file of the activity. The Canadian
    RCMP TSSIT OPS-II wipe version is shown here:^([3](footnote.xhtml#fn41))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When you’re wiping drives, ensure the DCO and HPA have been removed. With NVME
    drives, make sure each individual namespace has been wiped (most consumer NVME
    drives have only a single namespace).
  prefs: []
  type: TYPE_NORMAL
- en: '***Issue ATA Security Erase Unit Commands***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ATA standard specifies a security erase command that you can issue directly
    to a drive to wipe a disk. The `ATA SECURITY ERASE UNIT` command will write zeros
    to all user accessible sectors of the disk. The `EXTENDED SECURITY ERASE` command
    will write a predefined pattern (defined by the drive manufacturer) instead of
    zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `hdparm` displays the capabilities and status of security on the drive.
    Also provided is the estimated time needed to securely erase the drive, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Some drives will reject the erase command if you don’t explicitly set a password
    first. In the following example, a Western Digital drive was used, and the password
    was first set to *dummy* before the `--security-erase` command was accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The drive has now been securely wiped and can be reused. If a drive requires
    setting a password, don’t forget to disable the password after the security erase
    has completed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Destroy Encrypted Disk Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can securely destroy encrypted disks and filesystems by destroying all known
    copies of the encryption key. If the key was generated on a secure device such
    as a smartcard, a TPM, or an Opal drive, then only one copy of the key will exist.
    If a drive or filesystem was provisioned in an enterprise environment, there might
    be backup or escrow copies of the key for recovery purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Key-wiping procedures for OS-based encrypted drives, such as Microsoft BitLocker,
    Apple FileVault, Linux LUKS/dm-crypt, or TrueCrypt variants, require detailed
    knowledge of where the keys are stored. Keys might be password/passphrase protected
    and stored in a file or in a certain block on the drive. They might also be stored
    in a key file elsewhere. If it’s not possible to locate and securely destroy all
    copies of a private key, the alternative is to wipe the disk with the full drive-wiping
    method described in a previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, secure external USB thumb drives have a factory reset function for
    lost passwords. This can be used to destroy the key and hence the contents of
    the drive. For example, you can reset the Corsair Padlock2 thumb drive by holding
    down both the KEY and 0/1 buttons for three seconds, followed by entering `911`
    to reset the key and destroy the drive contents. On iStorage datashur drives,
    hold down both the KEY and 2 buttons for three seconds and then enter `999` to
    reset the key.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the contents of Opal SED drives is also instantaneous and simply
    involves destroying the encryption key on the drive by entering the *Physical
    Security ID (PSID)*. The PSID usually has a QR code on the physical cover of the
    drive that you can scan instead of typing it in by hand. You cannot get the PSID
    by querying the drive with ATA commands; it’s only visible on the cover of the
    physical drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sedutil-cli` command has a special option for irrevocably resetting the
    drive key using the PSID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The encryption key in the drive is now reset, and the data is effectively destroyed.
    The disk is factory reset, unlocked, and can be reused. The time needed to destroy
    the data on this 120GB drive was half a second.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a variety of techniques for managing forensic images,
    including the use of compression with common Linux tools and built-in compression
    with forensic formats. You saw more examples of the SquashFS compressed filesystem
    and the sfsimage script for managing forensic evidence containers. I demonstrated
    splitting and reassembling images, duplicating drives, and converting between
    image formats. You also learned how to verify hashes, signatures, and timestamps
    and how to protect images with encryption during network transfer and storage.
    Finally, I showed the secure disposal of forensic image files and drives.
  prefs: []
  type: TYPE_NORMAL
