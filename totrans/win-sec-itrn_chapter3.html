<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>3. User-Mode Applications</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch3">
<span class="CN"><span aria-label=" Page 63. " epub:type="pagebreak" id="pg_63" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">USER-MODE APPLICATIONS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">In the previous chapter, we discussed the Windows kernel. But a user doesn’t typically interact directly with the kernel. Instead, they interact with user-facing applications, such as word processors and file managers. This chapter will detail how these user-mode applications are created and how they interface with the kernel to provide services to the user.</p>
<p class="TX">We’ll start by discussing the Win32 application programming interfaces (APIs) designed for user-mode application development and how they relate to the design of the Windows operating system. Then we’ll cover the structure of the Windows user interface and how you can inspect it programmatically. Multiple users of a Windows system can all access a user interface at the same time; we’ll also look at how console sessions can isolate one user’s interface and application resources from those of other users on the same system.</p>
<p class="TX"><span aria-label=" Page 64. " epub:type="pagebreak" id="pg_64" role="doc-pagebreak"></span>To understand how user-mode applications function, it’s important to understand how the provided APIs interface with the underlying kernel system call interface. We’ll examine this too, along with the conversion process that filepaths must undergo to become compatible with the kernel. Next, we’ll cover how Win32 applications access the registry; then we’ll consider how Win32 handles process and thread creation and look at some important system processes.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-21"></span><samp class="SANS_Futura_Std_Bold_B_11">Win32 and the User-Mode Windows APIs</samp></h3>
<p class="TNI1">Most of the code that runs on Windows does not directly interact with system calls. This is an artifact of the <i>Windows NT</i> operating system’s original design. Microsoft initially developed Windows NT as an updated version of IBM’s OS/2 operating system, intending it to have multiple subsystems that implemented different APIs. At various times, it supported POSIX, OS/2, and the Win32 APIs.</p>
<p class="TX">Eventually, Microsoft’s relationship with IBM went sour, and Microsoft took the API set it had developed for Windows 95, <i>Win32</i>, and built a subsystem to implement it. The largely unloved OS/2 subsystem was removed in Windows 2000, while POSIX survived until Windows 8.1. By Windows 10, Win32 was the only remaining subsystem (though Microsoft subsequently implemented Linux compatibility layers, such as Windows Subsystem for Linux, that don’t use the old subsystem extension points).</p>
<p class="TX">To allow for these multiple APIs, the Windows kernel implements a generic set of system calls. It’s the responsibility of each subsystem’s specific libraries and services to convert their APIs to the low-level system call interface. <a href="chapter3.xhtml#fig3-1">Figure 3-1</a> shows an overview of the Win32 subsystem API libraries.</p>
<figure class="IMG"><img alt="" class="img7" height="928" id="fig3-1" src="../images/Figure3-1.jpg" width="844"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The Win32 API modules</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 65. " epub:type="pagebreak" id="pg_65" role="doc-pagebreak"></span>As you can see, the core of the Win32 APIs is implemented in the <i>KERNEL32</i> and <i>KERNELBASE</i> libraries. These libraries call methods in the system-provided <i>NT Layer dynamic link library (NTDLL)</i>, which implements system call dispatches as well as runtime library APIs to perform common low-level operations.</p>
<p class="TX">Most user-mode applications do not directly contain the implementation of the Windows system APIs. Instead, <i>NTDLL</i> includes the DLL loader, which loads new libraries on demand. The loading process is mostly opaque to the developer: when building a program, you link against a set of libraries, and the compiler and toolchain automatically add an import table to your executable file to reflect your dependencies. The DLL loader then inspects the import table, automatically loads any dependent libraries, and resolves the imports. You can also specify exported functions from your application so that other code can rely on your APIs.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-20"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading a New Library</samp></h4>
<p class="TNI1">It’s possible to access exported functions manually at runtime without needing an import table entry. You can load a new library using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> Win32 API, which is exposed to PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp> command. To find the memory address of a function exported by a DLL, use the Win32 API <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>, exposed with the PowerShell <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp> command (<a href="chapter3.xhtml#Lis3-1">Listing 3-1</a>).</p>
<span id="Lis3-1"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$lib = Import-Win32Module -Path "kernel32.dll"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$lib</b>
Name         ImageBase        EntryPoint
----         ---------        ----------
KERNEL32.DLL 00007FFA088A0000 00007FFA088B7C70

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-Win32ModuleExport -Module $lib</b>
Ordinal Name                    Address
------- ----                    -------
1       AcquireSRWLockExclusive NTDLL.RtlAcquireSRWLockExclusive
2       AcquireSRWLockShared    NTDLL.RtlAcquireSRWLockShared
3       ActivateActCtx          0x7FFA088BE640
4       ActivateActCtxWorker    0x7FFA088BA950
<var>--snip--</var>

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>"{0:X}" -f (Get-Win32ModuleExport -Module $lib </b>
<b>-ProcAddress "AllocConsole")</b>
7FFA088C27C0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-1: Exports for the</span> <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp> <span class="Futura_Std_Book_Oblique_I_11">library</span></p>
<p class="TX">Here, we use PowerShell to load the <i>KERNEL32</i> library and enumerate the exported and imported APIs. First we load it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Import -Win32Module</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <i>KERNEL32</i> library is always loaded, so this command will just return the existing loaded address; for other libraries, however, the load will cause the DLL to be mapped into memory and initialized.</p>
<p class="NOTE"><span aria-label=" Page 66. " epub:type="pagebreak" id="pg_66" role="doc-pagebreak"></span><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp></span></p>
<p class="NOTE-TXT"><i>The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Import-Win32Module</samp> command will load a DLL into memory and potentially execute code. In this example, this is acceptable, as</i> <span class="note_Italic">KERNEL32</span> <i>is one of the trusted system libraries. However, do not use the command on an untrusted DLL, especially if you’re analyzing malware, as it might result in malicious code execution. To be safe, always perform malware analysis on a segregated system dedicated to that purpose.</i></p>
<p class="TX">Once it’s loaded into memory, we can display some of the library’s properties <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. These include the name of the library, as well as the loaded memory address and the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp>. A DLL can optionally define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">DllMain</samp>, to run when it’s loaded. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EntryPoint</samp> address is the first instruction in memory to execute when the DLL is loaded.</p>
<p class="TX">Next, we dump all exported functions from the DLL <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In this case, we see three pieces of information for each: <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Ordinal</samp> is a small number that uniquely identifies the exported function in the DLL. It’s possible to import an API by its ordinal number, which means there is no need to export a name; you’ll see certain names missing from export tables in DLLs whenever Microsoft doesn’t want to officially support the function as a public API.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> is just the name of the exported function. It doesn’t need to match what the function was called in the original source code, although typically it does. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> is the address in memory of the function’s first instruction. You’ll notice that the first two exports have a string instead of an address. This is a case of <i>export forwarding</i>; it allows a DLL to export a function by name and has the loader automatically redirect it to another DLL. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireSRWLockExclusive</samp> is implemented as <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlAcquireSRWLockExclusive</samp> in <i>NTDLL</i>. We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleExport</samp> to look up a single exported function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> API <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-21"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing Imported APIs</samp></h4>
<p class="TNI1">In a similar fashion, we can view the APIs that an executable has imported from other DLLs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp> command, as shown in <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a>.</p>
<span id="Lis3-2"></span><pre><code>PS&gt; <b>Get-Win32ModuleImport -Path "kernel32.dll"</b>
DllName                                   FunctionCount DelayLoaded
-------                                   ------------- -----------
api-ms-win-core-rtlsupport-l1-1-0.dll     13            False
ntdll.dll                                 378           False
KERNELBASE.dll                            90            False
api-ms-win-core-processthreads-l1-1-0.dll 39            False
<var>--snip--</var>

PS&gt; <b>Get-Win32ModuleImport -Path "kernel32.dll" -DllName "ntdll.dll" |</b>
<b>Where-Object Name -Match "^Nt"</b>
Name                          Address
----                          -------
NtEnumerateKey                7FFA090BC6F0
NtTerminateProcess            7FFA090BC630
<span aria-label=" Page 67. " epub:type="pagebreak" id="pg_67" role="doc-pagebreak"></span>NtMapUserPhysicalPagesScatter 7FFA090BC110
NtMapViewOfSection            7FFA090BC5B0
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-2: Enumerating imports for the</span> <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp> <span class="Futura_Std_Book_Oblique_I_11">library</span></p>
<p class="TX">We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp>, specifying the <i>KERNEL32</i> DLL as the path. When you specify a path, the command will call <samp class="SANS_TheSansMonoCd_W5Regular_11">Import-Win32Module</samp> for you and display all the imports, including the name of the DLL to load and the number of functions imported. The final column indicates whether the DLL was marked by the developer as being <i>delay loaded</i>. This is a performance optimization; it allows a DLL to be loaded only when one of its exported functions is used. This delay avoids loading all DLLs into memory during initialization, which decreases process startup time and reduces runtime memory usage if the import is never used.</p>
<p class="TX">Next, we dump the imported functions for a DLL. As the executable can import code from multiple libraries, we specify the one we want using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllName</samp> property. We then filter to all imported functions starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> prefix; this allows us to see exactly what system calls <i>KERNEL32</i> imports from <i>NTDLL</i>.</p>
<aside aria-label="box-12" class="box">
<p class="BoxTitle" id="box-12"><samp class="SANS_Dogma_OT_Bold_B_11">API SETS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You might notice something odd in the list of imported DLL names in <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a>. If you search your filesystem for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">api-ms-win-core-rtlsupport-l1-1-0.dll</samp> <samp class="SANS_Futura_Std_Book_11">file, you won’t find it. This is because the DLL name refers to an API set.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">API sets</samp> <samp class="SANS_Futura_Std_Book_11">were introduced in Windows 7 to modularize the system libraries, and they abstract from the name of the set to the DLL that exports the API.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">API sets allow an executable to run on multiple different versions of Windows, such as a client, a server, or an embedded version, and change its functionality at runtime based on what libraries are available. When the DLL loader encounters one of these API set names, it consults a table loaded into every process, sourced from the file</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">apisetschema.dll</samp><samp class="SANS_Futura_Std_Book_11">, that maps the name to the real DLL. You can query the details for an API set by using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtApiSet</samp> <samp class="SANS_Futura_Std_Book_11">command and specifying the name of the API set:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-NtApiSet api-ms-win-core-rtlsupport-l1-1-0.dll</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">Name                               HostModule   Flags</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">----                               ------------ -----</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">api-ms-win-core-rtlsupport-l1-1-1  ntdll.dll    Sealed</samp>
</code></pre>
<p class="BoxBody"><span aria-label=" Page 68. " epub:type="pagebreak" id="pg_68" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">We can see that in this case the API set resolves to the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">NTDLL</samp> <samp class="SANS_Futura_Std_Book_11">library. You can also specify the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ResolveApiSet</samp> <samp class="SANS_Futura_Std_Book_11">parameter to the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp> <samp class="SANS_Futura_Std_Book_11">command to group the imports based on the real DLLs:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-Win32ModuleImport -Path "kernel32.dll"  -ResolveApiSet</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">DllName                           FunctionCount   DelayLoaded</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">--------                          --------------- -------------</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll                         392             False</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">KERNELBASE.dll                    867             False</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">ext-ms-win-oobe-query-l1-1-0.dll  1               True</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">RPCRT4.dll                        10              True</samp>
</code></pre>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If you compare the output in <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a> to that of the same command shown here, you’ll notice that the resolved imports list is much shorter and that the core libraries have gained additional function imports. Also notice the unresolved API set name,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ext-ms-win-oobe-query-l1-1-0.dll</samp><samp class="SANS_Futura_Std_Book_11">. Any API set with the prefix</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">api</samp> <samp class="SANS_Futura_Std_Book_11">should always be present, whereas one with the prefix</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ext</samp> <samp class="SANS_Futura_Std_Book_11">might not be. In this case, the API set is not present, and trying to call the imported function will fail. However, because the function is marked as delay loaded, an executable can check whether the API set is available before calling the function by using the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">IsApiSetImplemented</samp> <samp class="SANS_Futura_Std_Book_11">Win32 API.</samp></p>
</aside>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-22"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching for DLLs</samp></h4>
<p class="TNI1">When loading a DLL, the loader creates an image section object from the executable file and maps it into memory. The kernel is responsible for mapping the executable memory; however, user-mode code still needs to parse the import and export tables.</p>
<p class="TX">Let’s say you pass the string <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC.DLL</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> API. How does the API know where to find that DLL? If the file hasn’t been specified as an absolute path, the API implements a path-searching algorithm. The algorithm, as originally implemented in Windows NT 3.1, searches for files in the following order:</p>
<p class="ListNumber1">  1.  The same directory as the current process’s executable file</p>
<p class="ListNumber">  2.  The current working directory</p>
<p class="ListNumber">  3.  The Windows <i>System32</i> directory</p>
<p class="ListNumber">  4.  The <i>Windows</i> directory</p>
<p class="ListNumber2">  5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp> environment variable</p>
<p class="TX">The problem with this load order is that it can lead to a privileged process loading a DLL from an insecure location. For example, if a privileged process changed its current working directory using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCurrentDirectory</samp> API to a location a less privileged user could write to, the DLL would be loaded from that location before any DLL from the <i>System32</i> directory. This attack is called <i>DLL hijacking</i>, and it’s a persistent problem on Windows.</p>
<p class="TX"><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak"></span>Vista changed the default load order to the following, which is safer:</p>
<p class="ListNumber1">  1.  The same directory as the current process’s executable file</p>
<p class="ListNumber">  2.  The Windows <i>System32</i> directory</p>
<p class="ListNumber">  3.  The <i>Windows</i> directory</p>
<p class="ListNumber">  4.  The current working directory</p>
<p class="ListNumber2">  5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp> environment variable</p>
<p class="TX">Now we no longer load from the current working directory before the <i>System32</i> or <i>Windows</i> directory. However, if an attacker could write to the executable’s directory, a DLL hijack could still take place. Therefore, if an executable is run as a privileged process, only administrators should be able to modify its directory to prevent a DLL hijack from occurring.</p>
<aside aria-label="box-13" class="box">
<p class="BoxTitle" id="box-13"><samp class="SANS_Dogma_OT_Bold_B_11">THE .DLL FILE EXTENSION</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">A separate loading quirk involves the handling of file extensions in a DLL’s filename. If no extension is specified, the DLL loader will automatically add a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.DLL</samp> <samp class="SANS_Futura_Std_Book_11">extension. If any extension is specified, the filename is treated as is. Finally, if the extension consists of a single period (for example,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LIB.</samp><samp class="SANS_Futura_Std_Book_11">), the loader removes the period and tries to load the file without an extension (here,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LIB</samp><samp class="SANS_Futura_Std_Book_11">).</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This file extension behavior can introduce mismatches between the DLL an application is trying to load and the one it actually loads. For example, an application might check that the file</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LIB</samp> <samp class="SANS_Futura_Std_Book_11">is valid (that is, correctly cryptographically signed); however, the DLL loader would then load</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LIB.DLL</samp><samp class="SANS_Futura_Std_Book_11">, which was not checked. This can result in security vulnerabilities if you can trick a privileged application into loading the wrong DLL into memory, as the entry point will execute in the privileged context.</samp></p>
</aside>
<p class="TX">While the DLL loader will normally turn to the disk to retrieve a library, some libraries are used so often that it makes sense to pre-initialize them. This improves performance and prevents the DLLs from being hijacked. Two obvious examples are <i>KERNEL32</i> and <i>NTDLL</i>.</p>
<p class="TX">Before any user applications start on Windows, the system configures a <i>KnownDlls</i> OMNS directory containing a list of preloaded image sections. A <i>KnownDlls</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s name is just the filename of the library. The DLL loader can check <i>KnownDlls</i> first before going to the disk. This improves performance as the loader no longer needs to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object for the file. It also has a security benefit, ensuring that anything considered to be a known DLL can’t be hijacked.</p>
<p class="TX">We can list the object directory using the <i>NtObject</i> drive, as shown in <a href="chapter3.xhtml#Lis3-3">Listing 3-3</a>.</p>
<span id="Lis3-3"></span><pre><code><span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"></span>PS&gt; <b>ls NtObject:\KnownDlls</b>
Name                TypeName
----                --------
kernel32.dll        Section
kernel.appcore.dll  Section
windows.storage.dll Section
ucrtbase.dll        Section
MSCTF.dll           Section
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-3: Listing the contents of the</span> <samp class="SANS_Futura_Std_Book_11">KnownDlls</samp> <span class="Futura_Std_Book_Oblique_I_11">object directory</span></p>
<p class="TX">This section covered the basics of the Win32 subsystem and how it uses libraries to implement the APIs that a user-mode application can use to interface with the operating system. We’ll come back to the Win32 APIs later, but first we must discuss the Windows user interface, which is inextricably linked to how the Win32 subsystem functions.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-22"></span><samp class="SANS_Futura_Std_Bold_B_11">The Win32 GUI</samp></h3>
<p class="TNI1">The name “Windows” refers to the structure of the operating system’s graphical user interface (GUI). This GUI consists of one or more windows that the user can interact with using controls such as buttons and text input. Since Windows 1.0, the GUI has been the most important feature of the operating system, so it should come as no surprise that its model is complex. The implementation of the GUI is split between the kernel and user mode, as shown in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="764" id="fig3-2" src="../images/Figure3-2.jpg" width="1351"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The Win32 GUI modules</samp></p></figcaption>
</figure>
<p class="TX">You might notice that the left-hand side of <a href="chapter3.xhtml#fig3-2">Figure 3-2</a> looks a lot like <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>, which showed the modules for the normal Win32 APIs. In place <span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"></span>of <i>NTDLL</i>, however, is <i>WIN32U</i>, which implements system call stubs for the kernel to call. Two libraries call <i>WIN32U</i>: <i>USER32</i> and <i>GDI32</i>. <i>USER32</i> implements the window UI elements and generally manages the GUI, whereas <i>GDI32</i> implements drawing primitives, like fonts and shapes.</p>
<p class="TX">One big difference between <a href="chapter3.xhtml#fig3-2">Figure 3-2</a> and <a href="chapter3.xhtml#fig3-1">Figure 3-1</a> is that the GUI is not actually implemented inside the main NTOS kernel executive. Instead, its system calls are implemented in the <i>WIN32K</i> driver, which interfaces with the object manager, the kernel, and the display drivers to handle user interactions and display the results. The <i>WIN32K</i> driver also implements a system call table that is separate from the kernel’s.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In versions of Windows prior to 10, the system call dispatch code in</i> <span class="note_Italic">WIN32U</span> <i>was embedded directly inside the user-mode DLLs. This made it hard for an application to directly call</i> <span class="note_Italic">WIN32K</span> <i>system calls without writing assembly language.</i></p>
</blockquote>
<p class="TX">The GUI APIs also interact with a special privileged process: the <i>Client Server Runtime Subsystem (CSRSS)</i>. This process is responsible for handling certain privileged operations for lower-privileged clients, such as configuring per-user drive mappings, process management, and error handling.</p>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-23"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GUI Kernel Resources</samp></h4>
<p class="TNI1">The GUI is made up of four types of kernel resources:</p>
<p class="RunInPara1"><b>Window stations    </b>Objects that represent the connection to the screen and the user interface, such as the keyboard and mouse</p>
<p class="RunInPara"><b>Windows    </b>GUI elements for interacting with the user, accepting input, and displaying a result</p>
<p class="RunInPara"><b>Desktops    </b>Objects that represent the visible desktop and act as a host for windows</p>
<p class="RunInPara2"><b>Drawing resources    </b>Bitmaps, fonts, or anything else that needs to be displayed to the user</p>
<p class="TX">While the Win32 kernel and user components handle the windows, the window stations and desktops are accessible through the object manager. There are kernel object types for window stations and desktops, as shown in <a href="chapter3.xhtml#Lis3-4">Listing 3-4</a>.</p>
<span id="Lis3-4"></span><pre><code>PS&gt; <b>Get-NtType WindowStation,Desktop</b>
Name
----
WindowStation
Desktop
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-4: Showing the WindowStation and Desktop type objects</span></p>
<p class="TX">A window station is assigned to a process either at process startup or using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetProcessWindowStation</samp> API. Desktops are assigned on a <span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"></span>per-thread basis using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUserSetThreadDesktop</samp>. We can query the names of the window stations and desktops with the commands in <a href="chapter3.xhtml#Lis3-5">Listing 3-5</a>.</p>
<span id="Lis3-5"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-NtWindowStationName</b>
WinSta0
Service-0x0-b17580b$

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtWindowStationName -Current</b>
WinSta0

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtDesktopName</b>
Default
WinLogon

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-NtDesktopName -Current</b>
Default
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-5: Displaying all the current window stations and desktops</span></p>
<p class="TX">We start by querying the names of all available window stations <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In this example, there are two: the default <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> window station and <samp class="SANS_TheSansMonoCd_W5Regular_11">Service-0x0-b17580b$</samp>, which another process has created. The ability to create separate window stations allows a process to isolate its GUI interactions from other processes running at the same time. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp> is special, as it is the only object connected to the user’s console.</p>
<p class="TX">Next, we check what our current window station name is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp> parameter <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can see we’re on <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>.</p>
<p class="TX">We then query for the names of the desktops on our current window station <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We see only two desktops: <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinLogon</samp> desktop will be visible only if you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktopName</samp> command as an administrator, as it’s used solely to display the login screen, which a normal user application shouldn’t be able to access. <samp class="SANS_TheSansMonoCd_W5Regular_11">Desktop</samp> objects must be opened relative to a window station path; there isn’t a specific object directory for desktops. Therefore, the name of the desktop reflects the name of the window station object.</p>
<p class="TX">Finally, we check the name of the current thread’s desktop <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The desktop we’re attached to is shown as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>, as that’s the only desktop available to normal user applications. We can enumerate the windows created in a desktop using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDesktop</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp> (<a href="chapter3.xhtml#Lis3-6">Listing 3-6</a>).</p>
<span id="Lis3-6"></span><pre><code>PS&gt; <b>$desktop = Get-NtDesktop -Current</b>
PS&gt; <b>Get-NtWindow -Desktop $desktop</b>
Handle ProcessId ThreadId ClassName
------ --------- -------- ---------
66104  11864     12848    GDI+ Hook Window Class
65922  23860     18536    ForegroundStaging
65864  23860     24400    ForegroundStaging
65740  23860     20836    tooltips_class32
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-6: Enumerating windows for the current desktop</span></p>
<p class="TX"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"></span>As you can see, each window has a few properties. First is its <i>handle</i>, which is unique to the desktop. This is not the same type of handle we discussed in the preceding chapter for kernel objects; instead, it’s a value allocated by the Win32 subsystem.</p>
<p class="TX">To function, a window receives <i>messages</i> from the system. For example, when you click a mouse button on a window, the system will send a message to notify the window of the click and what mouse button was pressed. The window can then handle the message and change its behavior accordingly. You can also manually send messages to a window using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SendMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp> APIs.</p>
<p class="TX">Each message consists of a numeric identifier—such as <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>, which represents the message <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp> to close a window—and two additional parameters. The meaning of the two parameters depends on the message. For example, if the message is <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>, then neither parameter is used; for other messages, they might represent pointers to strings or integer values.</p>
<p class="TX">Messages can be sent or posted. The difference between sending and posting a message is that sending waits for the window to handle the message and return a value, while posting just sends the message to the window and returns immediately.</p>
<p class="TX">In <a href="chapter3.xhtml#Lis3-6">Listing 3-6</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessId</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadId</samp> columns identify the process and thread that created a window using an API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp>. A window has what’s called <i>thread affinity</i>, which means that only the creating thread can manipulate the state of the window and handle its messages. However, any thread can send messages to the window. To handle messages, the creating thread must run a <i>message loop</i>, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetMessage</samp> API to receive the next available message and then dispatches it to the window’s message handler callback function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DispatchMessage</samp> API. When an application is not running the loop, you might see Windows applications hanging, as without the loop, the GUI cannot be updated.</p>
<p class="TX">The final column in <a href="chapter3.xhtml#Lis3-6">Listing 3-6</a> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>. This is the name of a <i>window class</i>, which acts as a template for a new window. When <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> is called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp> is specified and the window is initialized with default values from the template, such as the style of the border or a default size. It’s common for an application to register its own classes to handle unique windows. Alternatively, it can use system-defined classes for things like buttons and other common controls.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-24"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Window Messages</samp></h4>
<p class="TNI1">Let’s look at a simple example in <a href="chapter3.xhtml#Lis3-7">Listing 3-7</a>, in which we send a window message to find the caption text for all the windows on the desktop.</p>
<span id="Lis3-7"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$ws = Get-NtWindow</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$char_count = 2048</b>
PS&gt; <b>$buf = New-Win32MemoryBuffer -Length ($char_count*2)</b>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>foreach($w in $ws) {</b>
<b>    $len = Send-NtWindowMessage -Window $w -Message 0xD -LParam $buf.DangerousGetHandle() -WParam $char_count -Wait</b>
<span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"></span><b>    $txt = $buf.ReadUnicodeString($len.ToInt32())</b>
<b>    if ($txt.Length -eq 0) {</b>
<b>        continue</b>
<b>    }</b>
<b>    "PID: $($w.ProcessId) - $txt"</b>
<b>}</b>
PID: 10064 - System tray overflow window.
PID: 16168 - HardwareMonitorWindow
PID: 10064 - Battery Meter
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-7: Sending the WM_GETTEXT message to all windows on the desktop</span></p>
<p class="TX">First, we enumerate all the windows on the current desktop using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtWindow</samp> command <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we allocate a memory buffer to store 2,048 characters <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Keep in mind that we’ll be using this buffer to store 16-bit Unicode characters, so the number of characters must be multiplied by 2 to determine the size in bytes for the buffer.</p>
<p class="TX">In a loop <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, we then send the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_GETTEXT</samp> message (which is message number <samp class="SANS_TheSansMonoCd_W5Regular_11">0xD</samp>) to every window to query the window’s caption. We need to specify two parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">LParam</samp>, which is a pointer to the buffer we allocated, and <samp class="SANS_TheSansMonoCd_W5Regular_11">WParam</samp>, which is the maximum number of Unicode characters in the buffer. The values passed in these two parameters will be different for different message types. We wait to receive the result of sending the message, which indicates the number of characters that were copied into the buffer. We can then read out the caption string and print it to the output, ignoring any windows that have an empty caption.</p>
<p class="TX">There is much more to explore in the windowing system, but those details are outside the scope of this book. I recommend Charles Petzold’s seminal work on the topic, <i>Programming Windows</i>, 5th edition (Microsoft Press, 1998), if you want to know more about the development of Win32 applications. Next, we’ll look at how multiple users can use their own user interfaces on the same system through the creation of console sessions.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-25"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Console Sessions</samp></h4>
<p class="TNI1">The first version of Windows NT allowed multiple users to be authenticated at the same time and each run processes. However, before the introduction of <i>Remote Desktop Services (RDS)</i>, it wasn’t possible for different interactive desktops to run multiple user accounts concurrently on the same machine. All authenticated users needed to share a single physical console. Windows NT 4 introduced multiple-console support as an optional, server-only feature before it became standard in Windows XP.</p>
<p class="TX">RDS is a service on Windows workstations and servers that allows you to remotely connect to the GUI and interact with the system. It’s used for remote administration and to provide shared hosting for multiple users on the same network-connected system. In addition, its functionality has been repurposed to support a mechanism that can switch between users on the same system without having to log users out.</p>
<p class="TX"><span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"></span>To prepare for a new user login to Windows, the session manager service creates a new session on the console. This session is used to organize a user’s window station and desktop objects so that they’re separate from those belonging to any other user authenticated at the same time. The kernel creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> object to keep track of resources, and a named reference to the object is stored in the <i>KernelObjects</i> OMNS directory. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> object is usually only exposed to the user as an integer. There’s no randomness to the integer; it’s just incremented as each new console session is created.</p>
<p class="TX">The session manager starts several processes in this new session before any user logs in. These include a dedicated copy of CSRSS and the Winlogon process, which display the <i>credentials</i> user interface and handle the authentication of the new user. We’ll dig into the authentication process more in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>.</p>
<p class="TX">The console session that a process belongs to is assigned when the process starts. (Technically, the console session is specified in the access token, but that’s a topic for <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.) We can observe the processes running in each session by running some PowerShell commands, as shown in <a href="chapter3.xhtml#Lis3-8">Listing 3-8</a>.</p>
<span id="Lis3-8"></span><pre><code>PS&gt; <b>Get-NtProcess -InfoOnly | Group-Object SessionId</b>
Count Name        Group
----- ----        -----
  156 0           {, System, Secure System, Registry...}
    1 1           {csrss.exe}
    1 2           {csrss.exe}
  113 3           {csrss.exe, winlogon.exe, fontdrvhost.exe, dwm.exe...}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-8: Displaying the processes in each console session using Get-NtProcess</span></p>
<p class="TX">Windows has only one physical console, which is connected to the keyboard, mouse, and monitor. However, it’s possible to create a new remote desktop over the network by using a client that communicates using the <i>Remote Desktop Protocol (RDP)</i>.</p>
<p class="TX">It’s also possible to switch the user logged on to the physical console; this enables support for the <i>Fast User Switching</i> feature in Windows. When the physical console switches to a new user, the previous user is still logged on and running in the background, but you cannot interact with that user’s desktop.</p>
<p class="TX">Each console session has its own special kernel memory region. Having duplicated resources ensures that the console sessions are separated; this acts as a security boundary. Session number 0 is special, in that it’s only for privileged services and system management. It’s normally not possible to use a GUI with processes running in this session.</p>
<aside aria-label="box-14" class="box">
<p class="BoxTitle" id="box-14"><span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">SHATTER ATTACKS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Prior to Windows Vista, both services and the physical console ran in session 0. As any process was able to send window messages to any other process in the same session, this introduced a security weakness called a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">shatter attack</samp><samp class="SANS_Futura_Std_Book_11">. A shatter attack occurs when a normal user can send a window message to a more privileged application in the same session to elevate privileges. For example, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_TIMER</samp> <samp class="SANS_Futura_Std_Book_11">message could accept an arbitrary function pointer that the more privileged application would call when it received the message. A normal user could send this message with a carefully chosen function pointer to enable arbitrary code execution in the context of the privileged application.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Windows Vista mitigated shatter attacks with two related security features that are still present in the latest versions of Windows. The first was</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Session 0 Isolation</samp><samp class="SANS_Futura_Std_Book_11">, which moved the physical console out of session 0 so that a normal user application cannot send messages to services. The second,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">User Interface Privilege Isolation (UIPI)</samp><samp class="SANS_Futura_Std_Book_11">, prevents lower-privileged processes from interacting with windows at higher privileges. Therefore, even if a service creates a window on the user’s desktop, the system will reject any messages sent by the user to a privileged service.</samp></p>
</aside>
<p class="TX">Another important feature associated with console sessions is the separation of named objects. In the previous chapter we discussed the <i>BaseNamedObjects</i> directory, which is a global location for named objects that provides a means for multiple users to share resources. However, if multiple users can be logged in to the system at the same time, you could easily get name conflicts. Windows solves this problem by creating a per-console session BNO directory at <i>\Sessions\&lt;N&gt;\BaseNamedObjects</i>, where <i>&lt;N&gt;</i> is the console session ID. The <i>\Sessions</i> directory also contains a directory for the window stations, under <i>\Sessions\&lt;N&gt;\Windows</i>, which ensures that window resources, too, are separated. You can list the BNO directory of the current console session with the <i>NtObjectSession</i> drive, as shown in <a href="chapter3.xhtml#Lis3-9">Listing 3-9</a>.</p>
<span id="Lis3-9"></span><pre><code>PS&gt; <b>ls NtObjectSession:\ | Group-Object TypeName</b>
Count Name                Group
----- ----                -----
  246 Semaphore           {SM0:10876:304:WilStaging_02_p0h...}
  263 Mutant              {SM0:18960:120:WilError_02,...}
  164 Section             {fd8HWNDInterface:3092e,...}
  159 Event               {BrushTransitionsCom...}
    4 SymbolicLink        {AppContainerNamedObjects, Local, Session, Global}
    1 ALPC Port           {SIPC_{2819B8FF-EB1C-4652-80F0-7AB4EFA88BE4}}
    2 Job                 {WinlogonAccess, ProcessJobTracker1980}
    1 Directory           {Restricted}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-9: The contents of a session’s BNO directory</span></p>
<p class="TX"><span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"></span>There is no per-console session BNO for session 0; it uses the global BNO directory.</p>
<aside aria-label="box-15" class="box">
<p class="BoxTitle" id="box-15"><samp class="SANS_Dogma_OT_Bold_B_11">THE ORIGINS OF REMOTE DESKTOP SERVICES</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The RDS feature didn’t originate at Microsoft. Rather, a company called Citrix developed the technology for Windows and licensed it to Microsoft for use in NT 4. The technology was originally called Terminal Services, so it’s common to sometimes see it referred to using that name. To this day, it’s possible to buy a Citrix version of RDS that uses a different network protocol, Independent Computing Architecture (ICA), instead of Microsoft’s RDP.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-23"></span><samp class="SANS_Futura_Std_Bold_B_11">Comparing Win32 APIs and System Calls</samp></h3>
<p class="TNI1">Not all system calls are directly exposed through Win32, and in some cases, the Win32 API reduces the functionality of exposed system calls. In this section, we’ll look at some common differences between system calls and their Win32 API equivalents.</p>
<p class="TX">As a case study, we’ll consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API, the Win32 version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> system call we looked at in the preceding chapter. The API has the C prototype shown in <a href="chapter3.xhtml#Lis3-10">Listing 3-10</a>.</p>
<span id="Lis3-10"></span><pre><code>HANDLE CreateMutexEx(
    SECURITY_ATTRIBUTES* lpMutexAttributes,
    const WCHAR*         lpName,
    DWORD                dwFlags,
    DWORD                dwDesiredAccess
);
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-10: The prototype for the CreateMutexEx Win32 API</span></p>
<p class="TX">Compare it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> prototype, shown in <a href="chapter3.xhtml#Lis3-11">Listing 3-11</a>.</p>
<span id="Lis3-11"></span><pre><code>NTSTATUS NtCreateMutant(
    HANDLE*              MutantHandle,
    ACCESS_MASK          DesiredAccess,
    OBJECT_ATTRIBUTES*   ObjectAttributes,
    BOOLEAN              InitialOwner
);
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-11: The prototype for the NtCreateMutant system call</span></p>
<p class="TX">The first difference between the prototypes is that the Win32 API returns a handle to the kernel object, while the system call returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code (and receives the handle via a pointer as the first parameter instead).</p>
<p class="TX"><span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"></span>You might wonder: How do errors get propagated back to an API’s caller, if not via an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code? In this respect, the Win32 APIs are not always consistent. If the API returns a handle, then it’s common to return a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>. However, some APIs, such as the file APIs, return the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> instead. If a handle is not returned, it’s common to return a Boolean value, with <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp> indicating success and <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp> indicating an error.</p>
<p class="TX">But what if we want to know <i>why</i> the API failed? For this purpose, the APIs define a set of error codes. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> codes, these error codes don’t have any structure; they’re just numbers. When a Windows API fails, you can query for this error code by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp> API.</p>
<p class="TX"><i>NTDLL</i> provides an <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlNtStatusToDosError</samp> API to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code to a predefined Win32 error code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API can convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> code to a Win32 error code on failure, then write it to the last error location for the current thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp> API.</p>
<p class="TX">We can look up error codes in PowerShell using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Error</samp>, as shown in <a href="chapter3.xhtml#Lis3-12">Listing 3-12</a>.</p>
<span id="Lis3-12"></span><pre><code>PS&gt; <b>Get-Win32Error 5</b>
ErrorCode Name                Message
--------- ----                -------
        5 ERROR_ACCESS_DENIED Access is denied.
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-12: Looking up Win32 error code 5</span></p>
<p class="TX">The second big difference between the system call and the Win32 API is that the API does not take the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure. Instead, it splits the attributes between two parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp>, used to specify the object’s name, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpMutexAttributes</samp>, which is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp> structure.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpName</samp> parameter is a NUL-terminated string composed of 16-bit Unicode characters. Even though the object manager uses the counted <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>, the Win32 API uses a C-style terminated string. This means that while the NUL character is a valid character for an object name, it’s impossible to specify using the Win32 API.</p>
<p class="TX">Another difference is that the name is not a full path to the OMNS location for the object; instead, it’s relative to the current session’s BNO directory. This means that if the name is <i>ABC</i>, then the final path used is <i>\Sessions\&lt;N&gt;\BaseNamedObjects\ABC</i>, where <i>&lt;N&gt;</i> is the console session ID. If you want to create an object in the global BNO directory, you can prefix the name with <i>Global</i> (for example, <i>Global\ABC</i>). This works because <i>Global</i> is a symbolic link to <i>\BaseNamedObjects</i>, which is automatically created along with the per-session BNO directory. If you want to simulate this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> PowerShell commands, pass them the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Win32Path</samp> option, as shown in <a href="chapter3.xhtml#Lis3-13">Listing 3-13</a>.</p>
<span id="Lis3-13"></span><pre><code>PS&gt; <b>$m = New-NtMutant ABC -Win32Path</b>
PS&gt; <b>$m.FullPath</b>
\Sessions\2\BaseNamedObjects\ABC
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-13: Creating a new Mutant with -Win32Path</span></p>
<p class="TX"><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"></span><a href="chapter3.xhtml#Lis3-14">Listing 3-14</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_ATTRIBUTES</samp> structure.</p>
<span id="Lis3-14"></span><pre><code>struct SECURITY_ATTRIBUTES {
    DWORD  nLength;
    VOID*  lpSecurityDescriptor;
    BOOL   bInheritHandle;
};
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-14: The SECURITY_ATTRIBUTES structure</span></p>
<p class="TX">This allows you to specify the security descriptor of the new object, as well as whether the handle should be inheritable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> Win32 API exposes no other options from <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>.</p>
<p class="TX">This brings us to the final two parameters in <a href="chapter3.xhtml#Lis3-10">Listing 3-10</a>: <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> directly maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>, and the native <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp> parameter is specified through <samp class="SANS_TheSansMonoCd_W5Regular_11">dwFlags</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_MUTEX_INITIAL_OWNER</samp> flag.</p>
<p class="TX">One surprise you might encounter may occur if you try to look up the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API in the export table of the <i>KERNEL32</i> DLL (<a href="chapter3.xhtml#Lis3-15">Listing 3-15</a>).</p>
<span id="Lis3-15"></span><pre><code>PS&gt; <b>Get-Win32ModuleExport "kernel32.dll" -ProcAddress CreateMutexEx</b>
Exception calling "GetProcAddress" with "2" argument(s):
"(0x8007007F) - The specified procedure could not be found."
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-15: Getting CreateMutexEx from</span> <samp class="SANS_Futura_Std_Book_11">KERNEL32</samp></p>
<p class="TX">Instead of receiving the address, we get an exception. Did we pick the wrong library? Let’s try to find the API by dumping all exports and filtering them by name, as shown in <a href="chapter3.xhtml#Lis3-16">Listing 3-16</a>.</p>
<span id="Lis3-16"></span><pre><code>PS&gt; <b>Get-Win32ModuleExport "kernel32.dll" | Where-Object Name -Match CreateMutexEx</b>

Ordinal Name           Address
------- ----           -------
217     CreateMutexExA 0x7FFA088C1EB0
218     CreateMutexExW 0x7FFA088C1EC0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-16: Finding the CreateMutexEx API by listing all exports</span></p>
<p class="TX">As you can see, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp> API is there not once, but twice. Each function has a suffix, either <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. This is because Windows 95 (where most of the APIs were initially created) didn’t natively support Unicode strings, so the APIs used single-character strings in the current text encoding. With the introduction of Windows NT, the kernel became 100 percent Unicode, but it provided two APIs for a single function to enable older Windows 95 applications.</p>
<p class="TX">APIs with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix accept single-character strings, or <i>ANSI strings</i>. These APIs convert their strings into Unicode strings to pass to the kernel, and they convert them back again if a string needs to be returned. Applications built for Windows NT, on the other hand, can use the APIs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix, for <i>wide string</i>; these don’t need to do any string <span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"></span>conversions. Which API you get when you build a native application depends on your build configuration and is a topic for a completely different book.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="h1-24"></span><samp class="SANS_Futura_Std_Bold_B_11">Win32 Registry Paths</samp></h3>
<p class="TNI1">In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, you learned the basics of how to access the registry with native system calls using paths in the OMNS. The Win32 APIs used to access the registry, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RegCreateKeyEx</samp>, do not expose these OMNS paths. Instead, you access registry keys relative to predefined root keys. You’ll be familiar with these keys if you’ve ever used the Windows regedit application, shown in <a href="chapter3.xhtml#fig3-3">Figure 3-3</a>.</p>
<figure class="IMG"><img alt="" class="img1" height="726" id="fig3-3" src="../images/Figure3-3.jpg" width="1388"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The main view of the regedit utility</samp></p></figcaption>
</figure>
<p class="TX">The handle values displayed in <a href="chapter3.xhtml#fig3-3">Figure 3-3</a> are listed in <a href="chapter3.xhtml#tab3-1">Table 3-1</a> along with their corresponding OMNS paths.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab3-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Predefined Registry Handles and Their Native Equivalents</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Predefined handle name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">OMNS path</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Hardware Profiles\Current</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\&lt;SDDL SID&gt;</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Merged view of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\MACHINE\SOFTWARE\Classes</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">\REGISTRY\USER\&lt;SDDL SID&gt;_Classes</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The first three predefined handles, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_USERS</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_CONFIG</samp>, are not particularly special; they directly map to a single <span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"></span>OMNS registry key path. The next handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>, is more interesting; it maps to a hive loaded for the currently authenticated user. The name of the hive’s key is the SDDL string of the user’s SID.</p>
<p class="TX">The final key, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp>, which stores information such as file extension mappings, is a merged view of a user’s classes hive and the machine’s hive. The user’s hive takes precedence over the machine’s, allowing the user to change their file extensions without needing an administrator.</p>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-26"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Keys</samp></h4>
<p class="TNI1">When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands, we can specify a Win32 path by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> parameter (<a href="chapter3.xhtml#Lis3-17">Listing 3-17</a>).</p>
<span id="Lis3-17"></span><pre><code>PS&gt; <b>Use-NtObject($key = Get-NtKey \REGISTRY\MACHINE\SOFTWARE) {</b>
<b>    $key.Win32Path</b>
<b>}</b>
HKEY_LOCAL_MACHINE\SOFTWARE

PS&gt; <b>Use-NtObject($key = Get-NtKey -Win32Path "HKCU\SOFTWARE") {</b>
<b>    $key.FullPath</b>
<b>}</b>
\REGISTRY\USER\S-1-5-21-818064985-378290696-2985406761-1002\SOFTWARE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-17: Interacting with the registry using Win32 paths</span></p>
<p class="TX">We start by opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> command. We use the OMNS path to open the key, then convert the path to its Win32 version using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> property. In this case, we see that <i>\REGISTRY\MACHINE\SOFTWARE</i> is mapped to <i>HKEY_LOCAL_MACHINE\SOFTWARE</i>.</p>
<p class="TX">We then do the reverse and open a key using a Win32 name by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> parameter and printing its native OMNS path. Here, we use the current user’s hive. Notice we’re using a shortened form of the predefined key name: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU</samp>, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>. All the other predefined keys have similar shortened forms; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM</samp> refers to <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>.</p>
<p class="TX">In the output, you can see the SDDL SID string, which represents the current user. As this example demonstrates, using the Win32 path to access the current user’s hive is much simpler than looking up the current user’s SID and opening it with the OMNS path.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-27"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing the Registry’s Contents</samp></h4>
<p class="TNI1">In the previous chapter, you saw how to list the registry’s contents using the <i>NtObject</i> or <i>NtKey</i> drive provider path. For the Win32 registry, you have a few additional options. To simplify accessing the current user’s hive, you can use <i>NtKeyUser</i>. For example, you can list the current user’s software key with the following:</p>
<pre><code>PS&gt; <b>ls NtKeyUser:\SOFTWARE</b>
</code></pre>
<p class="TX"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"></span>PowerShell also comes with built-in drives, <i>HKLM</i> and <i>HKCU</i>, for the local machine and current user’s hives, respectively. For example, the equivalent to the previous command is the following:</p>
<pre><code>PS&gt; <b>ls HKCU:\SOFTWARE</b>
</code></pre>
<p class="TX">Why would you use one of these drive providers over another? Well, the PowerShell module’s drive providers have the advantage of allowing you to view the entire registry. They also use the native APIs, which use counted strings and support the use of NUL characters in the names of the registry keys and values. In contrast, the Win32 APIs use NUL-terminated C-style strings, which cannot handle embedded NUL characters. Therefore, if a NUL is embedded into a name, it’s impossible for the built-in provider to access that key or value. <a href="chapter3.xhtml#Lis3-18">Listing 3-18</a> demonstrates this.</p>
<span id="Lis3-18"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$key = New-NtKey -Win32Path "HKCU\ABC`0XYZ"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-Item "NtKeyUser:\ABC`0XYZ"</b>
Name<b>    </b>TypeName
----<b>    </b>--------
ABC XYZ Key

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-Item "HKCU:\ABC`0XYZ"</b>
Get-Item : Cannot find path 'HKCU:\ABC XYZ' because it does not exist.

PS&gt; <b>Remove-NtKey $key</b>
PS&gt; <b>$key.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-18: Adding and accessing a registry key with a NUL character</span></p>
<p class="TX">We start by creating a new key with a NUL character in the name, indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">`0</samp> escape <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If you access this path via the <i>NtKeyUser</i> drive, you can successfully retrieve the key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. However, if you try this with the built-in drive provider, it doesn’t work; it can’t find the registry key <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">This behavior of the Win32 APIs can lead to security issues. For example, it’s possible for malicious code to hide registry keys and values from any software that uses the Win32 APIs by embedding NUL characters in the name. This can prevent the malicious code from being detected. We’ll see how to uncover the use of this hiding technique in <span class="Xref">“Finding Hidden Registry Keys or Values” on page 94</span>.</p>
<p class="TX">It’s also possible to get a mismatch if some software uses the native system calls and other software uses the Win32 APIs. For example, if some code checks the <i>ABC`0XYZ</i> path to ensure it has been correctly set up, then hands this to another application, which uses the path with the Win32 APIs, the new application will instead access the unrelated <i>ABC</i> key, which hasn’t been checked. This could lead to information disclosure issues if the contents of <i>ABC</i> were returned to the caller.</p>
<p class="TX">The built-in registry provider does have an advantage too: it can be used without the installation of an external module. It also allows you to create new keys and add values, which the module’s provider does not allow you to do.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-25"></span><span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">DOS Device Paths</samp></h3>
<p class="TNI1">Another big difference between the Win32 APIs and the native system calls is how they handle filepaths. In the previous chapter, we saw that we can access a mounted filesystem using a <i>Device\&lt;VolumeName&gt;</i> path. However, we can’t specify this native path using the Win32 APIs. Instead, we use well-known paths, such as <i>C:\Windows</i>, that have drive letters. Because the drive letter paths are a vestige of MS-DOS, we call them <i>DOS device paths</i>.</p>
<p class="TX">Of course, the Win32 API needs to pass the system call a native path for the system call to work correctly. The <i>NTDLL</i> API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp> handles this conversion process. This API takes a DOS device path and returns the fully converted native path. The simplest conversion occurs when the caller has supplied a full drive path: for example, <i>C:\Windows</i>. In these cases, the conversion process merely prefixes the path with the predefined path component <i>\??</i> to get the result <i>\??\C:\Windows</i>.</p>
<p class="TX">The <i>\??</i> path, also called the <i>DOS device map prefix</i>, indicates that the object manager should use a two-step lookup process to find the drive letter. The object manager will first check a per-user DOS device map directory, in the path <i>Sessions\0\DosDevices\&lt;AUTHID&gt;</i>. Because the object manager checks a per-user location first, each user can create their own drive mappings. The <i>&lt;AUTHID&gt;</i> component is related to the authentication session of the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>; I’ll describe this in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, but for now, it’s enough to know that its value is unique for each user. Note that the use of <i>0</i> for the console session ID is not a typo: all DOS device mappings are placed in a single location, regardless of which console session the user is logged in to.</p>
<p class="TX">If the drive letter is not found in the per-user location, the object manager will check a global directory, <i>GLOBAL??</i>. If it’s not found there, then the file lookup fails. The drive letter is an object manager symbolic link that points to the mounted volume device. We can see this in action by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSymbolicLink</samp> command to open the drive letters and display their properties (<a href="chapter3.xhtml#Lis3-19">Listing 3-19</a>).</p>
<span id="Lis3-19"></span><pre><code>PS&gt; <b>Use-NtObject($cdrive = Get-NtSymbolicLink "\??\C:") {</b>
    <b>$cdrive | Select-Object FullPath, Target</b>
<b>}</b>
FullPath     Target
--------     ------
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> \GLOBAL??\C: \Device\HarddiskVolume3

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Add-DosDevice Z: C:\Windows</b>
PS&gt; <b>Use-NtObject($zdrive = Get-NtSymbolicLink "\??\Z:") {</b>
    <b>$zdrive | Select-Object FullPath, Target</b>
<b>}</b>
FullPath                                    Target
--------                                    ------
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> \Sessions\0\DosDevices\00000000-011b224b\Z: \??\C:\windows

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Remove-DosDevice Z:</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-19: Displaying the symbolic links for the</span> <samp class="SANS_Futura_Std_Book_11">C:</samp> <span class="Futura_Std_Book_Oblique_I_11">and</span> <samp class="SANS_Futura_Std_Book_11">Z:</samp> <span class="Futura_Std_Book_Oblique_I_11">drives</span></p>
<p class="TX"><span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"></span>First, we open the <i>C:</i> drive symbolic link and display its <samp class="SANS_TheSansMonoCd_W5Regular_11">FullPath</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> properties. The full path is in the <i>\GLOBAL??</i> directory, and the target is the volume path <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then create a new <i>Z:</i> drive using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-DosDevice</samp> command, pointing the drive to the <i>Windows</i> directory <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Note that the <i>Z:</i> drive is accessible in any user application, not just in PowerShell. Displaying the <i>Z:</i> drive’s properties reveals that it’s in the per-user DOS device map and that the target is the native path to the <i>Windows</i> directory <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This shows that the target of a drive letter doesn’t have to point directly to a volume, as long as it gets there eventually (in this case, after following the <i>C:</i> drive symbolic link). Finally, for completeness, we remove the <i>Z:</i> drive with <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-DosDevice</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-28"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Path Types</samp></h4>
<p class="TNI1"><a href="chapter3.xhtml#tab3-2">Table 3-2</a> shows several different path types that the Win32 APIs support, along with example native paths after conversion.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab3-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Win32 Path Types</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">DOS path</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Native path</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">some\path</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Relative path to current directory</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Absolute path</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">C:some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\ABC\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Drive relative path</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Rooted to current drive</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\\.\C:\some\..\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Device path, canonicalized</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\\?\C:\some\..\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\..\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\C:\some\path</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Device path, non-canonicalized</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\\server\share\path</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">\??\UNC\server\share\path</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">UNC path to share on server</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Due to the way DOS paths are specified, multiple DOS paths might represent the same native path. To ensure the final native path is correct, the DOS path must go through a <i>canonicalization</i> process to convert these different representations into the same canonical form.</p>
<p class="TX">One simple operation undertaken in canonicalization is the handling of path separators. For native paths, there is only one path separator, the backslash (<i>\</i>) character. If you use a forward slash (<i>/</i>), the object manager will treat it as just another filename character. However, DOS paths support both forward slashes and backslashes as path separators. The canonicalization process takes care of this by ensuring all forward slashes are converted to backslashes. Therefore, <i>C:\Windows</i> and <i>C:/Windows</i> are equivalent.</p>
<p class="TX">Another canonicalization operation is the resolving of parent directory references. When writing a DOS path, you might specify a filename with one dot (<i>.</i>) or two dots (<i>..</i>), each of which has a special meaning. A single dot refers to the current directory, and the canonicalization process will remove it from the path. A double dot refers to the parent, so the parent directory will be removed. Therefore, the path <i>C:\ABC\.\XYZ</i> will get converted to <i>C:\ABC\XYZ</i>, and <i>C:\ABC\..\XYZ</i> will get converted to <i>C:\XYZ</i>. As with the <span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"></span>forward slash, the native APIs do not know about these special filenames and will assume that they’re the names of the file to look up.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Most other operating systems, such as Linux, handle this canonicalization process in the kernel. However, due to the subsystem model, Windows must do the path canonicalization in user mode, inside the subsystem-specific library. This is to support any differences in behavior in OS/2 and POSIX environments.</i></p>
</blockquote>
<p class="TX">If the DOS path is prefixed with <i>\\?\</i> or <i>\??\</i>, then the path is not canonicalized and is instead used verbatim, including any parent directory references or forward slashes. In some cases, the <i>\??\</i> prefix can confuse the Win32 APIs with a current drive–rooted path, resulting in the opening of a path such as <i>\??\C:\??\Path</i>. It’s unclear why Microsoft added this DOS path type, considering its potential for confusion.</p>
<p class="TX">You can manually convert a Win32 path to a native path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp> command. You can also check the path type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePathType</samp> command. <a href="chapter3.xhtml#Lis3-20">Listing 3-20</a> shows some examples of using these commands.</p>
<span id="Lis3-20"></span><pre><code>PS&gt; <b>Set-Location $env:SystemRoot</b>
PS C:\Windows&gt; <b>Get-NtFilePathType "."</b>
Relative

PS C:\Windows&gt; <b>Get-NtFilePath "."</b>
\??\C:\Windows

PS C:\Windows&gt; <b>Get-NtFilePath "..\"</b>
\??\C:\

PS C:\Windows&gt; <b>Get-NtFilePathType "C:ABC"</b>
DriveRelative

PS C:\Windows&gt; <b>Get-NtFilePath "C:ABC"</b>
\??\C:\Windows\ABC

PS C:\Windows&gt; <b>Get-NtFilePathType "\\?\C:\abc/..\xyz"</b>
LocalDevice

PS C:\Windows&gt; <b>Get-NtFilePath "\\?\C:\abc/..\xyz"</b>
\??\C:\abc/..\xyz
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-20: Examples of Win32 filepath conversion</span></p>
<p class="TX">When you’re using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp> command, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp> property to treat the path as a Win32 path and automatically convert it.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-29"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Maximum Path Lengths</samp></h4>
<p class="TNI1">The maximum filename length supported by Windows is limited by the maximum number of characters that can be stored in a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> <span aria-label=" Page 86. " epub:type="pagebreak" id="pg_86" role="doc-pagebreak"></span>structure (32,767). However, Win32 APIs have a stricter requirement. By default, as shown in <a href="chapter3.xhtml#Lis3-21">Listing 3-21</a>, any attempt to pass a path longer than the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp>, defined as 260 characters, will fail. This behavior is implemented inside the <i>NTDLL</i> API <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp> when converting the path from Win32 to native format.</p>
<span id="Lis3-21"></span><pre><code>PS&gt; <b>$path = "C:\$('A'*256)"</b>
PS&gt; <b>$path.Length</b>
259

PS&gt; <b>Get-NtFilePath -Path $path</b>
\??\C:\AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...

PS&gt; <b>$path += "A"</b>
PS&gt; <b>$path.Length</b>
260

PS&gt; <b>Get-NtFilePath -Path $path</b>
Get-NtFilePath : "(0xC0000106) - A specified name string is too long..."

PS&gt; <b>$path = "\\?\" + $path</b>
PS&gt; <b>$path.Length</b>
264

PS&gt; <b>Get-NtFilePath -Path $path</b>
\??\C:\AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-21: Testing the Win32 MAX_PATH path limit</span></p>
<p class="TX">We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDosPathNameToNtPathName</samp> API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFilePath</samp> command. The first path we create is 259 characters long, which we can successfully convert to a native path. We then add one more character to the path, making the path 260 characters long; this attempt fails with the error <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NAME_TOO_LONG</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAX_PATH</samp> is 260, you may be wondering: Shouldn’t a 260-character-long path succeed? Unfortunately, no. The APIs include the NUL-terminating character as part of the path’s length, so the maximum path length is really only 259 characters.</p>
<p class="TX"><a href="chapter3.xhtml#Lis3-21">Listing 3-21</a> also shows a way of bypassing this limitation. If we add the device prefix <i>\\?\</i> to the path, the conversion succeeds even though the length of the path is now 264 characters. This is because the prefix is replaced with the DOS device prefix <i>\??\</i>, and the remaining path is left verbatim. While this technique works, note that it also disables useful features, such as path canonicalization. As another workaround, in current versions of Windows there is a way of opting into long filenames, as shown in <a href="chapter3.xhtml#Lis3-22">Listing 3-22</a>.</p>
<span id="Lis3-22"></span><pre><code>PS&gt; <b>$path = "HKLM\SYSTEM\CurrentControlSet\Control\FileSystem"</b>
PS&gt; <b>Get-NtKeyValue -Win32Path $path -Name "LongPathsEnabled"</b>
Name             Type  DataObject
----             ----  ----------
LongPathsEnabled Dword 1

<span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"></span>PS&gt; <b>(Get-Process -Id $pid).Path | Get-Win32ModuleManifest |</b>
<b>Select-Object LongPathAware</b>
LongPathAware
-------------
        <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> True

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$path = "C:\$('A'*300)"</b>
PS&gt; <b>$path.Length</b>
303

PS&gt; <b>Get-NtFilePath -Path $path</b>
\??\C:\AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-22: Checking and testing long, path-aware applications</span></p>
<p class="TX">The first thing we do here is verify that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathsEnabled</samp> registry value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. The value must be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> before the process starts, as it will be read only once during process initialization. However, just enabling the long path feature isn’t sufficient: the process’s executable file must opt in by specifying a manifest property. We can query this property by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ExecutableManifest</samp> command and selecting <samp class="SANS_TheSansMonoCd_W5Regular_11">LongPathAware</samp>. Fortunately, PowerShell has this manifest option enabled <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We can now convert much larger paths successfully, as shown with a 303-character path <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Are long paths a security issue? It’s common for security issues to be introduced in places where there is an interface boundary. In this case, the fact that a filesystem can support exceptionally long paths could lead to the incorrect assumption that a filepath can never be longer than 260 characters. A possible issue might occur when an application queries the full path to a file and then copies that path into a memory buffer with a fixed size of 260 characters. If the length of the filepath is not first checked, this operation could result in the corruption of memory after the buffer, which might allow an attacker to gain control of the application’s execution.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H1" id="sec16"><span id="h1-26"></span><samp class="SANS_Futura_Std_Bold_B_11">Process Creation</samp></h3>
<p class="TNI1">Processes are the main way to execute user-mode components and isolate them for security purposes, so it’s important that we explore how to create them in detail. In the previous chapter, I mentioned that you can create a process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp> system call. However, most processes won’t be created directly using this system call; rather, they’ll be created with the Win32 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API, which acts as a wrapper.</p>
<p class="TX">The system call isn’t often used directly, because most processes need to interact with other user-mode components, especially CSRSS, to interact with the user’s desktop. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API will register the new process created by the system call with the appropriate services necessary for correct initialization. We won’t discuss process and thread creation in detail in this book, but in this section I’ll give a quick overview.</p>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-30"></span><span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Parsing</samp></h4>
<p class="TNI1">The simplest way to create a new process is to specify a command line string representing the executable to run. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API will then parse the command line to find the executable file to pass to the kernel.</p>
<p class="TX">To test this command line parsing, let’s create a new process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> PowerShell command, which executes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> under the hood. We could use a built-in command such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp> to do this, but <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> is useful because it exposes the full set of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API’s functionality. We can start a process using the following command:</p>
<pre><code>PS&gt; <b>$proc = New-Win32Process -CommandLine "notepad test.txt"</b>
</code></pre>
<p class="TX">We provide a command line containing the name of the executable to run, Notepad, and the name of a file to open, <i>test.txt</i>. This string doesn’t necessarily need to provide a full path to the executable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> command will parse the command line to try to distinguish the name of the initial executable image file from the file to open. That’s not as simple a process as it sounds.</p>
<p class="TX">The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> will do is parse the command line using an algorithm that splits on whitespace, unless that whitespace is enclosed in double quotes. In this case, it will parse the command line into two strings, <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test.txt</samp>. The command then takes the first string and tries to find a matching process. However, there’s a slight complication: there is no <i>notepad</i> executable file, only <i>notepad.exe</i>. Though it’s not required, Windows executables commonly have a <i>.exe</i> extension, so the search algorithm will automatically append this extension if one doesn’t already exist.</p>
<p class="TX">The command will then search the following locations for the executable, much like the DLL path searching we discussed in <span class="Xref">“Searching for DLLs” on page 68</span>. Note that the executable search path is the same as the unsafe DLL search path:</p>
<p class="ListNumber1">  1.  The same directory as the current process’s executable file</p>
<p class="ListNumber">  2.  The current working directory</p>
<p class="ListNumber">  3.  The Windows <i>System32</i> directory</p>
<p class="ListNumber">  4.  The <i>Windows</i> directory</p>
<p class="ListNumber2">  5.  Each semicolon-separated location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATH</samp> environment variable</p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> can’t find <i>notepad.exe</i>, it will next try to find the file <i>notepad test.txt</i>, in case that’s what we meant. As the filename has an extension already, it won’t replace it with <i>.exe</i>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> can’t find the file, it returns an error. Note that if we passed <samp class="SANS_TheSansMonoCd_W5Regular_11">notepad</samp> surrounded by double quotes, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">"notepad" test.txt</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> would search for <i>notepad.exe</i> only and never fall back to trying all combinations of the name with the whitespace.</p>
<p class="TX">This command line parsing behavior has two security implications. First, if the process is being created by a more privileged process and a less <span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"></span>privileged user can write a file to a location earlier in the path search list, then the process could be hijacked.</p>
<p class="TX">The second security implication is that the path-searching algorithm changes if the first value contains a path separator. In this case, instead of using the path-searching rules, <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> splits the path by whitespace and then tries each component as if it were a path, searching for the name either with the <i>.exe</i> extension or without it.</p>
<p class="TX">Let’s look at an example. If we specify a command line of <samp class="SANS_TheSansMonoCd_W5Regular_11">C:\Program Files\abc.exe</samp>, then the following paths will be searched for the executable file:</p>
<ul class="ul">
<li class="ListBullet"><i>C:\Program</i></li>
<li class="ListBullet"><i>C:\Program.exe</i></li>
<li class="ListBullet"><i>C:\Program Files\abc.exe</i></li>
<li class="ListBullet"><i>C:\Program Files\abc.exe.exe</i></li>
</ul>
<p class="TX">If the user could write the file <i>C:\Program</i> or <i>C:\Program.exe</i>, then they could hijack execution. Fortunately, on a default installation of Windows, a normal user can’t write files to the root of the system drive; however, configuration changes sometimes allow this. Also, the executable path might be on a different drive that does allow writing to the root.</p>
<p class="TX">To avoid both security implications, the caller can specify the executable’s full pathname by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationName</samp> property when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>:</p>
<pre><code>PS&gt; <b>$proc = New-Win32Process -CommandLine "notepad test.txt"</b>
<b>-ApplicationName "C:\windows\notepad.exe"</b>
</code></pre>
<p class="TX">If we specify the path this way, the command will pass it verbatim to the new process.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H2" id="sec18"><span id="h2-31"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shell APIs</samp></h4>
<p class="TNI1">If you double-click a non-executable file type, such as a text document, in Explorer, it will helpfully start an editor for you. However, if you try to run a document with <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>, you’ll get the error shown here:</p>
<pre><code>PS&gt; <b>New-Win32Process -CommandLine "document.txt"</b>
Exception calling "CreateProcess": "%1 is not a valid Win32 application"
</code></pre>
<p class="BodyContinued">This error indicates that the text file is not a valid Win32 application.</p>
<p class="TX">The reason Explorer can start the editor is that it doesn’t use the underlying <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API directly; instead, it uses a shell API. The main shell API used to start the editor for a file is <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecuteEx</samp>, implemented in the <i>SHELL32</i> library. This API and its simpler sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>, are much too complex to cover in detail here. Instead, I’ll give just a brief overview of the latter.</p>
<p class="TX"><span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"></span>For our purposes, we need to specify three parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>:</p>
<ul class="ul">
<li class="ListBullet">The path to the file to execute</li>
<li class="ListBullet">The verb to use on the file</li>
<li class="ListBullet">Any additional arguments</li>
</ul>
<p class="TX">The first thing <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> does is look up the handler for the extension of the file to execute. For example, if the file is <i>test.txt</i>, then it needs to look up the handler for the <i>.txt</i> extension. The handlers are registered in the registry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CLASSES_ROOT</samp> key, which, as we saw earlier in the chapter, is a merged view of parts of the machine software and the user’s registry hive. In <a href="chapter3.xhtml#Lis3-23">Listing 3-23</a>, we query the handler.</p>
<span id="Lis3-23"></span><pre><code>PS&gt; <b>$base_key = "NtKey:\MACHINE\SOFTWARE\Classes"</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Get-Item "$base_key\.txt" | Select-Object -ExpandProperty Values</b>
Name          Type   DataObject
----          ----   ----------
Content Type  String text/plain
PerceivedType String text
            <span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> String txtfile

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-ChildItem "$base_key\txtfile\Shell" | Format-Table</b>
Name    TypeName
----    --------
open    Key
print   Key
printto Key

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-Item "$base_key\txtfile\Shell\open\Command" |</b>
<b>Select-Object -ExpandProperty Values | Format-Table</b>
Name Type         DataObject
---- ----         ----------
   <span aria-label="annotation5" class="CodeAnnotationCode2">❺</span> ExpandString %SystemRoot%\system32\NOTEPAD.EXE %1
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-23: Querying the shell handler for</span> <samp class="SANS_Futura_Std_Book_11">.txt</samp> <span class="Futura_Std_Book_Oblique_I_11">files</span></p>
<p class="TX">We start by querying the machine class’s key for the <i>.txt</i> extension <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Although we could have checked for a user-specific key, checking the machine class’s key ensures that we inspect the system default. The <i>.txt</i> registry key doesn’t directly contain the handler. Instead, the default value, represented by an empty name, refers to another key: in this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We then list the subkeys of <samp class="SANS_TheSansMonoCd_W5Regular_11">txtfile</samp> and find three keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We can pass these verbs by name to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.</p>
<p class="TX">Each of these verb keys can have a subkey, called <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>, that contains a command line to execute <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We can see that the default for a <i>.txt</i> file is to open Notepad <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>; the <samp class="SANS_TheSansMonoCd_W5Regular_11">%1</samp> is replaced with the path to the file being executed. (The command could also contain <samp class="SANS_TheSansMonoCd_W5Regular_11">%*</samp>, which includes any additional arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API can now start the executable and handle the file.</p>
<p class="TX">There are many different standard verbs you can pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>. <a href="chapter3.xhtml#tab3-3">Table 3-3</a> shows a list of common ones you’ll encounter.</p>
<p class="Anchor"><span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab3-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Shell Verbs</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Verb</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Open the file; this is typically the default.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Edit the file.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Print the file.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">printto</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Print to a specified printer.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">explore</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Explore a directory; this is used to open a directory in an Explorer window.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Open the file as an administrator; typically, defined for executables only.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">runasuser</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Open the file as another user; typically, defined for executables only.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">You might find it odd that there is both an <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> verb. If you opened a <i>.txt</i> file, for example, the file would open in Notepad, and you’d be able to edit it. But the distinction is useful for files such as batch files, where the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb would execute the file and <samp class="SANS_TheSansMonoCd_W5Regular_11">edit</samp> would open it in a text editor.</p>
<p class="TX">To use <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> from PowerShell, you can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp> command. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb, but you can specify your own verb using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Verb</samp> parameter. In the following code, we print a <i>.txt</i> file as an administrator using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print</samp> verb:</p>
<pre><code>PS&gt; <b>Start-Process "test.txt" -Verb "print"</b>
</code></pre>
<p class="TX">Verb configurations can also improve security. For example, PowerShell scripts with a <i>.ps1</i> extension have the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> verb registered. However, clicking a script will open the script file in Notepad rather than executing the script. Therefore, if you double-click the script file in Explorer, it won’t execute. Instead, you must right-click the file and explicitly choose <b>Run with PowerShell</b>.</p>
<p class="TX">As mentioned previously, the full details of the shell APIs are out of scope for this book; as you might expect, the full picture is not quite as simple as I’ve shown here.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="h1-27"></span><samp class="SANS_Futura_Std_Bold_B_11">System Processes</samp></h3>
<p class="TNI1">Throughout this and the preceding chapter, I’ve alluded to various processes that run with higher privileges than a normal user. This is because, even when no user is logged in to the operating system, the system still needs to perform tasks like waiting for authentication, managing hardware, and communicating over the network.</p>
<p class="TX">The kernel could perform some of these tasks. However, writing kernel code is more difficult than user-mode code, for a number of reasons: the kernel doesn’t have as wide a range of APIs available; it’s resource constrained, especially in terms of memory; and any coding mistake could result in the system crashing or being exposed to a security vulnerability.</p>
<p class="TX"><span aria-label=" Page 92. " epub:type="pagebreak" id="pg_92" role="doc-pagebreak"></span>To avoid these challenges, Windows runs a variety of processes outside of kernel mode, with a high privilege level, to provide important facilities. We’ll go through some of these special processes in this section.</p>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-32"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Session Manager</samp></h4>
<p class="TNI1">The <i>Session Manager Subsystem (SMSS)</i> is the first user-mode process started by the kernel after boot. It’s responsible for setting up the working environment for subsequent processes. Some of its responsibilities include:</p>
<ul class="ul">
<li class="ListBullet">Loading known DLLs and creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects</li>
<li class="ListBullet">Starting subsystem processes such as CSRSS</li>
<li class="ListBullet">Initializing base DOS devices such as serial ports</li>
<li class="ListBullet">Running automatic disk integrity checks</li>
</ul>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-33"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Windows Logon Process</samp></h4>
<p class="TNI1">The <i>Windows logon</i> process is responsible for setting up a new console session, as well as displaying the logon user interface (primarily through the LogonUI application). It’s also responsible for starting the <i>user-mode font driver (UMFD)</i> process, which renders fonts to the screen, and the <i>desktop window manager (DWM)</i> process, which performs desktop compositing operations to allow for fancy, transparent windows and modern GUI touches.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-34"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Local Security Authority Subsystem</samp></h4>
<p class="TNI1">I’ve already mentioned LSASS in the context of the SRM. However, it’s worth stressing its important role in authentication. Without LSASS, a user would not be able to log on to the system. We’ll cover LSASS’s roles and responsibilities in much more detail in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-35"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Service Control Manager</samp></h4>
<p class="TNI1">The <i>service control manager (SCM)</i> is responsible for starting most privileged system processes on Windows. It manages these processes, referred to as <i>services</i>, and can start and stop them as needed. For example, the SCM could start a service based on certain conditions, such as a network becoming available.</p>
<p class="TX">Each service is a securable resource with fine-grained controls determining which users can manipulate its state. By default, only an administrator can manipulate a service. The following are some of the most important services running on any Windows system:</p>
<p class="RunInPara1"><b>Remote Procedure Call Subsystem (RPCSS)    </b>The RPCSS service manages the registration of remote procedure call endpoints, exposing the registration to local clients as well as over the network. This service is essential to a running system; in fact, if this process crashes, it will force Windows to reboot.</p>
<p class="RunInPara"><span aria-label=" Page 93. " epub:type="pagebreak" id="pg_93" role="doc-pagebreak"></span><b>DCOM Server Process Launcher    </b>The DCOM Server Process Launcher is a counterpart to RPCSS (and used to be part of the same service). It’s used to start Component Object Model (COM) server processes on behalf of local or remote clients.</p>
<p class="RunInPara"><b>Task Scheduler    </b>Being able to schedule an action to run at a specific time and date is a useful feature of an operating system. For example, perhaps you want to ensure that you delete unused files on a specific schedule. You could set up an action with the Task Scheduler service to run a cleanup tool on that schedule.</p>
<p class="RunInPara"><b>Windows Installer    </b>This service can be used to install new programs and features. By running as a privileged service, it permits installation and modification in normally protected locations on the filesystem.</p>
<p class="RunInPara"><b>Windows Update    </b>Having a fully up-to-date operating system is crucial to the security of your Windows system. When Microsoft releases new security fixes, they should be installed as soon as possible. To avoid requiring the user to check for updates, this service runs in the background, waking up periodically to check the internet for new patches.</p>
<p class="RunInPara2"><b>Application Information    </b>This service provides a mechanism for switching between an administrator and non-administrator user on the same desktop. This feature is usually referred to as <i>User Account Control (UAC)</i>. You can start an administrator process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> verb with the shell APIs. We’ll cover how UAC works under the hood in the next chapter.</p>
<p class="TX">We can query the status of all services controlled by the SCM using various tools. PowerShell has the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Service</samp> command; however, the PowerShell module used in this book provides a more comprehensive command, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Service</samp>, that can inspect the configured security of a service as well as additional properties not exposed using the default command. <a href="chapter3.xhtml#Lis3-24">Listing 3-24</a> shows how to query for all current services.</p>
<span id="Lis3-24"></span><pre><code>PS&gt; <b>Get-Win32Service</b>
Name               Status   ProcessId
----               ------   ---------
AarSvc             Stopped  0
AESMService        Running  7440
AJRouter           Stopped  0
ALG                Stopped  0
AppIDSvc           Stopped  0
Appinfo            Running  8460
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-24: Displaying all services using Get-Win32Service</span></p>
<p class="TX">The output shows the name of the service, its status (either <samp class="SANS_TheSansMonoCd_W5Regular_11">Stopped</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Running</samp>), and, if it’s running, the process ID of the service process. If you list the service’s properties using <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>, you’ll also be able to see additional information, such as a full description of the service.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h3 class="H1" id="sec24"><span id="h1-28"></span><span aria-label=" Page 94. " epub:type="pagebreak" id="pg_94" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some worked examples to practice using the various commands covered in this chapter for security research or systems analysis.</p>
<section aria-labelledby="sec25" epub:type="division">
<h4 class="H2" id="sec25"><span id="h2-36"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Executables That Import Specific APIs</samp></h4>
<p class="TNI1">At the beginning of this chapter, you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp> command to extract an executable file’s imported APIs. One use for this command that I find especially helpful when I’m trying to track down security issues is identifying all the executables that use a particular API, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>, and then using this list to reduce the files I need to reverse engineer. You can perform such a search with the basic PowerShell script shown in <a href="chapter3.xhtml#Lis3-25">Listing 3-25</a>.</p>
<span id="Lis3-25"></span><pre><code>PS&gt; <b>$imps = ls "$env:WinDir\*.exe" | ForEach-Object {</b>
<b>    Get-Win32ModuleImport -Path $_.FullName</b>
<b>}</b>
PS&gt; <b>$imps | Where-Object Names -Contains "CreateProcessW" |</b>
<b>Select-Object ModulePath</b>
ModulePath
----------
C:\WINDOWS\explorer.exe
C:\WINDOWS\unins000.exe
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-25: Finding executables that import CreateProcess</span></p>
<p class="TX">Here, we start by enumerating all the <i>.exe</i> files in the <i>Windows</i> directory. For every executable file, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32ModuleImport</samp> command. This will load the module and parse its imports. This can be a time-consuming process, so it’s best to capture the results into a variable, as we do here.</p>
<p class="TX">Next, we select only the imports that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessW</samp> API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp> property is a list containing the imported names for a single DLL. To get the resulting list of executable files that import a specific API, we can select the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModulePath</samp> property, which contains the original loaded pathname.</p>
<p class="TX">You can use the same technique to enumerate DLL files or drivers and quickly discover targets for reverse engineering.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="H2" id="sec26"><span id="h2-37"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Hidden Registry Keys or Values</samp></h4>
<p class="TNI1">In <span class="Xref">“Listing the Registry’s Contents” on page 81</span>, I mentioned that one of the big advantages of using the native system calls over the Win32 APIs to interact with the registry is that they allow you to access keys and values with NUL characters in their names. It would be useful to be able to find these keys and values so you can try to detect software on your system that is actively trying to hide registry keys or values from the user (some malware families, such as Kovter and Poweliks, are known to use this technique). Let’s start by finding keys with NUL characters in the name (<a href="chapter3.xhtml#Lis3-26">Listing 3-26</a>).</p>
<span id="Lis3-26"></span><pre><code><span aria-label=" Page 95. " epub:type="pagebreak" id="pg_95" role="doc-pagebreak"></span>PS&gt; <b>$key = New-NtKey -Win32Path "HKCU\SOFTWARE\`0HIDDENKEY"</b>
PS&gt; <b>ls NtKeyUser:\SOFTWARE -Recurse | Where-Object Name -Match "`0"</b>
Name                TypeName
----                --------
SOFTWARE\ HIDDENKEY Key

PS&gt; <b>Remove-NtKey $key</b>
PS&gt; <b>$key.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-26: Finding hidden registry keys</span></p>
<p class="TX">We first create a key in the current user’s hive with a NUL character in it. If you try to find this key using the built-in registry provider, it will fail. Instead, we do a recursive listing of the current user’s hive and select any keys that have a NUL character in the name. In the output, you can see that the hidden key was discovered.</p>
<p class="TX">To find hidden values, we can query the list of values of a key by enumerating its <samp class="SANS_TheSansMonoCd_W5Regular_11">Values</samp> property. Each value contains the name of the key and the data value (<a href="chapter3.xhtml#Lis3-27">Listing 3-27</a>).</p>
<span id="Lis3-27"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$key = New-NtKey -Win32Path "HKCU\SOFTWARE\ABC"</b>
PS&gt; <b>Set-NtKeyValue -Key $key -Name "`0HIDDEN" -String "HELLO"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span><b> </b>PS&gt; <b>function Select-HiddenValue {</b>
<b>    [CmdletBinding()]</b>
<b>    param(</b>
        <b>[parameter(ValueFromPipeline)]</b>
<b>        $Key</b>
<b>    )</b>

<b>    Process {</b>
<b>      </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span><b> foreach($val in $Key.Values) {</b>
<b>            if ($val.Name -match "`0") {</b>
<b>                [PSCustomObject]@{</b>
<b>                    RelativePath = $Key.RelativePath</b>
<b>                    Name = $val.Name</b>
<b>                    Value = $val.DataObject</b>
<b>                }</b>
<b>            }</b>
<b>        }</b>
<b>    }</b>
<b>}</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>ls -Recurse NtKeyUser:\SOFTWARE | Select-HiddenValue | Format-Table</b>
RelativePath Name    Value
------------ ----    -----
SOFTWARE\ABC HIDDEN  HELLO

PS&gt; <b>Remove-NtKey $key</b>
PS&gt; <b>$key.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 3-27: Finding hidden registry values</span></p>
<p class="TX">We start by creating a normal key, then adding a value with a NUL character in the name <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then define a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, <span aria-label=" Page 96. " epub:type="pagebreak" id="pg_96" role="doc-pagebreak"></span>that will check keys in the pipeline and select any value with a NUL character in the name, returning a custom object to the pipeline <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Next, we recursively enumerate the current user’s hive and filter the keys through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select-HiddenValue</samp> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. You can see in the output that we discovered the hidden value.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="H1" id="sec27"><span id="h1-29"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter provided a quick tour through the Windows user-mode components. We started with a dive into Win32 APIs and the loading of DLLs. Understanding this topic is important, as it reveals how user-mode applications communicate with the kernel and implement common features.</p>
<p class="TX">Next, I provided an overview of the Win32 GUI, including a description of the separate system call table used for <i>WIN32K</i>, which is the kernel-mode component of the Win32 subsystem. I introduced the window station and desktop object types and outlined the purpose of the console session, as well as how it corresponds to the desktop you see as a user.</p>
<p class="TX">I then returned to the topic of Win32 APIs by detailing the differences and similarities between a Win32 API (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutexEx</samp>) and the underlying system call (<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>). This discussion should have given you a better understanding of how the Win32 APIs interact with the rest of the operating system. I also introduced the differences between DOS device paths and native paths as understood by a system call, a topic that is important for understanding how user-mode applications interact with the filesystem.</p>
<p class="TX">I concluded with a discussion of several topics related to Win32 processes and threads, covering the APIs used to create processes directly or through the shell and providing an overview of well-known system processes. In later chapters, we’ll revisit many of these topics in more depth. In the next three chapters, we’ll focus on how Windows implements security through the SRM.</p>
</section>
</section>
</div></body>
</html>