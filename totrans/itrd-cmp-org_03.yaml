- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COMPUTER ARITHMETIC**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reality of computing is that we have a finite number of bits. In the previous
    chapter, you learned that each data item must fit within a fixed number of bits,
    depending on its data type. This chapter will show you that this limit complicates
    even our most basic mathematical operations. For both signed and unsigned numbers,
    a limited number of bits is a constraint we don’t normally think about when doing
    math on paper or in our heads.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU includes memory for a set of single-bit *condition flags*. Among them
    are a *carry flag (*C*)* and an *overflow flag (*V*)* that enable us to detect
    when adding or subtracting binary numbers yields results that exceed the allocated
    number of bits for the data type. We’ll dig deeper into the carry flag and the
    overflow flag in subsequent chapters, but for now, let’s take a look at how addition
    and subtraction affect them.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Unsigned Integers in the Decimal Number System**'
  prefs: []
  type: TYPE_NORMAL
- en: When computers do arithmetic, they do it in the binary number system. The operations
    may seem difficult at first, but if you remember the details of performing decimal
    arithmetic by hand, binary arithmetic becomes much easier. Although most people
    do addition on a calculator these days, reviewing all the steps required to do
    it by hand will help us develop the algorithms to do addition and subtraction
    in binary and hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Most computer architectures provide arithmetic instructions in other number
    systems, but those are somewhat specialized. We will not consider them in this
    book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Addition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s restrict ourselves to two-digit decimal numbers. Consider two of these,
    *x* = 67 and *y* = 79\. Adding these by hand on paper would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg66_Image_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by working from the right, adding the two decimal digits in the ones
    place: 7 + 9 = 16, which exceeds 10 by 6\. We show this by placing a 6 in the
    sum’s ones place and carrying a 1 to the tens place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg66_Image_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we add the three decimal digits in the tens place: 1 (the carry from
    the ones place) + 6 + 7\. The sum of these three digits exceeds 10 by 4, which
    we show by placing a 4 in the tens place and then recording the fact that there
    is an ultimate carry of 1\. Because we’re using only two digits, there is no hundreds
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following algorithm shows the procedure for adding two decimal integers,
    *x* and *y*. In this algorithm, *x[i]* and *y[i]* are the *i*th digits of *x*
    and *y*, respectively, numbered from right to left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm works because we use positional notation when writing numbers;
    a digit one place to the left counts 10 times more. The carry from the current
    position one place to the left is always 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use 10 in the `/` and `%` operations because there are exactly 10 digits
    in the decimal number system: 0, 1, 2, . . . , 9\. Since we are working in an
    *N*-digit system, we restrict our result to *N* digits. The ultimate carry, *Carry[N]*,
    is either 0 or 1 and is part of the result, along with the *N*-digit sum.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Subtraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For subtraction, you sometimes have to borrow from the next higher-order digit
    in the *minuend* (the number being subtracted from). We’ll do the subtraction
    with the same numbers we used earlier (67 and 79) and go through this in steps
    so you can understand the process. “Scratch” work will be in the borrowing row
    above the two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg67_Image_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we need to borrow 1 from the 6 in the tens place and add it to the 7
    in the ones place. Then, we can subtract 9 from 17 and get 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg67_Image_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to borrow from beyond the two digits, which we mark by placing
    a 1 in the “carry” position. That gives us 15 in the tens place, from which we
    subtract 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg67_Image_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is shown in the following algorithm, where *x* is the minuend and *y*
    is the number being subtracted from it (the *subtrahend*). If *Borrow* is 1 at
    the end of this algorithm, it shows that you had to borrow from beyond the *N*
    digits of the two values, so the *N*-digit result is incorrect. Although it’s
    called the *carry flag*, its purpose is to show when the operation gives a result
    that will not fit within the number of bits for the data type. Thus, the carry
    flag shows the value of *Borrow* (from beyond the size of the data type) at the
    completion of the subtraction operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm isn’t nearly as complicated as it first looks (but it took me
    a long time to figure it out!). If the digit we’re subtracting from is the same
    as or larger than the one we’re subtracting ❶, we’re done with that place in the
    number. Otherwise, we need to borrow from the next place to the left ❷. If the
    next digit we’retrying to borrow from is 0, then we need to continue moving to
    the left until we find a nonzero digit or until we reach the leftmost end of the
    number ❸. If we reach the number of digits allocated for the number ❹, we indicate
    that by setting *Borrow* to 1 ❺.
  prefs: []
  type: TYPE_NORMAL
- en: After we have borrowed from positions to the left, we work our way back to the
    position we’re dealing with ❻ and perform the subtraction ❼. When you do subtraction
    on paper, you do all these things automatically, in your head, but that probably
    won’t be as intuitive for you in the binary and hexadecimal systems. (I cheat
    and write my intermediate borrows in decimal.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble, don’t worry. You don’t need a thorough understanding
    of this algorithm to understand the material in this book, but I think working
    through it can help you learn how to develop algorithms for other computing problems.
    Translating everyday procedures into the logical statements used by programming
    languages is often a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsigned Integers in the Binary System**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to perform addition and subtraction operations
    on unsigned binary integers. Before going any further, take a good look at [Table
    3-1](ch03.xhtml#ch3tab1) (especially the binary bit patterns). You probably won’t
    memorize this table right away, but after you have worked with the binary and
    hexadecimal number systems for a while, it will become natural to think of, say,
    10, `a`, or `1010` as being the same numbers, just in different number systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Corresponding Bit Patterns and Unsigned Decimal Values for the
    Hexadecimal Digits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** | **Unsigned decimal**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0000` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0001` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `0010` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `0011` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `0100` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `0101` | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `0110` | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `7` | `0111` | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| `8` | `1000` | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `9` | `1001` | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | `1010` | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | `1011` | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | `1100` | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | `1101` | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | `1110` | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | `1111` | 15 |'
  prefs: []
  type: TYPE_TB
- en: Now that you’ve become familiar with [Table 3-1](ch03.xhtml#ch3tab1), let’s
    discuss unsigned integers. As we do so, don’t forget that as far as the value
    of the number goes, it doesn’t matter whether we think of an integer as being
    in decimal, hexadecimal, or binary—they are all mathematically equivalent. However,
    we might wonder whether a computer performing arithmetic in binary gets the same
    results we do when doing the same calculation using decimal arithmetic. Let’s
    take a closer look at some specific operations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Addition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following examples, we use 4-bit values. First, consider adding the
    two unsigned integers 2 and 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg69_Image_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The decimal value 2 is represented in binary as `0010`, and decimal 4 is represented
    by `0100`. The carry flag, or `C`, is equal to `0`, because the result of the
    addition operation is also 4 bits long. We add the digits (shown in both binary
    and hex here, though the carries are shown only in binary) in the same relative
    positions as we do in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider two larger integers. Keeping our 4-bit storage space, we’ll
    add the two unsigned integers 4 and 14:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg70_Image_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the carry flag equals `1`, because the result of the operation
    exceeded the 4 bits that we allocated for storing the integers. Thus, our result
    is incorrect. If we included the carry flag in the result, we would get a 5-bit
    value and the result would be `10010`[2] = 18[10], which is correct. In this case,
    we’d have to account for the carry flag in software.
  prefs: []
  type: TYPE_NORMAL
- en: '***Subtraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s subtract 14 from 4, or `1110` from `0100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg70_Image_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CPU can indicate that we had to borrow from beyond the 4 bits by setting
    the carry flag to `1`, which means the 4-bit result in this subtraction is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: These 4-bit arithmetic examples generalize to any size arithmetic performed
    by the computer. The AArch64 architecture has an addition instruction that sets
    the carry flag to `0` if there is no ultimate (or final) carry and sets it to
    `1` if there is an ultimate carry as a result of the addition. Similarly, there
    is a subtraction instruction that sets the carry flag to `0` if no borrow from
    the “outside” is required or to `1` if a borrow is required as a result of the
    subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Our C compiler does not use these addition and subtraction instructions. There
    is no indication of carry or borrow when performing an addition or subtraction
    operation. We’ll look at this more closely in [Chapter 15](ch15.xhtml), when we
    discuss embedding assembly language in C code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1     How many bits are required to store a single decimal digit? Invent a
    code for storing eight decimal digits in 32 bits. Using this code, does binary
    addition produce the correct results? You saw such a code in [Chapter 2](ch02.xhtml),
    with some reasons for its usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2     Develop an algorithm for adding fixed-width integers in the binary number
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3     Develop an algorithm for adding fixed-width integers in the hexadecimal
    number system.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4     Develop an algorithm for subtracting fixed-width integers in the binary
    number system.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5     Develop an algorithm for subtracting fixed-width integers in the hexadecimal
    number system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding and Subtracting Signed Integers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When representing nonzero signed decimal integers, there are two possibilities:
    they can be positive or negative. With only two options, we need to use only 1
    bit for the sign. We could use a *sign-magnitude code* by simply using the highest-order
    bit for signed numbers—say, where `0` means + and `1` means –. But if we do this,
    we’ll run into some problems. As an example, consider adding +2 and –2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg71_Image_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result, `1100`[2], is equal to –4[10] in our code, which is arithmetically
    incorrect. The simple addition we used for unsigned numbers will not work correctly
    for signed numbers when using a sign-magnitude code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some computer architectures do use 1 bit for the sign when using signed decimal
    integers. They have a special *signed add* instruction that handles cases like
    this. (A fun aside: such computers have both a +0 and a –0!) But most computers
    employ a different encoding to represent signed numbers that allows the use of
    a simple add instruction for signed addition. Let’s look at this now.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Two’s Complement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In mathematics, the *complement* of a quantity is the amount that must be added
    to make it “whole.” When applying this concept to numbers, the definition of *whole*
    depends on the radix (or base) you’re working in and the number of digits you
    allow to represent the numbers. If *x* is an *n*-digit number in radix *r*, its
    *radix complement*, ¬*x*, is defined such that *x* + (¬*x*) = *radix^n*, where
    *radix^n* is 1 followed by *n* 0s. For example, if we’re working with two-digit
    decimal numbers, then the radix complement of 37 is 63, because 37 + 63 = 10²
    = 100\. Another way of saying this is that adding a number to its radix complement
    results in 0, with a carry beyond the *n* digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful concept is the *diminished radix complement*, which is defined
    such that *x* + *diminished_radix_complement* = *radix^n* – 1\. For example, the
    diminished radix complement of 37 is 62, because 37 + 62 = 10² – 1 = 99\. If you
    add a number to its diminished radix complement, the result is *n* of the largest
    digits in the radix: two 9s in this example of two digits in radix 10.'
  prefs: []
  type: TYPE_NORMAL
- en: To see how the radix complement can be used to represent negative numbers, consider
    an audiotape cassette player, which plays a cassette tape containing magnetic
    tape wound back and forth between two spools.
  prefs: []
  type: TYPE_NORMAL
- en: The audio recording on the tape is an analog signal that does not include information
    about the position along the tape. Many audiotape cassette players have a four-digit
    counter that represents the tape position. You can insert a tape cassette and
    push a reset button to set the counter to 0000\. As you move the tape forward
    and backward, the counter registers the movement. These counters provide a “coded”
    representation of the relative tape position in arbitrary units. Now, assume we
    can insert a cassette, somehow move it to its center, and push the reset button.
    Moving the tape forward—in the positive direction—will cause the counter to increment.
    Moving the tape backward—in the negative direction—will cause the counter to decrement.
    In particular, if we start at 0000 and move to +1, the “code” on the tape counter
    will show 0001\. On the other hand, if we start at 0000 and move to –1, the “code”
    on the tape counter will show 9999.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our tape system to perform the arithmetic in the previous example,
    (+2) + (–2):'
  prefs: []
  type: TYPE_NORMAL
- en: Move the tape forward to (+2); the counter shows 0002.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add (–2) by moving the tape backward two steps on the counter; the counter now
    shows 0000, which is 0 according to our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’ll perform the same arithmetic starting with (–2) and then adding
    (+2):'
  prefs: []
  type: TYPE_NORMAL
- en: Move the tape backward to (–2); the counter shows 9998.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add (+2) by moving the tape forward two steps on the counter; the counter now
    shows 0000, but there is a carry (9998 + 2 = 0000 with carry = 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we ignore the carry, the answer is correct: 9998 is the 10’s complement
    (the radix is 10) of 0002\. When adding two signed integers using radix complement
    notation, the carry is irrelevant. Adding two signed numbers can give a result
    that will not fit within the number of bits allocated for storing the result,
    just as with unsigned numbers. But our tape example just illustrated that the
    carry flag will probably not show us that the result will not fit. We will discuss
    this issue in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Computers work in the binary number system, where the radix is 2\. Let’s look
    at the *two’s complement* notation for representing signed integers. It uses the
    same general pattern as the tape counter for representing signed decimal integers
    in bit patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-2](ch03.xhtml#ch3tab2) shows the correspondence between hexadecimal,
    binary, and signed decimal (in two’s complement notation) for 4-bit values. In
    binary, moving the “tape” one place back (negative) from 0 would go from `0000`
    to `1111`. In hexadecimal, it would go from `0` to `f`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Four-Bit Two’s Complement Notation'
  prefs: []
  type: TYPE_NORMAL
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** | **Signed decimal**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `8` | `1000` | –8 |'
  prefs: []
  type: TYPE_TB
- en: '| `9` | `1001` | –7 |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | `1010` | –6 |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | `1011` | –5 |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | `1100` | –4 |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | `1101` | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | `1110` | –2 |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | `1111` | –1 |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0000` |   0 |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0001` | +1 |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `0010` | +2 |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `0011` | +3 |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `0100` | +4 |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `0101` | +5 |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `0110` | +6 |'
  prefs: []
  type: TYPE_TB
- en: '| `7` | `0111` | +7 |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some important observations about this table:'
  prefs: []
  type: TYPE_NORMAL
- en: The high-order bit of each positive number is `0`, and the high-order bit of
    each negative number is `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although changing the sign of (*negating*) a number is more complicated than
    simply changing the high-order bit, it is common to call the high-order bit the
    *sign bit*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notation allows for one more negative number than positive numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of integers, *x*, that can be represented in this notation (with 4
    bits) is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last observation can be generalized for *n* bits to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using two’s complement notation, the negative of any *n*-bit integer *x*
    is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg73_Image_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that 2*^n* written in binary is `1` followed by *n* `0`s. In other words,
    in the *n*-bit two’s complement notation, adding a number to its negative produces
    *n* `0`s and a carry of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Computing Two’s Complement***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll derive a way to compute the negative of a number by using two’s complement
    notation. Solving the defining equation for –*x*, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This may look odd to a mathematician, but keep in mind that *x* in this equation
    is restricted to *n* bits, while 2*^n* has *n* + 1 bits (`1` followed by *n* `0`s).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to compute –123 in binary (using two’s complement notation)
    in 8 bits, we perform the arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This subtraction operation is error-prone, so let’s do a bit of algebra on
    our equation for computing –*x*. We’ll subtract 1 from both sides and rearrange
    a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If this looks more complicated than our first equation, don’t worry. Let’s
    consider the quantity (2*^n* – 1). Since 2*^n* is written in binary as `1` followed
    by *n* `0`s, (2*^n* – 1) is written as *n* `1`s. For example, for *n* = 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we can say
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where 11 *. . .* 1[2] designates *n* `1`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it may not be immediately obvious, you’ll see how easy this subtraction
    is when you consider the previous example of computing –123 in 8-bit binary. Let
    *x* = 123, giving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or, in hexadecimal, giving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg74_Image_38.jpg) Since all the quantities here have *n*
    bits, this computation is easy—simply flip all the bits, giving the diminished
    radix complement, also called the *one’s complement* in the binary number system.
    A `1` becomes a `0` and a `0` becomes a `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains to compute the negative is to add `1` to the result. Finally,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg75_Image_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To double-check your arithmetic, pay attention to whether the value you are
    converting is even or odd. It will be the same in all number bases.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 3.6     Develop an algorithm to convert signed decimal integers to two’s complement
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7     Develop an algorithm to convert integers in two’s complement binary
    notation to signed decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8     The following 16-bit hexadecimal values are stored in two’s complement
    notation. What are the equivalent signed decimal numbers?
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `1234`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `ffff`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `8000`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `7fff`
  prefs: []
  type: TYPE_NORMAL
- en: '3.9     Show how each of the following signed decimal integers would be stored
    in 16-bit two’s complement notation. Give your answers in hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     +1,024
  prefs: []
  type: TYPE_NORMAL
- en: (b)     –1,024
  prefs: []
  type: TYPE_NORMAL
- en: (c)     –256
  prefs: []
  type: TYPE_NORMAL
- en: (d)     –32,767
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding and Subtracting Signed Integers in Binary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number of bits used to represent a value is determined at the time a program
    is written by the computer architecture and programming language used. This is
    why you can’t just add more digits (bits) if the result is too large, as you would
    on paper. For unsigned integers, the solution to this problem is the carry flag,
    which indicates when the sum of two unsigned integers exceeds the number of bits
    allocated for it. In this section, you’ll learn that adding two signed numbers
    can also produce a result that exceeds the allocated number of bits, but in this
    case, the carry flag alone does not indicate the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU can indicate when the sum of signed numbers has gotten too big for
    its bits by using the *overflow flag*, `V`. The value of the overflow flag is
    given by an operation that may not seem intuitive at first: the *exclusive or
    (XOR)* of the penultimate and ultimate carries. As an example, let’s say we’re
    adding the two 8-bit numbers `15`[16] and `6f`[16]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg76_Image_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the carry is `0` and the penultimate carry is `1`. The `V`
    flag is equal to the XOR of the ultimate carry and penultimate carry, `V` = `C`
    ⊻ *(penultimate_carry)*, where ⊻ is the XOR operator. In this case, `V` = `0`
    ⊻ `1` = `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case by case, we’ll see why the `V` flag indicates the validity of adding two
    signed integers in the two’s complement representation. In the next three sections,
    we’ll discuss the three possible cases: the two numbers can have opposite signs,
    both be positive, or both be negative.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Two Numbers of the Opposite Sign***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let *x* be the negative number and *y* the positive number. We can express
    *x* and *y* in binary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0076-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That is, the high-order (sign) bit of one number is `1` and the high-order (sign)
    bit of the other is `0`, regardless of what the other bits are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of *x* + *y* always remains within the range of the two’s complement
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg76_Image_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we add *x* and *y*, there are two possible carry results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the penultimate carry is `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg76_Image_42.jpg) *   If the penultimate carry is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding two integers of opposite signs always yields `0` for the overflow flag,
    so the sum is always within the allocated range.
  prefs: []
  type: TYPE_NORMAL
- en: '***Two Positive Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If both *x* and *y* are positive, we can express them in binary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the high-order (sign) bit of both numbers is `0`, regardless of what the
    other bits are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, if we add *x* and *y*, there are two possible carry results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the penultimate carry is `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This addition produces `V = 0` ⊻ `0 = 0`. The high-order bit of the sum is `0`,
    so it’s a positive number, and the sum is in range.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the penultimate carry is `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This addition produces `V = 0` ⊻ `1 = 1`. The high-order bit of the sum is `1`,
    so it’s a negative number. Adding two positive numbers cannot give a negative
    sum, so the sum must have exceeded the allocated range.
  prefs: []
  type: TYPE_NORMAL
- en: '***Two Negative Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If both *x* and *y* are negative, we can express them in binary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg77_Image_47.jpg) In this case, the high-order (sign) bit
    of both numbers is `1`, regardless of what the other bits are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add *x* and *y*, there are two possible carry results:'
  prefs: []
  type: TYPE_NORMAL
- en: If the penultimate carry is `0`:![Image](../images/pg78_Image_48.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives `V = 1` ⊻ `0 = 1`. The high-order bit of the sum is `0`, so it’s
    a positive number. But adding two negative numbers cannot give a positive sum,
    so the sum has exceeded the allocated range.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the penultimate carry is `1`:![Image](../images/pg78_Image_49.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives `V = 1` ⊻ `1 = 0`. The high-order bit of the sum is `1`, so it’s
    a negative number and the sum is within range.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We won’t go into subtraction here. The same rules apply there, and I invite
    you to explore them on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can state the following rules for adding or subtracting two *n*-bit numbers,
    based on what you just learned and what we did in “Unsigned Integers in the Binary
    System” on [page 40](ch03.xhtml#ch03lev1sec2):'
  prefs: []
  type: TYPE_NORMAL
- en: When the program treats the result as unsigned, the carry flag, `C`, is `0`
    if and only if the result is within the *n*-bit range; `V` is irrelevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the program treats the result as signed, the overflow flag, `V`, is `0`
    if and only if the result is within the *n*-bit range; `C` is irrelevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using two’s complement notation means the CPU does not need additional instructions
    for signed addition and subtraction, thus simplifying the hardware. The CPU just
    sees bit patterns. The AArch64 architecture includes add and subtract instructions
    that set* C *and* V *according to the rules of the respective binary arithmetic
    operation, regardless of how the program treats the numbers. The distinction between
    signed and unsigned is completely determined by the program. After each addition
    or subtraction operation, the program should check the state of* C *for unsigned
    integers or* V *for signed integers and at least indicate when the sum is in error.
    Many high-level languages do not perform this check, which can lead to some obscure
    program bugs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '### **The Circular Nature of Integer Codes**'
  prefs: []
  type: TYPE_NORMAL
- en: The notations used for both unsigned integers and signed integers are circular
    in nature—for a given number of bits, each code “wraps around.” [Figure 3-1](ch03.xhtml#ch3fig1)
    shows this using the “decoder ring” for 3-bit numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg79_Image_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A “decoder ring” for 3-bit signed and unsigned integers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this decoder ring to add or subtract two integers, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick the ring corresponding to the type of integer you’re using (signed or unsigned).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the location on that ring corresponding to the first integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move along that ring the number of “spokes” equal to the second integer. Move
    clockwise to add and counterclockwise to subtract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is correct if you do not cross the top for unsigned integers or cross
    the bottom for signed integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '3.10     Use the decoder ring in [Figure 3-1](ch03.xhtml#ch3fig1) to perform
    the following arithmetic. Indicate whether the result is “right” or “wrong”:'
  prefs: []
  type: TYPE_NORMAL
- en: '(a)     Unsigned integers: 1 + 3'
  prefs: []
  type: TYPE_NORMAL
- en: '(b)     Unsigned integers: 3 + 4'
  prefs: []
  type: TYPE_NORMAL
- en: '(c)     Unsigned integers: 5 + 6'
  prefs: []
  type: TYPE_NORMAL
- en: '(d)     Signed integers: (+1) + (+3)'
  prefs: []
  type: TYPE_NORMAL
- en: '(e)     Signed integers: (–3) – (+3)'
  prefs: []
  type: TYPE_NORMAL
- en: '(f)     Signed integers: (+3) + (–4)'
  prefs: []
  type: TYPE_NORMAL
- en: '3.11     Add the following pairs of 8-bit numbers (shown in hexadecimal) and
    indicate whether your result is “right” or “wrong.” First treat them as unsigned
    values and then as signed values (stored in two’s complement):'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `55 + aa`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `55 + f0`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `80 + 7b`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `63 + 7b`
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `0f + ff`
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `80 + 80`
  prefs: []
  type: TYPE_NORMAL
- en: '3.12     Add the following pairs of 16-bit numbers (shown in hexadecimal) and
    indicate whether your result is “right” or “wrong.” First treat them as unsigned
    values and then as signed values (stored in two’s complement):'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `1234 + edcc`
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `1234 + fedc`
  prefs: []
  type: TYPE_NORMAL
- en: (c)     `8000 + 8000`
  prefs: []
  type: TYPE_NORMAL
- en: (d)     `0400 + ffff`
  prefs: []
  type: TYPE_NORMAL
- en: (e)     `07d0 + 782f`
  prefs: []
  type: TYPE_NORMAL
- en: (f)     `8000 + ffff`
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Binary arithmetic**   Computers perform addition and subtraction in the binary
    number system. Addition of two numbers may yield a result that is 1 bit wider
    than each of the two numbers. Subtraction of one number from another may require
    borrowing from 1 bit beyond the width of the two numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Representing signed/unsigned**   Bit patterns can be treated as representing
    either signed or unsigned integers. Two’s complement notation is commonly used
    to represent signed integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Carry flag**   The CPU includes a 1-bit carry flag, `C`, that can show whether
    the result of addition or subtraction exceeds the number of bits allowed for an
    unsigned integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflow flag**   The CPU includes a 1-bit overflow flag, `V`, that can show
    whether the result of addition or subtraction exceeds the number of bits allowed
    for a signed integer using two’s complement notation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to perform Boolean algebra. Although it
    may seem a bit strange at first, once we get going, you’ll see that it’s actually
    easier than elementary algebra. For one thing, everything evaluates to either
    `0` or `1`!
  prefs: []
  type: TYPE_NORMAL
