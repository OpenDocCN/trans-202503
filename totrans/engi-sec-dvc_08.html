<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_101"/><strong><span class="big">6</span><br/>SECURE DEVICE IDENTITY</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">For a long time, embedded systems ran anonymously in the shadows and didn’t care about remote access, digital business models, or sharing their data with other devices and cloud services. However, these days, those scenarios have changed fundamentally.</p>
<p class="indent">Suddenly, maintenance staff are now logging into devices remotely and can’t verify that they’re working with the correct device by looking at physical indicators. In addition, pay-per-use business models have become more and more popular in industrial scenarios, and devices write their own bills. Being able to prove the origin of usage data and mapping it to a specific customer is essential in this case. Moreover, devices made by different manufacturers have started talking to one another and exchanging data. All these trends have a strong requirement in common: every device needs a unique identity, and every device must be able to prove it.</p>
<p class="indent">The first part of this chapter investigates which properties contribute to device uniqueness and can serve as a basis for identity as well as the closely linked processes of identification and authentication. Next, we’ll look at how the implementation of device identity management is regarded from two angles: the on-device storage of a cryptographic identity and the life-cycle management on the manufacturer’s side. The chapter concludes with two case studies that explore identity generation and provisioning.</p>
<h3 class="h3" id="ch00lev1_50"><span epub:type="pagebreak" id="page_102"/><strong>Every Device Is Unique</strong></h3>
<p class="noindent">Mass production of consumer goods and industrial components might convey the impression that all the products rolling off the line are identical, right up to every bit in their firmware. However, if that were the case, how would you be able to tell one device from another? Of course, products have had stickers with serial numbers on them for a long time, but what if a sticker falls off, is removed on purpose, or even replaced with a forged version?</p>
<p class="indent">For modern devices, a unique identity should be an integral part of the device itself, and the component should be able to actively prove its identity to third-party devices, repair shops, and cloud services of the original manufacturer, just to name a few examples.</p>
<p class="indent">From a theoretical point of view, every single device—even with identical PCBs, microprocessors, and RAM—is clearly unique, because all these units are subject to (if only small) individual differences in material, timely behavior, power consumption, and so on. Academia is already working on exploiting the uniqueness of these tiny physical features to establish device identities. The corresponding research area is focused on <em>physical unclonable functions (PUFs)</em>, which have recently even found their way into the first commercial products.</p>
<p class="indent">The following sections explore what might be available in current devices that makes them unique from a practical point of view and how these unique identities can be proven to other parties.</p>
<h3 class="h3" id="ch00lev1_51"><strong>Identification and Identifiers</strong></h3>
<p class="noindent">Clearly, the term <em>identification</em> is closely related to the word <em>identity</em>. However, take a minute to think about its exact meaning.</p>
<p class="indent">If we want to define the process of identification, we could say it’s the “claiming of a given identity.” For example, if you meet someone at a conference, you could say, “Hi, my name is Joe!” You claim that you are Joe. The same happens if your device collects some usage data—let’s say in the course of one month—and then connects to your backend to provide the data for customer billing. It will probably start with “Hi backend, my name is XY1337-0815!” It claims to be a device with a certain “name.”</p>
<h4 class="h4" id="ch00lev2_61"><strong><em>Unique Identifiers</em></strong></h4>
<p class="noindent">Regarding uniqueness, telling somebody you’re Joe is clearly not enough. Several Joes might exist, maybe even at the same conference. Adding your last name might narrow it down, but your name still won’t be unique, at least on a global scale. If you take place and date of birth into consideration, you’ll be closer to having a set of data that uniquely identifies <em>you</em>. These properties are called <em>identifiers</em>. Humans have many more of them: hair color, eye color, size, weight, and so on.</p>
<p class="indent">Since devices usually don’t have human-like names, manufacturers have to take another path for identification. For a long time, typical identifiers <span epub:type="pagebreak" id="page_103"/>have been vendor-chosen values like model type, serial number, and date of production.</p>
<p class="indent">With the advent of the internet, the need for worldwide identifiers became clear. Back then, the concept of UUIDs, also known as <em>globally unique identifiers (GUIDs)</em>, was proposed. It’s standardized in RFC 4122, among others, and is meant to provide 128-bit unique identifiers that don’t require a central registration process. Although the probability of identifier collision is not zero, it’s regarded as very close to zero in practice. The generation of UUIDs can, for example, be performed by the Linux RNG, as shown in <a href="ch03.xhtml#ch03">Chapter 3</a>.</p>
<p class="indent">From a cryptographic point of view, public keys generated by asymmetric crypto algorithms like RSA and ECDSA also can perfectly serve as identifiers. They might even be combined with a subject name and further attributes to obtain a unique device certificate for identification as, for example, standardized in the network authentication standard IEEE 802.1AR.</p>
<h4 class="h4" id="ch00lev2_62"><strong><em>System Identities</em></strong></h4>
<p class="noindent">While some devices consist of a single central component that constitutes the whole device and its identity, other product architectures are more modular and allow for partial replacements in case of defects or hardware upgrades. Discussing which components contribute to the device’s identity and which don’t is worthwhile for the latter cases. The physical parts of an embedded system provide a multitude of identifiers like media access control (MAC) addresses of network cards, Bluetooth chipsets, and Wi-Fi controllers, but also serial numbers and unique identifiers of CPUs, flash memories, and removable media.</p>
<p class="indent">Requiring a set of identifiers to be part of the system identity also means that the system identity has to be regenerated or reapproved if one of those parts changes. This requirement can be an advantage for manufacturers—for example, to force users to purchase spare parts of the same brand—because every exchange requires the acknowledgment of the manufacturer. However, system identities and forced manufacturer approval can also cause additional workload on the manufacturers’ side. Further, if every little change requires a feedback loop with the original manufacturer, it could significantly limit operators’ freedom to act in their daily business.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Sometimes a device’s reliability is the utmost goal, and if its hardware breaks, it has to be immediately replaced by an operator. In such cases, allowing a device’s identity to be transferable is reasonable—for example, with a removable memory card.</em></p>
</div>
<h3 class="h3" id="ch00lev1_52"><strong>Authentication and Authenticators</strong></h3>
<p class="noindent">In everyday language, <em>identification</em> and <em>authentication</em> are sometimes used synonymously, but authentication means much more than merely claiming an identity.</p>
<p class="indent">If the validity and correctness of your identity are really important—for example, if you have to apply for a passport or register to vote—and you tell <span epub:type="pagebreak" id="page_104"/>them “Hi, I’m Joe,” they’ll probably reply, “Hi, Joe, please show me your ID card.” They’ll make you <em>prove</em> your identity—the analog equivalent of a digital authentication process.</p>
<p class="indent">The term <em>authentication</em> means that you have to <em>confirm</em> the identity you claimed during identification some seconds before. To do so, you need to possess a valid <em>authenticator</em> corresponding to the given identity. For humans, authenticators can be ID cards, driver’s licenses, and so on. For all these IDs, an authority at some point in time verified the human identity and subsequently issued a corresponding authenticator that’s usually valid for a certain amount of time. During this validity period, the authority and others can use the provided authenticator to verify a specific identity.</p>
<p class="indent">For devices, typical authenticators are symmetric secret keys or asymmetric private keys, (temporary) authentication tokens, or passwords (in legacy cases). These authenticators were created and issued for a specific device (for example, during production), and they can be used to prove cryptographically the identity of that same device at a later time.</p>
<h4 class="h4" id="ch00lev2_63"><strong><em>Authentication Protocols</em></strong></h4>
<p class="noindent">Depending on the type of authenticator, the authentication process is performed in different ways. A common approach is a <em>challenge-response authentication protocol</em>. <a href="ch06.xhtml#ch06fig01">Figure 6-1</a> shows one form of a challenge-response handshake.</p>
<div class="image"><img alt="Image" height="330" id="ch06fig01" src="../images/06fig01.jpg" width="878"/></div>
<p class="figcap"><em>Figure 6-1: The typical steps during challenge-response authentication</em></p>
<p class="indent">The challenge-response authentication process starts with the generation of a random challenge <em>C</em> <span class="ent">➊</span> on the verifier side that is subsequently transmitted to the device. The device processes this unpredictable value with its secret authenticator and yields a response <em>R</em> that’s returned to the verifier <span class="ent">➋</span>. In the final step <span class="ent">➌</span>, <em>R</em> is compared to its expected value to decide whether authentication was successful.</p>
<p class="indent">For symmetric secrets, the on-device algorithm processing the given challenge with the device-specific secret could be a hash function or an HMAC construction. However, the disadvantage is that the secret also has to be available in the verifier’s database to compute the correct expected value and is not solely stored within the device.</p>
<p class="indent"><span epub:type="pagebreak" id="page_105"/>In contrast, asymmetric cryptography allows for device-only authenticators that never leave the device, which is the most secure solution. Specifically, digital signatures based on RSA or ECDSA, as explained in <a href="ch02.xhtml#ch02">Chapter 2</a>, could be used to generate authentication responses from random challenges. In this case, the verifier would need only the corresponding public key in order to check the validity of the returned signature.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In most cases, authentication is possible only with secrets. Therefore, confidentiality is a natural protection goal for all kinds of authenticators. If broken, device impersonation becomes a likely threat.</em></p>
</div>
<h4 class="h4" id="ch00lev2_64"><strong><em>Dedicated Authentication Chips</em></strong></h4>
<p class="noindent">As introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>, semiconductor manufacturers offer a variety of authentication chips that not only securely store authenticators but also provide an algorithmic means to perform a challenge-response handshake for authentication purposes.</p>
<p class="indent">This approach has two advantages. First, extracting the secret authenticator from the chip is a pretty difficult task for attackers. Second, since these chips usually come with integrated support for asymmetric cryptography, mainly digital signatures based on elliptic curves, the secret never has to leave the physical boundaries of the chip.</p>
<p class="indent">On the other hand, with this approach, you now have another component on your BOM, you need space on the PCB, and necessary software integration efforts of these devices vary among vendors. In addition, an attack vector is often overlooked—namely, the physical transfer of such an identity chip to another device. The simple 8-pin packages could be desoldered and integrated into a different original device or even into a custom attacker device. As in code-lifting attacks, adversaries might not care about the secret inside the chip if they can move the whole chip to their desired location.</p>
<h4 class="h4" id="ch00lev2_65"><strong><em>Multifactor Authentication</em></strong></h4>
<p class="noindent">For the authentication of human users, <em>multifactor authentication (MFA)</em> has gained a lot of attention over the last several years. Following the principle of defense in depth, MFA requires attackers to capture not only one authenticator, such as a password, but also at least a second factor, like a temporary token generated in a mobile app or by a hardware token. Since passwords are stored in human brains (or password managers) and additional authenticators often originate from an additional hardware device or at least a different communication channel, the necessary effort for successful attacks is significantly higher.</p>
<p class="indent">For device authentication, the situation is a little bit different because devices don’t use brains and mobile apps for authenticator storage and generation. However, you could still consider a multifactor approach—for example, using one authenticator stored in firmware and a second one that originates from a dedicated authentication chip. The authentication process would then consist of two handshakes, one with the hardware component <span epub:type="pagebreak" id="page_106"/>and one based on the device software, forcing attackers to compromise two different parts of your device if they want to get hold of its identity.</p>
<p class="indent">Besides additional explicit authenticators, you can use implicit, environmental parameters to strengthen device authentication. A common example is geographical limitations, also known as <em>geo-fencing</em>. In that scenario, device authentication (or general operation) succeeds only if the device’s location matches a predefined area. One way to determine this parameter is the public IP address the device uses for internet communication. Of course, the security gain by these implicit authentication properties is maximized if an attacker who has compromised a device can’t forge the parameters. They should be observable from the outside and not just claimed by the device itself.</p>
<h4 class="h4" id="ch00lev2_66"><strong><em>Trusted Third Parties</em></strong></h4>
<p class="noindent">In the past, the main verifier of a device’s identity was the manufacturer of the same device. Proprietary (and eventually insecure) authentication processes did their job. However, in a multilateral digital ecosystem in IoT and IIoT scenarios, the need for cross-manufacturer device authentication becomes obvious.</p>
<p class="indent">This requirement means manufacturers have to trust authenticators of other devices, including competitors. Since one-to-one trust relations between manufacturers would lead to enormous management overhead, the concept of a <em>trusted third party (TTP)</em> is necessary, as shown in <a href="ch06.xhtml#ch06fig02">Figure 6-2</a>.</p>
<div class="image"><img alt="Image" height="376" id="ch06fig02" src="../images/06fig02.jpg" width="732"/></div>
<p class="figcap"><em>Figure 6-2: The role of a trusted third party in device authentication</em></p>
<p class="indent">In this approach, manufacturers register their device identities with the TTP <span class="ent">➊</span>. After verification, the TTP certifies the given identity and returns a device-specific certificate <span class="ent">➋</span>. Upon an authentication request in the field <span class="ent">➌</span>, the device can provide the issued certificate and cryptographically prove that it is in possession of the corresponding authenticators <span class="ent">➍</span>. However, at this point, the verifying party can’t be sure that the given cryptographic data corresponds to the actual device identity. The verifier finally has to check the validity of the authentication <span class="ent">➎</span>, either in direct communication with <span epub:type="pagebreak" id="page_107"/>the TTP or by using data like public keys provided by the TTP. Afterward, a reliable trust relation with a previously unknown device can be established.</p>
<h4 class="h4" id="ch00lev2_67"><strong><em>Certificates and Certificate Authorities</em></strong></h4>
<p class="noindent">I’ve been using the term <em>certificate</em> to describe a digital document that’s issued by a TTP to confirm a device’s identity. Technically speaking, the most common implementations of this concept are X.509 v3 certificates based on asymmetric cryptography as specified in RFC 5280.</p>
<p class="indent">The purpose of these certificates is to bind a given public key to its corresponding subject, such as a device, and to a set of attributes including a validity period and a certificate serial number. A <em>certificate authority (CA)</em> digitally signs these values with its own private key. This CA is also included in the certificate, in the <span class="literal">Issuer</span> field. The result is the smallest version of a <em>certificate chain</em>, which means that a device certificate and its public key can be cryptographically verified, and if successful, the next certificate (namely, that of the CA) has to be verified. Authentication is trusted only if both verifications succeed.</p>
<p class="indent">In practice, a manufacturer might have its own product CA, which is certified by an intermediate CA of a TTP, which is again certified by an internationally recognized root CA. With that process, the rather complex hierarchical certificate chains are established that have to be verified up to their root, whenever a device needs to authenticate itself.</p>
<p class="indent">The <em>root certificates</em> aren’t certified by anybody; they’re self-signed and have to be available in some kind of root store on the verifier’s side. This means that verifying parties also must unconditionally trust all their root certificates. Therefore, the root store requires strong integrity protection; otherwise, attackers can inject new trust relations by manipulating the stored certificates.</p>
<p class="indent">In several cases, a certificate can’t be trusted until its actual end of validity—for example, because of a private-key compromise, device theft, or similar issue. For such situations, CAs maintain a <em>certificate revocation list (CRL)</em> that lists all certificates no longer trusted even though their validity period is not yet over. The <em>Online Certificate Status Protocol (OCSP)</em> is a common protocol for checking the revocation status of a certificate during authentication, as standardized in RFC 6960.</p>
<p class="indent">The whole architecture of verification, certification, and revocation, and the corresponding processes and services, are often referred to as the <em>public-key infrastructure (PKI)</em>. Since such a system demands significant maintenance and documentation efforts, small and medium-sized companies often hesitate to implement it themselves and rely on PKI service providers instead, which means TTPs.</p>
<h3 class="h3" id="ch00lev1_53"><strong>Identity Life Cycle and Management</strong></h3>
<p class="noindent">Now that we’ve covered the basic concepts of device authentication, this section establishes the need for reliable strategies for managing the <em>life cycle</em> of <span epub:type="pagebreak" id="page_108"/>device identities. Life-cycle management has four main steps, as depicted in <a href="ch06.xhtml#ch06fig03">Figure 6-3</a>: identity generation, its provisioning in manufacturer systems as well as within the device, everyday usage in the field, and the often-forgotten exchange or destruction of the same identity.</p>
<div class="image"><img alt="Image" height="332" id="ch06fig03" src="../images/06fig03.jpg" width="577"/></div>
<p class="figcap"><em>Figure 6-3: The life cycle of device identities</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Don’t treat life-cycle management as optional. Even if you’ve solved all the technical challenges regarding identifiers, cryptography, and secure memory, make sure your organization has answers regarding the organizational challenges ahead.</em></p>
</div>
<h4 class="h4" id="ch00lev2_68"><strong><em>Generation</em></strong></h4>
<p class="noindent">A device’s identity can be generated in various places and at various times. The place and time you choose affect the security requirements and procedures of your production process. If you use electronics manufacturing services (EMS) to manufacture your product, a trustful and close cooperation with your service provider is essential.</p>
<p class="indent">Generating the identity on the device itself during production can be the most secure option of all, but only if the corresponding authentication secrets <em>never</em> leave the device. Asymmetric cryptography enables this use case because the generated private key might stay on the device, and its public counterpart can be made available to potential verifiers. Of course, you might also generate a symmetric secret on the device during the production process, but in that case, the key has to be exported later to enable identity verification.</p>
<p class="indent">While on-device generation has security advantages, it comes with operational and practical challenges. Imagine that a device “loses” its identity because the memory that stores it gets broken. If that was the single storage location, a new identity has to be generated after repair, which might lead to a conflict because a new entry is generated in your product database, but the hardware is actually old. Also, your customers would have to replace the old device identity with the new one in their asset management systems. If you as a manufacturer have an identity backup, this case could be handled easily, but at the cost of security.</p>
<p class="indent">A second disadvantage of on-device generation can be the late availability of product identities, because they are available only after a certain manufacturing step is completed. Sometimes that might be exactly what you want, <span epub:type="pagebreak" id="page_109"/>but if your device identities have to be populated in your own IT systems to enable smooth operation from day one, you might want to prepare those processes with your device identities even before actual production.</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>On-device identity generation based on RSA keys is a nondeterministic process and takes a variable amount of time. This limitation has to be considered when planning production processes, especially for low-performance devices.</em></p>
</div>
<p class="indent">Generating an identity outside the device provides more flexibility in managing the device identity before production and in cases of repair. Authentication secrets are prepared in advance within an identity management system and provided to production in a second step. However, this means that these identities exist before the real device is even assembled and, of course, they already carry the protection goals of confidentiality and integrity. Information disclosure or data manipulation before production could have severe consequences for the security of your product.</p>
<p class="indent">A last point that might influence your on-/off-device generation decision is the involvement of a TTP. If you generate identities during production, they have to be registered, verified, and certified with a third party within a tight schedule. Of course, that’s possible and desirable, and it’s already implemented by leaders in this field, but it requires a significant amount of infrastructure and process management efforts.</p>
<h4 class="h4" id="ch00lev2_69"><strong><em>Provisioning</em></strong></h4>
<p class="noindent">Depending on the identity generation phase, the following provisioning step comes in two flavors with their own pros and cons. In both cases, the end result should be that the identity is provisioned on the device itself and within the product-tracking and identity management system of the manufacturer and the eventually involved EMS provider.</p>
<p class="indent">After on-device generation, all manufacturer systems have to be provisioned with the new identity, which requires a read-out step during production. For asymmetric crypto, only the public key or a corresponding certificate from a TTP has to be stored in the manufacturer’s identity database. However, if backups of authentication secrets are desired, you can create them by extracting the private key at this point.</p>
<p class="indent">The offline generation of identities requires information flow in the other direction—namely, from an identity management system to the device to be produced. Clearly, a programming step is necessary, in which the secret and the attributes of the pregenerated identity are written to specific memory locations or hardware resources within the product. This step might be integrated in existing firmware programming procedures or similar processes.</p>
<p class="indent">In all these cases, when sensitive data is transferred to or from a device during provisioning, at least the integrity and often also the confidentiality of this communication should be guaranteed. Otherwise, authentication secrets might be disclosed, devices might end up with a manipulated identity, or the manufacturer’s identity data might be corrupted.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_110"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If your device identities are generated before production and are then sent to your EMS provider by email or on a USB stick by snail mail, consider carefully whether this meets your protection goals. If you’re honest, it probably doesn’t.</em></p>
</div>
<h4 class="h4" id="ch00lev2_70"><strong><em>Usage in the Field</em></strong></h4>
<p class="noindent">The previously generated and provisioned identities are used for authentication in the field. So far, so good. Can we take any other precautions during everyday usage? Absolutely. An identity management system allows us to perform sanity and plausibility checks whenever devices authenticate with our systems.</p>
<p class="indent">Imagine your authentication logs show that the same device connects from two locations within a short time. This might be an indicator that somebody has stolen a device’s identity and is using it for their own purposes. If such cases can be identified early and specific investigations follow in a timely manner, damage can be significantly limited.</p>
<h4 class="h4" id="ch00lev2_71"><strong><em>Exchange or Destruction</em></strong></h4>
<p class="noindent">Even if some devices (especially in industrial, military, or space applications) are meant to last forever physically, their authentication secrets usually don’t. On the internet, a common validity period for web server certificates is 90 days (as, for example, implemented by Let’s Encrypt at <em><a href="https://letsencrypt.org">https://letsencrypt.org</a></em>), which means that these identities have to be regenerated at least every three months.</p>
<p class="indent">Clearly, identity renewal in IoT and IIoT scenarios is still far away from such high frequencies. However, at least if X.509 certificates are used for authentication purposes, a validity period is a mandatory parameter that has to be specified, either by your company or by the TTP of your choice. Some manufacturers issue device certificates with a validity period of 20 years or more, but even if the chosen crypto is future-proof, it’s hard to estimate whether such an identity will still be trustworthy after 15 years or more.</p>
<p class="indent">Some network products (for example, those from Cisco) support certificate management protocols like the <em>Simple Certificate Enrollment Protocol (SCEP)</em> or its more recent alternative, <em>Enrollment over Secure Transport (EST)</em>. Since this is new ground for IoT and IIoT devices, no common standard has been established as of this writing, but it’s pretty clear that automation is key to continuous and reliable identity and certificate management.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In 2022, manufacturers of security gateways for accessing the German health telematics infrastructure claimed that devices had to be physically replaced because the validity of their five-year cryptographic identities came to an end. Subsequently, the Chaos Computer Club (CCC) proved the opposite and, by its own account, saved the German healthcare system</em> €<em>400 million. This is just one example that emphasizes the importance of robust identity-renewal processes.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_111"/>The final step of an identity’s life cycle is literally its destruction. While physical removal is not always possible, a manufacturer should at least be prepared to revoke the trust relation for a specific device if it reaches its end of life before the defined end of its validity period. A typical measure for this purpose is a CRL maintained by a CA or a trust status flag in your own manufacturer database.</p>
<h3 class="h3" id="ch00lev1_54"><strong>Case Study: Identity Generation and Provisioning</strong></h3>
<p class="noindent">In this case study, I investigate the availability of identifiers for an STM32-MP157F-DK2 and how to extract them in order to derive a system identity. Further, we’ll see how to prepare a certificate signing request on this device that can subsequently be provided to a TTP, which in turn, is able to issue a valid device certificate.</p>
<h4 class="h4" id="ch00lev2_72"><strong><em>Identifiers and System Identity</em></strong></h4>
<p class="noindent">The STM32MP157F-DK2 evaluation kit is an embedded system that consists of several components. Many of these components come with their own identifiers that engineers might capture and use to create a comprehensive device identity.</p>
<p class="indent">A common identifier is the serial number of a device’s main CPU. In this regard, ST’s <em>Reference Manual RM0436</em> for STM32MP157F devices states: “The 96-bit unique device identifier provides a reference number, unique for a given device and in any context. These bits cannot be altered by the user.” This unique ID (UID) is immutably stored in the OTP memory of the STM32-MP157F chip. <a href="ch06.xhtml#ch06list01">Listing 6-1</a> shows that this UID is split into three 32-bit words that can be read from specific memory addresses.</p>
<pre class="pre">Base address: 0x5C00 5000 (BSEC base address on APB5)&#13;
Address offset: 0x234 = UID[31:0]&#13;
Address offset: 0x238 = UID[63:32]&#13;
Address offset: 0x23C = UID[95:64]</pre>
<p class="list-title" id="ch06list01"><em>Listing 6-1: The physical addresses of the UID in STM32MP157F devices</em></p>
<p class="indent">We can use the <span class="literal">devmem2</span> command line tool to read physical memory addresses. As shown in <a href="ch06.xhtml#ch06list02">Listing 6-2</a>, the application outputs three 32-bit words representing the chip’s identity, given a combination of base address and UID offsets.</p>
<pre class="pre"># <span class="codestrong1">devmem2 0x5c005234</span>&#13;
...&#13;
Read at address  0x5C005234 (0xb6fb0234): 0x0038003D&#13;
# <span class="codestrong1">devmem2 0x5c005238</span>&#13;
...&#13;
Read at address  0x5C005238 (0xb6fb9238): 0x34385114&#13;
<span epub:type="pagebreak" id="page_112"/>&#13;
# <span class="codestrong1">devmem2 0x5c00523c</span>&#13;
...&#13;
Read at address  0x5C00523C (0xb6f1423c): 0x36383238</pre>
<p class="list-title" id="ch06list02"><em>Listing 6-2: Reading the CPU UID of my STM32MP157F device from physical addresses</em></p>
<p class="indent">On Linux systems, the serial number is also available from <em>/proc/cpuinfo</em>. The output shown in <a href="ch06.xhtml#ch06list03">Listing 6-3</a> confirms that the serial number is the same as that extracted from the raw memory locations before.</p>
<pre class="pre"># <span class="codestrong1">cat /proc/cpuinfo | grep Serial</span>&#13;
Serial : 0038003D3438511436383238</pre>
<p class="list-title" id="ch06list03"><em>Listing 6-3: Capturing the CPU serial number available in Linux</em></p>
<p class="indent">However, the STM32MP157F chip is not the only one on the PCB. ST’s <em>User Manual UM2637</em> describes a multitude of implemented communication interfaces. Besides classic Ethernet networking, the device includes an IC that provides Wi-Fi and Bluetooth capabilities. All these interfaces have unique MAC addresses that might be used to derive system identities. <a href="ch06.xhtml#ch06list04">Listing 6-4</a> shows how to extract those values when running on Linux.</p>
<pre class="pre"># <span class="codestrong1">cat /sys/class/net/eth0/address</span>&#13;
10:e7:7a:e1:81:65&#13;
# <span class="codestrong1">cat /sys/class/net/wlan0/address</span>&#13;
48:eb:62:c4:0a:08&#13;
# <span class="codestrong1">cat /sys/kernel/debug/bluetooth/hci0/identity</span>&#13;
43:43:a1:12:1f:ac (type 0) 00000000000000000000000000000000 00:00:00:00:00:00</pre>
<p class="list-title" id="ch06list04"><em>Listing 6-4: Extracting Ethernet, Wi-Fi, and Bluetooth MAC addresses in Linux</em></p>
<p class="indent">Finally, one part of the system can be removed and replaced easily: the removable media card. In my case, it’s a microSD card that contains a <em>card identification (CID)</em>. This 128-bit value uniquely identifies an SD card. Among other information, it contains a manufacturer ID, a product serial number, and the date of production. Again, Linux provides a corresponding entry in its <span class="literal">sysfs</span> that can be read out as illustrated in <a href="ch06.xhtml#ch06list05">Listing 6-5</a>.</p>
<pre class="pre"># <span class="codestrong1">cat /sys/block/mmcblk0/device/cid</span>&#13;
275048534431364760dad3df9a013780&#13;
# <span class="codestrong1">cat /sys/block/mmcblk0/device/serial</span>&#13;
0xdad3df9a</pre>
<p class="list-title" id="ch06list05"><em>Listing 6-5: Reading the unique CID of an SD card</em></p>
<p class="indent">Besides the <span class="literal">cid</span> value, Linux provides the <span class="literal">serial</span> value for an SD card, which solely contains the memory card’s serial number.</p>
<p class="indent">For this case study, let’s assume your team has chosen to use the central CPU ID and the Wi-Fi MAC address as the two relevant system identifiers. They can be combined by a hash function, as shown in the next section.</p>
<h4 class="h4" id="ch00lev2_73"><span epub:type="pagebreak" id="page_113"/><strong><em>Certificate Signing Request</em></strong></h4>
<p class="noindent">A <em>certificate signing request (CSR)</em> is a data structure that requests a CA to certify that a given public key is bound to a specific identity, a device identity in this case. Linux offers several ways to generate a CSR and provide the necessary information. <a href="ch06.xhtml#ch06list06">Listing 6-6</a> shows the imports necessary to accomplish RSA key generation and CSR creation with the help of the <span class="literal">cryptography</span> Python module. Also, the <span class="literal">subprocess</span> module is included to get system identifiers by using the available command line tools.</p>
<pre class="pre">import subprocess&#13;
from cryptography.hazmat.primitives import serialization&#13;
from cryptography.hazmat.primitives.asymmetric import rsa&#13;
from cryptography import x509&#13;
from cryptography.x509.oid import NameOID&#13;
from cryptography.hazmat.primitives import hashes</pre>
<p class="list-title" id="ch06list06"><em>Listing 6-6: The necessary imports from the</em> <span class="codeitalic1">cryptography</span> <em>and</em> <span class="codeitalic1">subprocess</span> <em>modules</em></p>
<p class="indent">The first part of the on-device identity generation is usually based on asymmetric cryptography (RSA, in this case). As shown in <a href="ch06.xhtml#ch06list07">Listing 6-7</a>, a random key pair can be created with a single line.</p>
<pre class="pre"># Generate RSA key&#13;
key = rsa.generate_private_key(public_exponent=65537, key_size=4096 <span class="ent">➊</span>)&#13;
&#13;
# Write key to disk&#13;
with open('dev.key', 'wb') as f:&#13;
    f.write(key.private_bytes(&#13;
        encoding=serialization.Encoding.PEM,&#13;
        format=serialization.PrivateFormat.TraditionalOpenSSL,&#13;
        encryption_algorithm=&#13;
        serialization.BestAvailableEncryption(<span class="ent">➋</span> b'PrivateKeyPassphrase'),&#13;
    ))</pre>
<p class="list-title" id="ch06list07"><em>Listing 6-7: An on-device generation of an RSA key pair</em></p>
<p class="indent">For this case study, I decided to use an RSA key length of 4,096 bits <span class="ent">➊</span> to account for an (I)IoT device’s lifetime of several years. To simplify this example, the generated private key is stored in the <em>dev.key</em> file and is protected by a standard passphrase <span class="ent">➋</span>. In an actual production environment, the key should be stored in a secure way, as discussed in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>
<p class="indent"><a href="ch06.xhtml#ch06list08">Listing 6-8</a> shows an example procedure of identifier collection and processing.</p>
<pre class="pre">   # Collect system data&#13;
<span class="ent">➊</span> output = subprocess.Popen('cat /proc/cpuinfo | grep Serial',&#13;
            shell=True, stdout=subprocess.PIPE)&#13;
   cpu_serial = output.stdout.read().split()[2](@\newpage@)&#13;
<span class="ent"><span epub:type="pagebreak" id="page_114"/>➋</span> output = subprocess.Popen('cat /sys/class/net/wlan0/address',&#13;
            shell=True, stdout=subprocess.PIPE)&#13;
   wifi_mac = output.stdout.read().split()[0]&#13;
&#13;
   # Hash collected system data&#13;
<span class="ent">➌</span> digest = hashes.Hash(hashes.SHA256())&#13;
   digest.update(cpu_serial)&#13;
   digest.update(wifi_mac)&#13;
   system_id = digest.finalize()&#13;
<span class="ent">➍</span> system_id = system_id[:4].hex()</pre>
<p class="list-title" id="ch06list08"><em>Listing 6-8: Collection and processing of an on-device identifier</em></p>
<p class="indent">In the first step, the CPU serial number <span class="ent">➊</span> and the Wi-Fi MAC address <span class="ent">➋</span> of the produced system are read by the means Linux provides. Subsequently, the hash function SHA-256 <span class="ent">➌</span> is used to process those values and to derive a 4-byte system identifier <span class="ent">➍</span> that would change if the CPU or the Wi-Fi chip is replaced in the future. The SD card ID is neglected on purpose, because SD cards break every now and then, which would lead to an unnecessarily high demand for identity regeneration.</p>
<p class="indent">For a device certificate and a CSR, respectively, you need to specify a <em>common name</em> for the device, as shown in <a href="ch06.xhtml#ch06list09">Listing 6-9</a>.</p>
<pre class="pre">   # Manufacturer data&#13;
   manufacturer = 'IoT Devices Corp'&#13;
   manufacturer_device_serial_no = 'IOTDEV-1337-08151234'&#13;
&#13;
   # System name for CSR and certificate&#13;
<span class="ent">➊</span> cert_common_name = manufacturer_device_serial_no + '-' + system_id&#13;
&#13;
   # Generate CSR and sign with private key&#13;
   csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([&#13;
       x509.NameAttribute(NameOID.ORGANIZATION_NAME, manufacturer),&#13;
    <span class="ent">➋</span>  x509.NameAttribute(NameOID.COMMON_NAME, cert_common_name),&#13;
<span class="ent">➋</span> ])).sign(key, hashes.SHA256())&#13;
&#13;
   # Write CSR to disk&#13;
   with open('dev.csr', 'wb') as f:&#13;
       f.write(csr.public_bytes(serialization.Encoding.PEM))</pre>
<p class="list-title" id="ch06list09"><em>Listing 6-9: An on-device CSR preparation</em></p>
<p class="indent">In this case study, the unique device name is the combination of the serial number given by the manufacturer and the hardware-dependent system identifier <span class="ent">➊</span>. This string is used as an input to the CSR generation <span class="ent">➋</span>, together with the manufacturer’s name in the CSR’s <em>organization</em> field. Finally, the device signs the CSR with its unique confidential private key <span class="ent">➌</span>. Afterward, the CSR is stored in the <em>dev.csr</em> file.</p>
<p class="indent">The saved CSR file has to be transmitted to the CA responsible for certifying the identity of produced devices. Also, the manufacturer or EMS <span epub:type="pagebreak" id="page_115"/>provider might extract the collected and generated device data in a database. As an example, <a href="ch06.xhtml#ch06list010">Listing 6-10</a> shows the data from an STM32MP157F device.</p>
<pre class="pre">Collected CPU serial number:  0038003D3438511436383238&#13;
Collected Wi-Fi MAC address:  48:eb:62:c4:0a:08&#13;
Derived system identifier:    f30cf858&#13;
Given device serial number:   IOTDEV-1337-08151234&#13;
Common name in certificate:   IOTDEV-1337-08151234-f30cf858</pre>
<p class="list-title" id="ch06list010"><em>Listing 6-10: Example output of identifier data from my STM32MP157F device</em></p>
<p class="indent">As you can see, a 4-byte system identifier is generated from the listed individual identifiers and appended to the device serial number. This string is subsequently used as the common name for the generated CSR.</p>
<h4 class="h4" id="ch00lev2_74"><strong><em>Certificate Authority</em></strong></h4>
<p class="noindent">Before we issue the final certificate, let’s look at what the CSR contains. <a href="ch06.xhtml#ch06list011">Listing 6-11</a> shows how to display CSR contents with the <span class="literal">openssl req</span> command line tool.</p>
<pre class="pre">$ <span class="codestrong1">openssl req -in dev.csr -noout -text</span>&#13;
Certificate Request:&#13;
    Data:&#13;
        Version: 1 (0x0)&#13;
      <span class="ent">➊</span> Subject: O = IoT Devices Corp, CN = IOTDEV-1337-08151234-f30cf858&#13;
      <span class="ent">➋</span> Subject Public Key Info:&#13;
            Public Key Algorithm: rsaEncryption&#13;
                Public-Key: (4096 bit)&#13;
                Modulus:&#13;
                    00:d3:a0:14:fb:e1:0e:d0:74:3d:26:d4:ef:a1:ed:&#13;
                    ...&#13;
                    c9:2a:f5:46:e4:b2:ad:a9:5e:ee:cb:79:85:d9:1e:&#13;
                    9f:3e:57&#13;
                Exponent: 65537 (0x10001)&#13;
        Attributes:&#13;
            (none)&#13;
            Requested Extensions:&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
  <span class="ent">➌</span> Signature Value:&#13;
         81:98:b1:e8:c2:fe:3a:55:32:39:2e:27:ce:2c:a8:54:bd:04:&#13;
         ...&#13;
         17:77:6c:a1:5b:4a:a7:ed:22:55:33:23:26:55:05:90:26:d2:&#13;
         90:7a:5e:34:65:80:32:4e</pre>
<p class="list-title" id="ch06list011"><em>Listing 6-11: Example CSR for my specific STM32MP157F device</em></p>
<p class="indent">The subject <span class="ent">➊</span> is represented by an organization string (<span class="literal">O</span>) and a common name (<span class="literal">CN</span>) as specified in our CSR preparation script in <a href="ch06.xhtml#ch06list09">Listing 6-9</a>, <span epub:type="pagebreak" id="page_116"/>followed by its corresponding RSA public key <span class="ent">➋</span>. The device’s digital signature <span class="ent">➌</span> can be clearly identified at the end of the given request. The CA can use it to verify whether the requesting subject actually has access to the private key corresponding to the given public key in the CSR.</p>
<p class="indent">CA and PKI infrastructures usually consist of complex processes with a variety of organizational and technical measures to ensure proper and trustworthy functioning. As shown in <a href="ch06.xhtml#ch06list012">Listing 6-12</a>, we create a test CA that’s far from production-ready but okay for educational purposes. The term <em>quick and dirty</em> might be applicable here.</p>
<pre class="pre">$ <span class="codestrong1">openssl genrsa -out ca.key 4096</span>&#13;
$ <span class="codestrong1">openssl req -new -x509 -key ca.key \</span>&#13;
              <span class="codestrong1">-subj "/C=DE/L=Augsburg/O=Super Trusted Party/CN=CA 123" \</span>&#13;
              <span class="codestrong1">-out ca.crt</span></pre>
<p class="list-title" id="ch06list012"><em>Listing 6-12: A quick generation of a test CA with</em> <span class="codeitalic1">openssl</span> <em>tools</em></p>
<p class="indent">We can generate the test CA with the help of the <span class="literal">openssl genrsa</span> tool. The first command in <a href="ch06.xhtml#ch06list012">Listing 6-12</a> generates a 4,096-bit RSA key pair for the CA and stores it as <em>ca.key</em>. Since, in this case study, this is the root of the CA, the corresponding certificate has to be self-signed. The <em>ca.crt</em> certificate can be obtained by using the <span class="literal">openssl req</span> tool and telling it the CA’s attributes—for example, the country (<span class="literal">DE</span> for Germany) and city it’s located in (<span class="literal">Augsburg</span>), its organization’s name (<span class="literal">Super Trusted Party</span>), and its common name (<span class="literal">CA 123</span>).</p>
<p class="indent">After the CA has registered and successfully verified the certificate request at hand, it takes the CSR data and adds attributes like the validity period. In <a href="ch06.xhtml#ch06list013">Listing 6-13</a>, you can see that the <span class="literal">-days</span> parameter is set to <span class="literal">3650</span>, which means that the issued certificate is valid for 10 years.</p>
<pre class="pre">$ <span class="codestrong1">openssl x509 -req -in dev.csr -CA ca.crt -CAkey ca.key -CAcreateserial \</span>&#13;
               <span class="codestrong1">-days 3650 -out dev.crt</span></pre>
<p class="list-title" id="ch06list013"><em>Listing 6-13: Generating a certificate from a CSR with the</em> <span class="codeitalic1">openssl</span> <em>tool</em></p>
<p class="indent">In the device certificate generation process, the CA decides on the length of the validity period, but of course that has an influence on your device identity life cycle. Make sure to choose this value deliberately.</p>
<p class="indent">Let’s look at the final result of this demanding process. The <span class="literal">openssl x509</span> tool is able to output the device certificate contents, as shown in <a href="ch06.xhtml#ch06list014">Listing 6-14</a>.</p>
<pre class="pre">$ <span class="codestrong1">openssl x509 -in dev.crt -noout -text</span>&#13;
Certificate:&#13;
    Data:&#13;
        Version: 1 (0x0)&#13;
        Serial Number:&#13;
         <span class="ent">➊</span> 45:3c:c3:30:c1:e3:c2:a9:49:5c:14:d6:16:5d:79:69:24:6c:31:66&#13;
        Signature Algorithm: sha256WithRSAEncryption&#13;
      <span class="ent">➋</span> Issuer: C = DE, L = Augsburg, O = Super Trusted Party, CN = CA 123&#13;
        Validity&#13;
            Not Before: Apr  5 11:18:13 2024 GMT&#13;
<span epub:type="pagebreak" id="page_117"/>          <span class="ent">➌</span> Not After : Apr  2 11:18:13 2034 GMT&#13;
        Subject: O = IoT Devices Corp, CN = IOTDEV-1337-08151234-f30cf858&#13;
        Subject Public Key Info:&#13;
            Public Key Algorithm: rsaEncryption&#13;
                RSA Public-Key: (4096 bit)&#13;
                Modulus:&#13;
                    00:d3:a0:14:fb:e1:0e:d0:74:3d:26:d4:ef:a1:ed:&#13;
                    ...&#13;
                    c9:2a:f5:46:e4:b2:ad:a9:5e:ee:cb:79:85:d9:1e:&#13;
                    9f:3e:57&#13;
                Exponent: 65537 (0x10001)&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
  <span class="ent">➍</span> Signature Value:&#13;
         75:d5:07:71:ec:fe:c6:27:fd:e2:a7:1c:fa:b9:89:b3:9c:0f:&#13;
         ...&#13;
         8d:fa:f6:f1:53:79:32:1e:a8:ec:6f:f7:03:57:2f:7b:f4:fb:&#13;
         45:77:6a:f8:c6:70:72:41</pre>
<p class="list-title" id="ch06list014"><em>Listing 6-14: The certificate contents of a sample device</em></p>
<p class="indent">In comparison to the original CSR, you can see that the CA added a certificate serial number <span class="ent">➊</span> and its own data at the <span class="literal">Issuer</span> field <span class="ent">➋</span>. The validity period <span class="ent">➌</span> is set to be 10 years from the moment of issuance. And, finally, all these attributes are signed by the CA <span class="ent">➍</span> together with the device’s information and its public key. Now every entity that trusts the used CA is able to authenticate the produced device.</p>
<p class="indent">After issuing the certificate, it has to be provided to the device itself, but also to the manufacturer’s identity management system. During production, this whole process of generation, certificate issuance, and provisioning should run with a high degree of automation and with precautions taken to minimize threats to confidentiality and integrity.</p>
<h3 class="h3" id="ch00lev1_55"><strong>Case Study: RSA Key Generation in Production</strong></h3>
<p class="noindent">Although ECDSA has some advantages over RSA, as discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>, it’s still widely used in certificates. However, if you work with RSA, be aware that RSA key generation is a nondeterministic process and might take varying amounts of time.</p>
<p class="indent">This second, brief case study investigates how much time is required during the production process to generate RSA keys of a given length. <a href="ch06.xhtml#ch06list015">Listing 6-15</a> shows a simple way to analyze RSA key-generation times.</p>
<pre class="pre">import time&#13;
from cryptography.hazmat.primitives.asymmetric import rsa&#13;
&#13;
time_data = []&#13;
for n in range(16):&#13;
    start_time   = time.time()&#13;
    key = rsa.generate_private_key(public_exponent=65537, key_size=4096)&#13;
<span epub:type="pagebreak" id="page_118"/>    elapsed_time = time.time() - start_time&#13;
    print('Try', n, ': RSA 4096-bit key generation took',&#13;
          '{:.3f}'.format(elapsed_time), 'seconds!')&#13;
    time_data.append(elapsed_time)&#13;
print('MIN:', '{:.3f}'.format(min(time_data)), 'seconds')&#13;
print('MAX:', '{:.3f}'.format(max(time_data)), 'seconds')&#13;
print('AVG:', '{:.3f}'.format(sum(time_data)/len(time_data)), 'seconds')</pre>
<p class="list-title" id="ch06list015"><em>Listing 6-15: An RSA key-generation timing analysis</em></p>
<p class="indent">This example uses the <span class="literal">cryptography</span> Python module and the parameters from the previous case study. It performs 16 tries for simplicity, but a sound statistical analysis would require a larger number of test runs. <a href="ch06.xhtml#ch06list016">Listing 6-16</a> shows exemplary results of RSA 4,096-bit key-generation times obtained by running the code from <a href="ch06.xhtml#ch06list015">Listing 6-15</a> on my STM32MP157F device.</p>
<pre class="pre"># <span class="codestrong1">python3 rsa_key_gen_time.py</span>&#13;
Try 0 : RSA 4096-bit key generation took 59.920 seconds!&#13;
Try 1 : RSA 4096-bit key generation took 28.696 seconds!&#13;
Try 2 : RSA 4096-bit key generation took 72.872 seconds!&#13;
Try 3 : RSA 4096-bit key generation took 109.765 seconds!&#13;
...&#13;
Try 12 : RSA 4096-bit key generation took 48.925 seconds!&#13;
Try 13 : RSA 4096-bit key generation took 50.885 seconds!&#13;
Try 14 : RSA 4096-bit key generation took 90.907 seconds!&#13;
Try 15 : RSA 4096-bit key generation took 40.634 seconds!&#13;
MIN: 28.696 seconds&#13;
MAX: 109.765 seconds&#13;
AVG: 62.768 seconds</pre>
<p class="list-title" id="ch06list016"><em>Listing 6-16: RSA key-generation timing results on my STM32MP157F device</em></p>
<p class="indent">The variation of generation times is not negligible. The RSA key generation may finish within 30 seconds but might also take 110 seconds or even more. This variation has to be considered in production scheduling, and since an upper bound doesn’t exist for the generation time, you have to expect outliers that might take significantly longer.</p>
<h3 class="h3" id="ch00lev1_56"><strong>Summary</strong></h3>
<p class="noindent">There’s no doubt that every single device is a physically unique object. With the help of identifiers like CPU serial numbers, MAC addresses, and values chosen by the manufacturer, we’re able to represent this uniqueness in the digital space and provide a base for device identities.</p>
<p class="indent">However, merely claiming an identity isn’t enough for most applications. Devices have to be able to cryptographically prove their identity with the help of unique and confidential authenticators like cryptographic keys. This process is called <em>authentication</em>. The secure storage of those authentication secrets is essential to prevent impersonation attacks. <a href="ch05.xhtml#ch05">Chapter 5</a> provided some ideas for confidential data storage in hardware or software.</p>
<p class="indent"><span epub:type="pagebreak" id="page_119"/>A common concept to establish trust in device identities is the registration of devices at third parties that verify their identities and issue digital device certificates. These can be used by anybody trusting the issuer to authenticate a device.</p>
<p class="indent">Besides the technical challenges of binding a digital identity to a device, a much broader field of organizational processes have to be specified to provide secure and reliable identity life-cycle management. These processes often involve EMS providers, TTPs, and your custom process specifics, which leads to a complexity that should never be underestimated.</p>
<p class="indent">The more you dive into this topic, the more “interesting” problems you will discover. For several years, researchers have been working on PUF implementations to exploit manufacturing process variations in order to derive implicit chip identities, and the first products on the market already contain such circuits. Further, identity management automation in on- and offline scenarios and corresponding protocols like SCEP and EST will certainly gain more attention in the future, providing a major step forward for managing secure device identities.<span epub:type="pagebreak" id="page_120"/></p>
</div></body></html>