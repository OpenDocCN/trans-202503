- en: '**18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OBJECT-ORIENTED PROGRAMMING**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far in this book, I have been using the procedural programming paradigm (described
    in “Exploring Data Formats with C” on [page 23](ch02.xhtml#ch02lev1sec4)). In
    this chapter, I’ll introduce how object-oriented programming is implemented at
    the assembly language level in C++.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we can create *objects*, each of which is an
    instance of a class. A class has a set of *attributes*, the data items that define
    the state of the object, and *methods* that can query or change the attributes
    of an object of the class. A software solution typically consists of constructing
    objects and then programming the sending of messages to the objects, which use
    the methods to act on the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use C++, an object-oriented extension of C, to illustrate some of these
    concepts. You’ll learn how a record can be used to store the attributes of an
    object and how methods are implemented as functions associated with the record.
  prefs: []
  type: TYPE_NORMAL
- en: Many other features of C++ are important for creating good object-oriented programming
    solutions, but I won’t go into them in this book. If you’re new to C++, Josh Lospinoso’s
    *C++ Crash Course* (No Starch Press, 2019) would be a good place to start. If
    you want to dig into the design of C++ after learning how to use it, I recommend
    *A Tour of C++*, 3rd edition, by Bjarne Stroustrup, the creator of C++ (Addison-Wesley
    Professional, 2022). A good online resource for using C++ is the C++ Core Guidelines
    at *[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)*.
    It’s kept up to date by Bjarne Stroustrup and Herb Sutter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a very simple C++ class and then look at some assembly language
    generated by the C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects in C++**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ allows us to create *classes*, which are like blueprints for creating objects.
    A C++ class is very much like a C record, but in addition to the *data members*
    that define the attributes of the object, it can include functions as members
    of the class. In C++, we send a message to an object telling it to perform a method
    by calling a class *member function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ specifies six special member functions that are used to create and delete
    objects. I’ll only cover the two most commonly used ones in this book: the constructor
    and the destructor. The *constructor* function is used to create an instance of
    an object, which is called *instantiation*. The job of a constructor is to allocate
    the necessary memory resources and place the object in a known state before sending
    messages to it.'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ compiler generates the code to call our constructor function automatically
    at the point where we instantiate an object. A constructor function has the same
    name as the class. It cannot have a return value—not even `void`. The *default
    constructor* does not take any arguments. We can also write constructors that
    take arguments, and a class can have more than one constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The job of a *destructor* function is to release any resources that were allocated
    by a constructor, thus deleting the object. For example, a constructor might allocate
    memory from the heap (described in [Chapter 10](ch10.xhtml)), which the destructor
    would deallocate. There can be only one destructor function, which has the same
    name as the class, preceded by the `~` (tilde) character. The destructor cannot
    have a return value and takes no arguments. The C++ compiler will generate the
    code to call the destructor automatically when program flow leaves the scope of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate these concepts, we’ll look at a simple `Fraction` class whose
    attributes are two `int`s: a `numerator` and a `denominator`. We’ll include a
    constructor, a destructor, and some member functions to work with our `Fraction`
    objects. If we don’t supply constructor or destructor member functions, the C++
    compiler will supply appropriate code to perform the construction and destruction
    of an object; we’ll explore what this means in “Writing a Constructor and Destructor
    via the Compiler” on [page 399](ch18.xhtml#ch18lev1sec2).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the declaration of our `Fraction` class, which we’ll place
    in a header file so it can be included in any file that uses the class, as shown
    in [Listing 18-1](ch18.xhtml#ch18list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-1: The C++* Fraction *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The overall syntax of a `class` declaration is similar to a record declaration
    in C, but it adds the capability to include the methods of the class as member
    functions. Access to members of a class can be *private*, *protected*, or *public*.
    We’ll look only at basic public and private access control here and leave the
    more complex access control concepts to books on C++.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the member functions to be `public` ❶. This means they can be used
    from outside the class to send messages to objects of this class. They provide
    an interface to the object.
  prefs: []
  type: TYPE_NORMAL
- en: We place the data members in the `private` part of the `class` declaration ❷.
    This means only member functions can access them directly, thus giving the member
    functions control over `numerator` and `denominator`, the attributes of our `Fraction`
    class. Code outside this class can access them only through the public interface.
  prefs: []
  type: TYPE_NORMAL
- en: Access to a `class` is private by default. If we listed the attributes before
    the `public` area, we wouldn’t need to use the `private` keyword, but I like to
    list the public interface of a `class` first.
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` keyword can also be used to declare a C++ class, as shown in [Listing
    18-2](ch18.xhtml#ch18list2).
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-2: The C++* Fraction struct'
  prefs: []
  type: TYPE_NORMAL
- en: The default access scope for a C++ `struct` is public, but I like to be explicit.
    The `private` declaration is required for the private scope.
  prefs: []
  type: TYPE_NORMAL
- en: Although `class` and `struct` are the same except for the default access scope,
    I prefer using the `class` keyword because it emphasizes that there is more to
    it than a simple record. However, this is a personal choice. Next, we’ll look
    at how to create objects and how to send messages to them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating an Object***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll illustrate how to create an object and send messages to it using a simple
    program that allows the user to enter the numerator and denominator values of
    a fraction and then adds 1 to the fraction. This program is shown in [Listing
    18-3](ch18.xhtml#ch18list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fraction.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-3: A program to add 1 to a fraction*'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate an object by using the class name and providing a name for the
    object ❶, just like when defining a variable. The dot operator (`.`) is used to
    send a message to a method in the class ❷, which calls the respective member function
    in the class the object belongs to. This program displays the state of the fraction
    before getting user input values and then again after adding 1 to the user’s fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the assembly language generated by the C++ compiler to implement
    the `main` function in [Listing 18-3](ch18.xhtml#ch18list3). The C++ compiler
    in our environment is called `g++`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the following command to generate the assembly language in [Listing
    18-4](ch18.xhtml#ch18list4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as the command we’ve been using for C code, except I’ve added
    the `-fno-exceptions` option. C++ provides an *exception* mechanism for dealing
    with detected runtime errors. The compiler provides the information for this feature
    through assembler directives, which would tend to obscure the discussion here
    of how objects are implemented. Using the `-fno-exceptions` option turns off this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fraction.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-4: The compiler-generated assembly language for the* main *function
    in [Listing 18-3](ch18.xhtml#ch18list3)*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that `my_fraction` (➊ in [Listing 18-3](ch18.xhtml#ch18list3))
    is an automatic local variable, so memory space is allocated on the stack for
    this `Fraction` object in the `main` function’s prologue ❶. The address of this
    memory area is passed to the constructor function, `_ZN8FractionC1Ev`, which will
    initialize the object ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ compiler has decorated the name of our constructor function `Fraction`,
    declared in [Listing 18-1](ch18.xhtml#ch18list1), to be `_ZN8FractionC1Ev` ❸.
    You learned about the C compiler decorating the names of static local variables
    in [Chapter 15](ch15.xhtml). The purpose there was to distinguish between different
    static local variables with the same name in different functions defined in the
    same file.
  prefs: []
  type: TYPE_NORMAL
- en: C++ uses name decorating to associate member functions with their class. Looking
    at the calls to the class member functions in [Listing 18-4](ch18.xhtml#ch18list4),
    you can see that they all begin with `_ZN8Fraction`. Since function names are
    global in scope, including the class name allows us to define other classes in
    the program that have the same names for member functions. For example, we might
    have more than one class in a program that has a `display` member function. Name
    decorating identifies each `display` member function with the class it belongs
    to ❹.
  prefs: []
  type: TYPE_NORMAL
- en: C++ name decorating also allows *function overloading*, which is the ability
    to have more than one class member function with the same name but that differ
    in the number of arguments and their types. In [Listing 18-4](ch18.xhtml#ch18list4),
    the decorated `_ZN8Fraction11add_integerEi`, which is our `add_integer` member
    function, ends with an appended `i`; this shows that the function takes a single
    `int` argument ❺. Including the number and types of the arguments in the name
    decorating differentiates overloaded functions. You’ll get a chance to overload
    the default constructor in “Your Turn” [exercise 18.1](ch18.xhtml#ch18exe1) on
    [page 406](ch18.xhtml#ch18you1).
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard for how name decorating is done, so each compiler may do
    it differently. This means that all C++ code in a program must be compiled and
    linked using compatible compilers and linkers.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the instruction just before each call to a member function ❷. The address
    of the object is passed as the first argument to each of them. This is an *implicit
    argument* that doesn’t show up in the C++ code. You’ll see how to access this
    address in a member function when we look inside the member functions in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Although it doesn’t show in the C++ code that we write, the compiler generates
    a call to our destructor function at the point where program flow leaves the scope
    of the object ❻. In some more advanced programming techniques, we would call the
    destructor explicitly, but we won’t cover them in the book. Most of the time,
    we let the compiler decide when to call the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the constructor and destructor and the other member functions
    of this `Fraction` class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Class Member Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although it’s common to put each C function definition in its own file, C++
    source files are commonly organized to include all the function definitions in
    a class. [Listing 18-5](ch18.xhtml#ch18list5) shows the definitions of the member
    functions for our `Fraction` class.
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-5: The member function definitions for our* Fraction *class*'
  prefs: []
  type: TYPE_NORMAL
- en: C++ adds some scoping rules to the C scoping rules you learned about in [Chapter
    14](ch14.xhtml). Even though the member functions declared in [Listing 18-1](ch18.xhtml#ch18list1)
    are public, they have *class scope*, meaning their names need to be associated
    with the class. The compiler does this by decorating the names when it uses them,
    but we need to use the *scope resolution operator* (`::`) to make this association
    when defining the member functions outside the class scope ❷.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary purposes of a constructor is to initialize the object. We’ll
    set our `Fraction` object to `0/1` ❸, a reasonable initial value for a fraction.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard library provides objects for writing to the screen and reading
    from the keyboard. The `cout` object in the `ostream` class writes a character
    stream to standard output, which is typically connected to the screen ❹. It uses
    the *insertion operator* (`<<`) and converts the data to the appropriate character
    string. The `cin` object in the `istream` class reads a character stream from
    standard input, which is typically connected to the keyboard ❺. It uses the *extraction
    operator* (`>>`) and converts the character string to the appropriate data type
    for the variable it’s reading into.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its class scope, C++ allows us to collect names of things into
    a *namespace scope*. The `iostream` header file places the `cout` and `cin` objects
    in the `std` namespace. We need to specify this namespace when using these objects
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the compiler-generated assembly language for these member
    functions. To simplify the discussion, we’ll look at each function in the file
    separately, in [Listings 18-6](ch18.xhtml#ch18list6) through [18-11](ch18.xhtml#ch18list11).
    As we go through them, keep in mind that this is one file, so the labels are visible
    across all six of the listings.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the *fraction.s* file, shown in [Listing 18-6](ch18.xhtml#ch18list6),
    is code that allocates memory used by functions in the C++ I/O library for the
    `cin` and `cout` I/O objects. Our inclusion of the `iostream` header file in [Listing
    18-5](ch18.xhtml#ch18list5) tells the compiler to insert this code.
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(a)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-6: A byte used by the* cin *and* cout *I/O objects*'
  prefs: []
  type: TYPE_NORMAL
- en: The `.local` assembler directive limits the `_ZStL8__ioinit` label to this object
    ❶. The `.comm` directive allocates 1 byte in memory, which is aligned to an 8-byte
    address and labeled `_ZStL8__ioinit` ❷. If there are other `.comm` directives
    with the same label in our program, they will share the same memory. This memory
    is for use by the `cin` and `cout` I/O objects; the details of its usage are beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-7](ch18.xhtml#ch18list7) shows the second part of the file, the
    constructor for our `Fraction` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(b)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-7: The compiler-generated assembly language for the constructor
    in [Listing 18-5](ch18.xhtml#ch18list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: Our constructor initializes the `numerator` ❷ and `denominator` ❸ data members
    in the `Fraction` object located in our stack frame. Back in [Listing 18-4](ch18.xhtml#ch18list4),
    you saw that the first argument to each member function is the address of the
    object that the member function is operating on. But looking at the class declaration
    in [Listing 18-1](ch18.xhtml#ch18list1), this address doesn’t show up in the member
    function’s parameter list. It’s called the *hidden parameter*.
  prefs: []
  type: TYPE_NORMAL
- en: If a member function is accessing another object in the same class as the object
    it was called from, it needs to be able to distinguish between the two objects.
    Although it doesn’t show up in the parameter list, C++ uses the name `this` for
    the hidden parameter, which is a pointer variable that contains the address of
    the object that called the member function ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler assumes that our member functions are working with the object
    at the address in the `this` pointer variable, so we usually don’t need to use
    it. But some situations require that we explicitly use the pointer. For example,
    we might write a `Fraction` constructor that allows us to specify the initialization
    values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The parameter names have precedence over the member names, so we had to disambiguate
    with the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know where the `Fraction` object’s data members are located within
    the object, you can see in [Figure 18-1](ch18.xhtml#ch18fig1) how the object is
    stored in `main`’s stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg424_Image_290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The* my_fraction *object in* main*’s stack frame*'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know why the compiler included 16 bytes in this stack frame that are
    not used in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor is followed by the destructor, shown in [Listing 18-8](ch18.xhtml#ch18list8).
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-8: The compiler-generated assembly language for the destructor
    in [Listing 18-5](ch18.xhtml#ch18list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing for the destructor to do in this simple class. Earlier, in
    [Listing 18-4](ch18.xhtml#ch18list4), you saw that the memory for the object was
    allocated in the stack frame by the `main` function’s prologue, not by the constructor.
    Similarly, the object’s memory is deleted from the stack in `main`’s epilogue
    code, after the call to the destructor. Some constructors allocate memory from
    the heap, in which case the destructor should release that memory.
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language for the destructor is followed by that for the member
    functions. [Listing 18-9](ch18.xhtml#ch18list9) shows the assembly language for
    the `get` member function.
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(d)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-9: The compiler-generated assembly language for* get *in [Listing
    18-5](ch18.xhtml#ch18list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: When the program is loaded into memory, the location of the `cout` object is
    loaded into our global offset table (GOT) ❶. The location of the `cin` object
    is also loaded into our GOT ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the `display` member function, shown in [Listing 18-10](ch18.xhtml#ch18list10).
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(e)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-10: The compiler-generated assembly language for* display *in [Listing
    18-5](ch18.xhtml#ch18list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our C++ code (see [Listing 18-5](ch18.xhtml#ch18list5)), we chain insertions
    to the `cout` object. The compiler matches the data item type with the `ostream`
    class member function it calls. The first value is an `int` ❶, the second a `char`
    ❷, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-11](ch18.xhtml#ch18list11) shows the compiler-generated assembly
    language for the `add_integer` member function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction.s(f)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-11: The compiler-generated assembly language for* add_integer *in
    [Listing 18-5](ch18.xhtml#ch18list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `this` pointer variable is created in this function’s stack frame ❶. This
    is a leaf function, so the compiler doesn’t generate a frame record in the stack
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `g++` compiler to generate the assembly language yourself, you’ll
    see two other functions, `_Z41__static_initialization_and_destruction_0ii` and
    `_GLOBAL__sub_I__ZN8FractionC2Ev`. The operating system calls these functions
    when the program is loaded to set up the `cout` and `cin` I/O streams. The details
    are beyond the scope of this book, so I won’t show them here.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a constructor is to allocate any system resources an object needs
    and to initialize the object. The destructor then releases the resources allocated
    by the constructor. In the next section, you’ll see that the compiler can automatically
    generate a constructor and a destructor for simple objects such as in our `Fraction`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing a Constructor and Destructor via the Compiler**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initialization of objects in C++ is complex, because there are many ways to
    do it. The previous section covered the most basic way. Now, I’ll show you some
    simple C++ syntax that tells the compiler to figure out how to do the initialization
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recommendation C.45 in the C++ Core Guidelines (see *[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default)*
    states: “Don’t define a default constructor that only initializes data members;
    use in-class member initializers instead.”'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-12](ch18.xhtml#ch18list12) shows how we can rewrite our `Fraction`
    class to tell the compiler to generate a constructor and destructor for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction_dflt.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-12: The C++* Fraction *class specifying the default constructor
    and destructor*'
  prefs: []
  type: TYPE_NORMAL
- en: The C++11 standard published in September 2011 added *explicitly defaulted functions*,
    which are specified with the `= default` notation ❶. The standard says that the
    compiler must generate the function body and place it inline if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the recommendation of the C++ Core Guidelines, I’ve used *in-class
    member initializers* in [Listing 18-12](ch18.xhtml#ch18list12) to specify the
    initialization values for the data members ❷. The initial value for the data member
    is specified in curly brackets, `{}`; an empty set of curly brackets tells the
    compiler to use `0`. C++ also allows the following syntaxes, using an equal sign
    for data member initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I like the plain curly brackets initialization syntax because it conveys the
    message that the actual assignment to the variable doesn’t take place until an
    object is instantiated, as you’ll see shortly. The differences are covered in
    Josh Lospinoso’s book, cited at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have told the compiler to create a default constructor and destructor,
    we can eliminate these functions from our member function definition file, as
    shown in [Listing 18-13](ch18.xhtml#ch18list13).
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction_dflt.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-13: The C++* Fraction *class with a compiler-generated constructor
    and destructor*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-14](ch18.xhtml#ch18list14) shows the `main` function for this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fraction_dflt.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-14: A program to add 1 to a fraction*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same `main` function as in [Listing 18-3](ch18.xhtml#ch18list3),
    except that we’re using the *fraction_dflt.h* header file from [Listing 18-12](ch18.xhtml#ch18list12)
    to match the member function definitions in [Listing 18-13](ch18.xhtml#ch18list13)
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: This header file tells the compiler that it needs to write the constructor and
    destructor for us, as shown in [Listing 18-15](ch18.xhtml#ch18list15).
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fraction_dflt.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-15: The compiler-generated assembly language from [Listing 18-14](ch18.xhtml#ch18list14),
    showing the default constructor and destructor specified in [Listing 18-12](ch18.xhtml#ch18list12)*'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this with [Listing 18-4](ch18.xhtml#ch18list4), you can see that the
    compiler has allocated 16 fewer bytes in the stack frame for the `Fraction` object
    than when we provided a constructor member function ❶. It then places the initialization
    of the data members inline instead of calling a function to do it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The default constructor takes no arguments, but we might want to pass some arguments
    to a constructor at the point of instantiating an object. C++ allows us to have
    multiple constructors, as long as their parameter lists differ. You’ll see how
    this works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overloading the Default Constructor in C++**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Function overloading* is when two or more functions in a class have the same
    name but differ in their parameter list or return type. To demonstrate, we’ll
    overload our default constructor, which takes no arguments, with one that takes
    a single `int` argument that allows us to specify the value of the numerator when
    instantiating a `Fraction` object. [Listing 18-16](ch18.xhtml#ch18list16) shows
    our new class.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction_2.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-16: Adding a second constructor to the* Fraction *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The second constructor differs from the default only in its parameter list ❶.
    We’re using the C++ syntax that tells the compiler how to use the parameter to
    initialize the `numerator` data member.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using weird in-class member initialization values to make it easier for
    you to see what the assembly language is doing to initialize our object ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify our `main` function to add another `Fraction` object that uses
    our overloaded constructor, as shown in [Listing 18-17](ch18.xhtml#ch18list17).
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fractions.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-17: A program to add 1 to two fractions that use different constructors*'
  prefs: []
  type: TYPE_NORMAL
- en: For the second `Fraction` object, we’re passing 78 to the constructor as the
    initial value `numerator` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-18](ch18.xhtml#ch18list18) shows how the compiler implements this
    second constructor in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: '*inc_fractions.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-18: The compiler-generated assembly language for the function in
    [Listing 18-17](ch18.xhtml#ch18list17)*'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler generates a separate function for our constructor, which takes
    an argument ❸. The compiler places this constructor in a special section, marked
    `comdat`, where it can be called from functions in other files that use this same
    constructor to instantiate a `Fraction` object ❶. The `.weak` assembler directive
    tells the compiler to generate this label only once in this file ❷. Although we’re
    passing an explicit integer to the constructor in our `main` function ❻, the separate
    function is more efficient if we’re instantiating several `Fraction` objects with
    variables whose values aren’t known until the program is running.
  prefs: []
  type: TYPE_NORMAL
- en: The argument passed to the `_ZN8FractionC2Ei` constructor is used to initialize
    the `numerator` attribute of our `Fraction` object ❹. Our default in-class value
    is used to initialize the `denominator` attribute ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler wrote this constructor for us, we only need to change `#include
    "fraction_dflt.h"` to `#include "fraction_2.h"` in the file that defines our other
    member functions, [Listing 18-13](ch18.xhtml#ch18list13). I won’t repeat that
    listing here.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t really make sense to write an object-oriented program in assembly
    language. We could invent a name decoration scheme for all our functions, but
    we would still be using the procedural programming paradigm to call them, not
    the object-oriented paradigm. However, there are situations in which we may wish
    to call functions written in assembly language. We’ll look at how to do this in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 18.1   Add another constructor to the C++ program in [Listings 18-1](ch18.xhtml#ch18list1),
    [18-3](ch18.xhtml#ch18list3), and [18-5](ch18.xhtml#ch18list5) that takes two
    integer arguments to initialize `Fraction`. Add an object that uses your second
    constructor. For example, `Fraction y(1,2);` would create the `Fraction` object
    initialized to `1/2`. Modify the `main` function to display this second `Fraction`
    object, get a new value for it, add an integer to the second object, and display
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: 18.2   Write a program in C++ that prompts the user to enter a numerator and
    a denominator and then instantiates a `Fraction` object using the user’s values.
    Display the new object, add 1 to it, and display the new state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling Assembly Language Functions in C++**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show you how to call assembly language functions in C++, I’ll change our
    `Fraction` member functions to use our assembly language functions `write_str`,
    `write_char`, `put_int`, and `get_int` for writing to the screen and reading from
    the keyboard. [Listing 18-19](ch18.xhtml#ch18list19) shows the changes we need
    to make in the definitions of our member functions.
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction_asm.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-19: Calling assembly language functions in the* Fraction *class*'
  prefs: []
  type: TYPE_NORMAL
- en: The `extern "C"` tells the C++ compiler that the items in these header files
    have C linkage, so the compiler doesn’t decorate their names ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-20](ch18.xhtml#ch18list20) shows how this affects the `get` member
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction_asm.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-20: The compiler-generated assembly language for* get *in [Listing
    18-19](ch18.xhtml#ch18list19)*'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language functions are called by the names we’ve given them, without
    any decoration ❶. If you use `g++` to generate the assembly language for the `display`
    member function, you’ll see similar results for the `put_int` and `write_char`
    function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Class** The declaration of the data members that define the state of an object,
    along with any member functions used to access these data members.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects in C++** A named area of memory that contains the data members declared
    in a class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods or member functions** The member functions declared in a class can
    be called to access the state of an object of the same class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name decoration** The compiler creates member function names that include
    the function name, the class it belongs to, and the number and types of any arguments
    to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor** A member function used to initialize an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destructor** A member function used to clean up resources that are no longer
    needed.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has been a brief introduction to the way C++ implements basic object-oriented
    programming features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned several techniques for organizing data in programs,
    I’ll turn back to how data is stored in binary. So far in this book, I’ve used
    only integral values in our programs. In the next chapter, you’ll see how fractional
    values are represented in memory and learn about some of the CPU instructions
    to manipulate them.
  prefs: []
  type: TYPE_NORMAL
