- en: '**18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18'
- en: OBJECT-ORIENTED PROGRAMMING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: So far in this book, I have been using the procedural programming paradigm (described
    in “Exploring Data Formats with C” on [page 23](ch02.xhtml#ch02lev1sec4)). In
    this chapter, I’ll introduce how object-oriented programming is implemented at
    the assembly language level in C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我一直使用过程化编程范式（在《用 C 探索数据格式》一章中描述，见[第 23 页](ch02.xhtml#ch02lev1sec4)）。在这一章中，我将介绍如何在
    C++ 中以汇编语言级别实现面向对象编程。
- en: In object-oriented programming, we can create *objects*, each of which is an
    instance of a class. A class has a set of *attributes*, the data items that define
    the state of the object, and *methods* that can query or change the attributes
    of an object of the class. A software solution typically consists of constructing
    objects and then programming the sending of messages to the objects, which use
    the methods to act on the attributes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们可以创建*对象*，每个对象都是某个类的实例。类具有一组*属性*，即定义对象状态的数据项，以及*方法*，可以查询或改变类对象的属性。软件解决方案通常包括构造对象，然后编程向对象发送消息，对象使用方法作用于其属性。
- en: I’ll use C++, an object-oriented extension of C, to illustrate some of these
    concepts. You’ll learn how a record can be used to store the attributes of an
    object and how methods are implemented as functions associated with the record.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 C++，一种 C 语言的面向对象扩展，来说明这些概念。你将学习如何使用记录来存储对象的属性，以及如何将方法实现为与记录关联的函数。
- en: Many other features of C++ are important for creating good object-oriented programming
    solutions, but I won’t go into them in this book. If you’re new to C++, Josh Lospinoso’s
    *C++ Crash Course* (No Starch Press, 2019) would be a good place to start. If
    you want to dig into the design of C++ after learning how to use it, I recommend
    *A Tour of C++*, 3rd edition, by Bjarne Stroustrup, the creator of C++ (Addison-Wesley
    Professional, 2022). A good online resource for using C++ is the C++ Core Guidelines
    at *[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)*.
    It’s kept up to date by Bjarne Stroustrup and Herb Sutter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的许多其他特性对于创建良好的面向对象编程解决方案也非常重要，但我在本书中不会详细讨论。如果你是 C++ 新手，Josh Lospinoso 的《C++
    快速入门》（No Starch Press，2019）是一个不错的起点。如果你想在学习如何使用 C++ 后深入了解其设计，推荐 Bjarne Stroustrup（C++
    的创造者）所著的《C++ 之旅》第三版（Addison-Wesley Professional，2022）。另一个很好的在线资源是 C++ 核心准则，网址是*[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)*，该准则由
    Bjarne Stroustrup 和 Herb Sutter 定期更新。
- en: Let’s start with a very simple C++ class and then look at some assembly language
    generated by the C++ compiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的 C++ 类开始，然后查看 C++ 编译器生成的汇编语言代码。
- en: '**Objects in C++**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C++ 中的对象**'
- en: C++ allows us to create *classes*, which are like blueprints for creating objects.
    A C++ class is very much like a C record, but in addition to the *data members*
    that define the attributes of the object, it can include functions as members
    of the class. In C++, we send a message to an object telling it to perform a method
    by calling a class *member function*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许我们创建*类*，它们就像创建对象的蓝图。C++ 类非常像 C 语言中的记录，但除了定义对象属性的*数据成员*外，还可以包含作为类成员的函数。在
    C++ 中，我们通过调用类的*成员函数*，向对象发送消息，指示它执行某个方法。
- en: 'C++ specifies six special member functions that are used to create and delete
    objects. I’ll only cover the two most commonly used ones in this book: the constructor
    and the destructor. The *constructor* function is used to create an instance of
    an object, which is called *instantiation*. The job of a constructor is to allocate
    the necessary memory resources and place the object in a known state before sending
    messages to it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 指定了六个特殊成员函数，用于创建和删除对象。在本书中，我将只介绍最常用的两个：构造函数和析构函数。*构造函数*用于创建对象的实例，这个过程称为*实例化*。构造函数的工作是分配必要的内存资源，并在向对象发送消息之前将其置于已知的状态。
- en: The C++ compiler generates the code to call our constructor function automatically
    at the point where we instantiate an object. A constructor function has the same
    name as the class. It cannot have a return value—not even `void`. The *default
    constructor* does not take any arguments. We can also write constructors that
    take arguments, and a class can have more than one constructor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器会在我们实例化对象的地方自动生成代码来调用构造函数。构造函数的名称与类相同，不能有返回值——甚至不能是 `void`。*默认构造函数* 不接受任何参数。我们也可以编写接受参数的构造函数，一个类可以有多个构造函数。
- en: The job of a *destructor* function is to release any resources that were allocated
    by a constructor, thus deleting the object. For example, a constructor might allocate
    memory from the heap (described in [Chapter 10](ch10.xhtml)), which the destructor
    would deallocate. There can be only one destructor function, which has the same
    name as the class, preceded by the `~` (tilde) character. The destructor cannot
    have a return value and takes no arguments. The C++ compiler will generate the
    code to call the destructor automatically when program flow leaves the scope of
    the object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*destructor* 函数的作用是释放构造函数分配的资源，从而删除对象。例如，构造函数可能会从堆上分配内存（在 [第 10 章](ch10.xhtml)
    中描述），而析构函数则负责释放这块内存。每个类只能有一个析构函数，它的名字与类相同，并以 `~`（波浪号）字符开头。析构函数不能有返回值，并且不接受任何参数。当程序流离开对象的作用域时，C++
    编译器会自动生成代码来调用析构函数。'
- en: 'To demonstrate these concepts, we’ll look at a simple `Fraction` class whose
    attributes are two `int`s: a `numerator` and a `denominator`. We’ll include a
    constructor, a destructor, and some member functions to work with our `Fraction`
    objects. If we don’t supply constructor or destructor member functions, the C++
    compiler will supply appropriate code to perform the construction and destruction
    of an object; we’ll explore what this means in “Writing a Constructor and Destructor
    via the Compiler” on [page 399](ch18.xhtml#ch18lev1sec2).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些概念，我们将查看一个简单的 `Fraction` 类，它的属性是两个 `int`：`numerator` 和 `denominator`。我们将包括一个构造函数、一个析构函数以及一些用于处理
    `Fraction` 对象的成员函数。如果我们没有提供构造函数或析构函数，C++ 编译器将自动提供适当的代码来执行对象的构造和销毁；我们将在“通过编译器编写构造函数和析构函数”一节中探讨这是什么意思，见
    [第 399 页](ch18.xhtml#ch18lev1sec2)。
- en: We’ll start with the declaration of our `Fraction` class, which we’ll place
    in a header file so it can be included in any file that uses the class, as shown
    in [Listing 18-1](ch18.xhtml#ch18list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `Fraction` 类的声明开始，将其放入头文件中，以便在任何使用该类的文件中都可以包含它，如 [清单 18-1](ch18.xhtml#ch18list1)
    所示。
- en: '*fraction.h*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.h*'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 18-1: The C++* Fraction *class*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-1：C++* 分数 *类*'
- en: The overall syntax of a `class` declaration is similar to a record declaration
    in C, but it adds the capability to include the methods of the class as member
    functions. Access to members of a class can be *private*, *protected*, or *public*.
    We’ll look only at basic public and private access control here and leave the
    more complex access control concepts to books on C++.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 声明的整体语法类似于 C 语言中的记录声明，但它增加了将类的方法作为成员函数包含进来的功能。对类成员的访问可以是*私有的*、*受保护的*或*公开的*。我们这里只讨论基本的公开和私有访问控制，复杂的访问控制概念留给
    C++ 书籍去讨论。'
- en: We declare the member functions to be `public` ❶. This means they can be used
    from outside the class to send messages to objects of this class. They provide
    an interface to the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将成员函数声明为 `public` ❶。这意味着它们可以从类外部使用，用来向该类的对象发送消息。它们提供了与对象的接口。
- en: We place the data members in the `private` part of the `class` declaration ❷.
    This means only member functions can access them directly, thus giving the member
    functions control over `numerator` and `denominator`, the attributes of our `Fraction`
    class. Code outside this class can access them only through the public interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据成员放在 `class` 声明的 `private` 部分 ❷。这意味着只有成员函数可以直接访问它们，从而让成员函数控制 `numerator`
    和 `denominator`，即 `Fraction` 类的属性。类外的代码只能通过公共接口访问它们。
- en: Access to a `class` is private by default. If we listed the attributes before
    the `public` area, we wouldn’t need to use the `private` keyword, but I like to
    list the public interface of a `class` first.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`class` 的访问权限是私有的。如果我们将属性列在 `public` 区域之前，则无需使用 `private` 关键字，但我喜欢先列出
    `class` 的公共接口。
- en: The `struct` keyword can also be used to declare a C++ class, as shown in [Listing
    18-2](ch18.xhtml#ch18list2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `struct` 关键字来声明 C++ 类，如 [清单 18-2](ch18.xhtml#ch18list2) 所示。
- en: '*fraction.h*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.h*'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 18-2: The C++* Fraction struct'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-2：C++* Fraction 结构'
- en: The default access scope for a C++ `struct` is public, but I like to be explicit.
    The `private` declaration is required for the private scope.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中 `struct` 的默认访问范围是 public，但我喜欢明确声明。`private` 声明是私有作用域所必需的。
- en: Although `class` and `struct` are the same except for the default access scope,
    I prefer using the `class` keyword because it emphasizes that there is more to
    it than a simple record. However, this is a personal choice. Next, we’ll look
    at how to create objects and how to send messages to them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `class` 和 `struct` 除了默认的访问范围不同外是相同的，但我更喜欢使用 `class` 关键字，因为它强调了它不仅仅是一个简单的记录。然而，这只是个人的选择。接下来，我们将看看如何创建对象以及如何向对象发送消息。
- en: '***Creating an Object***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建一个对象***'
- en: I’ll illustrate how to create an object and send messages to it using a simple
    program that allows the user to enter the numerator and denominator values of
    a fraction and then adds 1 to the fraction. This program is shown in [Listing
    18-3](ch18.xhtml#ch18list3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过一个简单的程序来说明如何创建对象并向其发送消息，该程序允许用户输入分数的分子和分母值，然后将 1 加到分数上。这个程序在[清单 18-3](ch18.xhtml#ch18list3)中展示。
- en: '*inc_fraction.cpp*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fraction.cpp*'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 18-3: A program to add 1 to a fraction*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-3：一个将 1 加到分数的程序*'
- en: We instantiate an object by using the class name and providing a name for the
    object ❶, just like when defining a variable. The dot operator (`.`) is used to
    send a message to a method in the class ❷, which calls the respective member function
    in the class the object belongs to. This program displays the state of the fraction
    before getting user input values and then again after adding 1 to the user’s fraction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用类名并为对象提供一个名称来实例化一个对象 ❶，就像定义变量一样。点操作符（`.`）用于向类中的方法发送消息 ❷，该方法调用对象所属类中的相应成员函数。该程序在获取用户输入值之前显示分数的状态，然后在将
    1 加到用户的分数后再次显示。
- en: Next, we’ll look at the assembly language generated by the C++ compiler to implement
    the `main` function in [Listing 18-3](ch18.xhtml#ch18list3). The C++ compiler
    in our environment is called `g++`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 C++ 编译器生成的汇编语言，用于实现[清单 18-3](ch18.xhtml#ch18list3)中的 `main` 函数。我们环境中的
    C++ 编译器叫做 `g++`。
- en: 'I used the following command to generate the assembly language in [Listing
    18-4](ch18.xhtml#ch18list4):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了以下命令来生成[清单 18-4](ch18.xhtml#ch18list4)中的汇编语言：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the same as the command we’ve been using for C code, except I’ve added
    the `-fno-exceptions` option. C++ provides an *exception* mechanism for dealing
    with detected runtime errors. The compiler provides the information for this feature
    through assembler directives, which would tend to obscure the discussion here
    of how objects are implemented. Using the `-fno-exceptions` option turns off this
    feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们一直用于 C 代码的命令相同，只不过我添加了 `-fno-exceptions` 选项。C++ 提供了一个*异常*机制来处理检测到的运行时错误。编译器通过汇编指令提供该功能的信息，这可能会使我们讨论对象实现的内容变得更加复杂。使用
    `-fno-exceptions` 选项将关闭此功能。
- en: '*inc_fraction.s*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fraction.s*'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 18-4: The compiler-generated assembly language for the* main *function
    in [Listing 18-3](ch18.xhtml#ch18list3)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-4：C++ 编译器生成的用于 main 函数的汇编语言，见[清单 18-3](ch18.xhtml#ch18list3)*'
- en: The first thing to note is that `my_fraction` (➊ in [Listing 18-3](ch18.xhtml#ch18list3))
    is an automatic local variable, so memory space is allocated on the stack for
    this `Fraction` object in the `main` function’s prologue ❶. The address of this
    memory area is passed to the constructor function, `_ZN8FractionC1Ev`, which will
    initialize the object ❷.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，`my_fraction`（见[清单 18-3](ch18.xhtml#ch18list3)中的➊）是一个自动局部变量，因此在 `main`
    函数的序言 ❶ 中为该 `Fraction` 对象分配了栈内存空间。该内存区域的地址被传递给构造函数 `_ZN8FractionC1Ev`，该函数将初始化该对象
    ❷。
- en: The C++ compiler has decorated the name of our constructor function `Fraction`,
    declared in [Listing 18-1](ch18.xhtml#ch18list1), to be `_ZN8FractionC1Ev` ❸.
    You learned about the C compiler decorating the names of static local variables
    in [Chapter 15](ch15.xhtml). The purpose there was to distinguish between different
    static local variables with the same name in different functions defined in the
    same file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器将我们在[清单 18-1](ch18.xhtml#ch18list1)中声明的构造函数 `Fraction` 的名称修饰为`_ZN8FractionC1Ev`
    ❸。你在[第 15 章](ch15.xhtml)中学到了 C 编译器如何修饰静态局部变量的名称。其目的是区分同一文件中不同函数中具有相同名称的静态局部变量。
- en: C++ uses name decorating to associate member functions with their class. Looking
    at the calls to the class member functions in [Listing 18-4](ch18.xhtml#ch18list4),
    you can see that they all begin with `_ZN8Fraction`. Since function names are
    global in scope, including the class name allows us to define other classes in
    the program that have the same names for member functions. For example, we might
    have more than one class in a program that has a `display` member function. Name
    decorating identifies each `display` member function with the class it belongs
    to ❹.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用名称修饰将成员函数与其类关联起来。查看[清单18-4](ch18.xhtml#ch18list4)中对类成员函数的调用，你会发现它们都以`_ZN8Fraction`开头。由于函数名是全局作用域的，包含类名可以让我们在程序中定义其他类，这些类的成员函数可能有相同的名称。例如，程序中可能有多个类都包含一个`display`成员函数。名称修饰通过类名来标识每个`display`成员函数所属的类❹。
- en: C++ name decorating also allows *function overloading*, which is the ability
    to have more than one class member function with the same name but that differ
    in the number of arguments and their types. In [Listing 18-4](ch18.xhtml#ch18list4),
    the decorated `_ZN8Fraction11add_integerEi`, which is our `add_integer` member
    function, ends with an appended `i`; this shows that the function takes a single
    `int` argument ❺. Including the number and types of the arguments in the name
    decorating differentiates overloaded functions. You’ll get a chance to overload
    the default constructor in “Your Turn” [exercise 18.1](ch18.xhtml#ch18exe1) on
    [page 406](ch18.xhtml#ch18you1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C++名称修饰还允许*函数重载*，即拥有多个名称相同但参数数量和类型不同的类成员函数。在[清单18-4](ch18.xhtml#ch18list4)中，修饰后的`_ZN8Fraction11add_integerEi`，就是我们的`add_integer`成员函数，最后有一个附加的`i`；这表示该函数接受一个`int`类型的单一参数❺。通过在名称修饰中包含参数的数量和类型，可以区分重载函数。在“你的任务”[练习18.1](ch18.xhtml#ch18exe1)中，你将有机会重载默认构造函数，[页面406](ch18.xhtml#ch18you1)中有详细介绍。
- en: There is no standard for how name decorating is done, so each compiler may do
    it differently. This means that all C++ code in a program must be compiled and
    linked using compatible compilers and linkers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 名称修饰的标准并不统一，因此每个编译器可能会有不同的做法。这意味着程序中的所有C++代码必须使用兼容的编译器和链接器进行编译和链接。
- en: Look at the instruction just before each call to a member function ❷. The address
    of the object is passed as the first argument to each of them. This is an *implicit
    argument* that doesn’t show up in the C++ code. You’ll see how to access this
    address in a member function when we look inside the member functions in the following
    section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下每个成员函数调用之前的指令❷。对象的地址作为第一个参数传递给每个成员函数。这是一个*隐式参数*，在C++代码中不会显示。在接下来的章节中，当我们查看成员函数内部时，你将看到如何访问这个地址。
- en: Although it doesn’t show in the C++ code that we write, the compiler generates
    a call to our destructor function at the point where program flow leaves the scope
    of the object ❻. In some more advanced programming techniques, we would call the
    destructor explicitly, but we won’t cover them in the book. Most of the time,
    we let the compiler decide when to call the destructor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们编写的C++代码中没有显示，但编译器会在程序流程离开对象的作用域时生成对析构函数的调用❻。在一些更高级的编程技术中，我们会显式调用析构函数，但书中不涉及这些内容。大多数时候，我们让编译器决定何时调用析构函数。
- en: Next, we’ll look at the constructor and destructor and the other member functions
    of this `Fraction` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看这个`Fraction`类的构造函数、析构函数和其他成员函数。
- en: '***Defining Class Member Functions***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义类成员函数***'
- en: Although it’s common to put each C function definition in its own file, C++
    source files are commonly organized to include all the function definitions in
    a class. [Listing 18-5](ch18.xhtml#ch18list5) shows the definitions of the member
    functions for our `Fraction` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常将每个C函数定义放在自己的文件中，但C++源文件通常会组织成将所有函数定义包含在一个类中。[清单18-5](ch18.xhtml#ch18list5)显示了我们`Fraction`类的成员函数定义。
- en: '*fraction.cpp*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.cpp*'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 18-5: The member function definitions for our* Fraction *class*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-5：我们`Fraction`类的成员函数定义*'
- en: C++ adds some scoping rules to the C scoping rules you learned about in [Chapter
    14](ch14.xhtml). Even though the member functions declared in [Listing 18-1](ch18.xhtml#ch18list1)
    are public, they have *class scope*, meaning their names need to be associated
    with the class. The compiler does this by decorating the names when it uses them,
    but we need to use the *scope resolution operator* (`::`) to make this association
    when defining the member functions outside the class scope ❷.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C++在你在[第14章](ch14.xhtml)中学到的C语言作用域规则上添加了一些作用域规则。尽管在[清单 18-1](ch18.xhtml#ch18list1)中声明的成员函数是公有的，但它们具有*类作用域*，这意味着它们的名称需要与类相关联。编译器通过装饰名称来实现这一点，但在类作用域外定义成员函数时，我们需要使用*作用域解析运算符*（`::`）来建立这种关联❷。
- en: One of the primary purposes of a constructor is to initialize the object. We’ll
    set our `Fraction` object to `0/1` ❸, a reasonable initial value for a fraction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的主要目的是初始化对象。我们将把`Fraction`对象设置为`0/1`❸，这是一个合理的初始值。
- en: The C++ standard library provides objects for writing to the screen and reading
    from the keyboard. The `cout` object in the `ostream` class writes a character
    stream to standard output, which is typically connected to the screen ❹. It uses
    the *insertion operator* (`<<`) and converts the data to the appropriate character
    string. The `cin` object in the `istream` class reads a character stream from
    standard input, which is typically connected to the keyboard ❺. It uses the *extraction
    operator* (`>>`) and converts the character string to the appropriate data type
    for the variable it’s reading into.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了用于向屏幕写入和从键盘读取的对象。`ostream`类中的`cout`对象将字符流写入标准输出，通常连接到屏幕❹。它使用*插入运算符*（`<<`）并将数据转换为适当的字符字符串。`istream`类中的`cin`对象从标准输入读取字符流，通常连接到键盘❺。它使用*提取运算符*（`>>`）并将字符字符串转换为适合其读取的变量的数据类型。
- en: In addition to its class scope, C++ allows us to collect names of things into
    a *namespace scope*. The `iostream` header file places the `cout` and `cin` objects
    in the `std` namespace. We need to specify this namespace when using these objects
    ❶.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类作用域外，C++还允许我们将事物的名称收集到*命名空间作用域*中。`iostream`头文件将`cout`和`cin`对象放置在`std`命名空间中。我们需要在使用这些对象时指定该命名空间❶。
- en: Next, we’ll look at the compiler-generated assembly language for these member
    functions. To simplify the discussion, we’ll look at each function in the file
    separately, in [Listings 18-6](ch18.xhtml#ch18list6) through [18-11](ch18.xhtml#ch18list11).
    As we go through them, keep in mind that this is one file, so the labels are visible
    across all six of the listings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看这些成员函数的编译器生成的汇编语言。为了简化讨论，我们将分别查看文件中的每个函数，参见[清单 18-6](ch18.xhtml#ch18list6)到[清单
    18-11](ch18.xhtml#ch18list11)。在查看这些内容时，请记住这是一个文件，因此标签在所有六个清单中都是可见的。
- en: The beginning of the *fraction.s* file, shown in [Listing 18-6](ch18.xhtml#ch18list6),
    is code that allocates memory used by functions in the C++ I/O library for the
    `cin` and `cout` I/O objects. Our inclusion of the `iostream` header file in [Listing
    18-5](ch18.xhtml#ch18list5) tells the compiler to insert this code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s*文件的开始部分，展示在[清单 18-6](ch18.xhtml#ch18list6)中，是为C++ I/O库中的`cin`和`cout`
    I/O对象分配内存的代码。我们在[清单 18-5](ch18.xhtml#ch18list5)中包含`iostream`头文件，告诉编译器插入这段代码。'
- en: '*fraction.s(a)*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(a)*'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 18-6: A byte used by the* cin *and* cout *I/O objects*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-6：`cin`和`cout` I/O对象使用的字节*'
- en: The `.local` assembler directive limits the `_ZStL8__ioinit` label to this object
    ❶. The `.comm` directive allocates 1 byte in memory, which is aligned to an 8-byte
    address and labeled `_ZStL8__ioinit` ❷. If there are other `.comm` directives
    with the same label in our program, they will share the same memory. This memory
    is for use by the `cin` and `cout` I/O objects; the details of its usage are beyond
    the scope of this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`.local`汇编指令将`_ZStL8__ioinit`标签限制在此对象内❶。`.comm`指令在内存中分配1个字节，并将其对齐到8字节地址，并标记为`_ZStL8__ioinit`❷。如果程序中有其他`.comm`指令使用相同的标签，它们将共享相同的内存。这段内存供`cin`和`cout`
    I/O对象使用；它的具体用法超出了本书的范围。'
- en: '[Listing 18-7](ch18.xhtml#ch18list7) shows the second part of the file, the
    constructor for our `Fraction` object.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-7](ch18.xhtml#ch18list7)展示了文件的第二部分，即我们`Fraction`对象的构造函数。'
- en: '*fraction.s(b)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(b)*'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 18-7: The compiler-generated assembly language for the constructor
    in [Listing 18-5](ch18.xhtml#ch18list5)*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-7：编译器生成的构造函数汇编语言，见[清单 18-5](ch18.xhtml#ch18list5)*'
- en: Our constructor initializes the `numerator` ❷ and `denominator` ❸ data members
    in the `Fraction` object located in our stack frame. Back in [Listing 18-4](ch18.xhtml#ch18list4),
    you saw that the first argument to each member function is the address of the
    object that the member function is operating on. But looking at the class declaration
    in [Listing 18-1](ch18.xhtml#ch18list1), this address doesn’t show up in the member
    function’s parameter list. It’s called the *hidden parameter*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数初始化了位于栈帧中的 `Fraction` 对象的 `numerator` ❷ 和 `denominator` ❸ 数据成员。回到[列表
    18-4](ch18.xhtml#ch18list4)，你会看到每个成员函数的第一个参数是正在操作的对象的地址。但是查看[列表 18-1](ch18.xhtml#ch18list1)中的类声明时，你会发现该地址没有出现在成员函数的参数列表中。它被称为
    *隐藏参数*。
- en: If a member function is accessing another object in the same class as the object
    it was called from, it needs to be able to distinguish between the two objects.
    Although it doesn’t show up in the parameter list, C++ uses the name `this` for
    the hidden parameter, which is a pointer variable that contains the address of
    the object that called the member function ❶.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个成员函数访问的是与调用它的对象属于同一类的另一个对象，它需要能够区分这两个对象。尽管它没有出现在参数列表中，C++ 使用 `this` 作为隐藏参数的名称，这是一个指针变量，包含了调用成员函数的对象的地址
    ❶。
- en: 'The compiler assumes that our member functions are working with the object
    at the address in the `this` pointer variable, so we usually don’t need to use
    it. But some situations require that we explicitly use the pointer. For example,
    we might write a `Fraction` constructor that allows us to specify the initialization
    values like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器假设我们的成员函数正在处理 `this` 指针变量中地址所指向的对象，因此我们通常不需要显式使用它。但某些情况要求我们显式地使用该指针。例如，我们可能会编写一个
    `Fraction` 构造函数，允许我们像这样指定初始化值：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The parameter names have precedence over the member names, so we had to disambiguate
    with the `this` pointer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称优先于成员名称，因此我们必须通过 `this` 指针来消除歧义。
- en: Now that you know where the `Fraction` object’s data members are located within
    the object, you can see in [Figure 18-1](ch18.xhtml#ch18fig1) how the object is
    stored in `main`’s stack frame.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道 `Fraction` 对象的数据成员在对象中的位置后，你可以在[图 18-1](ch18.xhtml#ch18fig1)中看到该对象是如何存储在
    `main` 的栈帧中的。
- en: '![Image](../images/pg424_Image_290.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg424_Image_290.jpg)'
- en: '*Figure 18-1: The* my_fraction *object in* main*’s stack frame*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-1：* my_fraction *对象在* main *的栈帧中*'
- en: I don’t know why the compiler included 16 bytes in this stack frame that are
    not used in the program.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么编译器在这个栈帧中包含了 16 字节的空间，但程序中并没有使用这些空间。
- en: The constructor is followed by the destructor, shown in [Listing 18-8](ch18.xhtml#ch18list8).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数后面是析构函数，如[列表 18-8](ch18.xhtml#ch18list8)所示。
- en: '*fraction.s(c)*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(c)*'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 18-8: The compiler-generated assembly language for the destructor
    in [Listing 18-5](ch18.xhtml#ch18list5)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-8：在 [列表 18-5](ch18.xhtml#ch18list5) 中析构函数的编译器生成的汇编语言*'
- en: There is nothing for the destructor to do in this simple class. Earlier, in
    [Listing 18-4](ch18.xhtml#ch18list4), you saw that the memory for the object was
    allocated in the stack frame by the `main` function’s prologue, not by the constructor.
    Similarly, the object’s memory is deleted from the stack in `main`’s epilogue
    code, after the call to the destructor. Some constructors allocate memory from
    the heap, in which case the destructor should release that memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类中，析构函数没有任何操作。之前在[列表 18-4](ch18.xhtml#ch18list4)中，你看到对象的内存是由 `main` 函数的序言分配到栈帧中的，而不是由构造函数分配的。同样，对象的内存会在
    `main` 的尾声代码中，在调用析构函数后从栈中删除。一些构造函数从堆中分配内存，在这种情况下，析构函数应该释放这些内存。
- en: The assembly language for the destructor is followed by that for the member
    functions. [Listing 18-9](ch18.xhtml#ch18list9) shows the assembly language for
    the `get` member function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数的汇编语言后面是成员函数的汇编语言。[列表 18-9](ch18.xhtml#ch18list9) 显示了 `get` 成员函数的汇编语言。
- en: '*fraction.s(d)*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(d)*'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 18-9: The compiler-generated assembly language for* get *in [Listing
    18-5](ch18.xhtml#ch18list5)*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-9：在 [列表 18-5](ch18.xhtml#ch18list5) 中的 get 函数的编译器生成的汇编语言*'
- en: When the program is loaded into memory, the location of the `cout` object is
    loaded into our global offset table (GOT) ❶. The location of the `cin` object
    is also loaded into our GOT ❷.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序加载到内存中时，`cout` 对象的位置会被加载到我们的全局偏移表 (GOT) ❶ 中。`cin` 对象的位置也会被加载到我们的 GOT ❷ 中。
- en: Next, we’ll look at the `display` member function, shown in [Listing 18-10](ch18.xhtml#ch18list10).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 `display` 成员函数，如[列表 18-10](ch18.xhtml#ch18list10)所示。
- en: '*fraction.s(e)*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(e)*'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 18-10: The compiler-generated assembly language for* display *in [Listing
    18-5](ch18.xhtml#ch18list5)*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-10：在[清单 18-5](ch18.xhtml#ch18list5)中显示的编译器生成的汇编语言*'
- en: In our C++ code (see [Listing 18-5](ch18.xhtml#ch18list5)), we chain insertions
    to the `cout` object. The compiler matches the data item type with the `ostream`
    class member function it calls. The first value is an `int` ❶, the second a `char`
    ❷, and so forth.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的C++代码中（见[清单 18-5](ch18.xhtml#ch18list5)），我们将插入操作链式调用到`cout`对象上。编译器将数据项类型与它所调用的`ostream`类成员函数匹配。第一个值是`int`
    ❶，第二个是`char` ❷，依此类推。
- en: '[Listing 18-11](ch18.xhtml#ch18list11) shows the compiler-generated assembly
    language for the `add_integer` member function.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-11](ch18.xhtml#ch18list11)展示了编译器为`add_integer`成员函数生成的汇编语言。'
- en: '*fraction.s(f)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction.s(f)*'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 18-11: The compiler-generated assembly language for* add_integer *in
    [Listing 18-5](ch18.xhtml#ch18list5)*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-11：在[清单 18-5](ch18.xhtml#ch18list5)中显示的add_integer编译器生成的汇编语言*'
- en: The `this` pointer variable is created in this function’s stack frame ❶. This
    is a leaf function, so the compiler doesn’t generate a frame record in the stack
    frame.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`指针变量在该函数的栈帧中创建 ❶。这是一个叶子函数，因此编译器不会在栈帧中生成帧记录。'
- en: If you use the `g++` compiler to generate the assembly language yourself, you’ll
    see two other functions, `_Z41__static_initialization_and_destruction_0ii` and
    `_GLOBAL__sub_I__ZN8FractionC2Ev`. The operating system calls these functions
    when the program is loaded to set up the `cout` and `cin` I/O streams. The details
    are beyond the scope of this book, so I won’t show them here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`g++`编译器生成汇编语言，你将看到另外两个函数，`_Z41__static_initialization_and_destruction_0ii`和`_GLOBAL__sub_I__ZN8FractionC2Ev`。操作系统在程序加载时调用这些函数，以设置`cout`和`cin`输入输出流。具体细节超出了本书的范围，因此我不会在这里展示它们。
- en: The purpose of a constructor is to allocate any system resources an object needs
    and to initialize the object. The destructor then releases the resources allocated
    by the constructor. In the next section, you’ll see that the compiler can automatically
    generate a constructor and a destructor for simple objects such as in our `Fraction`
    class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的目的是分配对象所需的系统资源并初始化对象。析构函数则释放构造函数分配的资源。在下一节中，你将看到编译器可以为像我们`Fraction`类这样简单的对象自动生成构造函数和析构函数。
- en: '**Writing a Constructor and Destructor via the Compiler**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过编译器编写构造函数和析构函数**'
- en: Initialization of objects in C++ is complex, because there are many ways to
    do it. The previous section covered the most basic way. Now, I’ll show you some
    simple C++ syntax that tells the compiler to figure out how to do the initialization
    itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，对象的初始化是复杂的，因为有许多种方式可以实现。上一节介绍了最基本的方式。现在，我将向你展示一些简单的C++语法，它告诉编译器自己处理初始化的方式。
- en: 'Recommendation C.45 in the C++ Core Guidelines (see *[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default)*
    states: “Don’t define a default constructor that only initializes data members;
    use in-class member initializers instead.”'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南中的建议C.45（见* [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default)
    *）指出：“不要定义仅初始化数据成员的默认构造函数；请改为使用类内成员初始化器。”
- en: '[Listing 18-12](ch18.xhtml#ch18list12) shows how we can rewrite our `Fraction`
    class to tell the compiler to generate a constructor and destructor for us.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-12](ch18.xhtml#ch18list12)展示了我们如何重写`Fraction`类，告诉编译器为我们生成构造函数和析构函数。'
- en: '*fraction_dflt.h*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction_dflt.h*'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 18-12: The C++* Fraction *class specifying the default constructor
    and destructor*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-12：C++* Fraction *类指定默认构造函数和析构函数*'
- en: The C++11 standard published in September 2011 added *explicitly defaulted functions*,
    which are specified with the `= default` notation ❶. The standard says that the
    compiler must generate the function body and place it inline if possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年9月发布的C++11标准新增了*显式默认函数*，这些函数通过`= default`符号来指定 ❶。标准规定，编译器必须生成函数体并尽可能将其内联。
- en: 'Following the recommendation of the C++ Core Guidelines, I’ve used *in-class
    member initializers* in [Listing 18-12](ch18.xhtml#ch18list12) to specify the
    initialization values for the data members ❷. The initial value for the data member
    is specified in curly brackets, `{}`; an empty set of curly brackets tells the
    compiler to use `0`. C++ also allows the following syntaxes, using an equal sign
    for data member initialization:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 C++ 核心准则的建议，我在[清单 18-12](ch18.xhtml#ch18list12)中使用了*类内成员初始化器*来指定数据成员的初始化值❷。数据成员的初始值通过大括号
    `{}` 来指定；一个空的大括号表示编译器使用 `0`。C++ 还允许以下语法，使用等号进行数据成员初始化：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I like the plain curly brackets initialization syntax because it conveys the
    message that the actual assignment to the variable doesn’t take place until an
    object is instantiated, as you’ll see shortly. The differences are covered in
    Josh Lospinoso’s book, cited at the beginning of this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用简单的大括号初始化语法，因为它传达了一个信息，即变量的实际赋值直到对象实例化时才会发生，正如你将很快看到的那样。有关这些差异的讨论，请参阅本章开始时引用的
    Josh Lospinoso 的书。
- en: Since we have told the compiler to create a default constructor and destructor,
    we can eliminate these functions from our member function definition file, as
    shown in [Listing 18-13](ch18.xhtml#ch18list13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经告诉编译器创建默认构造函数和析构函数，因此可以从我们的成员函数定义文件中删除这些函数，如[清单 18-13](ch18.xhtml#ch18list13)所示。
- en: '*fraction_dflt.cpp*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction_dflt.cpp*'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 18-13: The C++* Fraction *class with a compiler-generated constructor
    and destructor*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-13：带有编译器生成构造函数和析构函数的 C++* Fraction *类*'
- en: '[Listing 18-14](ch18.xhtml#ch18list14) shows the `main` function for this program.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-14](ch18.xhtml#ch18list14)展示了此程序的 `main` 函数。'
- en: '*inc_fraction_dflt.cpp*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fraction_dflt.cpp*'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 18-14: A program to add 1 to a fraction*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-14：一个将 1 加到分数中的程序*'
- en: This is the same `main` function as in [Listing 18-3](ch18.xhtml#ch18list3),
    except that we’re using the *fraction_dflt.h* header file from [Listing 18-12](ch18.xhtml#ch18list12)
    to match the member function definitions in [Listing 18-13](ch18.xhtml#ch18list13)
    ❶.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与[清单 18-3](ch18.xhtml#ch18list3)中的 `main` 函数相同，唯一不同的是我们使用了来自[清单 18-12](ch18.xhtml#ch18list12)的*fraction_dflt.h*头文件，以匹配[清单
    18-13](ch18.xhtml#ch18list13)中的成员函数定义❶。
- en: This header file tells the compiler that it needs to write the constructor and
    destructor for us, as shown in [Listing 18-15](ch18.xhtml#ch18list15).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件告诉编译器需要为我们编写构造函数和析构函数，如[清单 18-15](ch18.xhtml#ch18list15)所示。
- en: '*inc_fraction_dflt.s*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fraction_dflt.s*'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 18-15: The compiler-generated assembly language from [Listing 18-14](ch18.xhtml#ch18list14),
    showing the default constructor and destructor specified in [Listing 18-12](ch18.xhtml#ch18list12)*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-15：由[清单 18-14](ch18.xhtml#ch18list14)生成的编译器汇编语言，显示了在[清单 18-12](ch18.xhtml#ch18list12)中指定的默认构造函数和析构函数*'
- en: Comparing this with [Listing 18-4](ch18.xhtml#ch18list4), you can see that the
    compiler has allocated 16 fewer bytes in the stack frame for the `Fraction` object
    than when we provided a constructor member function ❶. It then places the initialization
    of the data members inline instead of calling a function to do it ❷.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与[清单 18-4](ch18.xhtml#ch18list4)进行比较，你可以看到编译器为 `Fraction` 对象分配的栈帧比我们提供构造函数成员函数时少了
    16 个字节❶。它随后将数据成员的初始化内联，而不是调用函数来进行初始化❷。
- en: The default constructor takes no arguments, but we might want to pass some arguments
    to a constructor at the point of instantiating an object. C++ allows us to have
    multiple constructors, as long as their parameter lists differ. You’ll see how
    this works in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数不接受任何参数，但我们可能希望在实例化对象时向构造函数传递一些参数。C++ 允许我们拥有多个构造函数，只要它们的参数列表不同。你将在下一节看到这如何运作。
- en: '**Overloading the Default Constructor in C++**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 C++ 中重载默认构造函数**'
- en: '*Function overloading* is when two or more functions in a class have the same
    name but differ in their parameter list or return type. To demonstrate, we’ll
    overload our default constructor, which takes no arguments, with one that takes
    a single `int` argument that allows us to specify the value of the numerator when
    instantiating a `Fraction` object. [Listing 18-16](ch18.xhtml#ch18list16) shows
    our new class.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数重载*是指类中的两个或多个函数具有相同的名称，但参数列表或返回类型不同。为了演示，我们将重载我们的默认构造函数，该构造函数不接受任何参数，使用一个接受单个
    `int` 参数的构造函数，这样我们就可以在实例化 `Fraction` 对象时指定分子值。[清单 18-16](ch18.xhtml#ch18list16)展示了我们的新类。'
- en: '*fraction_2.h*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction_2.h*'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 18-16: Adding a second constructor to the* Fraction *class*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-16：向* Fraction *类添加第二个构造函数*'
- en: The second constructor differs from the default only in its parameter list ❶.
    We’re using the C++ syntax that tells the compiler how to use the parameter to
    initialize the `numerator` data member.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数与默认构造函数的区别仅在于其参数列表 ❶。我们使用了C++语法来告诉编译器如何利用参数初始化`numerator`数据成员。
- en: I’m using weird in-class member initialization values to make it easier for
    you to see what the assembly language is doing to initialize our object ❷.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了奇怪的类内成员初始化值，以便让你更容易看出汇编语言是如何初始化我们的对象的 ❷。
- en: Let’s modify our `main` function to add another `Fraction` object that uses
    our overloaded constructor, as shown in [Listing 18-17](ch18.xhtml#ch18list17).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`main`函数，添加另一个使用我们重载构造函数的`Fraction`对象，如[清单18-17](ch18.xhtml#ch18list17)所示。
- en: '*inc_fractions.cpp*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fractions.cpp*'
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 18-17: A program to add 1 to two fractions that use different constructors*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-17：一个程序，向两个使用不同构造函数的分数加1*'
- en: For the second `Fraction` object, we’re passing 78 to the constructor as the
    initial value `numerator` ❶.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个`Fraction`对象，我们将78传递给构造函数，作为初始值`numerator` ❶。
- en: '[Listing 18-18](ch18.xhtml#ch18list18) shows how the compiler implements this
    second constructor in assembly language.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单18-18](ch18.xhtml#ch18list18)展示了编译器如何用汇编语言实现第二个构造函数。'
- en: '*inc_fractions.s*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_fractions.s*'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 18-18: The compiler-generated assembly language for the function in
    [Listing 18-17](ch18.xhtml#ch18list17)*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-18：编译器生成的[清单18-17](ch18.xhtml#ch18list17)中函数的汇编语言*'
- en: The compiler generates a separate function for our constructor, which takes
    an argument ❸. The compiler places this constructor in a special section, marked
    `comdat`, where it can be called from functions in other files that use this same
    constructor to instantiate a `Fraction` object ❶. The `.weak` assembler directive
    tells the compiler to generate this label only once in this file ❷. Although we’re
    passing an explicit integer to the constructor in our `main` function ❻, the separate
    function is more efficient if we’re instantiating several `Fraction` objects with
    variables whose values aren’t known until the program is running.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为我们的构造函数生成了一个独立的函数，该函数接受一个参数 ❸。编译器将这个构造函数放置在一个特殊的部分，标记为`comdat`，在那里可以从其他文件中的函数调用它，这些函数使用相同的构造函数来实例化一个`Fraction`对象
    ❶。`.weak`汇编指令告诉编译器只在这个文件中生成一次这个标签 ❷。虽然我们在`main`函数中将一个显式整数传递给构造函数 ❻，但如果我们实例化多个`Fraction`对象，并且这些对象的变量值直到程序运行时才知道，那么独立的函数会更高效。
- en: The argument passed to the `_ZN8FractionC2Ei` constructor is used to initialize
    the `numerator` attribute of our `Fraction` object ❹. Our default in-class value
    is used to initialize the `denominator` attribute ❺.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`_ZN8FractionC2Ei`构造函数的参数用于初始化我们`Fraction`对象的`numerator`属性 ❹。我们的默认类内值用于初始化`denominator`属性
    ❺。
- en: Since the compiler wrote this constructor for us, we only need to change `#include
    "fraction_dflt.h"` to `#include "fraction_2.h"` in the file that defines our other
    member functions, [Listing 18-13](ch18.xhtml#ch18list13). I won’t repeat that
    listing here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器为我们编写了这个构造函数，我们只需要将定义其他成员函数的文件中的`#include "fraction_dflt.h"`更改为`#include
    "fraction_2.h"`，如[清单18-13](ch18.xhtml#ch18list13)所示。我不会在这里重复该清单。
- en: It doesn’t really make sense to write an object-oriented program in assembly
    language. We could invent a name decoration scheme for all our functions, but
    we would still be using the procedural programming paradigm to call them, not
    the object-oriented paradigm. However, there are situations in which we may wish
    to call functions written in assembly language. We’ll look at how to do this in
    the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用汇编语言编写面向对象的程序其实没有多大意义。我们可以为所有函数发明一个名称修饰方案，但我们仍然会使用过程式编程范式来调用它们，而不是面向对象范式。然而，在某些情况下，我们可能希望调用用汇编语言编写的函数。我们将在下一节中学习如何做到这一点。
- en: '**YOUR TURN**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 18.1   Add another constructor to the C++ program in [Listings 18-1](ch18.xhtml#ch18list1),
    [18-3](ch18.xhtml#ch18list3), and [18-5](ch18.xhtml#ch18list5) that takes two
    integer arguments to initialize `Fraction`. Add an object that uses your second
    constructor. For example, `Fraction y(1,2);` would create the `Fraction` object
    initialized to `1/2`. Modify the `main` function to display this second `Fraction`
    object, get a new value for it, add an integer to the second object, and display
    it again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 18.1   在 C++ 程序中添加另一个构造函数，参考[清单 18-1](ch18.xhtml#ch18list1)、[18-3](ch18.xhtml#ch18list3)和[18-5](ch18.xhtml#ch18list5)，该构造函数接受两个整数参数以初始化`Fraction`。添加一个使用第二个构造函数的对象。例如，`Fraction
    y(1,2);`将创建一个初始化为`1/2`的`Fraction`对象。修改`main`函数以显示这个第二个`Fraction`对象，获取其新值，为第二个对象加上一个整数，并再次显示它。
- en: 18.2   Write a program in C++ that prompts the user to enter a numerator and
    a denominator and then instantiates a `Fraction` object using the user’s values.
    Display the new object, add 1 to it, and display the new state of the object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 18.2   编写一个 C++ 程序，提示用户输入分子和分母，然后使用用户的值实例化一个`Fraction`对象。显示新对象，为其加上 1，并显示该对象的新状态。
- en: '**Calling Assembly Language Functions in C++**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 C++ 中调用汇编语言函数**'
- en: To show you how to call assembly language functions in C++, I’ll change our
    `Fraction` member functions to use our assembly language functions `write_str`,
    `write_char`, `put_int`, and `get_int` for writing to the screen and reading from
    the keyboard. [Listing 18-19](ch18.xhtml#ch18list19) shows the changes we need
    to make in the definitions of our member functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何在 C++ 中调用汇编语言函数，我将修改我们的`Fraction`成员函数，使用我们的汇编语言函数`write_str`、`write_char`、`put_int`和`get_int`来进行屏幕输出和键盘输入。[清单
    18-19](ch18.xhtml#ch18list19)展示了我们需要在成员函数定义中做出的修改。
- en: '*fraction_asm.cpp*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction_asm.cpp*'
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 18-19: Calling assembly language functions in the* Fraction *class*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-19：在*Fraction*类中调用汇编语言函数*'
- en: The `extern "C"` tells the C++ compiler that the items in these header files
    have C linkage, so the compiler doesn’t decorate their names ❶.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern "C"`告诉 C++ 编译器这些头文件中的项目具有 C 链接方式，因此编译器不会修饰它们的名称❶。'
- en: '[Listing 18-20](ch18.xhtml#ch18list20) shows how this affects the `get` member
    function.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-20](ch18.xhtml#ch18list20)展示了这如何影响`get`成员函数。'
- en: '*fraction_asm.s*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*fraction_asm.s*'
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 18-20: The compiler-generated assembly language for* get *in [Listing
    18-19](ch18.xhtml#ch18list19)*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-20：在[清单 18-19](ch18.xhtml#ch18list19)中，编译器生成的汇编语言对应的*get*函数*'
- en: The assembly language functions are called by the names we’ve given them, without
    any decoration ❶. If you use `g++` to generate the assembly language for the `display`
    member function, you’ll see similar results for the `put_int` and `write_char`
    function calls.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言函数通过我们为它们指定的名称进行调用，没有任何修饰❶。如果你使用`g++`生成`display`成员函数的汇编语言，你会看到类似的结果，对于`put_int`和`write_char`函数的调用也是如此。
- en: '**What You’ve Learned**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Class** The declaration of the data members that define the state of an object,
    along with any member functions used to access these data members.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**类** 声明定义对象状态的数据成员，并包括用于访问这些数据成员的任何成员函数。'
- en: '**Objects in C++** A named area of memory that contains the data members declared
    in a class.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ 中的对象** 一个命名的内存区域，包含类中声明的数据成员。'
- en: '**Methods or member functions** The member functions declared in a class can
    be called to access the state of an object of the same class.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法或成员函数** 类中声明的成员函数可以被调用来访问同一类对象的状态。'
- en: '**Name decoration** The compiler creates member function names that include
    the function name, the class it belongs to, and the number and types of any arguments
    to the function.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称修饰** 编译器创建成员函数名称时，会包括函数名、所属类以及函数的参数数量和类型。'
- en: '**Constructor** A member function used to initialize an object.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数** 一种成员函数，用于初始化对象。'
- en: '**Destructor** A member function used to clean up resources that are no longer
    needed.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**析构函数** 一种成员函数，用于清理不再需要的资源。'
- en: This chapter has been a brief introduction to the way C++ implements basic object-oriented
    programming features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了 C++ 实现基本面向对象编程特性的方法。
- en: Now that you’ve learned several techniques for organizing data in programs,
    I’ll turn back to how data is stored in binary. So far in this book, I’ve used
    only integral values in our programs. In the next chapter, you’ll see how fractional
    values are represented in memory and learn about some of the CPU instructions
    to manipulate them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了几种在程序中组织数据的技术，我将回到如何在二进制中存储数据的话题。到目前为止，在本书中，我只在程序中使用了整数值。在下一章，你将看到小数值是如何在内存中表示的，并了解一些用于操作它们的CPU指令。
