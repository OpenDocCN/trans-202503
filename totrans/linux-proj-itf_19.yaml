- en: Chapter 19. Monitoring File Events
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19章 监控文件事件
- en: Some applications need to be able to monitor files or directories in order to
    determine whether events have occurred for the monitored objects. For example,
    a graphical file manager needs to be able to determine when files are added or
    removed from the directory that is currently being displayed, or a daemon may
    want to monitor its configuration file in order to know if the file has been changed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序需要能够监控文件或目录，以确定被监控对象是否发生了事件。例如，一个图形化文件管理器需要能够确定当前显示的目录中是否有文件被添加或删除，或者一个守护进程可能需要监控其配置文件，以便了解文件是否已更改。
- en: Starting with kernel 2.6.13, Linux provides the *inotify* mechanism, which allows
    an application to monitor file events. This chapter describes the use of *inotify*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.13开始，Linux提供了*inotify*机制，它允许应用程序监控文件事件。本章介绍了*inotify*的使用。
- en: The *inotify* mechanism replaces an older mechanism, *dnotify*, which provided
    a subset of the functionality of *inotify*. We describe *dnotify* briefly at the
    end of this chapter, focusing on why *inotify* is better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify*机制取代了较旧的机制*dnotify*，后者提供了*inotify*部分功能的子集。本章末尾简要描述了*dnotify*，并重点解释了为何*inotify*更好。'
- en: The *inotify* and *dnotify* mechanisms are Linux-specific. (A few other systems
    provide similar mechanisms. For example, the BSDs provide the *kqueue* API.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify*和*dnotify*机制是Linux特有的。（一些其他系统也提供类似的机制。例如，BSD提供了*kqueue* API。）'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A few libraries provide an API that is more abstract and portable than *inotify*
    and *dnotify*. The use of these libraries may be preferable for some applications.
    Some of these libraries employ *inotify* or *dnotify*, on systems where they are
    available. Two such libraries are FAM (File Alteration Monitor, [http://oss.sgi.com/projects/fam/](http://oss.sgi.com/projects/fam/))
    and Gamin ([http://www.gnome.org/~veillard/gamin/](http://www.gnome.org/~veillard/gamin/)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库提供了比*inotify*和*dnotify*更抽象、更具可移植性的API。这些库的使用可能更适合某些应用程序。这些库中的一些在支持的系统上使用了*inotify*或*dnotify*。例如，FAM（文件更改监视器，[http://oss.sgi.com/projects/fam/](http://oss.sgi.com/projects/fam/)）和Gamin（[http://www.gnome.org/~veillard/gamin/](http://www.gnome.org/~veillard/gamin/)）。
- en: Overview
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'The key steps in the use of the *inotify* API are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*inotify* API的关键步骤如下：
- en: The application uses *inotify_init()* to create an *inotify instance*. This
    system call returns a file descriptor that is used to refer to the *inotify* instance
    in later operations.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用*inotify_init()*来创建一个*inotify实例*。此系统调用返回一个文件描述符，用于在后续操作中引用该*inotify实例*。
- en: The application informs the kernel about which files are of interest by using
    *inotify_add_watch()* to add items to the watch list of the *inotify* instance
    created in the previous step. Each watch item consists of a pathname and an associated
    bit mask. The bit mask specifies the set of events to be monitored for the pathname.
    As its function result, *inotify_add_watch()* returns a *watch descriptor*, which
    is used to refer to the watch in later operations. (The *inotify_rm_watch()* system
    call performs the converse task, removing a watch that was previously added to
    an *inotify* instance.)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过使用*inotify_add_watch()*将感兴趣的文件添加到先前创建的*inotify实例*的监视列表中，从而告知内核哪些文件是感兴趣的。每个监视项由路径名和相关的位掩码组成。位掩码指定了要监控的路径名的事件集合。作为其函数结果，*inotify_add_watch()*返回一个*watch
    descriptor*，该描述符用于在后续操作中引用该监视项。（*inotify_rm_watch()*系统调用执行相反的任务，移除先前添加到*inotify实例*中的监视项。）
- en: In order to obtain event notifications, the application performs *read()* operations
    on the *inotify* file descriptor. Each successful *read()* returns one or more
    *inotify_event* structures, each containing information about an event that occurred
    on one of the pathnames being watched via this *inotify* instance.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获得事件通知，应用程序对*inotify*文件描述符执行*read()*操作。每次成功的*read()*返回一个或多个*inotify_event*结构体，每个结构体包含有关通过此*inotify实例*监控的路径名上发生的事件的信息。
- en: When the application has finished monitoring, it closes the *inotify* file descriptor.
    This automatically removes all watch items associated with the *inotify* instance.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序完成监控时，它会关闭*inotify*文件描述符。这会自动移除所有与该*inotify实例*关联的监视项。
- en: The *inotify* mechanism can be used to monitor files or directories. When monitoring
    a directory, the application will be informed about events for the directory itself
    and for files inside the directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify*机制可用于监控文件或目录。当监控一个目录时，应用程序将收到该目录本身及其内部文件的事件通知。'
- en: The *inotify* monitoring mechanism is not recursive. If an application wants
    to monitor events within an entire directory subtree, it must issue *inotify_add_watch()*
    calls for each directory in the tree.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify*监视机制不是递归的。如果应用程序想要监视整个目录子树中的事件，它必须为树中的每个目录发出*inotify_add_watch()*调用。'
- en: An *inotify* file descriptor can be monitored using *select()*, *poll()*, *epoll*,
    and, since Linux 2.6.25, signal-driven I/O. If events are available to be read,
    then these interfaces indicate the *inotify* file descriptor as being readable.
    See [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models") for further details
    of these interfaces.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*select()*、*poll()*、*epoll*以及从Linux 2.6.25开始的信号驱动I/O来监视*inotify*文件描述符。如果有事件可供读取，这些接口将表示*inotify*文件描述符是可读的。有关这些接口的更多细节，请参见[第63章](ch63.html
    "第63章. 替代I/O模型")。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *inotify* mechanism is an optional Linux kernel component that is configured
    via the options `CONFIG_INOTIFY` and `CONFIG_INOTIFY_USER`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify*机制是一个可选的Linux内核组件，通过选项`CONFIG_INOTIFY`和`CONFIG_INOTIFY_USER`进行配置。'
- en: The *inotify* API
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*inotify* API'
- en: The *inotify_init()* system call creates a new *inotify* instance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify_init()*系统调用创建一个新的*inotify*实例。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回-1
- en: As its function result, *inotify_init()* returns a file descriptor. This file
    descriptor is the handle that is used to refer to the *inotify* instance in subsequent
    operations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify_init()*的函数结果返回一个文件描述符。这个文件描述符是后续操作中用于引用*inotify*实例的句柄。'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.27, Linux supports a new, nonstandard system call,
    *inotify_init1()*. This system call performs the same task as *inotify_init()*,
    but provides an additional argument, *flags*, that can be used to modify the behavior
    of the system call. Two flags are supported. The `IN_CLOEXEC` flag causes the
    kernel to enable the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor.
    This flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The `IN_NONBLOCK` flag causes the
    kernel to enable the `O_NONBLOCK` flag on the underlying open file description,
    so that future reads will be nonblocking. This saves additional calls to *fcntl()*
    to achieve the same result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.27开始，Linux支持一个新的非标准系统调用，*inotify_init1()*。该系统调用与*inotify_init()*执行相同的任务，但提供了一个额外的参数*flags*，可以用来修改系统调用的行为。支持两个标志。`IN_CLOEXEC`标志使内核为新文件描述符启用close-on-exec标志（`FD_CLOEXEC`）。此标志的作用与[文件描述符号由*open()*返回](ch04.html#file_descriptor_number_returned_by-id1
    "由open()返回的文件描述符号")中描述的*open()* `O_CLOEXEC`标志相同。`IN_NONBLOCK`标志使内核在底层的打开文件描述符上启用`O_NONBLOCK`标志，从而使以后的读取操作变为非阻塞。这可以避免额外调用*fcntl()*来实现相同的效果。
- en: The *inotify_add_watch()* system call either adds a new watch item to or modifies
    an existing watch item in the watch list for the *inotify* instance referred to
    by the file descriptor *fd*. (Refer to [Figure 19-1](ch19.html#an_inotify_instance_and_associated_kerne
    "Figure 19-1. An inotify instance and associated kernel data structures").)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify_add_watch()*系统调用将新的监视项添加到*inotify*实例的监视列表中，或者修改已存在的监视项，具体取决于文件描述符*fd*所引用的*inotify*实例。（参见[图19-1](ch19.html#an_inotify_instance_and_associated_kerne
    "图19-1. 一个inotify实例及其关联的内核数据结构")。）'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns watch descriptor on success, or -1 on error
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回监视描述符，出错时返回-1
- en: '![An inotify instance and associated kernel data structures](figs/web/19-1_INOTIFY-inotify-instance-scale90.png.jpg)Figure 19-1. An
    *inotify* instance and associated kernel data structures'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![An inotify instance and associated kernel data structures](figs/web/19-1_INOTIFY-inotify-instance-scale90.png.jpg)图19-1.
    *inotify*实例及其关联的内核数据结构'
- en: The *pathname* argument identifies the file for which a watch item is to be
    created or modified. The caller must have read permission for this file. (The
    file permission check is performed once, at the time of the *inotify_add_watch()*
    call. As long as the watch item continues to exist, the caller will continue to
    receive file notifications even if the file permissions are later changed so that
    the caller no longer has read permission on the file.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname*参数标识要创建或修改监视项的文件。调用者必须对该文件具有读取权限。（文件权限检查仅在*inotify_add_watch()*调用时执行一次。只要监视项继续存在，即使文件权限稍后发生更改，导致调用者不再拥有读取权限，调用者仍会继续接收文件通知。）'
- en: The *mask* argument is a bit mask that specifies the events to be monitored
    for *pathname*. We say more about the bit values that can be specified in *mask*
    shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*mask*参数是一个位掩码，用于指定要监视的*pathname*的事件。我们将在稍后讨论可以在*mask*中指定的位值。'
- en: If *pathname* has not previously been added to the watch list for *fd*, then
    *inotify_add_watch()* creates a new watch item in the list and returns a new,
    nonnegative watch descriptor, which is used to refer to the watch item in later
    operations. This watch descriptor is unique for this *inotify* instance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*pathname*之前没有被添加到*fd*的监视列表中，则*inotify_add_watch()*会在列表中创建一个新的监视项，并返回一个新的非负监视描述符，该描述符用于在后续操作中引用该监视项。此监视描述符对于该*inotify*实例是唯一的。
- en: If *pathname* has previously been added to the watch list for *fd*, then *inotify_add_watch()*
    modifies the mask of the existing watch item for *pathname* and returns the watch
    descriptor for that item. (This watch descriptor will be the same as that returned
    by the *inotify_add_watch()* call that initially added *pathname* to this watch
    list.) We say more about how the mask may be modified when we describe the `IN_MASK_ADD`
    flag in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*pathname*之前已经被添加到*fd*的监视列表中，则*inotify_add_watch()*会修改现有监视项的*mask*，并返回该监视项的监视描述符。（此监视描述符将与最初添加*pathname*到此监视列表时返回的监视描述符相同。）我们将在下一节描述`IN_MASK_ADD`标志时进一步讨论*mask*如何被修改。
- en: The *inotify_rm_watch()* system call removes the watch item specified by *wd*
    from the *inotify* instance referred to by the file descriptor *fd*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*inotify_rm_watch()*系统调用从由文件描述符*fd*引用的*inotify*实例中移除由*wd*指定的监视项。'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1
- en: The *wd* argument is a watch descriptor returned by a previous call to *inotify_add_watch()*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*wd*参数是先前调用*inotify_add_watch()*返回的监视描述符。'
- en: Removing a watch causes an `IN_IGNORED` event to be generated for this watch
    descriptor. We say more about this event shortly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 移除监视会生成一个`IN_IGNORED`事件用于此监视描述符。我们将在稍后讨论这个事件。
- en: '*inotify* Events'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*inotify*事件'
- en: When we create or modify a watch using *inotify_add_watch()*, the *mask* bit-mask
    argument identifies the events to be monitored for the given *pathname*. The event
    bits that may be specified in *mask* are indicated by the *In* column of [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用*inotify_add_watch()*创建或修改一个监视项时，*mask*位掩码参数标识了要监视的给定*pathname*的事件。可以在*mask*中指定的事件位由[表19-1](ch19.html#inotify_events-id1
    "表19-1. inotify事件")的*输入*列指示。
- en: Table 19-1. *inotify* events
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表19-1. *inotify*事件
- en: '| Bit value | In | Out | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 位值 | 输入 | 输出 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `IN_ACCESS` | • | • | File was accessed (*read()*) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ACCESS` | • | • | 文件被访问（*read()*） |'
- en: '| `IN_ATTRIB` | • | • | File metadata changed |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ATTRIB` | • | • | 文件元数据已更改 |'
- en: '| `IN_CLOSE_WRITE` | • | • | File opened for writing was closed |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `IN_CLOSE_WRITE` | • | • | 打开用于写入的文件被关闭 |'
- en: '| `IN_CLOSE_NOWRITE` | • | • | File opened read-only was closed |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `IN_CLOSE_NOWRITE` | • | • | 只读打开的文件被关闭 |'
- en: '| `IN_CREATE` | • | • | File/directory created inside watched directory |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `IN_CREATE` | • | • | 文件/目录在被监视的目录内创建 |'
- en: '| `IN_DELETE` | • | • | File/directory deleted from within watched directory
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `IN_DELETE` | • | • | 文件/目录从被监视的目录中删除 |'
- en: '| `IN_DELETE_SELF` | • | • | Watched file/directory was itself deleted |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `IN_DELETE_SELF` | • | • | 被监视的文件/目录本身被删除 |'
- en: '| `IN_MODIFY` | • | • | File was modified |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MODIFY` | • | • | 文件已被修改 |'
- en: '| `IN_MOVE_SELF` | • | • | Watched file/directory was itself moved |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MOVE_SELF` | • | • | 被监视的文件/目录本身被移动 |'
- en: '| `IN_MOVED_FROM` | • | • | File moved out of watched directory |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MOVED_FROM` | • | • | 文件从被监视的目录中移动 |'
- en: '| `IN_MOVED_TO` | • | • | File moved into watched directory |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MOVED_TO` | • | • | 文件被移动到被监视的目录 |'
- en: '| `IN_OPEN` | • | • | File was opened |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `IN_OPEN` | • | • | 文件被打开 |'
- en: '| `IN_ALL_EVENTS` | • |   | Shorthand for all of the above input events |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ALL_EVENTS` | • |   | 所有上述输入事件的简写 |'
- en: '| `IN_MOVE` | • |   | Shorthand for `IN_MOVED_FROM &#124; IN_MOVED_TO` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MOVE` | • |   | `IN_MOVED_FROM &#124; IN_MOVED_TO`的简写 |'
- en: '| `IN_CLOSE` | • |   | Shorthand for `IN_CLOSE_WRITE &#124; IN_CLOSE_NOWRITE`
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `IN_CLOSE` | • |   | `IN_CLOSE_WRITE &#124; IN_CLOSE_NOWRITE`的简写 |'
- en: '| `IN_DONT_FOLLOW` | • |   | Don’t dereference symbolic link (since Linux 2.6.15)
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `IN_DONT_FOLLOW` | • |   | 不要解引用符号链接（自Linux 2.6.15起） |'
- en: '| `IN_MASK_ADD` | • |   | Add events to current watch mask for *pathname* |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `IN_MASK_ADD` | • |   | 将事件添加到当前*pathname*的监视掩码 |'
- en: '| `IN_ONESHOT` | • |   | Monitor *pathname* for just one event |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ONESHOT` | • |   | 仅监视*pathname*的一个事件 |'
- en: '| `IN_ONLYDIR` | • |   | Fail if *pathname* is not a directory (since Linux
    2.6.15) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ONLYDIR` | • |   | 如果*pathname*不是一个目录，则失败（自Linux 2.6.15起） |'
- en: '| `IN_IGNORED` |   | • | Watch was removed by application or by kernel |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `IN_IGNORED` |   | • | 监视项被应用程序或内核移除 |'
- en: '| `IN_ISDIR` |   | • | Filename returned in *name* is a directory |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `IN_ISDIR` |   | • | *name*中返回的文件名是一个目录 |'
- en: '| `IN_Q_OVERFLOW` |   | • | Overflow on event queue |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `IN_Q_OVERFLOW` |   | • | 事件队列溢出 |'
- en: '| `IN_UNMOUNT` |   | • | File system containing object was unmounted |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `IN_UNMOUNT` |   | • | 包含对象的文件系统已被卸载 |'
- en: 'The meanings of most of the bits in [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events") are evident from their names. The following list
    clarifies a few details:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[表19-1](ch19.html#inotify_events-id1 "表19-1. inotify事件")中大多数位的含义从它们的名称中可以看出。以下列表澄清了一些细节：'
- en: The `IN_ATTRIB` event occurs when file metadata such as permissions, ownership,
    link count, extended attributes, user ID, or group ID, is changed.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_ATTRIB`事件发生在文件元数据（如权限、所有权、链接计数、扩展属性、用户ID或组ID）发生更改时。'
- en: The `IN_DELETE_SELF` event occurs when an object (i.e., a file or a directory)
    that is being monitored is deleted. The `IN_DELETE` event occurs when the monitored
    object is a directory and one of the files that it contains is deleted.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_DELETE_SELF`事件发生在被监控的对象（即文件或目录）被删除时。`IN_DELETE`事件发生在监控的对象是目录，并且目录中包含的某个文件被删除时。'
- en: The `IN_MOVE_SELF` event occurs when an object that is being monitored is renamed.
    The `IN_MOVED_FROM` and `IN_MOVED_TO` events occur when an object is renamed within
    monitored directories. The former event occurs for the directory containing the
    old name, and the latter event occurs for the directory containing the new name.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_MOVE_SELF`事件发生在被监控的对象被重命名时。`IN_MOVED_FROM`和`IN_MOVED_TO`事件发生在对象在监控的目录内被重命名时。前一个事件发生在包含旧名称的目录，后一个事件发生在包含新名称的目录。'
- en: The `IN_DONT_FOLLOW`, `IN_MASK_ADD`, `IN_ONESHOT`, and `IN_ONLYDIR` bits don’t
    specify events to be monitored. Instead, they control the operation of the *inotify_add_watch()*
    call.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_DONT_FOLLOW`、`IN_MASK_ADD`、`IN_ONESHOT`和`IN_ONLYDIR`位不指定要监控的事件。相反，它们控制*inotify_add_watch()*调用的操作。'
- en: '`IN_DONT_FOLLOW` specifies that *pathname* should not be dereferenced if it
    is a symbolic link. This permits an application to monitor a symbolic link, rather
    than the file to which it refers.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_DONT_FOLLOW`指定如果*pathname*是符号链接，则不应对其进行解引用。这允许应用程序监控符号链接，而不是它所指向的文件。'
- en: If we perform an *inotify_add_watch()* call that specifies a pathname that is
    already being watched via this *inotify* file descriptor, then, by default, the
    given *mask* is used to replace the current mask for this watch item. If `IN_MASK_ADD`
    is specified, then the current mask is instead modified by ORing it with the value
    given in *mask*.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们执行一个指定已被通过此*inotify*文件描述符监视的*pathname*的`inotify_add_watch()`调用，则默认情况下，给定的*mask*将替换此监视项的当前掩码。如果指定了`IN_MASK_ADD`，则当前掩码将通过与*mask*中给定的值进行或运算来修改。
- en: '`IN_ONESHOT` permits an application to monitor *pathname* for a single event.
    After that event, the watch item is automatically removed from the watch list.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_ONESHOT`允许应用程序仅监控*pathname*的一个事件。该事件发生后，监视项会自动从监视列表中移除。'
- en: '`IN_ONLYDIR` permits an application to monitor a pathname only if it is a directory.
    If *pathname* is not a directory, then *inotify_add_watch()* fails with the error
    `ENOTDIR`. Using this flag prevents race conditions that could otherwise occur
    if we wanted to ensure that we are monitoring a directory.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_ONLYDIR`允许应用程序仅在*pathname*是目录时才进行监控。如果*pathname*不是一个目录，则`inotify_add_watch()`会因为错误`ENOTDIR`而失败。使用此标志可以防止在确保监控的是目录时可能发生的竞争条件。'
- en: Reading *inotify* Events
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取*inotify*事件
- en: Having registered items in the watch list, an application can determine which
    events have occurred by using *read()* to read events from the *inotify* file
    descriptor. If no events have occurred so far, then *read()* blocks until an event
    occurs (unless the `O_NONBLOCK` status flag has been set for the file descriptor,
    in which case the *read()* fails immediately with the error `EAGAIN` if no events
    are available).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册了监视项的情况下，应用程序可以通过使用*read()*从*inotify*文件描述符中读取事件来确定哪些事件已经发生。如果到目前为止没有事件发生，则*read()*会阻塞，直到事件发生（除非为文件描述符设置了`O_NONBLOCK`状态标志，在这种情况下，如果没有事件可用，*read()*会立即失败并返回错误`EAGAIN`）。
- en: 'After events have occurred, each *read()* returns a buffer (see [Figure 19-2](ch19.html#an_input_buffer_containing_three_inotify
    "Figure 19-2. An input buffer containing three inotify_event structures")) containing
    one or more structures of the following type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件发生后，每次 *read()* 调用返回一个缓冲区（参见 [图19-2](ch19.html#an_input_buffer_containing_three_inotify
    "Figure 19-2. An input buffer containing three inotify_event structures")），该缓冲区包含一个或多个如下类型的结构：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![An input buffer containing three inotify_event structures](figs/web/19-2_INOTIFY-inotify_event-buffer-scale90.png.jpg)Figure 19-2. An
    input buffer containing three *inotify_event* structures'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个包含三个 inotify_event 结构的输入缓冲区](figs/web/19-2_INOTIFY-inotify_event-buffer-scale90.png.jpg)图19-2.
    一个包含三个 *inotify_event* 结构的输入缓冲区'
- en: The *wd* field tells us the watch descriptor for which this event occurred.
    This field contains one of the values returned by a previous call to *inotify_add_watch()*.
    The *wd* field is useful when an application is monitoring multiple files or directories
    via the same *inotify* file descriptor. It provides the link that allows the application
    to determine the particular file or directory for which the event occurred. (To
    do this, the application must maintain a bookkeeping data structure that relates
    watch descriptors to pathnames.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*wd* 字段告诉我们发生此事件的监视描述符。该字段包含先前调用 *inotify_add_watch()* 时返回的值。当应用程序通过相同的 *inotify*
    文件描述符监视多个文件或目录时，*wd* 字段非常有用。它提供了一个链接，允许应用程序确定发生事件的特定文件或目录。（为此，应用程序必须维护一个书籍数据结构，将监视描述符与路径名关联起来。）'
- en: 'The *mask* field returns a bit mask that describes the event. The range of
    bits that can appear in *mask* is indicated via the *Out* column of [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events"). Note the following additional details about specific
    bits:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*mask* 字段返回一个描述事件的位掩码。*mask* 中可能出现的位范围通过 [表19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events")的*Out*列表示。请注意以下关于特定位的额外细节：'
- en: 'An `IN_IGNORED` event is generated when a watch is removed. This can occur
    for two reasons: the application used an *inotify_rm_watch()* call to explicitly
    remove the watch, or the watch was implicitly removed by the kernel because the
    monitored object was deleted or the file system where it resides was unmounted.
    An `IN_IGNORED` event is not generated when a watch that was established with
    `IN_ONESHOT` is automatically removed because an event was triggered.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当移除监视时，会生成一个 `IN_IGNORED` 事件。这可能有两个原因：应用程序使用了 *inotify_rm_watch()* 调用显式移除了监视，或者监视由于被监控对象被删除或所在文件系统被卸载而被内核隐式移除。当使用
    `IN_ONESHOT` 建立的监视被触发事件后自动移除时，不会生成 `IN_IGNORED` 事件。
- en: If the subject of the event is a directory, then, in addition to some other
    bit, the `IN_ISDIR` bit will be set in *mask*.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件的主题是一个目录，那么，除了其他一些位，`IN_ISDIR` 位还会在*mask*中被设置。
- en: The `IN_UNMOUNT` event informs the application that the file system containing
    the monitored object has been unmounted. After this event, a further event containing
    the `IN_IGNORED` bit will be delivered.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN_UNMOUNT` 事件通知应用程序，包含被监控对象的文件系统已经被卸载。该事件发生后，会发送一个包含 `IN_IGNORED` 位的后续事件。'
- en: We describe the `IN_Q_OVERFLOW` in [Queue Limits and `/proc` Files](ch19.html#queue_limits_and_solidus_proc_files
    "Queue Limits and /proc Files"), which discusses limits on queued *inotify* events.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 [队列限制和 `/proc` 文件](ch19.html#queue_limits_and_solidus_proc_files "Queue
    Limits and /proc Files")中描述了 `IN_Q_OVERFLOW`，该部分讨论了关于排队的 *inotify* 事件的限制。
- en: The *cookie* field is used to tie related events together. Currently, this field
    is used only when a file is renamed. When this happens, an `IN_MOVED_FROM` event
    is generated for the directory from which the file is renamed, and then an `IN_MOVED_TO`
    is generated for the directory to which the file is renamed. (If a file is given
    a new name within the same directory, then both events occur for the same directory.)
    These two events will have the same unique value in their *cookie* field, thus
    allowing the application to associate them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*cookie* 字段用于将相关事件关联在一起。目前，只有在文件被重命名时，该字段才会被使用。当文件重命名时，会为源目录生成一个 `IN_MOVED_FROM`
    事件，然后为目标目录生成一个 `IN_MOVED_TO` 事件。（如果文件在同一目录中被赋予新名称，那么这两个事件会出现在同一目录中。）这两个事件将在它们的
    *cookie* 字段中拥有相同的唯一值，从而使应用程序能够将它们关联起来。'
- en: When an event occurs for a file within a monitored directory, the *name* field
    is used to return a null-terminated string that identifies the file. If the event
    occurs for the monitored object itself, then the *name* field is unused, and the
    *len* field will contain 0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当监控目录中的文件发生事件时，*name*字段用于返回一个空字符终止的字符串，标识该文件。如果事件发生在被监控对象本身上，则*name*字段不使用，而*len*字段将包含0。
- en: The *len* field indicates how many bytes are actually allocated for the *name*
    field. This field is necessary because there may be additional padding bytes between
    the end of the string stored in *name* and the start of the next *inotify_event*
    structure contained in the buffer returned by *read()* (see [Figure 19-2](ch19.html#an_input_buffer_containing_three_inotify
    "Figure 19-2. An input buffer containing three inotify_event structures")). The
    length of an individual *inotify* event is thus *sizeof(struct inotify_event)
    + len*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*len*字段表示实际分配给*name*字段的字节数。这个字段是必要的，因为在*name*中存储的字符串的结尾与*read()*返回的缓冲区中下一个*inotify_event*结构的开始之间，可能会有额外的填充字节（请参见[图19-2](ch19.html#an_input_buffer_containing_three_inotify
    "图19-2. 一个包含三个inotify_event结构的输入缓冲区")）。因此，单个*inotify*事件的长度是*sizeof(struct inotify_event)
    + len*。'
- en: 'If the buffer passed to *read()* is too small to hold the next *inotify_event*
    structure, then *read()* fails with the error `EINVAL` to warn the application
    of this fact. (In kernels before 2.6.21, *read()* returned 0 for this case. The
    change to the use of an `EINVAL` error provides a clearer indication that a programming
    error has been made.) The application could respond by performing another *read()*
    with a larger buffer. However, the problem can be avoided altogether by ensuring
    that the buffer is always large enough to hold at least one event: the buffer
    given to *read()* should be at least *(sizeof(struct inotify_event) + NAME_MAX
    + 1)* bytes, where `NAME_MAX` is the maximum length of a filename, plus one for
    the terminating null byte.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给*read()*的缓冲区太小，无法容纳下一个*inotify_event*结构，则*read()*会因错误`EINVAL`而失败，以警告应用程序此事实。（在2.6.21之前的内核中，*read()*在这种情况下返回0。使用`EINVAL`错误可以更清晰地表明发生了编程错误。）应用程序可以通过使用更大的缓冲区再次调用*read()*来响应。然而，可以通过确保缓冲区始终足够大，以至少容纳一个事件，从而完全避免这个问题：传递给*read()*的缓冲区应该至少为*(sizeof(struct
    inotify_event) + NAME_MAX + 1)*字节，其中`NAME_MAX`是文件名的最大长度，再加一个终止的空字节。
- en: Using a larger buffer size than the minimum allows an application to efficiently
    retrieve multiple events with a single *read()*. A *read()* from an *inotify*
    file descriptor returns the minimum of the number of events that are available
    and the number of events that will fit in the supplied buffer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比最小值更大的缓冲区大小可以让应用程序通过一次*read()*高效地检索多个事件。从*inotify*文件描述符读取的*read()*将返回可用事件的数量和可以适配提供的缓冲区的事件数量中的最小值。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call *ioctl(fd, FIONREAD, &numbytes)* returns the number of bytes that are
    currently available to read from the *inotify* instance referred to by the file
    descriptor *fd*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*ioctl(fd, FIONREAD, &numbytes)*会返回当前可以从文件描述符*fd*所引用的*inotify*实例中读取的字节数。
- en: The events read from an *inotify* file descriptor form an ordered queue. Thus,
    for example, it is guaranteed that when a file is renamed, the `IN_MOVED_FROM`
    event will be read before the `IN_MOVED_TO` event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从*inotify*文件描述符读取的事件形成一个有序的队列。因此，例如，可以保证在文件被重命名时，`IN_MOVED_FROM`事件会在`IN_MOVED_TO`事件之前被读取。
- en: When appending a new event to the end of the event queue, the kernel will coalesce
    that event with the event at the tail of the queue (so that the new event is not
    in fact queued), if the two events have the same values for *wd*, *mask*, *cookie*,
    and *name*. This is done because many applications don’t need to know about repeated
    instances of the same event, and dropping the excess events reduces the amount
    of (kernel) memory required for the event queue. However, this means we can’t
    use *inotify* to reliably determine how many times or how often a recurrent event
    occurs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个新事件添加到事件队列的末尾时，如果两个事件的*wd*、*mask*、*cookie*和*name*值相同，内核会将新事件与队列尾部的事件合并（因此新事件实际上并不会被排入队列）。这样做是因为许多应用程序不需要知道同一事件的重复实例，丢弃多余的事件减少了事件队列所需的（内核）内存。然而，这也意味着我们不能使用*inotify*来可靠地确定一个重复事件发生的次数或频率。
- en: Example program
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: Although there is a lot of detail in the preceding description, the *inotify*
    API is actually quite simple to use. [Example 19-1](ch19.html#using_the_inotify_api
    "Example 19-1. Using the inotify API") demonstrates the use of *inotify*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的描述包含了很多细节，但 *inotify* API 实际上非常简单易用。[示例 19-1](ch19.html#using_the_inotify_api
    "示例 19-1. 使用 inotify API")演示了 *inotify* 的使用。
- en: Example 19-1. Using the *inotify* API
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-1. 使用 *inotify* API
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The program in [Example 19-1](ch19.html#using_the_inotify_api "Example 19-1. Using
    the inotify API") performs the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在[示例 19-1](ch19.html#using_the_inotify_api "示例 19-1. 使用 inotify API")中执行以下步骤：
- en: Use *inotify_init()* to create an *inotify* file descriptor ![](figs/web/U001.png).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *inotify_init()* 创建一个 *inotify* 文件描述符 ![](figs/web/U001.png)。
- en: Use *inotify_add_watch()* to add a watch item for each of the files named in
    the command-line argument of the program ![](figs/web/U002.png). Each watch item
    watches for all possible events.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *inotify_add_watch()* 为程序命令行参数中指定的每个文件添加一个监视项 ![](figs/web/U002.png)。每个监视项都会监视所有可能的事件。
- en: 'Execute an infinite loop that:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个无限循环，其中：
- en: Reads a buffer of events from the *inotify* file descriptor ![](figs/web/U003.png).
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *inotify* 文件描述符读取一个事件缓冲区 ![](figs/web/U003.png)。
- en: Calls the *displayInotifyEvent()* function to display the contents of each of
    the *inotify_event* structures within that buffer ![](figs/web/U004.png).
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 *displayInotifyEvent()* 函数显示该缓冲区中每个 *inotify_event* 结构的内容 ![](figs/web/U004.png)。
- en: 'The following shell session demonstrates the use of the program in [Example 19-1](ch19.html#using_the_inotify_api
    "Example 19-1. Using the inotify API"). We start an instance of the program that
    runs in the background monitoring two directories:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话演示了[示例 19-1](ch19.html#using_the_inotify_api "示例 19-1. 使用 inotify
    API")中程序的使用。我们启动一个后台运行的程序实例，监控两个目录：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we execute commands that generate events in the two directories. We begin
    by creating a file using *cat(1)*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行生成事件的命令，在两个目录中创建一个文件，使用 *cat(1)*：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The above output produced by the background program shows that *read()* fetched
    a buffer containing two events. We continue by typing some input for the file
    and then the terminal *end-of-file* character:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述由后台程序生成的输出显示，*read()* 获取了一个包含两个事件的缓冲区。我们继续为文件输入一些内容，然后输入终端的 *end-of-file*
    字符：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then rename the file into the other monitored directory. This results in
    two events, one for the directory from which the file moves (watch descriptor
    1), and the other for the destination directory (watch descriptor 2):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文件重命名到另一个监控的目录中。这会产生两个事件，一个是来自文件移动的源目录（监视描述符 1），另一个是目标目录（监视描述符 2）：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These two events share the same *cookie* value, allowing the application to
    link them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事件共享相同的*cookie*值，从而允许应用程序将它们关联起来。
- en: 'When we create a subdirectory under one of the monitored directories, the mask
    in the resulting event includes the `IN_ISDIR` bit, indicating that the subject
    of the event is a directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在监控的目录之一下创建一个子目录时，生成的事件的掩码中包含 `IN_ISDIR` 位，表明事件的主体是一个目录：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, it is worth repeating that *inotify* monitoring is not recursive.
    If the application wanted to monitor events in the newly created subdirectory,
    then it would need to issue a further *inotify_add_watch()* call specifying the
    pathname of the subdirectory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此需要重复说明的是，*inotify* 监控并不是递归的。如果应用程序想要监控新创建的子目录中的事件，它需要再次调用 *inotify_add_watch()*，并指定子目录的路径名。
- en: 'Finally, we remove one of the monitored directories:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移除其中一个被监控的目录：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last event, `IN_IGNORED`, was generated to inform the application that the
    kernel has removed this watch item from the watch list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个事件 `IN_IGNORED` 被生成，以通知应用程序内核已将此监视项从监视列表中移除。
- en: Queue Limits and `/proc` Files
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列限制和 `/proc` 文件
- en: 'Queuing *inotify* events requires kernel memory. For this reason, the kernel
    places various limits on the operation of the *inotify* mechanism. The superuser
    can configure these limits via three files in the directory `/proc/sys/fs/inotify`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 排队 *inotify* 事件需要内核内存。因此，内核对 *inotify* 机制的操作设置了各种限制。超级用户可以通过 `/proc/sys/fs/inotify`
    目录中的三个文件来配置这些限制：
- en: '`max_queued_events`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_queued_events`'
- en: When *inotify_init()* is called, this value is used to set an upper limit on
    the number of events that can be queued on the new *inotify* instance. If this
    limit is reached, then an `IN_Q_OVERFLOW` event is generated and excess events
    are discarded. The *wd* field for the overflow event will have the value -1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 *inotify_init()* 时，该值用于设置新 *inotify* 实例上可以排队的事件数量的上限。如果达到该限制，则会生成一个 `IN_Q_OVERFLOW`
    事件，且多余的事件会被丢弃。溢出事件的 *wd* 字段值为 -1。
- en: '`max_user_instances`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_user_instances`'
- en: This is a limit on the number of *inotify* instances that can be created per
    real user ID.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对每个真实用户 ID 可以创建的 *inotify* 实例数量的限制。
- en: '`max_user_watches`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_user_watches`'
- en: This is a limit on the number of watch items that can be created per real user
    ID.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对每个真实用户 ID 可以创建的监视项数量的限制。
- en: Typical default values for these three files are 16,384, 128, and 8192, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个文件的典型默认值分别是 16,384、128 和 8192。
- en: 'An Older System for Monitoring File Events: *dnotify*'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个旧的文件事件监控系统：*dnotify*
- en: 'Linux provides another mechanism for monitoring file events. This mechanism,
    known as *dnotify*, has been available since kernel 2.4, but has been made obsolete
    by *inotify*. The *dnotify* mechanism suffers a number of limitations compared
    with *inotify*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了另一种监控文件事件的机制。这个机制叫做 *dnotify*，自内核 2.4 以来就已存在，但已被 *inotify* 取代。与 *inotify*
    相比，*dnotify* 机制存在一些限制：
- en: The *dnotify* mechanism provides notification of events by sending signals to
    the application. Using signals as a notification mechanism complicates application
    design ([Interprocess Communication with Signals](ch22.html#interprocess_communication_with_signals
    "Interprocess Communication with Signals")). It also makes the use of *dnotify*
    within a library difficult, since the calling program might change the disposition
    of the notification signal(s). The *inotify* mechanism doesn’t use signals.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dnotify* 机制通过向应用程序发送信号来通知事件。使用信号作为通知机制使应用程序设计变得复杂（[信号的进程间通信](ch22.html#interprocess_communication_with_signals
    "信号的进程间通信")）。这也使得在库中使用 *dnotify* 变得困难，因为调用程序可能会改变通知信号的处理方式。*inotify* 机制不使用信号。'
- en: The monitoring unit of *dnotify* is a directory. The application is informed
    when an operation is performed on any file in that directory. By contrast, *inotify*
    can be used to monitor directories or individual files.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dnotify* 的监控单元是一个目录。当在该目录中的任何文件上执行操作时，应用程序会收到通知。相比之下，*inotify* 可以用于监控目录或单个文件。'
- en: In order to monitor a directory, *dnotify* requires the application to open
    a file descriptor for that directory. The use of file descriptors causes two problems.
    First, because it is busy, the file system containing the directory can’t be unmounted.
    Second, because one file descriptor is required for each directory, an application
    can end up consuming a large number of file descriptors. Because *inotify* doesn’t
    use file descriptors, it avoids these problems.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了监控一个目录，*dnotify* 要求应用程序为该目录打开一个文件描述符。使用文件描述符会导致两个问题。首先，因为文件系统忙碌，包含该目录的文件系统无法卸载。其次，因为每个目录都需要一个文件描述符，应用程序可能会消耗大量的文件描述符。而
    *inotify* 不使用文件描述符，从而避免了这些问题。
- en: The information provided by *dnotify* about file events is less precise than
    that provided by *inotify*. When a file is changed inside a monitored directory,
    *dnotify* tells us that an event has occurred, but doesn’t tell us which file
    was involved in the event. The application must determine this by caching information
    about the directory contents. Furthermore, *inotify* provides more detailed information
    than *dnotify* about the type of event that has occurred.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dnotify* 提供的文件事件信息比 *inotify* 提供的信息不够精确。当一个文件在监控的目录中发生变化时，*dnotify* 会告诉我们发生了事件，但不会告诉我们哪个文件参与了该事件。应用程序必须通过缓存目录内容的信息来确定这一点。此外，*inotify*
    提供比 *dnotify* 更详细的事件类型信息。'
- en: In some circumstances, *dnotify* doesn’t provide reliable notification of file
    events.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，*dnotify* 无法提供可靠的文件事件通知。
- en: Further information about *dnotify* can be found under the description of the
    `F_NOTIFY` operation in the *fcntl(2)* manual page, and in the kernel source file
    `Documentation/dnotify.txt`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 *dnotify* 的更多信息可以在 *fcntl(2)* 手册页中 `F_NOTIFY` 操作的描述中找到，也可以在内核源文件 `Documentation/dnotify.txt`
    中查阅。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The Linux-specific *inotify* mechanism allows an application to obtain notifications
    when events (files are opened, closed, created, deleted, modified, renamed, and
    so on) occur for a set of monitored files and directories. The *inotify* mechanism
    supersedes the older *dnotify* mechanism.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特有的 *inotify* 机制允许应用程序在一组被监控的文件和目录上发生事件（文件被打开、关闭、创建、删除、修改、重命名等）时获取通知。*inotify*
    机制取代了较旧的 *dnotify* 机制。
- en: Exercise
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a program that logs all file creations, deletions, and renames under
    the directory named in its command-line argument. The program should monitor events
    in all of the subdirectories under the specified directory. To obtain a list of
    all of these subdirectories, you will need to make use of *nftw()* ([File Tree
    Walking: *nftw()*](ch18.html#file_tree_walking_colon_nftw_open_parent "File Tree
    Walking: nftw()")). When a new subdirectory is added under the tree or a directory
    is deleted, the set of monitored subdirectories should be updated accordingly.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，记录在命令行参数指定的目录下的所有文件创建、删除和重命名操作。该程序应监控指定目录下所有子目录中的事件。为了获取所有这些子目录的列表，您需要使用
    *nftw()* 函数（[文件树遍历：*nftw()*](ch18.html#file_tree_walking_colon_nftw_open_parent
    "文件树遍历：nftw()")）。当树下添加新子目录或删除目录时，监控的子目录集合应相应更新。
