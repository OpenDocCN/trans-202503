- en: Chapter 19. Monitoring File Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications need to be able to monitor files or directories in order to
    determine whether events have occurred for the monitored objects. For example,
    a graphical file manager needs to be able to determine when files are added or
    removed from the directory that is currently being displayed, or a daemon may
    want to monitor its configuration file in order to know if the file has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.13, Linux provides the *inotify* mechanism, which allows
    an application to monitor file events. This chapter describes the use of *inotify*.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify* mechanism replaces an older mechanism, *dnotify*, which provided
    a subset of the functionality of *inotify*. We describe *dnotify* briefly at the
    end of this chapter, focusing on why *inotify* is better.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify* and *dnotify* mechanisms are Linux-specific. (A few other systems
    provide similar mechanisms. For example, the BSDs provide the *kqueue* API.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A few libraries provide an API that is more abstract and portable than *inotify*
    and *dnotify*. The use of these libraries may be preferable for some applications.
    Some of these libraries employ *inotify* or *dnotify*, on systems where they are
    available. Two such libraries are FAM (File Alteration Monitor, [http://oss.sgi.com/projects/fam/](http://oss.sgi.com/projects/fam/))
    and Gamin ([http://www.gnome.org/~veillard/gamin/](http://www.gnome.org/~veillard/gamin/)).
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key steps in the use of the *inotify* API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application uses *inotify_init()* to create an *inotify instance*. This
    system call returns a file descriptor that is used to refer to the *inotify* instance
    in later operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application informs the kernel about which files are of interest by using
    *inotify_add_watch()* to add items to the watch list of the *inotify* instance
    created in the previous step. Each watch item consists of a pathname and an associated
    bit mask. The bit mask specifies the set of events to be monitored for the pathname.
    As its function result, *inotify_add_watch()* returns a *watch descriptor*, which
    is used to refer to the watch in later operations. (The *inotify_rm_watch()* system
    call performs the converse task, removing a watch that was previously added to
    an *inotify* instance.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to obtain event notifications, the application performs *read()* operations
    on the *inotify* file descriptor. Each successful *read()* returns one or more
    *inotify_event* structures, each containing information about an event that occurred
    on one of the pathnames being watched via this *inotify* instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the application has finished monitoring, it closes the *inotify* file descriptor.
    This automatically removes all watch items associated with the *inotify* instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *inotify* mechanism can be used to monitor files or directories. When monitoring
    a directory, the application will be informed about events for the directory itself
    and for files inside the directory.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify* monitoring mechanism is not recursive. If an application wants
    to monitor events within an entire directory subtree, it must issue *inotify_add_watch()*
    calls for each directory in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: An *inotify* file descriptor can be monitored using *select()*, *poll()*, *epoll*,
    and, since Linux 2.6.25, signal-driven I/O. If events are available to be read,
    then these interfaces indicate the *inotify* file descriptor as being readable.
    See [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models") for further details
    of these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *inotify* mechanism is an optional Linux kernel component that is configured
    via the options `CONFIG_INOTIFY` and `CONFIG_INOTIFY_USER`.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify* API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *inotify_init()* system call creates a new *inotify* instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: As its function result, *inotify_init()* returns a file descriptor. This file
    descriptor is the handle that is used to refer to the *inotify* instance in subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.27, Linux supports a new, nonstandard system call,
    *inotify_init1()*. This system call performs the same task as *inotify_init()*,
    but provides an additional argument, *flags*, that can be used to modify the behavior
    of the system call. Two flags are supported. The `IN_CLOEXEC` flag causes the
    kernel to enable the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor.
    This flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The `IN_NONBLOCK` flag causes the
    kernel to enable the `O_NONBLOCK` flag on the underlying open file description,
    so that future reads will be nonblocking. This saves additional calls to *fcntl()*
    to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify_add_watch()* system call either adds a new watch item to or modifies
    an existing watch item in the watch list for the *inotify* instance referred to
    by the file descriptor *fd*. (Refer to [Figure 19-1](ch19.html#an_inotify_instance_and_associated_kerne
    "Figure 19-1. An inotify instance and associated kernel data structures").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns watch descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: '![An inotify instance and associated kernel data structures](figs/web/19-1_INOTIFY-inotify-instance-scale90.png.jpg)Figure 19-1. An
    *inotify* instance and associated kernel data structures'
  prefs: []
  type: TYPE_NORMAL
- en: The *pathname* argument identifies the file for which a watch item is to be
    created or modified. The caller must have read permission for this file. (The
    file permission check is performed once, at the time of the *inotify_add_watch()*
    call. As long as the watch item continues to exist, the caller will continue to
    receive file notifications even if the file permissions are later changed so that
    the caller no longer has read permission on the file.)
  prefs: []
  type: TYPE_NORMAL
- en: The *mask* argument is a bit mask that specifies the events to be monitored
    for *pathname*. We say more about the bit values that can be specified in *mask*
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* has not previously been added to the watch list for *fd*, then
    *inotify_add_watch()* creates a new watch item in the list and returns a new,
    nonnegative watch descriptor, which is used to refer to the watch item in later
    operations. This watch descriptor is unique for this *inotify* instance.
  prefs: []
  type: TYPE_NORMAL
- en: If *pathname* has previously been added to the watch list for *fd*, then *inotify_add_watch()*
    modifies the mask of the existing watch item for *pathname* and returns the watch
    descriptor for that item. (This watch descriptor will be the same as that returned
    by the *inotify_add_watch()* call that initially added *pathname* to this watch
    list.) We say more about how the mask may be modified when we describe the `IN_MASK_ADD`
    flag in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The *inotify_rm_watch()* system call removes the watch item specified by *wd*
    from the *inotify* instance referred to by the file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *wd* argument is a watch descriptor returned by a previous call to *inotify_add_watch()*.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a watch causes an `IN_IGNORED` event to be generated for this watch
    descriptor. We say more about this event shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '*inotify* Events'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create or modify a watch using *inotify_add_watch()*, the *mask* bit-mask
    argument identifies the events to be monitored for the given *pathname*. The event
    bits that may be specified in *mask* are indicated by the *In* column of [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events").
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-1. *inotify* events
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit value | In | Out | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ACCESS` | • | • | File was accessed (*read()*) |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ATTRIB` | • | • | File metadata changed |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_CLOSE_WRITE` | • | • | File opened for writing was closed |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_CLOSE_NOWRITE` | • | • | File opened read-only was closed |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_CREATE` | • | • | File/directory created inside watched directory |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_DELETE` | • | • | File/directory deleted from within watched directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_DELETE_SELF` | • | • | Watched file/directory was itself deleted |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MODIFY` | • | • | File was modified |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MOVE_SELF` | • | • | Watched file/directory was itself moved |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MOVED_FROM` | • | • | File moved out of watched directory |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MOVED_TO` | • | • | File moved into watched directory |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_OPEN` | • | • | File was opened |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ALL_EVENTS` | • |   | Shorthand for all of the above input events |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MOVE` | • |   | Shorthand for `IN_MOVED_FROM &#124; IN_MOVED_TO` |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_CLOSE` | • |   | Shorthand for `IN_CLOSE_WRITE &#124; IN_CLOSE_NOWRITE`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_DONT_FOLLOW` | • |   | Don’t dereference symbolic link (since Linux 2.6.15)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_MASK_ADD` | • |   | Add events to current watch mask for *pathname* |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ONESHOT` | • |   | Monitor *pathname* for just one event |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ONLYDIR` | • |   | Fail if *pathname* is not a directory (since Linux
    2.6.15) |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_IGNORED` |   | • | Watch was removed by application or by kernel |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_ISDIR` |   | • | Filename returned in *name* is a directory |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_Q_OVERFLOW` |   | • | Overflow on event queue |'
  prefs: []
  type: TYPE_TB
- en: '| `IN_UNMOUNT` |   | • | File system containing object was unmounted |'
  prefs: []
  type: TYPE_TB
- en: 'The meanings of most of the bits in [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events") are evident from their names. The following list
    clarifies a few details:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IN_ATTRIB` event occurs when file metadata such as permissions, ownership,
    link count, extended attributes, user ID, or group ID, is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IN_DELETE_SELF` event occurs when an object (i.e., a file or a directory)
    that is being monitored is deleted. The `IN_DELETE` event occurs when the monitored
    object is a directory and one of the files that it contains is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IN_MOVE_SELF` event occurs when an object that is being monitored is renamed.
    The `IN_MOVED_FROM` and `IN_MOVED_TO` events occur when an object is renamed within
    monitored directories. The former event occurs for the directory containing the
    old name, and the latter event occurs for the directory containing the new name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IN_DONT_FOLLOW`, `IN_MASK_ADD`, `IN_ONESHOT`, and `IN_ONLYDIR` bits don’t
    specify events to be monitored. Instead, they control the operation of the *inotify_add_watch()*
    call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IN_DONT_FOLLOW` specifies that *pathname* should not be dereferenced if it
    is a symbolic link. This permits an application to monitor a symbolic link, rather
    than the file to which it refers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we perform an *inotify_add_watch()* call that specifies a pathname that is
    already being watched via this *inotify* file descriptor, then, by default, the
    given *mask* is used to replace the current mask for this watch item. If `IN_MASK_ADD`
    is specified, then the current mask is instead modified by ORing it with the value
    given in *mask*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IN_ONESHOT` permits an application to monitor *pathname* for a single event.
    After that event, the watch item is automatically removed from the watch list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IN_ONLYDIR` permits an application to monitor a pathname only if it is a directory.
    If *pathname* is not a directory, then *inotify_add_watch()* fails with the error
    `ENOTDIR`. Using this flag prevents race conditions that could otherwise occur
    if we wanted to ensure that we are monitoring a directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading *inotify* Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having registered items in the watch list, an application can determine which
    events have occurred by using *read()* to read events from the *inotify* file
    descriptor. If no events have occurred so far, then *read()* blocks until an event
    occurs (unless the `O_NONBLOCK` status flag has been set for the file descriptor,
    in which case the *read()* fails immediately with the error `EAGAIN` if no events
    are available).
  prefs: []
  type: TYPE_NORMAL
- en: 'After events have occurred, each *read()* returns a buffer (see [Figure 19-2](ch19.html#an_input_buffer_containing_three_inotify
    "Figure 19-2. An input buffer containing three inotify_event structures")) containing
    one or more structures of the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![An input buffer containing three inotify_event structures](figs/web/19-2_INOTIFY-inotify_event-buffer-scale90.png.jpg)Figure 19-2. An
    input buffer containing three *inotify_event* structures'
  prefs: []
  type: TYPE_NORMAL
- en: The *wd* field tells us the watch descriptor for which this event occurred.
    This field contains one of the values returned by a previous call to *inotify_add_watch()*.
    The *wd* field is useful when an application is monitoring multiple files or directories
    via the same *inotify* file descriptor. It provides the link that allows the application
    to determine the particular file or directory for which the event occurred. (To
    do this, the application must maintain a bookkeeping data structure that relates
    watch descriptors to pathnames.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The *mask* field returns a bit mask that describes the event. The range of
    bits that can appear in *mask* is indicated via the *Out* column of [Table 19-1](ch19.html#inotify_events-id1
    "Table 19-1. inotify events"). Note the following additional details about specific
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `IN_IGNORED` event is generated when a watch is removed. This can occur
    for two reasons: the application used an *inotify_rm_watch()* call to explicitly
    remove the watch, or the watch was implicitly removed by the kernel because the
    monitored object was deleted or the file system where it resides was unmounted.
    An `IN_IGNORED` event is not generated when a watch that was established with
    `IN_ONESHOT` is automatically removed because an event was triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the subject of the event is a directory, then, in addition to some other
    bit, the `IN_ISDIR` bit will be set in *mask*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IN_UNMOUNT` event informs the application that the file system containing
    the monitored object has been unmounted. After this event, a further event containing
    the `IN_IGNORED` bit will be delivered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We describe the `IN_Q_OVERFLOW` in [Queue Limits and `/proc` Files](ch19.html#queue_limits_and_solidus_proc_files
    "Queue Limits and /proc Files"), which discusses limits on queued *inotify* events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *cookie* field is used to tie related events together. Currently, this field
    is used only when a file is renamed. When this happens, an `IN_MOVED_FROM` event
    is generated for the directory from which the file is renamed, and then an `IN_MOVED_TO`
    is generated for the directory to which the file is renamed. (If a file is given
    a new name within the same directory, then both events occur for the same directory.)
    These two events will have the same unique value in their *cookie* field, thus
    allowing the application to associate them.
  prefs: []
  type: TYPE_NORMAL
- en: When an event occurs for a file within a monitored directory, the *name* field
    is used to return a null-terminated string that identifies the file. If the event
    occurs for the monitored object itself, then the *name* field is unused, and the
    *len* field will contain 0.
  prefs: []
  type: TYPE_NORMAL
- en: The *len* field indicates how many bytes are actually allocated for the *name*
    field. This field is necessary because there may be additional padding bytes between
    the end of the string stored in *name* and the start of the next *inotify_event*
    structure contained in the buffer returned by *read()* (see [Figure 19-2](ch19.html#an_input_buffer_containing_three_inotify
    "Figure 19-2. An input buffer containing three inotify_event structures")). The
    length of an individual *inotify* event is thus *sizeof(struct inotify_event)
    + len*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the buffer passed to *read()* is too small to hold the next *inotify_event*
    structure, then *read()* fails with the error `EINVAL` to warn the application
    of this fact. (In kernels before 2.6.21, *read()* returned 0 for this case. The
    change to the use of an `EINVAL` error provides a clearer indication that a programming
    error has been made.) The application could respond by performing another *read()*
    with a larger buffer. However, the problem can be avoided altogether by ensuring
    that the buffer is always large enough to hold at least one event: the buffer
    given to *read()* should be at least *(sizeof(struct inotify_event) + NAME_MAX
    + 1)* bytes, where `NAME_MAX` is the maximum length of a filename, plus one for
    the terminating null byte.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a larger buffer size than the minimum allows an application to efficiently
    retrieve multiple events with a single *read()*. A *read()* from an *inotify*
    file descriptor returns the minimum of the number of events that are available
    and the number of events that will fit in the supplied buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call *ioctl(fd, FIONREAD, &numbytes)* returns the number of bytes that are
    currently available to read from the *inotify* instance referred to by the file
    descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: The events read from an *inotify* file descriptor form an ordered queue. Thus,
    for example, it is guaranteed that when a file is renamed, the `IN_MOVED_FROM`
    event will be read before the `IN_MOVED_TO` event.
  prefs: []
  type: TYPE_NORMAL
- en: When appending a new event to the end of the event queue, the kernel will coalesce
    that event with the event at the tail of the queue (so that the new event is not
    in fact queued), if the two events have the same values for *wd*, *mask*, *cookie*,
    and *name*. This is done because many applications don’t need to know about repeated
    instances of the same event, and dropping the excess events reduces the amount
    of (kernel) memory required for the event queue. However, this means we can’t
    use *inotify* to reliably determine how many times or how often a recurrent event
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although there is a lot of detail in the preceding description, the *inotify*
    API is actually quite simple to use. [Example 19-1](ch19.html#using_the_inotify_api
    "Example 19-1. Using the inotify API") demonstrates the use of *inotify*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1. Using the *inotify* API
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The program in [Example 19-1](ch19.html#using_the_inotify_api "Example 19-1. Using
    the inotify API") performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *inotify_init()* to create an *inotify* file descriptor ![](figs/web/U001.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *inotify_add_watch()* to add a watch item for each of the files named in
    the command-line argument of the program ![](figs/web/U002.png). Each watch item
    watches for all possible events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute an infinite loop that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads a buffer of events from the *inotify* file descriptor ![](figs/web/U003.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the *displayInotifyEvent()* function to display the contents of each of
    the *inotify_event* structures within that buffer ![](figs/web/U004.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shell session demonstrates the use of the program in [Example 19-1](ch19.html#using_the_inotify_api
    "Example 19-1. Using the inotify API"). We start an instance of the program that
    runs in the background monitoring two directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we execute commands that generate events in the two directories. We begin
    by creating a file using *cat(1)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The above output produced by the background program shows that *read()* fetched
    a buffer containing two events. We continue by typing some input for the file
    and then the terminal *end-of-file* character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then rename the file into the other monitored directory. This results in
    two events, one for the directory from which the file moves (watch descriptor
    1), and the other for the destination directory (watch descriptor 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These two events share the same *cookie* value, allowing the application to
    link them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a subdirectory under one of the monitored directories, the mask
    in the resulting event includes the `IN_ISDIR` bit, indicating that the subject
    of the event is a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, it is worth repeating that *inotify* monitoring is not recursive.
    If the application wanted to monitor events in the newly created subdirectory,
    then it would need to issue a further *inotify_add_watch()* call specifying the
    pathname of the subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we remove one of the monitored directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last event, `IN_IGNORED`, was generated to inform the application that the
    kernel has removed this watch item from the watch list.
  prefs: []
  type: TYPE_NORMAL
- en: Queue Limits and `/proc` Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Queuing *inotify* events requires kernel memory. For this reason, the kernel
    places various limits on the operation of the *inotify* mechanism. The superuser
    can configure these limits via three files in the directory `/proc/sys/fs/inotify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max_queued_events`'
  prefs: []
  type: TYPE_NORMAL
- en: When *inotify_init()* is called, this value is used to set an upper limit on
    the number of events that can be queued on the new *inotify* instance. If this
    limit is reached, then an `IN_Q_OVERFLOW` event is generated and excess events
    are discarded. The *wd* field for the overflow event will have the value -1.
  prefs: []
  type: TYPE_NORMAL
- en: '`max_user_instances`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a limit on the number of *inotify* instances that can be created per
    real user ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`max_user_watches`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a limit on the number of watch items that can be created per real user
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Typical default values for these three files are 16,384, 128, and 8192, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Older System for Monitoring File Events: *dnotify*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux provides another mechanism for monitoring file events. This mechanism,
    known as *dnotify*, has been available since kernel 2.4, but has been made obsolete
    by *inotify*. The *dnotify* mechanism suffers a number of limitations compared
    with *inotify*:'
  prefs: []
  type: TYPE_NORMAL
- en: The *dnotify* mechanism provides notification of events by sending signals to
    the application. Using signals as a notification mechanism complicates application
    design ([Interprocess Communication with Signals](ch22.html#interprocess_communication_with_signals
    "Interprocess Communication with Signals")). It also makes the use of *dnotify*
    within a library difficult, since the calling program might change the disposition
    of the notification signal(s). The *inotify* mechanism doesn’t use signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monitoring unit of *dnotify* is a directory. The application is informed
    when an operation is performed on any file in that directory. By contrast, *inotify*
    can be used to monitor directories or individual files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to monitor a directory, *dnotify* requires the application to open
    a file descriptor for that directory. The use of file descriptors causes two problems.
    First, because it is busy, the file system containing the directory can’t be unmounted.
    Second, because one file descriptor is required for each directory, an application
    can end up consuming a large number of file descriptors. Because *inotify* doesn’t
    use file descriptors, it avoids these problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information provided by *dnotify* about file events is less precise than
    that provided by *inotify*. When a file is changed inside a monitored directory,
    *dnotify* tells us that an event has occurred, but doesn’t tell us which file
    was involved in the event. The application must determine this by caching information
    about the directory contents. Furthermore, *inotify* provides more detailed information
    than *dnotify* about the type of event that has occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some circumstances, *dnotify* doesn’t provide reliable notification of file
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further information about *dnotify* can be found under the description of the
    `F_NOTIFY` operation in the *fcntl(2)* manual page, and in the kernel source file
    `Documentation/dnotify.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux-specific *inotify* mechanism allows an application to obtain notifications
    when events (files are opened, closed, created, deleted, modified, renamed, and
    so on) occur for a set of monitored files and directories. The *inotify* mechanism
    supersedes the older *dnotify* mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a program that logs all file creations, deletions, and renames under
    the directory named in its command-line argument. The program should monitor events
    in all of the subdirectories under the specified directory. To obtain a list of
    all of these subdirectories, you will need to make use of *nftw()* ([File Tree
    Walking: *nftw()*](ch18.html#file_tree_walking_colon_nftw_open_parent "File Tree
    Walking: nftw()")). When a new subdirectory is added under the tree or a directory
    is deleted, the set of monitored subdirectories should be updated accordingly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
