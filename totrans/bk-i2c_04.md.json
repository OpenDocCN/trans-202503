["```\n// Listing3-1.ino\n//\n// Software-based I2C controller device for\n// the Teensy 3.2.\n//\n// Copyright 2020, Randall Hyde.\n// All rights reserved.\n// Released under Creative Commons 4.0.\n\n#include <arduino.h>\n\n// I2C address of the SparkFun MCP4725 I2C-based\n// digital-to-analog converter.\n\n#define MCP4725_ADDR 0x60\n#define ADS1115_ADDR 0x48\n\n// Pins on the Teensy 3.2 to use for the\n// software SCL and SDA lines:\n\n❶ #define SCL 0\n#define SDA 1\n\n// digitalWriteFast is a Teensy-specific function. Change\n// to digitalWrite for standard Arduino.\n\n❷ #define pinWrite digitalWriteFast \n```", "```\n// Listing3-1.ino (cont.): \n//\n// Pin set functions.\n//\n// setSCL-\n//\n// Sets the SCL pin high (1) by changing the pin mode to\n// input and relying on the I2C bus pullup resistor to\n// put a 1 on the bus.\n\n❶ void setSCL( void )\n{\n    pinMode( SCL, INPUT );\n}\n\n// clrSCL-\n// \n// Sets the SCL pin low by changing the pin mode to output and\n// writing a 0 to the pin. This will pull down the SCL line.\n\n❷ void clrSCL( void )\n{\n    pinMode( SCL, OUTPUT );\n    pinWrite( SCL, 0 );\n}\n\n// setSDA, clrSDA-\n// \n// Same as setSCL and clrSCL except they set/clr the SDA line.\n\n❸ void setSDA( void )\n{\n    pinMode( SDA, INPUT );\n}\n\n❹ void clrSDA( void )\n{\n    pinMode( SDA, OUTPUT );\n    pinWrite( SDA, 0 );\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Reading the SCL and SDA pins.\n//\n// readSCL-\n// \n// Reads SCL pin until it gets the same value twice in\n// a row. This is done to filter noise.\n\n❶ inline byte readSCL( void )\n{\n    byte first;\n    byte second;\n    do\n    {\n        first = digitalRead( SCL );\n        second = digitalRead( SCL );\n    }while( first != second );\n\n    return first;\n}\n\n❷ // readSDA-\n// \n// Reads SDA pin until it gets the same value twice in\n// a row. This is done to filter noise.\n\ninline byte readSDA( void )\n{\n    byte first;\n    byte second;\n    do\n    {\n        first = digitalRead( SDA );\n        second = digitalRead( SDA );\n ❸ }while( first != second );\n    return first;\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Setting the start condition on the SCL and SDA lines.\n//\n// setStartCond-\n//\n// First checks to see if the bus is being used, which requires\n// a full 10 usec. If the bus is being used by some other bus\n// controller, this function returns false.\n//\n// If the bus is not being used, this function issues a start\n// condition for 5 usec (SDA = 0, SCL = 1) and then raises SDL\n// in preparation for an address byte transmission. If it\n// successfully sends a start condition, this code returns true.\n//\n// Postcondition:\n//     SDA and SCL will both be low if this function is \n//     successful. They will be unaffected if this function \n//     returns false.\n\n❶ int setStartCond( void )\n{\n    byte bothPins;\n\n    pinMode( SDA, INPUT ); // Going to be reading pins\n    pinMode( SCL, INPUT );\n    bothPins = readSDA() && readSCL();\n\n  ❷ delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n    bothPins &= readSDA() && readSCL();\n    delayMicroseconds(1);\n bothPins &= readSDA() && readSCL();\n    if( bothPins )\n    {\n        // Both pins have remained high for around 10 usec\n        // (one I2C clock period at 100 kHz). Chances\n        // are, the bus isn't currently being used.\n        // Go ahead and signal the start condition\n        // by setting SDA = 0.\n\n      ❸ clrSDA();\n        delayMicroseconds( 4 );\n        clrSCL();\n        return 1; // In theory, this code has the bus\n\n    }\n    return 0;     // Bus is busy\n\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Outputting a stop condition on the SCL and SDA lines.\n//\n// setStopCond-\n//\n// Generates an end-of-transmission stop sequence.\n//\n// Precondition: \n//     SCL must be low when this is called.\n// Postcondition: \n//     SCL and SDA will be high.\n\n❶ void setStopCond( void )\n{\n    clrSDA();               // Initialize for stop condition\n    delayMicroseconds( 1 ); // Give SDA time to go high\n    setSCL();\n    while( !readSCL() )\n    {\n        // Clock stretching-\n        //\n        // Wait while the peripheral is holding the clock\n        // line low.\n    }\n    delayMicroseconds( 4 ); // SCL = 1, SDA = 0 for 5 usec\n    setSDA();               // Signal stop condition\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Waiting for the stop condition to occur.\n//\n// waitForStop-\n//\n// If the bus is busy when this controller\n// tries to use the I2C bus, this code\n// must wait until a stop condition occurs\n// before trying to use the bus again.\n//\n// Stop condition is:\n//     SCL is high.\n//     SDA goes from low to high.\n\nvoid waitForStop( void )\n{\n    setSCL();   // Just make sure these are high;\n    setSDA();   // they already should be\n\n    do\n    {\n\n        while( !(readSCL() && !readSDA()) )\n        {\n                // Wait until the SCL line is high\n                // and the SDA line is low\n        }\n\n        // Stop condition might have begun. Wait\n        // for the data line to go high while\n // the SCL line remains high:\n\n        while( !readSDA() && readSCL() )\n        {\n                // Wait for data line to go high\n        }\n\n        // Is the SCL line still high?\n        // If not, you are just getting\n        // some data and the code needs to \n        // repeat until SCL is high again.\n\n    }while( !readSCL() );\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Transmitting a single bit on the I2C bus.\n//\n// sdaOut-\n//\n// bit: \n//     Bit to transmit.\n//     Transmits a single bit over the SDA/SCL lines.\n//\n// Returns:\n//     1: If successful.\n//     0: If arbitration failure or other error.\n//\n// Note: \n//     Caller is responsible for setting SCL and SDA\n//     high if there is an arbitration fault.\n\nint sdaOut( byte bit )\n{\n    bit = !!bit;    // Force 0/1\n\n    // Take SCL low so you can write to the\n    // data line. Wait until SCL is actually\n    // low before proceeding:\n\n  ❶ clrSCL();\n    while( readSCL() );\n\n    // Set the SDA line appropriately:\n\n  ❷ if( bit )\n    {\n setSDA();\n    }\n    else\n    {\n        clrSDA();\n    }\n\n    // Wait for 1/2 of the I2C clock period\n    // while SCL is low:\n\n  ❸ delayMicroseconds( 3 );\n\n    // Check to see if the value put on\n    // the SDA line can be read back. The code\n    // needed to delay before this call in order \n    // to allow signal time to rise on the\n    // SDA line.\n\n  ❹ if( readSDA() != bit )\n    {\n        // If the bit just written does not\n        // match the bit just read, then\n        // the code must have written a 1 and\n        // some other controller has written\n        // a 0 to the SDA line. In this\n        // case, the controller loses the \n        // arbitration test.\n\n        return 0;\n    }\n\n    // Raise the SCL line to indicate to the\n    // peripheral that the data is valid:\n\n  ❺ setSCL();\n\n    // Must hold SCL line high for 5 usec:\n\n    delayMicroseconds( 4 );\n\n    // Clock stretching or synchronization\n    // is handled here. Wait for the SCL\n    // line to go high (it can be held\n    // low by the peripheral or by another\n    // controller):\n\n  ❻ while( !readSCL() )\n    {\n        // Wait for SCL to go high\n    }\n\n    // Return success\n\n    return 1;\n}\n```", "```\n// Listing3-1.ino (cont.):\n//\n// Transmitting a byte on the I2C bus.\n//\n// xmitByte-\n//\n// Transmits a byte across the I2C bus.\n//\n// Returns:\n//     1: If ACK received after the transmission.\n//     0: If NAK received after the transmission or \n//        if there was bus contention (and this code\n//        has to give up the bus).\n//\n// Precondition:  \n//     SCL must be low.\n//\n// Postcondition:\n//     If arbitration failure, SDA and SCL will \n//     both be high (to avoid conflicts with some \n//     other controller).\n//\n// If successful:\n//     SCL will be low.\n\nint xmitByte( byte xmit )\n{\n  ❶ int result = sdaOut( xmit & 0x80 ); // MSB first!\n    if( result )\n result = sdaOut( xmit & 0x40 ); // Bit 6\n    if( result )\n        result = sdaOut( xmit & 0x20 ); // Bit 5\n    if( result )\n        result = sdaOut( xmit & 0x10 ); // Bit 4\n    if( result )\n        result = sdaOut( xmit & 0x8 );  // Bit 3\n    if( result )\n        result = sdaOut( xmit & 0x4 );  // Bit 2\n    if( result )\n        result = sdaOut( xmit & 0x2 );  // Bit 1\n    if( result )\n        result = sdaOut( xmit & 0x1 );  // Bit 0\n\n    if( result )\n    {\n        // And now the code must wait for \n        // the acknowledge bit:\n\n      ❷ clrSCL();\n        delayMicroseconds( 1 );\n        pinMode( SDA, INPUT );  // It's an input\n        delayMicroseconds( 3 ); // 1/2 clock cycle\n\n        // Raise the clock line and wait for it\n        // to go high, which also handles clock\n        // stretching and synchronization.\n\n        setSCL();               // Raise clock line\n        while( !readSCL() );\n\n        // Note that the clock line is high, so\n        // this code can read the SDA bit (acknowledge).\n\n        delayMicroseconds( 3 ); // Data valid for 5 usec\n        result = readSDA();\n\n      ❸ clrSCL();               // Exit with SCL = 0\n        while( readSCL() );\n        return !result;\n    }\n\n    // If there is an arbitration failure,\n    // then try to transmit a 1 bit while the\n    // other controller transmits a 0 bit.\n    // The 0 bit always wins, so this function \n    // sets SDA and SCL to 1 to avoid creating \n    // other problems for the other controller.\n\n    setSCL();\n    setSDA();\n    return 0;   // Arbitration failure\n}\n```", "```\n// Listing3-1.ino (cont.): \n// \n// Transmitting a sequence of bytes on the I2C bus.\n//\n// xmitBytes-\n//\n// Transmit a block of bytes (in write mode)\n// via the I2C bus. adrs is the I2C device\n// address. bytes is the array of bytes\n// to transmit (after the address byte).\n// cnt is the number of bytes to transmit\n// from the bytes array. addStop is true\n// if this function is to add a stop condition\n// at the end of the transmission.\n//\n// Note that, including the address byte,\n// this function actually transmits cnt + 1\n// bytes over the bus.\n\nint xmitBytes\n(\n    byte adrs,\n    byte bytes[],\n    int cnt,\n    int addStop\n)\n{\n    int result;\n\n    // Send the start condition.\n\n    result = setStartCond();\n    if( result )\n    {\n        // If bus was not in use, transmit\n        // the address byte:\n\n        result = xmitByte( adrs << 1 );\n        if( result )\n        {\n            // If there wasn't bus contention,\n            // ship out the bytes (as long as\n // bus contention does not occur):\n\n            for( int i=0; i < cnt; ++i )\n            {\n                result = xmitByte( bytes[i] );\n                if( !result ) break;\n            }\n        }\n        // If the transmission was correct to this\n        // point, transmit the stop condition.\n        // Note: if addStop() is false, don't send a \n        // stop condition after this transmission\n        // because a repeated start is about\n        // to happen.\n\n        if( result && addStop )\n        {\n            setStopCond();\n        }\n    }\n    return result;\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Receiving a single bit on the I2C bus.\n//\n// sdaIn-\n//\n// Retrieves a single bit from the SDA line.\n\nbyte sdaIn( void )\n{\n\n    // Take SCL low before writing to the\n    // data line. Wait until SCL is actually\n    // low before proceeding:\n\n    clrSCL();\n while( readSCL() );\n\n    // Wait for 1/2 clock period for \n    // the peripheral to put the data\n    // on the SDA line:\n\n    delayMicroseconds( 4 );\n\n    // Bring the clock line high.\n\n    setSCL();\n\n    // Wait until it actually goes high\n    // (stretching or syncing might be\n    // happening here).\n\n    while( !readSCL() );\n\n    // Wait for 1/2 of the I2C clock period\n    // while SCL is high:\n\n    delayMicroseconds( 3 );\n\n    // Read the data from the SDA line:\n\n    byte input = readSDA();\n\n    // Hold SCL line high for the\n    // remainder of this 1/2\n    // clock period:\n\n    delayMicroseconds( 2 );\n\n    // Return result.\n\n    return input;\n}\n```", "```\n// Listing3-1.ino (cont.):\n//\n// Receiving a byte on the I2C bus.\n//\n// rcvByte-\n//\n// Receives a byte from the I2C bus.\n//\n// Precondition:  \n//    SCL must be low.\n// Postcondition: \n//    SCL will be low.\n\nbyte rcvByte( void )\n{\n    setSDA();           // Before reading inputs\n    byte result = sdaIn()  7;\n    result |= sdaIn() << 6;\n    result |= sdaIn() << 5;\n    result |= sdaIn() << 4;\n    result |= sdaIn() << 3;\n    result |= sdaIn() << 2;\n    result |= sdaIn() << 1;\n    result |= sdaIn();\n\n    // Generate the ACK bit:\n\n    clrSCL();\n    while( readSCL() ); // Wait until it's low\n    delayMicroseconds( 2 );\n    clrSDA();\n    delayMicroseconds( 2 );\n    setSCL();\n    while( !readSCL() )\n    {\n        // Wait until SCL goes high (could be\n        // waiting for stretching or syncing).\n    }\n    delayMicroseconds( 4 );\n\n    // Leave SCL low for the next byte\n    // or the beginning of the stop\n    // condition:\n\n    clrSCL();\n    return result;\n\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Receiving a sequence of bytes on the I2C bus.\n\nint rcvBytes( byte adrs, byte bytes[], int cnt, int addStop )\n{\n int result;\n\n    // Send the start condition.\n\n    result = setStartCond();\n    if( result )\n    {\n        // If bus was not in use, transmit\n        // the address byte:\n\n        result = xmitByte( (adrs << 1) | 1 );\n        if( result )\n        {\n            // Read the specified number of\n            // bytes from the bus:\n\n            for( int i=0; i < cnt; ++i )\n            {\n                bytes[i] = rcvByte();\n            }\n        }\n\n        // If no errors at this point, transmit\n        // the stop condition.\n        // Note: if addStop is false, don't send\n        // a stop condition after this transmission\n        // because a repeated start is about\n        // to happen.\n\n        if( result && addStop )\n        {\n            setStopCond();\n        }\n    }\n    return result;\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Arduino setup() function for Listing3-1.ino.\n//\n// Standard Arduino initialization code:\n\nvoid setup( void )\n{\n    pinMode( SCL, INPUT ); // Begin with SCL/SDA = 1\n    pinMode( SDA, INPUT );\n\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"teensyTest\" );\n}\n```", "```\n// Listing3-1.ino (cont.): \n//\n// Arduino main loop() function for Listing3-1.ino.\n//\n// Arduino main loop:\n\nvoid loop( void )\n{\n    static  int     result;\n    static  word    adcValue;\n    static  byte    bytes[16];\n\n    // Read a 12-bit value from\n    // an Adafruit ADS1115 breakout\n    // board. The following configuration\n    // is for:\n    //\n    // * AIN[0]\n    // * 0-4.096 V operation\n    // * 1600 samples/second\n    // * Disabled comparator\n\n    adcValue    = 0;\n    bytes[0]    = 1;        // Point at config reg\n    bytes[1]    = 0xc2;     // MSB of config\n    bytes[2]    = 0x03;     // LSB of config\n\n    // adcValue = ADS1115.readADC_SingleEnded( 0 );\n    // Serial.print( \"ADC: \");\n    // Serial.println( adcValue, 16 );\n\n    result  = xmitBytes( ADS1115_ADDR, bytes, 3, true );\n    if( result )\n    {\n    // Point at the conversion register. Note that\n    // this is a repeated start condition command\n    // but ends with a stop condition.\n\n        bytes[0] = 0;\n        result = xmitBytes( ADS1115_ADDR, bytes, 1, true );\n\n        // Read the ADC value from the ADS1115.\n\n if( result )\n        {\n            // This really should go into a loop\n            // testing bit 16 of the config (status)\n            // register, but this is easier:\n\n            delay( 1 );\n\n            result = rcvBytes( ADS1115_ADDR, bytes, 2, true );\n            if( result )\n            {\n                adcValue = (bytes[0] << 8) | bytes[1];\n            }\n        }\n    }\n\n    // Start by writing 64 (0x40) to\n    // the DAC register (command byte\n    // which states that the next two\n    // bytes go into the DAC register).\n\n    bytes[0] = 64;\n\n    // The next two bytes to write are the\n    // 12 bits of the DAC value. The HO\n    // 4 bits are put in the first byte\n    // and the LO 8 bits appear in the\n    // second byte.\n\n    float volts = (((float) adcValue) * 4.096 / 32768.0 );\n    Serial.print( \"Volts: \" ); Serial.print( volts, 3 );\n    adcValue    = (word) (volts * 65536.0/5);\n    bytes[1]    = (adcValue >> 8) & 0xff;\n    bytes[2]    = (adcValue & 0xf0);\n\n    // Transmit the data to the DAC IC:\n\n    if( !xmitBytes( MCP4725_ADDR, bytes, 3, true ) )\n    {\n        // If there was an arbitration failure,\n        // wait for a start condition to come along.\n\n        waitForStop();\n    }\n    Serial.println();\n    delay( 100 );\n\n}\n```", "```\n// Listing3-2.ino\n// \n// Software-based I2C peripheral device for\n// the Teensy 3.2.\n//\n// Copyright 2020, Randall Hyde.\n// All rights reserved.\n// Released under Creative Commons 4.0.\n\n#include <arduino.h>\n\n// Pins on the Teensy 3.2 to use for the\n// software SCL and SDA lines:\n\n#define SCL 0\n#define SDA 1\n\n// PeriphAddress is the address of this PeripheralAddress.\n\n#define PeriphAddress (0x50)\n#define PeripheralAddress ((PeriphAddress) << 1)\n\n// digitalWriteFast is a Teensy-specific function. Change\n// to digitalWrite for standard Arduino.\n// Likewise, digitalReadFast changes to digitalRead for\n// standard Arduino.\n\n#define pinWrite digitalWriteFast\n#define pinRead  digitalReadFast\n```", "```\n// Listing3-2.ino (cont):  \n// \n// Pin control functions.\n//\n// setSCL-\n// \n// Sets the SCL pin high (1) by changing the pin mode\n// to input and relying on the I2C bus pullup resistor\n// to put a 1 on the bus.\n\n❶ void setSCL( void )\n{\n    pinMode( SCL, INPUT );\n}\n\n// clrSCL-\n//\n// Sets the SCL pin low. Changes the pin mode to output and\n// writes a 0 to the pin to pull down the SCL line. Used\n// mainly for clock stretching.\n\n❷ void clrSCL( void )\n{\n    pinMode( SCL, OUTPUT );\n    pinWrite( SCL, 0 );\n}\n\n// setSDA, clrSDA-\n//\n// Same as setSCL and clrSCL except they set or clr the SDA line.\n\n❸ void setSDA( void )\n{\n    pinMode( SDA, INPUT );\n}\n\n❹ void clrSDA( void )\n{\n    pinMode( SDA, OUTPUT );\n    pinWrite( SDA, 0 );\n}\n\n❺ // readSCL-\n//\n// Reads SCL pin until it gets the same value twice in\n// a row. This is done to filter noise.\n\ninline byte readSCL( void )\n{\n    byte first;\n    byte second;\n    do\n    {\n        first = pinRead( SCL );\n        second = pinRead( SCL );\n    }while( first != second );\n    return first;\n}\n\n❻ // readSDA-\n//\n// Reads SDA pin until it gets the same value twice in\n// a row. This is done to filter noise.\n\ninline byte readSDA( void )\n{\n    byte first;\n    byte second;\n    do\n    {\n first = pinRead( SDA );\n        second = pinRead( SDA );\n    }while( first != second );\n    return first;\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Transmitting a single bit on the I2C bus.\n//\n// sdaOut-\n//\n//     bit: Bit to transmit.\n//     Transmits a single bit over the SDA/SCL lines.\n//\n// Returns:\n//     1: If successful.\n//     0: If arbitration failure or other error.\n\nvoid sdaOut( byte bit )\n{\n    unsigned long time;\n\n    bit = !!bit;    // Force 0/1\n\n    // Wait until SCL is low.\n    // It's okay to change SDA\n    // when SCL is low:\n\n  ❶ while( readSCL() );\n\n    // Set the SDA line appropriately.\n\n  ❷ if( bit )\n    {\n        setSDA();\n    }\n    else\n    {\n        clrSDA();\n    }\n\n    // Wait for the SCL line to go high and\n    // then back to low. After that, release\n    // the SDA line by setting it to 1.\n\n  ❸ while( !readSCL() );\n\n time = micros() + 15;\n    while( readSCL() )\n    {\n        // If stuck in this loop for\n        // more than 15 usec, then bail.\n        // Need a timeout so it doesn't\n        // hold SDA low for an extended\n        // period of time.\n\n      ❹ if( micros() > time ) break;\n    }\n\n    // Release the SDA line by setting it high.\n\n    setSDA();\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Transmitting a byte on the I2C bus.\n//\n// xmitByte-\n//\n// Transmits a whole byte by call sdaOut\n// eight times.\n\nvoid xmitByte( byte xmit )\n{\n    unsigned long time;\n\n  ❶ sdaOut( xmit & 0x80 );\n    sdaOut( xmit & 0x40 );\n    sdaOut( xmit & 0x20 );\n    sdaOut( xmit & 0x10 );\n    sdaOut( xmit & 0x8 );\n    sdaOut( xmit & 0x4 );\n    sdaOut( xmit & 0x2 );\n    sdaOut( xmit & 0x1 );\n\n // The controller will generate the ACK\n    // bit. This code will ignore it.\n    // However, it does have to wait for\n    // the clock pulse (low->high->low)\n    // to come along.\n\n  ❷ while( readSCL() ); // Wait for low clock\n\n    time = micros()+25;\n    while( !readSCL() )\n    {\n        // Wait until SCL goes high (could be\n        // waiting for stretching or syncing).\n        // Bail if there is a timeout, though.\n\n      ❸ if( micros() > time ) break;\n    }\n\n    // Okay, SCL is (probably) high; wait for it\n    // to go low again:\n\n    while( readSCL() );\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Receiving a single bit on the I2C bus.\n//\n// sdaIn-\n//\n// Retrieves a single bit from the SDA line.\n// Note: no timeout on the loops because this\n// code doesn't mess with the SDA line.\n\nbyte sdaIn( void )\n{\n    byte input;\n\n  ❶ while( readSCL() );\n\n    // Wait until the SCL line is high.\n    // That is when data will be valid\n    // on the SDA line:\n\n  ❷ while( !readSCL() );\n\n // Wait for a small amount of time for the\n    // controller's data to be stabilized\n    // on the SDA line:\n\n  ❸ delayMicroseconds( 1 );\n\n    // Read the data from the SDA line:\n\n    input = readSDA();\n\n    // Return result:\n\n    return input;\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Receiving a byte on the I2C bus.\n//\n// rcvByte-\n//\n// Receives a byte from the I2C bus.\n\nbyte rcvByte( void )\n{\n    unsigned long time;\n\n    pinMode( SDA, INPUT );\n\n    // Read 8 bits from the SDA line:\n\n  ❶ byte result7 = sdaIn() << 7;\n    byte result6 = sdaIn() << 6;\n    byte result5 = sdaIn() << 5;\n    byte result4 = sdaIn() << 4;\n    byte result3 = sdaIn() << 3;\n    byte result2 = sdaIn() << 2;\n    byte result1 = sdaIn() << 1;\n    byte result0 = sdaIn();\n    byte result = result7\n        |   result6\n        |   result5\n        |   result4\n        |   result3\n        |   result2\n        |   result1\n        |   result0;\n\n // Generate the ACK bit.\n    // Wait for the SCL line to go low,\n    // pull SDA low, then wait for the\n    // SCL line to go high and low:\n\n    while( readSCL() );\n\n  ❷ clrSDA();\n    time = micros()+25;\n    while( !readSCL() )\n    {\n\n    // Wait until SCL goes high (could be\n    // waiting for stretching or syncing).\n    // Bail if there is a timeout, though.\n\n        if( micros() > time ) break;\n    }\n\n    // Okay, SCL is (probably) high; wait for it to go\n    // low again and then release the SDA line:\n\n    while( readSCL() );\n    setSDA(); // Set SDA high (releases SDA)\n\n    return result;\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Waiting for a start condition, while allowing other work.\n//\n// waitForStart-\n//\n// Wait until a start condition arrives.\n// The peripheral address byte will follow.\n//\n// Start condition is:\n//\n//    SCL is high.\n//    SDA goes from high to low.\n//\n// An address byte immediately follows the\n// start condition. Read it. Return\n// one of the following values:\n//\n// Negative:\n//           Address does not match or\n//           start condition yet to be\n//           received.\n//        0: Address match, R/W = 0 (W)\n//        1: Address match, R/W = 1 (R)\n//\n// This function is a state machine that\n// rapidly returns. It has the following\n// states:\n//\n// -1: Waiting for SCL and SDA to both\n//     be high.\n// -2: SCL and SDA are both high, waiting\n//     for SDA to go low.\n\nint waitForStart( void )\n{\n    static int  state = -1;\n    byte        sdaVal;\n    byte        sclVal;\n\n    switch( state )\n    {\n        case -1:\n\n            // Wait until the SCL line is high and the\n            // SDA line is high.\n\n            if( readSCL() && readSDA() )\n            {\n                state = -2;\n            }\n            return state;\n\n        case -2:\n\n            // Start condition may have begun. Wait\n            // for the data line to go low while\n            // the SCL line remains high:\n\n            sdaVal = readSDA();\n            sclVal = readSCL();\n            if( !sdaVal && sclVal )\n            {\n                break;\n            }\n\n            // If code sees anything other than\n            // SCL = 1 and SDA = 1 at this point,\n            // it has to reset the state machine\n            // to -1.\n\n            if( !( sclVal && sdaVal ) )\n            {\n state = -1;\n            }\n            return state;\n\n        // Just a fail-safe case:\n\n        default:\n            state = -1;\n            return state;\n\n    }   // Switch\n\n    // Reset the state machine for the next invocation:\n\n    state = -1;\n\n    // Okay, there is a start condition.\n    // Read the address byte.\n\n    byte address = rcvByte();\n    if( (address & 0xFE) == PeripheralAddress )\n    {\n        return address & 1;\n    }\n    return -1;  // Not our address\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Standard Arduino setup() function.\n//\n// Standard Arduino initialization code:\n\nvoid setup( void )\n{\n    pinMode( SCL, INPUT ); // Begin with SCL/SDA = 1\n    pinMode( SDA, INPUT );\n\n    Serial.begin( 9600 );\n delay( 1000 );\n    Serial.println( \"teensy Peripheral Test\" );\n}\n```", "```\n// Listing3-2.ino (cont.): \n//\n// Standard Arduino loop() function.\n//\n// Arduino main loop:\n\nvoid loop( void )\n{\n    static byte memory = 0; // Holds I2C memory byte\n\n    // Wait for a start condition to arrive.\n    // If not a start condition yet, just\n    // keep looping.\n    //\n    // Assumption: Arduino code outside this\n    // loop takes less than about 5 usec\n    // to execute. If that is not the case,\n    // then waitForStart() should be called\n    // in a hard loop to continuously poll\n    // for a start condition.\n\n    int gotStart = waitForStart();\n\n  ❶ if( gotStart == 0 )         // Write request\n    {\n        // On write operation, read the next byte\n        // coming from the I2C bus and store it\n        // into the memory location.\n\n        memory = rcvByte();\n\n        Serial.print( \"Memory=\" );\n        Serial.println( memory, 16 );\n    }\n  ❷ else if( gotStart == 1 )    // Read request\n    {\n        // On a read request, transmit the\n        // value in memory across the I2C bus.\n\n        xmitByte( memory );\n        Serial.print( \"Transmitted \" );\n        Serial.println( memory );\n\n    }\n ❸ // else: not of interest to us.\n\n}\n```", "```\n// Listing3-3.ino\n//\n// Software-based I2C test program.\n\n#include <Wire.h>\n#define LED 13\n\nvoid setup( void )\n{\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"test.ino\" );\n    Wire.begin();\n    pinMode( LED, OUTPUT );\n}\n\nvoid loop( void )\n{\n    static byte value = 0;\n\n    digitalWrite( LED, 0 );\n    Serial.print( \"Writing: \" );\n    Serial.print( value, 16 );\n    Wire.beginTransmission( 0x50 );\n    Wire.write( value );\n    Wire.endTransmission();\n    delay( 250 );\n\n    digitalWrite( LED, 1 );\n    Wire.requestFrom( 0x50, 1 );\n    while( Wire.available() )\n {\n        byte data = Wire.read();\n        Serial.print( \", read=\" );\n        Serial.print( data, 16 );\n        Serial.print( \", value=\" );\n        Serial.print( value, 16 );\n    }\n    Serial.println();\n    ++value;\n    delay( 250 );\n}\n```"]