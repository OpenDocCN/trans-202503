- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: MOVING THROUGH THE CORPORATE WINDOWS NETWORK**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**穿越企业Windows网络**'
- en: '*An inefficient virus kills its host. A clever virus stays with it.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个低效的病毒会杀死它的宿主。一个聪明的病毒会与宿主同生共死。*'
- en: –James Lovelock
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –詹姆斯·洛夫洛克
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: In this chapter, we’ll explore the architecture of large corporate Windows networks,
    which typically use a server called a *domain controller* to manage and secure
    the network’s machines. As you’ll soon see, if an attacker can compromise the
    domain controller, the network is theirs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨大型企业Windows网络的架构，这些网络通常使用一种叫做*域控制器*的服务器来管理和保护网络中的机器。如你所见，如果攻击者能够攻破域控制器，那么网络就属于他们了。
- en: After setting up our own mini corporate environment with a Linux equivalent
    to the Windows domain controller and single Windows desktop, I’ll demonstrate
    how an attacker might exploit the protocols used by Windows devices in many corporate
    environments. I’ll begin by showing you how to extract password hashes and session
    keys directly from a Windows machine or by intercepting network traffic. Then,
    I’ll show how to use these session keys and password hashes to access other machines
    in the network by exploiting vulnerabilities in various networking protocols.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置了一个与Windows域控制器和单台Windows桌面相对应的Linux环境后，我将演示攻击者如何利用Windows设备在许多企业环境中使用的协议。我将首先展示如何直接从Windows机器或通过拦截网络流量提取密码哈希值和会话密钥。然后，我将展示如何利用这些会话密钥和密码哈希值，通过利用各种网络协议中的漏洞，访问网络中的其他机器。
- en: The process and protocols we discuss here aren’t exclusively used by Windows
    systems. For example, the Kerberos authentication protocol is used on Linux, too.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的过程和协议并非Windows系统专用。例如，Kerberos身份验证协议也在Linux中使用。
- en: '**Creating a Windows Virtual Lab**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建Windows虚拟实验室**'
- en: We’ll be attacking Windows systems, so we must first create a virtual lab containing
    a Windows machine. Windows is proprietary, but Microsoft offers trial versions
    that you can download for free at *[https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise](https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise)*.
    Once you’ve downloaded the ISO image, create a new virtual machine in VirtualBox,
    just like you did in [Chapter 1](ch01.xhtml#ch1). Give your machine 32GB of hard
    drive space and 4GB of RAM. Then follow the default setup instructions to complete
    the installation, making sure to create a user account with administrative privileges.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将攻击Windows系统，因此必须首先创建一个包含Windows机器的虚拟实验室。Windows是专有的，但微软提供了可以免费下载的试用版本，网址是*[https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise](https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise)*。下载ISO镜像后，在VirtualBox中创建一个新虚拟机，就像你在[第1章](ch01.xhtml#ch1)中做的那样。给你的虚拟机分配32GB的硬盘空间和4GB的RAM。然后按照默认的安装指引完成安装，确保创建一个具有管理员权限的用户账户。
- en: '**Extracting Password Hashes with Mimikatz**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Mimikatz提取密码哈希值**'
- en: The process of extracting hashes on Windows is similar to the process on Linux
    ([Chapter 14](ch14.xhtml#ch14)), except that instead of extracting hashes from
    the file */etc/shadow*, we retrieve them by dumping the memory of the *Local Security
    Authority Subsystem Service (LSSAS)* process. The LSSAS process contains password
    hashes and security tokens and manages the process of authenticating and communicating
    with the domain controller.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上提取哈希值的过程类似于Linux上的过程（见[第14章](ch14.xhtml#ch14)），不同之处在于，我们不是从文件*/etc/shadow*中提取哈希值，而是通过转储*本地安全认证子系统服务（LSSAS）*进程的内存来获取哈希值。LSSAS进程包含密码哈希值和安全令牌，并管理身份验证和与域控制器通信的过程。
- en: As with Linux, you’ll need administrative privileges to do this. Although you
    can use searchsploit to find local privilege escalation vulnerabilities for Windows,
    for simplicity we’ll assume that you’ve compromised a user with administrative
    privileges. Still, it’s a good practice to keep a list of fresh privilege escalation
    vulnerabilities in your toolbox for use in real tests or attacks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux一样，你需要管理员权限才能执行此操作。虽然你可以使用searchsploit来查找Windows的本地权限提升漏洞，但为了简化起见，我们假设你已经获得了一个具有管理员权限的用户账户。尽管如此，将一份最新的权限提升漏洞清单放在工具箱里，在实际测试或攻击中使用，仍然是一个好习惯。
- en: To dump the credentials, we’ll use *mimikatz*, a program that contains a collection
    of tools to help us extract hashes from LSSAS process’s memory. You can manually
    dump a process’s memory by opening the task manager (CTRL-ALT-DELETE), right-clicking
    the process, and then selecting **Create dump file**; however, mimikatz automates
    this process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转储凭据，我们将使用*mimikatz*，这是一个包含多个工具的程序，帮助我们从LSSAS进程的内存中提取哈希值。你可以通过打开任务管理器（CTRL-ALT-DELETE），右键单击进程，然后选择**创建转储文件**来手动转储进程的内存；然而，mimikatz自动化了这个过程。
- en: On Kali Linux, you can download the precompiled executable at *[https://github.com/gentilkiwi/mimikatz/releases/](https://github.com/gentilkiwi/mimikatz/releases/)*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali Linux上，你可以在 *[https://github.com/gentilkiwi/mimikatz/releases/](https://github.com/gentilkiwi/mimikatz/releases/)*
    下载预编译的可执行文件。
- en: 'However, because the tool is so popular, many antivirus systems will detect
    it and Window’s signature detection algorithm will delete it immediately. Thus,
    you probably want to obfuscate the strings and the binary. Use Metasploitable’s
    `**msfencode**` command to encode the executable with SGN, as discussed in [Chapter
    10](ch10.xhtml#ch10). You can encode the mimikatz executable on Kali Linux by
    running the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于该工具非常流行，许多杀毒系统会检测到它，Windows的签名检测算法会立即删除它。因此，你可能需要混淆字符串和二进制文件。使用Metasploitable的`**msfencode**`命令使用SGN对可执行文件进行编码，正如在[第10章](ch10.xhtml#ch10)中讨论的那样。你可以通过在Kali
    Linux上运行以下命令来编码mimikatz可执行文件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you have an encoded version of mimikatz that you can download on the Windows
    machine. We can’t directly copy the encoded mimikatz executable from our Kali
    Linux virtual machine to our Windows virtual machine, so we transfer it over the
    network, as in previous chapters, by starting a web server on the Kali Linux machine
    and downloading the file onto the the Windows machine. First, start a Python web
    server on Kali Linux:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个编码版本的mimikatz，可以在Windows机器上下载。我们无法直接从Kali Linux虚拟机将编码后的mimikatz可执行文件复制到Windows虚拟机，因此我们像前几章一样通过网络传输它，通过在Kali
    Linux机器上启动一个Web服务器，然后将文件下载到Windows机器。首先，在Kali Linux上启动一个Python Web服务器：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Access the server and download *mimikatz_encoded.exe* onto your Windows virtual
    machine. Now let’s extract the password hashes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 访问服务器并将*mimikatz_encoded.exe*下载到你的Windows虚拟机上。现在让我们提取密码哈希值。
- en: 'Remember that you must have admin privileges to extract these hashes. To double-check
    that your account on the Windows machine has these privileges, use the keyboard
    shortcut Win-X, and then press A to open the Power-Shell console with admin privileges.
    Then, use the command `**whoami /groups**` to see your groups:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你必须具有管理员权限才能提取这些哈希值。为了确认你在Windows机器上的帐户是否具有这些权限，可以使用快捷键Win-X，然后按A以管理员权限打开Power-Shell控制台。然后，使用命令`**whoami
    /groups**`查看你的组：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Great! You’ve confirmed that this user has administrative privileges ➊. Now
    navigate to the folder containing mimikatz and run it by entering the following
    command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！你已经确认该用户具有管理员权限➊。现在导航到包含mimikatz的文件夹，并通过输入以下命令运行它：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Debug privileges is a security policy that allows a process like mimikatz to
    attach the debugger to the LSSAS process and extract its memory contents. Run
    the following command to instruct mimikatz to request debug privileges:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调试权限是一种安全策略，允许像mimikatz这样的进程将调试器附加到LSSAS进程并提取其内存内容。运行以下命令以指示mimikatz请求调试权限：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If mimikatz successfully gets debug privileges, you will see an `OK` message.
    For best results, run the mimikatz process with administrative privileges; this
    is because a process with administrative privileges will also be able to get debug
    privileges.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果mimikatz成功获取调试权限，你将看到一个`OK`消息。为了获得最佳效果，请以管理员权限运行mimikatz进程；这是因为具有管理员权限的进程也能够获取调试权限。
- en: 'The mimikatz tool supports several modules. For example, the `sekurlsa` module
    allows you to extract hashes from memory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: mimikatz工具支持多个模块。例如，`sekurlsa`模块允许你从内存中提取哈希值：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that mimikatz has extracted the SHA-1 and Windows NT LAN Manager hashes
    of the passwords ➊ ➋. In some cases, the LSSAS process will also contain plaintext
    passwords ➌. Tools like Credential Guard can help protect the LSSAS process from
    credential dumping attacks like these. However, even in those cases, mimikatz
    can still capture credentials that the user enters after the system has been compromised.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到mimikatz已经提取了密码的SHA-1和Windows NT LAN Manager哈希值➊ ➋。 在某些情况下，LSSAS进程还会包含明文密码➌。像Credential
    Guard这样的工具可以帮助保护LSSAS进程免受这些凭据转储攻击。然而，即使在这些情况下，mimikatz仍然可以捕获用户在系统被攻破后输入的凭据。
- en: 'The mimikatz tool is also included in the Metasploit Framework; however, Metasploit
    won’t always have the most up-to-date version. Still, you could dump the password
    hashes on the Windows system by running the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: mimikatz 工具也包含在 Metasploit Framework 中；然而，Metasploit 并不总是拥有最新版本。但你仍然可以通过运行以下命令来导出
    Windows 系统上的密码哈希：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have the password hashes, you could try to crack them. Alternatively,
    you could use them to log in to other machines on the corporate network by exploiting
    the Windows NT LAN Manager protocol in a pass-the-hash attack.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了密码哈希，你可以尝试破解它们。或者，你也可以利用这些哈希值通过在 pass-the-hash 攻击中利用 Windows NT LAN
    Manager 协议来登录到公司网络上的其他机器。
- en: '**Passing the Hash with NT LAN Manager**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 NT LAN Manager 传递哈希**'
- en: '*NT LAN Manager (NTLM)* is a Windows protocol that allows users to authenticate
    with other machines on the network using their password’s hash. [Figure 15-1](ch15.xhtml#ch15fig1)
    shows what happens when a user logs in to a machine and attempts to access an
    NTLM-shared folder on a server.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*NT LAN Manager (NTLM)* 是一种 Windows 协议，允许用户使用其密码哈希与网络上的其他机器进行身份验证。[图 15-1](ch15.xhtml#ch15fig1)
    展示了用户登录到一台机器并尝试访问服务器上共享的 NTLM 文件夹时发生的情况。'
- en: '![image](../images/ch15fig01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig01.jpg)'
- en: '*Figure 15-1: An overview of the authentication process using NTLM*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：使用 NTLM 进行身份验证的概览*'
- en: Several messages are exchanged during this process. When a user logs into a
    machine with their username and password, that machine stores the username and
    a hash of the password ➊ and then usually deletes the plaintext password. When
    the user wants to access the server or network folder, the operating system sends
    the server that user’s username. The server responds by sending a 16-byte nonce
    called a *challenge message*. Then, the client encrypts the nonce with the user’s
    password hash and sends it back to the server ➋. This encrypted nonce is commonly
    referred to as the *challenge-response*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中会交换几个消息。当用户使用用户名和密码登录机器时，机器会存储用户名和密码的哈希值 ➊，然后通常会删除明文密码。当用户想要访问服务器或网络文件夹时，操作系统会将该用户的用户名发送给服务器。服务器回应并发送一个
    16 字节的 nonce，称为 *挑战消息*。然后，客户端使用用户的密码哈希对 nonce 进行加密，并将其发送回服务器 ➋。这个加密后的 nonce 通常被称为
    *挑战响应*。
- en: The server then forwards the username, the challenge-response, and the challenge
    message to the domain controller. The domain controller is a server responsible
    for storing information about users and managing the network’s security policy.
    Once the domain controller receives the challenge-response ➌, it will verify it
    by looking up the user’s password hash in the database. It will then use this
    hash to decrypt the nonce in the challenge-response. If the nonces match, the
    domain controller will send the server a message telling the server that it has
    authenticated the user and the server will then grant the user access.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器将用户名、挑战响应以及挑战消息转发给域控制器。域控制器是一个负责存储用户信息并管理网络安全策略的服务器。一旦域控制器收到挑战响应➌，它会通过查找数据库中的用户密码哈希来验证该响应。然后，它将使用这个哈希值解密挑战响应中的
    nonce。如果 nonce 匹配，域控制器将向服务器发送一条消息，告知服务器它已成功认证用户，服务器将授予用户访问权限。
- en: Notice that the protocol never uses the plaintext version of the user’s password.
    This means that if an attacker can obtain a hash of the user’s password, they
    don’t need to crack the hash to access another machine. They can simply use the
    hash extracted from the machine to encrypt the challenge-response and authenticate
    with domain controller. We call this type of attack a *pass-the-hash attack*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，协议从未使用用户密码的明文版本。这意味着，如果攻击者能够获取到用户密码的哈希值，他们无需破解该哈希即可访问其他机器。他们可以直接使用从机器中提取的哈希值来加密挑战响应并与域控制器进行身份验证。我们称这种攻击为
    *pass-the-hash 攻击*。
- en: 'To perform a pass-the-hash attack, use mimikatz to load one of the hashes you
    extracted from the LSSAS process:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 pass-the-hash 攻击，使用 mimikatz 加载从 LSSAS 进程中提取的其中一个哈希值：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Replace the `<User>`, `<Domain>`, and `<NTLM Hash>` values with the extracted
    username, domain, and NTLM password hash.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<User>`、`<Domain>` 和 `<NTLM Hash>` 替换为提取的用户名、域和 NTLM 密码哈希值。
- en: 'Now you can impersonate a user and access their resources. For example, if
    our virtual environment contained another Windows machine, you could connect to
    and access it by using the `psexec` tool to run a PowerShell terminal on the other
    machine:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以冒充用户并访问他们的资源。例如，如果我们的虚拟环境中包含另一台 Windows 机器，你可以通过使用 `psexec` 工具在另一台机器上运行
    PowerShell 终端来连接并访问它：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can download `psexec` for free from Microsoft.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Microsoft 免费下载`psexec`。
- en: '**Exploring the Corporate Windows Network**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**探索公司 Windows 网络**'
- en: Once an attacker is inside a network, what should they do next? On corporate
    networks, they might learn about the network’s devices and the associated security
    policies by listening for network traffic or querying the domain controller.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者进入网络，他们接下来应该做什么？在企业网络中，他们可能通过监听网络流量或查询域控制器来了解网络的设备及相关的安全策略。
- en: Large corporations must manage security policies across thousands of devices,
    so they usually organize machines into a hierarchical structure consisting of
    organizational units, domains, trees, and forests. An *organizational unit (OU)*
    is the lowest level in the hierarchy, and consists of a grouping of users, security
    groups, and computers. A system administrator is free to choose the structure
    of OUs. For example, an administrator of a large bank may choose to create an
    OU for each location, such as for a Virginia branch, a California branch, and
    a Florida branch. Nested within each OU, the administrator might create two other
    OUs, one to contain the tellers’ machines and the other for staff accounts. This
    grouping allows system administrators to assign different privileges to each OU.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司必须管理跨越数千台设备的安全策略，因此它们通常将机器组织成一个层级结构，包含组织单位、域、树和森林。*组织单位 (OU)* 是层级结构中的最低级别，由用户、安全组和计算机的分组组成。系统管理员可以自由选择
    OU 的结构。例如，一家大型银行的管理员可能会选择为每个位置创建一个 OU，如弗吉尼亚分行、加利福尼亚分行和佛罗里达分行。在每个 OU 内，管理员可能会创建另外两个
    OU，一个用于包含出纳机，另一个用于员工账户。这样的分组允许系统管理员为每个 OU 分配不同的权限。
- en: 'A collection of OUs is called a *domain*, which are grouped into trees with
    parent and child domains. Trees are, in turn, grouped into a forest. A trust relationship
    is established between the domains in the same tree, thus allowing authorized
    users to move between domains. For example, a system administrator might want
    to keep machines at the bank headquarters isolated from those in the bank branches.
    Thus, the administrator might create two separate domains: `company.headquarters`
    and `company.branches`. Later, if the bank acquires a smaller bank that already
    has a domain infrastructure, the system administrator might connect the domains
    by making the acquired bank’s domain a child of the bank’s parent domain, `company.branches`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一组 OU 被称为*域*，这些域按树的结构分为父域和子域。树又被分组成一个森林。在同一树中的域之间建立信任关系，从而允许授权用户在域之间移动。例如，系统管理员可能希望将银行总部的机器与银行分行的机器隔离开来。因此，管理员可能会创建两个独立的域：`company.headquarters`
    和 `company.branches`。稍后，如果银行收购了一家已经有域基础设施的小银行，系统管理员可能会通过将收购银行的域设为主银行域 `company.branches`
    的子域来连接这些域。
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) shows an organization with one forest, two
    trees, three domains, and seven OUs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-2](ch15.xhtml#ch15fig2)展示了一个组织结构，包括一个森林、两棵树、三个域和七个组织单位 (OU)。'
- en: '![image](../images/ch15fig02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig02.jpg)'
- en: '*Figure 15-2: Visualizing the structure of a corporate network with multiple
    domains*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：可视化具有多个域的公司网络结构*'
- en: 'The domain controller manages these domains and their security policies and
    runs four key services: the *DNS service*, the *Active Directory Service (ADS)*,
    the *Lightweight Directory Access Protocol (LDAP)* service, and the *Kerberos*
    authentication service. Let’s begin by looking at the DNS Service.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 域控制器管理这些域及其安全策略，并运行四个关键服务：*DNS 服务*、*活动目录服务 (ADS)*、*轻量级目录访问协议 (LDAP)* 服务和*Kerberos*
    认证服务。我们从查看 DNS 服务开始。
- en: '**Attacking the DNS Service**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击 DNS 服务**'
- en: The DNS service is a key part of the domain controller. It allows machines in
    the domain to find the IP addresses of other machines on the network. For example,
    a file server might contain a shared network folder called *//Patient Records/*.
    When a user enters *//PatientRecords/* into their file explorer, the operating
    system will communicate with the domain controller’s DNS server to find the file
    server’s IP address. If the DNS service contains an entry for *//PatientRecords/*,
    it will respond with the corresponding IP address. The file explorer will then
    attempt to connect to that server and access the files (assuming that it has permission
    to do so).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务是域控制器的关键部分。它允许域中的计算机找到网络上其他计算机的IP地址。例如，一个文件服务器可能包含一个共享的网络文件夹，叫做*//Patient
    Records/*。当用户在文件资源管理器中输入*//PatientRecords/*时，操作系统将与域控制器的DNS服务器通信，以找到该文件服务器的IP地址。如果DNS服务包含*//PatientRecords/*的条目，它将返回相应的IP地址。然后，文件资源管理器将尝试连接到该服务器并访问文件（前提是它有权限这么做）。
- en: However, if the DNS lookup fails—for example, if the user mistypes the name,
    perhaps forgetting the *s* and typing *//PatientRecord/*, instead—the operating
    system will fall back on a less secure protocol called *Link-Local Multicast Name
    Resolution (LLMNR)* to discover a machine on the network that can respond to the
    request. LLMNR is a broadcast protocol, so any machine on the network can respond
    to the request. This allows attackers to respond with a malicious message, an
    attack called *LLMNR poisoning*. [Figure 15-3](ch15.xhtml#ch15fig3) shows the
    steps in an LLMNR poisoning attack.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果DNS查询失败——例如，如果用户输入错误的名称，可能忘记了*s*，而输入了*//PatientRecord/*——操作系统将回退到一个不太安全的协议，称为*链路本地多播名称解析（LLMNR）*，以发现网络中可以响应请求的机器。LLMNR是一种广播协议，因此网络中的任何机器都可以响应请求。这使得攻击者可以通过恶意信息进行响应，这种攻击被称为*LLMNR中毒*。[图
    15-3](ch15.xhtml#ch15fig3)展示了LLMNR中毒攻击的步骤。
- en: '![image](../images/ch15fig03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig03.jpg)'
- en: '*Figure 15-3: How DNS failures could result in insecure LLMNR lookups*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：DNS失败如何导致不安全的LLMNR查询*'
- en: The victim generates a DNS request, and this request is sent to the domain controller
    ➊. The domain controller’s DNS service tells the victim that it couldn’t find
    the requested entry ➋, so the victim machine resorts to the LLMNR protocol. It
    broadcasts a message asking if any machines have the *//PatientRecord/* folder
    ➌. The attacker will respond with a message to the effect of, “I can help, but
    you need to authenticate. Send me your NTLM hash” ➍. If the victim’s machine responds
    to the message, you’ll have captured the user’s NTLM password hash.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者生成DNS请求，该请求被发送到域控制器 ➊。域控制器的DNS服务告诉受害者找不到请求的条目 ➋，于是受害者的机器转而使用LLMNR协议。它广播一条消息，询问是否有机器拥有*//PatientRecord/*文件夹
    ➌。攻击者将以类似“我可以帮忙，但你需要进行身份验证。请发送给我你的NTLM哈希”这样的消息进行回应 ➍。如果受害者的机器响应了该消息，那么你就捕获到了用户的NTLM密码哈希。
- en: If LLMNR fails, the client will fall back to the less secure protocol Netbios
    Name Service (NBT-NS). LLMNR and NBT-NS aren’t the only protocols that are vulnerable
    to this type of poisoning attack. Suppose that an attacker performs an ARP spoofing
    attack and pretends to be the DNS server. They could then capture the NTLM hash
    from correct DNS lookups.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LLMNR失败，客户端将回退到不太安全的协议Netbios名称服务（NBT-NS）。LLMNR和NBT-NS并不是唯一易受这种类型的中毒攻击的协议。假设攻击者执行了ARP欺骗攻击，并伪装成DNS服务器。他们随后可以捕获正确DNS查询中的NTLM哈希值。
- en: 'You can use the `Responder` tool to perform these attacks. It lets you maliciously
    respond to various network protocols and capture the associated hashes. You can
    get a copy of `Responder` by cloning its GitHub repository to your Kali Linux
    virtual machine:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Responder`工具执行这些攻击。它允许你恶意响应各种网络协议并捕获相关的哈希值。你可以通过将其GitHub仓库克隆到你的Kali Linux虚拟机来获取`Responder`：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start `Responder` by running it on your Kali Linux virtual machine. Then, enter
    a dummy folder, such as *//PatientRecords/*, in the Windows virtual machine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Kali Linux虚拟机上运行`Responder`启动该工具。然后，在Windows虚拟机中输入一个虚拟文件夹，比如*//PatientRecords/*：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-I` option specifies the interfaces it will listen and respond on, and
    `-v` says to generate verbose output. You’ll find the NTLMv2 hash that was captured
    during the attack ➊. You can now crack this hash using the techniques discussed
    in [Chapter 12](ch12.xhtml#ch12) or use it in a pass-the-hash attack.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-I`选项指定了它将监听并响应的接口，`-v`表示生成详细输出。你将看到在攻击过程中捕获的NTLMv2哈希值 ➊。现在你可以使用[第12章](ch12.xhtml#ch12)中讨论的技术来破解该哈希值，或将其用于“传递哈希”攻击。'
- en: '**Attacking Active Directory and LDAP Services**'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击 Active Directory 和 LDAP 服务**'
- en: The second service hosted by the domain controller is the Active Directory service,
    which is a database of objects in the domain. These objects include users, security
    policies, and shared machines, such as printers and desktops.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 域控制器托管的第二个服务是 Active Directory 服务，这是一个包含域中对象的数据库。这些对象包括用户、安全策略和共享机器，如打印机和桌面。
- en: The user objects contain information such as usernames and password hashes.
    Security group objects contain information on the privileges afforded to that
    group as well as a member attribute that lists users associated with that security
    group. By storing all user information in a single repository, you can give users
    access to multiple machines without having to store their usernames and passwords
    on these devices. This is useful in places like libraries, banks, or corporate
    offices where users often share machines and printers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对象包含诸如用户名和密码哈希等信息。安全组对象包含该组所赋予的权限信息，以及列出与该安全组关联的用户的成员属性。通过将所有用户信息存储在一个单一的存储库中，您可以让用户访问多台机器，而无需在这些设备上存储他们的用户名和密码。这在图书馆、银行或公司办公室等地方非常有用，因为用户通常共享机器和打印机。
- en: Other operating systems besides Windows offer their own directory services.
    These services, such as the 389 Directory Server and Apple Open Directory, use
    custom protocols and queries. However, requiring operating systems to implement
    every directory access protocol is infeasible. Instead, they often implement the
    LDAP, a standard protocol that devices can use to interface with most directory
    services. The LDAP service translates LDAP-style queries into the query format
    supported by the backend directory service. This means that clients have to support
    only the LDAP protocol because the LDAP service abstracts the backend directory
    service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Windows，其他操作系统也提供了自己的目录服务。这些服务，如 389 目录服务器和 Apple Open Directory，使用自定义的协议和查询。然而，要求操作系统实现每个目录访问协议是不可行的。因此，它们通常实现
    LDAP，一个标准协议，设备可以使用该协议与大多数目录服务进行交互。LDAP 服务将 LDAP 风格的查询转换为后端目录服务支持的查询格式。这意味着客户端只需支持
    LDAP 协议，因为 LDAP 服务将后端目录服务进行了抽象。
- en: The LDAP protocol represents data in the form of a *directory information tree
    (DIT)*. [Figure 15-4](ch15.xhtml#ch15fig4) shows a DIT for an example version
    of the *[bank.com](http://bank.com)* domain.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 协议以 *目录信息树（DIT）* 的形式表示数据。[图 15-4](ch15.xhtml#ch15fig4) 显示了一个示例版本的 *[bank.com](http://bank.com)*
    域的 DIT。
- en: '![image](../images/ch15fig04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig04.jpg)'
- en: '*Figure 15-4: A directory information tree*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：目录信息树*'
- en: 'At the root of the DIT is the domain. The value `dc=bank, dc=com` is the distinguished
    name, which uniquely identifies a component in the tree. (In this case, `dc` doesn’t
    represent the domain controller, but rather refers to a domain component. A little
    confusing, I know, but this is standard notation.) Here, the domain *[bank.com](http://bank.com)*
    has two domain components: *bank* and *com*. Below the domain are two OUs. One
    of these represents machines and the other OU represents users. The distinguished
    name for the person with the user id Monique is `dc=bank, dc=com, ou=Staff, ou=Manager,
    uid=Monique`. In this way, in addition to uniquely identifying a component, the
    distinguished name also identifies the path to the object in the tree.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: DIT 的根部是域。值 `dc=bank, dc=com` 是区分名，用于唯一标识树中的一个组件。（在此，`dc` 并不代表域控制器，而是指域组件。可能有些令人困惑，但这是标准符号。）在这里，域
    *[bank.com](http://bank.com)* 有两个域组件：*bank* 和 *com*。在域下有两个组织单位（OU）。其中一个代表机器，另一个
    OU 代表用户。具有用户 ID Monique 的人的区分名是 `dc=bank, dc=com, ou=Staff, ou=Manager, uid=Monique`。通过这种方式，除了唯一标识一个组件外，区分名还标识了树中对象的路径。
- en: '***Writing an LDAP Query Client***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写 LDAP 查询客户端***'
- en: LDAP can be a helpful tool for gaining access to the domain controller. If we
    gain access to the domain controller, which stores the credentials for all users
    on the network and can also create user accounts, we control the network. If we
    can control the domain controller, we can create our own administrator account
    and log in to any machine we please.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 可以成为访问域控制器的有用工具。如果我们能够访问存储所有用户凭据并且可以创建用户帐户的域控制器，就能够控制网络。如果我们控制了域控制器，就可以创建自己的管理员帐户并登录到任何我们想要的机器。
- en: However, the credentials we extract from some machine on the network might not
    necessarily grant us access to the domain controller. Instead, we’ll need to move
    from machine to machine, extracting more privileged credentials until we find
    some that give us the access we need. To efficiently do this, you need to understand
    the structure of the network you’re attacking.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们从网络上的某台机器提取的凭据可能未必能够授权我们访问域控制器。相反，我们需要从一台机器跳到另一台机器，提取更多的特权凭据，直到找到能给我们所需访问权限的凭据。为了高效完成此操作，你需要了解你攻击的网络结构。
- en: 'Attackers can learn about the structure of the corporate network by querying
    the LDAP server on the domain controller. For example, an attacker might execute
    queries to the effect of: “How many machines are on the network?”, “How many users
    are there?”, or “Which users are members of the administrator group?” By executing
    queries like these, the attacker can map the network and discover a path to a
    domain controller, a process known as *enumeration*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过查询域控制器上的LDAP服务器来了解公司网络的结构。例如，攻击者可能会执行类似“网络上有多少台机器？”、“有多少个用户？”或“哪些用户是管理员组的成员？”这样的查询。通过执行这些查询，攻击者可以绘制网络图，并发现通向域控制器的路径，这一过程被称为*枚举*。
- en: 'Let’s make these ideas of LDAP queries and enumeration more concrete by writing
    a Python program that will query an LDAP server. This LDAP client, which we’ll
    call *info_probe.py*, will retrieve a list of all the users in the network. We’ll
    use the `ldap3` Python library to develop our client, so install it by using `pip3`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个Python程序来使LDAP查询和枚举的概念更加具体。这个LDAP客户端，我们将其命名为*info_probe.py*，将检索网络中所有用户的列表。我们将使用`ldap3`
    Python库来开发这个客户端，因此请使用`pip3`安装它：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we’ll need to connect to the LDAP service using a process called binding.
    LDAP supports three types of binds: *anonymous binds*, *password binds*, and *Simple
    Authentication and Security Layer (SASL) binds*. An anonymous bind doesn’t require
    any authentication, so we’ll start by doing an anonymous bind and then modify
    our program to do a password bind, which allows us to authenticate using a username
    and password. We’ll discuss SASL binds when we look at the Kerberos protocol later
    in the chapter.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用名为绑定的过程来连接LDAP服务。LDAP支持三种类型的绑定：*匿名绑定*、*密码绑定*和*简单认证和安全层（SASL）绑定*。匿名绑定不需要任何身份验证，因此我们首先进行匿名绑定，然后修改程序进行密码绑定，这样我们就可以使用用户名和密码进行身份验证。稍后在本章中，当我们讨论Kerberos协议时，将介绍SASL绑定。
- en: 'To avoid having to set up our own LDAP server, we’ll interact with a public
    demo server called *ipa.demo1.freeipa.org*, available at *[https://www.freeipa.org/page/Demo](https://www.freeipa.org/page/Demo)*.
    Alternatively, you can download the FreeIPA virtual machine and add it to your
    environment. The FreeIPA virtual machine is the Linux equivalent to a Windows
    domain controller, and we’ll use it as the domain controller in our environment.
    The web-based option is easier to set up, but your DIT may change during testing
    as other people have access to the server. Regardless, I’ll use the web-based
    option in the examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免自己搭建LDAP服务器，我们将与一个名为*ipa.demo1.freeipa.org*的公共演示服务器进行交互，网址为*[https://www.freeipa.org/page/Demo](https://www.freeipa.org/page/Demo)*。另外，你可以下载FreeIPA虚拟机并将其添加到你的环境中。FreeIPA虚拟机是Linux版本的Windows域控制器，我们将把它作为我们环境中的域控制器。基于Web的选项更容易设置，但在测试过程中，你的DIT可能会发生变化，因为其他人也能访问该服务器。无论如何，我将在示例中使用基于Web的选项：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We begin by creating a server object with information about the server to which
    we want to connect. We set the `get_info` option to `ALL` so that we can read
    as much information as possible about the server once we’ve connected. Then we’ll
    create a connection object and call the `bind` method. This connection to LDAP
    uses an anonymous bind. If our anonymous bind was successful, we’ll print information
    about the server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含目标服务器信息的服务器对象。我们将`get_info`选项设置为`ALL`，这样一旦连接成功，我们就能读取尽可能多的服务器信息。然后，我们将创建一个连接对象并调用`bind`方法。这个LDAP连接使用匿名绑定。如果我们的匿名绑定成功，我们将打印关于服务器的信息。
- en: 'Run *info_probe.py* to check whether we can connect to the server:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*info_probe.py*检查我们是否能够连接到服务器：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you can successfully connect to the server, you’ll see the output shown here.
    This server information will contain lots of great details, including the LDAP
    server’s version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够成功连接到服务器，你将看到这里显示的输出。该服务器信息将包含许多详细内容，包括LDAP服务器的版本。
- en: 'Now let’s query the LDAP server to discover more about the network. Most LDAP
    servers will block unauthorized users from submitting queries, so let’s modify
    *info_probe.py* so that it authenticates with the LDAP service. We’ll use the
    password bind authentication method to connect to the LDAP server and search for
    all of the users in the domain. The LDAP server has three default accounts, and
    the password for each one is **Secret123**. However, you can also use the NTLM
    password hash you extracted from memory to authenticate:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查询LDAP服务器，了解更多关于网络的信息。大多数LDAP服务器会阻止未经授权的用户提交查询，因此我们需要修改*info_probe.py*，使其能够通过LDAP服务进行身份验证。我们将使用密码绑定身份验证方法连接到LDAP服务器，并搜索域中的所有用户。LDAP服务器有三个默认帐户，每个帐户的密码是**Secret123**。然而，你也可以使用从内存中提取的NTLM密码哈希进行身份验证：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First, we connect to the LDAP server, supplying the user’s distinguished name
    as the `user` parameter. Notice the name specifies the path from the leaf to the
    root of the DIT. We also set the `auto_bind` option to true. The `ldap3` library
    will perform the bind operation as soon as it initiates the connection, saving
    us an extra line of code. Then, we specify our search query. The `search_base`
    argument represents the starting node in our DIT, and we set it to the root node.
    The second option allows you to filter the results. We’ll include person objects
    only. Filters can also include logical operators. For example, the following filter
    returns person objects with an attribute that starts with `Test: & (objectClass=person)
    (cn=Test*)`. Notice that the logical operation precedes the conditionals. This
    structure might be different from other query languages you’ve seen. Lastly, we
    specify the attributes to include.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们连接到LDAP服务器，提供用户的区别名作为`user`参数。注意，该名称指定了从叶节点到DIT根节点的路径。我们还将`auto_bind`选项设置为true。`ldap3`库将在初始化连接时执行绑定操作，这样我们就省去了额外的一行代码。接下来，我们指定搜索查询。`search_base`参数表示我们DIT中的起始节点，我们将其设置为根节点。第二个选项允许你筛选结果。我们只包括person对象。筛选器还可以包括逻辑运算符。例如，以下筛选器返回具有以`Test:`开头属性的person对象：`&
    (objectClass=person) (cn=Test*)`。注意，逻辑运算符位于条件之前。这个结构可能与你见过的其他查询语言不同。最后，我们指定要包含的属性。
- en: 'Run the Python program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python程序：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we see the four users contained in the DIT. Because the LDAP server is
    open, you and other users can modify the tree. When you run the query, you might
    notice some additional entries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到DIT中包含的四个用户。由于LDAP服务器是开放的，你和其他用户都可以修改树结构。当你运行查询时，可能会注意到一些额外的条目。
- en: View the network administrator panel by logging in to *[https://ipa.demo1.freeipa.org/](https://ipa.demo1.freeipa.org/)*
    with the username **admin** and the password **Secret123**. This panel is what
    the system administrator sees.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过登录到 *[https://ipa.demo1.freeipa.org/](https://ipa.demo1.freeipa.org/)*，使用用户名**admin**和密码**Secret123**查看网络管理员面板。这是系统管理员所看到的面板。
- en: '***Using SharpHound and Bloodhound for LDAP Enumeration***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用SharpHound和BloodHound进行LDAP枚举***'
- en: Various tools can automate the enumeration process. *Sharphound* collects information
    about the network by running LDAP queries, listening to network traffic, and using
    Windows APIs to extract information from machines on the network. You can download
    it from *[https://github.com/BloodHoundAD/SharpHound3/](https://github.com/BloodHoundAD/SharpHound3/)*
    After SharpHound has finished collecting information, it will output several JSON
    files that contain information on the users, groups, and machines on the network.
    We can then copy these files from the compromised machine into the Kali Linux
    virtual machine and feed them to the *BloodHound* visualization tool. Bloodhound
    allows attackers to query the data and visualize the paths (list of machines)
    that they can use to compromise the DC. [Figure 15-5](ch15.xhtml#ch15fig5) shows
    an illustration of a path.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 各种工具可以自动化枚举过程。*Sharphound* 通过运行LDAP查询、监听网络流量并使用Windows API从网络中的计算机提取信息来收集网络信息。你可以从
    *[https://github.com/BloodHoundAD/SharpHound3/](https://github.com/BloodHoundAD/SharpHound3/)*
    下载它。SharpHound收集完信息后，会输出几个JSON文件，包含关于网络中用户、组和机器的信息。然后，我们可以将这些文件从被攻陷的机器复制到Kali
    Linux虚拟机中，并将它们输入到*BloodHound*可视化工具中。BloodHound允许攻击者查询数据并可视化他们可以用来攻陷DC的路径（机器列表）。[图15-5](ch15.xhtml#ch15fig5)展示了一个路径的示意图。
- en: '![image](../images/ch15fig05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig05.jpg)'
- en: '*Figure 15-5: An illustration of a possible path*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-5：可能路径的示意图*'
- en: Say that Machine 1 is the machine you compromised. User Jane Jackson is logged
    in to this machine and has an active session. We can also see that Jane is a member
    of the Office Admin group, which has administrator access to the file server.
    This means that we can use Jane’s credentials to access the file server. We can
    also see that John Johnson has logged in to the file server and has an active
    session, and that John has administrator access to the domain controller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设机器1是你已经妥协的机器。用户Jane Jackson已登录此机器并有一个活跃的会话。我们还可以看到，Jane是Office Admin组的成员，该组拥有文件服务器的管理员访问权限。这意味着我们可以使用Jane的凭据访问文件服务器。我们还可以看到John
    Johnson已经登录文件服务器并有一个活跃的会话，且John具有域控制器的管理员访问权限。
- en: This means that we can compromise the domain controller by extracting Jane’s
    credentials and using using them in a pass-the-hash attack to get administrator
    access to the file server. Once we have administrator access to the file server
    we can extract John’s credentials and use them to gain access to the domain controller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过提取Jane的凭据并在传递哈希攻击中使用它们来妥协域控制器，从而获得文件服务器的管理员访问权限。一旦我们获得文件服务器的管理员权限，就可以提取John的凭据并使用它们访问域控制器。
- en: 'See Bloodhound’s documentation for more examples: *[https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html](https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html)*.
    You can also use other tools, such as windapsearch, to query the Active Directory
    service on the domain controller.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例请参阅Bloodhound的文档：*[https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html](https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html)*。你也可以使用其他工具，如windapsearch，来查询域控制器上的Active
    Directory服务。
- en: '**Attacking Kerberos**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击Kerberos**'
- en: 'The Kerberos protocol is a secure alternative to the NTLM protocol. To authenticate
    users who want to access network resources, Kerberos relies on two services: an
    authentication server and a ticket-granting service. [Figure 15-6](ch15.xhtml#ch15fig6)
    shows an overview of the Kerberos messages exchanged when a user requests access
    to a file server.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos协议是NTLM协议的安全替代方案。为了验证想要访问网络资源的用户，Kerberos依赖于两个服务：认证服务器和票据授予服务。[图15-6](ch15.xhtml#ch15fig6)展示了用户请求访问文件服务器时交换的Kerberos消息概览。
- en: '![image](../images/ch15fig06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch15fig06.jpg)'
- en: '*Figure 15-6: The Kerberos authentication process*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：Kerberos身份验证过程*'
- en: The client first initiates a connection to the authentication server and requests
    access to the ticket-granting service ➊. This plaintext message contains the user’s
    ID, the service ID, the user’s IP address, and the requested lifetime of the ticket-granting
    ticket. The authentication server will look up the user in the Active Directory
    service, and if the user exists, the authentication server will retrieve the user’s
    password hash. The user’s password hash will then be used as a symmetric key to
    encrypt the authentication server’s response. The authentication server and the
    user both have a copy of this hash, so only the user and the authentication server
    can decrypt the message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端首先发起与认证服务器的连接，并请求访问票据授予服务 ➊。此明文消息包含用户ID、服务ID、用户IP地址以及请求的票据授予票的生命周期。认证服务器将查找Active
    Directory服务中的用户，如果用户存在，认证服务器将检索该用户的密码哈希。然后，用户的密码哈希将作为对称密钥来加密认证服务器的响应。认证服务器和用户都拥有此哈希的副本，因此只有用户和认证服务器才能解密该消息。
- en: Next, the authentication server sends two messages, a response and a ticket-granting
    ticket ➋. Both of these messages are encrypted. The response, which is encrypted
    using the user’s password hash, contains the service ID, a timestamp, the lifetime
    of the session, and the session key the user will use to encrypt communications
    with the ticket-granting service. This message is equivalent to saying, “You’ve
    been authenticated. If you’re truly the user, you will be able to decrypt this
    message and extract the session key you can use to communicate securely with the
    ticket-granting service.” The second message (the ticket-granting ticket) is encrypted
    with the ticketgranting service’s secret key, meaning that only the ticket-granting
    service can read it. The message contains the user’s ID, the ticket-granting service’s
    ID, the time, the user’s IP address, the ticket-granting ticket’s lifetime, and
    the same session key shared with the client. This ticket is equivalent to the
    authentication server saying, “Show the ticket-granting service this ticket as
    proof that you have permission to talk to it. The service will know what to do
    with it.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，认证服务器发送两条消息，一条响应和一张票据授予票据 ➋。这两条消息都被加密。响应消息使用用户的密码哈希加密，包含服务 ID、时间戳、会话的生命周期和用户将用来加密与票据授予服务通信的会话密钥。这条消息相当于在说：“你已经通过身份验证。如果你真的是该用户，你将能够解密这条消息并提取你可以用来与票据授予服务安全通信的会话密钥。”第二条消息（票据授予票据）是用票据授予服务的密钥加密的，这意味着只有票据授予服务可以解密它。消息中包含用户的
    ID、票据授予服务的 ID、时间、用户的 IP 地址、票据授予票据的生命周期以及与客户端共享的相同会话密钥。这张票据相当于认证服务器在说：“把这张票据展示给票据授予服务，证明你有权限与它进行对话。服务会知道如何处理它。”
- en: The user decrypts the first message using their password hash and extracts the
    session key ➌. The user then encrypts their user ID and password hash using the
    session key. This is called the user authenticator. The user will attach the ticket-granting
    ticket as proof that it has permission to access the ticket-granting service,
    as well as a plaintext request including the service they wish to access (such
    as the file service) and the ticket’s requested lifetime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户使用其密码哈希解密第一条消息并提取会话密钥 ➌。然后，用户使用会话密钥加密他们的用户 ID 和密码哈希。这被称为用户认证器。用户将附加票据授予票据作为证明，表明其有权限访问票据授予服务，同时还会附上包括他们希望访问的服务（例如文件服务）和票据请求生命周期的明文请求。
- en: 'The ticket-granting service verifies the ticket-granting ticket by decrypting
    it with the ticket-granting service’s secret key ➍. The ticket-granting service
    then extracts the session key from the decrypted ticket and uses it to decrypt
    the user authenticator message and extract the user ID. It will then check the
    Active Directory service to see whether the user can access that service. If the
    user has permission to do so, the ticket-granting service will generate two messages:
    a response and a service ticket. The response, which is encrypted with the session
    key, contains the service ID (for instance, the ID of the file server), a timestamp,
    a lifetime, and a new filesystem session key that will be used to encrypt communications
    between the file server and the user. The second message is the service ticket,
    which is encrypted with the file server’s secret key so that only the file server
    can decrypt it. The service ticket contains the user ID, service ID, timestamp,
    and the new filesystem session key. This service ticket uniquely provides this
    user with access to a specific service.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 票据授予服务通过使用票据授予服务的密钥 ➍ 解密票据授予票据来验证它。票据授予服务然后从解密后的票据中提取会话密钥，并使用它来解密用户认证器消息并提取用户
    ID。接着，它将检查活动目录服务，查看用户是否有权限访问该服务。如果用户有权限，票据授予服务将生成两条消息：一条响应和一张服务票据。响应消息使用会话密钥加密，包含服务
    ID（例如文件服务器的 ID）、时间戳、生命周期以及一个新的文件系统会话密钥，该密钥将用于加密文件服务器和用户之间的通信。第二条消息是服务票据，它使用文件服务器的密钥加密，以确保只有文件服务器可以解密它。服务票据包含用户
    ID、服务 ID、时间戳和新的文件系统会话密钥。此服务票据唯一地为该用户提供对特定服务的访问权限。
- en: The user decrypts the response message, extracts the file server’s session key
    ”, and uses this key to encrypt a message requesting access to the file server.
    The user then sends the request and service ticket to the file server. Lastly,
    the server will follow the same process as the ticket-granting service ➏. It will
    first use its secret key to decrypt the service ticket and extract the session
    key, which it will then use to decrypt the user’s request message. If the file
    server can decrypt the message, it will authenticate the user and send an access-granted
    message encrypted with the session key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用户解密响应消息，提取文件服务器的会话密钥，并使用此密钥加密请求访问文件服务器的消息。用户随后将请求和服务票据发送给文件服务器。最后，服务器将按照与票据授予服务相同的流程进行处理➏。它将首先使用其秘密密钥解密服务票据并提取会话密钥，然后使用该密钥解密用户的请求消息。如果文件服务器能够解密消息，它将认证用户并发送使用会话密钥加密的访问授权消息。
- en: Is Kerberos secure? Notice that an attacker doesn’t need to have the user’s
    password hash to request a ticket-granting ticket. Suppose that an attacker sends
    the user’s ID to the authentication server. In that case, the server will respond
    with a ticket-granting ticket containing an encrypted session key. The attacker
    could then attempt to crack the ticket by using Hashcat to perform a dictionary-based
    attack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos安全吗？请注意，攻击者不需要拥有用户的密码哈希值就能请求票据授予票据。假设攻击者将用户ID发送到认证服务器，服务器将响应一个包含加密会话密钥的票据授予票据。攻击者然后可以使用Hashcat进行字典攻击来破解该票据。
- en: 'To prevent these attacks, modern Kerberos implementations require that requests
    include a timestamp encrypted with the user’s password hash. We refer to this
    extra check as *pre-authentication (pre-auth)*. But even with preauth present,
    you can use Metasploit modules to collect Kerberos usernames by performing a dictionary-based
    attack:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些攻击，现代Kerberos实现要求请求包括使用用户密码哈希加密的时间戳。我们将这一额外检查称为*预认证（pre-auth）*。但即使存在预认证，您仍然可以使用Metasploit模块通过执行字典攻击来收集Kerberos用户名：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Kerberos_enumuser` module will perform the first authentication step with
    the user IDs in the dictionary and then report information on the use; for example,
    if a user is present and whether pre-auth is required.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kerberos_enumuser`模块将使用字典中的用户ID执行第一个认证步骤，然后报告使用情况的信息；例如，用户是否存在，以及是否需要预认证。'
- en: Now that I’ve discussed the Kerberos protocol, let’s look at other ways to attack
    it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讨论了Kerberos协议，让我们看看其他攻击方式。
- en: '***The Pass-the-Ticket Attack***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传票攻击***'
- en: 'In a *pass-the-ticket* attack, a hacker manages to acquire a service ticket,
    which they can use to access services on the machine. To do this, they extract
    the response the authentication server sent, the ticket-granting ticket, and the
    user’s password hash from the LSSAS process on a local machine. The attacker decrypts
    the response using the user’s password hash and extracts the session key, which
    they then use to forge a new request for a service ticket. Once the attacker obtains
    the new service ticket, they can access other services or machines. Tools like
    mimikatz allow you to execute these types of attacks. Use your encoded version
    of mimikatz to extract the tickets from the LSSAS process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在*传票攻击*中，黑客设法获取了一个服务票据，利用该票据访问机器上的服务。为此，他们从本地机器上的LSSAS进程中提取认证服务器发送的响应、票据授予票据以及用户的密码哈希。攻击者使用用户的密码哈希解密响应并提取会话密钥，然后使用该密钥伪造新的服务票据请求。一旦攻击者获得新的服务票据，他们就可以访问其他服务或机器。像mimikatz这样的工具允许您执行这些类型的攻击。使用您编码后的mimikatz版本从LSSAS进程中提取票据：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Mimikatz outputs the ticket information to the terminal. It also writes each
    ticket to separate files with the *.kirbi* extension. The files will be placed
    in the same directory as the mimikatz executable. Select the ticket associated
    with the system that you want to access and load it into the memory of the LSSAS
    process by running the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Mimikatz将票据信息输出到终端。它还将每个票据写入带有*.kirbi*扩展名的单独文件。这些文件将被放置在与mimikatz可执行文件相同的目录中。选择与您要访问的系统相关的票据，并通过运行以下命令将其加载到LSSAS进程的内存中：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After it’s loaded, you should be able to access the system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，您应该能够访问系统。
- en: '***The Golden Ticket and DC Sync Attacks***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***金票和DC同步攻击***'
- en: Although we didn’t show it in our discussion of the Kerberos protocol, all messages
    are signed with the password hash associated with the *krbtgt* account, a special
    account on all domain controllers with a long and difficult-to-crack password
    that is automatically generated. However, suppose that an attacker could compromise
    the domain controller and steal the password hash of the krbtgt account. In that
    case, they could forge any ticket by signing it with the krbtgt account’s hash.
    An attacker could then create tickets that they could use years after they’ve
    compromised a system. This is why it is important to reset the krbtgt account’s
    password if you suspect there has been an attack. Because this attack allows an
    attacker to forge any ticket, at any time, it is called a *golden ticket* attack.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在讨论Kerberos协议时没有展示过，但所有消息都是使用与*krbtgt*账户关联的密码哈希进行签名的，krbtgt是所有域控制器上的一个特殊账户，具有长且难以破解的密码，并且是自动生成的。然而，假设攻击者能够攻破域控制器并窃取krbtgt账户的密码哈希，在这种情况下，他们可以通过使用krbtgt账户的哈希来伪造任何票证。攻击者随后可以创建他们可以在攻破系统多年后仍然使用的票证。这就是为什么如果怀疑发生了攻击，重置krbtgt账户的密码非常重要的原因。因为这种攻击允许攻击者在任何时候伪造任何票证，所以它被称为*金票*攻击。
- en: You’ll need the krbtgt account’s password hash to create a golden ticket. But
    how can you obtain the krbtgt password hash without directly compromising the
    domain controller? Well, when a network administrator adds a new domain controller
    to the network, the new domain controller asks existing domain controllers to
    send it a copy of their databases. This request allows the domain controllers
    to remain in sync. However, these databases also contain password hashes, including
    the krbtgt account’s password hash. By pretending to be a domain controller performing
    a sync operation, an attacker can steal the krbtgt account’s password hash. We
    call this attack a *DC sync* attack.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要krbtgt账户的密码哈希值来创建一个金票。但是，如何在不直接攻破域控制器的情况下获取krbtgt密码哈希值呢？当网络管理员将新的域控制器添加到网络时，新的域控制器会要求现有的域控制器发送它们的数据库副本。这个请求允许域控制器保持同步。然而，这些数据库也包含密码哈希值，包括krbtgt账户的密码哈希值。通过假装是正在执行同步操作的域控制器，攻击者可以窃取krbtgt账户的密码哈希值。我们称这种攻击为*DC同步*攻击。
- en: '*Impacket* is an amazing collection of Python programs that allows hackers
    to perform network attacks, including the DC sync attack. You can download it
    by cloning the impacket Git repository:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Impacket*是一个惊人的Python程序集合，它允许黑客执行网络攻击，包括DC同步攻击。你可以通过克隆Impacket的Git仓库来下载它：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Perform a DC sync attack by running the *secretsdump.py* Python program in
    the *impacket* folder you just cloned:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行你刚刚克隆的*impacket*文件夹中的*secretsdump.py* Python程序来执行DC同步攻击：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each line corresponds to a user’s password hashes. The line at ➊, represents
    the user krbtgt. All lines have the following structure: `uid:rid:lmhash: nthash`,
    where `uid` is the user’s id, `rid` is the relative identifier (a code that identifies
    a user’s role, such as 500 for an administrator), `lmhash` is the LAN manager
    hash, which is a hash that predates the NTLM hash, and `nthash` represents the
    NTLM hash. Because `lmhash` uses only seven case-insensitive characters, it’s
    easily cracked; however, it is included for legacy purposes.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应一个用户的密码哈希。➊处的那一行表示krbtgt用户。所有行的结构如下：`uid:rid:lmhash:nthash`，其中`uid`是用户的ID，`rid`是相对标识符（一个识别用户角色的代码，例如管理员的值是500），`lmhash`是LAN管理器哈希，它是NTLM哈希之前的哈希，而`nthash`代表NTLM哈希。由于`lmhash`仅使用七个不区分大小写的字符，因此很容易被破解；然而，它作为遗留用途被包含在内。
- en: 'Use `nthash` to create your golden ticket. The following command creates the
    ticket and loads it into memory so that it can be used in a pass-the-ticket attack:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nthash`来创建你的金票。以下命令创建票证并将其加载到内存中，以便可以在传递票证攻击中使用：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we included the `/ptt` (pass-the-ticket) flag, which tells mimikatz to
    associate the ticket with our current session. Now you can log in to any machine
    with your new admin ticket.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`/ptt`（传递票证）标志，这告诉mimikatz将票证与我们当前的会话关联。现在你可以使用新的管理员票证登录任何机器。
- en: '**Exercise: Kerberoasting**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习：Kerberoasting**'
- en: In the final exercise in this book, you’ll research and execute an attack on
    your own. The attack that you’ll execute is called *Kerberoasting*, which is a
    dictionary-based attack that attempts to crack the password hash used to encrypt
    the ticket-granting service. Some services are associated with normal users, and
    thus use regular passwords instead of computer-generated ones. Successfully cracking
    the ticket-granting service will give you the service’s password, which is the
    same as the user’s password.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一个练习中，你将自行研究并执行一个攻击。你将执行的攻击叫做*Kerberoasting*，这是一种基于字典的攻击，旨在破解用于加密票据授予服务的密码哈希。一些服务与普通用户相关联，因此使用的是常规密码，而非计算机生成的密码。成功破解票据授予服务将为你提供该服务的密码，这个密码与用户密码相同。
- en: 'Set up a Windows lab environment with a Windows desktop virtual machine and
    a Windows server to act as your domain controller. Next, try executing some attacks
    against it. To execute a Kerberoasting attack, use the *getuserspns.py* impacket
    script:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个Windows实验环境，包括一个Windows桌面虚拟机和一个Windows服务器，后者将充当域控制器。接下来，尝试对其执行一些攻击。要执行Kerberoasting攻击，请使用*getuserspns.py*
    impacket脚本：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
