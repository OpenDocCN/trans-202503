- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MOVING THROUGH THE CORPORATE WINDOWS NETWORK**
  prefs: []
  type: TYPE_NORMAL
- en: '*An inefficient virus kills its host. A clever virus stays with it.*'
  prefs: []
  type: TYPE_NORMAL
- en: –James Lovelock
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore the architecture of large corporate Windows networks,
    which typically use a server called a *domain controller* to manage and secure
    the network’s machines. As you’ll soon see, if an attacker can compromise the
    domain controller, the network is theirs.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up our own mini corporate environment with a Linux equivalent
    to the Windows domain controller and single Windows desktop, I’ll demonstrate
    how an attacker might exploit the protocols used by Windows devices in many corporate
    environments. I’ll begin by showing you how to extract password hashes and session
    keys directly from a Windows machine or by intercepting network traffic. Then,
    I’ll show how to use these session keys and password hashes to access other machines
    in the network by exploiting vulnerabilities in various networking protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The process and protocols we discuss here aren’t exclusively used by Windows
    systems. For example, the Kerberos authentication protocol is used on Linux, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Windows Virtual Lab**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll be attacking Windows systems, so we must first create a virtual lab containing
    a Windows machine. Windows is proprietary, but Microsoft offers trial versions
    that you can download for free at *[https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise](https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise)*.
    Once you’ve downloaded the ISO image, create a new virtual machine in VirtualBox,
    just like you did in [Chapter 1](ch01.xhtml#ch1). Give your machine 32GB of hard
    drive space and 4GB of RAM. Then follow the default setup instructions to complete
    the installation, making sure to create a user account with administrative privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extracting Password Hashes with Mimikatz**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of extracting hashes on Windows is similar to the process on Linux
    ([Chapter 14](ch14.xhtml#ch14)), except that instead of extracting hashes from
    the file */etc/shadow*, we retrieve them by dumping the memory of the *Local Security
    Authority Subsystem Service (LSSAS)* process. The LSSAS process contains password
    hashes and security tokens and manages the process of authenticating and communicating
    with the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: As with Linux, you’ll need administrative privileges to do this. Although you
    can use searchsploit to find local privilege escalation vulnerabilities for Windows,
    for simplicity we’ll assume that you’ve compromised a user with administrative
    privileges. Still, it’s a good practice to keep a list of fresh privilege escalation
    vulnerabilities in your toolbox for use in real tests or attacks.
  prefs: []
  type: TYPE_NORMAL
- en: To dump the credentials, we’ll use *mimikatz*, a program that contains a collection
    of tools to help us extract hashes from LSSAS process’s memory. You can manually
    dump a process’s memory by opening the task manager (CTRL-ALT-DELETE), right-clicking
    the process, and then selecting **Create dump file**; however, mimikatz automates
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: On Kali Linux, you can download the precompiled executable at *[https://github.com/gentilkiwi/mimikatz/releases/](https://github.com/gentilkiwi/mimikatz/releases/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, because the tool is so popular, many antivirus systems will detect
    it and Window’s signature detection algorithm will delete it immediately. Thus,
    you probably want to obfuscate the strings and the binary. Use Metasploitable’s
    `**msfencode**` command to encode the executable with SGN, as discussed in [Chapter
    10](ch10.xhtml#ch10). You can encode the mimikatz executable on Kali Linux by
    running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have an encoded version of mimikatz that you can download on the Windows
    machine. We can’t directly copy the encoded mimikatz executable from our Kali
    Linux virtual machine to our Windows virtual machine, so we transfer it over the
    network, as in previous chapters, by starting a web server on the Kali Linux machine
    and downloading the file onto the the Windows machine. First, start a Python web
    server on Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Access the server and download *mimikatz_encoded.exe* onto your Windows virtual
    machine. Now let’s extract the password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you must have admin privileges to extract these hashes. To double-check
    that your account on the Windows machine has these privileges, use the keyboard
    shortcut Win-X, and then press A to open the Power-Shell console with admin privileges.
    Then, use the command `**whoami /groups**` to see your groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! You’ve confirmed that this user has administrative privileges ➊. Now
    navigate to the folder containing mimikatz and run it by entering the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Debug privileges is a security policy that allows a process like mimikatz to
    attach the debugger to the LSSAS process and extract its memory contents. Run
    the following command to instruct mimikatz to request debug privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If mimikatz successfully gets debug privileges, you will see an `OK` message.
    For best results, run the mimikatz process with administrative privileges; this
    is because a process with administrative privileges will also be able to get debug
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mimikatz tool supports several modules. For example, the `sekurlsa` module
    allows you to extract hashes from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that mimikatz has extracted the SHA-1 and Windows NT LAN Manager hashes
    of the passwords ➊ ➋. In some cases, the LSSAS process will also contain plaintext
    passwords ➌. Tools like Credential Guard can help protect the LSSAS process from
    credential dumping attacks like these. However, even in those cases, mimikatz
    can still capture credentials that the user enters after the system has been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mimikatz tool is also included in the Metasploit Framework; however, Metasploit
    won’t always have the most up-to-date version. Still, you could dump the password
    hashes on the Windows system by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the password hashes, you could try to crack them. Alternatively,
    you could use them to log in to other machines on the corporate network by exploiting
    the Windows NT LAN Manager protocol in a pass-the-hash attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing the Hash with NT LAN Manager**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*NT LAN Manager (NTLM)* is a Windows protocol that allows users to authenticate
    with other machines on the network using their password’s hash. [Figure 15-1](ch15.xhtml#ch15fig1)
    shows what happens when a user logs in to a machine and attempts to access an
    NTLM-shared folder on a server.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: An overview of the authentication process using NTLM*'
  prefs: []
  type: TYPE_NORMAL
- en: Several messages are exchanged during this process. When a user logs into a
    machine with their username and password, that machine stores the username and
    a hash of the password ➊ and then usually deletes the plaintext password. When
    the user wants to access the server or network folder, the operating system sends
    the server that user’s username. The server responds by sending a 16-byte nonce
    called a *challenge message*. Then, the client encrypts the nonce with the user’s
    password hash and sends it back to the server ➋. This encrypted nonce is commonly
    referred to as the *challenge-response*.
  prefs: []
  type: TYPE_NORMAL
- en: The server then forwards the username, the challenge-response, and the challenge
    message to the domain controller. The domain controller is a server responsible
    for storing information about users and managing the network’s security policy.
    Once the domain controller receives the challenge-response ➌, it will verify it
    by looking up the user’s password hash in the database. It will then use this
    hash to decrypt the nonce in the challenge-response. If the nonces match, the
    domain controller will send the server a message telling the server that it has
    authenticated the user and the server will then grant the user access.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the protocol never uses the plaintext version of the user’s password.
    This means that if an attacker can obtain a hash of the user’s password, they
    don’t need to crack the hash to access another machine. They can simply use the
    hash extracted from the machine to encrypt the challenge-response and authenticate
    with domain controller. We call this type of attack a *pass-the-hash attack*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a pass-the-hash attack, use mimikatz to load one of the hashes you
    extracted from the LSSAS process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `<User>`, `<Domain>`, and `<NTLM Hash>` values with the extracted
    username, domain, and NTLM password hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can impersonate a user and access their resources. For example, if
    our virtual environment contained another Windows machine, you could connect to
    and access it by using the `psexec` tool to run a PowerShell terminal on the other
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can download `psexec` for free from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring the Corporate Windows Network**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once an attacker is inside a network, what should they do next? On corporate
    networks, they might learn about the network’s devices and the associated security
    policies by listening for network traffic or querying the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: Large corporations must manage security policies across thousands of devices,
    so they usually organize machines into a hierarchical structure consisting of
    organizational units, domains, trees, and forests. An *organizational unit (OU)*
    is the lowest level in the hierarchy, and consists of a grouping of users, security
    groups, and computers. A system administrator is free to choose the structure
    of OUs. For example, an administrator of a large bank may choose to create an
    OU for each location, such as for a Virginia branch, a California branch, and
    a Florida branch. Nested within each OU, the administrator might create two other
    OUs, one to contain the tellers’ machines and the other for staff accounts. This
    grouping allows system administrators to assign different privileges to each OU.
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection of OUs is called a *domain*, which are grouped into trees with
    parent and child domains. Trees are, in turn, grouped into a forest. A trust relationship
    is established between the domains in the same tree, thus allowing authorized
    users to move between domains. For example, a system administrator might want
    to keep machines at the bank headquarters isolated from those in the bank branches.
    Thus, the administrator might create two separate domains: `company.headquarters`
    and `company.branches`. Later, if the bank acquires a smaller bank that already
    has a domain infrastructure, the system administrator might connect the domains
    by making the acquired bank’s domain a child of the bank’s parent domain, `company.branches`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-2](ch15.xhtml#ch15fig2) shows an organization with one forest, two
    trees, three domains, and seven OUs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Visualizing the structure of a corporate network with multiple
    domains*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain controller manages these domains and their security policies and
    runs four key services: the *DNS service*, the *Active Directory Service (ADS)*,
    the *Lightweight Directory Access Protocol (LDAP)* service, and the *Kerberos*
    authentication service. Let’s begin by looking at the DNS Service.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking the DNS Service**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DNS service is a key part of the domain controller. It allows machines in
    the domain to find the IP addresses of other machines on the network. For example,
    a file server might contain a shared network folder called *//Patient Records/*.
    When a user enters *//PatientRecords/* into their file explorer, the operating
    system will communicate with the domain controller’s DNS server to find the file
    server’s IP address. If the DNS service contains an entry for *//PatientRecords/*,
    it will respond with the corresponding IP address. The file explorer will then
    attempt to connect to that server and access the files (assuming that it has permission
    to do so).
  prefs: []
  type: TYPE_NORMAL
- en: However, if the DNS lookup fails—for example, if the user mistypes the name,
    perhaps forgetting the *s* and typing *//PatientRecord/*, instead—the operating
    system will fall back on a less secure protocol called *Link-Local Multicast Name
    Resolution (LLMNR)* to discover a machine on the network that can respond to the
    request. LLMNR is a broadcast protocol, so any machine on the network can respond
    to the request. This allows attackers to respond with a malicious message, an
    attack called *LLMNR poisoning*. [Figure 15-3](ch15.xhtml#ch15fig3) shows the
    steps in an LLMNR poisoning attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: How DNS failures could result in insecure LLMNR lookups*'
  prefs: []
  type: TYPE_NORMAL
- en: The victim generates a DNS request, and this request is sent to the domain controller
    ➊. The domain controller’s DNS service tells the victim that it couldn’t find
    the requested entry ➋, so the victim machine resorts to the LLMNR protocol. It
    broadcasts a message asking if any machines have the *//PatientRecord/* folder
    ➌. The attacker will respond with a message to the effect of, “I can help, but
    you need to authenticate. Send me your NTLM hash” ➍. If the victim’s machine responds
    to the message, you’ll have captured the user’s NTLM password hash.
  prefs: []
  type: TYPE_NORMAL
- en: If LLMNR fails, the client will fall back to the less secure protocol Netbios
    Name Service (NBT-NS). LLMNR and NBT-NS aren’t the only protocols that are vulnerable
    to this type of poisoning attack. Suppose that an attacker performs an ARP spoofing
    attack and pretends to be the DNS server. They could then capture the NTLM hash
    from correct DNS lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `Responder` tool to perform these attacks. It lets you maliciously
    respond to various network protocols and capture the associated hashes. You can
    get a copy of `Responder` by cloning its GitHub repository to your Kali Linux
    virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start `Responder` by running it on your Kali Linux virtual machine. Then, enter
    a dummy folder, such as *//PatientRecords/*, in the Windows virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `-I` option specifies the interfaces it will listen and respond on, and
    `-v` says to generate verbose output. You’ll find the NTLMv2 hash that was captured
    during the attack ➊. You can now crack this hash using the techniques discussed
    in [Chapter 12](ch12.xhtml#ch12) or use it in a pass-the-hash attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking Active Directory and LDAP Services**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second service hosted by the domain controller is the Active Directory service,
    which is a database of objects in the domain. These objects include users, security
    policies, and shared machines, such as printers and desktops.
  prefs: []
  type: TYPE_NORMAL
- en: The user objects contain information such as usernames and password hashes.
    Security group objects contain information on the privileges afforded to that
    group as well as a member attribute that lists users associated with that security
    group. By storing all user information in a single repository, you can give users
    access to multiple machines without having to store their usernames and passwords
    on these devices. This is useful in places like libraries, banks, or corporate
    offices where users often share machines and printers.
  prefs: []
  type: TYPE_NORMAL
- en: Other operating systems besides Windows offer their own directory services.
    These services, such as the 389 Directory Server and Apple Open Directory, use
    custom protocols and queries. However, requiring operating systems to implement
    every directory access protocol is infeasible. Instead, they often implement the
    LDAP, a standard protocol that devices can use to interface with most directory
    services. The LDAP service translates LDAP-style queries into the query format
    supported by the backend directory service. This means that clients have to support
    only the LDAP protocol because the LDAP service abstracts the backend directory
    service.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP protocol represents data in the form of a *directory information tree
    (DIT)*. [Figure 15-4](ch15.xhtml#ch15fig4) shows a DIT for an example version
    of the *[bank.com](http://bank.com)* domain.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: A directory information tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root of the DIT is the domain. The value `dc=bank, dc=com` is the distinguished
    name, which uniquely identifies a component in the tree. (In this case, `dc` doesn’t
    represent the domain controller, but rather refers to a domain component. A little
    confusing, I know, but this is standard notation.) Here, the domain *[bank.com](http://bank.com)*
    has two domain components: *bank* and *com*. Below the domain are two OUs. One
    of these represents machines and the other OU represents users. The distinguished
    name for the person with the user id Monique is `dc=bank, dc=com, ou=Staff, ou=Manager,
    uid=Monique`. In this way, in addition to uniquely identifying a component, the
    distinguished name also identifies the path to the object in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing an LDAP Query Client***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: LDAP can be a helpful tool for gaining access to the domain controller. If we
    gain access to the domain controller, which stores the credentials for all users
    on the network and can also create user accounts, we control the network. If we
    can control the domain controller, we can create our own administrator account
    and log in to any machine we please.
  prefs: []
  type: TYPE_NORMAL
- en: However, the credentials we extract from some machine on the network might not
    necessarily grant us access to the domain controller. Instead, we’ll need to move
    from machine to machine, extracting more privileged credentials until we find
    some that give us the access we need. To efficiently do this, you need to understand
    the structure of the network you’re attacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attackers can learn about the structure of the corporate network by querying
    the LDAP server on the domain controller. For example, an attacker might execute
    queries to the effect of: “How many machines are on the network?”, “How many users
    are there?”, or “Which users are members of the administrator group?” By executing
    queries like these, the attacker can map the network and discover a path to a
    domain controller, a process known as *enumeration*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make these ideas of LDAP queries and enumeration more concrete by writing
    a Python program that will query an LDAP server. This LDAP client, which we’ll
    call *info_probe.py*, will retrieve a list of all the users in the network. We’ll
    use the `ldap3` Python library to develop our client, so install it by using `pip3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need to connect to the LDAP service using a process called binding.
    LDAP supports three types of binds: *anonymous binds*, *password binds*, and *Simple
    Authentication and Security Layer (SASL) binds*. An anonymous bind doesn’t require
    any authentication, so we’ll start by doing an anonymous bind and then modify
    our program to do a password bind, which allows us to authenticate using a username
    and password. We’ll discuss SASL binds when we look at the Kerberos protocol later
    in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid having to set up our own LDAP server, we’ll interact with a public
    demo server called *ipa.demo1.freeipa.org*, available at *[https://www.freeipa.org/page/Demo](https://www.freeipa.org/page/Demo)*.
    Alternatively, you can download the FreeIPA virtual machine and add it to your
    environment. The FreeIPA virtual machine is the Linux equivalent to a Windows
    domain controller, and we’ll use it as the domain controller in our environment.
    The web-based option is easier to set up, but your DIT may change during testing
    as other people have access to the server. Regardless, I’ll use the web-based
    option in the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating a server object with information about the server to which
    we want to connect. We set the `get_info` option to `ALL` so that we can read
    as much information as possible about the server once we’ve connected. Then we’ll
    create a connection object and call the `bind` method. This connection to LDAP
    uses an anonymous bind. If our anonymous bind was successful, we’ll print information
    about the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *info_probe.py* to check whether we can connect to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you can successfully connect to the server, you’ll see the output shown here.
    This server information will contain lots of great details, including the LDAP
    server’s version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s query the LDAP server to discover more about the network. Most LDAP
    servers will block unauthorized users from submitting queries, so let’s modify
    *info_probe.py* so that it authenticates with the LDAP service. We’ll use the
    password bind authentication method to connect to the LDAP server and search for
    all of the users in the domain. The LDAP server has three default accounts, and
    the password for each one is **Secret123**. However, you can also use the NTLM
    password hash you extracted from memory to authenticate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we connect to the LDAP server, supplying the user’s distinguished name
    as the `user` parameter. Notice the name specifies the path from the leaf to the
    root of the DIT. We also set the `auto_bind` option to true. The `ldap3` library
    will perform the bind operation as soon as it initiates the connection, saving
    us an extra line of code. Then, we specify our search query. The `search_base`
    argument represents the starting node in our DIT, and we set it to the root node.
    The second option allows you to filter the results. We’ll include person objects
    only. Filters can also include logical operators. For example, the following filter
    returns person objects with an attribute that starts with `Test: & (objectClass=person)
    (cn=Test*)`. Notice that the logical operation precedes the conditionals. This
    structure might be different from other query languages you’ve seen. Lastly, we
    specify the attributes to include.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the four users contained in the DIT. Because the LDAP server is
    open, you and other users can modify the tree. When you run the query, you might
    notice some additional entries.
  prefs: []
  type: TYPE_NORMAL
- en: View the network administrator panel by logging in to *[https://ipa.demo1.freeipa.org/](https://ipa.demo1.freeipa.org/)*
    with the username **admin** and the password **Secret123**. This panel is what
    the system administrator sees.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using SharpHound and Bloodhound for LDAP Enumeration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Various tools can automate the enumeration process. *Sharphound* collects information
    about the network by running LDAP queries, listening to network traffic, and using
    Windows APIs to extract information from machines on the network. You can download
    it from *[https://github.com/BloodHoundAD/SharpHound3/](https://github.com/BloodHoundAD/SharpHound3/)*
    After SharpHound has finished collecting information, it will output several JSON
    files that contain information on the users, groups, and machines on the network.
    We can then copy these files from the compromised machine into the Kali Linux
    virtual machine and feed them to the *BloodHound* visualization tool. Bloodhound
    allows attackers to query the data and visualize the paths (list of machines)
    that they can use to compromise the DC. [Figure 15-5](ch15.xhtml#ch15fig5) shows
    an illustration of a path.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: An illustration of a possible path*'
  prefs: []
  type: TYPE_NORMAL
- en: Say that Machine 1 is the machine you compromised. User Jane Jackson is logged
    in to this machine and has an active session. We can also see that Jane is a member
    of the Office Admin group, which has administrator access to the file server.
    This means that we can use Jane’s credentials to access the file server. We can
    also see that John Johnson has logged in to the file server and has an active
    session, and that John has administrator access to the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can compromise the domain controller by extracting Jane’s
    credentials and using using them in a pass-the-hash attack to get administrator
    access to the file server. Once we have administrator access to the file server
    we can extract John’s credentials and use them to gain access to the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'See Bloodhound’s documentation for more examples: *[https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html](https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html)*.
    You can also use other tools, such as windapsearch, to query the Active Directory
    service on the domain controller.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking Kerberos**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Kerberos protocol is a secure alternative to the NTLM protocol. To authenticate
    users who want to access network resources, Kerberos relies on two services: an
    authentication server and a ticket-granting service. [Figure 15-6](ch15.xhtml#ch15fig6)
    shows an overview of the Kerberos messages exchanged when a user requests access
    to a file server.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch15fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: The Kerberos authentication process*'
  prefs: []
  type: TYPE_NORMAL
- en: The client first initiates a connection to the authentication server and requests
    access to the ticket-granting service ➊. This plaintext message contains the user’s
    ID, the service ID, the user’s IP address, and the requested lifetime of the ticket-granting
    ticket. The authentication server will look up the user in the Active Directory
    service, and if the user exists, the authentication server will retrieve the user’s
    password hash. The user’s password hash will then be used as a symmetric key to
    encrypt the authentication server’s response. The authentication server and the
    user both have a copy of this hash, so only the user and the authentication server
    can decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the authentication server sends two messages, a response and a ticket-granting
    ticket ➋. Both of these messages are encrypted. The response, which is encrypted
    using the user’s password hash, contains the service ID, a timestamp, the lifetime
    of the session, and the session key the user will use to encrypt communications
    with the ticket-granting service. This message is equivalent to saying, “You’ve
    been authenticated. If you’re truly the user, you will be able to decrypt this
    message and extract the session key you can use to communicate securely with the
    ticket-granting service.” The second message (the ticket-granting ticket) is encrypted
    with the ticketgranting service’s secret key, meaning that only the ticket-granting
    service can read it. The message contains the user’s ID, the ticket-granting service’s
    ID, the time, the user’s IP address, the ticket-granting ticket’s lifetime, and
    the same session key shared with the client. This ticket is equivalent to the
    authentication server saying, “Show the ticket-granting service this ticket as
    proof that you have permission to talk to it. The service will know what to do
    with it.”
  prefs: []
  type: TYPE_NORMAL
- en: The user decrypts the first message using their password hash and extracts the
    session key ➌. The user then encrypts their user ID and password hash using the
    session key. This is called the user authenticator. The user will attach the ticket-granting
    ticket as proof that it has permission to access the ticket-granting service,
    as well as a plaintext request including the service they wish to access (such
    as the file service) and the ticket’s requested lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ticket-granting service verifies the ticket-granting ticket by decrypting
    it with the ticket-granting service’s secret key ➍. The ticket-granting service
    then extracts the session key from the decrypted ticket and uses it to decrypt
    the user authenticator message and extract the user ID. It will then check the
    Active Directory service to see whether the user can access that service. If the
    user has permission to do so, the ticket-granting service will generate two messages:
    a response and a service ticket. The response, which is encrypted with the session
    key, contains the service ID (for instance, the ID of the file server), a timestamp,
    a lifetime, and a new filesystem session key that will be used to encrypt communications
    between the file server and the user. The second message is the service ticket,
    which is encrypted with the file server’s secret key so that only the file server
    can decrypt it. The service ticket contains the user ID, service ID, timestamp,
    and the new filesystem session key. This service ticket uniquely provides this
    user with access to a specific service.'
  prefs: []
  type: TYPE_NORMAL
- en: The user decrypts the response message, extracts the file server’s session key
    ”, and uses this key to encrypt a message requesting access to the file server.
    The user then sends the request and service ticket to the file server. Lastly,
    the server will follow the same process as the ticket-granting service ➏. It will
    first use its secret key to decrypt the service ticket and extract the session
    key, which it will then use to decrypt the user’s request message. If the file
    server can decrypt the message, it will authenticate the user and send an access-granted
    message encrypted with the session key.
  prefs: []
  type: TYPE_NORMAL
- en: Is Kerberos secure? Notice that an attacker doesn’t need to have the user’s
    password hash to request a ticket-granting ticket. Suppose that an attacker sends
    the user’s ID to the authentication server. In that case, the server will respond
    with a ticket-granting ticket containing an encrypted session key. The attacker
    could then attempt to crack the ticket by using Hashcat to perform a dictionary-based
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent these attacks, modern Kerberos implementations require that requests
    include a timestamp encrypted with the user’s password hash. We refer to this
    extra check as *pre-authentication (pre-auth)*. But even with preauth present,
    you can use Metasploit modules to collect Kerberos usernames by performing a dictionary-based
    attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Kerberos_enumuser` module will perform the first authentication step with
    the user IDs in the dictionary and then report information on the use; for example,
    if a user is present and whether pre-auth is required.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I’ve discussed the Kerberos protocol, let’s look at other ways to attack
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Pass-the-Ticket Attack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a *pass-the-ticket* attack, a hacker manages to acquire a service ticket,
    which they can use to access services on the machine. To do this, they extract
    the response the authentication server sent, the ticket-granting ticket, and the
    user’s password hash from the LSSAS process on a local machine. The attacker decrypts
    the response using the user’s password hash and extracts the session key, which
    they then use to forge a new request for a service ticket. Once the attacker obtains
    the new service ticket, they can access other services or machines. Tools like
    mimikatz allow you to execute these types of attacks. Use your encoded version
    of mimikatz to extract the tickets from the LSSAS process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Mimikatz outputs the ticket information to the terminal. It also writes each
    ticket to separate files with the *.kirbi* extension. The files will be placed
    in the same directory as the mimikatz executable. Select the ticket associated
    with the system that you want to access and load it into the memory of the LSSAS
    process by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After it’s loaded, you should be able to access the system.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Golden Ticket and DC Sync Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although we didn’t show it in our discussion of the Kerberos protocol, all messages
    are signed with the password hash associated with the *krbtgt* account, a special
    account on all domain controllers with a long and difficult-to-crack password
    that is automatically generated. However, suppose that an attacker could compromise
    the domain controller and steal the password hash of the krbtgt account. In that
    case, they could forge any ticket by signing it with the krbtgt account’s hash.
    An attacker could then create tickets that they could use years after they’ve
    compromised a system. This is why it is important to reset the krbtgt account’s
    password if you suspect there has been an attack. Because this attack allows an
    attacker to forge any ticket, at any time, it is called a *golden ticket* attack.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need the krbtgt account’s password hash to create a golden ticket. But
    how can you obtain the krbtgt password hash without directly compromising the
    domain controller? Well, when a network administrator adds a new domain controller
    to the network, the new domain controller asks existing domain controllers to
    send it a copy of their databases. This request allows the domain controllers
    to remain in sync. However, these databases also contain password hashes, including
    the krbtgt account’s password hash. By pretending to be a domain controller performing
    a sync operation, an attacker can steal the krbtgt account’s password hash. We
    call this attack a *DC sync* attack.
  prefs: []
  type: TYPE_NORMAL
- en: '*Impacket* is an amazing collection of Python programs that allows hackers
    to perform network attacks, including the DC sync attack. You can download it
    by cloning the impacket Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a DC sync attack by running the *secretsdump.py* Python program in
    the *impacket* folder you just cloned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line corresponds to a user’s password hashes. The line at ➊, represents
    the user krbtgt. All lines have the following structure: `uid:rid:lmhash: nthash`,
    where `uid` is the user’s id, `rid` is the relative identifier (a code that identifies
    a user’s role, such as 500 for an administrator), `lmhash` is the LAN manager
    hash, which is a hash that predates the NTLM hash, and `nthash` represents the
    NTLM hash. Because `lmhash` uses only seven case-insensitive characters, it’s
    easily cracked; however, it is included for legacy purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `nthash` to create your golden ticket. The following command creates the
    ticket and loads it into memory so that it can be used in a pass-the-ticket attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we included the `/ptt` (pass-the-ticket) flag, which tells mimikatz to
    associate the ticket with our current session. Now you can log in to any machine
    with your new admin ticket.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Kerberoasting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the final exercise in this book, you’ll research and execute an attack on
    your own. The attack that you’ll execute is called *Kerberoasting*, which is a
    dictionary-based attack that attempts to crack the password hash used to encrypt
    the ticket-granting service. Some services are associated with normal users, and
    thus use regular passwords instead of computer-generated ones. Successfully cracking
    the ticket-granting service will give you the service’s password, which is the
    same as the user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a Windows lab environment with a Windows desktop virtual machine and
    a Windows server to act as your domain controller. Next, try executing some attacks
    against it. To execute a Kerberoasting attack, use the *getuserspns.py* impacket
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
