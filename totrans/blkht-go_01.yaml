- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: GO FUNDAMENTALS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 基础知识
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: This chapter will guide you through the process of setting up your Go development
    environment and introduce you to the language’s syntax. People have written entire
    books on the fundamental mechanics of the language; this chapter covers the most
    basic concepts you’ll need in order to work through the code examples in the following
    chapters. We’ll cover everything from primitive data types to implementing concurrency.
    For readers who are already well versed in the language, you’ll find much of this
    chapter to be a review.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导你完成设置 Go 开发环境的过程，并介绍语言的语法。人们已经写了整本书来讲解语言的基本机制；本章涵盖了你在后续章节的代码示例中需要的最基本概念。我们将涵盖从原始数据类型到实现并发的所有内容。对于已经精通语言的读者来说，你会发现本章的内容大部分是复习。
- en: Setting Up a Development Environment
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: To get started with Go, you’ll need a functional development environment. In
    this section, we’ll walk you through the steps to download Go and set up your
    workspace and environment variables. We’ll discuss various options for your integrated
    development environment and some of the standard tooling that comes with Go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Go，你需要一个功能完善的开发环境。在本节中，我们将带你了解如何下载 Go 并设置工作区和环境变量。我们还会讨论各种集成开发环境的选项以及
    Go 附带的一些标准工具。
- en: Downloading and Installing Go
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载并安装 Go
- en: Start by downloading the Go binary release most appropriate to your operating
    system and architecture from [*https://golang.org/dl/*](https://golang.org/dl/).
    Binaries exist for Windows, Linux, and macOS. If you’re using a system that doesn’t
    have an available precompiled binary, you can download the Go source code from
    that link.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [*https://golang.org/dl/*](https://golang.org/dl/) 下载最适合你的操作系统和架构的 Go 二进制版本。Windows、Linux
    和 macOS 都有对应的二进制文件。如果你使用的系统没有现成的预编译二进制文件，你可以从该链接下载 Go 源代码。
- en: Execute the binary and follow the prompts, which will be minimal, in order to
    install the entire set of Go core packages. *Packages*, called *libraries* in
    most other languages, contain useful code you can use in your Go programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 执行二进制文件并按照提示操作，这些提示将非常简单，以便安装整个 Go 核心包。*包*，在其他大多数语言中称为 *库*，包含你可以在 Go 程序中使用的有用代码。
- en: Setting GOROOT to Define the Go Binary Location
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 GOROOT 以定义 Go 二进制文件的位置
- en: Next, the operating system needs to know how to find the Go installation. In
    most instances, if you’ve installed Go in the default path, such as */usr/local/go*
    on a *Nix/BSD-based system, you don’t have to take any action here. However, in
    the event that you’ve chosen to install Go in a nonstandard path or are installing
    Go on Windows, you’ll need to tell the operating system where to find the Go binary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，操作系统需要知道如何找到 Go 的安装路径。在大多数情况下，如果你将 Go 安装在默认路径下，比如在基于 *Nix/BSD* 的系统中是 */usr/local/go*，你不需要在这里做任何操作。但是，如果你选择将
    Go 安装在非标准路径，或者在 Windows 上安装 Go，你需要告诉操作系统 Go 二进制文件的位置。
- en: 'You can do this from your command line by setting the reserved `GOROOT` environment
    variable to the location of your binary. Setting environment variables is operating-system
    specific. On Linux or macOS, you can add this to your *~/.profile*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行将保留的 `GOROOT` 环境变量设置为二进制文件的位置来实现这一点。设置环境变量是操作系统特定的。在 Linux 或 macOS 上，你可以将其添加到
    *~/.profile* 中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On Windows, you can add this environment variable through the System (Control
    Panel), by clicking the **Environment Variables** button.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以通过系统（控制面板）添加这个环境变量，点击 **环境变量** 按钮。
- en: Setting GOPATH to Determine the Location of Your Go Workspace
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 GOPATH 以确定 Go 工作区的位置
- en: 'Unlike setting your `GOROOT`, which is necessary in only certain installation
    scenarios, you must always define an environment variable named `GOPATH` to instruct
    the Go toolset where your source code, third-party libraries, and compiled programs
    will exist. This can be any location of your choosing. Once you’ve chosen or created
    this base workspace directory, create the following three subdirectories within:
    *bin*, *pkg*, and *src* (more on these directories shortly). Then, set an environment
    variable named `GOPATH` that points to your base workspace directory. For example,
    if you want to place your projects in a directory called *gocode* located within
    your home directory on Linux, you set `GOPATH` to the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置 `GOROOT` 不同，`GOROOT` 仅在某些安装场景中需要，你必须始终定义一个名为 `GOPATH` 的环境变量，以指示 Go 工具链你的源代码、第三方库和已编译程序的位置。这个位置可以是你选择的任何位置。一旦你选择或创建了这个基础工作区目录，就在其中创建以下三个子目录：*bin*、*pkg*
    和 *src*（稍后会详细讲解这些目录）。然后，设置一个名为 `GOPATH` 的环境变量，指向你的基础工作区目录。例如，如果你想将项目放在 Linux 系统中名为
    *gocode* 的目录中，你可以将 `GOPATH` 设置为以下路径：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The *bin* directory will contain your compiled and installed Go executable binaries.
    Binaries that are built and installed will be automatically placed into this location.
    The *pkg* directory stores various package objects, including third-party Go dependencies
    that your code might rely on. For example, perhaps you want to use another developer’s
    code that more elegantly handles HTTP routing. The *pkg* directory will contain
    the binary artifacts necessary to consume their implementation in your code. Finally,
    the *src* directory will contain all the evil source code you’ll write.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*bin* 目录将包含你编译并安装的 Go 可执行二进制文件。构建并安装的二进制文件会自动放置到此位置。*pkg* 目录存储各种包对象，包括你的代码可能依赖的第三方
    Go 库。例如，假设你想使用另一位开发者的代码来更优雅地处理 HTTP 路由。*pkg* 目录将包含必要的二进制文件，用于在你的代码中使用他们的实现。最后，*src*
    目录将包含你编写的所有源代码。'
- en: The location of your workspace is arbitrary, but the directories within must
    match this naming convention and structure. The compilation, build, and package
    management commands you’ll learn about later in this chapter all rely on this
    common directory structure. Without this important setup, Go projects won’t compile
    or be able to locate any of their necessary dependencies!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工作区的位置是任意的，但其中的目录必须遵循此命名约定和结构。稍后你将学习到的编译、构建和包管理命令都依赖于这种通用的目录结构。如果没有这个重要的设置，Go
    项目将无法编译或找到任何必要的依赖！
- en: 'After configuring the necessary `GOROOT` and `GOPATH` environment variables,
    confirm that they’re properly set. You can do this on Linux and Windows via the
    `set` command. Also, check that your system can locate the binary and that you’ve
    installed the expected Go version with the `go version` command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好必要的 `GOROOT` 和 `GOPATH` 环境变量后，确认它们是否已正确设置。你可以通过 `set` 命令在 Linux 和 Windows
    上进行检查。还要确保你的系统能够找到二进制文件，并且你已使用 `go version` 命令安装了预期的 Go 版本：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command should return the version of the binary you installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应返回你安装的二进制版本。
- en: Choosing an Integrated Development Environment
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择集成开发环境
- en: Next, you’ll probably want to select an integrated development environment (IDE)
    in which to write your code. Although an IDE isn’t required, many have features
    that help reduce errors in your code, add version-control shortcuts, aid in package
    management, and more. As Go is still a fairly young language, there may not be
    as many mature IDEs as for other languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能需要选择一个集成开发环境（IDE）来编写代码。虽然 IDE 不是必需的，但许多 IDE 提供的功能可以帮助减少代码中的错误、添加版本控制快捷键、协助包管理等。由于
    Go 仍然是一个相对年轻的语言，可能没有其他语言那样多成熟的 IDE。
- en: Fortunately, advancements over the last few years leave you with several, full-featured
    options. We’ll review some of them in this chapter. For a more complete list of
    IDE or editor options, check out the Go wiki page at [*https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/*](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/).
    This book is IDE/editor agnostic, meaning we won’t force you into any one solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，近年来的技术进步为你提供了几种功能齐全的选择。我们将在本章中回顾其中的一些。要查看完整的 IDE 或编辑器选项列表，请访问 Go 的维基页面
    [*https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/*](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/)。本书对
    IDE/编辑器没有特定要求，这意味着我们不会强迫你使用任何一种解决方案。
- en: Vim Editor
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Vim 编辑器
- en: The *Vim* text editor, available in many operating-system distributions, provides
    a versatile, extensible, and completely open source development environment. One
    appealing feature of Vim is that it lets users run everything from their terminal
    without fancy GUIs getting in the way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vim*文本编辑器在许多操作系统发行版中都有提供，提供了一个多功能、可扩展并且完全开源的开发环境。Vim的一个吸引人之处是，它允许用户从终端运行所有内容，不会被华丽的GUI界面干扰。'
- en: Vim contains a vast ecosystem of plug-ins through which you can customize themes,
    add version control, define snippets, add layout and code-navigation features,
    include autocomplete, perform syntax highlighting and linting, and much, much
    more. Vim’s most common plug-in management systems include Vundle and Pathogen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Vim包含了一个庞大的插件生态系统，您可以通过它自定义主题、添加版本控制、定义代码片段、添加布局和代码导航功能、包括自动补全、执行语法高亮和静态检查，等等。Vim最常见的插件管理系统包括Vundle和Pathogen。
- en: To use Vim for Go, install the `vim-go` plug-in ([*https://github.com/fatih/vim-go/*](https://github.com/fatih/vim-go/))
    shown in [Figure 1-1](ch01.xhtml#ch1fig1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Vim中使用Go，请安装`vim-go`插件（[*https://github.com/fatih/vim-go/*](https://github.com/fatih/vim-go/)，如[图1-1](ch01.xhtml#ch1fig1)所示）。
- en: '![Image](Images/01fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/01fig01.jpg)'
- en: '*Figure 1-1: The `vim-go` plug-in*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-1：`vim-go`插件*'
- en: Of course, to use Vim for Go development, you’ll have to become comfortable
    with Vim. Further, customizing your development environment with all the features
    you desire might be a frustrating process. If you use Vim, which is free, you’ll
    likely need to sacrifice some of the conveniences of commercial IDEs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要在Go开发中使用Vim，您需要对Vim非常熟悉。而且，定制一个符合您需求的开发环境，可能会是一个令人沮丧的过程。如果您使用Vim（它是免费的），那么您可能需要牺牲一些商业IDE的便利性。
- en: GitHub Atom
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GitHub Atom
- en: GitHub’s IDE, called *Atom* (*[https://atom.io/](https://atom.io/)*), is a hackable
    text editor with a large offering of community-driven packages. Unlike Vim, Atom
    provides a dedicated IDE application rather than an in-terminal solution, as shown
    in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub的IDE，名为*Atom*（*[https://atom.io/](https://atom.io/)*），是一个可定制的文本编辑器，拥有大量社区驱动的插件。与Vim不同，Atom提供了一个专门的IDE应用，而不是终端内解决方案，如[图1-2](ch01.xhtml#ch1fig2)所示。
- en: '![Image](Images/01fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/01fig02.jpg)'
- en: '*Figure 1-2: Atom with Go support*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-2：带Go支持的Atom*'
- en: Like Vim, Atom is free. It provides tiling, package management, version control,
    debugging, autocomplete, and a myriad of additional features out of the box or
    through the use of the `go-plus` plug-in, which provides dedicated Go support
    (*[https://atom.io/packages/go-plus/](https://atom.io/packages/go-plus/)*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 像Vim一样，Atom是免费的。它提供了平铺窗口、包管理、版本控制、调试、自动补全和许多额外功能，这些功能要么是开箱即用的，要么是通过使用`go-plus`插件来提供专门的Go支持（*[https://atom.io/packages/go-plus/](https://atom.io/packages/go-plus/)*）。
- en: Microsoft Visual Studio Code
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 微软Visual Studio Code
- en: Microsoft’s *Visual Studio Code*, or *VS Code* (*[https://code.visualstudio.com](https://code.visualstudio.com)*),
    is arguably one of the most feature-rich and easiest IDE applications to configure.
    VS Code, shown in [Figure 1-3](ch01.xhtml#ch1fig3), is completely open source
    and distributed under an MIT license.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的*Visual Studio Code*，或*VS Code*（*[https://code.visualstudio.com](https://code.visualstudio.com)*），可以说是功能最丰富且最易于配置的IDE应用之一。VS
    Code，如[图1-3](ch01.xhtml#ch1fig3)所示，完全开源并根据MIT许可证分发。
- en: '![Image](Images/01fig03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/01fig03.jpg)'
- en: '*Figure 1-3: The VS Code IDE with Go support*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：带Go支持的VS Code IDE*'
- en: VS Code supports a diverse set of extensions for themes, versioning, code completion,
    debugging, linting, and formatting. You can get Go integration with the `vscode-go`
    extension (*[https://github.com/Microsoft/vscode-go/](https://github.com/Microsoft/vscode-go/)*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code支持一系列多样化的扩展，用于主题、版本控制、代码补全、调试、静态检查和格式化。您可以通过`vscode-go`扩展获得Go集成（*[https://github.com/Microsoft/vscode-go/](https://github.com/Microsoft/vscode-go/)*）。
- en: JetBrains GoLand
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JetBrains GoLand
- en: The JetBrains collection of development tools are efficient and feature-rich,
    making both professional development and hobbyist projects easy to accomplish.
    [Figure 1-4](ch01.xhtml#ch1fig4) shows what the JetBrains GoLand IDE looks like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains的开发工具集合高效且功能丰富，使得专业开发和业余项目都变得易于完成。[图1-4](ch01.xhtml#ch1fig4)展示了JetBrains
    GoLand IDE的界面。
- en: '*GoLand* is the JetBrains commercial IDE dedicated to the Go language. Pricing
    for GoLand ranges from free for students, to $89 annually for individuals, to
    $199 annually for organizations. GoLand offers all the expected features of a
    rich IDE, including debugging, code completion, version control, linting, formatting,
    and more. Although paying for a product may not sound appealing, commercial products
    such as GoLand typically have official support, documentation, timely bug fixes,
    and some of the other assurances that come with enterprise software.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*GoLand* 是 JetBrains 为 Go 语言开发的商业 IDE。GoLand 的定价从学生免费，到个人每年 89 美元，再到组织每年 199
    美元。GoLand 提供了丰富的 IDE 功能，包括调试、代码补全、版本控制、代码检查、格式化等。虽然付费购买产品可能听起来不太吸引人，但像 GoLand
    这样的商业产品通常会提供官方支持、文档、及时的 bug 修复和企业软件所带来的一些其他保证。'
- en: '![Image](Images/01fig04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/01fig04.jpg)'
- en: '*Figure 1-4: The GoLand commercial IDE*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-4：GoLand 商业 IDE*'
- en: Using Common Go Tool Commands
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用常见的 Go 工具命令
- en: Go ships with several useful commands that simplify the development process.
    The commands themselves are commonly included in IDEs, making the tooling consistent
    across development environments. Let’s take a look at some of these commands.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go 附带了几个有用的命令，可以简化开发过程。这些命令通常会包含在 IDE 中，使得工具在不同的开发环境中保持一致。让我们来看一些这些命令。
- en: The go run Command
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`go run` 命令'
- en: One of the more common commands you’ll execute during development, `go run`
    will compile and execute the *main package*—your program’s entry point.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中你会执行的常见命令之一，`go run` 会编译并执行 *main 包*——你程序的入口点。
- en: 'As an example, save the following code under a project directory within *$GOPATH/src*
    (remember, you created this workspace during installation) as *main.go*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将以下代码保存在 *$GOPATH/src* 下的项目目录中（记住，在安装时你创建了这个工作空间），命名为 *main.go*：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the command line, within the directory containing this file, execute `go
    run main.go`. You should see `Hello, Black Hat Gophers!` printed to your screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，在包含此文件的目录下执行 `go run main.go`。你应该会看到 `Hello, Black Hat Gophers!` 显示在屏幕上。
- en: The go build Command
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`go build` 命令'
- en: Note that `go run` executed your file, but it didn’t produce a standalone binary
    file. That’s where `go build` comes in. The `go build` command compiles your application,
    including any packages and their dependencies, without installing the results.
    It creates a binary file on disk but doesn’t execute your program. The files it
    creates follow reasonable naming conventions, but it’s not uncommon to change
    the name of the created binary file by using the `-o output` command line option.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`go run` 执行了你的文件，但它没有生成独立的二进制文件。此时 `go build` 就派上用场了。`go build` 命令会编译你的应用程序，包括任何包及其依赖项，但不会安装结果。它会在磁盘上创建一个二进制文件，但不会执行你的程序。它创建的文件遵循合理的命名约定，但也不罕见使用
    `-o output` 命令行选项更改生成的二进制文件名称。
- en: 'Rename *main.go* from the previous example to *hello.go*. In a terminal window,
    execute `go build hello.go`. If everything goes as intended, this command should
    create an executable file with the name *hello*. Now enter this command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前示例中的 *main.go* 重命名为 *hello.go*。在终端窗口中，执行 `go build hello.go`。如果一切按预期进行，这条命令应该会创建一个名为
    *hello* 的可执行文件。现在输入此命令：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This should run the standalone binary file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会运行独立的二进制文件。
- en: 'By default, the produced binary file contains debugging information and the
    symbol table. This can bloat the size of the file. To reduce the file size, you
    can include additional flags during the build process to strip this information
    from the binary. For example, the following command will reduce the binary size
    by approximately 30 percent:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的二进制文件包含调试信息和符号表，这可能会增加文件的大小。为了减小文件大小，你可以在构建过程中添加额外的标志，从二进制文件中剥离这些信息。例如，以下命令将使二进制文件的大小减少大约
    30%：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having a smaller binary will make it more efficient to transfer or embed while
    pursuing your nefarious endeavors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更小的二进制文件将使其在传输或嵌入过程中更加高效，同时有助于你完成一些阴谋任务。
- en: Cross-Compiling
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跨平台编译
- en: Using `go build` works great for running a binary on your current system or
    one of identical architecture, but what if you want to create a binary that can
    run on a different architecture? That’s where cross-compiling comes in. *Cross-compiling*
    is one of the coolest aspects of Go, as no other language can do it as easily.
    The `build` command allows you to cross-compile your program for multiple operating
    systems and architectures. Reference the official Go documentation at *[https://golang.org/doc/install/source#environment/](https://golang.org/doc/install/source#environment/)*
    for further details regarding allowable combinations of compatible operating system
    and architecture compilation types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go build`非常适合在当前系统或相同架构的系统上运行二进制文件，但如果你想创建一个可以在不同架构上运行的二进制文件怎么办呢？这就是交叉编译的用途。*交叉编译*是Go的一个非常酷的特点，因为没有其他语言能像Go一样轻松实现。`build`命令允许你为多个操作系统和架构交叉编译程序。有关可兼容的操作系统和架构编译类型的详细信息，请参考官方Go文档的*[https://golang.org/doc/install/source#environment/](https://golang.org/doc/install/source#environment/)*。
- en: To cross-compile, you need to set a *constraint*. This is just a means to pass
    information to the `build` command about the operating system and architecture
    for which you’d like to compile your code. These constraints include `GOOS` (for
    the operating system) and `GOARCH` (for the architecture).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行交叉编译，你需要设置一个*约束*。这只是一个用于将操作系统和架构的信息传递给`build`命令的方式。这些约束包括`GOOS`（操作系统）和`GOARCH`（架构）。
- en: 'You can introduce build constraints in three ways: via the command line, code
    comments, or a file suffix naming convention. We’ll discuss the command line method
    here and leave the other two methods for you to research if you wish.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种方式引入构建约束：通过命令行、代码注释或文件后缀命名约定。我们将在这里讨论命令行方法，其它两种方法如果你愿意，可以自行研究。
- en: 'Let’s suppose that you want to cross-compile your previous *hello.go* program
    residing on a macOS system so that it runs on a Linux 64-bit architecture. You
    can accomplish this via the command line by setting the `GOOS` and `GOARCH` constraints
    when running the `build` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将之前的*hello.go*程序从macOS系统交叉编译，以便它能在Linux 64位架构上运行。你可以通过命令行设置`GOOS`和`GOARCH`约束，执行`build`命令来完成这一操作：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output confirms that the resulting binary is a 64-bit ELF (Linux) file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果确认生成的二进制文件是一个64位的ELF（Linux）文件。
- en: The cross-compilation process is much simpler in Go than in just about any other
    modern programming language. The only real “gotcha” happens when you try to cross-compile
    applications that use native C bindings. We’ll stay out of the weeds and let you
    dig into those challenges independently. Depending on the packages you import
    and the projects you develop, you may not have to worry about that very often.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，交叉编译过程比几乎所有其他现代编程语言都要简单。唯一的“坑”是当你尝试交叉编译使用本地C绑定的应用程序时。我们不会深入探讨这些问题，留给你自己去解决。根据你导入的包和开发的项目，你可能不需要经常担心这个问题。
- en: The go doc Command
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`go doc`命令'
- en: 'The `go doc` command lets you interrogate documentation about a package, function,
    method, or variable. This documentation is embedded as comments through your code.
    Let’s take a look at how to obtain details about the `fmt.Println()` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`go doc`命令允许你查询有关包、函数、方法或变量的文档。这些文档嵌入在你的代码注释中。让我们来看一下如何获取`fmt.Println()`函数的详细信息：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output that `go doc` produces is taken directly out of the source code comments.
    As long as you adequately comment your packages, functions, methods, and variables,
    you’ll be able to automatically inspect the documentation via the `go doc` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`go doc`生成的输出直接来自源代码中的注释。只要你适当注释你的包、函数、方法和变量，你就能够通过`go doc`命令自动检查文档。'
- en: The go get Command
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`go get`命令'
- en: 'Many of the Go programs that you’ll develop in this book will require third-party
    packages. To obtain package source code, use the `go get` command. For instance,
    let’s assume you’ve written the following code that imports the `stacktitan/ldapauth`
    package:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中开发的许多Go程序将需要第三方包。要获取包的源代码，可以使用`go get`命令。例如，假设你编写了以下代码，导入了`stacktitan/ldapauth`包：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though you’ve imported the `stacktitan/ldapauth` package ❶, you can’t access
    the package quite yet. You first have to run the `go get` command. Using `go get
    github.com/stacktitan/ldapauth` downloads the actual package and places it within
    the *$GOPATH/src* directory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经导入了`stacktitan/ldapauth`包❶，你也无法直接访问该包。你首先需要运行`go get`命令。使用`go get github.com/stacktitan/ldapauth`会下载实际的包并将其放入*
    $GOPATH/src *目录中。
- en: 'The following directory tree illustrates the placement of the `ldapauth` package
    within your `GOPATH` workspace:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下目录树展示了`ldapauth`包在你的`GOPATH`工作空间中的位置：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the path ❶ and the imported package name are constructed in a way
    that avoids assigning the same name to multiple packages. Using `github.com/stacktitan`
    as a preface to the actual package name `ldapauth` ensures that the package name
    remains unique.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，路径❶和导入的包名是以一种避免为多个包分配相同名称的方式构建的。使用`github.com/stacktitan`作为实际包名`ldapauth`的前缀，确保包名保持唯一。
- en: Although Go developers traditionally install dependencies with `go get`, problems
    can arise if those dependent packages receive updates that break backward compatibility.
    Go has introduced two separate tools—`dep` and `mod`—to lock dependencies in order
    to prevent backward compatibility issues. However, this book almost exclusively
    uses `go get` to pull down dependencies. This will help avoid inconsistencies
    with ongoing dependency management tooling and hopefully make it easier for you
    to get the examples up and running.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go开发者传统上使用`go get`来安装依赖项，但如果那些依赖的包接收到会破坏向后兼容性的更新，可能会出现问题。Go引入了两个独立的工具——`dep`和`mod`——来锁定依赖项，以防止向后兼容性问题。然而，本书几乎专门使用`go
    get`来拉取依赖项。这有助于避免与正在进行的依赖项管理工具不一致，并希望能够更容易地让你运行这些示例。
- en: The go fmt Command
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`go fmt`命令'
- en: The `go fmt` command automatically formats your source code. For example, running
    `go fmt` /path/to/your/package will style your code by enforcing the use of proper
    line breaks, indentation, and brace alignment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`go fmt`命令会自动格式化你的源代码。例如，运行`go fmt` /path/to/your/package会通过强制使用适当的换行、缩进和括号对齐来调整你的代码样式。'
- en: Adhering to arbitrary styling preferences might seem strange at first, particularly
    if they differ from your habits. However, you should find this consistency refreshing
    over time, as your code will look similar to other third-party packages and feel
    more organized. Most IDEs contain hooks that will automatically run `go fmt` when
    you save your file, so you don’t need to explicitly run the command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持任意的样式偏好一开始可能看起来很奇怪，特别是当它们与你的习惯不同时。然而，随着时间的推移，你应该会觉得这种一致性非常清新，因为你的代码将看起来和其他第三方包相似，并且更加有条理。大多数IDE都包含钩子，当你保存文件时会自动运行`go
    fmt`，因此你不需要显式地运行该命令。
- en: The golint and go vet Commands
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`golint`和`go vet`命令'
- en: Whereas `go fmt` changes the syntactical styling of your code, `golint` reports
    style mistakes such as missing comments, variable naming that doesn’t follow conventions,
    useless type specifications, and more. Notice that `golint` is a standalone tool,
    and not a subcommand of the main `go` binary. You’ll need to install it separately
    by using `go get -u golang.org/x/lint/golint`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`go fmt`改变你代码的语法样式不同，`golint`报告样式错误，例如缺少注释、变量命名不符合约定、无用的类型规格等。请注意，`golint`是一个独立的工具，而不是主`go`二进制文件的子命令。你需要通过运行`go
    get -u golang.org/x/lint/golint`单独安装它。
- en: Similarly, `go vet` inspects your code and uses heuristics to identify suspicious
    constructs, such as calling `Printf()` with the incorrect format string types.
    The `go vet` command attempts to identify issues, some of which might be legitimate
    bugs, that a compiler might miss.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`go vet`检查你的代码，并使用启发式方法来识别可疑的构造，例如使用不正确的格式字符串类型调用`Printf()`。`go vet`命令试图识别问题，其中一些可能是编译器无法发现的真正的BUG。
- en: Go Playground
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Go Playground
- en: The *Go Playground* is an execution environment hosted at [*https://play.golang.org/*](https://play.golang.org/)
    that provides a web-based frontend for developers to quickly develop, test, execute,
    and share snippets of Go code. The site makes it easy to try out various Go features
    without having to install or run Go on your local system. It’s a great way to
    test snippets of code before integrating them within your projects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Go Playground*是一个托管在[*https://play.golang.org/*](https://play.golang.org/)上的执行环境，为开发人员提供了一个基于网页的前端，能够快速开发、测试、执行并分享Go代码片段。该网站使得开发者可以在不安装或运行Go的情况下快速尝试各种Go功能。它是测试代码片段在集成到项目中之前的一个很好的方式。'
- en: It also allows you to simply play with various nuances of the language in a
    preconfigured environment. It’s worth noting that the Go Playground restricts
    you from calling certain dangerous functions to prevent you from, for example,
    executing operating-system commands or interacting with third-party websites.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许你在预配置的环境中轻松地体验语言的各种细微差别。值得注意的是，Go Playground 限制你调用某些危险的函数，以防止你例如执行操作系统命令或与第三方网站交互。
- en: Other Commands and Tools
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他命令和工具
- en: Although we won’t explicitly discuss other tools and commands, we encourage
    you to do your own research. As you create increasingly complex projects, you’re
    likely to run into a desire to, for example, use the `go test` tool to run unit
    tests and benchmarks, `cover` to check for test coverage, `imports` to fix import
    statements, and more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会明确讨论其他工具和命令，但我们鼓励你自己进行研究。随着你创建越来越复杂的项目，你可能会遇到需要使用 `go test` 工具来运行单元测试和基准测试、使用
    `cover` 来检查测试覆盖率、使用 `imports` 来修复导入语句等需求。
- en: Understanding Go Syntax
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Go 语法
- en: An exhaustive review of the entire Go language would take multiple chapters,
    if not an entire book. This section gives a brief overview of Go’s syntax, particularly
    relative to data types, control structures, and common patterns. This should act
    as a refresher for casual Go coders and an introduction for those new to the language.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个 Go 语言的全面回顾需要多章内容，甚至可能需要一本书。本节简要概述了 Go 的语法，特别是关于数据类型、控制结构和常见模式的内容。这应该为轻度使用
    Go 的程序员提供一个复习资料，也为新接触该语言的人提供一个入门介绍。
- en: For an in-depth, progressive review of the language, we recommend that you work
    through the excellent *A Tour of Go* (*[https://tour.golang.org/](https://tour.golang.org/)*)
    tutorial. It’s a comprehensive, hands-on discussion of the language broken into
    bite-sized lessons that use an embedded playground to enable you to try out each
    of the concepts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于深入、渐进式的语言回顾，我们推荐你通过优秀的 *Go 入门教程* (*[https://tour.golang.org/](https://tour.golang.org/)*)
    进行学习。该教程是对 Go 语言的全面、实践讨论，分为小节，并提供内嵌的 Playground，让你可以亲自尝试每个概念。
- en: The language itself is a much cleaner version of C that removes a lot of the
    lower-level nuances, resulting in better readability and easier adoption.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言本身是 C 的一种更加简洁的版本，去除了许多低级别的细节，从而提高了可读性和易用性。
- en: Data Types
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类型
- en: Like most modern programming languages, Go provides a variety of primitive and
    complex data types. *Primitive types* consist of the basic building blocks (such
    as strings, numbers, and booleans) that you’re accustomed to in other languages.
    Primitives make up the foundation of all information used within a program. *Complex
    data types* are user-defined structures composed of a combination of one or more
    primitive or other complex types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数现代编程语言一样，Go 提供了多种原始数据类型和复杂数据类型。*原始类型*由基本的构建块（如字符串、数字和布尔值）组成，这些构建块在其他语言中也很常见。原始类型构成了程序中所有信息的基础。*复杂数据类型*是用户定义的结构，由一个或多个原始类型或其他复杂类型的组合组成。
- en: Primitive Data Types
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: The primitive types include `bool`, `string`, `int`, `int8`, `int16`, `int32`,
    `int64`, `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr`, `byte`, `rune`,
    `float32`, `float64`, `complex64`, and `complex128`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型包括 `bool`、`string`、`int`、`int8`、`int16`、`int32`、`int64`、`uint`、`uint8`、`uint16`、`uint32`、`uint64`、`uintptr`、`byte`、`rune`、`float32`、`float64`、`complex64`
    和 `complex128`。
- en: 'You typically declare a variable’s type when you define it. If you don’t, the
    system will automatically infer the variable’s data type. Consider the following
    examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义变量时你会声明其类型。如果不声明，系统会自动推断变量的数据类型。考虑以下示例：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first example, you use the keyword `var` to define a variable named `x`
    and assign to it the value `"Hello World"`. Go implicitly infers `x` to be a `string`,
    so you don’t have to declare that type. In the second example, you use the `:=`
    operator to define a new variable named `z` and assign to it an integer value
    of 42\. There really is no difference between the two operators. We’ll use both
    throughout this book, but some people feel that the `:=` operator is an ugly symbol
    that reduces readability. Choose whatever works best for you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，你使用关键字 `var` 来定义一个名为 `x` 的变量，并为其赋值 `"Hello World"`。Go 会隐式地推断 `x` 是一个
    `string` 类型，因此你不需要显式声明类型。在第二个示例中，你使用 `:=` 运算符定义一个新变量 `z`，并为其赋值整数 42。实际上，这两个运算符没有什么区别。我们在本书中会使用这两者，但有些人觉得
    `:=` 运算符是一个丑陋的符号，影响可读性。选择最适合你的方式。
- en: In the preceding example, you explicitly wrap the 42 value in an `int` call
    to force a type on it. You could omit the `int` call but would have to accept
    whatever type the system automatically uses for that value. In some cases, this
    won’t be the type you intended to use. For instance, perhaps you want 42 to be
    represented as an unsigned integer, rather than an `int` type, in which case you’d
    have to explicitly wrap the value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你明确地使用`int`函数将42的值包装起来，强制指定其类型。你也可以省略`int`函数调用，但这时你必须接受系统自动为该值选择的类型。在某些情况下，这可能不是你打算使用的类型。例如，假设你希望42表示为无符号整数，而不是`int`类型，那么你必须明确地包装该值。
- en: Slices and Maps
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切片与映射
- en: Go also has more-complex data types, such as slices and maps. *Slices* are like
    arrays that you can dynamically resize and pass to functions more efficiently.
    *Maps* are associative arrays, unordered lists of key/value pairs that allow you
    to efficiently and quickly look up values for a unique key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go还有更复杂的数据类型，如切片和映射。*切片*类似于可以动态调整大小并更高效地传递给函数的数组。*映射*是关联数组，是无序的键/值对列表，允许你高效且快速地根据唯一键查找值。
- en: 'There are all sorts of ways to define, initialize, and work with slices and
    maps. The following example demonstrates a common way to define both a slice `s`
    and a map `m` and add elements to both:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式定义、初始化和操作切片与映射。以下示例展示了一种常见方式来定义切片`s`和映射`m`，并向其中添加元素：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code uses the two built-in functions: `make()` to initialize each variable
    and `append()` to add a new item to a slice. The last line adds the key/value
    pair of `some key` and `some value` to the map `m`. We recommend that you read
    the official Go documentation to explore all the methods for defining and using
    these data types.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了两个内建函数：`make()`来初始化每个变量，和`append()`来向切片中添加新项。最后一行将`some key`和`some value`的键值对添加到映射`m`中。我们建议你阅读官方Go文档，以深入了解所有定义和使用这些数据类型的方法。
- en: Pointers, Structs, and Interfaces
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指针、结构体和接口
- en: 'A *pointer* points to a particular area in memory and allows you to retrieve
    the value stored there. As you do in C, you use the `&` operator to retrieve the
    address in memory of some variable, and the `*` operator to dereference the address.
    The following example illustrates this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针*指向内存中的特定区域，并允许你检索存储在该位置的值。像在C语言中一样，你使用`&`操作符来获取某个变量在内存中的地址，使用`*`操作符来解除引用该地址。下面的示例说明了这一点：'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code defines an integer, `count` ❶, and then creates a pointer ❷ by using
    the `&` operator. This returns the address of the `count` variable. You dereference
    the variable ❸ while making a call to `fmt.Println()` to log the value of `count`
    to stdout. You then use the `*` operator ❹ to assign a new value to the memory
    location pointed to by `ptr`. Because this is the address of the `count` variable,
    the assignment changes the value of that variable, which you confirm by printing
    it to the screen ❺.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个整数`count`❶，然后使用`&`操作符创建了一个指针❷。这会返回`count`变量的地址。你通过调用`fmt.Println()`来解引用该变量❸，将`count`的值打印到标准输出。接着，你使用`*`操作符❹为指针`ptr`指向的内存位置分配一个新值。由于这是`count`变量的地址，赋值操作会改变该变量的值，你通过打印它到屏幕上❺来确认这一点。
- en: 'You use the *struct* type to define new data types by specifying the type’s
    associated fields and methods. For example, the following code defines a `Person`
    type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用*结构体*类型通过指定类型的相关字段和方法来定义新数据类型。例如，下面的代码定义了一个`Person`类型：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code uses the `type` keyword ❶ to define a new struct containing two fields:
    a `string` named `Name` ❷ and an `int` named `Age` ❸.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`type`关键字❶定义了一个新结构体，该结构体包含两个字段：一个名为`Name`的`string`❷和一个名为`Age`的`int`❸。
- en: You define a method, `SayHello()`, on the `Person` type assigned to variable
    `p` ❹. The method prints a greeting message to stdout by looking at the struct,
    `p` ❺, that received the call. Think of `p` as a reference to `self` or `this`
    in other languages. You also define a function, `main()`, which acts as the program’s
    entry point. This function uses the `new` keyword ❻ to initialize a new `Person`.
    It assigns the name `Dave` to the person ❼ and then tells the person to `SayHello()`
    ❽.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`Person`类型上定义了一个方法`SayHello()`，该方法分配给变量`p`❹。该方法通过查看接收调用的结构体`p`❺，向标准输出打印一条问候信息。可以将`p`视为其他语言中`self`或`this`的引用。你还定义了一个函数`main()`，它作为程序的入口点。这个函数使用`new`关键字❻来初始化一个新的`Person`。它将名字`Dave`分配给这个人❼，然后告诉这个人调用`SayHello()`❽。
- en: 'Structs lack scoping modifiers—such as private, public, or protected—that are
    commonly used in other languages to control access to their members. Instead,
    Go uses capitalization to determine scope: types and fields that begin with a
    capital letter are exported and accessible outside the package, whereas those
    starting with a lowercase letter are private, accessible only within the package.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体缺乏常见于其他语言中的作用域修饰符——如 private、public 或 protected，用于控制对其成员的访问。相反，Go 使用大小写字母来确定作用域：以大写字母开头的类型和字段是公开的，可以在包外访问，而以小写字母开头的是私有的，仅能在包内访问。
- en: 'You can think of Go’s *interface* type as a blueprint or a contract. This blueprint
    defines an expected set of actions that any concrete implementation must fulfill
    in order to be considered a type of that interface. To define an interface, you
    define a set of methods; any data type that contains those methods with the correct
    signatures fulfills the contract and is considered a type of that interface. Let’s
    take a look at an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Go 的 *interface* 类型看作一个蓝图或合同。这个蓝图定义了一个期望的操作集合，任何具体的实现必须满足这些操作，才能被视为该接口的类型。定义接口时，你定义了一组方法；任何包含这些方法且具有正确签名的数据类型都履行了合同，并被视为该接口的类型。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this sample, you’ve defined an interface called `Friend` ❶ that requires
    one method to be implemented: `SayHello()` ❷. That means that any type that implements
    the `SayHello()` method is a `Friend`. Notice that the `Friend` interface doesn’t
    actually implement that function—it just says that if you’re a `Friend`, you need
    to be able to `SayHello()`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你定义了一个名为 `Friend` ❶ 的接口，要求实现一个方法：`SayHello()` ❷。这意味着任何实现了 `SayHello()`
    方法的类型都是 `Friend`。请注意，`Friend` 接口并没有实际实现这个函数——它只是说，如果你是一个 `Friend`，你需要能够 `SayHello()`。
- en: 'The following function, `Greet()`, takes a `Friend` interface as input and
    says hello in a `Friend`-specific way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数 `Greet()` 接受一个 `Friend` 接口作为输入，并以特定于 `Friend` 的方式打招呼：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can pass any `Friend` type to the function. Luckily, the `Person` type
    used in the previous example can `SayHello()`—it’s a `Friend`. Therefore, if a
    function named `Greet()` ❶, as shown in the preceding code, expects a `Friend`
    as an input parameter ❷, you can pass it a `Person`, like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何 `Friend` 类型传递给该函数。幸运的是，在前面的示例中使用的 `Person` 类型可以 `SayHello()`——它是一个 `Friend`。因此，如果一个名为
    `Greet()` 的函数 ❶，如前面的代码所示，期望接收一个 `Friend` 作为输入参数 ❷，你可以像这样传递一个 `Person`：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using interfaces and structs, you can define multiple types that you can pass
    to the same `Greet()` function, so long as these types implement the `Friend`
    interface. Consider this modified example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口和结构体，你可以定义多个类型，只要这些类型实现了 `Friend` 接口，就可以将它们传递给相同的 `Greet()` 函数。考虑这个修改后的示例：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The example shows a new type, `Dog` ❶, that is able to `SayHello()` ❷ and, therefore,
    is a `Friend`. You are able to `Greet()` both a `Person` ❸ and a `Dog` ❹, since
    both are capable of `SayHello()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例展示了一个新类型 `Dog` ❶，它能够 `SayHello()` ❷，因此它是一个 `Friend`。你可以 `Greet()` 一个 `Person`
    ❸ 和一个 `Dog` ❹，因为它们都能 `SayHello()`。
- en: We’ll cover interfaces multiple times throughout the book to help you better
    understand the concept.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将在多次讲解接口的内容，帮助你更好地理解这一概念。
- en: Control Structures
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制结构
- en: Go contains slightly fewer control structures than other modern languages. Despite
    that, you can still accomplish complex processing, including conditionals and
    loops, with Go.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的控制结构比其他现代语言略少。尽管如此，你仍然可以使用 Go 完成复杂的处理任务，包括条件判断和循环。
- en: 'Go’s primary conditional is the if/else structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的主要条件语句是 if/else 结构：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go’s syntax deviates slightly from the syntax of other languages. For instance,
    you don’t wrap the conditional check—in this case, `x == 1`—in parentheses. You
    must wrap all code blocks, even the preceding single-line blocks, in braces. Many
    other modern languages make the braces optional for single-line blocks, but they’re
    required in Go.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的语法与其他语言的语法略有不同。例如，你不需要将条件判断（在本例中为 `x == 1`）放在括号中。你必须将所有代码块，包括前面的单行代码块，都用大括号包裹起来。许多其他现代语言对于单行代码块可以选择不使用大括号，但在
    Go 中大括号是必须的。
- en: 'For conditionals involving more than two choices, Go provides a `switch` statement.
    The following is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及多个选择的条件判断，Go 提供了 `switch` 语句。以下是一个示例：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the `switch` statement compares the contents of a variable
    `x` ❶ against various values—`foo` ❷ and `bar` ❸—and logs a message to stdout
    if `x` matches one of the conditions. This example includes a `default` case ❹,
    which executes in the event that none of the other conditions match.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`switch`语句将变量`x`的内容❶与不同的值进行比较——`foo`❷和`bar`❸——如果`x`匹配其中一个条件，则向标准输出（stdout）记录一条消息。这个示例包括一个`default`语句❹，在没有其他条件匹配时执行。
- en: Note that, unlike many other modern languages, your cases don’t have to include
    `break` statements. In other languages, execution often continues through each
    of the cases until the code reaches a `break` statement or the end of the `switch`.
    Go will execute no more than one matching or default case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与许多其他现代语言不同，你的`case`语句不需要包含`break`语句。在其他语言中，执行通常会继续遍历每个`case`，直到代码达到`break`语句或`switch`的结尾。而Go只会执行一个匹配的或默认的`case`。
- en: 'Go also contains a special variation on the `switch` called a *type switch*
    that performs type assertions by using a `switch` statement. Type switches are
    useful for trying to understand the underlying type of an interface. For example,
    you might use a type switch to retrieve the underlying type of an interface called
    `i`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go还包含一个特殊的`switch`变体，称为*类型开关*，通过使用`switch`语句执行类型断言。类型开关对于尝试理解接口的底层类型非常有用。例如，你可能会使用类型开关来获取名为`i`的接口的底层类型：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example uses special syntax, `i.(type)` ❷, to retrieve the type of the
    `i` `interface` variable ❶. You use this value in a `switch` statement in which
    each case matches against a specific type. In this example, your cases check for
    `int` or `string` primitive types, but you could very well check for pointers
    or user-defined struct types, for instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用特殊语法`i.(type)`❷来获取`i`接口变量❶的类型。你将这个值用于一个`switch`语句，其中每个`case`匹配特定的类型。在这个示例中，`case`检查`int`或`string`原始类型，但你也可以检查指针或用户定义的结构体类型等。
- en: 'Go’s last flow control structure is the `for` loop. The `for` loop is Go’s
    exclusive construct for performing iteration or repeating sections of code. It
    might seem odd to not have conventions such as `do` or `while` loops at your disposal,
    but you can re-create them by using variations of the `for` loop syntax. Here’s
    one variation of a `for` loop:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Go的最后一个流程控制结构是`for`循环。`for`循环是Go专用的用于执行迭代或重复代码段的构造。虽然没有像`do`或`while`这样的循环语法可能显得奇怪，但你可以通过使用`for`循环语法的变体来重新创建它们。以下是`for`循环的一个变体：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code loops through numbers 0 to 9, printing each number to stdout. Notice
    the semicolons in the first line. Unlike many other languages, which use semicolons
    as line delimiters, Go uses them for various control structures to perform multiple
    distinct, but related, subtasks in a single line of code. The first line uses
    the semicolons to separate the initialization logic (`i := 0`), the conditional
    expression (`i < 10`), and the post statement (`i++`). This structure should be
    very, very familiar to anyone who has coded in any modern language, as it closely
    follows the conventions of those languages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码循环打印0到9的数字，每个数字都打印到标准输出。注意第一行中的分号。与许多其他语言不同，Go使用分号来分隔不同的控制结构，使得在单行代码中执行多个不同但相关的子任务。第一行使用分号将初始化逻辑（`i
    := 0`）、条件表达式（`i < 10`）和后置语句（`i++`）分开。这种结构对于任何在现代语言中编写过代码的人来说应该非常熟悉，因为它紧跟这些语言的约定。
- en: 'The following example shows a slight variation of the `for` loop that loops
    over a collection, such as a slice or a map:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`for`循环的一个稍微变化的版本，循环遍历一个集合，如切片或映射：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, you initialize a slice of integers named `nums` ❶. You then
    use the keyword `range` ❹ within the `for` loop to iterate over the slice. The
    `range` keyword returns two values: the current index ❷ and a copy of the current
    value ❸ at that index. If you don’t intend to use the index, you could replace
    `idx` in the `for` loop with an underscore to tell Go you won’t need it.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你初始化了一个名为`nums`的整数切片❶。然后在`for`循环中使用关键字`range`❹来遍历切片。`range`关键字返回两个值：当前索引❷和该索引处的当前值的副本❸。如果你不打算使用索引，你可以将`for`循环中的`idx`替换为下划线，告诉Go你不需要它。
- en: You can use this exact same looping logic with maps as well to return each key/value
    pair.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用相同的循环逻辑与映射（maps）一起，返回每个键/值对。
- en: Concurrency
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并发
- en: Much like the control structures already reviewed, Go has a much simpler concurrency
    model than other languages. To execute code concurrently, you can use *goroutines*,
    which are functions or methods that can run simultaneously. These are often described
    as *lightweight threads* because the cost of creating them is minimal when compared
    to actual threads.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与已经回顾过的控制结构类似，Go拥有比其他语言更简洁的并发模型。为了并发执行代码，你可以使用*goroutines*，它们是可以同时运行的函数或方法。由于创建它们的开销相对于实际线程非常小，所以它们通常被描述为*轻量级线程*。
- en: 'To create a goroutine, use the `go` keyword before the call to a method or
    function you wish to run concurrently:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个goroutine，在你希望并发运行的方法或函数调用前使用`go`关键字：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, you define a function, `f()` ❶, that you call in your `main()`
    function, the program’s entry point. You preface the call with the keyword `go`
    ❷, meaning that the program will run function `f()` concurrently; in other words,
    the execution of your `main()` function will continue without waiting for `f()`
    to complete. You then use a `time.Sleep(1 * time.Second)` to force the `main()`
    function to pause temporarily so that `f()` can complete. If you didn’t pause
    the `main()` function, the program would likely exit prior to the completion of
    function `f()`, and you would never see its results displayed to stdout. Done
    correctly, you’ll see messages printed to stdout indicating that you’ve finished
    executing both the `f()` and `main()` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你定义了一个函数`f()` ❶，并在`main()`函数中调用它，`main()`函数是程序的入口点。你在调用前加上了关键字`go` ❷，这意味着程序将并发运行`f()`函数；换句话说，`main()`函数的执行将继续进行，而不等待`f()`完成。然后，你使用`time.Sleep(1
    * time.Second)`强制`main()`函数暂停，给`f()`足够的时间完成。如果你没有暂停`main()`函数，程序很可能会在`f()`函数完成之前退出，结果你将无法看到它的输出。正确执行后，你会看到一些消息被打印到标准输出，表明你已经完成了`f()`和`main()`函数的执行。
- en: 'Go contains a data type called *channels* that provide a mechanism through
    which goroutines can synchronize their execution and communicate with one another.
    Let’s look at an example that uses channels to display the length of different
    strings and their sum simultaneously:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Go包含了一种称为*通道*的数据类型，它提供了一种机制，允许goroutines同步执行并相互通信。让我们来看一个使用通道的例子，同时显示不同字符串的长度及其总和：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, you define and use a variable `c` of type `chan int`. You can define
    channels of various types, depending on the type of data you intend to pass via
    the channel. In this case, you’ll be passing the lengths of various strings as
    integer values between goroutines, so you should use an `int` channel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义并使用了一个类型为`chan int`的变量`c`。你可以根据打算通过通道传递的数据类型来定义不同类型的通道。在这个例子中，你将传递不同字符串的长度作为整数值，在goroutines之间传递，因此应该使用`int`类型的通道。
- en: 'Notice a new operator: `<-`. This operator indicates whether the data is flowing
    to or from a channel. You can think of this as the equivalent of placing items
    into a bucket or removing items from a bucket.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个新的操作符：`<-`。这个操作符表示数据是流入还是流出一个通道。你可以把它理解为将物品放入桶中或从桶中取出物品的等价操作。
- en: The function you define, `strlen()` ❶, accepts a word as a string, as well as
    a channel that you’ll use for synchronizing data. The function contains a single
    statement, `c <- len(s)` ❷, which uses the built-in `len()` function to determine
    the length of the string, and then puts the result into the `c` channel by using
    the `<-` operator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义的函数`strlen()` ❶接受一个字符串类型的单词以及一个用于同步数据的通道。这个函数包含一个语句`c <- len(s)` ❷，它使用内置的`len()`函数来计算字符串的长度，然后通过`<-`操作符将结果放入`c`通道。
- en: The `main()` function pieces everything together. First, you issue a call to
    `make(chan int)` ❸ to create the integer channel. You then issue multiple concurrent
    calls to the `strlen()` function by using the `go` keyword ❹, which spins up multiple
    goroutines. You pass to the `strlen()` function two string values, as well as
    the channel into which you want the results placed. Lastly, you read data from
    the channel by using the `<-` operator ❺, this time with data flowing from the
    channel. This means you’re taking items out of your bucket, so to speak, and assigning
    those values to the variables `x` and `y`. Note that execution blocks at this
    line until adequate data can be read from the channel.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数将所有内容串联在一起。首先，你调用 `make(chan int)` ❸ 创建整数通道。然后，你通过使用 `go` 关键字 ❹
    发起多个并发调用 `strlen()` 函数，这会启动多个 goroutine。你将两个字符串值以及结果放入的通道传递给 `strlen()` 函数。最后，你使用
    `<-` 操作符 ❺ 从通道中读取数据，这次数据从通道流出。这意味着你从桶中取出物品，可以把这些值赋给变量 `x` 和 `y`。请注意，在这行代码执行时，程序会阻塞，直到能从通道中读取到足够的数据。'
- en: 'When the line completes, you display the length of each string as well as their
    sum to stdout. In this example, it produces the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一行执行完成时，你将显示每个字符串的长度以及它们的总和输出到标准输出（stdout）。在这个示例中，它会产生如下输出：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This may seem overwhelming, but it’s key to highlight basic concurrency patterns,
    as Go shines in this area. Because concurrency and parallelism in Go can become
    rather complicated, feel free to explore on your own. Throughout this book, we’ll
    talk about more realistic and complicated implementations of concurrency as we
    introduce buffered channels, wait groups, mutexes, and more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能有些复杂，但关键在于突出 Go 在基本并发模式方面的优势，因为 Go 在这方面表现出色。由于 Go 中的并发和并行处理可能变得相当复杂，因此你可以自行探索。在本书的后续章节中，我们会介绍更多现实且复杂的并发实现，包括缓冲通道、等待组、互斥锁等。
- en: Error Handling
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误处理
- en: Unlike most other modern programming languages, Go does not include syntax for
    try/catch/finally error handling. Instead, it adopts a minimalistic approach that
    encourages you to check for errors where they occur rather than allowing them
    to “bubble up” to other functions in the call chain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他现代编程语言不同，Go 不包括用于 `try/catch/finally` 错误处理的语法。相反，它采用了一种极简主义的方法，鼓励你在发生错误的地方进行检查，而不是让错误“冒泡”到调用链中的其他函数。
- en: 'Go defines a built-in error type with the following `interface` declaration:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go 定义了一个内建的错误类型，其 `interface` 声明如下：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means you can use any data type that implements a method named `Error()`,
    which returns a `string` value, as an `error`. For example, here’s a custom error
    you could define and use throughout your code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以使用任何实现了名为 `Error()` 方法并返回 `string` 类型值的数据类型作为 `error`。例如，以下是你可以定义并在代码中使用的自定义错误：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You create a user-defined string type named `MyError` ❶ and implement an `Error()
    string` method ❷ for the type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为 `MyError` 的用户定义字符串类型 ❶，并为该类型实现了一个 `Error() string` 方法 ❷。
- en: 'When it comes to error handling, you’ll quickly get accustomed to the following
    pattern:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理错误时，你将很快适应以下模式：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You’ll find that it’s fairly common for functions and methods to return at least
    one value. One of these values is almost always an `error`. In Go, the `error`
    returned may be a value of `nil`, indicating that the function generated no error
    and everything seemingly ran as expected. A non-`nil` value means something broke
    in the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，函数和方法返回至少一个值是相当常见的。这个值几乎总是一个 `error`。在 Go 中，返回的 `error` 值可能是 `nil`，这表示函数没有生成错误，一切看似按预期运行。非
    `nil` 值意味着函数中出现了问题。
- en: Thus, you can check for errors by using an `if` statement, as shown in the `main()`
    function. You’ll typically see multiple statements, separated by a semicolon.
    The first statement calls the function and assigns the resulting error to a variable
    ❶. The second statement then checks whether that `error` is `nil` ❷. You use the
    body of the `if` statement to handle the error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以通过使用 `if` 语句来检查错误，如 `main()` 函数中所示。你通常会看到多个语句，语句之间用分号分隔。第一个语句调用函数并将结果错误分配给一个变量
    ❶。第二个语句检查该 `error` 是否为 `nil` ❷。你可以在 `if` 语句的主体中处理错误。
- en: You’ll find that philosophies differ on the best way to handle and log errors
    in Go. One of the challenges is that, unlike other languages, Go’s built-in error
    type doesn’t implicitly include a stack trace to help you pinpoint the error’s
    context or location. Although you can certainly generate one and assign it to
    a custom type in your application, its implementation is left up to the developers.
    This can be a little annoying at first, but you can manage it through proper application
    design.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，关于在Go中如何处理和记录错误的最佳方式，存在不同的哲学观点。一个挑战是，与其他语言不同，Go内置的错误类型并不隐式包含堆栈跟踪，这帮助您定位错误的上下文或位置。尽管您可以当然生成一个堆栈跟踪并将其分配给应用中的自定义类型，但它的实现完全由开发人员决定。一开始这可能有点令人烦恼，但您可以通过适当的应用设计来管理它。
- en: Handling Structured Data
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理结构化数据
- en: Security practitioners will often write code that handles *structured data*,
    or data with common encoding, such as JSON or XML. Go contains standard packages
    for data encoding. The most common packages you’re likely to use include `encoding/json`
    and `encoding/xml`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 安全从业人员经常编写处理*结构化数据*的代码，或者是具有常见编码的数据，例如JSON或XML。Go包含用于数据编码的标准包。您可能会使用的最常见的包包括`encoding/json`和`encoding/xml`。
- en: 'Both packages can marshal and unmarshal arbitrary data structures, which means
    they can turn strings to structures, and structures to strings. Let’s look at
    the following sample, which serializes a structure to a byte slice and then subsequently
    deserializes the byte slice back to a structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两个包都可以对任意数据结构进行序列化和反序列化，这意味着它们可以将字符串转换为结构体，将结构体转换为字符串。让我们看一下以下示例，它将结构体序列化为字节切片，然后将字节切片反序列化回结构体：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code (which deviates from best practices and ignores possible errors)
    defines a `struct` type named `Foo` ❶. You initialize it in your `main()` function
    ❷ and then make a call to `json.Marshal()` ❹, passing it the `Foo` instance ❺.
    This `Marshal()` method encodes the `struct` to JSON, returning a `byte` slice
    ❸ that you subsequently print to stdout ❻. The output, shown here, is a JSON-encoded
    string representation of our `Foo` struct:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码（偏离最佳实践并忽略了可能的错误）定义了一个名为`Foo`的`struct`类型❶。您在`main()`函数中初始化它❷，然后调用`json.Marshal()`❹，将`Foo`实例❺传递给它。这个`Marshal()`方法将`struct`编码为JSON，返回一个`byte`切片❸，您随后将其打印到标准输出❻。这里显示的输出是我们`Foo`结构的JSON编码字符串表示：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Lastly, you take that same `byte` slice ❼ and decode it via a call to `json.Unmarshal(b,
    &f)`. This produces a `Foo` struct instance ❽. Dealing with XML is nearly identical
    to this process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将相同的`byte`切片❼传递给`json.Unmarshal(b, &f)`进行解码。这将生成一个`Foo`结构实例❽。处理XML的过程与此几乎相同。
- en: 'When working with JSON and XML, you’ll commonly use *field tags*, which are
    metadata elements that you assign to your struct fields to define how the marshaling
    and unmarshaling logic can find and treat the affiliated elements. Numerous variations
    of these field tags exist, but here is a short example that demonstrates their
    usage for handling XML:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理JSON和XML时，您通常会使用*字段标签*，这些是您分配给结构体字段的元数据元素，用于定义序列化和反序列化逻辑如何查找和处理关联的元素。存在多种变体的字段标签，但这里有一个简短的示例，演示了如何使用它们来处理XML：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The string values, wrapped in backticks and following the struct fields, are
    field tags. *Field tags* always begin with the tag name (`xml` in this case),
    followed by a colon and the directive enclosed in double quotes. The *directive*
    defines how the fields should be handled. In this case, you are supplying directives
    that declare that `Bar` should be treated as an attribute named `id`, not an element,
    and that `Baz` should be found in a subelement of `parent`, named `child`. If
    you modify the previous JSON example to now encode the structure as XML, you would
    see the following result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值，使用反引号包裹并跟随结构体字段的是字段标签。*字段标签*总是以标签名称（在此情况下为`xml`）开头，后跟一个冒号和用双引号括起来的指令。*指令*定义了字段应如何处理。在这种情况下，您提供的指令声明`Bar`应作为名为`id`的属性处理，而不是作为元素，并且`Baz`应位于`parent`的子元素`child`中。如果您将之前的JSON示例修改为现在以XML编码结构，您将看到以下结果：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The XML encoder reflectively determines the names of elements, using the tag
    directives, so each field is handled according to your needs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: XML编码器通过反射确定元素的名称，使用标签指令，因此每个字段都根据您的需求进行处理。
- en: Throughout this book, you’ll see these field tags used for dealing with other
    data serialization formats, including ASN.1 and MessagePack. We’ll also discuss
    some relevant examples of defining your own custom tags, specifically when you
    learn how to handle the Server Message Block (SMB) Protocol.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将看到这些字段标签被用于处理其他数据序列化格式，包括ASN.1和MessagePack。我们还将讨论一些定义自定义标签的相关示例，特别是当你学习如何处理服务器消息块（SMB）协议时。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you set up your Go environment and learned about the fundamental
    aspects of the Go language. This is not an exhaustive list of all Go’s characteristics;
    the language is far too nuanced and large for us to cram it all into a single
    chapter. Instead, we included the aspects that will be most useful in the chapters
    that follow. We’ll now turn our attention to practical applications of the language
    for security practitioners and hackers. Here we Go!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你设置了Go环境并了解了Go语言的基本方面。这不是Go语言所有特性的详尽列表；该语言的细节和规模远远超出了我们在单一章节中所能囊括的内容。相反，我们包括了在接下来的章节中最有用的方面。现在我们将注意力转向安全从业人员和黑客的语言实际应用。现在，开始吧！
