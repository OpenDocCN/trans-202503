<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_25"/><span class="big">3</span><br/>TYPES AND ENTITIES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">The idea that every expression has a type is central to Haskell. Haskell has several built-in types available to us in the Prelude and a system for making our own types. In this chapter, we’ll discuss some of the built-in types, and in <a href="ch10.xhtml">Chapter 10</a>, we’ll see how to make types of our own.</p>&#13;
<h3 class="h3" id="ch3lev1">Basic Types</h3>&#13;
<p class="noindent">Types reflect the nature of information. For example, in physics, we want to know whether something is a scalar or a vector. These are different types. It makes no sense to add a scalar to a vector, and the computer can prevent us from making this mistake if we use a good system of types.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3tab1">Table 3-1</a> shows Haskell’s most important basic types.</p>&#13;
<p class="tabcap" id="ch3tab1"><strong>Table 3-1:</strong> Haskell’s Basic Types</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Examples</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Bool</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Boolean</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False, True</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Character</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>'h', '7'</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>String</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">String</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>"101 N. College Ave."</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Int</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Small (machine-precision) integer</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>42</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Integer</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Arbitrarily large integer</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>18446744073709551616</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Float</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Single-precision floating point</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>0.33333334</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>Double</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Double-precision floating point</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>0.3333333333333333</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>The <code>Bool</code> type is for values that are either true or false, like the result of a comparison. For example, <code>3 &gt; 4</code> evaluates to <code>False</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">3 &gt; 4</span>&#13;
False</pre>&#13;
<p class="indent">The <code>Char</code> type is for single characters. The <code>String</code> type is for a sequence of characters. The types <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code> are for numbers.</p>&#13;
<p class="indent">Let’s take a closer look at each of these types.</p>&#13;
<h4 class="h4" id="ch3lev2">The Boolean Type</h4>&#13;
<p class="noindent">The <code>Bool</code> type has only two possible values: <code>False</code> and <code>True</code>. The type is used for expressions that are meant to represent claims that might be true or false.</p>&#13;
<p class="indent">Haskell has an <code>if-then-else</code> expression whose value depends on a Boolean. The expression has the form <code>if</code> <code>b</code> <code>then</code> <code>c</code> <code>else</code> <code>a</code>. Here <code>b</code> is an expression of type <code>Bool</code> called the <em>condition</em> is called the <em>consequent</em> is called the <em>alternative</em>. Haskell’s type system demands not only that <code>b</code> have type <code>Bool</code> but also that the consequent <code>c</code> and the alternative <code>a</code> have the same type (this can be any type, <code>Bool</code> or something else). If the condition <code>b</code> evaluates to <code>True</code>, the entire <code>if-then-else</code> expression evaluates to <code>c</code>; if the condition <code>b</code> evaluates to <code>False</code>, the entire <code>if-then-else</code> expression evaluates to <code>a</code>.</p>&#13;
<p class="indent">If you are familiar with an imperative language like Python or C, it may help to realize that Haskell’s <code>if-then-else</code> construction is an <em>expression</em>, not a statement. An expression evaluates to a value. In imperative languages, <code>if-then</code> constructions are typically statements that are executed if the condition is true and ignored otherwise. In an imperative language, the <code>else</code> clause is optional; that is, it’s only used when there are statements to be executed if the condition is false. Because the <code>if-then-else</code> construction in a functional language is an expression, the <code>else</code> clause is mandatory, not optional. <em>Some</em> value must be returned whether the condition is true or false.</p>&#13;
<p class="indent">As an example of the <code>if-then-else</code> expression, consider the following function (which is sometimes called the <em>Heaviside step function</em> or the <em>unit step function</em>):</p>&#13;
<div class="imagec"><img src="Images/026equ01.jpg" alt="Image" width="450" height="50"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>We can write a definition for this function in Haskell using the <code>if-then-else</code> construction. In Haskell, we are not allowed to begin the names of constants or functions with a capital letter (recall the discussion of variable identifiers in the last chapter), so we’ll call this function <code>stepFunction</code>.</p>&#13;
<pre>stepFunction :: Double -&gt; Double&#13;
stepFunction x = if x &lt;= 0&#13;
                 then 0&#13;
                 else 1</pre>&#13;
<p class="indent">The function <code>stepFunction</code> accepts a <code>Double</code> as input (called <code>x</code> in the definition) and returns a <code>Double</code> as output. The expression <code>x &lt;= 0</code> is the condition, the expression <code>0</code> is the consequent, and the expression <code>1</code> is the alternative.</p>&#13;
<p class="indent">The Prelude provides a few functions that work with Booleans. The first is <code>not</code>, which has type <code>Bool -&gt; Bool</code>, meaning it accepts a Boolean as input and gives another Boolean as output. The function <code>not</code> returns <code>True</code> if its input is <code>False</code> and returns <code>False</code> if its input is <code>True</code>. You can see this for yourself in GHCi if you type</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">not False</span>&#13;
True</pre>&#13;
<p class="noindent">or</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">not True</span>&#13;
False</pre>&#13;
<p class="noindent">at the GHCi prompt.</p>&#13;
<p class="indent">As you saw in <a href="ch02.xhtml">Chapter 2</a>, GHCi has a command <code>:type</code> (<code>:t</code> for short) that asks about the type of something. You can ask GHCi for the type of <code>not</code> by entering</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t not</span>&#13;
not :: Bool -&gt; Bool</pre>&#13;
<p class="noindent">at the GHCi prompt. GHCi commands that start with a colon are not part of the Haskell language itself. You cannot use the colon commands in a Haskell program file.</p>&#13;
<p class="indent">The Boolean AND operator <code>&amp;&amp;</code> takes two Booleans as input and gives one Boolean as output. The output is <code>True</code> only when both inputs are <code>True</code>, and it’s <code>False</code> otherwise. <a href="ch03.xhtml#ch3tab2">Table 3-2</a> describes the behavior of the <code>&amp;&amp;</code> operator.</p>&#13;
<p class="tabcap" id="ch3tab2"><strong>Table 3-2:</strong> Definition of the AND Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>y</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em> <code>&amp;&amp;</code> <em>y</em></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>False</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>The Boolean OR operator <code>||</code> takes two Booleans as input and gives one Boolean as output. The output is <code>False</code> only when both inputs are <code>False</code>, and it’s <code>True</code> otherwise. <a href="ch03.xhtml#ch3tab3">Table 3-3</a> describes the behavior of the <code>||</code> operator.</p>&#13;
<p class="tabcap" id="ch3tab3"><strong>Table 3-3:</strong> Definition of the OR Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>y</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em> <code>||</code> <em>y</em></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>True</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>True</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>True</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These operators are listed in <a href="ch01.xhtml#ch1tab2">Table 1-2</a> with their precedence and associativity. You can play with them in GHCi, asking for evaluations of expressions such as</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">True</span> || <span class="codestrong1">False &amp;&amp; True</span>&#13;
True</pre>&#13;
<p class="noindent">at the GHCi prompt.</p>&#13;
<h4 class="h4" id="ch3lev3">The Character Type</h4>&#13;
<p class="noindent">The <code>Char</code> type is for single characters, including uppercase and lowercase letters, digits, and some special characters (like the newline character, which produces a new line of text). Here are some examples of character definitions:</p>&#13;
<pre>ticTacToeMarker :: Char&#13;
ticTacToeMarker = 'X'&#13;
&#13;
newLine :: Char&#13;
newLine = '\n'</pre>&#13;
<p class="indent">There is very little reason to make these definitions because any place we could use <code>newLine</code>, for example, we could just as easily use <code>'\n'</code>, which takes up less space. We do it here only to show the relationship between the term <code>'X'</code> and the type <code>Char</code>. As shown in the examples above, a character can be formed by enclosing a single letter or digit in single quotes.</p>&#13;
<h4 class="h4" id="ch3lev4">The String Type</h4>&#13;
<p class="noindent">A string is a sequence of characters. (In <a href="ch05.xhtml">Chapter 5</a>, we’ll learn that a string is a <em>list</em> of characters, where list has a precise meaning.) Here are some examples:</p>&#13;
<pre>hello :: String&#13;
hello = "Hello, world!"&#13;
&#13;
errorMessage :: String&#13;
errorMessage = "Can't take the square root of a Boolean!"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_29"/>These definitions are not as useless as the ones shown earlier for characters, because although <code>"Hello, world!"</code> is entirely equivalent to <code>hello</code>, the name <code>hello</code> is at least shorter and easier to type than the string it represents. If such a string was needed at several different places in a program, that would justify the definition of a name such as <code>hello</code>. To form a string from a sequence of characters, we enclose the character sequence in double quotes.</p>&#13;
<h4 class="h4" id="ch3lev5">Numeric Types</h4>&#13;
<p class="noindent">The basic numeric types are <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code>. The <code>Int</code> type is for small integers. A 32-bit machine will use 32 bits to represent an <code>Int</code>, which gives numbers up to a few billion. A 64-bit machine will use 64 bits to represent an <code>Int</code>, which gives numbers up to about 10<sup>18</sup>. The <code>Integer</code> type is for arbitrary integers. The computer will use whatever number of bits it needs to represent an <code>Integer</code> exactly. On my 64-bit machine, I get the following results:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">10^18 :: Int</span>&#13;
1000000000000000000&#13;
Prelude&gt; <span class="codestrong1">10^18 :: Integer</span>&#13;
1000000000000000000&#13;
Prelude&gt; <span class="codestrong1">10^19 :: Int</span>&#13;
-8446744073709551616&#13;
Prelude&gt; <span class="codestrong1">10^19 :: Integer</span>&#13;
10000000000000000000</pre>&#13;
<p class="indent">Notice that I get no error message about going too high with <code>Int</code>; I just get the wrong answer. The <code>Int</code> type is good for almost any kind of counting you might ask the computer to do. The computer can’t count up to 10<sup>18</sup> because it takes too long.</p>&#13;
<p class="indent">The <code>Float</code> type is for approximations to real numbers and has a precision of about 7 decimal digits. The <code>Double</code> type is for approximations to real numbers and has a precision of about 15 decimal digits. I always choose <code>Double</code> for my real numbers unless I am using a library written by someone else that uses <code>Float</code>.</p>&#13;
<p class="indent">The numeric examples in the rightmost column of <a href="ch03.xhtml#ch3tab1">Table 3-1</a> <em>can be</em> expressions of the type indicated, but an expression by itself, such as <code>42</code>, does not <em>necessarily</em> have type <code>Int</code>. To be specific, <code>False</code> and <code>True</code> must have type <code>Bool</code>, <code>'h'</code> and <code>'7'</code> must have type <code>Char</code>, and <code>"101 N. College Ave."</code> must have type <code>String</code>. On the other hand, <code>42</code> could have type <code>Int</code>, <code>Integer</code>, <code>Float</code>, or <code>Double</code>. Clarifying this ambiguity is one reason to give a type signature with each name you define in a Haskell program. Without a type signature, the compiler cannot tell which of the four numeric types you might want for a <span epub:type="pagebreak" id="page_30"/>number like <code>18446744073709551616</code>. Any of the four numeric types would try to hold the number, but only <code>Integer</code> would represent the number exactly. The complexity of numeric types in Haskell is related to a more advanced language feature called <em>type classes</em>, which we’ll discuss in <a href="ch08.xhtml">Chapter 8</a>.</p>&#13;
<p class="indent">The four numeric types in <a href="ch03.xhtml#ch3tab1">Table 3-1</a> are not the only numeric types in the Prelude. The Prelude includes a <code>Rational</code> type for rational numbers that we won’t use in this book but that you can explore on your own if you are interested. Complex numbers are provided by a library module called <code>Data.Complex</code>. We won’t use complex numbers in this book.</p>&#13;
<h3 class="h3" id="ch3lev6">Function Types</h3>&#13;
<p class="noindent">Haskell provides several ways to form new types from existing types. Given any two types <code>a</code> and <code>b</code>, there is a type <code>a -&gt; b</code> for functions that take an expression of type <code>a</code> as input and produce an expression of type <code>b</code> as output. Here is an example:</p>&#13;
<pre>isX :: Char -&gt; Bool&#13;
isX c = c == 'X'</pre>&#13;
<p class="indent">The function <code>isX</code> takes a character as input and gives a Boolean as output. The function returns <code>True</code> if the input character is <code>'X'</code> and returns <code>False</code> otherwise. Adding parentheses may help in reading the function definition. The definition is equivalent to</p>&#13;
<pre>isX c = (c == 'X')</pre>&#13;
<p class="indent">In general in a definition, the name on the left of the single equal sign (<code>=</code>) is being defined (<code>isX</code> in this case), and the expression on the right of the single equal sign is the body of the definition. The expression <code>c == 'X'</code> uses the equality operator <code>==</code> from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> to ask if the input character <code>c</code> is the same as <code>'X'</code>.</p>&#13;
<p class="indent">If we put this function definition into a Haskell program file (for example, <em>FunctionType.hs</em>) and load it into GHCi,</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l FunctionType.hs</span>&#13;
[1 of 1] Compiling Main            ( FunctionType.hs, interpreted )&#13;
Ok, one module loaded.</pre>&#13;
<p class="noindent">we can ask about the types of things. If we ask about the type of <code>isX</code>,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t isX</span>&#13;
isX :: Char -&gt; Bool</pre>&#13;
<p class="noindent">we see what we wrote in our type signature. In GHCi, we can also ask for the type of <code>isX 't'</code>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t isX 't'</span>&#13;
isX 't' :: Bool</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>This makes sense because the expression <code>isX 't'</code> represents the function isX applied to the character argument <code>'t'</code>. Therefore, the type represents the type of the output of <code>isX</code>, namely <code>Bool</code>.</p>&#13;
<p class="indent">We can also ask GHCi for the <em>value</em> of <code>isX 't'</code> (as opposed to the type of the expression). If we enter <code>isX 't'</code> at the GHCi prompt,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">isX 't'</span>&#13;
False</pre>&#13;
<p class="noindent">we see that the value of <code>isX 't'</code> is <code>False</code> because <code>'t'</code> is not equal to <code>'X'</code>.</p>&#13;
<p class="indent">Here is an example of a function with type <code>Bool -&gt; String</code>:</p>&#13;
<pre>bagFeeMessage :: Bool -&gt; String&#13;
bagFeeMessage checkingBags = if checkingBags&#13;
                             then "There is a $100 fee."&#13;
                             else "There is no fee."</pre>&#13;
<p class="indent">The function <code>bagFeeMessage</code> takes a Boolean as input and gives a string as output. The input Boolean (called <code>checkingBags</code>) is intended to represent an answer (<code>True</code> or <code>False</code>) to the question of whether a passenger is checking bags. The style of naming a variable by sticking words together without spaces and using a capital letter at the beginning of the second and subsequent words is common in Haskell programming.</p>&#13;
<p class="indent">There is an alternative way to write the function <code>bagFeeMessage</code> that uses a facility in Haskell called <em>pattern matching</em>. Some data types have one or more patterns that values of that type fall into. The idea behind pattern matching for <code>Bool</code> is that the only possible values are <code>False</code> and <code>True</code>, so why not just give the output for each possible input? The fundamental way of achieving pattern matching is with the <code>case</code>-<code>of</code> construction. Here is what the function looks like using pattern matching:</p>&#13;
<pre>bagFeeMessage2 :: Bool -&gt; String&#13;
bagFeeMessage2 checkingBags = case checkingBags of&#13;
                                False -&gt; "There is no fee."&#13;
                                True  -&gt; "There is a $100 fee."</pre>&#13;
<p class="indent">This doesn’t look so different from the <code>if</code>-<code>then</code>-<code>else</code> construction, but the <code>case</code>-<code>of</code> construction is more general because it can be used with other data types, not just <code>Bool</code>. In <a href="ch05.xhtml">Chapter 5</a>, for example, we will see that every list falls into one of two patterns that can be distinguished using the <code>case</code>-<code>of</code> construction.</p>&#13;
<p class="indent">Although the <code>case</code>-<code>of</code> construction is the basic way to do pattern matching, Haskell provides some syntactic sugar for the special case in which we want to pattern match on the input to a function.</p>&#13;
<pre>bagFeeMessage3 :: Bool -&gt; String&#13;
bagFeeMessage3 False = "There is no fee."&#13;
bagFeeMessage3 True  = "There is a $100 fee."</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>By using pattern matching on the input, we have avoided using the <code>if</code>-<code>then</code>-<code>else</code> construction. Also, we no longer need the variable <code>checkingBags</code>, which held the input value.</p>&#13;
<h3 class="h3" id="ch3lev7">Summary</h3>&#13;
<p class="noindent">Haskell has built-in types and facilities for making our own types. Types are intended to describe the meaning of data. This chapter looks at seven of the most common built-in types: <code>Bool</code>, <code>Char</code>, <code>String</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, and <code>Double</code>. It also considers function types, which are very important to the language because functions play such a central role. We got a first glimpse of pattern matching, both with the <code>case</code>-<code>of</code> construction and by pattern matching on the input. In the next chapter, we begin our physics work, starting with motion in one dimension.</p>&#13;
<h3 class="h3" id="ch3lev8">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 3.1.</strong> Add parentheses to the following expressions to indicate the order in which Haskell’s precedence and associativity rules (<a href="ch01.xhtml#ch1tab2">Table 1-2</a>) would evaluate the expressions. Some of the expressions are well-formed and have a clear type. In those cases, give the type of the (entire) expression. Also identify expressions that are not correctly formed (and consequently do not have a clear type) and say what is wrong with them.</p>&#13;
<p class="alphats">(a) <code>False || True &amp;&amp; False || True</code></p>&#13;
<p class="alphats">(b) <code>2 / 3 / 4 == 4 / 3 / 2</code></p>&#13;
<p class="alphats">(c) <code>7 - 5 / 4 &gt; 6 || 2 ^ 5 - 1 == 31</code></p>&#13;
<p class="alphats">(d) <code>2 &lt; 3 &lt; 4</code></p>&#13;
<p class="alphats">(e) <code>2 &lt; 3 &amp;&amp; 3 &lt; 4</code></p>&#13;
<p class="alphats">(f) <code>2 &amp;&amp; 3 &lt; 4</code></p>&#13;
<p class="noindentts"><strong>Exercise 3.2.</strong> Write Haskell function definitions for the following mathematical functions. In each case, write a type signature (the type should be <code>Double -&gt; Double</code> for each function) and a function definition.</p>&#13;
<p class="alphats">(a) <img class="inline" src="Images/032equ01.jpg" alt="Image" width="192" height="50"/></p>&#13;
<p class="alphats">(b) <img class="inline" src="Images/032equ02.jpg" alt="Image" width="194" height="53"/></p>&#13;
<p class="noindentts"><strong>Exercise 3.3.</strong> Define a function <code>isXorY</code> with type signature</p>&#13;
<pre>isXorY :: Char -&gt; Bool</pre>&#13;
<p class="noindentts">that will return <code>True</code> if the input character is <code>'X'</code> or <code>'Y'</code> (capital X or Y) and return <code>False</code> otherwise. Test your function by loading it into GHCi and giving it inputs of <code>'X'</code>, <code>'Y'</code>, <code>'Z'</code>, and so on.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_33"/><strong>Exercise 3.4.</strong> Define a function <code>bagFee</code> with type signature</p>&#13;
<pre>bagFee :: Bool -&gt; Int</pre>&#13;
<p class="noindentts">that will return the integer <code>100</code> if the person is checking bags and the integer <code>0</code> if not. Use an <code>if</code>-<code>then</code>-<code>else</code> construction for this function. Then define a second function, <code>bagFee2</code>, with the same type signature that uses pattern matching on the input instead of the <code>if</code>-<code>then</code>-<code>else</code> construction.</p>&#13;
<p class="noindentts"><strong>Exercise 3.5.</strong> Define a function <code>greaterThan50</code> with type signature</p>&#13;
<pre>greaterThan50 :: Integer -&gt; Bool</pre>&#13;
<p class="noindentts">that will return <code>True</code> if the given integer is greater than 50 and return <code>False</code> otherwise.</p>&#13;
<p class="noindentts"><strong>Exercise 3.6.</strong> Define a function <code>amazingCurve</code> with type signature</p>&#13;
<pre>amazingCurve :: Int -&gt; Int</pre>&#13;
<p class="noindentts">that will double a student’s score on an exam. However, if the new score after doubling is greater than 100, the function should output <code>100</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 3.7.</strong> What is the <em>type</em> of the expression <code>bagFee False</code> using the definition of <code>bagFee</code> you wrote in Exercise 3.4? What is the <em>value</em> of the expression <code>bagFee False</code> using that definition of <code>bagFee</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 3.8.</strong> “Give every function a type signature.” In Haskell, it is good practice to give every function you define in your program file a type signature. We have been doing this all along. Type signatures serve as a form of documentation to readers of your program (including yourself).</p>&#13;
<p class="indent">Add type signatures for each of the definitions in the code below:</p>&#13;
<pre>circleRadius = 3.5&#13;
&#13;
cot x = 1 / tan x&#13;
&#13;
fe epsilon = epsilon * tan (epsilon * pi / 2)&#13;
&#13;
fo epsilon = -epsilon * cot (epsilon * pi / 2)&#13;
&#13;
g nu epsilon = sqrt (nu**2 - epsilon**2)</pre>&#13;
<p class="noindentts"><strong>Exercise 3.9.</strong> There are only a finite number of functions with type <code>Bool -&gt;</code> <code>Bool</code>. How many are there? What would be good names for them? How many functions have type <code>Bool -&gt; Bool -&gt; Bool</code>?</p>&#13;
<p class="noindentts"><strong>Exercise 3.10.</strong> Devise an expression using <code>True</code>, <code>False</code>, <code>&amp;&amp;</code>, and <code>||</code> that would come out differently if the precedence of <code>||</code> was higher than the precedence of <code>&amp;&amp;</code>.<span epub:type="pagebreak" id="page_34"/></p>&#13;
</div></body></html>