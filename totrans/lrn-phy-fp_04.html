<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_25"/><span class="big">3</span><br/>TYPES AND ENTITIES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">The idea that every expression has a type is central to Haskell. Haskell has several built-in types available to us in the Prelude and a system for making our own types. In this chapter, we’ll discuss some of the built-in types, and in <a href="ch10.xhtml">Chapter 10</a>, we’ll see how to make types of our own.</p>&#13;
<h3 class="h3" id="ch3lev1">Basic Types</h3>&#13;
<p class="noindent">Types reflect the nature of information. For example, in physics, we want to know whether something is a scalar or a vector. These are different types. It makes no sense to add a scalar to a vector, and the computer can prevent us from making this mistake if we use a good system of types.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3tab1">Table 3-1</a> shows Haskell’s most important basic types.</p>&#13;
<p class="tabcap" id="ch3tab1"><strong>Table 3-1:</strong> Haskell’s Basic Types</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Examples</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Bool</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Boolean</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False, True</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Character</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">'h', '7'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">String</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">String</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">"101 N. College Ave."</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Int</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Small (machine-precision) integer</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">42</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Integer</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Arbitrarily large integer</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">18446744073709551616</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Float</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Single-precision floating point</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">0.33333334</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">Double</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Double-precision floating point</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">0.3333333333333333</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>The <span class="literal">Bool</span> type is for values that are either true or false, like the result of a comparison. For example, <span class="literal">3 &gt; 4</span> evaluates to <span class="literal">False</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">3 &gt; 4</span>&#13;
False</pre>&#13;
<p class="indent">The <span class="literal">Char</span> type is for single characters. The <span class="literal">String</span> type is for a sequence of characters. The types <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span> are for numbers.</p>&#13;
<p class="indent">Let’s take a closer look at each of these types.</p>&#13;
<h4 class="h4" id="ch3lev2">The Boolean Type</h4>&#13;
<p class="noindent">The <span class="literal">Bool</span> type has only two possible values: <span class="literal">False</span> and <span class="literal">True</span>. The type is used for expressions that are meant to represent claims that might be true or false.</p>&#13;
<p class="indent">Haskell has an <span class="literal">if-then-else</span> expression whose value depends on a Boolean. The expression has the form <span class="literal">if</span> <span class="literal">b</span> <span class="literal">then</span> <span class="literal">c</span> <span class="literal">else</span> <span class="literal">a</span>. Here <span class="literal">b</span> is an expression of type <span class="literal">Bool</span> called the <em>condition</em> is called the <em>consequent</em> is called the <em>alternative</em>. Haskell’s type system demands not only that <span class="literal">b</span> have type <span class="literal">Bool</span> but also that the consequent <span class="literal">c</span> and the alternative <span class="literal">a</span> have the same type (this can be any type, <span class="literal">Bool</span> or something else). If the condition <span class="literal">b</span> evaluates to <span class="literal">True</span>, the entire <span class="literal">if-then-else</span> expression evaluates to <span class="literal">c</span>; if the condition <span class="literal">b</span> evaluates to <span class="literal">False</span>, the entire <span class="literal">if-then-else</span> expression evaluates to <span class="literal">a</span>.</p>&#13;
<p class="indent">If you are familiar with an imperative language like Python or C, it may help to realize that Haskell’s <span class="literal">if-then-else</span> construction is an <em>expression</em>, not a statement. An expression evaluates to a value. In imperative languages, <span class="literal">if-then</span> constructions are typically statements that are executed if the condition is true and ignored otherwise. In an imperative language, the <span class="literal">else</span> clause is optional; that is, it’s only used when there are statements to be executed if the condition is false. Because the <span class="literal">if-then-else</span> construction in a functional language is an expression, the <span class="literal">else</span> clause is mandatory, not optional. <em>Some</em> value must be returned whether the condition is true or false.</p>&#13;
<p class="indent">As an example of the <span class="literal">if-then-else</span> expression, consider the following function (which is sometimes called the <em>Heaviside step function</em> or the <em>unit step function</em>):</p>&#13;
<div class="imagec"><img src="Images/026equ01.jpg" alt="Image" width="450" height="50"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>We can write a definition for this function in Haskell using the <span class="literal">if-then-else</span> construction. In Haskell, we are not allowed to begin the names of constants or functions with a capital letter (recall the discussion of variable identifiers in the last chapter), so we’ll call this function <span class="literal">stepFunction</span>.</p>&#13;
<pre>stepFunction :: Double -&gt; Double&#13;
stepFunction x = if x &lt;= 0&#13;
                 then 0&#13;
                 else 1</pre>&#13;
<p class="indent">The function <span class="literal">stepFunction</span> accepts a <span class="literal">Double</span> as input (called <span class="literal">x</span> in the definition) and returns a <span class="literal">Double</span> as output. The expression <span class="literal">x &lt;= 0</span> is the condition, the expression <span class="literal">0</span> is the consequent, and the expression <span class="literal">1</span> is the alternative.</p>&#13;
<p class="indent">The Prelude provides a few functions that work with Booleans. The first is <span class="literal">not</span>, which has type <span class="literal">Bool -&gt; Bool</span>, meaning it accepts a Boolean as input and gives another Boolean as output. The function <span class="literal">not</span> returns <span class="literal">True</span> if its input is <span class="literal">False</span> and returns <span class="literal">False</span> if its input is <span class="literal">True</span>. You can see this for yourself in GHCi if you type</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">not False</span>&#13;
True</pre>&#13;
<p class="noindent">or</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">not True</span>&#13;
False</pre>&#13;
<p class="noindent">at the GHCi prompt.</p>&#13;
<p class="indent">As you saw in <a href="ch02.xhtml">Chapter 2</a>, GHCi has a command <span class="literal">:type</span> (<span class="literal">:t</span> for short) that asks about the type of something. You can ask GHCi for the type of <span class="literal">not</span> by entering</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t not</span>&#13;
not :: Bool -&gt; Bool</pre>&#13;
<p class="noindent">at the GHCi prompt. GHCi commands that start with a colon are not part of the Haskell language itself. You cannot use the colon commands in a Haskell program file.</p>&#13;
<p class="indent">The Boolean AND operator <span class="literal">&amp;&amp;</span> takes two Booleans as input and gives one Boolean as output. The output is <span class="literal">True</span> only when both inputs are <span class="literal">True</span>, and it’s <span class="literal">False</span> otherwise. <a href="ch03.xhtml#ch3tab2">Table 3-2</a> describes the behavior of the <span class="literal">&amp;&amp;</span> operator.</p>&#13;
<p class="tabcap" id="ch3tab2"><strong>Table 3-2:</strong> Definition of the AND Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>y</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em> <span class="literal">&amp;&amp;</span> <em>y</em></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">False</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>The Boolean OR operator <span class="literal">||</span> takes two Booleans as input and gives one Boolean as output. The output is <span class="literal">False</span> only when both inputs are <span class="literal">False</span>, and it’s <span class="literal">True</span> otherwise. <a href="ch03.xhtml#ch3tab3">Table 3-3</a> describes the behavior of the <span class="literal">||</span> operator.</p>&#13;
<p class="tabcap" id="ch3tab3"><strong>Table 3-3:</strong> Definition of the OR Operator</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>y</em></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><em>x</em> <span class="literal">||</span> <em>y</em></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">True</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">True</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">True</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These operators are listed in <a href="ch01.xhtml#ch1tab2">Table 1-2</a> with their precedence and associativity. You can play with them in GHCi, asking for evaluations of expressions such as</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">True</span> || <span class="codestrong1">False &amp;&amp; True</span>&#13;
True</pre>&#13;
<p class="noindent">at the GHCi prompt.</p>&#13;
<h4 class="h4" id="ch3lev3">The Character Type</h4>&#13;
<p class="noindent">The <span class="literal">Char</span> type is for single characters, including uppercase and lowercase letters, digits, and some special characters (like the newline character, which produces a new line of text). Here are some examples of character definitions:</p>&#13;
<pre>ticTacToeMarker :: Char&#13;
ticTacToeMarker = 'X'&#13;
&#13;
newLine :: Char&#13;
newLine = '\n'</pre>&#13;
<p class="indent">There is very little reason to make these definitions because any place we could use <span class="literal">newLine</span>, for example, we could just as easily use <span class="literal">'\n'</span>, which takes up less space. We do it here only to show the relationship between the term <span class="literal">'X'</span> and the type <span class="literal">Char</span>. As shown in the examples above, a character can be formed by enclosing a single letter or digit in single quotes.</p>&#13;
<h4 class="h4" id="ch3lev4">The String Type</h4>&#13;
<p class="noindent">A string is a sequence of characters. (In <a href="ch05.xhtml">Chapter 5</a>, we’ll learn that a string is a <em>list</em> of characters, where list has a precise meaning.) Here are some examples:</p>&#13;
<pre>hello :: String&#13;
hello = "Hello, world!"&#13;
&#13;
errorMessage :: String&#13;
errorMessage = "Can't take the square root of a Boolean!"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_29"/>These definitions are not as useless as the ones shown earlier for characters, because although <span class="literal">"Hello, world!"</span> is entirely equivalent to <span class="literal">hello</span>, the name <span class="literal">hello</span> is at least shorter and easier to type than the string it represents. If such a string was needed at several different places in a program, that would justify the definition of a name such as <span class="literal">hello</span>. To form a string from a sequence of characters, we enclose the character sequence in double quotes.</p>&#13;
<h4 class="h4" id="ch3lev5">Numeric Types</h4>&#13;
<p class="noindent">The basic numeric types are <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span>. The <span class="literal">Int</span> type is for small integers. A 32-bit machine will use 32 bits to represent an <span class="literal">Int</span>, which gives numbers up to a few billion. A 64-bit machine will use 64 bits to represent an <span class="literal">Int</span>, which gives numbers up to about 10<sup>18</sup>. The <span class="literal">Integer</span> type is for arbitrary integers. The computer will use whatever number of bits it needs to represent an <span class="literal">Integer</span> exactly. On my 64-bit machine, I get the following results:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">10^18 :: Int</span>&#13;
1000000000000000000&#13;
Prelude&gt; <span class="codestrong1">10^18 :: Integer</span>&#13;
1000000000000000000&#13;
Prelude&gt; <span class="codestrong1">10^19 :: Int</span>&#13;
-8446744073709551616&#13;
Prelude&gt; <span class="codestrong1">10^19 :: Integer</span>&#13;
10000000000000000000</pre>&#13;
<p class="indent">Notice that I get no error message about going too high with <span class="literal">Int</span>; I just get the wrong answer. The <span class="literal">Int</span> type is good for almost any kind of counting you might ask the computer to do. The computer can’t count up to 10<sup>18</sup> because it takes too long.</p>&#13;
<p class="indent">The <span class="literal">Float</span> type is for approximations to real numbers and has a precision of about 7 decimal digits. The <span class="literal">Double</span> type is for approximations to real numbers and has a precision of about 15 decimal digits. I always choose <span class="literal">Double</span> for my real numbers unless I am using a library written by someone else that uses <span class="literal">Float</span>.</p>&#13;
<p class="indent">The numeric examples in the rightmost column of <a href="ch03.xhtml#ch3tab1">Table 3-1</a> <em>can be</em> expressions of the type indicated, but an expression by itself, such as <span class="literal">42</span>, does not <em>necessarily</em> have type <span class="literal">Int</span>. To be specific, <span class="literal">False</span> and <span class="literal">True</span> must have type <span class="literal">Bool</span>, <span class="literal">'h'</span> and <span class="literal">'7'</span> must have type <span class="literal">Char</span>, and <span class="literal">"101 N. College Ave."</span> must have type <span class="literal">String</span>. On the other hand, <span class="literal">42</span> could have type <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, or <span class="literal">Double</span>. Clarifying this ambiguity is one reason to give a type signature with each name you define in a Haskell program. Without a type signature, the compiler cannot tell which of the four numeric types you might want for a <span epub:type="pagebreak" id="page_30"/>number like <span class="literal">18446744073709551616</span>. Any of the four numeric types would try to hold the number, but only <span class="literal">Integer</span> would represent the number exactly. The complexity of numeric types in Haskell is related to a more advanced language feature called <em>type classes</em>, which we’ll discuss in <a href="ch08.xhtml">Chapter 8</a>.</p>&#13;
<p class="indent">The four numeric types in <a href="ch03.xhtml#ch3tab1">Table 3-1</a> are not the only numeric types in the Prelude. The Prelude includes a <span class="literal">Rational</span> type for rational numbers that we won’t use in this book but that you can explore on your own if you are interested. Complex numbers are provided by a library module called <span class="literal">Data.Complex</span>. We won’t use complex numbers in this book.</p>&#13;
<h3 class="h3" id="ch3lev6">Function Types</h3>&#13;
<p class="noindent">Haskell provides several ways to form new types from existing types. Given any two types <span class="literal">a</span> and <span class="literal">b</span>, there is a type <span class="literal">a -&gt; b</span> for functions that take an expression of type <span class="literal">a</span> as input and produce an expression of type <span class="literal">b</span> as output. Here is an example:</p>&#13;
<pre>isX :: Char -&gt; Bool&#13;
isX c = c == 'X'</pre>&#13;
<p class="indent">The function <span class="literal">isX</span> takes a character as input and gives a Boolean as output. The function returns <span class="literal">True</span> if the input character is <span class="literal">'X'</span> and returns <span class="literal">False</span> otherwise. Adding parentheses may help in reading the function definition. The definition is equivalent to</p>&#13;
<pre>isX c = (c == 'X')</pre>&#13;
<p class="indent">In general in a definition, the name on the left of the single equal sign (<span class="literal">=</span>) is being defined (<span class="literal">isX</span> in this case), and the expression on the right of the single equal sign is the body of the definition. The expression <span class="literal">c == 'X'</span> uses the equality operator <span class="literal">==</span> from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> to ask if the input character <span class="literal">c</span> is the same as <span class="literal">'X'</span>.</p>&#13;
<p class="indent">If we put this function definition into a Haskell program file (for example, <em>FunctionType.hs</em>) and load it into GHCi,</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l FunctionType.hs</span>&#13;
[1 of 1] Compiling Main            ( FunctionType.hs, interpreted )&#13;
Ok, one module loaded.</pre>&#13;
<p class="noindent">we can ask about the types of things. If we ask about the type of <span class="literal">isX</span>,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t isX</span>&#13;
isX :: Char -&gt; Bool</pre>&#13;
<p class="noindent">we see what we wrote in our type signature. In GHCi, we can also ask for the type of <span class="literal">isX 't'</span>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t isX 't'</span>&#13;
isX 't' :: Bool</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>This makes sense because the expression <span class="literal">isX 't'</span> represents the function isX applied to the character argument <span class="literal">'t'</span>. Therefore, the type represents the type of the output of <span class="literal">isX</span>, namely <span class="literal">Bool</span>.</p>&#13;
<p class="indent">We can also ask GHCi for the <em>value</em> of <span class="literal">isX 't'</span> (as opposed to the type of the expression). If we enter <span class="literal">isX 't'</span> at the GHCi prompt,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">isX 't'</span>&#13;
False</pre>&#13;
<p class="noindent">we see that the value of <span class="literal">isX 't'</span> is <span class="literal">False</span> because <span class="literal">'t'</span> is not equal to <span class="literal">'X'</span>.</p>&#13;
<p class="indent">Here is an example of a function with type <span class="literal">Bool -&gt; String</span>:</p>&#13;
<pre>bagFeeMessage :: Bool -&gt; String&#13;
bagFeeMessage checkingBags = if checkingBags&#13;
                             then "There is a $100 fee."&#13;
                             else "There is no fee."</pre>&#13;
<p class="indent">The function <span class="literal">bagFeeMessage</span> takes a Boolean as input and gives a string as output. The input Boolean (called <span class="literal">checkingBags</span>) is intended to represent an answer (<span class="literal">True</span> or <span class="literal">False</span>) to the question of whether a passenger is checking bags. The style of naming a variable by sticking words together without spaces and using a capital letter at the beginning of the second and subsequent words is common in Haskell programming.</p>&#13;
<p class="indent">There is an alternative way to write the function <span class="literal">bagFeeMessage</span> that uses a facility in Haskell called <em>pattern matching</em>. Some data types have one or more patterns that values of that type fall into. The idea behind pattern matching for <span class="literal">Bool</span> is that the only possible values are <span class="literal">False</span> and <span class="literal">True</span>, so why not just give the output for each possible input? The fundamental way of achieving pattern matching is with the <span class="literal">case</span>-<span class="literal">of</span> construction. Here is what the function looks like using pattern matching:</p>&#13;
<pre>bagFeeMessage2 :: Bool -&gt; String&#13;
bagFeeMessage2 checkingBags = case checkingBags of&#13;
                                False -&gt; "There is no fee."&#13;
                                True  -&gt; "There is a $100 fee."</pre>&#13;
<p class="indent">This doesn’t look so different from the <span class="literal">if</span>-<span class="literal">then</span>-<span class="literal">else</span> construction, but the <span class="literal">case</span>-<span class="literal">of</span> construction is more general because it can be used with other data types, not just <span class="literal">Bool</span>. In <a href="ch05.xhtml">Chapter 5</a>, for example, we will see that every list falls into one of two patterns that can be distinguished using the <span class="literal">case</span>-<span class="literal">of</span> construction.</p>&#13;
<p class="indent">Although the <span class="literal">case</span>-<span class="literal">of</span> construction is the basic way to do pattern matching, Haskell provides some syntactic sugar for the special case in which we want to pattern match on the input to a function.</p>&#13;
<pre>bagFeeMessage3 :: Bool -&gt; String&#13;
bagFeeMessage3 False = "There is no fee."&#13;
bagFeeMessage3 True  = "There is a $100 fee."</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>By using pattern matching on the input, we have avoided using the <span class="literal">if</span>-<span class="literal">then</span>-<span class="literal">else</span> construction. Also, we no longer need the variable <span class="literal">checkingBags</span>, which held the input value.</p>&#13;
<h3 class="h3" id="ch3lev7">Summary</h3>&#13;
<p class="noindent">Haskell has built-in types and facilities for making our own types. Types are intended to describe the meaning of data. This chapter looks at seven of the most common built-in types: <span class="literal">Bool</span>, <span class="literal">Char</span>, <span class="literal">String</span>, <span class="literal">Int</span>, <span class="literal">Integer</span>, <span class="literal">Float</span>, and <span class="literal">Double</span>. It also considers function types, which are very important to the language because functions play such a central role. We got a first glimpse of pattern matching, both with the <span class="literal">case</span>-<span class="literal">of</span> construction and by pattern matching on the input. In the next chapter, we begin our physics work, starting with motion in one dimension.</p>&#13;
<h3 class="h3" id="ch3lev8">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 3.1.</strong> Add parentheses to the following expressions to indicate the order in which Haskell’s precedence and associativity rules (<a href="ch01.xhtml#ch1tab2">Table 1-2</a>) would evaluate the expressions. Some of the expressions are well-formed and have a clear type. In those cases, give the type of the (entire) expression. Also identify expressions that are not correctly formed (and consequently do not have a clear type) and say what is wrong with them.</p>&#13;
<p class="alphats">(a) <span class="literal">False || True &amp;&amp; False || True</span></p>&#13;
<p class="alphats">(b) <span class="literal">2 / 3 / 4 == 4 / 3 / 2</span></p>&#13;
<p class="alphats">(c) <span class="literal">7 - 5 / 4 &gt; 6 || 2 ^ 5 - 1 == 31</span></p>&#13;
<p class="alphats">(d) <span class="literal">2 &lt; 3 &lt; 4</span></p>&#13;
<p class="alphats">(e) <span class="literal">2 &lt; 3 &amp;&amp; 3 &lt; 4</span></p>&#13;
<p class="alphats">(f) <span class="literal">2 &amp;&amp; 3 &lt; 4</span></p>&#13;
<p class="noindentts"><strong>Exercise 3.2.</strong> Write Haskell function definitions for the following mathematical functions. In each case, write a type signature (the type should be <span class="literal">Double -&gt; Double</span> for each function) and a function definition.</p>&#13;
<p class="alphats">(a) <img class="inline" src="Images/032equ01.jpg" alt="Image" width="192" height="50"/></p>&#13;
<p class="alphats">(b) <img class="inline" src="Images/032equ02.jpg" alt="Image" width="194" height="53"/></p>&#13;
<p class="noindentts"><strong>Exercise 3.3.</strong> Define a function <span class="literal">isXorY</span> with type signature</p>&#13;
<pre>isXorY :: Char -&gt; Bool</pre>&#13;
<p class="noindentts">that will return <span class="literal">True</span> if the input character is <span class="literal">'X'</span> or <span class="literal">'Y'</span> (capital X or Y) and return <span class="literal">False</span> otherwise. Test your function by loading it into GHCi and giving it inputs of <span class="literal">'X'</span>, <span class="literal">'Y'</span>, <span class="literal">'Z'</span>, and so on.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_33"/><strong>Exercise 3.4.</strong> Define a function <span class="literal">bagFee</span> with type signature</p>&#13;
<pre>bagFee :: Bool -&gt; Int</pre>&#13;
<p class="noindentts">that will return the integer <span class="literal">100</span> if the person is checking bags and the integer <span class="literal">0</span> if not. Use an <span class="literal">if</span>-<span class="literal">then</span>-<span class="literal">else</span> construction for this function. Then define a second function, <span class="literal">bagFee2</span>, with the same type signature that uses pattern matching on the input instead of the <span class="literal">if</span>-<span class="literal">then</span>-<span class="literal">else</span> construction.</p>&#13;
<p class="noindentts"><strong>Exercise 3.5.</strong> Define a function <span class="literal">greaterThan50</span> with type signature</p>&#13;
<pre>greaterThan50 :: Integer -&gt; Bool</pre>&#13;
<p class="noindentts">that will return <span class="literal">True</span> if the given integer is greater than 50 and return <span class="literal">False</span> otherwise.</p>&#13;
<p class="noindentts"><strong>Exercise 3.6.</strong> Define a function <span class="literal">amazingCurve</span> with type signature</p>&#13;
<pre>amazingCurve :: Int -&gt; Int</pre>&#13;
<p class="noindentts">that will double a student’s score on an exam. However, if the new score after doubling is greater than 100, the function should output <span class="literal">100</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 3.7.</strong> What is the <em>type</em> of the expression <span class="literal">bagFee False</span> using the definition of <span class="literal">bagFee</span> you wrote in Exercise 3.4? What is the <em>value</em> of the expression <span class="literal">bagFee False</span> using that definition of <span class="literal">bagFee</span>?</p>&#13;
<p class="noindentts"><strong>Exercise 3.8.</strong> “Give every function a type signature.” In Haskell, it is good practice to give every function you define in your program file a type signature. We have been doing this all along. Type signatures serve as a form of documentation to readers of your program (including yourself).</p>&#13;
<p class="indent">Add type signatures for each of the definitions in the code below:</p>&#13;
<pre>circleRadius = 3.5&#13;
&#13;
cot x = 1 / tan x&#13;
&#13;
fe epsilon = epsilon * tan (epsilon * pi / 2)&#13;
&#13;
fo epsilon = -epsilon * cot (epsilon * pi / 2)&#13;
&#13;
g nu epsilon = sqrt (nu**2 - epsilon**2)</pre>&#13;
<p class="noindentts"><strong>Exercise 3.9.</strong> There are only a finite number of functions with type <span class="literal">Bool -&gt;</span> <span class="literal">Bool</span>. How many are there? What would be good names for them? How many functions have type <span class="literal">Bool -&gt; Bool -&gt; Bool</span>?</p>&#13;
<p class="noindentts"><strong>Exercise 3.10.</strong> Devise an expression using <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">&amp;&amp;</span>, and <span class="literal">||</span> that would come out differently if the precedence of <span class="literal">||</span> was higher than the precedence of <span class="literal">&amp;&amp;</span>.<span epub:type="pagebreak" id="page_34"/></p>&#13;
</div></body></html>