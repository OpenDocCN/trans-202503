<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_329"/><span class="big"><strong>15</strong></span><br/><strong>DAYS AND DATES</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">It’s tricky to calculate date math, whether you’re trying to figure out if a given year was a leap year, how many days remain until Christmas, or how many days you’ve been alive. This is where there’s a chasm between the Unix-based systems, like OS X, and Linux systems with their GNU foundations. David MacKenzie’s rewrite of the <span class="literal">date</span> utility for the GNU version of Linux is dramatically superior in its capabilities.</p>&#13;
<p class="indent">If you are using OS X or another system where <span class="literal">date --version</span> generates an error message, you can download a set of core utilities that will give you GNU <span class="literal">date</span> as a new command line option (probably installing it as <span class="literal">gdate</span>). For OS X, you can use the <span class="literal">brew</span> package manager (not installed by default, but easy to install for future use):</p>&#13;
<pre class="programs">$ <span class="codestrong">brew install coreutils</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_330"/>Once you have GNU <span class="literal">date</span> installed, calculating, say, whether a given year is a leap year can be handled by the program itself, rather than you having to mess with rules about years divisible by 4 but not 100 and so on.</p>&#13;
<pre class="programs">if [ $( date 12/31/$year +%j ) -eq 366 ]</pre>&#13;
<p class="indent">In other words, if the last day of the year is the 366th day of the year, it must be a leap year.</p>&#13;
<p class="indent">Another quality that makes GNU <span class="literal">date</span> superior is its ability to go far back in time. The standard Unix date command was built with a “time zero” or epoch date of January 1, 1970, at precisely 00:00:00 UTC. Want to know about something that happened in 1965? Tough luck. Fortunately, with the three nifty scripts in this chapter, you can harness the advantages of GNU <span class="literal">date</span>.</p>&#13;
<h3 class="h3" id="ch15lev1sec01"><strong>#99 Finding the Day of a Specific Date in the Past</strong></h3>&#13;
<p class="noindenta">Quick: On what day of the week were you born? On what day of the week did Neil Armstrong and Buzz Aldrin first walk on the moon? The script in <a href="ch15.xhtml#ch15ex1">Listing 15-1</a> helps you quickly answer these classic questions and neatly demonstrates how powerful GNU <span class="literal">date</span> is.</p>&#13;
<h4 class="h4" id="ch15lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # dayinpast--Given a date, reports what day of the week it was&#13;
&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $(basename $0) mon day year" &gt;&amp;2&#13;
     echo "  with just numerical values (ex: 7 7 1776)" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   date --version &gt; /dev/null 2&gt;&amp;1    # Discard error, if any.&#13;
   baddate="$?"                       # Just look at return code.&#13;
&#13;
   if [ ! $baddate ] ; then&#13;
<span class="ent">➊</span>   date -d $1/$2/$3 +"That was a %A."&#13;
   else&#13;
&#13;
     if [ $2 -lt 10 ] ; then&#13;
       pattern=" $2[^0-9]"&#13;
     else&#13;
       pattern="$2[^0-9]"&#13;
     fi&#13;
&#13;
     dayofweek="$(<span class="ent">➋</span>ncal $1 $3 | grep "$pattern" | cut -c1-2)"&#13;
&#13;
     case $dayofweek in&#13;
       Su ) echo "That was a Sunday.";        ;;&#13;
       Mo ) echo "That was a Monday.";        ;;&#13;
       Tu ) echo "That was a Tuesday.";       ;;&#13;
       We ) echo "That was a Wednesday.";     ;;&#13;
       Th ) echo "That was a Thursday.";      ;;&#13;
       Fr ) echo "That was a Friday.";        ;;&#13;
       Sa ) echo "That was a Saturday.";      ;;&#13;
     esac&#13;
   fi&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_331"/><a id="ch15ex1"/><em>Listing 15-1: The</em> <span class="literal"><em>dayinpast</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch15lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">You know how we’ve been extolling GNU <span class="literal">date</span>? Here’s why. This entire script boils down to a single invocation at <span class="ent">➊</span>.</p>&#13;
<p class="indent">Crazy easy.</p>&#13;
<p class="indent">If that version of <span class="literal">date</span> isn’t available, the script uses <span class="literal">ncal</span> <span class="ent">➋</span>, a variation of the simple <span class="literal">cal</span> program that presents the specified month in a curious—but helpful!—format:</p>&#13;
<pre class="programs">$ <span class="codestrong">ncal 8 1990</span>&#13;
    August 1990&#13;
Mo     6 13 20 27&#13;
Tu     7 14 21 28&#13;
We  1  8 15 22 29&#13;
Th  2  9 16 23 30&#13;
Fr  3 10 17 24 31&#13;
Sa  4 11 18 25&#13;
Su  5 12 19 26</pre>&#13;
<p class="indent">With this information available, pinpointing the day of the week is a simple matter of finding the line with the matching day of the month and then translating the two-letter day abbreviation into a proper name.</p>&#13;
<h4 class="h4" id="ch15lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Neil Armstrong and Buzz Aldrin landed at Tranquility Base on July 20, 1969, and <a href="ch15.xhtml#ch15ex2">Listing 15-2</a> shows this was a Sunday.</p>&#13;
<pre class="programs">$ <span class="codestrong">dayinpast 7 20 1969</span>&#13;
That was a Sunday.</pre>&#13;
<p class="listcap"><a id="ch15ex2"/><em>Listing 15-2: Running the</em> <span class="literal"><em>dayinpast</em></span> <em>script with the date Armstrong and Aldrin landed on the moon</em></p>&#13;
<p class="indent">D-Day, the Allied mass landing at Normandy, was June 6, 1944:</p>&#13;
<pre class="programs">$ <span class="codestrong">dayinpast 6 6 1944</span>&#13;
That was a Tuesday.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_332"/>And here’s one more, the date of the US Declaration of Independence on July 4, 1776:</p>&#13;
<pre class="programs">$ <span class="codestrong">dayinpast 7 4 1776</span>&#13;
That was a Thursday.</pre>&#13;
<h4 class="h4" id="ch15lev2sec04"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">All the scripts in this chapter use the same <span class="literal"><em>month day year</em></span> input format, but it would be nice to let users specify something more familiar, like <span class="literal"><em>month</em>/<em>day</em>/ <em>year</em></span>. Luckily, it’s not hard to do, and <a href="ch01.xhtml#ch01lev1sec04">Script #3</a> on <a href="ch01.xhtml#page_17">page 17</a> is an excellent place to start.</p>&#13;
<h3 class="h3" id="ch15lev1sec02"><strong>#100 Calculating Days Between Dates</strong></h3>&#13;
<p class="noindenta">How many days have you been alive? How many days have passed since your parents met? There are a lot of questions of this nature related to elapsed time, and the answers are generally difficult to calculate. Again, however, GNU <span class="literal">date</span> makes life easier.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15lev1sec02">Script #100</a> and <a href="ch15.xhtml#ch15lev1sec03">Script #101</a> are both based on the concept of calculating the number of days between two dates by figuring out the difference in days for the start year and the end year as well as the number of days in each intervening year. You can use this approach to calculate how many days ago a date in the past was (this script) and how many days remain until some future date (<a href="ch15.xhtml#ch15lev1sec03">Script #101</a>).</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex3">Listing 15-3</a> is pretty complicated. Ready?</p>&#13;
<h4 class="h4" id="ch15lev2sec05"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # daysago--Given a date in the form month/day/year, calculates how many&#13;
   #   days in the past that was, factoring in leap years, etc.&#13;
&#13;
   # If you are on Linux, this should only be 'which date'.&#13;
   #   If you are on OS X, install coreutils with brew or from source for gdate.&#13;
   date="$(which gdate)"&#13;
&#13;
   function  daysInMonth&#13;
   {&#13;
     case $1 in&#13;
       1|3|5|7|8|10|12 ) dim=31 ;;  # Most common value&#13;
       4|6|9|11        ) dim=30 ;;&#13;
       2               ) dim=29 ;;  # Depending on whether it's a leap year&#13;
       *               ) dim=-1 ;;  # Unknown month&#13;
     esac&#13;
   }&#13;
&#13;
<span epub:type="pagebreak" id="page_333"/><span class="ent">➊</span> function isleap&#13;
   {&#13;
     # Returns nonzero value for $leapyear if $1 was a leap year&#13;
       leapyear=$($date -d 12/31/$1 +%j | grep 366)&#13;
   }&#13;
&#13;
   #######################&#13;
   #### MAIN BLOCK&#13;
   #######################&#13;
&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $(basename $0) mon day year"&#13;
     echo "  with just numerical values (ex: 7 7 1776)"&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➋</span> $date --version &gt; /dev/null 2&gt;&amp;1         # Discard error, if any.&#13;
&#13;
   if [ $? -ne 0 ] ; then&#13;
     echo "Sorry, but $(basename $0) can't run without GNU date." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   eval $($date "+thismon=%m;thisday=%d;thisyear=%Y;dayofyear=%j")&#13;
&#13;
   startmon=$1; startday=$2; startyear=$3&#13;
&#13;
   daysInMonth $startmon # Sets global var dim.&#13;
&#13;
   if [ $startday -lt 0 -o $startday -gt $dim ] ; then&#13;
     echo "Invalid: Month #$startmon only has $dim days." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ $startmon -eq 2 -a $startday -eq 29 ] ; then&#13;
     isleap $startyear&#13;
     if [ -z "$leapyear" ] ; then&#13;
       echo "Invalid: $startyear wasn't a leap year; February had 28 days." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   #######################&#13;
   #### CALCULATING DAYS&#13;
   #######################&#13;
&#13;
   #### DAYS LEFT IN START YEAR&#13;
&#13;
   # Calculate the date string format for the specified starting date.&#13;
&#13;
   startdatefmt="$startmon/$startday/$startyear"&#13;
&#13;
<span class="ent">➌</span> calculate="$((10#$($date -d "12/31/$startyear" +%j))) \&#13;
     -$((10#$($date -d $startdatefmt +%j)))"&#13;
&#13;
   daysleftinyear=$(( $calculate ))&#13;
&#13;
   #### DAYS IN INTERVENING YEARS&#13;
&#13;
   daysbetweenyears=0&#13;
   tempyear=$(( $startyear + 1 ))&#13;
&#13;
   while [ $tempyear -lt $thisyear ] ; do&#13;
     daysbetweenyears=$(($daysbetweenyears + \&#13;
     $((10#$($date -d "12/31/$tempyear" +%j)))))&#13;
     tempyear=$(( $tempyear + 1 ))&#13;
   done&#13;
&#13;
   #### DAYS IN CURRENT YEAR&#13;
&#13;
<span class="ent">➍</span> dayofyear=$($date +%j) # That's easy!&#13;
&#13;
   #### NOW ADD IT ALL UP&#13;
&#13;
   totaldays=$(( $((10#$daysleftinyear)) + \&#13;
     $((10#$daysbetweenyears)) + \&#13;
     $((10#$dayofyear)) ))&#13;
&#13;
   /bin/echo -n "$totaldays days have elapsed between "&#13;
   /bin/echo -n "$startmon/$startday/$startyear "&#13;
   echo "and today, day $dayofyear of $thisyear."&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_334"/><a id="ch15ex3"/><em>Listing 15-3: The</em> <span class="literal"><em>daysago</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch15lev2sec06"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This is a long script, but what’s going on isn’t too complicated. The leap year function <span class="ent">➊</span> is straightforward enough—we just check if the year has 366 days or not.</p>&#13;
<p class="indent">There’s an interesting test to ensure that the GNU version of <span class="literal">date</span> is available <span class="ent">➋</span> before the script proceeds.</p>&#13;
<p class="indent">The redirection throws away any error messages or output, and the return code is checked to see whether it’s nonzero, which would indicate an error parsing the <span class="literal">--version</span> parameter. On OS X, for instance, <span class="literal">date</span> is minimal and does not have <span class="literal">--version</span> or many other niceties.</p>&#13;
<p class="indent">Now it’s just basic date math. <span class="literal">%j</span> returns the day of the year, so it makes calculating days left in the current year straightforward <span class="ent">➌</span>. The count of days in intervening years is done in the <span class="literal">while</span> loop, where the progression is tracked with the <span class="literal">tempyear</span> variable.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_335"/>Finally, how many days into the current year are we? That’s easily done at <span class="ent">➍</span>.</p>&#13;
<pre class="programs">dayofyear=$($date +%j)</pre>&#13;
<p class="indent">Then it’s just a matter of summing up the days to get the result!</p>&#13;
<h4 class="h4" id="ch15lev2sec07"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Let’s look at those historical dates again in <a href="ch15.xhtml#ch15ex4">Listing 15-4</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">daysago 7 20 1969</span>&#13;
17106 days have elapsed between 7/20/1969 and today, day 141 of 2016.&#13;
&#13;
$ <span class="codestrong">daysago 6 6 1944</span>&#13;
26281 days have elapsed between 6/6/1944 and today, day 141 of 2016.&#13;
&#13;
$ <span class="codestrong">daysago 1 1 2010</span>&#13;
2331 days have elapsed between 1/1/2010 and today, day 141 of 2016.</pre>&#13;
<p class="listcap"><a id="ch15ex4"/><em>Listing 15-4: Running the</em> <span class="literal"><em>daysago</em></span> <em>script with various dates</em></p>&#13;
<p class="indent">These were all run on ... Well, let’s let <span class="literal">date</span> tell us:</p>&#13;
<pre class="programs">$ <span class="codestrong">date</span>&#13;
Fri May 20 13:30:49 UTC 2016</pre>&#13;
<h4 class="h4" id="ch15lev2sec08"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There are additional error conditions that the script isn’t catching, notably the edge cases when the date in the past is just a few days ago or even a few days in the future. What happens, and how can you fix it? (Tip: look at <a href="ch15.xhtml#ch15lev1sec03">Script #101</a> to see additional tests you can apply to this script.)</p>&#13;
<h3 class="h3" id="ch15lev1sec03"><strong>#101 Calculating Days Until a Specified Date</strong></h3>&#13;
<p class="noindenta">The logical partner of <a href="ch15.xhtml#ch15lev1sec02">Script #100</a>, <span class="literal">daysago</span>, is another script, <span class="literal">daysuntil</span>. This script essentially performs the same calculation but modifies the logic to count days left in the current year, days in intervening years, and days before the specified date in the target year, as shown in <a href="ch15.xhtml#ch15ex5">Listing 15-5</a>.</p>&#13;
<h4 class="h4" id="ch15lev2sec09"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # daysuntil--Basically, this is the daysago script backward, where the&#13;
   #   desired date is set as the current date and the current date is used&#13;
   #   as the basis of the daysago calculation.&#13;
<span epub:type="pagebreak" id="page_336"/>   # As in the previous script, use 'which gdate' if you are on OS X.&#13;
   #   If you are on Linux, use 'which date'.&#13;
   date="$(which gdate)"&#13;
&#13;
   function daysInMonth&#13;
   {&#13;
     case $1 in&#13;
       1|3|5|7|8|10|12 ) dim=31 ;;  # Most common value&#13;
       4|6|9|11        ) dim=30 ;;&#13;
       2               ) dim=29 ;;  # Depending on whether it's a leap year&#13;
       *               ) dim=-1 ;;  # Unknown month&#13;
     esac&#13;
   }&#13;
&#13;
   function isleap&#13;
   {&#13;
     # If specified year is a leap year, returns nonzero value for $leapyear&#13;
&#13;
     leapyear=$($date -d 12/31/$1 +%j | grep 366)&#13;
   }&#13;
&#13;
   #######################&#13;
   #### MAIN BLOCK&#13;
   #######################&#13;
&#13;
   if [ $# -ne 3 ] ; then&#13;
     echo "Usage: $(basename $0) mon day year"&#13;
     echo "  with just numerical values (ex: 1 1 2020)"&#13;
     exit 1&#13;
   fi&#13;
&#13;
   $date --version &gt; /dev/null 2&gt;&amp;1         # Discard error, if any.&#13;
&#13;
   if [ $? -ne 0 ] ; then&#13;
     echo "Sorry, but $(basename $0) can't run without GNU date." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   eval $($date "+thismon=%m;thisday=%d;thisyear=%Y;dayofyear=%j")&#13;
&#13;
   endmon=$1; endday=$2; endyear=$3&#13;
&#13;
   # Lots of parameter checks needed...&#13;
&#13;
   daysInMonth $endmon    # Sets $dim variable&#13;
   if [ $endday -lt 0 -o $endday -gt $dim ] ; then&#13;
     echo "Invalid: Month #$endmon only has $dim days." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ $endmon -eq 2 -a $endday -eq 29 ] ; then&#13;
     isleap $endyear&#13;
<span epub:type="pagebreak" id="page_337"/>     if [ -z "$leapyear" ] ; then&#13;
       echo "Invalid: $endyear wasn't a leapyear; February had 28 days." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   if [ $endyear -lt $thisyear ] ; then&#13;
     echo "Invalid: $endmon/$endday/$endyear is prior to the current year." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ $endyear -eq $thisyear -a $endmon -lt $thismon ] ; then&#13;
     echo "Invalid: $endmon/$endday/$endyear is prior to the current month." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ $endyear -eq $thisyear -a $endmon -eq $thismon -a $endday -lt $thisday ]&#13;
   then&#13;
     echo "Invalid: $endmon/$endday/$endyear is prior to the current date." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➊</span> if [ $endyear -eq $thisyear -a $endmon -eq $thismon -a $endday -eq $thisday ]&#13;
   then&#13;
     echo "There are zero days between $endmon/$endday/$endyear and today." &gt;&amp;2&#13;
     exit 0&#13;
   fi&#13;
&#13;
   #### If we're working with the same year, the calculation is a bit different.&#13;
&#13;
   if [ $endyear -eq $thisyear ] ; then&#13;
&#13;
     totaldays=$(( $($date -d "$endmon/$endday/$endyear" +%j) - $($date +%j) ))&#13;
&#13;
   else&#13;
&#13;
     #### Calculate this in chunks, starting with days left in this year.&#13;
&#13;
     #### DAYS LEFT IN START YEAR&#13;
&#13;
     # Calculate the date string format for the specified starting date.&#13;
&#13;
     thisdatefmt="$thismon/$thisday/$thisyear"&#13;
&#13;
     calculate="$($date -d "12/31/$thisyear" +%j) - $($date -d $thisdatefmt +%j)"&#13;
&#13;
     daysleftinyear=$(( $calculate ))&#13;
&#13;
     #### DAYS IN INTERVENING YEARS&#13;
&#13;
     daysbetweenyears=0&#13;
     tempyear=$(( $thisyear + 1 ))&#13;
     while [ $tempyear -lt $endyear ] ; do&#13;
       daysbetweenyears=$(( $daysbetweenyears + \&#13;
         $($date -d "12/31/$tempyear" +%j) ))&#13;
       tempyear=$(( $tempyear + 1 ))&#13;
     done&#13;
&#13;
     #### DAYS IN END YEAR&#13;
&#13;
     dayofyear=$($date --date $endmon/$endday/$endyear +%j)    # That's easy!&#13;
&#13;
     #### NOW ADD IT ALL UP&#13;
&#13;
     totaldays=$(( $daysleftinyear + $daysbetweenyears + $dayofyear ))&#13;
   fi&#13;
&#13;
   echo "There are $totaldays days until the date $endmon/$endday/$endyear."&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_338"/><a id="ch15ex5"/><em>Listing 15-5: The</em> <span class="literal"><em>daysuntil</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch15lev2sec10"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">As we’ve said, there’s a lot of overlap between the <span class="literal">daysago</span> script and this script, enough that you could probably combine them into one script and have conditionals test whether the user is requesting a date in the past or a date in the future. Most of the math here is simply the inverse of the math in the <span class="literal">daysago</span> script, looking ahead into the future instead of back into the past.</p>&#13;
<p class="indent">This script is a bit cleaner, however, because it considers a lot more error conditions before invoking the actual calculations. Take, for example, our favorite test at <span class="ent">➊</span>.</p>&#13;
<p class="indent">If someone tries to trick the script by specifying today’s date, this conditional will catch that and return “zero days” as its calculation.</p>&#13;
<h4 class="h4" id="ch15lev2sec11"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">How many days until January 1, 2020? <a href="ch15.xhtml#ch15ex6">Listing 15-6</a> gives us the answer.</p>&#13;
<pre class="programs">$ <span class="codestrong">daysuntil 1 1 2020</span>&#13;
There are 1321 days until the date 1/1/2020.</pre>&#13;
<p class="listcap"><a id="ch15ex6"/><em>Listing 15-6: Running the</em> <span class="literal"><em>daysuntil</em></span> <em>script with the first day of 2020</em></p>&#13;
<p class="indent">How many until Christmas 2025?</p>&#13;
<pre class="programs">$ <span class="codestrong">daysuntil 12 25 2025</span>&#13;
There are 3506 days until the date 12/25/2025.</pre>&#13;
<p class="indent">Preparing for the tricentennial in the United States? Here’s how many days you have left:</p>&#13;
<pre class="programs">$ <span class="codestrong">daysuntil 7 4 2076</span>&#13;
There are 21960 days until the date 7/4/2076.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_339"/>Finally, given the following, odds are good we won’t be here for the third millennium:</p>&#13;
<pre class="programs">$ <span class="codestrong">daysuntil 1 1 3000</span>&#13;
There are 359259 days until the date 1/1/3000.</pre>&#13;
<h4 class="h4" id="ch15lev2sec12"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">In <a href="ch15.xhtml#ch15lev1sec01">Script #99</a> on <a href="ch15.xhtml#page_330">page 330</a>, we were able to determine what day of the week a given date fell on. Combining this functionality with that of the <span class="literal">daysago</span> and <span class="literal">daysuntil</span> scripts to get all the relevant information at once would be very useful.<span epub:type="pagebreak" id="page_340"/></p>&#13;
</body></html>