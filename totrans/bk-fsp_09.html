<html><head></head><body><section class="chapter" title="Chapter&#xA0;9.&#xA0;Can I Quote You on that?" epub:type="chapter" id="can_i_quote_you_on_thatquestion_mark"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Can I Quote You on that?</h2></div></div></div><p><a id="iddle1376" class="indexterm"/><a id="iddle1570" class="indexterm"/><a id="iddle1641" class="indexterm"/><a id="iddle1813" class="indexterm"/>Another feature introduced to the .NET Framework with LINQ is expression trees. Often using the same syntax as lambda expressions, <span class="emphasis"><em>expression trees</em></span> compile not to executable code but instead into a tree structure that describes the code and can be parsed for translation to other forms. This type of programming is often called <span class="emphasis"><em>metaprogramming</em></span>. Just as we can think of metadata as data that describes data, we can think of metaprogramming as code that describes code.</p><p>This chapter isn’t about expression trees, though; it’s about a similar construct in F# called a <span class="emphasis"><em>quoted expression</em></span>, also known as a <span class="emphasis"><em>code quotation</em></span>. Quoted expressions address the same basic problem as expression trees, but they take a fundamentally different approach. Let’s quickly compare expression trees to quoted expressions before diving into how to compose and parse quoted expressions within your F# code.</p><div class="sect1" title="Comparing Expression Trees and Quoted Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="comparing_expression_trees_and_quoted_ex">Comparing Expression Trees and Quoted Expressions</h2></div></div></div><p><a id="iddle1377" class="indexterm"/>Expression trees are commonly used with LINQ providers to translate certain C# or Visual Basic expressions into SQL, but they aren’t only useful for translating code between languages. Sometimes expression trees are employed to add an extra degree of safety or readability to code that would otherwise be confusing or error-prone. Consider the <code class="literal">INotifyPropertyChanged</code> interface commonly used in WPF and Silverlight.</p><p><code class="literal">INotifyPropertyChanged</code> defines a single member: an event with a string parameter, <code class="literal">PropertyName</code>, that identifies the property that changed and triggered the event. You raise the <code class="literal">PropertyChanged</code> event by creating a <code class="literal">PropertyChangedEventArgs</code> instance and passing the property name to the constructor as a string. This approach is error prone, though:Because there are no inherent checks around the string passed to the <code class="literal">PropertyChangedEventArgs</code> constructor, it’s possible to provide an invalid name. Expression trees can help avoid problems like this, as shown in the following C# class, which employs an expression tree to safely identify the changed property without resorting to obscene amounts of reflection code:</p><a id="pro_id00465"/><pre class="programlisting">// C#
public class PropertyChangedExample
  : INotifyPropertyChanged
{
  public event PropertyChangedEventHandler PropertyChanged;

  private string _myProperty = String.Empty;

  public string MyProperty
  {
    get { return _myProperty; }
    set
    {
      _myProperty = value;
      RaisePropertyChangedEvent(①() =&gt; MyProperty);
    }
  }

  protected void RaisePropertyChangedEvent&lt;TValue&gt;(
    ② Expression&lt;Func&lt;TValue&gt;&gt; propertyExpr)
  {
   if(PropertyChanged == null) return;

   var memberExpr = ③(MemberExpression)propertyExpr.Body;
   var ea = new PropertyChangedEventArgs(④ memberExpr.Member.Name);

   PropertyChanged(this, ea);
  }
}</pre><p>The preceding example shows a twist on the typical pattern for implementing <code class="literal">INotifyPropertyChanged</code>. Instead of passing a magic string to the <code class="literal">RaisePropertyChangedEvent</code> method ①, it uses a lambda expression. This <a id="iddle1234" class="indexterm"/>lambda expression isn’t compiled to a delegate, however. Instead, the C# compiler infers through the signature that it should compile the lambda expression to an expression tree ②. Inside the method, we then cast the expression’s body to <code class="literal">MemberExpression</code> at ③ so we can extract the property name and pass it to <code class="literal">PropertyChangedEventArgs</code> at ④.</p><p>Quoted expressions serve a similar purpose in F#, but unlike expression trees, they were designed with an emphasis on functional programming, not only with how they’re constructed but also with how they’re parsed. Furthermore, expression trees don’t support many important F#concepts. By contrast, quoted expressions are fully aware of concepts like currying, partial application, and recursive declarations (<code class="literal">let rec</code>). Finally, quoted expressions are designed for recursive parsing, which makes it almost trivial to walk the entire quoted structure.</p><p>You can rewrite the preceding C# class in F# using quoted expressions as follows:</p><a id="pro_id00466"/><pre class="programlisting">// F#
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.Patterns
open System.ComponentModel

type PropertyChangedExample() as x =
  let pce = Event&lt;_, _&gt;()
  let mutable _myProperty = ""
① let triggerPce =
    function
    | ② PropertyGet(_, pi, _) -&gt;
        let ea = PropertyChangedEventArgs(pi.Name)
        pce.Trigger(x, ea)
    | _ -&gt; failwith "PropertyGet quotation is required"
  interface INotifyPropertyChanged with
    [&lt;CLIEvent&gt;]
    member x.PropertyChanged = pce.Publish
  member x.MyProperty with get() = _myProperty
                      and set(value) = _myProperty &lt;- value
                                       triggerPce(③ &lt;@@ x.MyProperty @@&gt;)</pre><p>This revised version of the <code class="literal">PropertyChangedExample</code> class is structured much like the C# version. As in the C# version, <code class="literal">PropertyChangedEvent</code> isn’t published directly. Instead, the <code class="literal">triggerPce</code> function at ① accepts a quoted expression and uses pattern matching to determine whether the supplied quoted expression represents getting the value of a property at ②. Finally, instead of a lambda expression in the call to <code class="literal">triggerPce</code> at ③, the quoted expression is represented as a property reference enclosed within <code class="literal">&lt;@@</code> and <code class="literal">@@&gt;</code>. By using a quoted expression, we allow the compiler to determine whether the supplied property is valid, rather than crossing our fingers and hoping we’ve entered the correct name. Using a quoted expression in this manner also protects us against future refactorings where we remove or rename a property but forget to update the string.</p><p>Despite their many similarities, quoted expressions and expression trees aren’t quite the same. First, there’s no built-in way to evaluate quoted <a id="iddle1068" class="indexterm"/><a id="iddle1074" class="indexterm"/><a id="iddle1378" class="indexterm"/><a id="iddle1379" class="indexterm"/><a id="iddle1815" class="indexterm"/><a id="iddle1817" class="indexterm"/><a id="iddle1818" class="indexterm"/><a id="iddle2104" class="indexterm"/>expressions, nor is there any built-in way to translate between quoted expressions and expression trees. Should you need to perform either task, you’ll need to turn to the F# PowerPack, or another library that provides these capabilities. With the inclusion of query expressions (<a class="xref" href="ch10.html" title="Chapter 10. Show Me the Data">Chapter 10</a>) in F# 3.0, however, these needs should be diminished.</p></div><div class="sect1" title="Composing Quoted Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="composing_quoted_expressions">Composing Quoted Expressions</h2></div></div></div><p>Quoted expressions can take one of two forms: strongly typed and weakly typed. The distinction between the two forms is a bit of a misnomer because all quotation expressions are ultimately based upon either the <code class="literal">Expr&lt;'T&gt;</code> or <code class="literal">Expr</code> types found in the <code class="literal">Microsoft.FSharp.Quotations</code> namespace. In this context, strong and weak typing really indicates whether the quotation carries information about the expression type as opposed to describing the expression through its constituent parts. You can get a weakly typed quoted expression from a strongly typed one through its <code class="literal">Raw</code> property.</p><p>In addition to the <code class="literal">Expr</code> and <code class="literal">Expr&lt;'T&gt;</code> types, the <code class="literal">Microsoft.FSharp.Quotations</code> namespace also includes the <code class="literal">Var</code> type. The <code class="literal">Var</code> type is used inside quoted expressions to describe binding information including a binding name, its data type, and whether the binding is mutable.</p><p>Regardless of whether a quoted expression is strongly or weakly typed, all quoted expressions are subject to a few constraints. First, object expressions are forbidden within quotations. Next, the quotation cannot resolve to a generic expression. Finally, the quotation must be a complete expression; that is, a quotation must do more than define a <code class="literal">let</code> binding. Attempting to create a quoted expression that violates any of these criteria will result in a compiler error.</p><div class="sect2" title="Quoted Literals"><div class="titlepage"><div><div><h3 class="title" id="quoted_literals">Quoted Literals</h3></div></div></div><p>To create a quoted expression, you simply need to enclose an expression within <code class="literal">&lt;@</code> and <code class="literal">@&gt;</code> or <code class="literal">&lt;@@</code> and <code class="literal">@@&gt;</code>, where the first form creates a strongly typed quoted expression and the second creates a weakly typed quoted expression. For example, to create a strongly typed quoted expression that represents multiplying two values, you could write something like this:</p><a id="pro_id00467"/><pre class="programlisting">&gt; <span class="strong"><strong>open Microsoft.FSharp.Quotations</strong></span>
<span class="strong"><strong>let x, y = 10, 10</strong></span>
<span class="strong"><strong>let expr = &lt;@ x * y @&gt;;;</strong></span>

val x : int = 10
val y : int = 10
val expr : ① Expr&lt;int&gt; =
  Call (None, op_Multiply, [PropertyGet (None, x, []), PropertyGet (None, y, [])])</pre><p>In the preceding snippet, the underlying type of the quoted expression is ① <code class="literal">Expr&lt;int&gt;</code>. In this case, the compiler infers the quoted expression’s type as <code class="literal">int</code> and carries that type along with the expression. The expression’s <a id="iddle1238" class="indexterm"/><a id="iddle1380" class="indexterm"/><a id="iddle1811" class="indexterm"/><a id="iddle1846" class="indexterm"/><a id="iddle2029" class="indexterm"/>value is a listing of the source expression’s constituent elements. We’ll dive into what the pieces mean and how to use them to decompose quoted expressions a bit later in this chapter.</p><p>Quoted expressions can be simple like the one in the preceding example, but they can also represent more complex expressions including lambda expressions. For instance, a lambda expression that multiplies two integers could be quoted like this:</p><a id="pro_id00468"/><pre class="programlisting">&gt; <span class="strong"><strong>open Microsoft.FSharp.Quotations</strong></span>
<span class="strong"><strong>let expr = &lt;@ fun a b -&gt; a * b @&gt;;;</strong></span>

val expr : Expr&lt;(int -&gt; int -&gt; int)&gt; =
  Lambda (a, Lambda (b, Call (None, op_Multiply, [a, b])))</pre><p>Similarly, you can include multiple expressions in a single quoted expression. Here, a <code class="literal">let</code> bound function is defined and applied to two integer values:</p><a id="pro_id00469"/><pre class="programlisting">&gt; <span class="strong"><strong>let expr = &lt;@ let mult x y = x * y</strong></span>
                 <span class="strong"><strong>mult 10 20 @&gt;;;</strong></span>

val expr : Quotations.Expr&lt;int&gt; =
  Let (mult, Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y]))),
     Application (Application (mult, Value (10)), Value (20)))</pre></div><div class="sect2" title=".NET Reflection"><div class="titlepage"><div><div><h3 class="title" id="dotnet_reflection">.NET Reflection</h3></div></div></div><p>Another way to create a quoted expression is through standard .NET reflection. Normally, quoted expressions are created from nonexecutable code, but on occasion you may find that you’ve already defined a function that includes the code you want to quote. Rather than duplicating the code, you can decorate the function with the <code class="literal">ReflectedDefinition</code> attribute:</p><a id="pro_id00470"/><pre class="programlisting">type Calc =
  [&lt;ReflectedDefinition&gt;]
  static member Multiply x y = x * y</pre><p>Here, <code class="literal">Multiply</code> is compiled normally so it can be invoked directly, but the <code class="literal">ReflectedDefinition</code> attribute instructs the compiler to also generate a weakly typed quoted expression and embed the result within the compiled assembly. To access the generated quoted expression, you need to obtain a standard reflection <code class="literal">MethodInfo</code> object that represents the compiled method and pass it to the <code class="literal">Expr</code> class’s static <code class="literal">TryGetReflectedDefinition</code> method:</p><a id="pro_id00471"/><pre class="programlisting">&gt; <span class="strong"><strong>let expr =</strong></span>
  <span class="strong"><strong>typeof&lt;Calc&gt;</strong></span>
    <span class="strong"><strong>.GetMethod("Multiply")</strong></span>
  <span class="strong"><strong>|&gt; Expr.TryGetReflectedDefinition;;</strong></span>

val expr : Expr option =
  Some Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y])))</pre><p><a id="iddle1381" class="indexterm"/><a id="iddle1814" class="indexterm"/><a id="iddle1847" class="indexterm"/>When you need to quote multiple values within a type, decorating each one with the <code class="literal">ReflectedDefinition</code> attribute can get tedious. Fortunately, you can also apply the attribute to modules and types to generate quoted expressions for each of their values or members, respectively.</p></div><div class="sect2" title="Manual Composition"><div class="titlepage"><div><div><h3 class="title" id="manual_composition">Manual Composition</h3></div></div></div><p>The final way to compose a quoted expression is to manually construct one by chaining the results of calls to the <code class="literal">Expr</code> type’s static methods. The <code class="literal">Expr</code> type defines over 40 methods that create new <code class="literal">Expr</code> instances, each representing the various constructs that can appear in a quoted expression.</p><p>The <code class="literal">Expr</code> methods are defined such that their purpose should be clear now that you know about the data structures and language constructs available to you in F#, so I won’t go into detail about each of them. There are two important things to note about the methods, though.</p><p>First, the method parameters are tupled so instead of currying multiple parameters, they must be provided in tupled form. Second, many of the methods—nearly 50 percent of them—use .NET reflection to construct the corresponding expression.</p><p>Building quoted expressions manually can be tedious, but it gives you the most control over how expressions are constructed. Perhaps more important, however, is that these methods allow you to build quoted expressions based on code that you don’t control and therefore can’t decorate with the <code class="literal">ReflectedDefinition</code> attribute.</p><p>To demonstrate the process of manually constructing a quoted expression, let’s walk through constructing a method that multiplies two values using the multiplication operator. To begin, we need to use reflection to access the <code class="literal">Operators</code> module where the multiplication operator is defined, like this:</p><a id="pro_id00472"/><pre class="programlisting">let operators =
  System.Type.GetType("Microsoft.FSharp.Core.Operators, FSharp.Core")</pre><p>This binding uses a partially qualified name to identify the type we’re looking for. (We had to use reflection here because <code class="literal">typeof&lt;'T&gt;</code> and <code class="literal">typedefof&lt;'T&gt;</code> don’t work on modules.) Now that we have a reference to the <code class="literal">Operators</code> module, we can obtain a reference to the multiplication operator method by its name, <code class="literal">op_Multiply</code>, with the <code class="literal">GetMethod</code> method:</p><a id="pro_id00473"/><pre class="programlisting">let multiplyOperator = operators.GetMethod("op_Multiply")</pre><p>Next, we inspect the returned <code class="literal">MethodInfo</code> to retrieve each of the operator’s parameters. To include these parameters in our expression, we need to create <code class="literal">Var</code> instances from the corresponding <code class="literal">PropertyInfo</code> instances. We can <a id="iddle1075" class="indexterm"/>easily perform this transformation by mapping each parameter through the <code class="literal">Array.map</code> function. For convenience, we can also use an Array pattern to convert the resulting array into a tuple, as shown here:</p><a id="pro_id00474"/><pre class="programlisting">let varX, varY =
  multiplyOperator.GetParameters()
  |&gt; Array.map (fun p -&gt; Var(p.Name, p.ParameterType))
  |&gt; (function | [| x; y |] -&gt; x, y
               | _ -&gt; failwith "not supported")</pre><p>We now have enough information to construct the quoted expression:</p><a id="pro_id00475"/><pre class="programlisting">let call = Expr.Call(multiplyOperator, [ Expr.Var(varX); Expr.Var(varY) ])
let innerLambda = Expr.Lambda(varY, call)
let outerLambda = Expr.Lambda(varX, innerLambda)</pre><p>The preceding bindings incrementally construct a quoted expression representing a curried function that multiplies two values. As you can see, the quoted expression contains a method call for the multiplication operator, an inner lambda expression that applies the <code class="literal">y</code> value, and an outer lambda expression that applies the <code class="literal">x</code> value. If you were to inspect the value of <code class="literal">outerLambda</code>, you should see the resulting expression represented like this:</p><a id="pro_id00476"/><pre class="programlisting">val outerLambda : Expr =
  Lambda (x, Lambda (y, Call (None, op_Multiply, [x, y])))</pre><p>After all this work, we finally have a quoted expression that’s equivalent to this weakly typed expression:</p><a id="pro_id00477"/><pre class="programlisting">&lt;@@ fun x y -&gt; x * y @@&gt;</pre><p>For your convenience, I’m including the previous examples in their entirety here so you can see all the parts working together.</p><a id="pro_id00478"/><pre class="programlisting">let operators =
  System.Type.GetType("Microsoft.FSharp.Core.Operators, FSharp.Core")
let multiplyOperator = operators.GetMethod("op_Multiply")
let varX, varY =
  multiplyOperator.GetParameters()
  |&gt; Array.map (fun p -&gt; Var(p.Name, p.ParameterType))
  |&gt; (function | [| x; y |] -&gt; x, y
               | _ -&gt; failwith "not supported")

let call = Expr.Call(multiplyOperator, [ Expr.Var(varX); Expr.Var(varY) ])
let innerLambda = Expr.Lambda(varY, call)
let outerLambda = Expr.Lambda(varX, innerLambda)</pre></div><div class="sect2" title="Splicing Quoted Expressions"><div class="titlepage"><div><div><h3 class="title" id="splicing_quoted_expressions">Splicing Quoted Expressions</h3></div></div></div><p><a id="iddle1069" class="indexterm"/><a id="iddle1076" class="indexterm"/><a id="iddle1310" class="indexterm"/><a id="iddle1382" class="indexterm"/><a id="iddle1768" class="indexterm"/><a id="iddle1812" class="indexterm"/><a id="iddle1816" class="indexterm"/><a id="iddle1848" class="indexterm"/>If you need to combine multiple quoted expressions, you could manually construct a new quoted expression by passing each one to the appropriate static method on the <code class="literal">Expr</code> class (typically <code class="literal">Call</code>), but there’s a much easier way: You can create a new literal quoted expression by splicing them together using the splicing operators. For example, suppose you have the following sequence and strongly typed quoted expressions:</p><a id="pro_id00479"/><pre class="programlisting">let numbers = seq { 1..10 }
let sum = &lt;@ Seq.sum numbers @&gt;
let count = &lt;@ Seq.length numbers @&gt;</pre><p>You can combine <code class="literal">sum</code> and <code class="literal">count</code> into a third quoted expression that represents calculating the average from a sequence using the strongly typed splice operator (<code class="literal">%</code>) like this:</p><a id="pro_id00480"/><pre class="programlisting">let avgExpr = &lt;@ %sum / %count @&gt;</pre><p>Weakly typed quoted expressions can be spliced, too. If <code class="literal">sum</code> and <code class="literal">count</code> had been defined as weakly typed quoted expressions (via the <code class="literal">&lt;@@ ... @@&gt;</code> syntax), you could splice them with the weakly typed splice operator (<code class="literal">%%</code>) like this:</p><a id="pro_id00481"/><pre class="programlisting">let avgExpr = &lt;@@ %%sum / %%count @@&gt;</pre></div></div><div class="sect1" title="Decomposing Quoted Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="decomposing_quoted_expressions">Decomposing Quoted Expressions</h2></div></div></div><p>While code quotations can be useful for helping you understand the structure of code, most of their power comes from decomposition. F# includes three modules, also within the <code class="literal">Microsoft.FSharp.Quotations</code> namespace, that define a plethora of complete and partial active patterns that you can use todecompose a quoted expression to its constituent parts at varying degrees of granularity.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="Pattern module"><span class="title"><strong><span class="strong"><strong><code class="literal">Pattern</code> module</strong></span></strong></span>. The partial active patterns in the <code class="literal">Pattern</code> module match the elementary F# language features such as function calls, function applications, looping constructs, raw values, binding definitions, and object creation. They correspond nearly one-to-one with the functions defined on the <code class="literal">Expr</code> type, helping you identify which pattern to use for the most common expressions.</p></li><li class="listitem" style="list-style-type: none"><p title="DerivedPatterns module"><span class="title"><strong><span class="strong"><strong><code class="literal">DerivedPatterns</code> module</strong></span></strong></span>. The <code class="literal">DerivedPatterns</code> module includes partial active patterns that primarily match quoted expressions representing primitive literals, basic Boolean operators such as <code class="literal">&amp;&amp;</code> and <code class="literal">||</code>, and constructs decorated with <code class="literal">ReflectedDefinition</code>.</p></li><li class="listitem" style="list-style-type: none"><p title="ExprShape module"><span class="title"><strong><span class="strong"><strong><code class="literal">ExprShape</code> module</strong></span></strong></span>. <a id="iddle1916" class="indexterm"/><a id="iddle1918" class="indexterm"/><a id="iddle1920" class="indexterm"/>The <code class="literal">ExprShape</code> module defines a complete active pattern with three cases: <code class="literal">ShapeVar</code>, <code class="literal">ShapeLambda</code>, and <code class="literal">ShapeCombination</code>. It’s designed for use in recursive pattern matching so you can easily traverse a quoted expression, matching every expression along the way.</p></li></ul></div><div class="sect2" title="Parsing Quoted Expressions"><div class="titlepage"><div><div><h3 class="title" id="parsing_quoted_expressions">Parsing Quoted Expressions</h3></div></div></div><p>Rather than going into detail about the specific active patterns defined in each module, I think it’s more helpful to see how they work together. We’ll start with a typical example, where a sampling of patterns from each module is used to build a string that represents the quoted F# syntax.</p><a id="pro_id00482"/><pre class="programlisting">open System.Text
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Quotations.DerivedPatterns
open Microsoft.FSharp.Quotations.ExprShape

let rec showSyntax =
  function
  | Int32 v -&gt;
      sprintf "%i" v
  | Value (v, _) -&gt;
      sprintf "%s" (v.ToString())
  | SpecificCall &lt;@@ (+) @@&gt; (_, _, exprs) -&gt;
      let left = showSyntax exprs.Head
      let right = showSyntax exprs.Tail.Head
      sprintf "%s + %s" left right
  | SpecificCall &lt;@@ (-) @@&gt; (_, _, exprs) -&gt;
      let left = showSyntax exprs.Head
      let right = showSyntax exprs.Tail.Head
      sprintf "%s - %s" left right
  | Call (opt, mi, exprs) -&gt;
      let owner = match opt with
                  | Some expr -&gt; showSyntax expr
                  | None -&gt; sprintf "%s" mi.DeclaringType.Name
      if exprs.IsEmpty then
        sprintf "%s.%s ()" owner mi.Name
      else
        let sb = StringBuilder(showSyntax exprs.Head)
        exprs.Tail
        |&gt; List.iter (fun expr -&gt;
                           sb
                             .Append(",")
                             .Append(showSyntax expr) |&gt; ignore)
        sprintf "%s.%s (%s)" owner mi.Name (sb.ToString())
  | ShapeVar var -&gt;
      sprintf "%A" var
  | ShapeLambda (p, body) -&gt;
      sprintf "fun %s -&gt; %s" p.Name (showSyntax body)
  | ShapeCombination (o, exprs) -&gt;
      let sb = StringBuilder()
      exprs |&gt; List.iter (fun expr -&gt; sb.Append(showSyntax expr) |&gt; ignore)
      sb.ToString()</pre><p><a id="iddle1223" class="indexterm"/><a id="iddle1532" class="indexterm"/><a id="iddle1917" class="indexterm"/><a id="iddle1919" class="indexterm"/><a id="iddle1921" class="indexterm"/><a id="iddle1937" class="indexterm"/><a id="iddle2098" class="indexterm"/>The preceding example may look intimidating, but despite including a number of match cases, it’s really not particularly complicated when you break it down. The first thing to note is that the <code class="literal">showSyntax</code> function is recursive, which allows us to traverse the tree with any nested expressions we encounter. Each of the match cases belongs to one of the three quoted expression modules and matches a particular type of expression. I won’t go into detail about the bodies of each case since they don’t introduce any new concepts, but I encourage you to experiment with them.</p><p>The first two cases, <code class="literal">Int32</code> and <code class="literal">Value</code>, match individual literal values. The <code class="literal">Int32</code> pattern is a derived pattern that matches only integer values, whereas <code class="literal">Value</code> is a basic pattern that matches any literal value. As you can see from the definitions, both of these patterns extract the literal value. The <code class="literal">Value</code> pattern also extracts the corresponding data type, but since we’re not using it here we simply discard it with the Wildcard pattern.</p><p>Following the <code class="literal">Value</code> case are two <code class="literal">SpecificCall</code> cases and a generalized <code class="literal">Call</code> case. The <code class="literal">SpecificCall</code> cases are derived patterns that match calls to the addition and subtraction operators (as inline weakly typed quoted expressions), respectively. The <code class="literal">Call</code> case, on the other hand, is a basic pattern that matches any function call. The <code class="literal">SpecificCall</code> cases are much simpler than the <code class="literal">Call</code> case because we can make certain assumptions about the code given that we know more about what constitutes a match. The <code class="literal">Call</code> case needs to do more work to expand the expression.</p><p>Finally, we reach the last three cases: <code class="literal">ShapeVar</code>, <code class="literal">ShapeLambda</code>, and <code class="literal">ShapeCombination</code>. The simplest of these, <code class="literal">ShapeVar</code>, matches any variable definition. (Note that the term <span class="emphasis"><em>variable</em></span> is preferable to <span class="emphasis"><em>binding</em></span> here because it represents a placeholder within the code.) The value captured by <code class="literal">ShapeVar</code> includes information such as the variable name, its data type, and mutability. <code class="literal">ShapeLambda</code> matches any lambda expression, capturing its parameter definition and body as a nested expression. The last case, <code class="literal">ShapeCombination</code>, matches any other expression and is included here for completeness.</p><p>To see the <code class="literal">showSyntax</code> function in action, you can pass in any quoted expression. Just remember that this implementation hardly covers every possible case, so with more complex expressions your results will probably be less than stellar. For starters, though, here are a few sample inputs and results:</p><a id="pro_id00483"/><pre class="programlisting">&gt; <span class="strong"><strong>showSyntax &lt;@ fun x y -&gt; x + y @&gt;;;</strong></span>
val it : string = "fun x -&gt; fun y -&gt; x + y"
&gt; <span class="strong"><strong>showSyntax &lt;@ fun x y -&gt; x - y @&gt;;;</strong></span>
val it : string = "fun x -&gt; fun y -&gt; x - y"
&gt; <span class="strong"><strong>showSyntax &lt;@ 10 * 20 @&gt;;;</strong></span>
val it : string = "Operators.op_Multiply (10,20)"
&gt; <span class="strong"><strong>showSyntax &lt;@@ System.Math.Max(10, 20) @@&gt;;;</strong></span>
val it : string = "Math.Max (10,20)"</pre></div><div class="sect2" title="Substituting Reflection"><div class="titlepage"><div><div><h3 class="title" id="substituting_reflection">Substituting Reflection</h3></div></div></div><p>Just as you can use expression trees to enable reflection-like capabilities (as you saw at the beginning of this chapter), you can use quoted expressions to achieve a similar effect. To demonstrate, I’ll use an adapted version of a sample I found extremely helpful when I was first learning about quoted expressions.</p><p>This example, found in its original form at <span class="emphasis"><em><a class="ulink" href="http://fssnip.net/eu/" target="_top">http://fssnip.net/eu/</a></em></span>, defines a module that makes extensive use of higher-order functions, partial application, and quoted expressions, letting you define ad hoc validation functions for your types. We’ll start with the full listing and break it down after you’ve had a chance to digest it.</p><a id="pro_id00484"/><pre class="programlisting">module Validation =
  open System
  open Microsoft.FSharp.Quotations
  open Microsoft.FSharp.Quotations.Patterns

  type Test&lt;'e&gt; = | Test of ('e -&gt; (string * string) option)

  ① let private add (quote : Expr&lt;'x&gt;) message args validate (xs : Test&lt;'e&gt; list) =
    let propName, eval =
      match quote with
      | PropertyGet (_, p, _) -&gt; p.Name, fun x -&gt; p.GetValue(x, [||])
      | Value (_, ty) when ty = typeof&lt;'e&gt; -&gt; "x", box
      | _ -&gt; failwith "Unsupported expression"
    let test entity =
      let value = eval entity
      if validate (unbox value) then None
      else Some (propName, String.Format(message, Array.ofList (value :: args)))
    Test(test) :: xs

  ② let notNull quote =
    let validator = (fun v -&gt; v &lt;&gt; null)
    add quote "Is a required field" [] validator

  ③ let notEmpty quote =
    add quote "Cannot be empty" [] (String.IsNullOrWhiteSpace &gt;&gt; not)

  ④ let between quote min max =
    let validator = (fun v -&gt; v &gt;= min &amp;&amp; v &lt;= max)
    add quote "Must be at least {2} and greater than {1}" [min; max] validator

  ⑤ let createValidator (f : 'e -&gt; Test&lt;'e&gt; list -&gt; Test&lt;'e&gt; list) =
    let entries = f Unchecked.defaultof&lt;_&gt; []
    fun entity -&gt; List.choose (fun (Test test) -&gt; test entity) entries</pre><p>The <code class="literal">Validation</code> module’s heart is the private <code class="literal">add</code> function at ①. This function accepts five parameters that each participate in the validation. Of primary interest are the first parameter, <code class="literal">quote</code>; the third parameter, <a id="iddle1792" class="indexterm"/><a id="iddle2099" class="indexterm"/><code class="literal">validate</code>; and the final parameter, <code class="literal">xs</code>. These represent the quotation that identifies the property being validated, a validation function, and a list of test functions, respectively.</p><p>Inside <code class="literal">add</code>, we first attempt to match <code class="literal">quote</code> against the <code class="literal">PropertyGet</code> and <code class="literal">Value</code> active patterns to appropriately extract the value from the source object so it can be passed to the validation function later. Next, we define a function, <code class="literal">test</code>, that invokes the supplied <code class="literal">validate</code> function and returns an option indicating whether the extracted value is valid. Finally, the <code class="literal">test</code> function is wrapped inside the <code class="literal">Test</code> union case and prepended to <code class="literal">xs</code>, and the entire list is returned.</p><p>With the <code class="literal">add</code> function in place, we define a variety of functions that return partially applied versions of <code class="literal">add</code>, giving us an expressive validation syntax. In this example, we’ve defined <code class="literal">notNull</code> ②, <code class="literal">notEmpty</code> ③, and <code class="literal">between</code> ④. Each of these functions accepts a quoted expression that’s applied to <code class="literal">add</code> along with the next three parameters, resulting in new functions that accept only a list of <code class="literal">Test</code> union cases and return the same.</p><p>The <code class="literal">createValidator</code> ⑤ function is the primary entry point into the <code class="literal">Validation</code> module. <code class="literal">createValidator</code> accepts a curried function whose arguments include a generic value and a list of <code class="literal">Test</code> union cases (of the same generic type), and ultimately returns another list of <code class="literal">Test</code> union cases. Notice how the second parameter and return value correspond to the functions returned by the <code class="literal">notNull</code>, <code class="literal">notEmpty</code>, and <code class="literal">between</code> functions. The implication here is that we can compose a validation function to pass into <code class="literal">createValidator</code> for arbitrary invocation later.</p><p>Now that the <code class="literal">Validation</code> module is fully defined, we can see how to use it. Let’s begin by opening the <code class="literal">Validation</code> module and defining a simple record type definition that we can validate against.</p><a id="pro_id00485"/><pre class="programlisting">open Validation
type TestType = { ObjectValue : obj
                  StringValue : string
                  IntValue : int }</pre><p>There’s nothing particularly notable about this type; it merely includes three labels we can reference for validation. Now we can create a validation method by calling <code class="literal">createValidator</code> like this:</p><a id="pro_id00486"/><pre class="programlisting">let validate =
  createValidator &lt;| fun x -&gt; notNull &lt;@ x.ObjectValue @&gt; &gt;&gt;
                              notEmpty &lt;@ x.StringValue @&gt; &gt;&gt;
                              between &lt;@ x.IntValue @&gt; 1 100</pre><p>Here, we’ve chained together calls to <code class="literal">notNull</code>, <code class="literal">notEmpty</code>, and <code class="literal">between</code> using the composition operator within the function we pass to <code class="literal">createValidator</code>. The resulting function (returned from <code class="literal">createValidator</code>) is then bound to <code class="literal">validate</code>. Each of the chained calls includes a quoted expression that identifies one of <code class="literal">TestType</code>’s labels. You can even see here how F#’s type inference has played a role in determining the type of <code class="literal">x</code> in this expression.</p><p>All we need to do now is invoke the <code class="literal">validate</code> function by passing it instances of <code class="literal">TestType</code>. When all values satisfy the validation, <code class="literal">validate</code> simply returns an empty list like this:</p><a id="pro_id00487"/><pre class="programlisting">&gt; <span class="strong"><strong>{ ObjectValue = obj(); StringValue = "Sample"; IntValue = 35 }</strong></span>
<span class="strong"><strong>|&gt; validate;;</strong></span>
val it : (string * string) list = []</pre><p>On the other hand, when one or more values fail validation, the <code class="literal">validate</code> function returns a list including the name of the member that failed along with a failure message, as shown here where all three values fail:</p><a id="pro_id00488"/><pre class="programlisting">&gt; <span class="strong"><strong>{ ObjectValue = null; StringValue = ""; IntValue = 1000 }</strong></span>
<span class="strong"><strong>|&gt; validate;;</strong></span>
val it : (string * string) list =
  [("IntValue", "Must be at least 100 and greater than 1");
   ("StringValue", "Cannot be empty"); ("ObjectValue", "Is a required field")]</pre></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00015">Summary</h2></div></div></div><p>Although quoted expressions serve much the same purpose as the expression trees introduced with LINQ, F#’s quoted expressions are more finely tuned for functional programming. As you’ve seen, you can construct quoted expressions as literal expressions, directly through reflection with the <code class="literal">ReflectedDefinition</code> attribute, or programmatically with reflection and the static methods on the <code class="literal">Expr</code> class. Quoted expressions derive their true power from their decomposition, however. By using the active patterns defined in the <code class="literal">Patterns</code>, <code class="literal">DerivedPatterns</code>, and <code class="literal">ExprShape</code> modules, you can decompose a quoted expression at varying degrees of granularity to accomplish a variety of tasks such as language translation or even flexible validation.</p></div></section></body></html>