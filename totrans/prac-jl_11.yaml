- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9  '
- en: PHYSICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学**
- en: '*Physics is not a religion. If it were, we’d have a much easier time raising
    money.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*物理学不是宗教。如果它是宗教，我们就更容易筹集资金了。*'
- en: —Leon M. Lederman
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —利昂·M·莱德曼
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Julia is a superb platform for physics calculations of all kinds. Various features
    of its syntax, such as the ability to use mathematical symbols and its concise
    array operations, make it a natural fit for programming algorithms that we use
    in physics. Julia’s speed of execution makes it one of only a few languages used
    for the most demanding large-scale simulations (and the others in this club are
    all lower-level, statically compiled languages). Julia’s physics ecosystem includes
    some state-of-the-art packages. Finally, Julia’s unique ability to mix and match
    functions and data types from disparate packages to create new capabilities is
    especially powerful in physics calculations, as we’ll see in detail in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是进行各种物理计算的出色平台。它的语法特性，例如使用数学符号的能力和简洁的数组操作，使其成为编程物理算法的自然选择。Julia的执行速度使其成为仅有的几种用于最具挑战性的大规模模拟的语言之一（其他的都是低级的、静态编译的语言）。Julia的物理生态系统包括一些最先进的软件包。最后，Julia独特的能力是将来自不同软件包的函数和数据类型混合搭配，创造出新的功能，这在物理计算中尤其强大，正如我们将在本章中详细看到的。
- en: We begin with an introduction to two packages of general utility for dealing
    with units and errors. Both of these are potentially helpful in any physics project.
    We’ll spend some time in the first section looking into various options for producing
    publication-quality plots including typeset units in axis labels. Then we’ll turn
    to specific calculations, first using a package for fluid dynamics and then using
    a general-purpose differential equation solver. See “Further Reading” on [page
    304](ch09.xhtml#fur9) for each major package’s URL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍两个通用软件包开始，这些软件包用于处理单位和误差。这两个软件包在任何物理项目中都可能是有用的。在第一部分，我们将花一些时间研究如何生成包含轴标签中的排版单位的出版质量图表的各种选项。然后我们将转向具体的计算，首先使用一个流体动力学软件包，然后使用一个通用的微分方程求解器。有关每个主要软件包的URL，请参见[第304页](ch09.xhtml#fur9)中的“进一步阅读”。
- en: '**Bringing Physical Units into the Computer with Unitful**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过Unitful将物理单位引入计算机**'
- en: The traditional way to perform physics calculations on a computer is to represent
    physical quantities as floating-point numbers, subject those numbers to a long
    series of arithmetic operations, and then interpret the results again as physical
    quantities. Since physical quantities are usually not simply numbers, but have
    *dimensions*, we need to manually keep track of the *units* that are associated
    with these quantities, often with code comments to remind us what the various
    units are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上执行物理计算的传统方法是将物理量表示为浮点数，对这些数字进行一系列算术运算，然后再将结果解释为物理量。由于物理量通常不仅仅是数字，而是具有*维度*的，我们需要手动跟踪与这些量相关联的*单位*，通常通过代码注释来提醒我们这些单位是什么。
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A* dimension *is a fundamental physical idea encompassing something that can
    be measured, such as mass or time. A* unit *is a specific way of measuring a dimension.
    The dimensions are universal, but there are various systems of units. For example,
    for the dimension of length, some common units are centimeter (cm), meter (m),
    or, if we live in the United States, inches or football fields.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*维度*是一个基本的物理概念，涵盖了可以被测量的东西，比如质量或时间。*单位*是衡量一个维度的具体方式。维度是普遍存在的，但有不同的单位系统。例如，对于长度维度，一些常见的单位是厘米（cm）、米（m），或者如果我们生活在美国，可能是英寸或美式足球场。'
- en: In other words, the physical meanings of the numbers appearing in a program
    are not part of the quantities themselves, but are implicit. It may not be surprising
    that this can lead to confusion and errors. In 1999, NASA lost a spacecraft because
    two different contractors were contributing to the design, and their engineering
    programs used different systems of units.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，程序中出现的数字的物理意义并不是这些量本身的一部分，而是隐含的。这可能并不令人惊讶，因为这可能导致混淆和错误。1999年，NASA因为两个不同的承包商分别参与设计，并且他们的工程程序使用了不同的单位系统，导致失去了一个航天器。
- en: In traditional languages for physics, such as Fortran, not much can be done
    about this issue directly. In Julia, because of its sophisticated type system,
    we are not limited to collections of dimensionless numbers; we can calculate with
    richer objects including units.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的物理学语言中，如 Fortran，通常无法直接解决这个问题。但在 Julia 中，由于其先进的类型系统，我们不局限于无量纲数值的集合；我们可以与包含单位的更丰富的对象进行计算。
- en: 'After importing the `Unitful` package, we can refer to many common physics
    units using a nonstandard string literal (see “Nonstandard String Literals” on
    [page 128](ch05.xhtml#ch05lev4)) with the prefix `u`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `Unitful` 包后，我们可以使用非标准字符串文字（见 [第128页](ch05.xhtml#ch05lev4) 中的“非标准字符串文字”）并以
    `u` 前缀引用许多常见的物理单位：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we add a meter and a centimeter, and receive the result as a rational number
    of meters. The package returns results as rational numbers, when possible, to
    preserve the ability to carry out exact conversions. But, as the second example
    shows, we can coerce a floating-point result by supplying a floating-point coefficient.
    The third example shows how we can construct expressions within the string literal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将米和厘米相加，得到的结果是一个表示米数的有理数。该包在可能的情况下返回有理数结果，以保持执行精确转换的能力。但是，正如第二个例子所示，我们可以通过提供浮点系数来强制转换为浮点结果。第三个例子展示了我们如何在字符串文字中构造表达式。
- en: 'You can find the complete list of units only in the source code, in its GitHub
    repository at *src/pkgdefaults.jl*, but most of them follow the usual physics
    conventions. Using the string literal syntax each time we want to refer to a unit
    can be cumbersome, so we can assign units to our own variables to ease our typing
    and make the code easier to read:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中的 GitHub 仓库的 *src/pkgdefaults.jl* 文件中找到完整的单位列表，但大多数单位遵循常见的物理学约定。每次引用单位时使用字符串文字语法可能会显得繁琐，因此我们可以将单位分配给自己的变量，以便减少输入并使代码更易读：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We add a meter to a kilometer, showing how we can use custom variables in combination
    with the string literals. The result is 1,001 meters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一米加到一公里，展示了如何将自定义变量与字符串文字结合使用。结果是 1,001 米。
- en: 'We can parse a string as a `Unitful` expression with another function provided
    by the package (undocumented at the time of writing):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包提供的另一个函数将字符串解析为 `Unitful` 表达式（在写作时没有文档）：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we use `uparse()` to convert a string, created by concatenating a string
    representing a mass with another representing the gravitational acceleration near
    the surface of Earth, into a unit expression representing the mass’s weight. The
    forms in which unit expressions appear in the REPL are not themselves legal strings
    for converting with `uconvert()`. For example, we need to include the multiplication
    operator in the string in the second line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `uparse()` 将一个由表示质量的字符串和另一个表示地球表面重力加速度的字符串连接起来，转换为一个表示质量重量的单位表达式。单位表达式在
    REPL 中的形式本身不是可以通过 `uconvert()` 转换的合法字符串。例如，我们需要在第二行的字符串中包含乘法运算符。
- en: '***Using Unitful Types***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Unitful 类型***'
- en: 'We can gain access to a large supply of standard SI units by importing the
    `DefaultSymbols` submodule rather than defining them one by one. This practice
    adds a profusion of names to our namespace, however, so it may not be a good idea
    if we’re using only a few units:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导入 `DefaultSymbols` 子模块来访问大量标准 SI 单位，而不是一个个地定义它们。然而，这种做法会将大量名称添加到我们的命名空间中，因此如果我们只使用少数单位，可能不是一个好主意：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we add 2 seconds to 1 minute, resulting in 62 seconds. The `DefaultSymbols`
    submodule supplies the `s` unit, but we need to define `minute`, as that’s not
    an SI unit. We’re using Julia’s syntax for multiplication through juxtaposition;
    this expression is the same as `2 * s + 1minute`. However, these variables must
    be attached to numerical coefficients in arithmetic expressions; `2 * s + minute`
    is a `MethodError`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将 2 秒加到 1 分钟，结果是 62 秒。`DefaultSymbols` 子模块提供了 `s` 单位，但我们需要定义 `minute`，因为它不是
    SI 单位。我们通过并列的方式使用 Julia 的乘法语法；这个表达式与 `2 * s + 1minute` 是相同的。然而，这些变量必须附加到算术表达式中的数值系数上；`2
    * s + minute` 会导致 `MethodError`。
- en: 'We can find the reason for this error in the types of the two expressions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这两个表达式的类型找到该错误的原因：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type of `1minute`, which is the same as the type of `1 * minute`, is a `Quantity`,
    while the type of `minute` is a `FreeUnits`. Both of these types are defined in
    the package. The `Unitful` package defines methods for addition and other arithmetic
    operations that accept arguments of type `Quantity`, but not of type `FreeUnits`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`1minute`的类型（与`1 * minute`的类型相同）是`Quantity`，而`minute`的类型是`FreeUnits`。这两种类型都在包中定义。`Unitful`包定义了接受`Quantity`类型参数的加法和其他算术运算方法，但不接受`FreeUnits`类型的参数。'
- en: These types contain parameters appearing as boldface Unicode characters. The
    `Unitful` package uses these characters to represent dimensions, so these type
    specifications tell us that the `minute` unit has dimensions of time, represented
    by `**T**`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型包含作为粗体Unicode字符出现的参数。`Unitful`包使用这些字符来表示维度，因此这些类型规范告诉我们，`minute`单位具有时间维度，用`**T**`表示。
- en: The type of `minute` and other units is an abstract type (see “The Type Hierarchy”
    on [page 222](ch08.xhtml#ch08lev1sec4)), while the types of quantified units such
    as `1minute` are concrete. For good performance, we should calculate with concrete
    types and define our own types with fields that have concrete types only.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`minute`类型和其他单位是抽象类型（见[第222页](ch08.xhtml#ch08lev1sec4)的“类型层次结构”），而诸如`1minute`这样的量化单位类型是具体类型。为了获得更好的性能，我们应该使用具体类型进行计算，并定义只包含具体类型字段的自定义类型。'
- en: '***Stripping and Converting Units***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***剥离和转换单位***'
- en: 'Sometimes we need to remove the units from the result of a calculation—for
    example, when passing a result to a function that doesn’t understand units. We
    can do this with the `convert()` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要从计算结果中去除单位——例如，当将结果传递给一个无法理解单位的函数时。我们可以通过`convert()`函数来做到这一点：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The type of the result is `Float64`. The results returned by `Unitful` calculations
    may not always be what we expect, so we should use `convert()` when we require
    a simple number:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的类型是`Float64`。`Unitful`计算返回的结果可能并不总是我们预期的，因此当我们需要一个简单数字时，应使用`convert()`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we divide a length by another length, so the result should be the simple
    number 1.0 (because the lengths are equal) with no dimensions. The actual result
    is equivalent to that, but it’s expressed in an obscure form. Checking the type
    of the result, we find that it’s the concrete `Unitful` type `Quantity`, with
    type parameters indicating that it has no dimensions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将一个长度除以另一个长度，因此结果应该是简单的数字1.0（因为长度相等），且没有维度。实际结果等同于此，但它以一个模糊的形式表达。检查结果的类型，我们发现它是具体的`Unitful`类型`Quantity`，其类型参数表示它没有维度。
- en: 'If we use the same literal unit in the numerator and denominator, we get a
    result that may be closer to what we expect:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在分子和分母中使用相同的字面单位，我们会得到一个更接近我们预期的结果：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A further example shows that `Unitful` is consistent in retaining the units
    we use in expressions instead of making conversions that might seem obvious to
    a physicist:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的例子表明，`Unitful`在保留我们在表达式中使用的单位时是一致的，而不是进行物理学家可能认为显而易见的转换：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two input expressions mean the same thing, but lead to equivalent results
    that are expressed differently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个输入表达式意味着相同的事情，但会产生以不同方式表达的等效结果。
- en: 'The function `upreferred()` from `Unitful` converts expressions so they use
    a standard set of units. The user can establish preferred systems of units, but
    the default behavior uses conventional SI units:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unitful`中的`upreferred()`函数将表达式转换为使用标准单位集的形式。用户可以建立首选的单位系统，但默认行为是使用常规的SI单位：'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to converting to a number with `convert()`, we can use `uconvert()`,
    which is part of `Unitful`, to convert between units:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`convert()`转换为数字外，我们还可以使用`Unitful`中的`uconvert()`来进行单位之间的转换：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function takes the unit to convert to in its first argument and the expression
    to convert in its second argument. In the first example we convert from ergs to
    joules. As both are metric units related by an exact ratio, `uconvert()` supplies
    the answer using a rational coefficient. The second example is a conversion from
    the US unit of mass, slugs, to kilograms, the standard SI unit used in physics.
    The conversion factor is a floating-point number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个参数是要转换到的单位，第二个参数是要转换的表达式。在第一个示例中，我们将能量从ergs转换为joules。由于这两者是由精确比例关系相关的公制单位，`uconvert()`使用有理数系数提供答案。第二个示例是将美国的质量单位slug转换为千克，后者是物理学中使用的标准SI单位。转换因子是一个浮动的浮点数。
- en: '[Listing 9-1](ch09.xhtml#ch9lis1) shows another way to extract the purely numerical
    part of a `Unitful` expression with `ustrip()`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-1](ch09.xhtml#ch9lis1) 展示了另一种方法，通过 `ustrip()` 提取 `Unitful` 表达式中的纯数字部分。'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-1: Stripping units with* ustrip()'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：使用* ustrip() *去除单位*'
- en: The `ustrip()` function preserves the numerical type in the expression.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ustrip()` 函数在表达式中保留数值类型。'
- en: To extract just the unit from a `Unitful` expression, the package provides the
    `unit()` function, as shown in [Listing 9-2](ch09.xhtml#ch9lis2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `Unitful` 表达式中提取单位，包提供了 `unit()` 函数，如 [列表 9-2](ch09.xhtml#ch9lis2) 所示。
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-2: Extracting units with* unit()'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：使用* unit() *提取单位*'
- en: We’ll find applications for `ustrip()` and `unit()` in “Plotting with Units”
    on [page 276](ch09.xhtml#ch09lev1sec4).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“带单位的绘图”部分的 [第 276 页](ch09.xhtml#ch09lev1sec4) 中找到 `ustrip()` 和 `unit()`
    的应用。
- en: '***Typesetting Units***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***排版单位***'
- en: 'Using the `UnitfulLatexify` package, we can turn our `Unitful` expressions
    into LaTeX-typeset mathematics: either as LaTeX source ready to be dropped into
    a research paper or as a rendered image. Here is a simple example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UnitfulLatexify` 包，我们可以将 `Unitful` 表达式转化为 LaTeX 排版的数学公式：可以是可以直接放入研究论文中的
    LaTeX 源代码，也可以是渲染后的图像。以下是一个简单的例子：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `latexify()` function transforms the `Unitful` expression for Earth’s gravitational
    acceleration into a LaTeX string. We encountered La TeXstrings in [Listing 4-1](ch04.xhtml#ch4lis1),
    when we used one to generate a title for a graph. The `UnitfulLatexify` package
    combines the LaTeX abilities in `Latexify` with `Unitful`, which is why we need
    to import all three packages, as we did at the start of this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`latexify()` 函数将地球重力加速度的 `Unitful` 表达式转换为 LaTeX 字符串。我们在 [列表 4-1](ch04.xhtml#ch4lis1)
    中遇到过 LaTeX 字符串，当时我们用它来为图表生成标题。`UnitfulLatexify` 包结合了 `Latexify` 中的 LaTeX 能力与 `Unitful`，这就是为什么我们需要导入这三个包，就像在本示例开始时那样。'
- en: When used in the REPL or another nongraphical context, `latexify()` produces
    LaTeX markup ready to be copied and pasted into a document. We can, instead, create
    a PDF image of the result by passing it to the `render()` function. To do that,
    you need to have the external program `LuaLaTeX`, which is part of standard LaTeX
    installations, installed. If that program is available, `render()` will use it
    to typeset the LaTeX string and immediately display it with the default PDF viewer.
    The `render()` process litters your temporary directory with files for every rendered
    expression, which is something to keep an eye on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 或其他非图形化环境中使用时，`latexify()` 生成准备好可以复制并粘贴到文档中的 LaTeX 标记。我们也可以通过将结果传递给 `render()`
    函数，创建一个 PDF 图像。为了做到这一点，你需要安装外部程序 `LuaLaTeX`，它是标准 LaTeX 安装的一部分。如果该程序可用，`render()`
    会使用它来排版 LaTeX 字符串，并立即通过默认的 PDF 查看器显示它。`render()` 过程会在你的临时目录中留下每个渲染表达式的文件，这是需要注意的地方。
- en: When using `UnitfulLatexify` in a graphical environment, such as a Pluto notebook,
    the output is rendered as LaTeX rather than LaTeX source. In most environments,
    typesetting uses a built-in engine rather than an external program, so no additional
    installations are required. For example, Pluto uses MathJax, a JavaScript library
    for LaTeX mathematical typesetting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形化环境中使用 `UnitfulLatexify` 时，比如在 Pluto 笔记本中，输出会以 LaTeX 的形式进行渲染，而不是 LaTeX 源代码。在大多数环境中，排版使用的是内建引擎，而不是外部程序，因此不需要额外的安装。例如，Pluto
    使用 MathJax，这是一个用于 LaTeX 数学排版的 JavaScript 库。
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) shows a Pluto session with Newton’s Second
    Law of Motion.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch9fig1) 显示了一个包含牛顿第二定律的 Pluto 会话。'
- en: '![Image](../images/ch09fig01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig01.jpg)'
- en: '*Figure 9-1: Using* UnitfulLatexify *in Pluto*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：在* Pluto *中使用* UnitfulLatexify'
- en: In the final cell in [Figure 9-1](ch09.xhtml#ch9fig1), we convert the acceleration
    to a more conventional combination of units and pass the result to `latexify()`.
    The typeset version appears as the result. MathJax provides a contextual menu
    when right-clicking on the result that gives us access to the LaTeX source.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-1](ch09.xhtml#ch9fig1) 中的最后一个单元格，我们将加速度转换为更常见的单位组合，并将结果传递给 `latexify()`。排版版本作为结果出现。MathJax
    提供了一个上下文菜单，当右键单击结果时，可以访问 LaTeX 源代码。
- en: 'If the use of negative exponents in unit expressions is not to our taste, we
    can pass the `permode` keyword to tell `latexify()` to use other styles. Here’s
    an example that demonstrates the default and the two options for `permode`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不喜欢在单位表达式中使用负指数，我们可以传递 `permode` 关键字，告诉 `latexify()` 使用其他样式。以下是一个例子，展示了默认选项和
    `permode` 的两个选项：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The example uses the existing definition for `a`. The `:frac` option uses LaTeX
    fractions instead of negative exponents, and the `:slash` option uses a slash,
    which is usually better for inline math.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了现有的`a`定义。`:frac`选项使用LaTeX分数，而不是负指数，`:slash`选项使用斜杠，通常对于内联数学更为合适。
- en: 'Pasting the output in the previous listing into the LaTeX source of this book
    shows the rendered result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个列表中的输出粘贴到本书的LaTeX源代码中会显示渲染结果：
- en: a = 0.0571 m s^(−2)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: a = 0.0571 m s^(−2)
- en: or
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 0.0571 ![Image](../images/276math.jpg)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0571 ![图片](../images/276math.jpg)
- en: or
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 0.0571 m/s²
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0571 m/s²
- en: We can change the default mode for rendering units with the `set_default(permode=:slash)`
    command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`set_default(permode=:slash)`命令更改渲染单位的默认模式。
- en: '***Plotting with Units***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带单位的绘图***'
- en: '[Listing 9-3](ch09.xhtml#ch9lis3) shows how `Plots` knows how to handle `Unitful`
    quantities.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-3](ch09.xhtml#ch9lis3)展示了`Plots`如何处理`Unitful`量。'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-3: Plotting* Unitful *arrays*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：带单位的* Unitful *数组绘图*'
- en: Here we import `Plots`, which we need for plotting, and `Unitful`, to handle
    units. After defining a mass in kilograms and a range of velocities in meters
    per second, we create an array of kinetic energies, `KE`, from the fact that kinetic
    energy = 1/2 mass × velocity². The new package gives the plotting functions in
    `Plots` the ability to handle quantities with units and automatically appends
    the units to the axis labels. [Figure 9-2](ch09.xhtml#ch9fig2) shows the result
    of the `plot()` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`Plots`，这是我们绘图所需的库，以及`Unitful`，用来处理单位。在定义了质量（以千克为单位）和一系列速度（以米每秒为单位）之后，我们根据动能公式（动能
    = 1/2 质量 × 速度²）创建了一个动能数组`KE`。这个新包赋予`Plots`中的绘图函数处理带单位的量的能力，并自动将单位附加到轴标签上。[图 9-2](ch09.xhtml#ch9fig2)展示了`plot()`语句的结果。
- en: '![Image](../images/ch09fig02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig02.jpg)'
- en: '*Figure 9-2: The plot that [Listing 9-3](ch09.xhtml#ch9lis3) generates*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：* [列表 9-3](ch09.xhtml#ch9lis3) *生成的图表*'
- en: I’ve left the energy units alone for this example, but more conventional physics
    usage would involve a conversion to joules using `uconvert()`, which we could
    have done before the plotting call or inline within `plot()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个例子中没有更改能量单位，但更常见的物理学用法是使用`uconvert()`将其转换为焦耳，这可以在绘图调用之前或在`plot()`内部进行。
- en: We were able to create this graph with the same `plot()` call that we might
    have used to plot the same quantities stored in numerical arrays without units.
    All the plotting functions in `Plots`, such as `scatter()` and `surface()`, work
    with `Unitful` arrays to produce similar axis labels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用相同的`plot()`调用创建这个图表，正如我们可能用来绘制存储在没有单位的数值数组中的相同量。`Plots`中的所有绘图函数，如`scatter()`和`surface()`，都可以处理`Unitful`数组，并生成类似的轴标签。
- en: '***Making Plots for Publication***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为出版制作图表***'
- en: When attempting to make high-quality plots for publication, however, we encounter
    some shortcomings. While `Plots` aspires to create a unified interface to a variety
    of backends, each plotting engine works somewhat differently, with each having
    unique capabilities and limitations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在尝试制作高质量的出版图表时，我们会遇到一些不足之处。虽然`Plots`旨在为各种后端创建统一的接口，但每个绘图引擎的工作方式有所不同，每个引擎都有独特的功能和局限性。
- en: These differences among backends become more salient when we are making the
    final adjustments that accompany the preparation of graphs for publication. It
    is at this stage that, for example, the typographic details in labels and annotations
    become important. [Figure 9-2](ch09.xhtml#ch9fig2) was created using the `GR`
    backend, which, as mentioned in “Useful Backends” on [page 115](ch04.xhtml#ch04lev11),
    is the default at the time of writing, and is fast and capable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行最终调整以准备图表用于出版时，这些后端之间的差异变得更加明显。例如，标签和注释中的排版细节在这一阶段变得非常重要。[图 9-2](ch09.xhtml#ch9fig2)是使用`GR`后端创建的，正如在“有用的后端”部分所提到的[第115页](ch04.xhtml#ch04lev11)，该后端在写作时是默认后端，且快速且功能强大。
- en: '[Figure 9-2](ch09.xhtml#ch9fig2) may be acceptable as is, but for publication
    we may want to improve the appearance of its graph labels, especially to make
    the unit notations look like conventional mathematical notation. As we saw in
    “LaTeX Titles and Label Positioning by Data” on [page 103](ch04.xhtml#ch04lev1sec12),
    we can use LaTeX notation in graph annotations with mathematical content. This
    also works for the automatic labeling using units with the packages we’ve already
    imported:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-2](ch09.xhtml#ch9fig2)可能已经可以接受，但为了出版，我们可能需要改进其图表标签的外观，特别是让单位符号看起来像常规的数学符号。正如我们在“基于数据的
    LaTeX 标题和标签定位”一节中，在 [第103页](ch04.xhtml#ch04lev1sec12)看到的那样，我们可以在图表注释中使用带有数学内容的
    LaTeX 符号。这同样适用于我们已经导入的包中的单位自动标签：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The example repeats the plot command from [Listing 9-3](ch09.xhtml#ch9lis3),
    but with some alterations to create LaTeX strings for the plot labels. The `unitformat`
    keyword processes the unit annotations through `latexify()`, with the value `latexroundunitlabel`
    retaining the parentheses around the units. Since this triggers placing the entire
    label into a LaTeX string, we also need to wrap the non-math parts of the labels
    in LaTeX commands to set them as normal text instead of math.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例重复了 [清单 9-3](ch09.xhtml#ch9lis3) 中的绘图命令，但做了一些修改，创建了用于绘图标签的 LaTeX 字符串。`unitformat`
    关键字通过 `latexify()` 处理单位注释，值 `latexroundunitlabel` 保留了单位周围的括号。由于这会将整个标签放入 LaTeX
    字符串中，因此我们还需要将标签中的非数学部分用 LaTeX 命令包裹起来，以将它们设置为常规文本，而非数学公式。
- en: '**The GR Backend**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GR 后端**'
- en: The results of this approach depend critically on what backend we’re using.
    Obviously, it makes sense to use LaTeX strings only with backends that can do
    something with them. Although the default `GR` backend can interpret LaTeX, the
    results are not always adequate. This engine includes its own version of LaTeX
    processing, which often creates poor-quality typesetting with faulty kerning.
    The LaTeX engine in `GR` is the focus of some development activity, however, so
    its performance may improve.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的结果在很大程度上依赖于我们使用的后端。显然，只有在后端能够处理 LaTeX 字符串时，使用 LaTeX 字符串才有意义。尽管默认的 `GR`
    后端可以解释 LaTeX，但其结果并不总是令人满意。这个引擎包含了自己的 LaTeX 处理版本，通常会产生质量较差的排版，且字间距不准确。不过，`GR` 中的
    LaTeX 引擎目前正在开发中，因此其性能可能会有所提高。
- en: Good-quality typesetting of labels in most cases requires processing by an external
    TeX engine, which involves a TeX installation such as TeXLive. As many physicists
    and other scientists have already made such an installation, we’ll move on to
    considering options that take advantage of it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，标签的高质量排版需要通过外部 TeX 引擎处理，这通常涉及如 TeXLive 之类的 TeX 安装。由于许多物理学家和其他科学家已经安装了这样的
    TeX 系统，我们将继续考虑那些能够利用该安装的选项。
- en: '**The Gaston Backend**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Gaston 后端**'
- en: Gnuplot can optionally be compiled with support for the `tikz` terminal, which
    saves plots as text files containing TikZ commands. (TikZ is a graphics language
    that comes with most full-featured TeX installations.) Such files are processed
    with LaTeX and can contain TeX or LaTeX markup for the annotations on the plot.
    The result is of the highest quality, with fonts and styles that match the document
    in which the plot is included. Unfortunately, at the time of writing, the `Gaston`
    backend, which uses gnuplot, does not properly support the `tikz` terminal, so
    this option is off the table. It’s being worked on, however, and once we can use
    `Gaston` with `tikz`, it will be the best option for complex plots for publication
    or when the best typographic quality is desired.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gnuplot 可以选择性地编译支持 `tikz` 终端，这会将图形保存为包含 TikZ 命令的文本文件。（TikZ 是一种图形语言，通常包含在大多数完整的
    TeX 安装中。）这些文件通过 LaTeX 处理，并且可以包含 TeX 或 LaTeX 标记，用于图形上的注释。结果的质量非常高，字体和样式与图形所在的文档一致。不幸的是，在写作时，使用
    gnuplot 的 `Gaston` 后端并不完全支持 `tikz` 终端，因此这个选项目前不可用。不过，它正在被开发中，一旦我们能够将 `Gaston`
    与 `tikz` 一起使用，它将成为用于复杂图形出版或需要最佳排版质量时的最佳选择。
- en: '**The PGFPlotsX Backend**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**PGFPlotsX 后端**'
- en: Another backend that can make use of LaTeX strings is `PGFPlotsX`, which is
    invoked with the `pgfplotsx()` function. This backend creates plots by calling
    out to the LuaLaTeX TeX engine, which comes with most TeX installations, including
    TeXLive. Since LuaLaTeX does all the typesetting, the labels come out with TeX-level
    quality. This backend is, therefore, an excellent choice for publication-quality
    graphs. `Gaston` may still be the best future choice for complex plots because
    processing through LuaLaTeX can be far slower than through gnuplot if the plot
    contains a large number of elements, such as in a large scatterplot.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以利用 LaTeX 字符串的后端是 `PGFPlotsX`，它通过 `pgfplotsx()` 函数调用。该后端通过调用 LuaLaTeX TeX
    引擎来创建图形，而 LuaLaTeX 是大多数 TeX 安装包中都包含的，包括 TeXLive。由于 LuaLaTeX 负责排版，因此标签的质量达到 TeX
    级别。因此，这个后端是发布高质量图表的绝佳选择。如果图表包含大量元素（例如在大型散点图中），`Gaston` 可能仍然是未来处理复杂图形的最佳选择，因为通过
    LuaLaTeX 处理的速度可能比通过 gnuplot 要慢得多。
- en: '**Handling Units Manually**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**手动处理单位**'
- en: Unfortunately, `PGFPlotsX` does not work properly with `Unitful`, not taking
    TeX processing into account. This limitation provides the opportunity to demonstrate
    a different way of plotting `Unitful` quantities and labeling axes with units—one
    that affords us complete control over the details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`PGFPlotsX` 与 `Unitful` 兼容性不佳，没有考虑到 TeX 处理。这一限制提供了一个展示不同方式绘制 `Unitful`
    数量并用单位标签轴的机会——这种方法让我们完全控制细节。
- en: 'The following listing contains the definition of a function that accepts two
    `Unitful` arrays for plotting, along with keyword arguments for labels:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含了一个函数的定义，该函数接受两个 `Unitful` 数组进行绘图，并带有用于标签的关键字参数：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `ustrip()` and `unit()` functions (see [Listings 9-1](ch09.xhtml#ch9lis1)
    and [9-2](ch09.xhtml#ch9lis2)), this code separates the arrays from their associated
    units, plotting the numerical parts and using the unit parts to construct labels
    with the `LaTeXStrings` package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ustrip()` 和 `unit()` 函数（见[清单 9-1](ch09.xhtml#ch9lis1) 和 [9-2](ch09.xhtml#ch9lis2)），这段代码将数组与其关联的单位分离，绘制数值部分，并使用单位部分通过
    `LaTeXStrings` 包构建标签。
- en: In order to interpolate values into a `LaTeXStrings` string, we need to use
    the two characters `%$` rather than a simple `$` ➊. When extracting the units
    from the arrays, we require the units of the elements of the array, which is why
    `eltype()` appears in the label assignment. The function saves both the stand-alone
    PDF version of the graph and its TeX version ➋ for including in a LaTeX document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将值插入到 `LaTeXStrings` 字符串中，我们需要使用两个字符 `%$` 而不是简单的 `$` ➊。在从数组中提取单位时，我们需要数组元素的单位，这就是为什么在标签分配中出现了
    `eltype()` 的原因。该函数会保存图形的独立 PDF 版本以及其 TeX 版本 ➋，以便将其包含在 LaTeX 文档中。
- en: 'After selecting the desired backend, we call the function to create the *.pdf*
    and *.tex* files with the default names:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的后端后，我们调用该函数以默认名称创建 *.pdf* 和 *.tex* 文件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Figure 9-3](ch09.xhtml#ch9fig3) shows the result.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.xhtml#ch9fig3) 显示了结果。'
- en: '![Image](../images/ch09fig03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch09fig03.jpg)'
- en: '*Figure 9-3: A* PGFPlotsX *plot with typeset unit labels*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：A* PGFPlotsX *绘图与排版单位标签*'
- en: Typesetting by LuaTeX provides the excellent quality of the labels in [Figure
    9-3](ch09.xhtml#ch9fig3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: LuaTeX 排版提供了[图 9-3](ch09.xhtml#ch9fig3)中标签的优异质量。
- en: '**Error Propagation with Measurements**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测量中的误差传播**'
- en: In the previous section we explored a package that extended the concept of numbers
    to include physical units. Here we’ll meet `Measurements`, another package that
    defines a number-like object useful for calculations in physics or nearly any
    empirical science.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们探讨了一个扩展数字概念以包括物理单位的包。在这里，我们将遇到 `Measurements`，这是另一个定义类似数字对象的包，适用于物理学或几乎所有经验科学中的计算。
- en: The `Measurements` package allows us to attach uncertainties to numbers. The
    number in question must be convertible to a float, so we can attach uncertainties
    directly to `Float64` numbers, integers, and `Irrational` quantities. (We can
    also create complex numbers with uncertainties, if we really want to, by attaching
    errors to their real and imaginary parts.) The `Measurements` package defines
    a new data type, called `Measurement{T}`, where `T` can be any size float. We
    can perform any arithmetic operations on `Measurement` types that are allowed
    on floats, and the errors, or uncertainties, will be propagated to the result
    using standard linear error propagation theory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of creating instances of `Measurement` types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create `Measurement` objects using a notation that will be familiar to scientists.
    We can type the `±` operator by entering \pm in the REPL and pressing TAB or by
    using the operating system’s entry method for special characters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In the REPL, the `ans` variable holds the most recently returned result. Since
    `Measurement` objects have only one type parameter, the base number and the error
    must be of the same type. As the `typeof()` calls show, `Measurements` promotes
    the smaller type as needed; the `f0` suffix is a way to enter 32-bit float literals
    ➊.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The package treats significant digits intelligently:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The digits made insignificant by the error are not printed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'When printing results in the REPL, the package displays only two significant
    digits in the error, to keep things neat:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, it retains the full values internally for computations. We can access
    these components with the `value()` and `uncertainty()` functions shown here,
    which, as they are not exported, we need to qualify with the package namespace.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Scientists often use an alternative, convenient notation to express uncertainty
    by appending the error in the final significant digits within parentheses. The
    `Measurements` package understands this notation as well:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to use the notation, we need to employ the `measurement()` function
    and supply the argument as a string. We can also use `measurement()` as an alternative
    to the `±` operator:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Arithmetic operations propagate errors correctly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All these examples perform arithmetic as might be expected on the quantities
    and their errors. More interesting is the last example, where `Measurements` has
    recognized a ratio that has no error. The package maintains the notion of correlated
    and independent measurements, which is explained in its documentation. See “Further
    Reading” on [page 304](ch09.xhtml#fur9) for the URL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to the example in [Listing 9-3](ch09.xhtml#ch9lis3), we can
    add an uncertainty to the `Unitful` value for mass in two ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example shows that the packages `Measurements` and `Unitful` can work together
    to create quantities with both units and uncertainties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the example from [Listing 9-3](ch09.xhtml#ch9lis3) using
    this new value for `mass`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although, as before, `velocity` has no uncertainty attached to it, `mass` does;
    therefore, `KE` should also contain uncertainties.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the result.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Plotting with units and errors*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the `Unitful` arrays plotted as before
    with the axes labeled with their units. It also has error bars, showing how the
    error increases as the kinetic energy increases. We didn’t have to change anything
    in the call to `plot()`. Somehow the type of the quantities to be plotted triggered
    the plotting function to use both unit labels and error bars. We would observe
    the same behavior with the other plotting functions in `Plots`, such as `scatter()`
    or `surface()`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Fluid Dynamics with Oceananigans**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Oceananigans` package for fluid dynamics simulations is especially well
    suited, as the name suggests, to the physics of the ocean. It provides a simulation
    construction kit that can include the effects of temperature and salinity variations,
    Earth’s rotation, wind, and more. Its defaults usually perform well, but it’s
    flexible enough that the user can specify one of several available solution methods.
    It has various physics models built in, including a linear equation of state,
    but makes it easy to substitute others of the user’s devising.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '***The Physical System***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are setting out to simulate a two-dimensional layer of fluid in Earth’s gravitational
    field. The bottom of the layer is maintained at a higher temperature than the
    top. This heating from below creates a convective motion, as can be seen in clouds
    or in a pan on the stove.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Oceananigans *depends on some compiled binaries in the standard library. If
    the precompilation of* Oceananigans *fails and you’re using a recent or beta version
    of Julia, try it with an earlier Julia release (the previous major version number).*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The bottom and top simulation boundaries are impenetrable and freeslip, which
    means the fluid can slide across them. Horizontally, we impose a periodic boundary
    condition, requiring the solution to wrap around and be the same on the left and
    right boundaries. The horizontal direction is *x* and the vertical direction is
    *z*. We start the fluid at rest and are interested in the pattern of motion that
    the temperature difference creates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-5](ch09.xhtml#ch9fig5) shows the setup of the simulated system. The
    gray area represents the fluid, and the thick black horizontal lines indicate
    the constant-temperature boundaries.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig05.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: The simulation box*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `Luxor` program (see “Diagramming with Luxor” on [page 190](ch07.xhtml#ch07lev1))
    that created this diagram is available in the Physics section of the online supplement
    at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: A fluid dynamics simulation contains many pieces that we’ll need to construct
    separately before we can begin the calculation. In the following subsections,
    we’ll define the computational grid, the boundary conditions, the diffusivity
    models, and the equation of state, and establish the boundary conditions and the
    hydrodynamic model, in that order. After all the pieces are in place, we’ll run
    the `Oceananigans` simulation and visualize the results.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '***The Grid***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To put together an `Oceananigans` simulation, we’ll define its various components
    using functions exported by the package, and then define a model using the `model()`
    function, passing in the components as arguments. For this example we’ll use a
    `grid`, a `buoyancy` model that specifies the fluid’s equation of state, a set
    of boundary conditions, the coefficients of viscosity and thermal diffusivity
    (material properties of the fluid), and initial conditions on the temperature
    within the fluid. We won’t include the effects of Earth’s rotation, salinity,
    or wind, but these ingredients are available for use in other `Oceananigans` models.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid is defined by its computational `size` (how many grid points exist
    in each direction), its `extent` (the physical lengths represented by these directions),
    and its `topology`, which is the term `Oceananigans` uses for what boundary conditions
    hold in each direction. For our problem we define the grid this way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `RectilinearGrid()` function that `Oceananigans` provides constructs grids
    as one of many data types defined in the package. We assign the grid to our own
    variable, `grid`, for use later when creating the model. We could have chosen
    any name for this variable, but `grid` is the name of the relevant keyword argument
    accepted by the model construction function; using the same names for our own
    variables will keep everything neat.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In the `topology` keyword argument, we list the boundary conditions in the *x*,
    *y*, and *z* directions, with *z* pointing upward. The boundary condition `Flat`
    means that we’re not using (in this case) the *y* direction. This call defines
    a two-dimensional, *x*–*z* grid, with periodic boundaries in *x* and impenetrable
    boundaries in *z*. `Oceananigans` uses a kilogram-meter-second unit system. Because
    we set the `extent` to be equal to the `size`, the grid spacing is one unit in
    length along each dimension, giving us a fluid layer 256 meters wide and 32 meters
    tall.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As the example shows, `Oceananigans` has useful forms for representing its data
    types in the REPL, summarizing the salient information for our inspection. Here
    the output provides us with a summary of the grid parameters and boundary conditions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***The Boundary Conditions***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define any boundary conditions on physical variables as a separate component,
    which is also eventually passed into `model()`. We want to impose constant values
    of temperature on the top and bottom boundaries; `Oceananigans` sets this type
    of boundary condition with the `FieldBoundaryConditions()` function, as it sets
    boundary conditions on, in this case, the temperature field. We can use `Oceananigans`’s
    convenient definitions of `top` and `bottom`, which have their intuitive meaning
    (there are also `north`, `south`, `east`, and `west`, which we don’t need in this
    problem):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `immersed` boundary refers to one that exists inside the fluid volume, but
    we’re not using that one, nor any of the other myriad options, such as defined
    gradients or fluxes. The `ValueBoundaryCondition` that we use sets a constant
    value for a variable on the specified boundary.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '***The Diffusivities***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to assign values to two constants that describe some of the fluid’s
    material properties; this is part of the problem definition. The viscosity coefficient
    (*ν*) determines how “thick” the fluid is, and the thermal diffusivity (*κ*) determines
    how readily it conducts heat. These values are passed to the model in the `closure`
    keyword and can be set through the `ScalarDiffusivity()` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The symbol for viscosity is the Greek letter *nu* and that for thermal diffusivity
    is *kappa*. Like all Greek letters, we can precede their names with a backslash
    and then press TAB to enter them in the REPL.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***The Equation of State***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The equation of state is a function that describes how the density of the fluid
    at any point depends on the temperature and salinity there (the assumption of
    *incompressibility* usually used in `Oceananigans` models means that density has
    no dependence on pressure). Our model is salt free, but our fluid will be lighter
    when it’s hotter. This is what will cause the fluid to move, as the lighter parts
    will rise and the heavier parts will sink, driven by gravity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The `model()` function expects the keyword `buoyancy`, so we’ll use that too:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Oceananigans offers many other options, including the ability to define our
    own equation of state, but we’ll keep the model simple. The `SeawaterBuoyancy`
    component deals with buoyancy by combining gravity (with the default Earth value
    given here) with density variations. As we’re not interested in salinity effects
    for this calculation, we set `haline_contraction` to 0 (“haline” is essentially
    a synonym for saline used by oceanographers).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '***The Model and Initial Conditions***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have all the pieces set up, we can put them together into a *model*,
    the `Oceananigans` term for the definition of the computational problem, including
    all the physics along with the grid and the boundary conditions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The package prints a nice summary of the result, including a reminder of some
    (but not all) of the features we’re not using, such as the coriolis force from
    Earth’s rotation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The `NonhydrostaticModel()` function creates a model using the approximation
    appropriate to our problem. `Oceananigans` offers several other choices, including
    a hydrostatic model to simulate surface waves.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We use the abbreviated form of passing keyword arguments explained in “Concise
    Syntax for Keyword Arguments” on [page 154](ch06.xhtml#ch06lev1sec1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Our boundary condition `bc` doesn’t refer to any particular physical variable;
    it simply defines a constant field value on the boundaries. The named tuple assigned
    to `boundary_conditions` enforces them on `T`, the variable used in `Oceananigans`
    for the temperature.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The printed result refers to the CPU ➊, which means that this model is intended
    for “normal” machine architectures. The other option is to calculate on GPUs (graphics
    processing units). The `halo` refers to the several points outside the physical
    grid that the numerical algorithm uses to enforce the boundary conditions or other
    constraints.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword argument, `tracers`, tells the model to keep track of the
    temperature and salinity as those scalar fields are advected around the fluid.
    We’re required to include `:S` even though our equation of state means it will
    have no effect.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The fluid layer heated from below defined by our model is physically *unstable*,
    which means that a small perturbation to its initial, motionless state will be
    magnified and develop into a state with some form of persistent motion, driven
    by the temperature difference and the gravitational field. It is the development
    of the instability that we want to study. We need to add the small perturbation,
    or else, even though the system is unstable, it will never move.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set!()` function lets us create any desired initial condition on any of
    the fields. We’ll use it to add a small, random perturbation to the temperature
    field throughout the fluid volume:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The function is spelled with an exclamation point to remind us that it mutates
    its arguments: it alters the `T` field in place, and the model as well.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***The Simulation***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next we need to create a *simulation*, using the `Simulation()` function. This
    object will receive the model as its positional argument, along with keyword arguments
    for the timestep and when to stop the calculation. It will keep track of how much
    simulation time and wall-clock time has elapsed and the state of all the physical
    fields. This allows us to continue the simulation after the requested start time
    if we want, save the progress of the simulation in files, and retrieve the fields
    for examination and plotting.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a simple call, as `model` already contains all the details of the problem.
    We get a summary of various options for the simulation, most of which we didn’t
    use. If you want to use the *delta* for the time interval in the REPL, enter \Delta
    and press TAB.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Before running the simulation, let’s arrange for the velocity and temperature
    fields to be stored on disk at regular intervals so we can see its development
    over time (if we don’t do this, we’ll see only the final state of the simulation),
    as shown in [Listing 9-4](ch09.xhtml#ch9lis4).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 9-4: Setting up output writers*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding elements to the `output_writers` property of the `simulation` causes
    it to store the results periodically. The `JLD2OutputWriter` uses the `JLD2` file
    format, which is a compact way to store multiple Julia data structures in a single
    file. It’s a version of the `HDF5` format widely used in computational science.
    The `schedule` causes a data dump every 1 second, which, using our timestep, will
    be every 100 steps. The information in the result shows which quantities will
    be saved: `T` and `S` are the temperature and salinity.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we’re ready to run the calculation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The REPL will not have anything more to say until it reaches the final timestep,
    which in this case will take several hours on a typical personal computer. Then
    it will indicate that the calculation is complete and return to the interactive
    prompt. [Chapter 15](ch15.xhtml) explores ways to speed up such calculations by
    using parallel processing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When an `Oceananigans` simulation ends, the final state of the fields (the velocity
    components and the temperature, in this case) is available as properties of the
    `model`. [Listing 9-5](ch09.xhtml#ch9lis5) shows how to retrieve them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 9-5: Examining the results of a simulation*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The velocity and temperature fields are properties of the model. The `heatmap()`
    call will plot the two-dimensional temperature field, but first we need to turn
    it into an array with the `interior()` function. This function converts the `Oceananigans`
    field into a numerical array and trims away the `halo` points. Its arguments,
    following the field to convert, are the extents of the grid in each of the three
    directions; we enter a `1` to indicate an unused coordinate. In setting the `yrange`,
    we’ve accessed another property of the field, its grid shape. The prime after
    the array to plot transposes it so that it appears in its natural orientation,
    with a vertical gravity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We would normally run a simulation for just a few timesteps and examine the
    fields in this way before running a long calculation, to make sure we’ve set it
    up correctly. If we want to take another look after a few more timesteps, we can
    do this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These commands advance the simulation an additional 10 timesteps, after which
    we can repeat the steps in [Listing 9-5](ch09.xhtml#ch9lis5) to see how things
    are going.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Returning now to the quantities stored in files, as set up in [Listing 9-4](ch09.xhtml#ch9lis4),
    [Listing 9-6](ch09.xhtml#ch9lis6) shows how to retrieve the entire history of
    a field.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 9-6: Retrieving a field from the JLD2 file*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The summary of the result shows that the `FieldTimeSeries` has dimensions of
    256×1×32×1,030, which means that it’s defined on a 2D, 256×32 grid and evolves
    over 1,030 timesteps.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'After this call the entire history of the *x*-velocity field and its various
    properties are conveniently available. The data structure `uF` itself takes up
    almost no space:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `sizeof()` function returns the amount of storage, in bytes, occupied by
    its argument. The actual data occupies 256 × 32 × 1,030 × 8 = 67,502,080 bytes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We can plot the horizontal velocity field at any timestep:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’ve added some labeling to the version in [Listing 9-5](ch09.xhtml#ch9lis5),
    annotating the plot using properties read out from the field. Creating similar
    plots for timesteps 100 and 500, adding an `xlabel` to the last one, and putting
    them together with `plot(h50, h100, h500; layout=(3, 1))` creates the plot in
    [Figure 9-6](ch09.xhtml#ch9fig6).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig06.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: Results of an* Oceananigans *simulation*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The system evinces the regime called *turbulent convection*; it’s interesting
    to observe the emergence of large-scale order from randomness and its persistent
    coexistence with the turbulent flow.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In order to make an animation of the simulation, we need to generate plots at
    equally spaced time intervals and stitch them together into a video file. Our
    simulation used a constant timestep, so in this case, equal time intervals translates
    into equal numbers of timesteps. However, that won’t always be the case. `Oceananigans`
    has options for automatically adjusted timesteps, and we may perform a simulation
    in stages with differently sized Δ*t*. It’s convenient, therefore, to have a function
    that creates a plot given a *time*. Since a given time may not correspond to any
    particular stored field, but may fall between two consecutive data dumps, we’ll
    need a function that determines which stored field is closest to the time requested.
    The Julia program shown in [Listing 9-7](ch09.xhtml#ch9lis7) retrieves the simulation
    output and produces a movie of a specified duration.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 9-7: Creating an animation of an Oceananigans simulation*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The `heatmap_at_time()` function does what’s needed, creating a heatmap at the
    time closest to the time in its argument. In this function, `F` is a field retrieved
    with a call to `FieldTimeSeries()`, as in [Listing 9-6](ch09.xhtml#ch9lis6). It
    makes use of the `times` property of these objects, which is an array holding
    all the times at which the field has been saved. The index `i` holds the dump
    corresponding to the time closest to the supplied `time` ➊. When making an animation
    of a heatmap, we want to use the same mapping from values to colors in each frame,
    so our call to `heatmap()` uses the `clim` keyword ➋.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function in place we can create an animation using the `Reel` package
    introduced in “Animations with Reel” on [page 206](ch07.xhtml#ch07lev4). To work
    with that package, we need to define a function of time `t` and (an unused) `dt`
    that returns a plot corresponding to `t`: the `plotframe()` function. The three
    constants ➌ in the script set the palette limits based on the data and the desired
    total duration of the animation. The palette limits are scaled so that more details
    are visible near the beginning of the run, but we can adjust it based on the features
    of interest.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '*See the online supplement at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)
    *for the resulting animation, along with full-color versions of the figures.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The final call saves the animation as an MP4 file. Other options that will work
    with `Reel` are `gif` and `webm`. To create these file types, we merely need to
    use the appropriate file ending.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Solving Differential Equations with DifferentialEquations**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the 18th century, differential equations have been the language of physical
    science and engineering, and of the quantitative aspects of other sciences as
    well. Julia’s `DifferentialEquations` package is a massive, state-of-the-art facility
    for solving many types of differential equations using a multitude of methods.
    It incorporates recent research on the use of machine learning to apply the best
    line of attack for solving a given equation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces the use of `DifferentialEquations` by solving an example
    problem. Interested readers can delve into its detailed documentation for more
    information (see “Further Reading” on [page 304](ch09.xhtml#fur9)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Physics Problem and Its Differential Equation***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an example, let’s investigate the pendulum. [Figure 9-7](ch09.xhtml#ch9fig7)
    diagrams the problem and defines the string length (*L*) and the angle (*θ*).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig07.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: The pendulum system*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We measure *θ* counterclockwise from the vertical reference line, which is dotted
    in the diagram, and the gravitational acceleration points down.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '*The* Luxor *program that produced the diagram is available in the code section
    of the Physics chapter on the online supplement at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward analysis of the forces on the pendulum bob (the black circle
    in the diagram) and Newton’s Second Law leads to the differential equation
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/295math.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: which is derived in any introductory general physics text. Here *t* is time
    and *g* is the gravitational acceleration. The usual next step is to confine the
    problem to small angles (≲ 5^°), where sin(*θ*) ≈ *θ*, and solve the resulting
    differential equation for simple harmonic motion. We’re going to solve the “exact”
    pendulum equation numerically, using the `DifferentialEquations` package. We’ll
    be able to examine the solution for any initial *θ*, up to π radians.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The package works with systems of first-order equations, which means differential
    equations limited to first derivatives of the unknown function. To handle the
    pendulum equation, therefore, we first need to cast it into the form of two coupled
    first-order equations. This first step is also part of many analytic solution
    methods. We can proceed easily by defining a new variable:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/295math1.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Now we’re solving for two functions of time, the angle *θ*(*t*) and the angular
    velocity *ω*(*t*).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up the Problem***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in translating the mathematical problem into a form that `DifferentialEquations`
    can digest is to define a Julia function of four positional arguments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: du  An array for the derivatives of the solutions
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: u   An array for the solution functions
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: p   An array of parameters
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: t   The time
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-8](ch09.xhtml#ch9lis8) is the version for the pendulum problem.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 9-8: The Julia version of the pendulum equation*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This is a mutating function, as indicated by the exclamation point, because
    as the calculation progresses, the solution engine mutates the `u` and `du` arrays
    to hold the results. Here `L` and `g` are set through destructuring the array
    `p`, and θ and ω are read from the array `u`. The solver from `DifferentialEquations`
    will repeatedly call `pendulum!()` as it builds up the solution, passing in `p`,
    `t`, and the developing solution arrays themselves.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '***Solving the Equation System***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To calculate the solution, we first define the computational problem and then
    pass that problem to the `solve()` function. The components of the computational
    problem are the parameter array, the initial conditions, the time span over which
    we want the solution, and the function that defines the differential equations
    to be solved, in this example `pendulum!()`. Other options include such things
    as the numerical method to be employed, but in this simple example we’ll leave
    those options unspecified. The package generally does an excellent job of choosing
    the solution method best suited to the nature of the equations we present to it.
    [Listing 9-9](ch09.xhtml#ch9lis9) shows the problem set up and initiated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 9-9: Solving differential equations using* DifferentialEquations'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The only two functions in this section from the `DifferentialEquations` package
    are `ODEProblem()` and `solve()`. `ODEProblem()` takes four positional arguments:
    the function defining the equation system, an array of initial conditions, the
    time span, and the parameter array. We defined the function in [Listing 9-8](ch09.xhtml#ch9lis8)
    and we define the other three arguments here. Allowing the solver to pass the
    parameters as arguments makes it convenient to generate families of solutions
    with a range of parameters.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The result returned by `ODEProblem()` contains the complete solutions of all
    functions (in this example, two) bundled into a data type defined in the package.
    This data type is designed to make it easy to examine and plot the solutions,
    and it contains, in addition to the computed functions, information about the
    problem and the calculation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '***Examining the Solutions***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For small angles, the analytic solution to our pendulum problem is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/297math.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: where *θ*[0] is the initial angle. The initial conditions in [Listing 9-9](ch09.xhtml#ch9lis9)
    have the pendulum at rest with a starting angle of 5°, so the small angle approximation
    should be valid.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Since we know the analytic solution, we can check the numerical result against
    it. [Listing 9-10](ch09.xhtml#ch9lis10) shows how we can plot one against the
    other.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 9-10: Solving for the small angle case*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The first `plot()` call uses only one data argument, the solution itself, assigned
    to `sol5d` in [Listing 9-9](ch09.xhtml#ch9lis9). This is neither an array nor
    a function, yet `plot()` seems to know how to display it. The first keyword argument,
    `idxs`, requests that (in this case) the first function, *θ*, is plotted. `idxs`
    does not appear in the documentation for the `Plots` package, and in fact is not
    defined in that package. Thus, it has no effect unless we first import `DifferentialEquations`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The plot, shown in [Figure 9-8](ch09.xhtml#ch9fig8), gives us confidence that
    we’ve set up the problem correctly and that the numerical solution methods are
    working.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig08.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: Checking the small angle solution of the pendulum equation*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the solution as we did here does not simply plot the solution arrays.
    It also interpolates between calculated values in order to generate a smooth plot.
    In this case, the solution contains only 83 points, which, if plotted directly,
    would make a coarse graph.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the solution objects are not arrays, the package defines methods for
    indexing that make it convenient to extract the data. If we do want access to
    the uninterpolated solution data, we can get it by indexing. Here, `sol5d[1, :]`
    returns a `Vector` of the 83 points for the first variable, *θ*, and `sol5d[2,
    :]` for the second, *ω*. To get the times at which these values are defined, we
    use a property: `sol5d.t`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Using the solution objects as functions returns the result interpolated to the
    time passed as an argument. (We’re using time in this section, but in other problems
    the independent variable may be something else.) The `sol5d(1.3)` function call
    returns a `Vector` of two elements, one for each variable, interpolated to the
    time 1.3\. These functions accept ranges and arrays as well, so `sol5d(0:0.1:1)`
    returns the interpolated solution data at 11 times from 0 to 1\. To extract just
    the angle variable at these times, we can call `sol5d(0:0.1:1)[1, :]`. Controlling
    the density of the interpolation by using the functional form of the solution
    objects can be helpful when making, for example, scatterplots, where we need to
    control the density of plotted points.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: How does the solution depend on the initial angle? Redefining `u0` to try two
    larger initial angles, and proceeding as in [Listing 9-10](ch09.xhtml#ch9lis10)
    to generate two new solutions, we get the results shown in [Figure 9-9](ch09.xhtml#ch9fig9).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig09.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: The pendulum with larger initial angles*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The 90° solution, with the pendulum string initially horizontal, appears approximately
    sinusoidal, but with the frequency around 25 percent lower than the small angle
    case. When the initial angle is 175°, the period is nearly three times the small
    angle period, and the solution is clearly far from sinusoidal. In generating [Figure
    9-9](ch09.xhtml#ch9fig9), we limit the range of the independent variable by passing
    another `DifferentialEquations`-defined keyword to `plot()`: `tspan=(0, 10)`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining Time-Dependent Parameters***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By replacing one or more of the constant parameters in the `p` array with functions
    of time, we can study the system’s response to time-dependent parameters. In this
    way we can include inhomogeneous terms in the differential equations, forcing
    functions, and time-varying parameters in general.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find out what happens if we pull up on the string steadily as the pendulum
    oscillates. We’ll start at 45° and calculate the solution over 10 seconds, replacing
    the constant `L` by a linearly decreasing function of time:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to create a slightly different version of our `pendulum()` function,
    shown in [Listing 9-11](ch09.xhtml#ch9lis11), that can use the time-dependent
    string length.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 9-11: The pendulum function with a time-dependent* L'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The only change we made to the previous function is replacing `L` with `L(t)`
    ➊. We proceed just as before. The `ODEProblem()` function needs a new parameter
    array, shown in [Listing 9-12](ch09.xhtml#ch9lis12), to pass in to `pendulum2()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 9-12: Getting the numerical solution with a time-varying* L'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The ease of generalizing the problem to include a time-varying parameter clarifies
    the advantages of the parameter-passing approach in `Differential` `Equations`.
    The result, in [Figure 9-10](ch09.xhtml#ch9fig10), shows a steadily decreasing
    period and amplitude with an increasing angular velocity (*ω*).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig10.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Pulling up the string on the pendulum*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We create [Figure 9-10](ch09.xhtml#ch9fig10) with the following calls:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the call to `plot!()`, the first argument, `twinx()`, creates a subplot overlay
    that shares the horizontal axis with the first plot and draws a new vertical axis;
    we use it so the two curves don’t have to share the same scale. We need some extra
    room on the right ➊ for the labels on the second vertical axis. This margin setting
    requires the import of `Plots.PlotMeasures`, as explained in “Working with Plot
    Settings” on [page 101](ch04.xhtml#ch04lev7).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '***Parametric Instability***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A child “pumping” a swing in the playground to get it moving is exploiting a
    *parametric instability*. The driver of this instability is the periodic change
    in the effective length of the pendulum string. The results of linear theory (the
    small angle version of the differential equation that we’re attacking in this
    section) tell us that a resonance occurs when the forcing frequency is twice the
    natural frequency of the pendulum, which, using our *L* = 1, is ![Image](../images/300math.jpg).
    If the string length is perturbed sinusoidally at this frequency, the amplitude
    of small oscillations will increase exponentially.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know how to insert any time-dependent function *L*(*t*) into the numerical
    solution, we can investigate the response of the pendulum to parametric excitation
    beyond the small angle approximation. We’ll start with a small initial angle,
    follow the evolution for a longer span, and define a new function of time for
    the string length:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Lt(t)` will perturb the nominal length of 1 meter by 10 percent at the frequency
    of parametric resonance.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Our work proceeds exactly as before, with one adjustment. We use `pendulum2()`,
    defined in [Listing 9-11](ch09.xhtml#ch9lis11), and set up the problem as in [Listing
    9-12](ch09.xhtml#ch9lis12). The adjustment is that we need to supply a keyword
    argument to the solving function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `reltol` parameter adjusts the adaptive timestepping as needed to limit
    the local error to the value that we supply. Its default of 0.001 led to a solution
    that seemed suspicious, as it was not quite periodic. I generated solutions with
    `reltol` = 1e–4, 1e–5, and 1e–6\. The 1e–4 solution looked reasonable, but the
    1e–5 solution was slightly different. As the solution with `reltol` = 1e–6 looked
    identical to the one at 1e–5, they’re probably accurate. [Figure 9-11](ch09.xhtml#ch9fig11)
    shows the resulting graph of *θ* versus time.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig11.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: Parametric instability of the finite-angle pendulum*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the amplitude increases exponentially, as predicted by the linear
    theory. But we know from our previous solutions that the frequency of the pendulum
    decreases with amplitude; therefore, it moves continuously out of resonance with
    the forcing function, and the amplitude decreases back to close to its initial
    value. At that point it’s closer to resonance, and the amplitude again grows exponentially.
    As the solution shows, the process repeats.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '***Combining DifferentialEquations with Measurements***'
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we want to verify the predictions of our pendulum solutions with an
    experiment. There will be some error inherent in the setting of the initial angle.
    If we estimate that uncertainty to be one degree, we might think to state the
    initial conditions this way (see “Error Propagation with Measurements” on [page
    280](ch09.xhtml#ch09lev2)):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function `deg2rad()` converts from degrees to radians.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We can proceed exactly as before, repeating the procedure shown in [Listings
    9-8](ch09.xhtml#ch9lis8) and [9-9](ch09.xhtml#ch9lis9). A plot of the solution
    for *θ*(*t*) now looks like [Figure 9-12](ch09.xhtml#ch9fig12).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch09fig12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-12: Combining* DifferentialEquations *with* Measurements'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Although we don’t tell the `plot()` function anything about drawing error bars,
    they appear in the plot. The plot shows how the error in the angular position
    grows, on average, over time. The error doesn’t grow monotonically, however. It
    decreases when the exact solution and those at the limits of the error bound happen
    to be in phase.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate the solution and plot it in [Figure 9-12](ch09.xhtml#ch9fig12)
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since `DifferentialEquations` places an error on every point of the solution,
    including the points interpolated when creating a plot, we have to use the technique
    described in “Examining the Solutions” on [page 297](ch09.xhtml#ch09lev1sec17)
    to limit the number of points plotted; otherwise, the plot becomes too crowded
    with error bars and is impossible to interpret.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we delved into several physics packages at some length in this chapter,
    we really only scratched their surfaces. I hope, however, that the introductions
    here are sufficient to help you assess whether any of the packages explored in
    this chapter might be a good choice for your projects and to show you how to get
    started.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Another purpose of this chapter is to serve as an introduction to a superpower
    of Julia and the Julia ecosystem. In several examples we were able to combine
    the abilities of two or three packages without making any particular arrangements
    to do so. We made plots and typeset expressions that contained units, and saw
    that they were handled sensibly. We handed the output of a differential equation
    solver to a plotting function from a different package, and it extracted the relevant
    data and plotted it. We solved differential equations with error estimates in
    their initial conditions, and the error was propagated through the solution correctly.
    We plotted *this* result, and, as if by magic, the solution displayed error bars.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We wrote scripts and programs that combined the abilities of five packages in
    various combinations, giving them capabilities neither envisioned nor planned
    by their authors. Most of these packages were written without any knowledge of
    the others that we combined them with. The authors of these packages wrote their
    code in a generic way that allows Julia’s type system and its method of multiple
    dispatch to enable its functions to work with data types defined in other packages.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia initially attracted attention as a language that was as easy to pick
    up and be productive in as a high-level interpreted language, but one that was
    fast enough for the most demanding scientific work: “as easy as Python and as
    fast as Fortran.” The second reason for Julia’s increasing adoption in the sciences
    is its ability to combine the abilities of disparate packages with no additional
    work on the part of the application programmer. Julia creators and package authors
    refer to this property as the *composability* of packages, in analogy with the
    composition of functions.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub community “Julia’s Physics Ecosystem” ([*https://juliaphysics.github.io/latest/ecosystem/*](https://juliaphysics.github.io/latest/ecosystem/))
    maintains a convenient list of packages related to all areas of physics, and includes
    related packages for mathematics and plotting.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Unitful` package is available at [*https://github.com/PainterQubits/Unitful.jl*](https://github.com/PainterQubits/Unitful.jl).
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [*https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/*](https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/)
    for details on how a mixup in units destroyed the Mars Climate Orbiter.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for `UnitfulLatexify` is at [*https://gustaphe.github.io/UnitfulLatexify.jl/dev/*](https://gustaphe.github.io/UnitfulLatexify.jl/dev/).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Measurements` package resides at [*https://github.com/JuliaPhysics/Measurements.jl*](https://github.com/JuliaPhysics/Measurements.jl).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started with `Oceananigans`, see [*https://clima.github.io/OceananigansDocumentation/stable/quick_start/*](https://clima.github.io/OceananigansDocumentation/stable/quick_start/).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DifferentialEquations.jl` documentation is available at [*https://diffeq.sciml.ai/stable/*](https://diffeq.sciml.ai/stable/).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations, color images, and supplementary code for this chapter are available
    at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find simple examples of the use of `DifferentialEquations.jl` at [*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)
    and [*https://lwn.net/Articles/834571/*](https://lwn.net/Articles/834571/).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parametric instability of a pendulum is demonstrated in the video at [*https://www.youtube.com/watch?v=dGE_LQXy6c0*](https://www.youtube.com/watch?v=dGE_LQXy6c0).
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The theory of parametric resonance for the general harmonic oscillator is treated
    at [*https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf*](https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
