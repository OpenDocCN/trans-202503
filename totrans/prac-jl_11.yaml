- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9  '
- en: PHYSICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学**
- en: '*Physics is not a religion. If it were, we’d have a much easier time raising
    money.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*物理学不是宗教。如果它是宗教，我们就更容易筹集资金了。*'
- en: —Leon M. Lederman
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —利昂·M·莱德曼
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Julia is a superb platform for physics calculations of all kinds. Various features
    of its syntax, such as the ability to use mathematical symbols and its concise
    array operations, make it a natural fit for programming algorithms that we use
    in physics. Julia’s speed of execution makes it one of only a few languages used
    for the most demanding large-scale simulations (and the others in this club are
    all lower-level, statically compiled languages). Julia’s physics ecosystem includes
    some state-of-the-art packages. Finally, Julia’s unique ability to mix and match
    functions and data types from disparate packages to create new capabilities is
    especially powerful in physics calculations, as we’ll see in detail in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是进行各种物理计算的出色平台。它的语法特性，例如使用数学符号的能力和简洁的数组操作，使其成为编程物理算法的自然选择。Julia的执行速度使其成为仅有的几种用于最具挑战性的大规模模拟的语言之一（其他的都是低级的、静态编译的语言）。Julia的物理生态系统包括一些最先进的软件包。最后，Julia独特的能力是将来自不同软件包的函数和数据类型混合搭配，创造出新的功能，这在物理计算中尤其强大，正如我们将在本章中详细看到的。
- en: We begin with an introduction to two packages of general utility for dealing
    with units and errors. Both of these are potentially helpful in any physics project.
    We’ll spend some time in the first section looking into various options for producing
    publication-quality plots including typeset units in axis labels. Then we’ll turn
    to specific calculations, first using a package for fluid dynamics and then using
    a general-purpose differential equation solver. See “Further Reading” on [page
    304](ch09.xhtml#fur9) for each major package’s URL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍两个通用软件包开始，这些软件包用于处理单位和误差。这两个软件包在任何物理项目中都可能是有用的。在第一部分，我们将花一些时间研究如何生成包含轴标签中的排版单位的出版质量图表的各种选项。然后我们将转向具体的计算，首先使用一个流体动力学软件包，然后使用一个通用的微分方程求解器。有关每个主要软件包的URL，请参见[第304页](ch09.xhtml#fur9)中的“进一步阅读”。
- en: '**Bringing Physical Units into the Computer with Unitful**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过Unitful将物理单位引入计算机**'
- en: The traditional way to perform physics calculations on a computer is to represent
    physical quantities as floating-point numbers, subject those numbers to a long
    series of arithmetic operations, and then interpret the results again as physical
    quantities. Since physical quantities are usually not simply numbers, but have
    *dimensions*, we need to manually keep track of the *units* that are associated
    with these quantities, often with code comments to remind us what the various
    units are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上执行物理计算的传统方法是将物理量表示为浮点数，对这些数字进行一系列算术运算，然后再将结果解释为物理量。由于物理量通常不仅仅是数字，而是具有*维度*的，我们需要手动跟踪与这些量相关联的*单位*，通常通过代码注释来提醒我们这些单位是什么。
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A* dimension *is a fundamental physical idea encompassing something that can
    be measured, such as mass or time. A* unit *is a specific way of measuring a dimension.
    The dimensions are universal, but there are various systems of units. For example,
    for the dimension of length, some common units are centimeter (cm), meter (m),
    or, if we live in the United States, inches or football fields.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*维度*是一个基本的物理概念，涵盖了可以被测量的东西，比如质量或时间。*单位*是衡量一个维度的具体方式。维度是普遍存在的，但有不同的单位系统。例如，对于长度维度，一些常见的单位是厘米（cm）、米（m），或者如果我们生活在美国，可能是英寸或美式足球场。'
- en: In other words, the physical meanings of the numbers appearing in a program
    are not part of the quantities themselves, but are implicit. It may not be surprising
    that this can lead to confusion and errors. In 1999, NASA lost a spacecraft because
    two different contractors were contributing to the design, and their engineering
    programs used different systems of units.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，程序中出现的数字的物理意义并不是这些量本身的一部分，而是隐含的。这可能并不令人惊讶，因为这可能导致混淆和错误。1999年，NASA因为两个不同的承包商分别参与设计，并且他们的工程程序使用了不同的单位系统，导致失去了一个航天器。
- en: In traditional languages for physics, such as Fortran, not much can be done
    about this issue directly. In Julia, because of its sophisticated type system,
    we are not limited to collections of dimensionless numbers; we can calculate with
    richer objects including units.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的物理学语言中，如 Fortran，通常无法直接解决这个问题。但在 Julia 中，由于其先进的类型系统，我们不局限于无量纲数值的集合；我们可以与包含单位的更丰富的对象进行计算。
- en: 'After importing the `Unitful` package, we can refer to many common physics
    units using a nonstandard string literal (see “Nonstandard String Literals” on
    [page 128](ch05.xhtml#ch05lev4)) with the prefix `u`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `Unitful` 包后，我们可以使用非标准字符串文字（见 [第128页](ch05.xhtml#ch05lev4) 中的“非标准字符串文字”）并以
    `u` 前缀引用许多常见的物理单位：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we add a meter and a centimeter, and receive the result as a rational number
    of meters. The package returns results as rational numbers, when possible, to
    preserve the ability to carry out exact conversions. But, as the second example
    shows, we can coerce a floating-point result by supplying a floating-point coefficient.
    The third example shows how we can construct expressions within the string literal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将米和厘米相加，得到的结果是一个表示米数的有理数。该包在可能的情况下返回有理数结果，以保持执行精确转换的能力。但是，正如第二个例子所示，我们可以通过提供浮点系数来强制转换为浮点结果。第三个例子展示了我们如何在字符串文字中构造表达式。
- en: 'You can find the complete list of units only in the source code, in its GitHub
    repository at *src/pkgdefaults.jl*, but most of them follow the usual physics
    conventions. Using the string literal syntax each time we want to refer to a unit
    can be cumbersome, so we can assign units to our own variables to ease our typing
    and make the code easier to read:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中的 GitHub 仓库的 *src/pkgdefaults.jl* 文件中找到完整的单位列表，但大多数单位遵循常见的物理学约定。每次引用单位时使用字符串文字语法可能会显得繁琐，因此我们可以将单位分配给自己的变量，以便减少输入并使代码更易读：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We add a meter to a kilometer, showing how we can use custom variables in combination
    with the string literals. The result is 1,001 meters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一米加到一公里，展示了如何将自定义变量与字符串文字结合使用。结果是 1,001 米。
- en: 'We can parse a string as a `Unitful` expression with another function provided
    by the package (undocumented at the time of writing):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包提供的另一个函数将字符串解析为 `Unitful` 表达式（在写作时没有文档）：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we use `uparse()` to convert a string, created by concatenating a string
    representing a mass with another representing the gravitational acceleration near
    the surface of Earth, into a unit expression representing the mass’s weight. The
    forms in which unit expressions appear in the REPL are not themselves legal strings
    for converting with `uconvert()`. For example, we need to include the multiplication
    operator in the string in the second line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `uparse()` 将一个由表示质量的字符串和另一个表示地球表面重力加速度的字符串连接起来，转换为一个表示质量重量的单位表达式。单位表达式在
    REPL 中的形式本身不是可以通过 `uconvert()` 转换的合法字符串。例如，我们需要在第二行的字符串中包含乘法运算符。
- en: '***Using Unitful Types***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Unitful 类型***'
- en: 'We can gain access to a large supply of standard SI units by importing the
    `DefaultSymbols` submodule rather than defining them one by one. This practice
    adds a profusion of names to our namespace, however, so it may not be a good idea
    if we’re using only a few units:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导入 `DefaultSymbols` 子模块来访问大量标准 SI 单位，而不是一个个地定义它们。然而，这种做法会将大量名称添加到我们的命名空间中，因此如果我们只使用少数单位，可能不是一个好主意：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we add 2 seconds to 1 minute, resulting in 62 seconds. The `DefaultSymbols`
    submodule supplies the `s` unit, but we need to define `minute`, as that’s not
    an SI unit. We’re using Julia’s syntax for multiplication through juxtaposition;
    this expression is the same as `2 * s + 1minute`. However, these variables must
    be attached to numerical coefficients in arithmetic expressions; `2 * s + minute`
    is a `MethodError`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将 2 秒加到 1 分钟，结果是 62 秒。`DefaultSymbols` 子模块提供了 `s` 单位，但我们需要定义 `minute`，因为它不是
    SI 单位。我们通过并列的方式使用 Julia 的乘法语法；这个表达式与 `2 * s + 1minute` 是相同的。然而，这些变量必须附加到算术表达式中的数值系数上；`2
    * s + minute` 会导致 `MethodError`。
- en: 'We can find the reason for this error in the types of the two expressions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这两个表达式的类型找到该错误的原因：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type of `1minute`, which is the same as the type of `1 * minute`, is a `Quantity`,
    while the type of `minute` is a `FreeUnits`. Both of these types are defined in
    the package. The `Unitful` package defines methods for addition and other arithmetic
    operations that accept arguments of type `Quantity`, but not of type `FreeUnits`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`1minute`的类型（与`1 * minute`的类型相同）是`Quantity`，而`minute`的类型是`FreeUnits`。这两种类型都在包中定义。`Unitful`包定义了接受`Quantity`类型参数的加法和其他算术运算方法，但不接受`FreeUnits`类型的参数。'
- en: These types contain parameters appearing as boldface Unicode characters. The
    `Unitful` package uses these characters to represent dimensions, so these type
    specifications tell us that the `minute` unit has dimensions of time, represented
    by `**T**`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型包含作为粗体Unicode字符出现的参数。`Unitful`包使用这些字符来表示维度，因此这些类型规范告诉我们，`minute`单位具有时间维度，用`**T**`表示。
- en: The type of `minute` and other units is an abstract type (see “The Type Hierarchy”
    on [page 222](ch08.xhtml#ch08lev1sec4)), while the types of quantified units such
    as `1minute` are concrete. For good performance, we should calculate with concrete
    types and define our own types with fields that have concrete types only.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`minute`类型和其他单位是抽象类型（见[第222页](ch08.xhtml#ch08lev1sec4)的“类型层次结构”），而诸如`1minute`这样的量化单位类型是具体类型。为了获得更好的性能，我们应该使用具体类型进行计算，并定义只包含具体类型字段的自定义类型。'
- en: '***Stripping and Converting Units***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***剥离和转换单位***'
- en: 'Sometimes we need to remove the units from the result of a calculation—for
    example, when passing a result to a function that doesn’t understand units. We
    can do this with the `convert()` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要从计算结果中去除单位——例如，当将结果传递给一个无法理解单位的函数时。我们可以通过`convert()`函数来做到这一点：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The type of the result is `Float64`. The results returned by `Unitful` calculations
    may not always be what we expect, so we should use `convert()` when we require
    a simple number:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的类型是`Float64`。`Unitful`计算返回的结果可能并不总是我们预期的，因此当我们需要一个简单数字时，应使用`convert()`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we divide a length by another length, so the result should be the simple
    number 1.0 (because the lengths are equal) with no dimensions. The actual result
    is equivalent to that, but it’s expressed in an obscure form. Checking the type
    of the result, we find that it’s the concrete `Unitful` type `Quantity`, with
    type parameters indicating that it has no dimensions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将一个长度除以另一个长度，因此结果应该是简单的数字1.0（因为长度相等），且没有维度。实际结果等同于此，但它以一个模糊的形式表达。检查结果的类型，我们发现它是具体的`Unitful`类型`Quantity`，其类型参数表示它没有维度。
- en: 'If we use the same literal unit in the numerator and denominator, we get a
    result that may be closer to what we expect:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在分子和分母中使用相同的字面单位，我们会得到一个更接近我们预期的结果：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A further example shows that `Unitful` is consistent in retaining the units
    we use in expressions instead of making conversions that might seem obvious to
    a physicist:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的例子表明，`Unitful`在保留我们在表达式中使用的单位时是一致的，而不是进行物理学家可能认为显而易见的转换：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two input expressions mean the same thing, but lead to equivalent results
    that are expressed differently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个输入表达式意味着相同的事情，但会产生以不同方式表达的等效结果。
- en: 'The function `upreferred()` from `Unitful` converts expressions so they use
    a standard set of units. The user can establish preferred systems of units, but
    the default behavior uses conventional SI units:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unitful`中的`upreferred()`函数将表达式转换为使用标准单位集的形式。用户可以建立首选的单位系统，但默认行为是使用常规的SI单位：'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to converting to a number with `convert()`, we can use `uconvert()`,
    which is part of `Unitful`, to convert between units:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`convert()`转换为数字外，我们还可以使用`Unitful`中的`uconvert()`来进行单位之间的转换：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function takes the unit to convert to in its first argument and the expression
    to convert in its second argument. In the first example we convert from ergs to
    joules. As both are metric units related by an exact ratio, `uconvert()` supplies
    the answer using a rational coefficient. The second example is a conversion from
    the US unit of mass, slugs, to kilograms, the standard SI unit used in physics.
    The conversion factor is a floating-point number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个参数是要转换到的单位，第二个参数是要转换的表达式。在第一个示例中，我们将能量从ergs转换为joules。由于这两者是由精确比例关系相关的公制单位，`uconvert()`使用有理数系数提供答案。第二个示例是将美国的质量单位slug转换为千克，后者是物理学中使用的标准SI单位。转换因子是一个浮动的浮点数。
- en: '[Listing 9-1](ch09.xhtml#ch9lis1) shows another way to extract the purely numerical
    part of a `Unitful` expression with `ustrip()`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-1](ch09.xhtml#ch9lis1) 展示了另一种方法，通过 `ustrip()` 提取 `Unitful` 表达式中的纯数字部分。'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-1: Stripping units with* ustrip()'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：使用* ustrip() *去除单位*'
- en: The `ustrip()` function preserves the numerical type in the expression.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ustrip()` 函数在表达式中保留数值类型。'
- en: To extract just the unit from a `Unitful` expression, the package provides the
    `unit()` function, as shown in [Listing 9-2](ch09.xhtml#ch9lis2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `Unitful` 表达式中提取单位，包提供了 `unit()` 函数，如 [列表 9-2](ch09.xhtml#ch9lis2) 所示。
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-2: Extracting units with* unit()'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：使用* unit() *提取单位*'
- en: We’ll find applications for `ustrip()` and `unit()` in “Plotting with Units”
    on [page 276](ch09.xhtml#ch09lev1sec4).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“带单位的绘图”部分的 [第 276 页](ch09.xhtml#ch09lev1sec4) 中找到 `ustrip()` 和 `unit()`
    的应用。
- en: '***Typesetting Units***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***排版单位***'
- en: 'Using the `UnitfulLatexify` package, we can turn our `Unitful` expressions
    into LaTeX-typeset mathematics: either as LaTeX source ready to be dropped into
    a research paper or as a rendered image. Here is a simple example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UnitfulLatexify` 包，我们可以将 `Unitful` 表达式转化为 LaTeX 排版的数学公式：可以是可以直接放入研究论文中的
    LaTeX 源代码，也可以是渲染后的图像。以下是一个简单的例子：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `latexify()` function transforms the `Unitful` expression for Earth’s gravitational
    acceleration into a LaTeX string. We encountered La TeXstrings in [Listing 4-1](ch04.xhtml#ch4lis1),
    when we used one to generate a title for a graph. The `UnitfulLatexify` package
    combines the LaTeX abilities in `Latexify` with `Unitful`, which is why we need
    to import all three packages, as we did at the start of this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`latexify()` 函数将地球重力加速度的 `Unitful` 表达式转换为 LaTeX 字符串。我们在 [列表 4-1](ch04.xhtml#ch4lis1)
    中遇到过 LaTeX 字符串，当时我们用它来为图表生成标题。`UnitfulLatexify` 包结合了 `Latexify` 中的 LaTeX 能力与 `Unitful`，这就是为什么我们需要导入这三个包，就像在本示例开始时那样。'
- en: When used in the REPL or another nongraphical context, `latexify()` produces
    LaTeX markup ready to be copied and pasted into a document. We can, instead, create
    a PDF image of the result by passing it to the `render()` function. To do that,
    you need to have the external program `LuaLaTeX`, which is part of standard LaTeX
    installations, installed. If that program is available, `render()` will use it
    to typeset the LaTeX string and immediately display it with the default PDF viewer.
    The `render()` process litters your temporary directory with files for every rendered
    expression, which is something to keep an eye on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 或其他非图形化环境中使用时，`latexify()` 生成准备好可以复制并粘贴到文档中的 LaTeX 标记。我们也可以通过将结果传递给 `render()`
    函数，创建一个 PDF 图像。为了做到这一点，你需要安装外部程序 `LuaLaTeX`，它是标准 LaTeX 安装的一部分。如果该程序可用，`render()`
    会使用它来排版 LaTeX 字符串，并立即通过默认的 PDF 查看器显示它。`render()` 过程会在你的临时目录中留下每个渲染表达式的文件，这是需要注意的地方。
- en: When using `UnitfulLatexify` in a graphical environment, such as a Pluto notebook,
    the output is rendered as LaTeX rather than LaTeX source. In most environments,
    typesetting uses a built-in engine rather than an external program, so no additional
    installations are required. For example, Pluto uses MathJax, a JavaScript library
    for LaTeX mathematical typesetting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形化环境中使用 `UnitfulLatexify` 时，比如在 Pluto 笔记本中，输出会以 LaTeX 的形式进行渲染，而不是 LaTeX 源代码。在大多数环境中，排版使用的是内建引擎，而不是外部程序，因此不需要额外的安装。例如，Pluto
    使用 MathJax，这是一个用于 LaTeX 数学排版的 JavaScript 库。
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) shows a Pluto session with Newton’s Second
    Law of Motion.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch9fig1) 显示了一个包含牛顿第二定律的 Pluto 会话。'
- en: '![Image](../images/ch09fig01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig01.jpg)'
- en: '*Figure 9-1: Using* UnitfulLatexify *in Pluto*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：在* Pluto *中使用* UnitfulLatexify'
- en: In the final cell in [Figure 9-1](ch09.xhtml#ch9fig1), we convert the acceleration
    to a more conventional combination of units and pass the result to `latexify()`.
    The typeset version appears as the result. MathJax provides a contextual menu
    when right-clicking on the result that gives us access to the LaTeX source.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-1](ch09.xhtml#ch9fig1) 中的最后一个单元格，我们将加速度转换为更常见的单位组合，并将结果传递给 `latexify()`。排版版本作为结果出现。MathJax
    提供了一个上下文菜单，当右键单击结果时，可以访问 LaTeX 源代码。
- en: 'If the use of negative exponents in unit expressions is not to our taste, we
    can pass the `permode` keyword to tell `latexify()` to use other styles. Here’s
    an example that demonstrates the default and the two options for `permode`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不喜欢在单位表达式中使用负指数，我们可以传递 `permode` 关键字，告诉 `latexify()` 使用其他样式。以下是一个例子，展示了默认选项和
    `permode` 的两个选项：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The example uses the existing definition for `a`. The `:frac` option uses LaTeX
    fractions instead of negative exponents, and the `:slash` option uses a slash,
    which is usually better for inline math.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了现有的`a`定义。`:frac`选项使用LaTeX分数，而不是负指数，`:slash`选项使用斜杠，通常对于内联数学更为合适。
- en: 'Pasting the output in the previous listing into the LaTeX source of this book
    shows the rendered result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个列表中的输出粘贴到本书的LaTeX源代码中会显示渲染结果：
- en: a = 0.0571 m s^(−2)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: a = 0.0571 m s^(−2)
- en: or
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 0.0571 ![Image](../images/276math.jpg)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0571 ![图片](../images/276math.jpg)
- en: or
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 0.0571 m/s²
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0571 m/s²
- en: We can change the default mode for rendering units with the `set_default(permode=:slash)`
    command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`set_default(permode=:slash)`命令更改渲染单位的默认模式。
- en: '***Plotting with Units***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带单位的绘图***'
- en: '[Listing 9-3](ch09.xhtml#ch9lis3) shows how `Plots` knows how to handle `Unitful`
    quantities.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-3](ch09.xhtml#ch9lis3)展示了`Plots`如何处理`Unitful`量。'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-3: Plotting* Unitful *arrays*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：带单位的* Unitful *数组绘图*'
- en: Here we import `Plots`, which we need for plotting, and `Unitful`, to handle
    units. After defining a mass in kilograms and a range of velocities in meters
    per second, we create an array of kinetic energies, `KE`, from the fact that kinetic
    energy = 1/2 mass × velocity². The new package gives the plotting functions in
    `Plots` the ability to handle quantities with units and automatically appends
    the units to the axis labels. [Figure 9-2](ch09.xhtml#ch9fig2) shows the result
    of the `plot()` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`Plots`，这是我们绘图所需的库，以及`Unitful`，用来处理单位。在定义了质量（以千克为单位）和一系列速度（以米每秒为单位）之后，我们根据动能公式（动能
    = 1/2 质量 × 速度²）创建了一个动能数组`KE`。这个新包赋予`Plots`中的绘图函数处理带单位的量的能力，并自动将单位附加到轴标签上。[图 9-2](ch09.xhtml#ch9fig2)展示了`plot()`语句的结果。
- en: '![Image](../images/ch09fig02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig02.jpg)'
- en: '*Figure 9-2: The plot that [Listing 9-3](ch09.xhtml#ch9lis3) generates*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：* [列表 9-3](ch09.xhtml#ch9lis3) *生成的图表*'
- en: I’ve left the energy units alone for this example, but more conventional physics
    usage would involve a conversion to joules using `uconvert()`, which we could
    have done before the plotting call or inline within `plot()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个例子中没有更改能量单位，但更常见的物理学用法是使用`uconvert()`将其转换为焦耳，这可以在绘图调用之前或在`plot()`内部进行。
- en: We were able to create this graph with the same `plot()` call that we might
    have used to plot the same quantities stored in numerical arrays without units.
    All the plotting functions in `Plots`, such as `scatter()` and `surface()`, work
    with `Unitful` arrays to produce similar axis labels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用相同的`plot()`调用创建这个图表，正如我们可能用来绘制存储在没有单位的数值数组中的相同量。`Plots`中的所有绘图函数，如`scatter()`和`surface()`，都可以处理`Unitful`数组，并生成类似的轴标签。
- en: '***Making Plots for Publication***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为出版制作图表***'
- en: When attempting to make high-quality plots for publication, however, we encounter
    some shortcomings. While `Plots` aspires to create a unified interface to a variety
    of backends, each plotting engine works somewhat differently, with each having
    unique capabilities and limitations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在尝试制作高质量的出版图表时，我们会遇到一些不足之处。虽然`Plots`旨在为各种后端创建统一的接口，但每个绘图引擎的工作方式有所不同，每个引擎都有独特的功能和局限性。
- en: These differences among backends become more salient when we are making the
    final adjustments that accompany the preparation of graphs for publication. It
    is at this stage that, for example, the typographic details in labels and annotations
    become important. [Figure 9-2](ch09.xhtml#ch9fig2) was created using the `GR`
    backend, which, as mentioned in “Useful Backends” on [page 115](ch04.xhtml#ch04lev11),
    is the default at the time of writing, and is fast and capable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行最终调整以准备图表用于出版时，这些后端之间的差异变得更加明显。例如，标签和注释中的排版细节在这一阶段变得非常重要。[图 9-2](ch09.xhtml#ch9fig2)是使用`GR`后端创建的，正如在“有用的后端”部分所提到的[第115页](ch04.xhtml#ch04lev11)，该后端在写作时是默认后端，且快速且功能强大。
- en: '[Figure 9-2](ch09.xhtml#ch9fig2) may be acceptable as is, but for publication
    we may want to improve the appearance of its graph labels, especially to make
    the unit notations look like conventional mathematical notation. As we saw in
    “LaTeX Titles and Label Positioning by Data” on [page 103](ch04.xhtml#ch04lev1sec12),
    we can use LaTeX notation in graph annotations with mathematical content. This
    also works for the automatic labeling using units with the packages we’ve already
    imported:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-2](ch09.xhtml#ch9fig2)可能已经可以接受，但为了出版，我们可能需要改进其图表标签的外观，特别是让单位符号看起来像常规的数学符号。正如我们在“基于数据的
    LaTeX 标题和标签定位”一节中，在 [第103页](ch04.xhtml#ch04lev1sec12)看到的那样，我们可以在图表注释中使用带有数学内容的
    LaTeX 符号。这同样适用于我们已经导入的包中的单位自动标签：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The example repeats the plot command from [Listing 9-3](ch09.xhtml#ch9lis3),
    but with some alterations to create LaTeX strings for the plot labels. The `unitformat`
    keyword processes the unit annotations through `latexify()`, with the value `latexroundunitlabel`
    retaining the parentheses around the units. Since this triggers placing the entire
    label into a LaTeX string, we also need to wrap the non-math parts of the labels
    in LaTeX commands to set them as normal text instead of math.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例重复了 [清单 9-3](ch09.xhtml#ch9lis3) 中的绘图命令，但做了一些修改，创建了用于绘图标签的 LaTeX 字符串。`unitformat`
    关键字通过 `latexify()` 处理单位注释，值 `latexroundunitlabel` 保留了单位周围的括号。由于这会将整个标签放入 LaTeX
    字符串中，因此我们还需要将标签中的非数学部分用 LaTeX 命令包裹起来，以将它们设置为常规文本，而非数学公式。
- en: '**The GR Backend**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GR 后端**'
- en: The results of this approach depend critically on what backend we’re using.
    Obviously, it makes sense to use LaTeX strings only with backends that can do
    something with them. Although the default `GR` backend can interpret LaTeX, the
    results are not always adequate. This engine includes its own version of LaTeX
    processing, which often creates poor-quality typesetting with faulty kerning.
    The LaTeX engine in `GR` is the focus of some development activity, however, so
    its performance may improve.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的结果在很大程度上依赖于我们使用的后端。显然，只有在后端能够处理 LaTeX 字符串时，使用 LaTeX 字符串才有意义。尽管默认的 `GR`
    后端可以解释 LaTeX，但其结果并不总是令人满意。这个引擎包含了自己的 LaTeX 处理版本，通常会产生质量较差的排版，且字间距不准确。不过，`GR` 中的
    LaTeX 引擎目前正在开发中，因此其性能可能会有所提高。
- en: Good-quality typesetting of labels in most cases requires processing by an external
    TeX engine, which involves a TeX installation such as TeXLive. As many physicists
    and other scientists have already made such an installation, we’ll move on to
    considering options that take advantage of it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，标签的高质量排版需要通过外部 TeX 引擎处理，这通常涉及如 TeXLive 之类的 TeX 安装。由于许多物理学家和其他科学家已经安装了这样的
    TeX 系统，我们将继续考虑那些能够利用该安装的选项。
- en: '**The Gaston Backend**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Gaston 后端**'
- en: Gnuplot can optionally be compiled with support for the `tikz` terminal, which
    saves plots as text files containing TikZ commands. (TikZ is a graphics language
    that comes with most full-featured TeX installations.) Such files are processed
    with LaTeX and can contain TeX or LaTeX markup for the annotations on the plot.
    The result is of the highest quality, with fonts and styles that match the document
    in which the plot is included. Unfortunately, at the time of writing, the `Gaston`
    backend, which uses gnuplot, does not properly support the `tikz` terminal, so
    this option is off the table. It’s being worked on, however, and once we can use
    `Gaston` with `tikz`, it will be the best option for complex plots for publication
    or when the best typographic quality is desired.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gnuplot 可以选择性地编译支持 `tikz` 终端，这会将图形保存为包含 TikZ 命令的文本文件。（TikZ 是一种图形语言，通常包含在大多数完整的
    TeX 安装中。）这些文件通过 LaTeX 处理，并且可以包含 TeX 或 LaTeX 标记，用于图形上的注释。结果的质量非常高，字体和样式与图形所在的文档一致。不幸的是，在写作时，使用
    gnuplot 的 `Gaston` 后端并不完全支持 `tikz` 终端，因此这个选项目前不可用。不过，它正在被开发中，一旦我们能够将 `Gaston`
    与 `tikz` 一起使用，它将成为用于复杂图形出版或需要最佳排版质量时的最佳选择。
- en: '**The PGFPlotsX Backend**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**PGFPlotsX 后端**'
- en: Another backend that can make use of LaTeX strings is `PGFPlotsX`, which is
    invoked with the `pgfplotsx()` function. This backend creates plots by calling
    out to the LuaLaTeX TeX engine, which comes with most TeX installations, including
    TeXLive. Since LuaLaTeX does all the typesetting, the labels come out with TeX-level
    quality. This backend is, therefore, an excellent choice for publication-quality
    graphs. `Gaston` may still be the best future choice for complex plots because
    processing through LuaLaTeX can be far slower than through gnuplot if the plot
    contains a large number of elements, such as in a large scatterplot.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以利用 LaTeX 字符串的后端是 `PGFPlotsX`，它通过 `pgfplotsx()` 函数调用。该后端通过调用 LuaLaTeX TeX
    引擎来创建图形，而 LuaLaTeX 是大多数 TeX 安装包中都包含的，包括 TeXLive。由于 LuaLaTeX 负责排版，因此标签的质量达到 TeX
    级别。因此，这个后端是发布高质量图表的绝佳选择。如果图表包含大量元素（例如在大型散点图中），`Gaston` 可能仍然是未来处理复杂图形的最佳选择，因为通过
    LuaLaTeX 处理的速度可能比通过 gnuplot 要慢得多。
- en: '**Handling Units Manually**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**手动处理单位**'
- en: Unfortunately, `PGFPlotsX` does not work properly with `Unitful`, not taking
    TeX processing into account. This limitation provides the opportunity to demonstrate
    a different way of plotting `Unitful` quantities and labeling axes with units—one
    that affords us complete control over the details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`PGFPlotsX` 与 `Unitful` 兼容性不佳，没有考虑到 TeX 处理。这一限制提供了一个展示不同方式绘制 `Unitful`
    数量并用单位标签轴的机会——这种方法让我们完全控制细节。
- en: 'The following listing contains the definition of a function that accepts two
    `Unitful` arrays for plotting, along with keyword arguments for labels:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含了一个函数的定义，该函数接受两个 `Unitful` 数组进行绘图，并带有用于标签的关键字参数：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `ustrip()` and `unit()` functions (see [Listings 9-1](ch09.xhtml#ch9lis1)
    and [9-2](ch09.xhtml#ch9lis2)), this code separates the arrays from their associated
    units, plotting the numerical parts and using the unit parts to construct labels
    with the `LaTeXStrings` package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ustrip()` 和 `unit()` 函数（见[清单 9-1](ch09.xhtml#ch9lis1) 和 [9-2](ch09.xhtml#ch9lis2)），这段代码将数组与其关联的单位分离，绘制数值部分，并使用单位部分通过
    `LaTeXStrings` 包构建标签。
- en: In order to interpolate values into a `LaTeXStrings` string, we need to use
    the two characters `%$` rather than a simple `$` ➊. When extracting the units
    from the arrays, we require the units of the elements of the array, which is why
    `eltype()` appears in the label assignment. The function saves both the stand-alone
    PDF version of the graph and its TeX version ➋ for including in a LaTeX document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将值插入到 `LaTeXStrings` 字符串中，我们需要使用两个字符 `%$` 而不是简单的 `$` ➊。在从数组中提取单位时，我们需要数组元素的单位，这就是为什么在标签分配中出现了
    `eltype()` 的原因。该函数会保存图形的独立 PDF 版本以及其 TeX 版本 ➋，以便将其包含在 LaTeX 文档中。
- en: 'After selecting the desired backend, we call the function to create the *.pdf*
    and *.tex* files with the default names:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的后端后，我们调用该函数以默认名称创建 *.pdf* 和 *.tex* 文件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Figure 9-3](ch09.xhtml#ch9fig3) shows the result.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.xhtml#ch9fig3) 显示了结果。'
- en: '![Image](../images/ch09fig03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch09fig03.jpg)'
- en: '*Figure 9-3: A* PGFPlotsX *plot with typeset unit labels*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：A* PGFPlotsX *绘图与排版单位标签*'
- en: Typesetting by LuaTeX provides the excellent quality of the labels in [Figure
    9-3](ch09.xhtml#ch9fig3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: LuaTeX 排版提供了[图 9-3](ch09.xhtml#ch9fig3)中标签的优异质量。
- en: '**Error Propagation with Measurements**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测量中的误差传播**'
- en: In the previous section we explored a package that extended the concept of numbers
    to include physical units. Here we’ll meet `Measurements`, another package that
    defines a number-like object useful for calculations in physics or nearly any
    empirical science.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们探讨了一个扩展数字概念以包括物理单位的包。在这里，我们将遇到 `Measurements`，这是另一个定义类似数字对象的包，适用于物理学或几乎所有经验科学中的计算。
- en: The `Measurements` package allows us to attach uncertainties to numbers. The
    number in question must be convertible to a float, so we can attach uncertainties
    directly to `Float64` numbers, integers, and `Irrational` quantities. (We can
    also create complex numbers with uncertainties, if we really want to, by attaching
    errors to their real and imaginary parts.) The `Measurements` package defines
    a new data type, called `Measurement{T}`, where `T` can be any size float. We
    can perform any arithmetic operations on `Measurement` types that are allowed
    on floats, and the errors, or uncertainties, will be propagated to the result
    using standard linear error propagation theory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Measurements` 包允许我们为数字附加不确定性。所讨论的数字必须能够转换为浮点数，因此我们可以直接为 `Float64` 数字、整数和 `Irrational`
    数量附加不确定性。（如果我们真的需要，还可以通过为其实部和虚部附加误差来创建带有不确定性的复数。）`Measurements` 包定义了一种新的数据类型，叫做
    `Measurement{T}`，其中 `T` 可以是任何大小的浮点数。我们可以对 `Measurement` 类型执行浮点数允许的任何算术运算，误差或不确定性将使用标准线性误差传播理论传播到结果中。'
- en: 'Here are some examples of creating instances of `Measurement` types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建 `Measurement` 类型实例的一些例子：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create `Measurement` objects using a notation that will be familiar to scientists.
    We can type the `±` operator by entering \pm in the REPL and pressing TAB or by
    using the operating system’s entry method for special characters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用科学家熟悉的符号表示法来创建 `Measurement` 对象。我们可以在 REPL 中输入 `\pm` 操作符并按下 TAB 键，或者使用操作系统的特殊字符输入法来输入
    `±` 符号。
- en: In the REPL, the `ans` variable holds the most recently returned result. Since
    `Measurement` objects have only one type parameter, the base number and the error
    must be of the same type. As the `typeof()` calls show, `Measurements` promotes
    the smaller type as needed; the `f0` suffix is a way to enter 32-bit float literals
    ➊.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，`ans` 变量保存最近返回的结果。由于 `Measurement` 对象只有一个类型参数，因此基本数字和误差必须是相同的类型。正如
    `typeof()` 调用所示，`Measurements` 根据需要提升较小的类型；`f0` 后缀是输入 32 位浮点字面量的一种方式 ➊。
- en: 'The package treats significant digits intelligently:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该包智能地处理有效数字：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The digits made insignificant by the error are not printed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被误差影响而变得不重要的数字不会被打印出来。
- en: 'When printing results in the REPL, the package displays only two significant
    digits in the error, to keep things neat:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中打印结果时，包仅显示误差的两个有效数字，以保持整洁：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, it retains the full values internally for computations. We can access
    these components with the `value()` and `uncertainty()` functions shown here,
    which, as they are not exported, we need to qualify with the package namespace.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它在内部仍然保留完整的值用于计算。我们可以使用 `value()` 和 `uncertainty()` 函数访问这些组件，正如这里所示，由于这些函数没有被导出，我们需要用包的命名空间来限定。
- en: 'Scientists often use an alternative, convenient notation to express uncertainty
    by appending the error in the final significant digits within parentheses. The
    `Measurements` package understands this notation as well:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家们常常使用另一种方便的表示法，通过在最终有效数字后面加上括号中的误差来表示不确定性。`Measurements` 包也理解这种表示法：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to use the notation, we need to employ the `measurement()` function
    and supply the argument as a string. We can also use `measurement()` as an alternative
    to the `±` operator:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种表示法，我们需要使用 `measurement()` 函数并将参数作为字符串提供。我们还可以将 `measurement()` 用作 `±`
    操作符的替代方法：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Arithmetic operations propagate errors correctly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算会正确传播误差：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All these examples perform arithmetic as might be expected on the quantities
    and their errors. More interesting is the last example, where `Measurements` has
    recognized a ratio that has no error. The package maintains the notion of correlated
    and independent measurements, which is explained in its documentation. See “Further
    Reading” on [page 304](ch09.xhtml#fur9) for the URL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例子都按照预期对量和它们的误差执行算术运算。更有趣的是最后一个例子，其中 `Measurements` 识别了一个没有误差的比率。该包保持了相关和独立测量的概念，这在其文档中有详细说明。请参阅
    [第 304 页](ch09.xhtml#fur9)的“进一步阅读”获取网址。
- en: 'Referring back to the example in [Listing 9-3](ch09.xhtml#ch9lis3), we can
    add an uncertainty to the `Unitful` value for mass in two ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [示例 9-3](ch09.xhtml#ch9lis3) 的例子，我们可以通过两种方式为 `Unitful` 中的质量值添加不确定性：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example shows that the packages `Measurements` and `Unitful` can work together
    to create quantities with both units and uncertainties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 `Measurements` 和 `Unitful` 包如何协同工作，创建同时带有单位和不确定性的量。
- en: 'Let’s continue with the example from [Listing 9-3](ch09.xhtml#ch9lis3) using
    this new value for `mass`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用来自 [示例 9-3](ch09.xhtml#ch9lis3) 的例子，使用这个新的 `mass` 值：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although, as before, `velocity` has no uncertainty attached to it, `mass` does;
    therefore, `KE` should also contain uncertainties.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与之前一样，`velocity` 没有附带不确定性，但 `mass` 有；因此，`KE` 也应该包含不确定性。
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the result.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch9fig4) 显示了结果。'
- en: '![Image](../images/ch09fig04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig04.jpg)'
- en: '*Figure 9-4: Plotting with units and errors*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：带单位和误差的绘图*'
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the `Unitful` arrays plotted as before
    with the axes labeled with their units. It also has error bars, showing how the
    error increases as the kinetic energy increases. We didn’t have to change anything
    in the call to `plot()`. Somehow the type of the quantities to be plotted triggered
    the plotting function to use both unit labels and error bars. We would observe
    the same behavior with the other plotting functions in `Plots`, such as `scatter()`
    or `surface()`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch9fig4) 显示了如前所述的带单位的 `Unitful` 数组图，其中坐标轴已标明单位。图中还显示了误差条，展示了动能增加时误差如何增加。我们不需要修改
    `plot()` 函数的调用。某种程度上，绘图的量类型触发了绘图函数同时使用单位标签和误差条。我们在 `Plots` 中的其他绘图函数（如 `scatter()`
    或 `surface()`）也会表现出相同的行为。'
- en: '**Fluid Dynamics with Oceananigans**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流体动力学与 Oceananigans**'
- en: The `Oceananigans` package for fluid dynamics simulations is especially well
    suited, as the name suggests, to the physics of the ocean. It provides a simulation
    construction kit that can include the effects of temperature and salinity variations,
    Earth’s rotation, wind, and more. Its defaults usually perform well, but it’s
    flexible enough that the user can specify one of several available solution methods.
    It has various physics models built in, including a linear equation of state,
    but makes it easy to substitute others of the user’s devising.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oceananigans` 流体动力学仿真包，顾名思义，特别适用于海洋物理学。它提供了一个仿真构建工具包，可以包含温度和盐度变化、地球自转、风力等的影响。其默认设置通常表现良好，但足够灵活，用户可以指定几种可用的求解方法。它内置了各种物理模型，包括线性状态方程，但也很容易替换为用户自定义的其他模型。'
- en: '***The Physical System***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***物理系统***'
- en: We are setting out to simulate a two-dimensional layer of fluid in Earth’s gravitational
    field. The bottom of the layer is maintained at a higher temperature than the
    top. This heating from below creates a convective motion, as can be seen in clouds
    or in a pan on the stove.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算模拟地球引力场中的二维流体层。流体层底部的温度高于顶部。这种来自底部的加热会产生对流运动，正如云层或炉子上的锅中所见。
- en: '**NOTE**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Oceananigans *depends on some compiled binaries in the standard library. If
    the precompilation of* Oceananigans *fails and you’re using a recent or beta version
    of Julia, try it with an earlier Julia release (the previous major version number).*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Oceananigans *依赖于标准库中的一些已编译的二进制文件。如果 Oceananigans 的预编译失败，并且你正在使用最近或测试版的 Julia，可以尝试使用之前的
    Julia 版本（前一个主版本号）。*
- en: The bottom and top simulation boundaries are impenetrable and freeslip, which
    means the fluid can slide across them. Horizontally, we impose a periodic boundary
    condition, requiring the solution to wrap around and be the same on the left and
    right boundaries. The horizontal direction is *x* and the vertical direction is
    *z*. We start the fluid at rest and are interested in the pattern of motion that
    the temperature difference creates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 底部和顶部的仿真边界是不可穿透且自由滑移的，这意味着流体可以在其上滑动。在水平方向上，我们施加了周期性边界条件，要求解答在左右边界之间进行环绕并保持一致。水平方向是
    *x* 轴，垂直方向是 *z* 轴。我们将流体初始设为静止，并且对温度差异所产生的运动模式感兴趣。
- en: '[Figure 9-5](ch09.xhtml#ch9fig5) shows the setup of the simulated system. The
    gray area represents the fluid, and the thick black horizontal lines indicate
    the constant-temperature boundaries.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](ch09.xhtml#ch9fig5) 显示了仿真系统的设置。灰色区域代表流体，粗黑色水平线表示恒温边界。'
- en: '![Image](../images/ch09fig05.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig05.jpg)'
- en: '*Figure 9-5: The simulation box*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：仿真框*'
- en: The `Luxor` program (see “Diagramming with Luxor” on [page 190](ch07.xhtml#ch07lev1))
    that created this diagram is available in the Physics section of the online supplement
    at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此图表的 `Luxor` 程序（见 [第190页](ch07.xhtml#ch07lev1)的“使用 Luxor 绘图”）可以在在线补充资料的物理学部分找到，网址为
    [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)。
- en: A fluid dynamics simulation contains many pieces that we’ll need to construct
    separately before we can begin the calculation. In the following subsections,
    we’ll define the computational grid, the boundary conditions, the diffusivity
    models, and the equation of state, and establish the boundary conditions and the
    hydrodynamic model, in that order. After all the pieces are in place, we’ll run
    the `Oceananigans` simulation and visualize the results.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流体动力学模拟包含许多部分，我们需要分别构建它们，然后才能开始计算。在接下来的小节中，我们将定义计算网格、边界条件、扩散模型和状态方程，并按此顺序建立边界条件和流体动力学模型。所有部分就绪后，我们将运行`Oceananigans`模拟并可视化结果。
- en: '***The Grid***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网格***'
- en: To put together an `Oceananigans` simulation, we’ll define its various components
    using functions exported by the package, and then define a model using the `model()`
    function, passing in the components as arguments. For this example we’ll use a
    `grid`, a `buoyancy` model that specifies the fluid’s equation of state, a set
    of boundary conditions, the coefficients of viscosity and thermal diffusivity
    (material properties of the fluid), and initial conditions on the temperature
    within the fluid. We won’t include the effects of Earth’s rotation, salinity,
    or wind, but these ingredients are available for use in other `Oceananigans` models.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个`Oceananigans`模拟，我们将使用该软件包导出的函数来定义其各个组件，然后使用`model()`函数定义一个模型，并将组件作为参数传递。对于这个例子，我们将使用一个`grid`，一个指定流体状态方程的`buoyancy`模型，一组边界条件，粘度和热扩散率的系数（流体的物理属性），以及流体内部的温度初始条件。我们不会包括地球自转、盐度或风的影响，但这些因素可以在其他`Oceananigans`模型中使用。
- en: 'The grid is defined by its computational `size` (how many grid points exist
    in each direction), its `extent` (the physical lengths represented by these directions),
    and its `topology`, which is the term `Oceananigans` uses for what boundary conditions
    hold in each direction. For our problem we define the grid this way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 网格由其计算`size`（每个方向上有多少网格点）、`extent`（这些方向所表示的物理长度）以及其`topology`（`Oceananigans`用于表示每个方向上的边界条件的术语）定义。对于我们的问题，我们这样定义网格：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `RectilinearGrid()` function that `Oceananigans` provides constructs grids
    as one of many data types defined in the package. We assign the grid to our own
    variable, `grid`, for use later when creating the model. We could have chosen
    any name for this variable, but `grid` is the name of the relevant keyword argument
    accepted by the model construction function; using the same names for our own
    variables will keep everything neat.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oceananigans`提供的`RectilinearGrid()`函数构建网格，这是该软件包中定义的多种数据类型之一。我们将网格赋值给我们自己的变量`grid`，以便在创建模型时使用。我们本可以为这个变量选择任何名称，但`grid`是模型构建函数接受的相关关键字参数的名称；为我们自己的变量使用相同的名称会使一切保持整洁。'
- en: In the `topology` keyword argument, we list the boundary conditions in the *x*,
    *y*, and *z* directions, with *z* pointing upward. The boundary condition `Flat`
    means that we’re not using (in this case) the *y* direction. This call defines
    a two-dimensional, *x*–*z* grid, with periodic boundaries in *x* and impenetrable
    boundaries in *z*. `Oceananigans` uses a kilogram-meter-second unit system. Because
    we set the `extent` to be equal to the `size`, the grid spacing is one unit in
    length along each dimension, giving us a fluid layer 256 meters wide and 32 meters
    tall.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`topology`关键字参数中，我们列出了在*x*、*y*和*z*方向上的边界条件，其中*z*方向指向上方。边界条件`Flat`意味着我们没有使用（在这种情况下）*y*方向。这个调用定义了一个二维的*x*–*z*网格，其中*x*方向是周期性边界，*z*方向是不可穿透的边界。`Oceananigans`使用千克-米-秒单位制。因为我们将`extent`设置为等于`size`，所以网格间距在每个方向上为一个单位长度，给我们提供了一个宽256米、高32米的流体层。
- en: As the example shows, `Oceananigans` has useful forms for representing its data
    types in the REPL, summarizing the salient information for our inspection. Here
    the output provides us with a summary of the grid parameters and boundary conditions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，`Oceananigans`在REPL中有用于表示其数据类型的有用形式，总结了我们检查时需要的关键信息。这里的输出为我们提供了网格参数和边界条件的摘要。
- en: '***The Boundary Conditions***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***边界条件***'
- en: 'We define any boundary conditions on physical variables as a separate component,
    which is also eventually passed into `model()`. We want to impose constant values
    of temperature on the top and bottom boundaries; `Oceananigans` sets this type
    of boundary condition with the `FieldBoundaryConditions()` function, as it sets
    boundary conditions on, in this case, the temperature field. We can use `Oceananigans`’s
    convenient definitions of `top` and `bottom`, which have their intuitive meaning
    (there are also `north`, `south`, `east`, and `west`, which we don’t need in this
    problem):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将任何物理变量的边界条件定义为单独的组件，最终也会传递给`model()`。我们希望在上下边界上施加常数温度值；`Oceananigans`使用`FieldBoundaryConditions()`函数设置这种类型的边界条件，因为它设置了在这种情况下温度场的边界条件。我们可以使用`Oceananigans`提供的`top`和`bottom`的便捷定义，它们具有直观的含义（还有`north`、`south`、`east`和`west`，但在这个问题中我们不需要用到它们）：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `immersed` boundary refers to one that exists inside the fluid volume, but
    we’re not using that one, nor any of the other myriad options, such as defined
    gradients or fluxes. The `ValueBoundaryCondition` that we use sets a constant
    value for a variable on the specified boundary.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`immersed`边界指的是存在于流体体积内部的边界，但我们不使用这个边界，也不使用其他任何复杂的选项，比如定义的梯度或通量。我们使用的`ValueBoundaryCondition`设置了在指定边界上某个变量的常数值。'
- en: '***The Diffusivities***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩散率***'
- en: 'We need to assign values to two constants that describe some of the fluid’s
    material properties; this is part of the problem definition. The viscosity coefficient
    (*ν*) determines how “thick” the fluid is, and the thermal diffusivity (*κ*) determines
    how readily it conducts heat. These values are passed to the model in the `closure`
    keyword and can be set through the `ScalarDiffusivity()` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为描述流体材料属性的两个常数赋值，这是问题定义的一部分。粘度系数(*ν*)决定了流体的“稠密”程度，热扩散率(*κ*)决定了它传导热量的速率。这些值通过`closure`关键词传递给模型，并可以通过`ScalarDiffusivity()`函数进行设置：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The symbol for viscosity is the Greek letter *nu* and that for thermal diffusivity
    is *kappa*. Like all Greek letters, we can precede their names with a backslash
    and then press TAB to enter them in the REPL.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 粘度的符号是希腊字母*nu*，而热扩散率的符号是*kappa*。像所有希腊字母一样，我们可以在它们的名称前加上反斜杠，然后按TAB键在REPL中输入它们。
- en: '***The Equation of State***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***状态方程***'
- en: The equation of state is a function that describes how the density of the fluid
    at any point depends on the temperature and salinity there (the assumption of
    *incompressibility* usually used in `Oceananigans` models means that density has
    no dependence on pressure). Our model is salt free, but our fluid will be lighter
    when it’s hotter. This is what will cause the fluid to move, as the lighter parts
    will rise and the heavier parts will sink, driven by gravity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 状态方程是一个函数，用于描述流体在任何点的密度如何依赖于该点的温度和盐度（在`Oceananigans`模型中，通常假设*不可压缩性*意味着密度不依赖于压力）。我们的模型是无盐的，但当流体变热时，它会变得更轻。这就是流体会运动的原因，较轻的部分会上升，而较重的部分则会下沉，受到重力的驱动。
- en: 'The `model()` function expects the keyword `buoyancy`, so we’ll use that too:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`model()`函数期望关键词`buoyancy`，所以我们也会使用它：'
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Oceananigans offers many other options, including the ability to define our
    own equation of state, but we’ll keep the model simple. The `SeawaterBuoyancy`
    component deals with buoyancy by combining gravity (with the default Earth value
    given here) with density variations. As we’re not interested in salinity effects
    for this calculation, we set `haline_contraction` to 0 (“haline” is essentially
    a synonym for saline used by oceanographers).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oceananigans`提供了许多其他选项，包括定义我们自己的状态方程的能力，但我们会保持模型的简单性。`SeawaterBuoyancy`组件通过将重力（此处给出的默认地球值）与密度变化相结合来处理浮力。由于我们不关心盐度效应，我们将`haline_contraction`设置为0（“haline”实际上是海洋学家用来表示盐度的同义词）。'
- en: '***The Model and Initial Conditions***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模型与初始条件***'
- en: 'Now that we have all the pieces set up, we can put them together into a *model*,
    the `Oceananigans` term for the definition of the computational problem, including
    all the physics along with the grid and the boundary conditions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了所有的组成部分，我们可以将它们结合成一个*模型*，这是`Oceananigans`定义计算问题的术语，包括所有的物理内容、网格和边界条件：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The package prints a nice summary of the result, including a reminder of some
    (but not all) of the features we’re not using, such as the coriolis force from
    Earth’s rotation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该包打印了结果的简洁摘要，包括提醒一些我们未使用的特性（但并非所有），比如地球自转产生的科里奥利力。
- en: The `NonhydrostaticModel()` function creates a model using the approximation
    appropriate to our problem. `Oceananigans` offers several other choices, including
    a hydrostatic model to simulate surface waves.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonhydrostaticModel()` 函数使用适合我们问题的近似方法来创建模型。`Oceananigans` 提供了其他几种选择，包括模拟表面波的静力学模型。'
- en: We use the abbreviated form of passing keyword arguments explained in “Concise
    Syntax for Keyword Arguments” on [page 154](ch06.xhtml#ch06lev1sec1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了“关键字参数简洁语法”中解释的简化形式，详见[第 154 页](ch06.xhtml#ch06lev1sec1)。
- en: Our boundary condition `bc` doesn’t refer to any particular physical variable;
    it simply defines a constant field value on the boundaries. The named tuple assigned
    to `boundary_conditions` enforces them on `T`, the variable used in `Oceananigans`
    for the temperature.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的边界条件 `bc` 并不指向任何特定的物理变量；它仅仅是在边界上定义一个常数场值。分配给 `boundary_conditions` 的命名元组会在
    `T` 上强制执行这些条件，`T` 是 `Oceananigans` 中用于表示温度的变量。
- en: The printed result refers to the CPU ➊, which means that this model is intended
    for “normal” machine architectures. The other option is to calculate on GPUs (graphics
    processing units). The `halo` refers to the several points outside the physical
    grid that the numerical algorithm uses to enforce the boundary conditions or other
    constraints.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果提到的 CPU ➊，意味着该模型适用于“普通”机器架构。另一种选择是使用 GPU（图形处理单元）进行计算。`halo` 指的是数值算法用来强制执行边界条件或其他约束的物理网格外的几个点。
- en: The final keyword argument, `tracers`, tells the model to keep track of the
    temperature and salinity as those scalar fields are advected around the fluid.
    We’re required to include `:S` even though our equation of state means it will
    have no effect.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的关键字参数 `tracers` 告诉模型在流体中跟踪温度和盐度等标量场的输送。尽管我们的状态方程意味着它不会产生任何影响，但我们仍然需要包括 `:S`。
- en: The fluid layer heated from below defined by our model is physically *unstable*,
    which means that a small perturbation to its initial, motionless state will be
    magnified and develop into a state with some form of persistent motion, driven
    by the temperature difference and the gravitational field. It is the development
    of the instability that we want to study. We need to add the small perturbation,
    or else, even though the system is unstable, it will never move.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型中由下方加热的流体层在物理上是*不稳定*的，这意味着对其初始静止状态的一个小扰动将被放大，并发展成一种具有持续运动的状态，这种运动由温度差和引力场驱动。我们要研究的正是这种不稳定性的发展。我们需要加入小的扰动，否则，即使系统不稳定，它也永远不会移动。
- en: 'The `set!()` function lets us create any desired initial condition on any of
    the fields. We’ll use it to add a small, random perturbation to the temperature
    field throughout the fluid volume:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`set!()` 函数让我们可以在任何字段上创建所需的初始条件。我们将使用它在整个流体体积中对温度场添加一个小的随机扰动：'
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The function is spelled with an exclamation point to remind us that it mutates
    its arguments: it alters the `T` field in place, and the model as well.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的拼写中有一个感叹号，提醒我们它会修改其参数：它会就地更改 `T` 字段，也会更改模型。
- en: '***The Simulation***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿真***'
- en: Next we need to create a *simulation*, using the `Simulation()` function. This
    object will receive the model as its positional argument, along with keyword arguments
    for the timestep and when to stop the calculation. It will keep track of how much
    simulation time and wall-clock time has elapsed and the state of all the physical
    fields. This allows us to continue the simulation after the requested start time
    if we want, save the progress of the simulation in files, and retrieve the fields
    for examination and plotting.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `Simulation()` 函数创建一个*仿真*。这个对象将接收模型作为位置参数，并接收时间步长和停止计算时间的关键字参数。它会跟踪仿真时间和墙钟时间的经过情况，以及所有物理场的状态。这使得我们可以在请求的开始时间之后继续仿真，保存仿真进度到文件，并检索字段进行检查和绘图。
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a simple call, as `model` already contains all the details of the problem.
    We get a summary of various options for the simulation, most of which we didn’t
    use. If you want to use the *delta* for the time interval in the REPL, enter \Delta
    and press TAB.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的调用，因为 `model` 已经包含了问题的所有细节。我们会得到仿真各种选项的摘要，大部分我们并没有使用。如果你想在 REPL 中使用*时间间隔的增量*，输入
    \Delta 并按 TAB 键。
- en: Before running the simulation, let’s arrange for the velocity and temperature
    fields to be stored on disk at regular intervals so we can see its development
    over time (if we don’t do this, we’ll see only the final state of the simulation),
    as shown in [Listing 9-4](ch09.xhtml#ch9lis4).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行模拟之前，让我们安排在定期的时间间隔内将速度和温度字段存储到磁盘上，这样我们就可以查看它们随时间的发展（如果不这样做，我们只能看到模拟的最终状态），如[列表
    9-4](ch09.xhtml#ch9lis4)所示。
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 9-4: Setting up output writers*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4：设置输出写入器*'
- en: 'Adding elements to the `output_writers` property of the `simulation` causes
    it to store the results periodically. The `JLD2OutputWriter` uses the `JLD2` file
    format, which is a compact way to store multiple Julia data structures in a single
    file. It’s a version of the `HDF5` format widely used in computational science.
    The `schedule` causes a data dump every 1 second, which, using our timestep, will
    be every 100 steps. The information in the result shows which quantities will
    be saved: `T` and `S` are the temperature and salinity.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素添加到 `simulation` 的 `output_writers` 属性中会导致它定期存储结果。`JLD2OutputWriter` 使用 `JLD2`
    文件格式，这是将多个 Julia 数据结构存储在一个文件中的紧凑方式。它是广泛应用于计算科学中的 `HDF5` 格式的一个版本。`schedule` 每秒进行一次数据转储，使用我们的时间步长，这将是每
    100 步一次。结果中的信息显示将保存哪些量：`T` 和 `S` 分别是温度和盐度。
- en: 'With this, we’re ready to run the calculation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好运行计算了：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The REPL will not have anything more to say until it reaches the final timestep,
    which in this case will take several hours on a typical personal computer. Then
    it will indicate that the calculation is complete and return to the interactive
    prompt. [Chapter 15](ch15.xhtml) explores ways to speed up such calculations by
    using parallel processing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 在计算达到最终时间步之前不会有任何输出，在此情况下，通常需要几个小时才能在个人计算机上完成。计算完成后，它会指示计算结束并返回交互式提示。[第
    15 章](ch15.xhtml)探讨了通过并行处理加速此类计算的方法。
- en: '***The Results***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: When an `Oceananigans` simulation ends, the final state of the fields (the velocity
    components and the temperature, in this case) is available as properties of the
    `model`. [Listing 9-5](ch09.xhtml#ch9lis5) shows how to retrieve them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `Oceananigans` 模拟结束时，字段的最终状态（此例中为速度分量和温度）作为 `model` 的属性可用。[列表 9-5](ch09.xhtml#ch9lis5)展示了如何检索它们。
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 9-5: Examining the results of a simulation*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-5：检查模拟结果*'
- en: The velocity and temperature fields are properties of the model. The `heatmap()`
    call will plot the two-dimensional temperature field, but first we need to turn
    it into an array with the `interior()` function. This function converts the `Oceananigans`
    field into a numerical array and trims away the `halo` points. Its arguments,
    following the field to convert, are the extents of the grid in each of the three
    directions; we enter a `1` to indicate an unused coordinate. In setting the `yrange`,
    we’ve accessed another property of the field, its grid shape. The prime after
    the array to plot transposes it so that it appears in its natural orientation,
    with a vertical gravity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和温度字段是模型的属性。`heatmap()` 调用将绘制二维温度场，但首先我们需要使用 `interior()` 函数将其转换为数组。此函数将 `Oceananigans`
    字段转换为数值数组，并去除 `halo` 点。它的参数，在要转换的字段之后，是三个方向上网格的范围；我们输入 `1` 来表示未使用的坐标。在设置 `yrange`
    时，我们访问了字段的另一个属性，即网格形状。数组后面的撇号会将其转置，以便它呈现出自然的方向，带有垂直的重力。
- en: 'We would normally run a simulation for just a few timesteps and examine the
    fields in this way before running a long calculation, to make sure we’ve set it
    up correctly. If we want to take another look after a few more timesteps, we can
    do this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会先运行几个时间步的模拟，并以这种方式检查字段，然后再进行长时间的计算，以确保我们正确设置了模拟。如果我们想在经过更多时间步后再查看一次，可以这样做：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These commands advance the simulation an additional 10 timesteps, after which
    we can repeat the steps in [Listing 9-5](ch09.xhtml#ch9lis5) to see how things
    are going.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将模拟推进额外的 10 个时间步，之后我们可以重复[列表 9-5](ch09.xhtml#ch9lis5)中的步骤，看看进展如何。
- en: Returning now to the quantities stored in files, as set up in [Listing 9-4](ch09.xhtml#ch9lis4),
    [Listing 9-6](ch09.xhtml#ch9lis6) shows how to retrieve the entire history of
    a field.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到存储在文件中的量，如[列表 9-4](ch09.xhtml#ch9lis4)所示，[列表 9-6](ch09.xhtml#ch9lis6)展示了如何检索字段的整个历史。
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 9-6: Retrieving a field from the JLD2 file*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-6：从 JLD2 文件中检索字段*'
- en: The summary of the result shows that the `FieldTimeSeries` has dimensions of
    256×1×32×1,030, which means that it’s defined on a 2D, 256×32 grid and evolves
    over 1,030 timesteps.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的摘要显示，`FieldTimeSeries` 的维度为 256×1×32×1,030，这意味着它定义在一个 2D 的 256×32 网格上，并在
    1,030 个时间步长中演化。
- en: 'After this call the entire history of the *x*-velocity field and its various
    properties are conveniently available. The data structure `uF` itself takes up
    almost no space:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用之后，整个 *x* 速度场及其各种属性都可以方便地访问。数据结构 `uF` 本身几乎不占用任何空间：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `sizeof()` function returns the amount of storage, in bytes, occupied by
    its argument. The actual data occupies 256 × 32 × 1,030 × 8 = 67,502,080 bytes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof()` 函数返回其参数所占用的存储空间（以字节为单位）。实际数据占用的空间为 256 × 32 × 1,030 × 8 = 67,502,080
    字节。'
- en: 'We can plot the horizontal velocity field at any timestep:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制任何时间步长的水平速度场：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’ve added some labeling to the version in [Listing 9-5](ch09.xhtml#ch9lis5),
    annotating the plot using properties read out from the field. Creating similar
    plots for timesteps 100 and 500, adding an `xlabel` to the last one, and putting
    them together with `plot(h50, h100, h500; layout=(3, 1))` creates the plot in
    [Figure 9-6](ch09.xhtml#ch9fig6).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 9-5](ch09.xhtml#ch9lis5)中的版本上添加了一些标注，使用从字段中读取的属性对图形进行注解。为时间步长 100 和 500
    创建类似的图形，给最后一个添加 `xlabel`，然后使用 `plot(h50, h100, h500; layout=(3, 1))` 将它们组合起来，生成[图
    9-6](ch09.xhtml#ch9fig6)中的图形。
- en: '![Image](../images/ch09fig06.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch09fig06.jpg)'
- en: '*Figure 9-6: Results of an* Oceananigans *simulation*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：Oceananigans 仿真结果*'
- en: The system evinces the regime called *turbulent convection*; it’s interesting
    to observe the emergence of large-scale order from randomness and its persistent
    coexistence with the turbulent flow.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 系统展现了所谓的*湍流对流*状态；观察从随机性中出现的大尺度秩序及其与湍流流动的持久共存非常有趣。
- en: In order to make an animation of the simulation, we need to generate plots at
    equally spaced time intervals and stitch them together into a video file. Our
    simulation used a constant timestep, so in this case, equal time intervals translates
    into equal numbers of timesteps. However, that won’t always be the case. `Oceananigans`
    has options for automatically adjusted timesteps, and we may perform a simulation
    in stages with differently sized Δ*t*. It’s convenient, therefore, to have a function
    that creates a plot given a *time*. Since a given time may not correspond to any
    particular stored field, but may fall between two consecutive data dumps, we’ll
    need a function that determines which stored field is closest to the time requested.
    The Julia program shown in [Listing 9-7](ch09.xhtml#ch9lis7) retrieves the simulation
    output and produces a movie of a specified duration.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作仿真的动画，我们需要在相等的时间间隔生成图形，并将它们拼接成一个视频文件。我们的仿真使用了常量时间步长，因此在这种情况下，相等的时间间隔意味着相等的时间步长数量。然而，这并不总是如此。`Oceananigans`
    提供了自动调整时间步长的选项，我们可能会在不同的阶段进行仿真，使用不同大小的 Δ*t*。因此，拥有一个根据 *时间* 创建图形的函数非常方便。由于给定的时间可能不对应于任何特定的存储字段，可能会落在两个连续数据存储之间，我们需要一个函数来确定最接近请求时间的存储字段。[清单
    9-7](ch09.xhtml#ch9lis7) 中的 Julia 程序获取仿真输出并生成指定持续时间的动画。
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 9-7: Creating an animation of an Oceananigans simulation*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：创建一个 Oceananigans 仿真动画*'
- en: The `heatmap_at_time()` function does what’s needed, creating a heatmap at the
    time closest to the time in its argument. In this function, `F` is a field retrieved
    with a call to `FieldTimeSeries()`, as in [Listing 9-6](ch09.xhtml#ch9lis6). It
    makes use of the `times` property of these objects, which is an array holding
    all the times at which the field has been saved. The index `i` holds the dump
    corresponding to the time closest to the supplied `time` ➊. When making an animation
    of a heatmap, we want to use the same mapping from values to colors in each frame,
    so our call to `heatmap()` uses the `clim` keyword ➋.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`heatmap_at_time()` 函数完成了所需的操作，在其参数中最接近的时间点创建了热力图。在这个函数中，`F` 是通过调用 `FieldTimeSeries()`
    获取的字段，如[清单 9-6](ch09.xhtml#ch9lis6)所示。它利用了这些对象的 `times` 属性，该属性是一个数组，包含了该字段被保存的所有时间点。索引
    `i` 保存了与提供的 `time` ➊ 最接近的时间点对应的数据。当制作热力图动画时，我们希望每一帧中的值到颜色的映射保持一致，因此我们对 `heatmap()`
    的调用使用了 `clim` 关键字 ➋。'
- en: 'With this function in place we can create an animation using the `Reel` package
    introduced in “Animations with Reel” on [page 206](ch07.xhtml#ch07lev4). To work
    with that package, we need to define a function of time `t` and (an unused) `dt`
    that returns a plot corresponding to `t`: the `plotframe()` function. The three
    constants ➌ in the script set the palette limits based on the data and the desired
    total duration of the animation. The palette limits are scaled so that more details
    are visible near the beginning of the run, but we can adjust it based on the features
    of interest.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，我们可以使用在[第206页](ch07.xhtml#ch07lev4)的“使用Reel制作动画”中介绍的`Reel`包来创建动画。为了使用该包，我们需要定义一个关于时间`t`的函数，并使用（未使用的）`dt`，该函数返回与`t`相对应的绘图：`plotframe()`函数。脚本中的三个常数
    ➌ 设置了基于数据和动画总时长的调色板限制。调色板限制经过缩放，使得在运行的初期可以看到更多细节，但我们可以根据感兴趣的特征进行调整。
- en: '**NOTE**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See the online supplement at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)
    *for the resulting animation, along with full-color versions of the figures.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看在线补充内容，了解生成的动画，以及图表的全彩图版，链接见* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)
    *。*'
- en: The final call saves the animation as an MP4 file. Other options that will work
    with `Reel` are `gif` and `webm`. To create these file types, we merely need to
    use the appropriate file ending.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调用将动画保存为MP4文件。`Reel`支持的其他选项包括`gif`和`webm`。要创建这些文件类型，我们只需使用适当的文件扩展名。
- en: '**Solving Differential Equations with DifferentialEquations**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用DifferentialEquations求解微分方程**'
- en: Since the 18th century, differential equations have been the language of physical
    science and engineering, and of the quantitative aspects of other sciences as
    well. Julia’s `DifferentialEquations` package is a massive, state-of-the-art facility
    for solving many types of differential equations using a multitude of methods.
    It incorporates recent research on the use of machine learning to apply the best
    line of attack for solving a given equation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 自18世纪以来，微分方程一直是物理科学和工程学，以及其他科学定量分析的语言。Julia的`DifferentialEquations`包是一个强大、先进的工具，用于使用多种方法求解许多类型的微分方程。它还结合了关于机器学习的最新研究，以选择解决给定方程的最佳方法。
- en: This section introduces the use of `DifferentialEquations` by solving an example
    problem. Interested readers can delve into its detailed documentation for more
    information (see “Further Reading” on [page 304](ch09.xhtml#fur9)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过解决一个示例问题介绍了如何使用`DifferentialEquations`。有兴趣的读者可以深入查阅其详细文档获取更多信息（请参阅[第304页](ch09.xhtml#fur9)的“进一步阅读”）。
- en: '***Defining the Physics Problem and Its Differential Equation***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义物理问题及其微分方程***'
- en: As an example, let’s investigate the pendulum. [Figure 9-7](ch09.xhtml#ch9fig7)
    diagrams the problem and defines the string length (*L*) and the angle (*θ*).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们来研究摆锤问题。[图9-7](ch09.xhtml#ch9fig7)展示了问题的图示，并定义了弦长(*L*)和角度(*θ*)。
- en: '![Image](../images/ch09fig07.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch09fig07.jpg)'
- en: '*Figure 9-7: The pendulum system*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-7：摆锤系统*'
- en: We measure *θ* counterclockwise from the vertical reference line, which is dotted
    in the diagram, and the gravitational acceleration points down.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从竖直参考线开始逆时针测量*θ*，该线在图中为虚线，重力加速度指向下方。
- en: '**NOTE**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* Luxor *program that produced the diagram is available in the code section
    of the Physics chapter on the online supplement at* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成该图表的* Luxor *程序可在在线补充内容的物理章节代码部分找到，链接见* [https://julia.lee-phillips.org](https://julia.lee-phillips.org)*。*'
- en: A straightforward analysis of the forces on the pendulum bob (the black circle
    in the diagram) and Newton’s Second Law leads to the differential equation
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对摆锤摆球（图中的黑色圆圈）上的力进行简单分析，并应用牛顿第二定律，得到微分方程
- en: '![Image](../images/295math.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/295math.jpg)'
- en: which is derived in any introductory general physics text. Here *t* is time
    and *g* is the gravitational acceleration. The usual next step is to confine the
    problem to small angles (≲ 5^°), where sin(*θ*) ≈ *θ*, and solve the resulting
    differential equation for simple harmonic motion. We’re going to solve the “exact”
    pendulum equation numerically, using the `DifferentialEquations` package. We’ll
    be able to examine the solution for any initial *θ*, up to π radians.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在任何基础通用物理教材中得出的。在这里，*t*是时间，*g*是重力加速度。通常的下一步是将问题限制在小角度（≲ 5°）范围内，此时sin(*θ*)
    ≈ *θ*，并求解得到简谐运动的差分方程。我们将使用`DifferentialEquations`包数值求解“精确的”摆动方程。我们将能够检查任何初始*θ*的解，直到π弧度。
- en: 'The package works with systems of first-order equations, which means differential
    equations limited to first derivatives of the unknown function. To handle the
    pendulum equation, therefore, we first need to cast it into the form of two coupled
    first-order equations. This first step is also part of many analytic solution
    methods. We can proceed easily by defining a new variable:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该包处理一阶方程组，这意味着差分方程仅限于未知函数的一阶导数。因此，为了处理摆动方程，我们首先需要将其转化为两个耦合的一阶方程的形式。这一步也是许多解析解法的一部分。我们可以通过定义一个新变量轻松进行：
- en: '![Image](../images/295math1.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/295math1.jpg)'
- en: Now we’re solving for two functions of time, the angle *θ*(*t*) and the angular
    velocity *ω*(*t*).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要求解两个随时间变化的函数，角度*θ*(*t*)和角速度*ω*(*t*)。
- en: '***Setting Up the Problem***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置问题***'
- en: 'The first step in translating the mathematical problem into a form that `DifferentialEquations`
    can digest is to define a Julia function of four positional arguments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将数学问题转化为`DifferentialEquations`能处理的形式的第一步是定义一个有四个位置参数的Julia函数：
- en: du  An array for the derivatives of the solutions
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: du   解的导数数组
- en: u   An array for the solution functions
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: u   解函数的数组
- en: p   An array of parameters
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: p   参数数组
- en: t   The time
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: t   时间
- en: '[Listing 9-8](ch09.xhtml#ch9lis8) is the version for the pendulum problem.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-8](ch09.xhtml#ch9lis8) 是摆动问题的版本。'
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 9-8: The Julia version of the pendulum equation*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-8：摆动方程的Julia版本*'
- en: This is a mutating function, as indicated by the exclamation point, because
    as the calculation progresses, the solution engine mutates the `u` and `du` arrays
    to hold the results. Here `L` and `g` are set through destructuring the array
    `p`, and θ and ω are read from the array `u`. The solver from `DifferentialEquations`
    will repeatedly call `pendulum!()` as it builds up the solution, passing in `p`,
    `t`, and the developing solution arrays themselves.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个变异函数，如感叹号所示，因为随着计算的进行，解算引擎会变异`u`和`du`数组来存储结果。这里通过解构数组`p`来设置`L`和`g`，而θ和ω则从数组`u`中读取。`DifferentialEquations`中的求解器会在构建解的过程中反复调用`pendulum!()`，并传入`p`、`t`以及正在发展的解数组。
- en: '***Solving the Equation System***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***求解方程组***'
- en: To calculate the solution, we first define the computational problem and then
    pass that problem to the `solve()` function. The components of the computational
    problem are the parameter array, the initial conditions, the time span over which
    we want the solution, and the function that defines the differential equations
    to be solved, in this example `pendulum!()`. Other options include such things
    as the numerical method to be employed, but in this simple example we’ll leave
    those options unspecified. The package generally does an excellent job of choosing
    the solution method best suited to the nature of the equations we present to it.
    [Listing 9-9](ch09.xhtml#ch9lis9) shows the problem set up and initiated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算解，我们首先定义计算问题，然后将该问题传递给`solve()`函数。计算问题的组成部分包括参数数组、初始条件、我们希望得到解的时间范围，以及定义待求解差分方程的函数，在这个例子中是`pendulum!()`。其他选项包括要使用的数值方法，但在这个简单的例子中我们将不指定这些选项。该包通常会很好地选择最适合我们所提供方程性质的解法。[列表
    9-9](ch09.xhtml#ch9lis9) 显示了问题的设置和初始化。
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 9-9: Solving differential equations using* DifferentialEquations'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：使用* DifferentialEquations *求解差分方程*'
- en: 'The only two functions in this section from the `DifferentialEquations` package
    are `ODEProblem()` and `solve()`. `ODEProblem()` takes four positional arguments:
    the function defining the equation system, an array of initial conditions, the
    time span, and the parameter array. We defined the function in [Listing 9-8](ch09.xhtml#ch9lis8)
    and we define the other three arguments here. Allowing the solver to pass the
    parameters as arguments makes it convenient to generate families of solutions
    with a range of parameters.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中来自`DifferentialEquations`包的唯一两个函数是`ODEProblem()`和`solve()`。`ODEProblem()`接受四个位置参数：定义方程系统的函数、初始条件数组、时间跨度和参数数组。我们在[清单
    9-8](ch09.xhtml#ch9lis8)中定义了该函数，这里定义了其他三个参数。允许求解器将参数作为参数传递，使得生成具有不同参数范围的解集变得方便。
- en: The result returned by `ODEProblem()` contains the complete solutions of all
    functions (in this example, two) bundled into a data type defined in the package.
    This data type is designed to make it easy to examine and plot the solutions,
    and it contains, in addition to the computed functions, information about the
    problem and the calculation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`ODEProblem()`返回的结果包含了所有函数的完整解（在这个例子中是两个），并将它们打包成包中定义的数据类型。这个数据类型设计用于便于检查和绘制解，它包含了计算的函数，以及关于问题和计算的其他信息。'
- en: '***Examining the Solutions***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查解***'
- en: For small angles, the analytic solution to our pendulum problem is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小角度，摆动问题的解析解为：
- en: '![Image](../images/297math.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/297math.jpg)'
- en: where *θ*[0] is the initial angle. The initial conditions in [Listing 9-9](ch09.xhtml#ch9lis9)
    have the pendulum at rest with a starting angle of 5°, so the small angle approximation
    should be valid.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*θ*[0]是初始角度。[清单 9-9](ch09.xhtml#ch9lis9)中的初始条件设置了摆动处于静止状态，起始角度为5°，因此小角度近似应该有效。
- en: Since we know the analytic solution, we can check the numerical result against
    it. [Listing 9-10](ch09.xhtml#ch9lis10) shows how we can plot one against the
    other.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道解析解，我们可以将数值结果与之进行对比。[清单 9-10](ch09.xhtml#ch9lis10)展示了如何将两者绘制在一起。
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 9-10: Solving for the small angle case*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-10：求解小角度情况*'
- en: The first `plot()` call uses only one data argument, the solution itself, assigned
    to `sol5d` in [Listing 9-9](ch09.xhtml#ch9lis9). This is neither an array nor
    a function, yet `plot()` seems to know how to display it. The first keyword argument,
    `idxs`, requests that (in this case) the first function, *θ*, is plotted. `idxs`
    does not appear in the documentation for the `Plots` package, and in fact is not
    defined in that package. Thus, it has no effect unless we first import `DifferentialEquations`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`plot()`调用只使用一个数据参数，即解本身，在[清单 9-9](ch09.xhtml#ch9lis9)中被赋值给`sol5d`。这既不是数组，也不是函数，但`plot()`似乎知道如何显示它。第一个关键字参数`idxs`请求绘制（在本例中）第一个函数*θ*。`idxs`在`Plots`包的文档中没有出现，实际上在该包中并没有定义。因此，除非我们首先导入`DifferentialEquations`，否则它没有任何效果。
- en: The plot, shown in [Figure 9-8](ch09.xhtml#ch9fig8), gives us confidence that
    we’ve set up the problem correctly and that the numerical solution methods are
    working.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 9-8](ch09.xhtml#ch9fig8)所示，该图使我们确信我们已经正确设置了问题，且数值解法是有效的。
- en: '![Image](../images/ch09fig08.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig08.jpg)'
- en: '*Figure 9-8: Checking the small angle solution of the pendulum equation*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：检查摆动方程的小角度解*'
- en: Plotting the solution as we did here does not simply plot the solution arrays.
    It also interpolates between calculated values in order to generate a smooth plot.
    In this case, the solution contains only 83 points, which, if plotted directly,
    would make a coarse graph.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们这里所做的那样绘制解，并不仅仅是直接绘制解数组。它还会在计算值之间进行插值，以生成平滑的图形。在这个例子中，解只包含83个数据点，如果直接绘制，将生成一个粗糙的图表。
- en: 'Although the solution objects are not arrays, the package defines methods for
    indexing that make it convenient to extract the data. If we do want access to
    the uninterpolated solution data, we can get it by indexing. Here, `sol5d[1, :]`
    returns a `Vector` of the 83 points for the first variable, *θ*, and `sol5d[2,
    :]` for the second, *ω*. To get the times at which these values are defined, we
    use a property: `sol5d.t`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解对象不是数组，但该包定义了索引方法，方便提取数据。如果我们确实需要访问未插值的解数据，可以通过索引获取。在这里，`sol5d[1, :]`返回第一个变量*θ*的83个数据点，而`sol5d[2,
    :]`返回第二个变量*ω*的83个数据点。要获取这些值定义的时间，我们可以使用一个属性：`sol5d.t`。
- en: Using the solution objects as functions returns the result interpolated to the
    time passed as an argument. (We’re using time in this section, but in other problems
    the independent variable may be something else.) The `sol5d(1.3)` function call
    returns a `Vector` of two elements, one for each variable, interpolated to the
    time 1.3\. These functions accept ranges and arrays as well, so `sol5d(0:0.1:1)`
    returns the interpolated solution data at 11 times from 0 to 1\. To extract just
    the angle variable at these times, we can call `sol5d(0:0.1:1)[1, :]`. Controlling
    the density of the interpolation by using the functional form of the solution
    objects can be helpful when making, for example, scatterplots, where we need to
    control the density of plotted points.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将解对象作为函数使用时，会返回插值结果，插值时间作为参数传入。（我们在本节中使用的是时间，但在其他问题中，独立变量可能是其他内容。）`sol5d(1.3)`函数调用返回一个包含两个元素的`Vector`，每个元素对应一个变量，插值到时间1.3。
    这些函数也接受范围和数组，因此`sol5d(0:0.1:1)`返回在0到1之间11个时刻的插值解数据。要提取这些时刻的角度变量，我们可以调用`sol5d(0:0.1:1)[1,
    :]`。通过使用解对象的函数形式来控制插值的密度，在绘制例如散点图时非常有帮助，因为我们需要控制绘制点的密度。
- en: How does the solution depend on the initial angle? Redefining `u0` to try two
    larger initial angles, and proceeding as in [Listing 9-10](ch09.xhtml#ch9lis10)
    to generate two new solutions, we get the results shown in [Figure 9-9](ch09.xhtml#ch9fig9).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解的结果如何依赖于初始角度？通过重新定义`u0`以尝试两个较大的初始角度，并按照[清单 9-10](ch09.xhtml#ch9lis10)的方式生成两个新的解，我们得到了如[图
    9-9](ch09.xhtml#ch9fig9)所示的结果。
- en: '![Image](../images/ch09fig09.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch09fig09.jpg)'
- en: '*Figure 9-9: The pendulum with larger initial angles*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：具有较大初始角度的摆*'
- en: 'The 90° solution, with the pendulum string initially horizontal, appears approximately
    sinusoidal, but with the frequency around 25 percent lower than the small angle
    case. When the initial angle is 175°, the period is nearly three times the small
    angle period, and the solution is clearly far from sinusoidal. In generating [Figure
    9-9](ch09.xhtml#ch9fig9), we limit the range of the independent variable by passing
    another `DifferentialEquations`-defined keyword to `plot()`: `tspan=(0, 10)`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始角度为90°时，摆绳最初水平，解的形状近似为正弦波，但其频率比小角度情况下低大约25%。当初始角度为175°时，周期几乎是小角度周期的三倍，解明显远离正弦波形。在生成[图
    9-9](ch09.xhtml#ch9fig9)时，我们通过传递另一个由`DifferentialEquations`定义的关键字`tspan=(0, 10)`给`plot()`来限制自变量的范围。
- en: '***Defining Time-Dependent Parameters***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义时间依赖参数***'
- en: By replacing one or more of the constant parameters in the `p` array with functions
    of time, we can study the system’s response to time-dependent parameters. In this
    way we can include inhomogeneous terms in the differential equations, forcing
    functions, and time-varying parameters in general.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`p`数组中的一个或多个常数参数替换为时间的函数，我们可以研究系统对时间依赖参数的响应。通过这种方式，我们可以在微分方程中包含非齐次项、强迫函数和时间变化的参数。
- en: 'Let’s find out what happens if we pull up on the string steadily as the pendulum
    oscillates. We’ll start at 45° and calculate the solution over 10 seconds, replacing
    the constant `L` by a linearly decreasing function of time:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如果在摆动时稳定地拉动绳子会发生什么。我们将从45°开始，计算10秒内的解，将常数`L`替换为一个线性递减的时间函数：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to create a slightly different version of our `pendulum()` function,
    shown in [Listing 9-11](ch09.xhtml#ch9lis11), that can use the time-dependent
    string length.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个稍微不同版本的`pendulum()`函数，如[清单 9-11](ch09.xhtml#ch9lis11)所示，该版本可以使用时间变化的摆绳长度。
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 9-11: The pendulum function with a time-dependent* L'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：具有时间依赖的L的摆函数*'
- en: The only change we made to the previous function is replacing `L` with `L(t)`
    ➊. We proceed just as before. The `ODEProblem()` function needs a new parameter
    array, shown in [Listing 9-12](ch09.xhtml#ch9lis12), to pass in to `pendulum2()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对之前的函数所做的唯一更改是将`L`替换为`L(t)` ➊。接下来的步骤和之前一样。`ODEProblem()`函数需要一个新的参数数组，见[清单
    9-12](ch09.xhtml#ch9lis12)，用于传递给`pendulum2()`。
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 9-12: Getting the numerical solution with a time-varying* L'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：使用时间变化的L获得数值解*'
- en: The ease of generalizing the problem to include a time-varying parameter clarifies
    the advantages of the parameter-passing approach in `Differential` `Equations`.
    The result, in [Figure 9-10](ch09.xhtml#ch9fig10), shows a steadily decreasing
    period and amplitude with an increasing angular velocity (*ω*).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题推广到包括时变参数的方式简化了`微分方程`中参数传递方法的优势。结果，在[图9-10](ch09.xhtml#ch9fig10)中，显示了随着角速度（*ω*）的增加，周期和幅度稳步减小。
- en: '![Image](../images/ch09fig10.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch09fig10.jpg)'
- en: '*Figure 9-10: Pulling up the string on the pendulum*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-10：摆钟上拉绳子的动作*'
- en: 'We create [Figure 9-10](ch09.xhtml#ch9fig10) with the following calls:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下调用生成[图9-10](ch09.xhtml#ch9fig10)：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the call to `plot!()`, the first argument, `twinx()`, creates a subplot overlay
    that shares the horizontal axis with the first plot and draws a new vertical axis;
    we use it so the two curves don’t have to share the same scale. We need some extra
    room on the right ➊ for the labels on the second vertical axis. This margin setting
    requires the import of `Plots.PlotMeasures`, as explained in “Working with Plot
    Settings” on [page 101](ch04.xhtml#ch04lev7).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`plot!()`的调用中，第一个参数`twinx()`创建了一个子图重叠，分享第一个图的水平轴并绘制一个新的垂直轴；我们使用它是为了让两条曲线不必共享同一个比例尺。右侧需要额外的空间➊来为第二个垂直轴上的标签留出位置。这个边距设置需要导入`Plots.PlotMeasures`，正如在[第101页](ch04.xhtml#ch04lev7)“与图表设置一起工作”中解释的那样。
- en: '***Parametric Instability***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***参数不稳定性***'
- en: A child “pumping” a swing in the playground to get it moving is exploiting a
    *parametric instability*. The driver of this instability is the periodic change
    in the effective length of the pendulum string. The results of linear theory (the
    small angle version of the differential equation that we’re attacking in this
    section) tell us that a resonance occurs when the forcing frequency is twice the
    natural frequency of the pendulum, which, using our *L* = 1, is ![Image](../images/300math.jpg).
    If the string length is perturbed sinusoidally at this frequency, the amplitude
    of small oscillations will increase exponentially.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个孩子在操场上“推动”秋千使其摆动，实际上是在利用*参数不稳定性*。这种不稳定性的驱动因素是摆钟绳子有效长度的周期性变化。线性理论（我们在本节中正在攻克的微分方程的小角度版本）告诉我们，当驱动力频率是摆钟固有频率的两倍时，就会发生共振，利用我们的*L*
    = 1，可以得到![Image](../images/300math.jpg)。如果绳子的长度在这个频率下做正弦扰动，小幅度振荡的幅度会指数级增长。
- en: 'Since we know how to insert any time-dependent function *L*(*t*) into the numerical
    solution, we can investigate the response of the pendulum to parametric excitation
    beyond the small angle approximation. We’ll start with a small initial angle,
    follow the evolution for a longer span, and define a new function of time for
    the string length:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何将任何时变函数*L*(*t*)插入到数值解中，因此我们可以研究摆钟对超出小角度近似的参数激励的响应。我们将从一个小的初始角度开始，跟踪其演化一段较长的时间，并定义一个新的时间函数来表示绳子的长度：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Lt(t)` will perturb the nominal length of 1 meter by 10 percent at the frequency
    of parametric resonance.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lt(t)`将按照参数共振的频率，将名义上1米的长度扰动10%。'
- en: 'Our work proceeds exactly as before, with one adjustment. We use `pendulum2()`,
    defined in [Listing 9-11](ch09.xhtml#ch9lis11), and set up the problem as in [Listing
    9-12](ch09.xhtml#ch9lis12). The adjustment is that we need to supply a keyword
    argument to the solving function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作与之前完全相同，只是做了一些调整。我们使用`pendulum2()`，它在[清单9-11](ch09.xhtml#ch9lis11)中定义，并像[清单9-12](ch09.xhtml#ch9lis12)中那样设置问题。调整之处在于，我们需要向求解函数提供一个关键字参数：
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `reltol` parameter adjusts the adaptive timestepping as needed to limit
    the local error to the value that we supply. Its default of 0.001 led to a solution
    that seemed suspicious, as it was not quite periodic. I generated solutions with
    `reltol` = 1e–4, 1e–5, and 1e–6\. The 1e–4 solution looked reasonable, but the
    1e–5 solution was slightly different. As the solution with `reltol` = 1e–6 looked
    identical to the one at 1e–5, they’re probably accurate. [Figure 9-11](ch09.xhtml#ch9fig11)
    shows the resulting graph of *θ* versus time.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`reltol`参数根据需要调整自适应时间步进，以限制局部误差达到我们提供的值。它的默认值为0.001，这导致一个看起来有些可疑的解，因为它并不完全是周期性的。我生成了`reltol`
    = 1e–4、1e–5和1e–6的解。1e–4的解看起来合理，但1e–5的解略有不同。由于`reltol` = 1e–6的解与1e–5的解几乎相同，因此它们可能是准确的。[图9-11](ch09.xhtml#ch9fig11)显示了*θ*与时间的关系图。'
- en: '![Image](../images/ch09fig11.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch09fig11.jpg)'
- en: '*Figure 9-11: Parametric instability of the finite-angle pendulum*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-11：有限角度摆钟的参数不稳定性*'
- en: Initially, the amplitude increases exponentially, as predicted by the linear
    theory. But we know from our previous solutions that the frequency of the pendulum
    decreases with amplitude; therefore, it moves continuously out of resonance with
    the forcing function, and the amplitude decreases back to close to its initial
    value. At that point it’s closer to resonance, and the amplitude again grows exponentially.
    As the solution shows, the process repeats.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，振幅呈指数增长，符合线性理论的预测。但我们从之前的解中知道，摆的频率随着振幅的增大而减小；因此，它会持续地与强迫函数失去共振，振幅回落到接近初始值。到那个时候，它会更接近共振，振幅再次呈指数增长。正如解所示，这个过程会重复发生。
- en: '***Combining DifferentialEquations with Measurements***'
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结合微分方程与测量***'
- en: 'Suppose we want to verify the predictions of our pendulum solutions with an
    experiment. There will be some error inherent in the setting of the initial angle.
    If we estimate that uncertainty to be one degree, we might think to state the
    initial conditions this way (see “Error Propagation with Measurements” on [page
    280](ch09.xhtml#ch09lev2)):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想通过实验验证我们的摆动解决方案的预测。在设置初始角度时会存在一些误差。如果我们估计这个不确定度为一度，我们可能会考虑这样陈述初始条件（请参见[第
    280 页](ch09.xhtml#ch09lev2)的“测量误差传播”）：
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function `deg2rad()` converts from degrees to radians.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `deg2rad()` 将角度从度转换为弧度。
- en: We can proceed exactly as before, repeating the procedure shown in [Listings
    9-8](ch09.xhtml#ch9lis8) and [9-9](ch09.xhtml#ch9lis9). A plot of the solution
    for *θ*(*t*) now looks like [Figure 9-12](ch09.xhtml#ch9fig12).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样继续操作，重复[列表 9-8](ch09.xhtml#ch9lis8)和[9-9](ch09.xhtml#ch9lis9)中展示的过程。现在，*θ*(*t*)的解的图像如[图
    9-12](ch09.xhtml#ch9fig12)所示。
- en: '![Image](../images/ch09fig12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch09fig12.jpg)'
- en: '*Figure 9-12: Combining* DifferentialEquations *with* Measurements'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-12：结合* 微分方程 *与* 测量'
- en: Although we don’t tell the `plot()` function anything about drawing error bars,
    they appear in the plot. The plot shows how the error in the angular position
    grows, on average, over time. The error doesn’t grow monotonically, however. It
    decreases when the exact solution and those at the limits of the error bound happen
    to be in phase.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有告诉 `plot()` 函数任何有关绘制误差条的内容，但它们还是出现在了图表中。图表显示了角位置的误差如何随着时间的推移平均增长。然而，误差并不是单调增长的。当精确解和误差范围的极限解恰好同相时，误差会减小。
- en: 'We generate the solution and plot it in [Figure 9-12](ch09.xhtml#ch9fig12)
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成解并在[图 9-12](ch09.xhtml#ch9fig12)中绘制它，具体过程如下：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since `DifferentialEquations` places an error on every point of the solution,
    including the points interpolated when creating a plot, we have to use the technique
    described in “Examining the Solutions” on [page 297](ch09.xhtml#ch09lev1sec17)
    to limit the number of points plotted; otherwise, the plot becomes too crowded
    with error bars and is impossible to interpret.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DifferentialEquations` 在解的每个点上都附加了误差，包括在绘制图形时插值的点，我们必须使用在[第 297 页](ch09.xhtml#ch09lev1sec17)的“检查解”部分描述的技术来限制绘制的点的数量；否则，图表会因为误差条过于密集而无法解释。
- en: '**Conclusion**'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Although we delved into several physics packages at some length in this chapter,
    we really only scratched their surfaces. I hope, however, that the introductions
    here are sufficient to help you assess whether any of the packages explored in
    this chapter might be a good choice for your projects and to show you how to get
    started.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中详细探讨了几个物理包，但实际上我们只是略微触及了它们的表面。然而，我希望这里的介绍足以帮助你评估本章中探讨的任何包是否适合你的项目，并向你展示如何开始使用它们。
- en: Another purpose of this chapter is to serve as an introduction to a superpower
    of Julia and the Julia ecosystem. In several examples we were able to combine
    the abilities of two or three packages without making any particular arrangements
    to do so. We made plots and typeset expressions that contained units, and saw
    that they were handled sensibly. We handed the output of a differential equation
    solver to a plotting function from a different package, and it extracted the relevant
    data and plotted it. We solved differential equations with error estimates in
    their initial conditions, and the error was propagated through the solution correctly.
    We plotted *this* result, and, as if by magic, the solution displayed error bars.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We wrote scripts and programs that combined the abilities of five packages in
    various combinations, giving them capabilities neither envisioned nor planned
    by their authors. Most of these packages were written without any knowledge of
    the others that we combined them with. The authors of these packages wrote their
    code in a generic way that allows Julia’s type system and its method of multiple
    dispatch to enable its functions to work with data types defined in other packages.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia initially attracted attention as a language that was as easy to pick
    up and be productive in as a high-level interpreted language, but one that was
    fast enough for the most demanding scientific work: “as easy as Python and as
    fast as Fortran.” The second reason for Julia’s increasing adoption in the sciences
    is its ability to combine the abilities of disparate packages with no additional
    work on the part of the application programmer. Julia creators and package authors
    refer to this property as the *composability* of packages, in analogy with the
    composition of functions.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub community “Julia’s Physics Ecosystem” ([*https://juliaphysics.github.io/latest/ecosystem/*](https://juliaphysics.github.io/latest/ecosystem/))
    maintains a convenient list of packages related to all areas of physics, and includes
    related packages for mathematics and plotting.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Unitful` package is available at [*https://github.com/PainterQubits/Unitful.jl*](https://github.com/PainterQubits/Unitful.jl).
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [*https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/*](https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/)
    for details on how a mixup in units destroyed the Mars Climate Orbiter.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for `UnitfulLatexify` is at [*https://gustaphe.github.io/UnitfulLatexify.jl/dev/*](https://gustaphe.github.io/UnitfulLatexify.jl/dev/).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Measurements` package resides at [*https://github.com/JuliaPhysics/Measurements.jl*](https://github.com/JuliaPhysics/Measurements.jl).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started with `Oceananigans`, see [*https://clima.github.io/OceananigansDocumentation/stable/quick_start/*](https://clima.github.io/OceananigansDocumentation/stable/quick_start/).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DifferentialEquations.jl` documentation is available at [*https://diffeq.sciml.ai/stable/*](https://diffeq.sciml.ai/stable/).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DifferentialEquations.jl`的文档可以在[*https://diffeq.sciml.ai/stable/*](https://diffeq.sciml.ai/stable/)查阅。'
- en: Animations, color images, and supplementary code for this chapter are available
    at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节的动画、彩色图像和补充代码可在[*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)找到。
- en: You can find simple examples of the use of `DifferentialEquations.jl` at [*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)
    and [*https://lwn.net/Articles/834571/*](https://lwn.net/Articles/834571/).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[*https://lwn.net/Articles/835930/*](https://lwn.net/Articles/835930/)和[*https://lwn.net/Articles/834571/*](https://lwn.net/Articles/834571/)找到`DifferentialEquations.jl`使用的简单示例。
- en: The parametric instability of a pendulum is demonstrated in the video at [*https://www.youtube.com/watch?v=dGE_LQXy6c0*](https://www.youtube.com/watch?v=dGE_LQXy6c0).
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆的参数不稳定性在视频[*https://www.youtube.com/watch?v=dGE_LQXy6c0*](https://www.youtube.com/watch?v=dGE_LQXy6c0)中展示。
- en: The theory of parametric resonance for the general harmonic oscillator is treated
    at [*https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf*](https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般谐振子参数共振的理论在[*https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf*](https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf)中进行了讨论。
