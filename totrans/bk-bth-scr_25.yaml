- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 22 WRITING REPORTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even if squinting hard enough to provoke an aneurysm, no one will ever mistake
    Batch for Power BI or other similar report writers, but when you want a simple
    formatted text report, Batch is one tool that’s up to the challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll build a report with real-world data from a pipe-delimited
    input file. With two pseudo-environment variables from the previous chapter, you’ll
    learn how to build a title with the current date and time, and formatted column
    headers. You’ll also create detail records by reading the input file with a certain
    command you learned about in [Part II](part2.xhtml). I’ll share a few techniques
    for right- and left-justifying strings, integers, and floating-point data into
    nicely aligned columns when viewed in a fixed-width or monospace font. Finally,
    you’ll learn how to tally the data to create trailer records with total and average
    quantities.
  prefs: []
  type: TYPE_NORMAL
- en: And if you are looking to generate a pie graph, histogram, or scatter- plot
    ... there are other tools.
  prefs: []
  type: TYPE_NORMAL
- en: The Data and Report
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this exercise, we’ll start with a simple pipe-delimited file containing
    three important health measures for a short list of selected wealthy countries
    from the year 2019\. The first token in each record is the name of a country,
    followed by the percentage of the country’s gross domestic product spent on healthcare.
    This is a great measure of how much money a country spends on healthcare out of
    its overall wealth. The third token is life expectancy, and the final is the number
    of avoidable deaths for every 100,000 residents. Avoidable deaths are defined
    as deaths resulting from a lack of access to effective and quality healthcare
    for conditions such as diabetes, hypertension, and certain cancers. These last
    two measures are very good indicators of the effectiveness of a healthcare system.
    The *HealthStats.dat* file can hold any number of records, but for brevity’s sake,
    I’m including only seven countries and their statistics, as shown in [Listing
    22-1](#Lis22-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-1: The pipe-delimited HealthStats.dat file containing health statistics'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the first two numeric tokens are floating-point values, but someone
    (me) didn’t include the .0 for a couple of entries’ values. We’ll have to take
    that into account in the code. (The data in this file is from the Commonwealth
    Fund, used with permission, at *[https://<wbr>www<wbr>.commonwealthfund<wbr>.org<wbr>/publications<wbr>/issue<wbr>-briefs<wbr>/2020<wbr>/jan<wbr>/us<wbr>-health<wbr>-care<wbr>-global<wbr>-perspective<wbr>-2019](https://www.commonwealthfund.org/publications/issue-briefs/2020/jan/us-health-care-global-perspective-2019)*.)
  prefs: []
  type: TYPE_NORMAL
- en: It’s wonderful data, but pipe-delimited files are not known for their readability.
    Our task is to convert the data in [Listing 22-1](#Lis22-1) into the far more
    readable and descriptive report shown in [Listing 22-2](#Lis22-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 22-2: The HealthRpt.txt bat file–generated report'
  prefs: []
  type: TYPE_NORMAL
- en: At worst, you might call this report functional. It doesn’t have the different
    font sizes, boxes, highlighting, automatic centering, or other features you might
    find in an HTML-created report viewed in a browser, but it’s useful, informative,
    and well-formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'A report such as this has three distinct parts: introduction, body, and summary,
    consisting of header, detail, and trailer records, respectively. I’ll share the
    entire bat file to build this report, but I’ll break it down into those three
    parts. At the conclusion of this chapter, you’ll be able to build your own data
    files and create your own reports.'
  prefs: []
  type: TYPE_NORMAL
- en: Header Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The obvious place to start is with the introduction, which consists of the
    title and column headers. Here’s the first part of the bat file that creates the
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the opening setlocal command, we define the rpt variable ❶ with the path
    and name of the report file. I’m keeping the variable name succinct because we’ll
    be using it every time we write a record to the report, which will be often. Next,
    we initialize four variables ❷ to 0. The cnt variable keeps a count of the number
    of detail records, and the other variables are totals for each of the three quantities
    in the report, which we’ll use in the next two sections of the bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction is actually composed of two parts: the title ❸ and the column
    headers ❹. In this particular report, they account for seven header records overall,
    and we’ll create them with seven echo commands redirected to the report file.'
  prefs: []
  type: TYPE_NORMAL
- en: We start the report by redirecting the beginning of the title to the file defined
    by the rpt variable ❸; a single redirection character is used for only this command,
    so if an existing file is present, we overwrite it. We next append the remainder
    of the title, followed by the date and time and a blank line with the echo. command.
  prefs: []
  type: TYPE_NORMAL
- en: We’re populating the date and time in the third record from the aptly named
    date and time variables, respectively. These pseudo-environment variables introduced
    in [Chapter 21](chapter21.xhtml) offer an easy way of documenting when the report
    was generated. Notice I’m extracting portions of each value to remove the day
    of the week from the date and the seconds from the time. Sometimes there’s such
    a thing as too much data.
  prefs: []
  type: TYPE_NORMAL
- en: The final three echo commands are writing out the column headers ❹. Most of
    this data is hardcoded, but notice that I’m escaping the percent sign with another
    percent so the interpreter doesn’t think that it’s the start of a very awkward
    variable name (see [Chapter 14](chapter14.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the data in the title and the column headers appear to be off-kilter,
    but this is just a result of variable resolution and escaping. The best way to
    line up everything is to type the title, headers, and a sample data line into
    a text file using a fixed-width font and line up everything as desired—that is,
    type up a sample of the report in [Listing 22-2](#Lis22-2). When satisfied with
    the alignment, copy the resulting headings into the bat file, preceding each with
    the redirection and an echo command. Then add any escape characters and replace
    any temporary text such as the sample date and time with the variables that will
    take their place.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this last step, let the data shift; everything will realign in the
    final output. For instance, the record with the date and time ❸ appears to be
    shifted to the right, but that’s only because the variable name with the substringing
    syntax and the encasing percent signs is longer than the time it will eventually
    display. Likewise, the extra percent sign ❹ skews the rest of the data in the
    first column header record. Life and Avoidable don’t appear to be lined up with
    the next two lines, but after the interpreter consolidates the two percent signs
    into one, everything will again realign.
  prefs: []
  type: TYPE_NORMAL
- en: Detail Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s much to unpack, but the following code writes one formatted detail
    record for each record in the input file and keeps track of the record count and
    the running totals of the three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The for /F command ❶ introduced in [Chapter 19](chapter19.xhtml) is the obvious
    solution to pull out the four tokens (tokens=1-4) from each record of the pipe-delimited
    data file (delims=|). This logic assigns the country from the data file to the
    for variable %%a, which implies that the percent of GDP is %%b, the life expectancy
    is %%c, and the number of avoidable deaths is %%d.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning Columns with Justified Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’m padding the ctry variable ❷, which contains string data, with a number of
    spaces and ultimately the text eol that doesn’t appear in the report. To make
    the columns line up, I’ll make this a left-justified field and ultimately substring
    out just its first 15 bytes, but for this to work, the field must be at least
    15 bytes in length—hence, the space padding.
  prefs: []
  type: TYPE_NORMAL
- en: The eol tag at the end is simply there to demonstrate to the reader that the
    field has trailing spaces. I’ll strip it off before writing the record, so any
    text would work, but it does stand for *end of line*. (If you are really proud
    of the report, you can sign your work by entering your name instead.) Without
    some sort of a marker, a future coder might someday remove the trailing spaces,
    especially if they’re more familiar with languages that ignore trailing spaces,
    which is almost any language not named Batch.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*In [Chapter 2](chapter2.xhtml), I mentioned that you can place an ampersand,
    or the command separator, after trailing spaces, but due to a frustrating batveat,
    that doesn’t work in a code block, or at least not the same way. The interpreter
    balks when you use the ampersand in a code block without an actual command after
    it, which means you could replace eol with &rem. In what’s even more of an oddity,
    if escaped, the ampersand works in a code block without a second command, so you
    can also replace eol with ^&.*'
  prefs: []
  type: TYPE_NORMAL
- en: Contrast the country variable with the variable corresponding to the last column
    detailing avoidable deaths per 100,000 people. Instead of trailing spaces, I’m
    adding 15 *leading* spaces to deaths ❺. This is an integer and unlike the string
    data items that we should line up by the first character, we should line up avoidable
    deaths by its final character, or the ones digit.
  prefs: []
  type: TYPE_NORMAL
- en: To right-justify a number, I do the opposite of what I did for a string. I *prepend*
    the value with a number of spaces so that I can later extract the desired text
    from the end of the field. To maintain the spaces needed for the report, I’ll
    extract 15 total bytes from this field, so if this field isn’t at least 15 bytes
    long, the resulting data will be askew.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Floating-Point Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decimal or floating-point values represent the two middle columns, and since
    we’ll be treating both the same way, I’ll focus on just one. The data in the input
    file expresses life expectancy ❹ as a decimal with a tenths place for all values
    except for Canada, which happens to be an integer, but we want a decimal place
    for each value in the report, and we want to line up the numbers on that decimal
    place.
  prefs: []
  type: TYPE_NORMAL
- en: I’m resolving life expectancy from the third token, %%c, of the outer for command
    ❶ and using it as the input string to one of the inner for commands ❹. Delimiting
    on the dot breaks the value up into the whole number before the decimal and the
    decimal part after the decimal point. I’m assigning the latter value to the dcml
    or decimal variable while appending 0. Batch syntax can be so esoteric it’s easy
    to miss, but in the four bytes %%n0, the first three are the second token of the
    inner for loop, and the last is a hardcoded number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second and final command inside the code block of the inner for command,
    I’m extracting the first byte of the decimal: !dcml:~0,1!. For most countries,
    we append 0 to the decimal value and immediately strip it off. That seems pointless
    until Canada is considered. Since its life expectancy is 82 with no decimal value
    present, the 0 tacked onto the end becomes the sole decimal byte. Finally, I string
    together the whole number, %%m, a dot, and the first digit of the decimal value.
    Lest we forget, this must all follow a number of leading spaces for right-justification.
    If we had wanted to format numbers with two decimal points, such as dollar amounts,
    we could have appended two zeros and extracted the first two bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '(In this example, %%n0 represents a for variable followed by the hardcoded
    0, but changing just one byte produces something quite different: %~n0. The n
    now turns into a modifier for the hidden parameter, %~0. Hence, %~n0 resolves
    to the extensionless name the bat file. Oh, the vagaries of Batch.)'
  prefs: []
  type: TYPE_NORMAL
- en: The logic for the percentage of each country’s GDP spent on healthcare ❸ is
    nearly identical to the logic for life expectancy. Because of how the columns
    line up, the only difference is the number of leading spaces we attach to each
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Detail Record
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These four variables culminate in the line that actually writes the formatted
    text string to the report file ❻. This is a redirection of an echo command similar
    to what we’ve seen earlier in this chapter, resolving the four variables and extracting
    portions via substringing, each separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: To left-justify the ctry variable, I use an offset of 0 and length of 15, thus
    extracting the first 15 bytes and dropping everything else (including the eol
    marker). The next three values, perGDP, lifeExp, and deaths, are to be right-justified
    numbers, so I substring with negative offsets to grab the last 5, 14, and 15 bytes,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The various lengths are dependent on the layout. The best way to format the
    detail record and determine the proper layout is to type up the same type of sample
    line I suggested for the header records. Figure out the lengths of each justified
    field, experiment, and expect the need for some tweaking. Just be careful to make
    sure there are at least *n* bytes in a string if you plan to extract *n* bytes
    from it. Put more plainly, the country is 15 bytes, so make sure you append 15
    spaces to ensure perfect alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Counters and Totals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last four lines of the code block ❼ all perform some arithmetic with the
    augmented assignment operators from [Chapter 6](chapter6.xhtml). The first is
    a simple counter, cnt, keeping track of the number of entries. The last three,
    totPerGDP, totLifeExp, and totDeaths, are cumulative totals of the three quantities
    in the report. I’ve named these variable names with tot, for *total*, prepending
    a familiar variable name.
  prefs: []
  type: TYPE_NORMAL
- en: The logic is straightforwardly incrementing the variable for total deaths by
    the number of deaths in each record. The other two are decimals, and as you learned
    in [Chapter 6](chapter6.xhtml), floating-point arithmetic requires a little ingenuity.
    The text replacement syntax removes the decimal point before adding each to the
    total—for example, !perGDP:.=!. This effectively multiples the total by 10, so
    we’ll need to address this discrepancy when calculating the averages and writing
    out the trailer records.
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t do it in this report, but you may want to create a page break after
    a certain number of detail records. Typically, you might want a page number at
    the bottom followed by a few blank lines before reproducing the headers followed
    by another page of detail lines. To do this after every 25 detail lines, interrogate
    cnt %% 25 at the end of the loop. If equal to 0, the record count is a multiple
    of 25, so you can initiate a page break. You can also create another counter for
    the page number and write it as part of the page trailer information and move
    the header logic to a callable routine so that you can invoke it one to many times.
  prefs: []
  type: TYPE_NORMAL
- en: Trailer Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third and final section of the bat file finds and formats the averages
    before writing them to the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the averages, we could simply divide the totals by the number of detail
    records, but since Batch truncates the decimal part of the solution, everything
    is in effect rounded down. To compensate, each set /A command ❶ first multiplies
    the value by 10 and divides by cnt. Adding 5 to this number corrects for the rounding
    so that dividing by 10 produces the rounded average. For example, 77.4 deaths
    should round down: 77.4 + 0.5 = 77.9, which is 77 when the decimal is truncated.
    Then 77.6 should round up: 77.6 + 0.5 = 78.1, which becomes 78\. Because we can’t
    add the decimal 0.5, we are instead multiplying by 10, adding 5, and dividing
    by 10.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section of code ❷ appends leading spaces to each of the three averages
    in anticipation of the substringing for data alignment. The final section of the
    code ❸ writes the trailer records to the report with two echo commands. The first
    writes hardcoded dashes identical to a header record. The second command replaces
    the name of a country with the hardcoded text, Averages, and the remainder of
    the command displays the three averages with such dense substringing that I’ve
    had to continue the command on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: I’m extracting the last 15 bytes from the avgDeaths variable, but since the
    other two totals are actually 10 times greater than their actual values, it follows
    that their corresponding averages, avePerGDP and aveLifeExp, are also increased
    by a factor of 10\. We can’t correct this by dividing these by 10, because that
    would lose the decimal parts. However, by inserting a decimal point into the number
    as it’s being written, we are presenting the number as it should be, effectively
    dividing by 10 while also showing the decimal part, which is a win-win. Notice
    that !avePerGDP:~-5,-1!.!avePerGDP:~-1! resolves to the four bytes prior to the
    last byte, a hardcoded dot, and that last byte.
  prefs: []
  type: TYPE_NORMAL
- en: Other datasets may lend themselves to simply displaying totals instead of averages,
    meaning that the floating-point arithmetic will be lessened or nonexistent. Even
    with this example using averages, we were able to create a fairly impressive report
    without a great deal of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I stepped through the three sections of a typical text report
    formatted with Batch. If you were expecting a nifty routine to automatically line
    up columns with ease, I’m sure I’ve disappointed you, but with a little attention
    to the details, you can create a quality report. You learned how to build a title,
    headers, any number of detail records, and a trailer record with totals and averages.
    Along the way, I demonstrated techniques for aligning columns with justified data
    items and tips for handling floating-point data. This isn’t a heavy-duty utility,
    and I’m sure that no one is making a living solely producing Batch reports, but
    when a simple text report is needed, a compiled program is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter changes gears and delves into a subject that’s dear to my
    heart: recursion. You''ll learn how to build Batch code that calls itself, along
    with some interesting applications.'
  prefs: []
  type: TYPE_NORMAL
