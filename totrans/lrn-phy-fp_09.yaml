- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: TYPE CLASSES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: We have seen functions that have a concrete type, such as `not`, which takes
    a `Bool` as input and returns a `Bool` as output. We have also seen functions
    with types that use a type variable to express that they work with all types,
    such as `head`, which takes a list of any type and returns the first element.
    Use of a type variable expresses commonality over all types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们见过具有具体类型的函数，例如`not`，它接受一个`Bool`类型作为输入，并返回一个`Bool`类型作为输出。我们也见过使用类型变量来表示它们可以处理所有类型的函数，例如`head`，它接受任何类型的列表并返回第一个元素。使用类型变量表示了所有类型之间的共性。
- en: Between the extremes of functions that work with a single type and functions
    that work with all types is a need to express a more limited commonality among
    types that does not extend to all types. For example, we would like addition to
    be available for numeric types like `Int`, `Integer`, and `Double`, without the
    need to define addition for *all* types. The term *parametric polymorphism* is
    used to express commonality among all types. The `head` function mentioned earlier
    is parametric polymorphic on the underlying type of the input list. The term *ad-hoc
    polymorphism* is used to express more limited commonality. Type classes are Haskell’s
    way of providing a mechanism for ad-hoc polymorphism. They express commonality
    among types that doesn’t extend to all types.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理单一类型的函数和处理所有类型的函数之间，我们需要表达一个更有限的类型间共性，这种共性并不适用于所有类型。例如，我们希望加法操作适用于像`Int`、`Integer`和`Double`这样的数值类型，而无需为*所有*类型定义加法。术语*参数多态性*用于表示所有类型之间的共性。之前提到的`head`函数就是对输入列表的基础类型进行参数多态性的。术语*临时多态性*则用于表示更有限的共性。类型类是Haskell提供的处理临时多态性的机制。它们表达的是类型之间的共性，而这种共性并不适用于所有类型。
- en: In this chapter, we’ll introduce the idea of a type class, along with a number
    of type classes from the Prelude. We’ll describe which of the basic types are
    members of these type classes, and why. The explanation for why Haskell has three
    different exponentiation operators is based on type classes. A *section* is a
    function based on an operator and one of its arguments, and many sections have
    types that involve type classes. While type classes provide a nice way to express
    commonality, they also allow for the possibility that the compiler cannot figure
    out concrete types for values when it needs to, and we give an example where the
    code writer must provide extra type information to the compiler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍类型类的概念，并介绍Prelude中一些常见的类型类。我们将描述哪些基本类型是这些类型类的成员，以及为什么这样设计。Haskell中有三个不同的指数运算符的解释也基于类型类。*Section*是基于一个运算符和它的一个参数构造的函数，许多section的类型涉及类型类。虽然类型类提供了一种表达共性的好方法，但它们也允许编译器在需要时无法确定值的具体类型，我们将给出一个示例，说明代码编写者必须提供额外的类型信息给编译器。
- en: Type Classes and Numbers
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型类与数字
- en: Let us begin by asking GHCi about the type of the number `4`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在GHCi中询问数字`4`的类型。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It would be entirely reasonable to expect the type of the number `4` to be `Int`
    or `Integer`. But the designers of the Haskell language wanted a number like `4`
    to be able to be an `Int`, an `Integer`, a `Double`, or even a few other types,
    depending on the programmer’s needs. For this reason (and other, more compelling
    reasons), they invented the idea of type classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 期望数字`4`的类型是`Int`或`Integer`是完全合理的。但Haskell语言的设计者希望像`4`这样的数字能够根据程序员的需要，既可以是`Int`，也可以是`Integer`，`Double`，甚至其他一些类型。正因如此（以及其他更有说服力的原因），他们发明了类型类的概念。
- en: A type class is like a club to which a type can belong, and it makes certain
    functions available to that type. The types `Int`, `Integer`, and `Double` all
    belong to the type class `Num` (short for number). Each of these types has addition,
    subtraction, and multiplication available to it because these functions are owned
    by the `Num` type class. When a type belongs to a type class, we say that it is
    an *instance* of that type class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类就像一个俱乐部，类型可以加入该俱乐部，这样类型就可以使用该俱乐部中的某些函数。`Int`、`Integer`和`Double`这些类型都属于类型类`Num`（数字类型的缩写）。这些类型都可以使用加法、减法和乘法操作，因为这些函数是由`Num`类型类提供的。当一个类型属于某个类型类时，我们称它是该类型类的*实例*。
- en: 'The type signature `4 :: Num p => p` can be read as “`4` has type `p` as long
    as `p` is in type class `Num`.” The letter `p` is a type variable in this type
    signature. It can stand for any type. The conditions to the left of the double
    arrow (`=>`) are *type class constraints*. In the type signature above, there
    is one type class constraint, `Num p`, which says that `p` must belong to type
    class `Num`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '类型签名 `4 :: Num p => p` 可以理解为 “`4` 的类型是 `p`，前提是 `p` 属于类型类 `Num`。” 字母 `p` 是这个类型签名中的类型变量，代表任何类型。双箭头
    (`=>`) 左边的条件是 *类型类约束*。在上面的类型签名中，存在一个类型类约束 `Num p`，它表示 `p` 必须属于类型类 `Num`。'
- en: Type classes are a way to express commonality among types. The types `Int`,
    `Integer`, `Float`, and `Double` have quite a bit in common; namely, we want to
    do the same sorts of things with them. We want to be able to add, subtract, and
    multiply numbers with these types. By having the type class `Num` own addition,
    subtraction, and multiplication, we allow the same addition operator that works
    with `Int`s to also work with `Double`s.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是一种表示类型之间共性的方式。类型 `Int`、`Integer`、`Float` 和 `Double` 之间有很多相似之处；也就是说，我们希望对它们执行相同类型的操作。我们希望能够对这些类型的数字进行加、减、乘等操作。通过让类型类
    `Num` 负责加法、减法和乘法，我们允许与 `Int` 类型配合使用的加法运算符同样适用于 `Double` 类型。
- en: 'In the type signature `4 :: Num p => p`, GHCi hasn’t committed to a concrete
    type for the number 4 yet. But this noncommittal attitude about the type of `4`
    can’t go on forever. At some point, the Haskell compiler will demand that every
    value have a concrete type. The inability of the compiler to assign a concrete
    type to a value can be a source of trouble. However, GHCi has some type-defaulting
    rules to make our lives easier. For example, if you put the line'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '在类型签名 `4 :: Num p => p` 中，GHCi 尚未为数字 4 确定具体类型。但这种对 4 类型的非承诺态度不能永远持续下去。最终，Haskell
    编译器将要求每个值都具有具体类型。编译器无法为值分配具体类型可能会带来麻烦。然而，GHCi 有一些类型默认规则可以让我们的生活更轻松。例如，如果你输入以下这一行'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: into a program file (say *typetest.hs*), giving `x` no type signature, load
    it into GHCi, and then ask for the type of `x`,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将其写入程序文件（如 *typetest.hs*），不给 `x` 添加类型签名，加载到 GHCi 中，然后询问 `x` 的类型，
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: GHCi will tell you that `x` has type `Integer`. Here, GHCi has committed to
    a concrete type without our specifying the type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 会告诉你 `x` 的类型是 `Integer`。在这里，GHCi 在没有我们指定类型的情况下，已经为其确定了具体的类型。
- en: There are other situations, like that in “Example of Type Classes and Plotting”
    at the end of this chapter, where GHCi feels unable to assign a concrete type,
    and you will need to help it out by adding type signatures to your code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他情况，比如在本章末尾的“类型类与绘图示例”中，GHCi 无法分配具体类型，在这种情况下，你需要通过为代码添加类型签名来帮助它。
- en: Type Classes from the Prelude
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Prelude 中的类型类
- en: '[Table 8-1](ch08.xhtml#ch8tab1) shows several type classes provided by the
    Prelude. The table also shows which of the basic types are instances of each of
    the type classes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.xhtml#ch8tab1) 显示了 Prelude 提供的几个类型类。该表还显示了哪些基本类型是每个类型类的实例。'
- en: '**Table 8-1:** Basic Types That Are Instances of Various Type Classes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 各种类型类的实例基本类型'
- en: '| **Type class** | `Bool` | `Char` | `Int` | `Integer` | `Float` | `Double`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **类型类** | `Bool` | `Char` | `Int` | `Integer` | `Float` | `Double` |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `Eq` | X | X | X | X | X | X |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `Eq` | X | X | X | X | X | X |'
- en: '| `Ord` | X | X | X | X | X | X |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Ord` | X | X | X | X | X | X |'
- en: '| `Show` | X | X | X | X | X | X |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Show` | X | X | X | X | X | X |'
- en: '| `Num` |  |  | X | X | X | X |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Num` |  |  | X | X | X | X |'
- en: '| `Integral` |  |  | X | X |  |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `Integral` |  |  | X | X |  |  |'
- en: '| `Fractional` |  |  |  |  | X | X |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Fractional` |  |  |  |  | X | X |'
- en: '| `Floating` |  |  |  |  | X | X |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Floating` |  |  |  |  | X | X |'
- en: The following sections discuss the purpose and use of the type classes listed
    in [Table 8-1](ch08.xhtml#ch8tab1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将讨论 [表 8-1](ch08.xhtml#ch8tab1) 中列出的类型类的用途和使用方法。
- en: The Eq Type Class
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Eq 类型类
- en: We want to be able to ask the computer whether two things are equal. That’s
    what the `==` (equality) operator (first introduced in [Table 1-2](ch01.xhtml#ch1tab2))
    does. But if we are serious about functions having types, what should the type
    of `(==)` be?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够询问计算机两个事物是否相等。这就是 `==`（相等）运算符（首次出现在 [表 1-2](ch01.xhtml#ch1tab2)）的作用。但是，如果我们认真的考虑函数的类型，`(==)`
    的类型应该是什么呢？
- en: A function that takes two strings as input and gives as output a Boolean value
    (true or false) that indicates whether the two strings are equal should have the
    type `String -> String -> Bool`. A function that takes two integers as input and
    gives as output a Boolean value indicating whether the two integers are equal
    should have the type `Integer -> Integer -> Bool`. It would be an unfortunate
    state of affairs if we needed a different function for each type (`String`, `Integer`,
    and so on) that we wanted to check for equality. Perhaps a type variable could
    solve the problem, and the type of `(==)` could be `a -> a -> Bool`. That is almost
    correct, but the type `a -> a -> Bool` implies that every type `a` can be checked
    for equality, while there are some types that can’t be checked for equality (such
    as function types).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受两个字符串作为输入并输出一个布尔值（true或false），表示这两个字符串是否相等的函数，应该具有类型`String -> String ->
    Bool`。一个接受两个整数作为输入并输出一个布尔值，表示这两个整数是否相等的函数，应该具有类型`Integer -> Integer -> Bool`。如果我们需要为每种类型（`String`、`Integer`等）分别编写一个函数来检查相等性，那将是一个不幸的局面。也许一个类型变量可以解决这个问题，`(==)`的类型可以是`a
    -> a -> Bool`。这几乎是正确的，但类型`a -> a -> Bool`暗示每个类型`a`都可以检查相等性，而实际上有些类型是无法检查相等性的（比如函数类型）。
- en: The type class `Eq` is for types that have a notion of equality. In other words,
    types for which equality checking makes sense will be instances of `Eq`. These
    are the types for which the operators `==` and `/=` are defined. You can see in
    [Table 8-1](ch08.xhtml#ch8tab1) that all of the six basic types (`Bool`, `Char`,
    `Int`, `Integer`, `Float`, and `Double`) are instances of `Eq`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类`Eq`用于具有相等概念的类型。换句话说，对于那些相等性检查有意义的类型，将会是`Eq`的实例。这些类型定义了操作符`==`和`/=`。你可以在[表格8-1](ch08.xhtml#ch8tab1)中看到，所有六种基本类型（`Bool`、`Char`、`Int`、`Integer`、`Float`和`Double`）都是`Eq`的实例。
- en: The type of the function `(==)` is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`(==)`的类型是
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which means that we can use the `==` operator between any two expressions of
    the same type `a`, as long as `a` is an instance of `Eq`. What sort of type would
    not be an instance of `Eq`? Generally function types are not instances of `Eq`.
    For example, the type `R -> R` is not an instance of `Eq`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何两个相同类型`a`的表达式之间使用`==`操作符，只要`a`是`Eq`的实例。哪些类型不会是`Eq`的实例呢？通常，函数类型不是`Eq`的实例。例如，类型`R
    -> R`不是`Eq`的实例。
- en: The reason is that it is usually difficult or impossible to check whether two
    functions are equal. (There is a rigorous mathematical result called Richardson’s
    theorem that gives sufficient conditions, which are quite mild, for when function
    equality is undecidable.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为通常很难或不可能检查两个函数是否相等。（有一个严格的数学结果叫做理查森定理，它给出了充分的条件，这些条件相当宽松，说明了在何种情况下函数相等性是不可判定的。）
- en: From the perspective of computational physics, it’s a bad idea that `Float`
    and `Double` are instances of `Eq`. Because these two types are used for approximate
    calculation, you should never test `Float`s and `Double`s for equality. (The one
    exception to this rule is that you might check whether a `Float` or `Double` is
    zero before attempting to divide by it.) From the perspective of the computer,
    these types are each represented by a finite number of bits, and the computer
    will happily check whether each bit of one `Double` is the same as the corresponding
    bit of another `Double`. But as we saw in [Chapter 1](ch01.xhtml), the bits of
    `sqrt 5 ^ 2` are not the same as the bits of `5`. They are very close, but not
    the same. If you want to go deeper, a nice introduction to floating-point computation
    is [**[5](bib.xhtml#bib5)**]. The take-home message for computational physics
    is to avoid using `==` for approximate types like `Double`. The issue of equality
    checking with floating-point numbers is not unique to Haskell or to functional
    programming. Approximately calculated results should not be tested for equality
    in any language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算物理的角度来看，`Float`和`Double`作为`Eq`的实例是一个坏主意。因为这两种类型用于近似计算，你不应该测试`Float`和`Double`是否相等。（这个规则的一个例外是你可能需要在尝试除以它们之前检查`Float`或`Double`是否为零。）从计算机的角度来看，这些类型由有限数量的位表示，计算机会愉快地检查一个`Double`的每一位是否与另一个`Double`对应的位相同。但正如我们在[第1章](ch01.xhtml)中看到的，`sqrt
    5 ^ 2`的位与`5`的位不相同。它们非常接近，但不完全相同。如果你想更深入了解，关于浮点计算的一个很好的介绍是[**[5](bib.xhtml#bib5)**]。计算物理的关键消息是，避免对近似类型如`Double`使用`==`。浮点数的相等性检查问题并不仅仅是Haskell或函数式编程中的问题。任何语言中，近似计算结果都不应进行相等性测试。
- en: The Show Type Class
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Show类型类
- en: The type class `Show` is for types whose values can be shown using text. As
    indicated in [Table 8-1](ch08.xhtml#ch8tab1), all of the basic types (`Bool`,
    `Char`, `Int`, `Integer`, `Float`, and `Double`) are instances of `Show`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Show` 类型类用于那些可以用文本显示其值的类型。如 [表 8-1](ch08.xhtml#ch8tab1) 中所示，所有基本类型（`Bool`、`Char`、`Int`、`Integer`、`Float`
    和 `Double`）都是 `Show` 的实例。'
- en: 'Function types are not typically instances of `Show`. If I enter the name of
    a function at the GHCi prompt, I get a message that complains that there is no
    `Show` instance for `sqrt`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型通常不是 `Show` 的实例。如果我在 GHCi 提示符下输入一个函数的名字，我会得到一条消息，抱怨没有 `Show` 实例来显示 `sqrt`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GHCi knows how to apply the `sqrt` function to numbers and show you the result,
    but it does not know how to show you the `sqrt` function itself. The reason behind
    this is the design decision that anything that is a member of the `Show` type
    class should also be a member of the `Read` type class. This means that what can
    be rendered from its internal form to a `String` (`Show` instance) can also be
    converted from a `String` back to its internal form (`Read` instance). If a function’s
    `Show` instance returns the function’s name, or even its source definition, it
    wouldn’t usually be convertible back into its internal representation because
    the source file context would be missing. Note that `sqrt` is a perfectly acceptable
    Haskell expression, with a well-defined type, even though it cannot be shown.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 知道如何将 `sqrt` 函数应用于数字并显示结果，但它不知道如何显示 `sqrt` 函数本身。这背后的原因是设计决策：任何属于 `Show`
    类型类的成员也应当是 `Read` 类型类的成员。这意味着从其内部形式渲染为 `String`（`Show` 实例）能够被从 `String` 转换回其内部形式（`Read`
    实例）。如果一个函数的 `Show` 实例返回函数的名称，甚至是其源代码定义，它通常无法转换回其内部表示，因为缺少源文件的上下文。需要注意的是，`sqrt`
    是一个完全合法的 Haskell 表达式，具有明确的类型，尽管它无法被显示。
- en: The Num Type Class
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Num` 类型类'
- en: As we saw earlier, the type class `Num` is for numeric types. You can see in
    [Table 8-1](ch08.xhtml#ch8tab1) that the types `Int`, `Integer`, `Float`, and
    `Double` are instances of `Num`, while `Bool` and `Char` are not. The functions
    `(+)` (addition), `(-)` (subtraction), and `(*)` (multiplication) are owned by
    `Num`. The type of the function `(+)` is
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`Num` 类型类用于数值类型。从 [表 8-1](ch08.xhtml#ch8tab1) 中可以看到，`Int`、`Integer`、`Float`
    和 `Double` 是 `Num` 的实例，而 `Bool` 和 `Char` 不是。`(+)`（加法）、`(-)`（减法）和 `(*)`（乘法）是 `Num`
    所拥有的函数。`(+)` 函数的类型是
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: meaning that we can use the operator `+` between any two expressions of the
    same type `a`, as long as `a` is an instance of `Num`. The result will be an expression
    of type `a`. The type class `Num` allows the addition function `(+)` to act as
    though it has the type `Int -> Int -> Int` or `Integer -> Integer -> Integer`
    or `Float -> Float -> Float` or `Double -> Double -> Double`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何两个相同类型 `a` 的表达式之间使用运算符 `+`，只要 `a` 是 `Num` 的实例，结果将是一个类型为 `a` 的表达式。`Num`
    类型类允许加法函数 `(+)` 的类型表现得像 `Int -> Int -> Int`、`Integer -> Integer -> Integer`、`Float
    -> Float -> Float` 或 `Double -> Double -> Double`。
- en: 'We can ask for information about the `Num` type class by using GHCi’s `:info`
    (or `:i`) command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 GHCi 的 `:info`（或 `:i`）命令来查询关于 `Num` 类型类的信息：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we see that `Num` owns addition, subtraction, multiplication, and a few
    other functions. We also see some concrete types that are instances of `Num`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到，`Num` 拥有加法、减法、乘法和其他几个函数。我们还看到了作为 `Num` 实例的一些具体类型。
- en: The Integral Type Class
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Integral` 类型类'
- en: The `Integral` type class is for types that behave like integers. A type has
    to be an instance of `Num` before it can be an instance of `Integral`. You can
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Int` and `Integer` are
    instances of `Integral`, while `Float` and `Double` are not. The type of the function
    `rem`, which finds the remainder of one integer divided by another, is
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integral` 类型类用于像整数一样表现的类型。一个类型必须先是 `Num` 的实例，才能成为 `Integral` 的实例。从 [表 8-1](ch08.xhtml#ch8tab1)
    中可以看到，`Int` 和 `Integer` 是 `Integral` 的实例，而 `Float` 和 `Double` 不是。函数 `rem` 的类型是，`rem`
    计算一个整数除以另一个整数的余数。'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: meaning that we can use the function `rem` between any two expressions of the
    same type `a`, as long as `a` is an instance of `Integral`, and the result will
    be an expression of type `a`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何两个相同类型 `a` 的表达式之间使用 `rem` 函数，只要 `a` 是 `Integral` 的实例，结果将是一个类型为 `a`
    的表达式。
- en: The Ord Type Class
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Ord` 类型类'
- en: We want to be able to compare things, but most people would agree that
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够进行比较，大多数人会同意
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'doesn’t make any sense. The designers of the Haskell language decided that
    such an expression should not evaluate to `True` or to `False` but instead should
    be regarded as a type error. To use one of the comparison operators (`<`, `<=`,
    `>`, or `>=`), two requirements must be met:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 是没有意义的。Haskell 语言的设计者决定，这样的表达式不应该求值为 `True` 或 `False`，而应该被视为类型错误。为了使用比较运算符（`<`，`<=`，`>`，或
    `>=`），必须满足两个要求：
- en: The two things being compared must have the same type. Let us call this type
    `a`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被比较的两个对象必须具有相同的类型。我们将这种类型称为 `a`。
- en: Type `a` must belong to the `Ord` type class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `a` 必须属于 `Ord` 类型类。
- en: The `Ord` type class is for types that have a notion of order. A type must first
    be an instance of `Eq` before it may be an instance of `Ord`. The type of the
    function `(<)` is
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ord` 类型类用于具有顺序概念的类型。一个类型必须首先是 `Eq` 的实例，才能成为 `Ord` 的实例。`(<)` 函数的类型是'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: which means we can use the operator `<` between any two expressions of the same
    type `a`, as long as `a` is an instance of `Ord`. The type of `(<)` expresses
    both requirements we listed above.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何两个相同类型 `a` 的表达式之间使用运算符 `<`，前提是 `a` 是 `Ord` 的实例。`(<)` 的类型表达了我们上面列出的两个要求。
- en: Some types have no obvious notion of comparison. Three-dimensional vectors,
    for which we’ll define the `Vec` type in [Chapter 10](ch10.xhtml), have no obvious
    notion of order. This is not to say that there is no way of defining comparison
    for vectors. We could compare their magnitudes or their x-components, for example.
    The point is that there is not a single, obvious candidate for what comparison
    would mean. Because vectors have no obvious notion of comparison, `Vec` will not
    belong to `Ord`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型没有明显的比较概念。例如，三维向量，我们将在[第10章](ch10.xhtml)中定义 `Vec` 类型，并且三维向量没有明显的顺序概念。这并不是说向量无法定义比较。我们可以比较它们的大小或它们的
    x 分量。例如。关键点是，比较的含义没有单一的、明显的候选项。由于向量没有明显的比较概念，`Vec` 不属于 `Ord`。
- en: What about the expression
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么表达式如何呢
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: if `x` has the value `4.2` and `y` has the value `4`? Most people would agree
    that the expression should evaluate to `True`. But Haskell will regard this expression
    as an error if `x` has type `Double` and `y` has type `Int`, because `Double`
    and `Int` are not the same type. To compare two things, we must explicitly convert
    the type of one thing into the type of the other. To avoid a rounding error, we’d
    want to convert `y` (the `Int`) into a `Double`. For this, we can use the Prelude
    function `fromIntegral`, replacing our original expression `x > y` with
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 的值是 `4.2`，而 `y` 的值是 `4`，怎么办？大多数人会同意，这个表达式应该求值为 `True`。但是如果 `x` 的类型是 `Double`，而
    `y` 的类型是 `Int`，Haskell 会将该表达式视为错误，因为 `Double` 和 `Int` 不是相同的类型。为了比较两个事物，我们必须显式地将其中一个的类型转换为另一个的类型。为了避免四舍五入错误，我们希望将
    `y`（即 `Int`）转换为 `Double`。为此，我们可以使用 Prelude 函数 `fromIntegral`，将原始表达式 `x > y` 替换为
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The type of `fromIntegral` is
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromIntegral` 的类型是'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: indicating that `fromIntegral` will convert any type in `Integral` into any
    type in `Num`. The type checker will figure out that in this case, since `x` has
    type `Double`, `y` needs to be converted to a `Double`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 `fromIntegral` 将会把 `Integral` 中的任何类型转换为 `Num` 中的任何类型。类型检查器会推导出，在这种情况下，既然
    `x` 的类型是 `Double`，那么 `y` 需要转换成 `Double`。
- en: Some other programming languages have a process of *type coercion* that changes
    the type of a value so that it can be compared with or used with another value.
    For example, an integer will automatically be changed into a floating-point number
    when the two are being compared. Haskell does not have automatic type conversion,
    and the decision to not include this was intentional. The designers of the language
    believed that many or most type coercions are really mistakes that the programmer
    did not intend rather than automatic help that the compiler could provide.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他编程语言有 *类型强制转换* 的过程，它会改变一个值的类型，以便与另一个值进行比较或使用。例如，整数在比较时会自动转换为浮动点数。Haskell
    没有自动类型转换，这一决定是经过深思熟虑的。语言设计者认为，许多或大多数类型强制转换实际上是程序员无意中犯的错误，而不是编译器可以提供的自动帮助。
- en: The Fractional Type Class
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分数类型类
- en: The `Fractional` type class is for numeric types that support division. A type
    has to be an instance of `Num` before it can be an instance of `Fractional`. We
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Float` and `Double` are
    instances of `Fractional`, while `Int` and `Integer` are not. The type of the
    function `(/)` is
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fractional` 类型类用于支持除法的数值类型。一个类型必须是 `Num` 的实例，才能成为 `Fractional` 的实例。我们在 [表
    8-1](ch08.xhtml#ch8tab1) 中看到，`Float` 和 `Double` 是 `Fractional` 的实例，而 `Int` 和 `Integer`
    不是。函数 `(/)` 的类型是'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: meaning that we can use the `/` operator between any two expressions of the
    same type `a`, as long as `a` is an instance of `Fractional`. The result will
    be an expression of type `a`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何两个类型为 `a` 的表达式之间使用 `/` 运算符，只要 `a` 是 `Fractional` 类型类的实例。结果将是一个类型为
    `a` 的表达式。
- en: The Floating Type Class
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浮动类型类
- en: The `Floating` type class is for numeric types that are stored by the computer
    as floating-point numbers, that is, as inexact approximations. A type has to be
    an instance of `Fractional` before it can be an instance of `Floating`. You can
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Float` and `Double` are
    instances of `Floating`, while `Int` and `Integer` are not. The type of the function
    `cos` is
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floating` 类型类用于存储为浮点数的数值类型，即存储为不精确的近似值。在一个类型成为 `Floating` 的实例之前，它必须先是 `Fractional`
    的实例。你可以在 [表 8-1](ch08.xhtml#ch8tab1) 中看到，`Float` 和 `Double` 是 `Floating` 的实例，而
    `Int` 和 `Integer` 不是。函数 `cos` 的类型是'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: meaning that we can use the `cos` function on any expression of type `a`, as
    long as `a` is an instance of `Floating`. The result will be an expression of
    type `a`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何类型为 `a` 的表达式上使用 `cos` 函数，只要 `a` 是 `Floating` 类型类的实例。结果将是一个类型为 `a`
    的表达式。
- en: '[Figure 8-1](ch08.xhtml#ch8fig1) shows the relationship among the numeric type
    classes we’ve just discussed.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](ch08.xhtml#ch8fig1) 显示了我们刚才讨论的数值类型类之间的关系。'
- en: '![Image](Images/104fig01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/104fig01.jpg)'
- en: '*Figure 8-1: Relationship among the numeric type classes `Num, Integral, Fractional`,
    and `Floating`*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1: 数值类型类 `Num, Integral, Fractional` 和 `Floating` 之间的关系*'
- en: In [Figure 8-1](ch08.xhtml#ch8fig1), types are preceded by a bullet and type
    classes are not. As you can see, the types `Int` and `Integer` are instances of
    type classes `Integral` and `Num`. The types `Float` and `Double` are instances
    of type classes `Floating`, `Fractional`, and `Num`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 8-1](ch08.xhtml#ch8fig1) 中，类型前面有一个符号，而类型类没有。如你所见，类型 `Int` 和 `Integer` 是类型类
    `Integral` 和 `Num` 的实例。类型 `Float` 和 `Double` 是类型类 `Floating`、`Fractional` 和 `Num`
    的实例。
- en: Exponentiation and Type Classes
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数运算和类型类
- en: Haskell offers three operators for exponentiation, shown in [Table 8-2](ch08.xhtml#ch8tab2).
    The difference between these operators lies in the type class constraints that
    each work under and in the methods of implementation. The single caret operator
    (`^`) requires that the exponent be a nonnegative integer. Exponentiation by `^`
    repeatedly multiplies a `Num` by itself. The double-caret operator (`^^`) requires
    that the exponent be an integer, enforced by the `Integral b` constraint. The
    `^^` operator can be implemented by repeated multiplication and taking reciprocals,
    and it can accept a negative exponent. The double-star operator (`**`) requires
    that the base and the exponent have the same type and that that type be an instance
    of `Floating`. This operator requires a more complicated implementation, taking
    a logarithm and using the exponential function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 提供了三种指数运算符，如 [表 8-2](ch08.xhtml#ch8tab2) 所示。这些运算符的区别在于它们所依赖的类型类约束以及实现方式。单个插入符号运算符
    (`^`) 要求指数是一个非负整数。`^` 运算符通过重复将 `Num` 自乘来进行指数运算。双插入符号运算符 (`^^`) 要求指数是一个整数，这一约束由
    `Integral b` 类型类强制。`^^` 运算符可以通过重复乘法和取倒数来实现，并且可以接受负指数。双星号运算符 (`**`) 要求基数和指数具有相同的类型，并且该类型必须是
    `Floating` 类型类的实例。此运算符需要更复杂的实现，通过对数运算和指数函数来完成。
- en: '**Table 8-2:** Haskell’s Three Functions for Exponentiation'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2:** Haskell 的三种指数运算函数'
- en: '| **Function** |  | **Type** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `(^)` | `::` | `(Integral b, Num a) => a -> b -> a` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `(^)` | `::` | `(Integral b, Num a) => a -> b -> a` |'
- en: '| `(^^)` | `::` | `(Fractional a, Integral b) => a -> b -> a` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `(^^)` | `::` | `(Fractional a, Integral b) => a -> b -> a` |'
- en: '| `(**)` | `::` | `Floating a => a -> a -> a` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `(**)` | `::` | `Floating a => a -> a -> a` |'
- en: Since `Float` and `Double` are members of the `Floating` type class, and thus
    represent numbers approximately, the `**` operator is generally going to do an
    approximate calculation. This is certainly what you want for a non-integral exponent.
    Under the right circumstances, the caret and double-caret operators can do exact
    calculation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Float` 和 `Double` 是 `Floating` 类型类的成员，因此它们表示的是近似的数字，`**` 运算符通常会进行近似计算。对于非整数指数，这是我们想要的行为。在适当的情况下，插入符号和双插入符号运算符可以进行精确计算。
- en: '[Table 8-3](ch08.xhtml#ch8tab3) shows which of types (`Int`, `Integer`, `Float`,
    and `Double`) are allowable for the base `x` and the exponent `y` in the expression
    `x ^^ y`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-3](ch08.xhtml#ch8tab3) 显示了表达式 `x ^^ y` 中基数 `x` 和指数 `y` 的类型（`Int`、`Integer`、`Float`
    和 `Double`）的允许情况。'
- en: '**Table 8-3:** Possible Types for `x` and `y` with the Double-Caret Exponentiation
    Operator'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-3：** 使用双插入符号指数运算符的 `x` 和 `y` 的可能类型'
- en: '|  | **`y :: Int`** | **`y :: Integer`** | **`y :: Float`** | **`y :: Double`**
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  | **`y :: Int`** | **`y :: Integer`** | **`y :: Float`** | **`y :: Double`**
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `x :: Int` |  |  |  |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `x :: Int` |  |  |  |  |'
- en: '| `x :: Integer` |  |  |  |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `x :: Integer` |  |  |  |  |'
- en: '| `x :: Float` | `^^` | `^^` |  |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `x :: Float` | `^^` | `^^` |  |  |'
- en: '| `x :: Double` | `^^` | `^^` |  |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `x :: Double` | `^^` | `^^` |  |  |'
- en: Since the base must have a type that is an instance of `Fractional`, only `Float`
    and `Double` can serve as a type for the base. Since the exponent must have a
    type that is an instance of `Integral`, only `Int` and `Integer` can serve as
    a type for the exponent.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基数必须具有 `Fractional` 实例类型，只有 `Float` 和 `Double` 可以作为基数的类型。由于指数必须具有 `Integral`
    实例类型，只有 `Int` 和 `Integer` 可以作为指数的类型。
- en: Sections
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区段
- en: An infix operator expects an argument on its left and an argument on its right.
    If only one of these two arguments is given, the resulting expression can be thought
    of as a function waiting for the other argument. Haskell allows us to make such
    functions by enclosing an operator and one of its arguments in parentheses. A
    function formed by enclosing an operator and one argument in parentheses is called
    a *section*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀运算符期望其左侧和右侧都有一个参数。如果只给定其中一个参数，结果表达式可以被看作是一个等待另一个参数的函数。Haskell 允许我们通过将运算符和其中一个参数括在括号中来创建这样的函数。通过将运算符和一个参数括在括号中形成的函数被称为*区段*。
- en: '[Table 8-4](ch08.xhtml#ch8tab4) shows examples of sections, with their types.
    Many useful sections have types with type-class constraints.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-4](ch08.xhtml#ch8tab4) 显示了区段示例及其类型。许多有用的区段具有带有类型类约束的类型。'
- en: '**Table 8-4:** Examples of Sections'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-4：** 区段示例'
- en: '| **Function** |  | **Type** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `(+1)` | `::` | `Num a => a -> a` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `(+1)` | `::` | `Num a => a -> a` |'
- en: '| `(2*)` | `::` | `Num a => a -> a` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `(2*)` | `::` | `Num a => a -> a` |'
- en: '| `(^2)` | `::` | `Num a => a -> a` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `(^2)` | `::` | `Num a => a -> a` |'
- en: '| `(2^)` | `::` | `(Integral b, Num a) => b -> a` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `(2^)` | `::` | `(Integral b, Num a) => b -> a` |'
- en: '| `(''A'':)` | `::` | `[Char] -> [Char]` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `(''A'':)` | `::` | `[Char] -> [Char]` |'
- en: '| `(:"end")` | `::` | `Char -> [Char]` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `(:"end")` | `::` | `Char -> [Char]` |'
- en: '| `("I won''t " ++)` | `::` | `[Char] -> [Char]` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `("I won''t " ++)` | `::` | `[Char] -> [Char]` |'
- en: '| `($ True)` | `::` | `(Bool -> b) -> b` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `($ True)` | `::` | `(Bool -> b) -> b` |'
- en: For example, `(+1)`, which could also be written `(1+)`, is a function that
    adds 1 to its argument, and `(2*)`, which could also be written `(*2)`, is a function
    that doubles its argument. However, the sections `(^2)` and `(2^)` are not the
    same function; the former is the squaring function and the latter is the “2 to
    the power of” function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`(+1)`，也可以写作 `(1+)`，是一个将 1 加到其参数上的函数，`(2*)`，也可以写作 `(*2)`，是一个将其参数乘以 2 的函数。然而，区段
    `(^2)` 和 `(2^)` 不是同一个函数；前者是平方函数，后者是“2 的幂次”函数。
- en: 'Sections can be useful in the same way that anonymous functions are useful:
    they provide a quick way of specifying a function without naming it, often as
    an input to a higher-order function.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 区段的用法类似于匿名函数的用法：它们提供了一种快速指定函数的方式，而不需要为函数命名，通常作为高阶函数的输入。
- en: Let’s use a section to integrate the squaring function. Using the `integral`
    function from [Chapter 6](ch06.xhtml),
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用区段来对平方函数进行积分。使用 [第 6 章](ch06.xhtml) 中的 `integral` 函数，
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'we can use a section for the squaring function as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用区段来表示平方函数：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Like anonymous functions, sections give the programmer tools to create functions
    “on the fly” without having to name them. And like anonymous functions, using
    sections requires a bit of care since it is easy to forget why you defined a particular
    section. This is because the terse syntax provides no clue about what you meant
    when you wrote it. If the meaning of a section is not immediately clear, a short
    function definition with an evocative name may be a better choice.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像匿名函数一样，区段（sections）为程序员提供了在不命名函数的情况下“动态”创建函数的工具。像匿名函数一样，使用区段需要小心，因为很容易忘记你定义某个特定区段的原因。这是因为简洁的语法并没有提供关于你当时意图的任何线索。如果一个区段的含义不立即显现，定义一个简短的带有描述性名称的函数可能是更好的选择。
- en: Example of Type Classes and Plotting
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型类和绘图的示例
- en: 'At the beginning of this chapter, we mentioned that the Haskell type checker
    will sometimes complain if it cannot determine concrete types for each expression
    it needs to deal with. The solution is to add a type signature or type annotation
    to your code. As an example of this, create a new program file called *typeTrouble.hs*
    with the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们提到过，如果Haskell类型检查器无法确定它需要处理的每个表达式的具体类型，它有时会报错。解决方法是给代码添加类型签名或类型注解。作为示例，创建一个新的程序文件叫做*typeTrouble.hs*，并包含以下代码：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When I try to load this file into GHCi, I get this horrible-looking error message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试将这个文件加载到GHCi时，我得到这个看起来很可怕的错误信息：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don’t panic. This error message contains much more information than we need
    to solve the problem. The most useful part of the message is the first line, which
    tells where the problem is in the code (line 3, column 9). At line 3, column 9
    of our code is the function `plotFunc`. Let’s look at the type of `plotFunc`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 别慌。这个错误信息包含了比我们解决问题所需更多的信息。最有用的部分是信息的第一行，它告诉我们代码中问题所在的位置（第3行，第9列）。在我们代码的第3行，第9列是`plotFunc`函数。让我们来看一下`plotFunc`的类型。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hmmm. Life just got worse. But this latter error is an easy one. “Variable not
    in scope” means that GHCi doesn’t know this function. That makes sense, actually,
    because it’s not included in the Prelude (the collection of built-in functions
    that are loaded automatically when we start up GHCi), and GHCi refused to load
    our *typeTrouble.hs* file because it had a problem with it. At the moment, it
    has no knowledge of `plotFunc`. The `plotFunc` function is defined in the `Graphics.Gnuplot.Simple`
    module. We can get access to `plotFunc` by loading the plotting module manually,
    like we first did to make a quick plot.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，生活变得更糟了。但这个错误其实很容易解决。“Variable not in scope”表示GHCi不知道这个函数。其实这很有道理，因为它没有包含在Prelude中（Prelude是GHCi启动时自动加载的内建函数集合），而且GHCi拒绝加载我们的*typeTrouble.hs*文件，因为它遇到了问题。目前，GHCi对`plotFunc`一无所知。`plotFunc`函数是在`Graphics.Gnuplot.Simple`模块中定义的。我们可以通过手动加载绘图模块来访问`plotFunc`，就像我们最初为了快速绘制图形所做的那样。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let’s ask again for the type of `plotFunc`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次查询`plotFunc`的类型。
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are a couple of type class constraints to the left of the `=>`. I don’t
    know the specifics of those type classes, but as long as `a` (a type variable)
    belongs to those two type classes, the type of `plotFunc` is the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`=>`的左边有几个类型类约束。我不清楚这些类型类的具体细节，但只要`a`（一个类型变量）属于这两个类型类，`plotFunc`的类型就是以下内容：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In other words, `plotFunc` needs a list of `Attribute`s (we have given an empty
    list in our examples so far), a list of `a`s, and a function that takes an `a`
    as input and gives back an `a` as output. If we give `plotFunc` all this stuff,
    it will give us back an `IO ()`, which is a way of saying that it will actually
    *do* something for us (make a plot).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`plotFunc`需要一个`Attribute`列表（到目前为止我们在示例中给出了一个空列表）、一个`a`的列表，以及一个接受`a`作为输入并返回`a`作为输出的函数。如果我们把这些都给`plotFunc`，它会返回一个`IO
    ()`，这意味着它会实际*做*一些事情（绘制图形）。
- en: The key to fixing an “ambiguous type variable” error like this lies in the suggestion
    of the fifth line in the error message shown earlier. Add a type signature to
    your code. The Haskell type checker would like more help figuring out the types
    of things. In particular, it can’t figure out the types of `[0,0.01..10]` and
    `cos`. Let’s ask GHCi about the types of these two.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解决“模糊类型变量”错误的关键在于错误信息第五行中的建议。给代码添加类型签名。Haskell类型检查器希望得到更多帮助，以便弄清楚事物的类型。特别是，它无法确定`[0,0.01..10]`和`cos`的类型。让我们询问GHCi这两个的类型。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both of these expressions contain type class constraints.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表达式都包含了类型类约束。
- en: 'One solution to the problem is to give the list `[0,0.01..10]` a name and a
    type signature. Let’s make a program file called *typeTrouble2.hs* with the following
    lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是给列表`[0,0.01..10]`一个名称和类型签名。我们可以创建一个名为*typeTrouble2.hs*的程序文件，内容如下：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This program file should load fine and give you a nice plot when you enter `plot2`.
    Try it and see.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序文件应该能正常加载，并且当你输入`plot2`时，能够给出一个不错的图形。试试看吧。
- en: 'A second solution is to specify the type of the list `[0,0.01..10]` on the
    line where it’s used. We could make a program file called *typeTrouble3.hs* with
    the following lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是在线使用列表`[0,0.01..10]`的地方指定其类型。我们可以创建一个名为*typeTrouble3.hs*的程序文件，内容如下：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A third solution, which is my favorite because it involves the fewest keystrokes,
    is to tell the compiler that the final element of the list, `10`, has type `Double`.
    This implies that all of the elements in the list have type `Double`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种解决方案是我最喜欢的，因为它涉及的按键最少，就是告诉编译器列表的最后一个元素`10`的类型是`Double`。这意味着列表中的所有元素都是`Double`类型。
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The moral of the story is that you should include type signatures for all of
    the functions you define, and you should be prepared to add more type signatures
    if the type checker complains.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是你应该为你定义的所有函数包含类型签名，并且如果类型检查器提示错误，你应该准备好添加更多的类型签名。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the idea of a type class, something that contains types
    and owns certain functions. We discussed several standard type classes from the
    Prelude, in addition to functions that have type-class constraints. We saw that
    a section is a function without a name, formed by combining an operator with one
    of its arguments. Many sections have types with type-class constraints. Finally,
    we gave an example where it was necessary to add a type annotation to our code
    to satisfy the Haskell type checker.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了类型类的概念，类型类包含类型并拥有特定的函数。我们讨论了Prelude中的几个标准类型类，以及具有类型类约束的函数。我们还看到，区段是没有名称的函数，通过将运算符与其参数结合形成。许多区段具有带类型类约束的类型。最后，我们举了一个例子，说明在代码中添加类型注解是如何满足
    Haskell 类型检查器的要求的。
- en: With the introduction of type classes, we have described almost all of Haskell’s
    type system. There are basic types, function types, list types, type variables,
    and type classes. Once we cover tuple types in the next chapter, we’ll have described
    Haskell’s type system in full.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着类型类的引入，我们几乎描述了 Haskell 的整个类型系统。它包括基本类型、函数类型、列表类型、类型变量和类型类。一旦我们在下一章中讲解元组类型，我们就会完整描述
    Haskell 的类型系统。
- en: Exercises
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 8.1.** Is it possible for a type to belong to more than one type
    class? If so, give an example. If not, why not?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.1.** 是否有可能一个类型属于多个类型类？如果可以，请举个例子。如果不行，为什么不行？'
- en: '**Exercise 8.2.** We said in this chapter that function types are typically
    not instances of `Eq` because it’s too hard to check whether two functions are
    equal.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.2.** 本章中我们提到函数类型通常不是`Eq`的实例，因为检查两个函数是否相等太困难。'
- en: (a) What does it mean mathematically for two functions to be equal?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 数学上，两个函数相等意味着什么？
- en: (b) Why is it usually very hard or impossible for the computer to check if two
    functions are equal?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 为什么计算机通常很难或者不可能检查两个函数是否相等？
- en: (c) Give a specific example of a function type that would be easy to check for
    equality.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 请举一个容易检查相等性的函数类型的具体例子。
- en: '**Exercise 8.3.** The function `(*2)` is the same as the function `(2*)`. Is
    the function `(/2)` the same as the function `(2/)`? Explain what these functions
    do.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.3.** 函数`(*2)`与函数`(2*)`是一样的。函数`(/2)`与函数`(2/)`是一样的吗？解释这些函数的作用。'
- en: '**Exercise 8.4.** In [Chapter 2](ch02.xhtml), we defined a function `square`.
    Now that we know that Haskell has sections, we can see that we didn’t need to
    define `square`. Show how to use a section to write the function that squares
    its argument. How about a section for the function that cubes its argument?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.4.** 在[第 2 章](ch02.xhtml)中，我们定义了一个函数`square`。现在我们知道 Haskell 有区段（sections）后，可以看出我们其实不需要定义`square`。请展示如何使用区段来编写一个平方其参数的函数。对于一个立方其参数的函数，如何使用区段表示？'
- en: '**Exercise 8.5.** You can get information from GHCi about a type or a type
    class by using the GHCi command `:info` (`:i` for short), followed by the name
    of the type or type class you want information about. If you ask for information
    about a type, GHCi will tell you the type classes of which your type is an instance
    (the line `instance Num Double`, for example, means that the type `Double` is
    an instance of the type class `Num`). If you ask for information about a type
    class, GHCi will tell you the types that are instances of your type class.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: (a) We showed in [Table 8-1](ch08.xhtml#ch8tab1) that the type `Integer` was
    an instance of type classes `Eq`, `Ord`, `Show`, `Num`, and `Integral`. There
    are a few more type classes that we did not discuss of which `Integer` is also
    an instance. Find these.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: (b) Type class `Enum` is for types that can be enumerated, or listed. Which
    Prelude types are instances of `Enum`?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.6.** Find the types of the following Prelude Haskell expressions
    (some are functions and some are not):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: (a) `42`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: (b) `42.0`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: (c) `42.5`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: (d) `pi`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: (e) `[3,1,4]`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: (f) `[3,3.5,4]`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: (g) `[3,3.1,pi]`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: (h) `(==)`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: (i) `(/=)`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: (j) `(<)`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: (k) `(<=)`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: (l) `(+)`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: (m) `(-)`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: (n) `(*)`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: (o) `(/)`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: (p) `(^)`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: (q) `(**)`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: (r) `8/4`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: (s) `sqrt`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: (t) `cos`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: (u) `show`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: (v) `(2/)`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.7.** If 8/4 = 2, and `2 :: Num a => a` (2 has type `a` for every
    type `a` in type class `Num`), why does `8/4 :: Fractional a => a`?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.8.** The functions `quot`, `rem`, `div`, and `mod` all have to
    do with integer division and remainders. All of these functions work with types
    that are instances of type class `Integral`, as shown in the following table:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `quot` | `::` | `Integral a => a -> a -> a` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `rem` | `::` | `Integral a => a -> a -> a` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `div` | `::` | `Integral a => a -> a -> a` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `mod` | `::` | `Integral a => a -> a -> a` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: By playing around with these functions, try to explain in words what each does.
    What is the difference between `quot` and `div`? What is the difference between
    `rem` and `mod`?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.9.** Make a table like [Table 8-3](ch08.xhtml#ch8tab3), showing
    which of types `Int`, `Integer`, `Float`, and `Double` can be used for the base
    `x` and the exponent `y` in the expression `x ^ y`. Do the same for the expression
    `x ** y`. Finally, find a pair of types `a` and `b` for which there is no exponentiation
    operator that allows the base to have type `a` and the exponent to have type `b`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
