- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TYPE CLASSES
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have seen functions that have a concrete type, such as `not`, which takes
    a `Bool` as input and returns a `Bool` as output. We have also seen functions
    with types that use a type variable to express that they work with all types,
    such as `head`, which takes a list of any type and returns the first element.
    Use of a type variable expresses commonality over all types.
  prefs: []
  type: TYPE_NORMAL
- en: Between the extremes of functions that work with a single type and functions
    that work with all types is a need to express a more limited commonality among
    types that does not extend to all types. For example, we would like addition to
    be available for numeric types like `Int`, `Integer`, and `Double`, without the
    need to define addition for *all* types. The term *parametric polymorphism* is
    used to express commonality among all types. The `head` function mentioned earlier
    is parametric polymorphic on the underlying type of the input list. The term *ad-hoc
    polymorphism* is used to express more limited commonality. Type classes are Haskell’s
    way of providing a mechanism for ad-hoc polymorphism. They express commonality
    among types that doesn’t extend to all types.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll introduce the idea of a type class, along with a number
    of type classes from the Prelude. We’ll describe which of the basic types are
    members of these type classes, and why. The explanation for why Haskell has three
    different exponentiation operators is based on type classes. A *section* is a
    function based on an operator and one of its arguments, and many sections have
    types that involve type classes. While type classes provide a nice way to express
    commonality, they also allow for the possibility that the compiler cannot figure
    out concrete types for values when it needs to, and we give an example where the
    code writer must provide extra type information to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Type Classes and Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us begin by asking GHCi about the type of the number `4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It would be entirely reasonable to expect the type of the number `4` to be `Int`
    or `Integer`. But the designers of the Haskell language wanted a number like `4`
    to be able to be an `Int`, an `Integer`, a `Double`, or even a few other types,
    depending on the programmer’s needs. For this reason (and other, more compelling
    reasons), they invented the idea of type classes.
  prefs: []
  type: TYPE_NORMAL
- en: A type class is like a club to which a type can belong, and it makes certain
    functions available to that type. The types `Int`, `Integer`, and `Double` all
    belong to the type class `Num` (short for number). Each of these types has addition,
    subtraction, and multiplication available to it because these functions are owned
    by the `Num` type class. When a type belongs to a type class, we say that it is
    an *instance* of that type class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type signature `4 :: Num p => p` can be read as “`4` has type `p` as long
    as `p` is in type class `Num`.” The letter `p` is a type variable in this type
    signature. It can stand for any type. The conditions to the left of the double
    arrow (`=>`) are *type class constraints*. In the type signature above, there
    is one type class constraint, `Num p`, which says that `p` must belong to type
    class `Num`.'
  prefs: []
  type: TYPE_NORMAL
- en: Type classes are a way to express commonality among types. The types `Int`,
    `Integer`, `Float`, and `Double` have quite a bit in common; namely, we want to
    do the same sorts of things with them. We want to be able to add, subtract, and
    multiply numbers with these types. By having the type class `Num` own addition,
    subtraction, and multiplication, we allow the same addition operator that works
    with `Int`s to also work with `Double`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the type signature `4 :: Num p => p`, GHCi hasn’t committed to a concrete
    type for the number 4 yet. But this noncommittal attitude about the type of `4`
    can’t go on forever. At some point, the Haskell compiler will demand that every
    value have a concrete type. The inability of the compiler to assign a concrete
    type to a value can be a source of trouble. However, GHCi has some type-defaulting
    rules to make our lives easier. For example, if you put the line'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: into a program file (say *typetest.hs*), giving `x` no type signature, load
    it into GHCi, and then ask for the type of `x`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: GHCi will tell you that `x` has type `Integer`. Here, GHCi has committed to
    a concrete type without our specifying the type.
  prefs: []
  type: TYPE_NORMAL
- en: There are other situations, like that in “Example of Type Classes and Plotting”
    at the end of this chapter, where GHCi feels unable to assign a concrete type,
    and you will need to help it out by adding type signatures to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Type Classes from the Prelude
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 8-1](ch08.xhtml#ch8tab1) shows several type classes provided by the
    Prelude. The table also shows which of the basic types are instances of each of
    the type classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Basic Types That Are Instances of Various Type Classes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type class** | `Bool` | `Char` | `Int` | `Integer` | `Float` | `Double`
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Eq` | X | X | X | X | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `Ord` | X | X | X | X | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `Show` | X | X | X | X | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `Num` |  |  | X | X | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `Integral` |  |  | X | X |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Fractional` |  |  |  |  | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| `Floating` |  |  |  |  | X | X |'
  prefs: []
  type: TYPE_TB
- en: The following sections discuss the purpose and use of the type classes listed
    in [Table 8-1](ch08.xhtml#ch8tab1).
  prefs: []
  type: TYPE_NORMAL
- en: The Eq Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to be able to ask the computer whether two things are equal. That’s
    what the `==` (equality) operator (first introduced in [Table 1-2](ch01.xhtml#ch1tab2))
    does. But if we are serious about functions having types, what should the type
    of `(==)` be?
  prefs: []
  type: TYPE_NORMAL
- en: A function that takes two strings as input and gives as output a Boolean value
    (true or false) that indicates whether the two strings are equal should have the
    type `String -> String -> Bool`. A function that takes two integers as input and
    gives as output a Boolean value indicating whether the two integers are equal
    should have the type `Integer -> Integer -> Bool`. It would be an unfortunate
    state of affairs if we needed a different function for each type (`String`, `Integer`,
    and so on) that we wanted to check for equality. Perhaps a type variable could
    solve the problem, and the type of `(==)` could be `a -> a -> Bool`. That is almost
    correct, but the type `a -> a -> Bool` implies that every type `a` can be checked
    for equality, while there are some types that can’t be checked for equality (such
    as function types).
  prefs: []
  type: TYPE_NORMAL
- en: The type class `Eq` is for types that have a notion of equality. In other words,
    types for which equality checking makes sense will be instances of `Eq`. These
    are the types for which the operators `==` and `/=` are defined. You can see in
    [Table 8-1](ch08.xhtml#ch8tab1) that all of the six basic types (`Bool`, `Char`,
    `Int`, `Integer`, `Float`, and `Double`) are instances of `Eq`.
  prefs: []
  type: TYPE_NORMAL
- en: The type of the function `(==)` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which means that we can use the `==` operator between any two expressions of
    the same type `a`, as long as `a` is an instance of `Eq`. What sort of type would
    not be an instance of `Eq`? Generally function types are not instances of `Eq`.
    For example, the type `R -> R` is not an instance of `Eq`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that it is usually difficult or impossible to check whether two
    functions are equal. (There is a rigorous mathematical result called Richardson’s
    theorem that gives sufficient conditions, which are quite mild, for when function
    equality is undecidable.)
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of computational physics, it’s a bad idea that `Float`
    and `Double` are instances of `Eq`. Because these two types are used for approximate
    calculation, you should never test `Float`s and `Double`s for equality. (The one
    exception to this rule is that you might check whether a `Float` or `Double` is
    zero before attempting to divide by it.) From the perspective of the computer,
    these types are each represented by a finite number of bits, and the computer
    will happily check whether each bit of one `Double` is the same as the corresponding
    bit of another `Double`. But as we saw in [Chapter 1](ch01.xhtml), the bits of
    `sqrt 5 ^ 2` are not the same as the bits of `5`. They are very close, but not
    the same. If you want to go deeper, a nice introduction to floating-point computation
    is [**[5](bib.xhtml#bib5)**]. The take-home message for computational physics
    is to avoid using `==` for approximate types like `Double`. The issue of equality
    checking with floating-point numbers is not unique to Haskell or to functional
    programming. Approximately calculated results should not be tested for equality
    in any language.
  prefs: []
  type: TYPE_NORMAL
- en: The Show Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The type class `Show` is for types whose values can be shown using text. As
    indicated in [Table 8-1](ch08.xhtml#ch8tab1), all of the basic types (`Bool`,
    `Char`, `Int`, `Integer`, `Float`, and `Double`) are instances of `Show`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function types are not typically instances of `Show`. If I enter the name of
    a function at the GHCi prompt, I get a message that complains that there is no
    `Show` instance for `sqrt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: GHCi knows how to apply the `sqrt` function to numbers and show you the result,
    but it does not know how to show you the `sqrt` function itself. The reason behind
    this is the design decision that anything that is a member of the `Show` type
    class should also be a member of the `Read` type class. This means that what can
    be rendered from its internal form to a `String` (`Show` instance) can also be
    converted from a `String` back to its internal form (`Read` instance). If a function’s
    `Show` instance returns the function’s name, or even its source definition, it
    wouldn’t usually be convertible back into its internal representation because
    the source file context would be missing. Note that `sqrt` is a perfectly acceptable
    Haskell expression, with a well-defined type, even though it cannot be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The Num Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we saw earlier, the type class `Num` is for numeric types. You can see in
    [Table 8-1](ch08.xhtml#ch8tab1) that the types `Int`, `Integer`, `Float`, and
    `Double` are instances of `Num`, while `Bool` and `Char` are not. The functions
    `(+)` (addition), `(-)` (subtraction), and `(*)` (multiplication) are owned by
    `Num`. The type of the function `(+)` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: meaning that we can use the operator `+` between any two expressions of the
    same type `a`, as long as `a` is an instance of `Num`. The result will be an expression
    of type `a`. The type class `Num` allows the addition function `(+)` to act as
    though it has the type `Int -> Int -> Int` or `Integer -> Integer -> Integer`
    or `Float -> Float -> Float` or `Double -> Double -> Double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ask for information about the `Num` type class by using GHCi’s `:info`
    (or `:i`) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that `Num` owns addition, subtraction, multiplication, and a few
    other functions. We also see some concrete types that are instances of `Num`.
  prefs: []
  type: TYPE_NORMAL
- en: The Integral Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Integral` type class is for types that behave like integers. A type has
    to be an instance of `Num` before it can be an instance of `Integral`. You can
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Int` and `Integer` are
    instances of `Integral`, while `Float` and `Double` are not. The type of the function
    `rem`, which finds the remainder of one integer divided by another, is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: meaning that we can use the function `rem` between any two expressions of the
    same type `a`, as long as `a` is an instance of `Integral`, and the result will
    be an expression of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The Ord Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to be able to compare things, but most people would agree that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'doesn’t make any sense. The designers of the Haskell language decided that
    such an expression should not evaluate to `True` or to `False` but instead should
    be regarded as a type error. To use one of the comparison operators (`<`, `<=`,
    `>`, or `>=`), two requirements must be met:'
  prefs: []
  type: TYPE_NORMAL
- en: The two things being compared must have the same type. Let us call this type
    `a`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `a` must belong to the `Ord` type class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Ord` type class is for types that have a notion of order. A type must first
    be an instance of `Eq` before it may be an instance of `Ord`. The type of the
    function `(<)` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: which means we can use the operator `<` between any two expressions of the same
    type `a`, as long as `a` is an instance of `Ord`. The type of `(<)` expresses
    both requirements we listed above.
  prefs: []
  type: TYPE_NORMAL
- en: Some types have no obvious notion of comparison. Three-dimensional vectors,
    for which we’ll define the `Vec` type in [Chapter 10](ch10.xhtml), have no obvious
    notion of order. This is not to say that there is no way of defining comparison
    for vectors. We could compare their magnitudes or their x-components, for example.
    The point is that there is not a single, obvious candidate for what comparison
    would mean. Because vectors have no obvious notion of comparison, `Vec` will not
    belong to `Ord`.
  prefs: []
  type: TYPE_NORMAL
- en: What about the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: if `x` has the value `4.2` and `y` has the value `4`? Most people would agree
    that the expression should evaluate to `True`. But Haskell will regard this expression
    as an error if `x` has type `Double` and `y` has type `Int`, because `Double`
    and `Int` are not the same type. To compare two things, we must explicitly convert
    the type of one thing into the type of the other. To avoid a rounding error, we’d
    want to convert `y` (the `Int`) into a `Double`. For this, we can use the Prelude
    function `fromIntegral`, replacing our original expression `x > y` with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The type of `fromIntegral` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: indicating that `fromIntegral` will convert any type in `Integral` into any
    type in `Num`. The type checker will figure out that in this case, since `x` has
    type `Double`, `y` needs to be converted to a `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: Some other programming languages have a process of *type coercion* that changes
    the type of a value so that it can be compared with or used with another value.
    For example, an integer will automatically be changed into a floating-point number
    when the two are being compared. Haskell does not have automatic type conversion,
    and the decision to not include this was intentional. The designers of the language
    believed that many or most type coercions are really mistakes that the programmer
    did not intend rather than automatic help that the compiler could provide.
  prefs: []
  type: TYPE_NORMAL
- en: The Fractional Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Fractional` type class is for numeric types that support division. A type
    has to be an instance of `Num` before it can be an instance of `Fractional`. We
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Float` and `Double` are
    instances of `Fractional`, while `Int` and `Integer` are not. The type of the
    function `(/)` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: meaning that we can use the `/` operator between any two expressions of the
    same type `a`, as long as `a` is an instance of `Fractional`. The result will
    be an expression of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The Floating Type Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Floating` type class is for numeric types that are stored by the computer
    as floating-point numbers, that is, as inexact approximations. A type has to be
    an instance of `Fractional` before it can be an instance of `Floating`. You can
    see in [Table 8-1](ch08.xhtml#ch8tab1) that the types `Float` and `Double` are
    instances of `Floating`, while `Int` and `Integer` are not. The type of the function
    `cos` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: meaning that we can use the `cos` function on any expression of type `a`, as
    long as `a` is an instance of `Floating`. The result will be an expression of
    type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-1](ch08.xhtml#ch8fig1) shows the relationship among the numeric type
    classes we’ve just discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/104fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Relationship among the numeric type classes `Num, Integral, Fractional`,
    and `Floating`*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 8-1](ch08.xhtml#ch8fig1), types are preceded by a bullet and type
    classes are not. As you can see, the types `Int` and `Integer` are instances of
    type classes `Integral` and `Num`. The types `Float` and `Double` are instances
    of type classes `Floating`, `Fractional`, and `Num`.
  prefs: []
  type: TYPE_NORMAL
- en: Exponentiation and Type Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell offers three operators for exponentiation, shown in [Table 8-2](ch08.xhtml#ch8tab2).
    The difference between these operators lies in the type class constraints that
    each work under and in the methods of implementation. The single caret operator
    (`^`) requires that the exponent be a nonnegative integer. Exponentiation by `^`
    repeatedly multiplies a `Num` by itself. The double-caret operator (`^^`) requires
    that the exponent be an integer, enforced by the `Integral b` constraint. The
    `^^` operator can be implemented by repeated multiplication and taking reciprocals,
    and it can accept a negative exponent. The double-star operator (`**`) requires
    that the base and the exponent have the same type and that that type be an instance
    of `Floating`. This operator requires a more complicated implementation, taking
    a logarithm and using the exponential function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** Haskell’s Three Functions for Exponentiation'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(^)` | `::` | `(Integral b, Num a) => a -> b -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^^)` | `::` | `(Fractional a, Integral b) => a -> b -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(**)` | `::` | `Floating a => a -> a -> a` |'
  prefs: []
  type: TYPE_TB
- en: Since `Float` and `Double` are members of the `Floating` type class, and thus
    represent numbers approximately, the `**` operator is generally going to do an
    approximate calculation. This is certainly what you want for a non-integral exponent.
    Under the right circumstances, the caret and double-caret operators can do exact
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-3](ch08.xhtml#ch8tab3) shows which of types (`Int`, `Integer`, `Float`,
    and `Double`) are allowable for the base `x` and the exponent `y` in the expression
    `x ^^ y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-3:** Possible Types for `x` and `y` with the Double-Caret Exponentiation
    Operator'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **`y :: Int`** | **`y :: Integer`** | **`y :: Float`** | **`y :: Double`**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x :: Int` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x :: Integer` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x :: Float` | `^^` | `^^` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x :: Double` | `^^` | `^^` |  |  |'
  prefs: []
  type: TYPE_TB
- en: Since the base must have a type that is an instance of `Fractional`, only `Float`
    and `Double` can serve as a type for the base. Since the exponent must have a
    type that is an instance of `Integral`, only `Int` and `Integer` can serve as
    a type for the exponent.
  prefs: []
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An infix operator expects an argument on its left and an argument on its right.
    If only one of these two arguments is given, the resulting expression can be thought
    of as a function waiting for the other argument. Haskell allows us to make such
    functions by enclosing an operator and one of its arguments in parentheses. A
    function formed by enclosing an operator and one argument in parentheses is called
    a *section*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-4](ch08.xhtml#ch8tab4) shows examples of sections, with their types.
    Many useful sections have types with type-class constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-4:** Examples of Sections'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(+1)` | `::` | `Num a => a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(2*)` | `::` | `Num a => a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^2)` | `::` | `Num a => a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(2^)` | `::` | `(Integral b, Num a) => b -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(''A'':)` | `::` | `[Char] -> [Char]` |'
  prefs: []
  type: TYPE_TB
- en: '| `(:"end")` | `::` | `Char -> [Char]` |'
  prefs: []
  type: TYPE_TB
- en: '| `("I won''t " ++)` | `::` | `[Char] -> [Char]` |'
  prefs: []
  type: TYPE_TB
- en: '| `($ True)` | `::` | `(Bool -> b) -> b` |'
  prefs: []
  type: TYPE_TB
- en: For example, `(+1)`, which could also be written `(1+)`, is a function that
    adds 1 to its argument, and `(2*)`, which could also be written `(*2)`, is a function
    that doubles its argument. However, the sections `(^2)` and `(2^)` are not the
    same function; the former is the squaring function and the latter is the “2 to
    the power of” function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sections can be useful in the same way that anonymous functions are useful:
    they provide a quick way of specifying a function without naming it, often as
    an input to a higher-order function.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a section to integrate the squaring function. Using the `integral`
    function from [Chapter 6](ch06.xhtml),
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'we can use a section for the squaring function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Like anonymous functions, sections give the programmer tools to create functions
    “on the fly” without having to name them. And like anonymous functions, using
    sections requires a bit of care since it is easy to forget why you defined a particular
    section. This is because the terse syntax provides no clue about what you meant
    when you wrote it. If the meaning of a section is not immediately clear, a short
    function definition with an evocative name may be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Example of Type Classes and Plotting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we mentioned that the Haskell type checker
    will sometimes complain if it cannot determine concrete types for each expression
    it needs to deal with. The solution is to add a type signature or type annotation
    to your code. As an example of this, create a new program file called *typeTrouble.hs*
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When I try to load this file into GHCi, I get this horrible-looking error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Don’t panic. This error message contains much more information than we need
    to solve the problem. The most useful part of the message is the first line, which
    tells where the problem is in the code (line 3, column 9). At line 3, column 9
    of our code is the function `plotFunc`. Let’s look at the type of `plotFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm. Life just got worse. But this latter error is an easy one. “Variable not
    in scope” means that GHCi doesn’t know this function. That makes sense, actually,
    because it’s not included in the Prelude (the collection of built-in functions
    that are loaded automatically when we start up GHCi), and GHCi refused to load
    our *typeTrouble.hs* file because it had a problem with it. At the moment, it
    has no knowledge of `plotFunc`. The `plotFunc` function is defined in the `Graphics.Gnuplot.Simple`
    module. We can get access to `plotFunc` by loading the plotting module manually,
    like we first did to make a quick plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s ask again for the type of `plotFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of type class constraints to the left of the `=>`. I don’t
    know the specifics of those type classes, but as long as `a` (a type variable)
    belongs to those two type classes, the type of `plotFunc` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `plotFunc` needs a list of `Attribute`s (we have given an empty
    list in our examples so far), a list of `a`s, and a function that takes an `a`
    as input and gives back an `a` as output. If we give `plotFunc` all this stuff,
    it will give us back an `IO ()`, which is a way of saying that it will actually
    *do* something for us (make a plot).
  prefs: []
  type: TYPE_NORMAL
- en: The key to fixing an “ambiguous type variable” error like this lies in the suggestion
    of the fifth line in the error message shown earlier. Add a type signature to
    your code. The Haskell type checker would like more help figuring out the types
    of things. In particular, it can’t figure out the types of `[0,0.01..10]` and
    `cos`. Let’s ask GHCi about the types of these two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both of these expressions contain type class constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution to the problem is to give the list `[0,0.01..10]` a name and a
    type signature. Let’s make a program file called *typeTrouble2.hs* with the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This program file should load fine and give you a nice plot when you enter `plot2`.
    Try it and see.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second solution is to specify the type of the list `[0,0.01..10]` on the
    line where it’s used. We could make a program file called *typeTrouble3.hs* with
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A third solution, which is my favorite because it involves the fewest keystrokes,
    is to tell the compiler that the final element of the list, `10`, has type `Double`.
    This implies that all of the elements in the list have type `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The moral of the story is that you should include type signatures for all of
    the functions you define, and you should be prepared to add more type signatures
    if the type checker complains.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced the idea of a type class, something that contains types
    and owns certain functions. We discussed several standard type classes from the
    Prelude, in addition to functions that have type-class constraints. We saw that
    a section is a function without a name, formed by combining an operator with one
    of its arguments. Many sections have types with type-class constraints. Finally,
    we gave an example where it was necessary to add a type annotation to our code
    to satisfy the Haskell type checker.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of type classes, we have described almost all of Haskell’s
    type system. There are basic types, function types, list types, type variables,
    and type classes. Once we cover tuple types in the next chapter, we’ll have described
    Haskell’s type system in full.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 8.1.** Is it possible for a type to belong to more than one type
    class? If so, give an example. If not, why not?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.2.** We said in this chapter that function types are typically
    not instances of `Eq` because it’s too hard to check whether two functions are
    equal.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) What does it mean mathematically for two functions to be equal?
  prefs: []
  type: TYPE_NORMAL
- en: (b) Why is it usually very hard or impossible for the computer to check if two
    functions are equal?
  prefs: []
  type: TYPE_NORMAL
- en: (c) Give a specific example of a function type that would be easy to check for
    equality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.3.** The function `(*2)` is the same as the function `(2*)`. Is
    the function `(/2)` the same as the function `(2/)`? Explain what these functions
    do.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.4.** In [Chapter 2](ch02.xhtml), we defined a function `square`.
    Now that we know that Haskell has sections, we can see that we didn’t need to
    define `square`. Show how to use a section to write the function that squares
    its argument. How about a section for the function that cubes its argument?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.5.** You can get information from GHCi about a type or a type
    class by using the GHCi command `:info` (`:i` for short), followed by the name
    of the type or type class you want information about. If you ask for information
    about a type, GHCi will tell you the type classes of which your type is an instance
    (the line `instance Num Double`, for example, means that the type `Double` is
    an instance of the type class `Num`). If you ask for information about a type
    class, GHCi will tell you the types that are instances of your type class.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) We showed in [Table 8-1](ch08.xhtml#ch8tab1) that the type `Integer` was
    an instance of type classes `Eq`, `Ord`, `Show`, `Num`, and `Integral`. There
    are a few more type classes that we did not discuss of which `Integer` is also
    an instance. Find these.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Type class `Enum` is for types that can be enumerated, or listed. Which
    Prelude types are instances of `Enum`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.6.** Find the types of the following Prelude Haskell expressions
    (some are functions and some are not):'
  prefs: []
  type: TYPE_NORMAL
- en: (a) `42`
  prefs: []
  type: TYPE_NORMAL
- en: (b) `42.0`
  prefs: []
  type: TYPE_NORMAL
- en: (c) `42.5`
  prefs: []
  type: TYPE_NORMAL
- en: (d) `pi`
  prefs: []
  type: TYPE_NORMAL
- en: (e) `[3,1,4]`
  prefs: []
  type: TYPE_NORMAL
- en: (f) `[3,3.5,4]`
  prefs: []
  type: TYPE_NORMAL
- en: (g) `[3,3.1,pi]`
  prefs: []
  type: TYPE_NORMAL
- en: (h) `(==)`
  prefs: []
  type: TYPE_NORMAL
- en: (i) `(/=)`
  prefs: []
  type: TYPE_NORMAL
- en: (j) `(<)`
  prefs: []
  type: TYPE_NORMAL
- en: (k) `(<=)`
  prefs: []
  type: TYPE_NORMAL
- en: (l) `(+)`
  prefs: []
  type: TYPE_NORMAL
- en: (m) `(-)`
  prefs: []
  type: TYPE_NORMAL
- en: (n) `(*)`
  prefs: []
  type: TYPE_NORMAL
- en: (o) `(/)`
  prefs: []
  type: TYPE_NORMAL
- en: (p) `(^)`
  prefs: []
  type: TYPE_NORMAL
- en: (q) `(**)`
  prefs: []
  type: TYPE_NORMAL
- en: (r) `8/4`
  prefs: []
  type: TYPE_NORMAL
- en: (s) `sqrt`
  prefs: []
  type: TYPE_NORMAL
- en: (t) `cos`
  prefs: []
  type: TYPE_NORMAL
- en: (u) `show`
  prefs: []
  type: TYPE_NORMAL
- en: (v) `(2/)`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.7.** If 8/4 = 2, and `2 :: Num a => a` (2 has type `a` for every
    type `a` in type class `Num`), why does `8/4 :: Fractional a => a`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.8.** The functions `quot`, `rem`, `div`, and `mod` all have to
    do with integer division and remainders. All of these functions work with types
    that are instances of type class `Integral`, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `quot` | `::` | `Integral a => a -> a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `rem` | `::` | `Integral a => a -> a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `div` | `::` | `Integral a => a -> a -> a` |'
  prefs: []
  type: TYPE_TB
- en: '| `mod` | `::` | `Integral a => a -> a -> a` |'
  prefs: []
  type: TYPE_TB
- en: By playing around with these functions, try to explain in words what each does.
    What is the difference between `quot` and `div`? What is the difference between
    `rem` and `mod`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 8.9.** Make a table like [Table 8-3](ch08.xhtml#ch8tab3), showing
    which of types `Int`, `Integer`, `Float`, and `Double` can be used for the base
    `x` and the exponent `y` in the expression `x ^ y`. Do the same for the expression
    `x ** y`. Finally, find a pair of types `a` and `b` for which there is no exponentiation
    operator that allows the base to have type `a` and the exponent to have type `b`.'
  prefs: []
  type: TYPE_NORMAL
