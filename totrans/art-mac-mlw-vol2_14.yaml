- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 11 PERSISTENCE MONITOR
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11 持久性监控器
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: While KnockKnock, covered in the previous chapter, provides a powerful detection
    capability, it doesn’t protect the system in real time. To complement it, I created
    BlockBlock, which monitors the most important persistence locations enumerated
    by KnockKnock, alerts the user whenever a new item appears, and gives them the
    ability to block the activity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上一章中介绍的 KnockKnock 提供了强大的检测能力，但它并不实时保护系统。为了补充它，我创建了 BlockBlock，它监控 KnockKnock
    列出的最重要的持久性位置，并在新项出现时提醒用户，同时赋予他们阻止该活动的能力。
- en: BlockBlock’s initial versions, written in 2014, were largely proofs of concept,
    which didn’t stop employees from commercial security companies from labeling the
    tool “lam[e]ware” and concluding that “providing quality service for nothing can’t
    be a one-person job.”^([1](#chapter11-1)) Over the years, BlockBlock has matured,
    consistently proving its merit with a near 100 percent detection rate of persistent
    Mac malware, even without prior knowledge of these threats.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock 的初始版本于2014年编写，主要是概念验证，尽管如此，来自商业安全公司的员工仍然把这个工具称为“垃圾软件”，并得出结论：“提供免费的优质服务不是一个人的工作。”^([1](#chapter11-1))
    多年来，BlockBlock 已逐步成熟，始终凭借接近100%的检测率有效识别持久性 Mac 恶意软件，即使事先没有这些威胁的相关知识。
- en: In this chapter, I’ll discuss BlockBlock’s design and show how it uses Endpoint
    Security to effectively detect unauthorized persistence events. You’ll learn how
    to request and apply the required Endpoint Security client entitlement and how
    XPC can allow tool components to securely communicate with one another. You can
    find BlockBlock’s source code in its entirety in the Objective-See GitHub repository
    at [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock*](https://github.com/objective-see/BlockBlock).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论 BlockBlock 的设计，并展示它如何利用 Endpoint Security 有效检测未经授权的持久性事件。你将了解如何申请和应用所需的
    Endpoint Security 客户端授权，以及如何通过 XPC 使工具组件之间安全地进行通信。你可以在 Objective-See 的 GitHub
    仓库中找到完整的 BlockBlock 源代码，网址是 [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock*](https://github.com/objective-see/BlockBlock)。
- en: Entitlements
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权
- en: Multiple BlockBlock components leverage Endpoint Security, which means the tool
    must receive a privileged entitlement from Apple. Without the entitlement, attempts
    to create an Endpoint Security client at runtime will fail unless we’ve disabled
    System Integrity Protection (SIP) and Apple Mobile File Integrity (AMFI). So,
    let’s start by walking through the process of requesting the Endpoint Security
    client entitlement from Apple and, once it’s granted, applying it to BlockBlock.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 BlockBlock 组件利用了 Endpoint Security，这意味着该工具必须从 Apple 获得特权授权。如果没有授权，除非我们禁用了系统完整性保护（SIP）和
    Apple 移动文件完整性（AMFI），否则在运行时创建 Endpoint Security 客户端的尝试将失败。所以，让我们首先了解如何向 Apple 请求
    Endpoint Security 客户端授权，一旦获得授权，如何将其应用到 BlockBlock。
- en: Applying for Endpoint Security Entitlements
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 申请 Endpoint Security 授权
- en: You can apply for Endpoint Security entitlements at [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/contact<wbr>/request<wbr>/system<wbr>-extension<wbr>/*](https://developer.apple.com/contact/request/system-extension/).
    The request form asks for developer information, such as your name and company,
    then presents a drop-down menu containing a list of entitlements you can request.
    Select the Endpoint Security client entitlement, **com.apple.developer.endpoint-security.client**.
    At the bottom of the form, describe how you intend to use the entitlement you’re
    requesting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/contact<wbr>/request<wbr>/system<wbr>-extension<wbr>/*](https://developer.apple.com/contact/request/system-extension/)
    申请 Endpoint Security 授权。申请表格会要求提供开发者信息，如你的姓名和公司，然后展示一个包含可申请授权列表的下拉菜单。选择 Endpoint
    Security 客户端授权 **com.apple.developer.endpoint-security.client**。在表格底部，描述你计划如何使用你所申请的授权。
- en: Given the power of Endpoint Security, Apple is understandably cautious about
    granting requests for the client entitlement, even to renowned security companies.
    That said, you can take several measures to improve your chances of receiving
    one. First, register as a company, such as an LLC or equivalent. I’m aware of
    only one instance in which Apple granted the Endpoint Security client entitlement
    to an individual. Second, in your request, make sure to describe exactly what
    you plan to do with the entitlement. The Endpoint Security client entitlement
    is designed for security tools, so include details of the tool you’re developing
    and articulate exactly why it needs the use of Endpoint Security. Finally, be
    prepared to wait.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于端点安全的强大功能，苹果在授予客户端权限请求时非常谨慎，即使是知名的安全公司也是如此。也就是说，你可以采取一些措施来提高获得权限的机会。首先，注册为公司，例如有限责任公司（LLC）或类似公司。我只知道苹果曾经将端点安全客户端权限授予过一个个人。其次，在你的请求中，确保详细描述你计划如何使用该权限。端点安全客户端权限是为安全工具设计的，因此请包括你正在开发的工具的细节，并明确说明为什么它需要使用端点安全。最后，要做好等待的准备。
- en: Registering App IDs
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册 App ID
- en: Once Apple has granted you the entitlement, you must register an App ID for
    your tool, specifying its bundle ID and the entitlements it will use. Log in to
    your Apple Developer account, click **Account**, then navigate to **Certificates,
    Identifiers & Profiles****Identifiers**. If you have any existing identifiers,
    they should show up here. To create a new identifier, click **+**. Select **App
    IDs**, then click **Continue**. Select **App** and **Continue** again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦苹果授予了你权限，你必须为你的工具注册一个 App ID，指定它的捆绑 ID 和将使用的权限。登录到你的 Apple Developer 账户，点击**Account**，然后导航到**Certificates,
    Identifiers & Profiles****Identifiers**。如果你已有任何现有的标识符，它们应该会显示在这里。要创建新的标识符，点击**+**。选择**App
    IDs**，然后点击**Continue**。选择**App**并再次点击**Continue**。
- en: This should bring you to the App ID registration form. Most of the fields are
    self-explanatory. For the Bundle ID, Apple recommends using a reverse-domain name
    style, generally in the form *com.company.product*. For BlockBlock, I populated
    the fields as shown in [Figure 11-1](chapter11.xhtml#fig11-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将你带到 App ID 注册表单。大多数字段的含义显而易见。对于捆绑 ID，苹果建议使用反向域名样式，通常为 *com.company.product*。对于
    BlockBlock，我按照[图 11-1](chapter11.xhtml#fig11-1)中所示填写了字段。
- en: '![](../images/Figure11-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.jpg)'
- en: 'Figure 11-1: Registering the BlockBlock app ID'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：注册 BlockBlock 应用 ID
- en: In the remainder of the form, you’ll see options to specify either capabilities,
    app services, or additional capabilities for your tool. Assuming Apple has granted
    you the Endpoint Security client entitlement, click **Additional Capabilities**,
    then select the checkbox next to Endpoint Security. To register the new identifier,
    click **Register**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单的其余部分，你将看到选项，允许你为你的工具指定能力、应用服务或附加功能。如果苹果已经授予你端点安全客户端权限，点击**Additional Capabilities**，然后选择“端点安全”旁边的复选框。要注册新的标识符，点击**Register**。
- en: Creating Provisioning Profiles
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: Now you can create the provisioning profile, which provides the mechanism that
    the operating system will use to authorize the use of the entitlement at runtime.^([2](#chapter11-2))
    Clicking **Profiles** in your Developer Account should take you to a page containing
    all of your current profiles. You can also register a new profile by clicking
    +. On the first page, specify the provisioning profile’s type. Unless you’ll be
    distributing your tool via the Mac App Store, select **Developer ID** at the very
    bottom of the page. Click **Continue**, then select the App ID you just created.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建配置文件，它提供了操作系统在运行时授权使用权限的机制。^([2](#chapter11-2)) 点击你开发者账户中的**Profiles**，应该会带你到一个页面，显示你当前的所有配置文件。你也可以通过点击
    + 来注册新的配置文件。在第一页上，指定配置文件的类型。除非你通过 Mac App Store 分发你的工具，否则请选择页面底部的**Developer ID**。点击**Continue**，然后选择你刚刚创建的
    App ID。
- en: Next, select the certificate to include in your profile. This is the same certificate
    you’ll use to sign your application, likely your Apple Developer certificate.
    On the next page, you’ll be given a list of available entitlements you can add
    to the provisioning profile. To leverage Endpoint Security, select **System Extension
    EndpointSecurity for macOS**. If Apple hasn’t yet granted you this entitlement,
    it won’t show up in the list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择要包含在配置文件中的证书。这是你用来签名应用程序的证书，可能是你的 Apple Developer 证书。在下一页面中，你将看到可以添加到配置文件中的可用权限列表。要使用
    Endpoint Security，选择 **System Extension EndpointSecurity for macOS**。如果 Apple
    尚未授予你此权限，它将不会出现在列表中。
- en: Enabling Entitlements in Xcode
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Xcode 中启用权限
- en: Once you’ve generated the provisioning profile, you can head to Xcode to add
    it to your project. First, tell Xcode that your project will use Endpoint Security
    by clicking the small **+** next to **Capabilities** in the Signing & Capabilities
    pane and then selecting **Endpoint Security** capability. Behind the scenes, this
    will add the entitlement to the project’s entitlement file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了配置文件，你可以进入 Xcode 将其添加到你的项目中。首先，通过点击签名和功能面板中 **Capabilities** 旁的小**+**，然后选择
    **Endpoint Security** 功能，告诉 Xcode 你的项目将使用 Endpoint Security。幕后，Xcode 会将权限添加到项目的权限文件中。
- en: Now, when building the tool for deployment, you can select the provisioning
    profile. The first time you do this, you might have to download and import the
    profile into Xcode. Download the profile you generated from your Apple Developer
    account. Then, in Xcode’s Select Certificate and Developer ID Profiles window,
    select the **Import Profile** option, found in the drop-down menu next to the
    application’s name, and browse to the downloaded profile.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构建用于部署的工具时，你可以选择配置文件。第一次这样做时，你可能需要下载并将配置文件导入 Xcode。首先，从你的 Apple Developer
    账户下载你生成的配置文件。然后，在 Xcode 的“选择证书和开发者 ID 配置文件”窗口中，选择**导入配置文件**选项，该选项位于应用程序名称旁边的下拉菜单中，浏览并选择下载的配置文件。
- en: 'If all goes well, you should have a compiled, entitled tool that also contains
    the provisioning profile. For example, BlockBlock’s provisioning profile is embedded
    in its app bundle at the standard location, *Contents/embedded.provisionprofile*.
    You can dump any embedded provisioning profile by running the macOS security tool,
    along with the command line flags cms -D -i and this path. The following output
    contains BlockBlock’s App ID, information about its code signing certificate,
    and the entitlements it is authorized to use:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该拥有一个已编译、已授权的工具，并且该工具还包含了配置文件。例如，BlockBlock 的配置文件嵌入在其应用程序包的标准位置 *Contents/embedded.provisionprofile*
    中。你可以通过运行 macOS 安全工具和命令行标志 cms -D -i 以及该路径，提取任何嵌入的配置文件。以下输出包含 BlockBlock 的应用 ID、其代码签名证书的信息以及它被授权使用的权限：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use the codesign utility to view any entitlements a program possesses.
    For BlockBlock, this list includes the Endpoint Security client entitlement:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 codesign 工具查看程序所拥有的任何权限。对于 BlockBlock，这个列表包括 Endpoint Security 客户端权限：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because macOS requires a provisioning profile to authorize the entitlement,
    even programs not typically developed as applications, such as daemons, must be
    packaged as application bundles to leverage Endpoint Security. You can read more
    about this design choice in Apple’s documentation,^([3](#chapter11-3)) which also
    notes that if you switch from a daemon to a system extension, Xcode will automatically
    handle the packaging for you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 macOS 需要一个配置文件来授权权限，即使是那些通常不作为应用程序开发的程序，如守护进程，也必须打包成应用程序包才能利用 Endpoint Security。你可以在
    Apple 的文档中了解更多关于此设计选择的内容，^([3](#chapter11-3))，文档中还提到，如果你从守护进程切换到系统扩展，Xcode 会自动为你处理打包工作。
- en: '### Tool Design'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '### 工具设计'
- en: 'BlockBlock is composed of two pieces: a launch daemon and a login item. The
    daemon is packaged as an application bundle to accommodate the use of entitlements
    and provisioning profiles. It runs in the background with root privileges, monitoring
    for persistence events (by ingesting file input/output and other events delivered
    from Endpoint Security), managing rules, and blocking user-specified persistent
    items. Anytime it detects a persistence event, the daemon sends an XPC message
    to the login item. The login item, which runs in the context of the user’s desktop
    session and thus is capable of displaying user interface (UI) elements, will then
    show the user an alert ([Figure 11-2](chapter11.xhtml#fig11-2)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock由两部分组成：一个启动守护进程和一个登录项。守护进程作为一个应用程序包装，以便使用权限和配置文件。它在后台以root权限运行，监控持久化事件（通过处理文件输入/输出和从Endpoint
    Security传递的其他事件），管理规则，并阻止用户指定的持久项。每当它检测到一个持久化事件时，守护进程会向登录项发送一个XPC消息。登录项在用户的桌面会话上下文中运行，因此能够显示用户界面（UI）元素，随后会向用户显示一个警报（[图11-2](chapter11.xhtml#fig11-2)）。
- en: '![](../images/Figure11-2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.jpg)'
- en: 'Figure 11-2: A BlockBlock alert'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：一个BlockBlock警报
- en: BlockBlock’s alerts contain plenty of information about the item that installed
    the persistent item and the persistent item itself. This information can assist
    the user in deciding whether to allow or delete the item. For example, various
    red flags in the alert shown in [Figure 11-2](chapter11.xhtml#fig11-2) indicate
    an infection. First, the item that installed the launch agent, *airportpaird*,
    is unsigned, as indicated by the perplexed frowning face. From its path, you can
    also see that it’s running from a temporary directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock的警报包含了关于安装持久项的项目及持久项本身的丰富信息。这些信息可以帮助用户决定是否允许或删除该项。例如，[图11-2](chapter11.xhtml#fig11-2)中显示的警报中的各种红色警告标志表明存在感染。首先，安装启动代理的项*airportpaird*没有签名，如困惑的皱眉脸所示。从其路径可以看出，它是从临时目录运行的。
- en: If you turn your attention to the persistent item, you’ll notice that the property
    list is prefixed with com.apple, implying that it belongs to Apple. However, it’s
    installed in the user’s Launch Agent directory, which only ever contains third-party
    agents. Moreover, the persistent item that this property list references is installed
    and runs from a hidden directory (*.local*). Finally, if you manually examined
    the code signing information of this binary, *softwareupdate*, you would see it
    is unsigned.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将注意力转向持久项，您会注意到属性列表以com.apple为前缀，暗示它属于Apple。然而，它被安装在用户的启动代理目录中，而该目录仅包含第三方代理。此外，属性列表所引用的持久项是安装并从隐藏目录（*.local*）运行的。最后，如果您手动检查这个二进制文件*softwareupdate*的代码签名信息，您会发现它没有签名。
- en: When I originally released BlockBlock in 2014, Apple didn’t yet support System
    Extensions, which is why I placed the tool’s core logic in a launch daemon. Today,
    BlockBlock continues to make use of a daemon even though doing so isn’t strictly
    necessary, as the approach still has benefits. For one, you might want to develop
    tools that maintain compatibility with older versions of macOS. It’s also easy
    for any sufficiently privileged tool to install and manage launch daemons. On
    the other hand, System Extensions require additional entitlements, and to install
    or remove them, you’ll typically need explicit user approval. This adds complexity
    and requires additional code. Still, there are cases where putting your code into
    a System Extension makes sense, as you’ll see in [Chapter 13](chapter13.xhtml).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2014年首次发布BlockBlock时，Apple尚未支持系统扩展，这也是为什么我将工具的核心逻辑放在了启动守护进程中。今天，尽管这样做并非绝对必要，BlockBlock仍然继续使用守护进程，因为这种方法仍然有其优势。首先，您可能希望开发与旧版本macOS兼容的工具。其次，任何具有足够权限的工具都可以安装和管理启动守护进程。另一方面，系统扩展需要额外的权限，并且要安装或删除它们，通常需要明确的用户批准。这增加了复杂性，并需要额外的代码。然而，在某些情况下，将代码放入系统扩展中是有意义的，正如您在[第13章](chapter13.xhtml)中将看到的那样。
- en: Plug-ins
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插件
- en: Like KnockKnock, BlockBlock uses statically compiled plug-ins to detect multiple
    types of persistence. Each plug-in is responsible for handling either one unique
    persistent event or several related ones. The tool stores metadata about each
    plug-in in a property list file, including the name of the plug-in class, various
    descriptions of it to customize alerts, and, most importantly, a regular expression
    describing the path or paths of file events in which the plug-in is interested.
    For example, [Listing 11-1](chapter11.xhtml#Lis11-1) shows the metadata for the
    plug-in that monitors file events for the additions of new launch daemons and
    agents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 KnockKnock，BlockBlock 使用静态编译的插件来检测多种类型的持久化。每个插件负责处理一个独特的持久化事件或多个相关事件。该工具将每个插件的元数据存储在属性列表文件中，包括插件类的名称、用于定制警报的各种描述，以及最重要的，描述插件感兴趣的文件事件路径的正则表达式。例如，[列表
    11-1](chapter11.xhtml#Lis11-1) 显示了监视启动守护进程和代理新增的文件事件的插件元数据。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-1: Metadata for the launch item plug-in'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-1：启动项插件的元数据
- en: The regular expression will be applied to incoming file input/output events,
    matching on those that were ingested due to the addition of property lists added
    to the launch daemons and agents directories such as */System/Library/LaunchDaemons*
    or *~/ Library/LaunchAgents*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式将应用于传入的文件输入/输出事件，匹配那些由于添加到启动守护进程和代理目录（如*/System/Library/LaunchDaemons*
    或 *~/ Library/LaunchAgents*）的属性列表而被处理的事件。
- en: 'All plug-ins inherit from a custom base class named PluginBase that implements
    base methods, such as a standard initialization method and methods to check whether
    a file event matches an event of interest. The initialization method initWithParams:
    takes one parameter, a dictionary containing a plug-in’s metadata ([Listing 11-2](chapter11.xhtml#Lis11-2)).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有插件都继承自一个名为`PluginBase`的自定义基类，该类实现了基础方法，如标准初始化方法和检查文件事件是否与感兴趣事件匹配的方法。初始化方法`initWithParams:`接受一个参数，即包含插件元数据的字典（[列表
    11-2](chapter11.xhtml#Lis11-2)）。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-2: The base class logic for plug-in object initialization'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-2：插件对象初始化的基类逻辑
- en: Here, you can see that the method first compiles each of the plug-in’s paths
    of interest into regular expressions and then extracts other values from the metadata
    dictionary to save into instance variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到该方法首先将每个插件感兴趣的路径编译成正则表达式，然后从元数据字典中提取其他值并保存到实例变量中。
- en: Another important base method, isMatch:, accepts a file object representing
    an event from the *FileMonitor* library, then checks for a match against the plug-in
    paths of interest ([Listing 11-3](chapter11.xhtml#Lis11-3)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的基类方法`isMatch:`接受一个表示来自*FileMonitor*库的事件的文件对象，然后检查是否与插件感兴趣的路径匹配（[列表 11-3](chapter11.xhtml#Lis11-3)）。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-3: Filepath matching'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-3：文件路径匹配
- en: 'The method runs enumerateObjectsWithOptions:usingBlock: on the array of the
    plug-in’s regular expressions so it can iterate over all of them concurrently
    ❶. In the concurrently invoked callback block, it uses the current regular expression
    to check whether the destination file matches an event of interest to the plug-in
    ❷. For example, for the launch item plug-in, the method will check whether the
    file event corresponds to the creation of a property list in a launch daemon or
    agent directory. If a match does occur, the method sets a flag and terminates
    the enumeration ❸.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在插件的正则表达式数组上运行`enumerateObjectsWithOptions:usingBlock:`，以便可以并发地迭代它们❶。在并发调用的回调块中，它使用当前的正则表达式检查目标文件是否匹配插件感兴趣的事件❷。例如，对于启动项插件，该方法将检查文件事件是否与启动守护进程或代理目录中属性列表的创建对应。如果发生匹配，方法会设置标志并终止枚举❸。
- en: 'Other methods in the base plug-in class are left for each plug-in to implement.
    For example, the block: method, invoked when the user clicks the Block button
    on the alert, will remove the persistent item. This logic must differ based on
    the type of item persisted. If you’re interested in the specific uninstallation
    logic for each kind of persistent item, take a look at the code of each plug-in’s
    block: method.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基础插件类中的其他方法留给每个插件来实现。例如，当用户点击警报中的“Block”按钮时，调用的`block:`方法将移除持久化项。这个逻辑必须根据持久化项的类型有所不同。如果你对每种持久化项的具体卸载逻辑感兴趣，可以查看每个插件的`block:`方法的代码。
- en: At its core, BlockBlock ingests events from the *FileMonitor* library, which
    leverages Apple’s Endpoint Security. After initializing a FileMonitor object with
    the specific events of interest, it specifies a callback block and then begins
    file monitoring ([Listing 11-4](chapter11.xhtml#Lis11-4)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，BlockBlock 从*FileMonitor*库中获取事件，该库利用了 Apple 的 Endpoint Security。在用特定的感兴趣事件初始化
    FileMonitor 对象后，它指定一个回调块，然后开始文件监控（[清单 11-4](chapter11.xhtml#Lis11-4)）。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-4: A helper method invoked for each file event'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-4：为每个文件事件调用的辅助方法
- en: 'If you look carefully at the Endpoint Security events of interest passed to
    the file monitor, you’ll see both file and process events ❶. It makes sense to
    initialize a file monitor with file events, and we need the process events to
    record the arguments of processes creating persistent items. Although not every
    process that persists an item is invoked with arguments, many are, and in those
    cases, we include the arguments in the alert shown to the user to help them determine
    whether the persistence event is benign or malicious. Before we discuss the processing
    of file input/output events, note that the file monitor logic is started by invoking
    the start:count:csOption:callback: method.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察传递给文件监控器的 Endpoint Security 感兴趣事件，你会看到既有文件事件，也有进程事件 ❶。初始化文件监控器时包含文件事件是有意义的，我们需要进程事件来记录创建持久性项目的进程的参数。尽管并非每个持久化项目的进程都会带有参数，但许多进程是有的，在这些情况下，我们会将参数包含在展示给用户的警报中，帮助他们判断持久化事件是正常还是恶意的。在我们讨论文件输入/输出事件的处理之前，请注意，文件监控器逻辑是通过调用
    `start:count:csOption:callback:` 方法启动的。
- en: 'When the file monitor receives events, it invokes the specified callback block
    with a File object representing the event. The callback simply hands this object
    a helper method named processEvent:plugin:message: ❷. This method calls each plug-in’s
    isMatch: method to see whether the file event matches any persistence locations,
    such as the creation of a *.plist* in the launch daemon or agent directories.
    If any plug-in is interested in the file event, BlockBlock creates a custom Event
    object with both the file object representing the persistence event and the relevant
    plug-in.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件监控器接收到事件时，它会调用指定的回调块，并传递一个表示该事件的文件对象。回调方法仅仅调用一个名为 `processEvent:plugin:message:`
    的辅助方法 ❷。该方法调用每个插件的 `isMatch:` 方法，以查看文件事件是否与任何持久化位置匹配，例如在启动守护进程或代理目录中创建 *.plist*
    文件。如果有插件对该文件事件感兴趣，BlockBlock 会创建一个自定义的 Event 对象，该对象包含表示持久化事件的文件对象和相关插件。
- en: Next, the method checks whether the event matches any existing rules. Rules
    get created when a user interacts with an alert. They can either allow or block
    persistence items based on factors like the item’s startup file or the process
    responsible for triggering the event. For example, on my developer box, where
    I also dabble in photography and photo editing, there are rules allowing the creation
    of various Adobe Creative Cloud launch agents ([Figure 11-3](chapter11.xhtml#fig11-3)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，方法检查事件是否与任何现有规则匹配。规则是在用户与警报互动时创建的。它们可以根据诸如项目的启动文件或触发事件的进程等因素，允许或阻止持久性项目。例如，在我的开发者设备上，我也涉及摄影和照片编辑，那里有规则允许创建各种
    Adobe Creative Cloud 启动代理（[图 11-3](chapter11.xhtml#fig11-3)）。
- en: '![](../images/Figure11-3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.jpg)'
- en: 'Figure 11-3: BlockBlock rules can allow or block events from specified processes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：BlockBlock 规则可以允许或阻止来自指定进程的事件。
- en: Because Adobe frequently updates these persistent items, without these rules
    I’d be regularly responding to BlockBlock alerts. If it finds a matching rule,
    BlockBlock automatically takes the action specified in the rule. Otherwise, it
    delivers the event to the BlockBlock login item to show an alert to the user.
    Shortly, we’ll take a closer look at how bidirectional XPC achieves this communication.
    First, though, let’s explore BlockBlock’s use of the Endpoint Security Background
    Task Management events.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Adobe 经常更新这些持久性项目，如果没有这些规则，我会频繁响应 BlockBlock 警报。如果找到匹配的规则，BlockBlock 会自动执行规则中指定的操作。否则，它会将事件发送到
    BlockBlock 登录项，向用户显示警报。稍后，我们将更深入地了解双向 XPC 如何实现这种通信。不过，首先，让我们探讨一下 BlockBlock 如何使用
    Endpoint Security 背景任务管理事件。
- en: Background Task Management Events
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 背景任务管理事件
- en: One downside to using a global file monitor to detect persistence is that it’s
    rather inefficient, as file events happen almost constantly as part of normal
    system behavior. While we could mitigate the influx of traffic using Endpoint
    Security’s mute inversion capabilities covered in [Chapter 9](chapter9.xhtml),
    BlockBlock needs to monitor many locations to detect multiple methods of persistence,
    and mute inversion may not fully alleviate the inefficiencies of a file monitor–based
    approach.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局文件监视器来检测持久化的一个缺点是它效率较低，因为文件事件几乎会随着正常的系统行为不断发生。虽然我们可以利用[第9章](chapter9.xhtml)中介绍的Endpoint
    Security的静音反转功能来缓解流量的涌入，但BlockBlock需要监视多个位置以检测多种持久化方法，而静音反转可能无法完全缓解基于文件监视器的方法效率低下的问题。
- en: 'A better solution for our purposes would be to subscribe to persistence events
    rather than file events. In previous chapters, I discussed the Background Task
    Management subsystem, a recent addition to macOS that governs the most popular
    types of persistence, including login items, launch agents, and daemons. Background
    Task Management also added two events to Endpoint Security: ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD
    and ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_REMOVE, which clients can receive whenever
    a login or launch item is persisted or removed.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们而言，一个更好的解决方案是订阅持久化事件，而不是文件事件。在之前的章节中，我讨论了Background Task Management子系统，这是macOS中的一项新功能，它管理最常见的持久化类型，包括登录项、启动代理和守护进程。Background
    Task Management还向Endpoint Security添加了两个事件：ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD和ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_REMOVE，客户端可以在登录项或启动项被持久化或移除时接收到这些事件。
- en: Recent versions of BlockBlock leverage the first of these events to deprecate
    much of its file monitoring–based approach, providing a significant boost in efficiency
    and simplifying the code base. The tool still monitors persistence mechanisms
    such as cronjobs, however, for which Background Task Management doesn’t yet generate
    Endpoint Security events, so it can’t wholly deprecate its file monitoring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock的最新版本利用这些事件中的第一个来弃用其大部分基于文件监视的方法，从而显著提高了效率并简化了代码库。该工具仍然监视诸如cron作业之类的持久化机制，但Background
    Task Management尚未为这些机制生成Endpoint Security事件，因此它无法完全弃用其文件监视功能。
- en: 'NOTE:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: '*Although Endpoint Security technically added these Background Task Management
    events in macOS 13, they didn’t work correctly. For example, Endpoint Security
    would deliver a notification not just for a newly installed item but for every
    existing item as well. Worse, for login items, it delivered no event at all! After
    I reported these flaws, Apple fixed both issues in macOS 14.*^([4](#chapter11-4))
    *When run on macOS 13 and earlier, BlockBlock falls back to the file monitoring–based
    approach.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然Endpoint Security技术上在macOS 13中添加了这些Background Task Management事件，但它们并未正确工作。例如，Endpoint
    Security不仅会为新安装的项目发送通知，还会为每个现有项目发送通知。更糟糕的是，对于登录项，它根本没有发送任何事件！在我报告了这些缺陷后，Apple在macOS
    14中修复了这两个问题。*^([4](#chapter11-4)) *在macOS 13及更早版本上运行时，BlockBlock回退到基于文件监视的方法。*'
- en: You can find the code that implements an Endpoint Security client for Background
    Task Management in the *Daemon/Monitors/BTMMonitor.m* folder and the plug-in to
    process the events in *Daemon/Plugins/Btm.m*. Let’s start by considering the Background
    Task Management monitor. As with any code that wants to leverage Endpoint Security
    events, we start by defining the events of interest, creating an Endpoint Security
    client with a handler block, and subscribing to the specified events ([Listing
    11-5](chapter11.xhtml#Lis11-5)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*Daemon/Monitors/BTMMonitor.m*文件夹中找到实现Background Task Management的Endpoint
    Security客户端的代码，在*Daemon/Plugins/Btm.m*中找到处理事件的插件。让我们先从考虑Background Task Management监视器开始。像任何想要利用Endpoint
    Security事件的代码一样，我们首先定义感兴趣的事件，创建一个带有处理块的Endpoint Security客户端，并订阅指定的事件（[列表 11-5](chapter11.xhtml#Lis11-5)）。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-5: Subscribing to ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD events'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：订阅ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD事件
- en: The code starts by creating an array with the single event to subscribe to ❶.
    Then, using the es_new_client API, it creates a new Endpoint Security client.
    Because the client is an instance variable of the BTMMonitor class, we prepend
    it with an underscore (_) to pass it to the es_new_client API ❷. We must do this
    because the compiler automatically generates an instance variable prefixed with
    an underscore whenever we declare an instance variable using the Objective-C @property
    keyword.^([5](#chapter11-5)) We normally don’t directly reference instance variables,
    but rather access them through an object; however, in the case of Endpoint Security’s
    C APIs, such as es_new_client, which expects a pointer, we must perform a direct
    reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一个包含单一事件的数组，供订阅❶。接着，使用es_new_client API，它创建了一个新的Endpoint Security客户端。因为客户端是BTMMonitor类的实例变量，我们在传递给es_new_client
    API时，使用了下划线(_)前缀❷。我们之所以这么做，是因为每当使用Objective-C的@property关键字声明实例变量时，编译器会自动生成一个以下划线开头的实例变量。^([5](#chapter11-5))通常我们不直接引用实例变量，而是通过对象访问它们；然而，在Endpoint
    Security的C API（如es_new_client）中，由于它需要一个指针，因此我们必须进行直接引用。
- en: Recall that the es_new_client API accepts a handler block to invoke each time
    a subscribed-to event occurs ❸. Shortly, you’ll see the code that BlockBlock’s
    Background Task Management monitor executes in this callback. Of course, before
    Endpoint Security can deliver events, we must tell it that we’re interested in
    subscribing, which we do via the es_subscribe API ❹.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，es_new_client API接受一个处理块，每当订阅的事件发生时就会调用❸。很快，你将看到BlockBlock的后台任务管理监控器在这个回调中执行的代码。当然，在Endpoint
    Security能够交付事件之前，我们必须告诉它我们有兴趣订阅，这可以通过es_subscribe API来实现❹。
- en: '[Listing 11-6](chapter11.xhtml#Lis11-6) shows the code in the handler block.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-6](chapter11.xhtml#Lis11-6)展示了处理块中的代码。'
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-6: The Background Task Management event monitoring logic'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-6：后台任务管理事件监控逻辑
- en: First, the code initializes a BlockBlock File object, passing in the received
    Endpoint Security message ❶. Then, for launch agents and daemons, it directly
    sets the file’s destination path to the property list of the item just created.
    We find this property list in the item_url member of the item structure in the
    btm_launch_item_add structure, within the Endpoint Security message ❷.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码初始化了一个BlockBlock文件对象，并传入接收到的Endpoint Security消息❶。然后，对于启动代理和守护进程，它直接将文件的目标路径设置为刚创建的项目的属性列表。我们在Endpoint
    Security消息中的btm_launch_item_add结构体的item_url成员中找到这个属性列表❷。
- en: 'Finally, the code calls BlockBlock’s processEvent:plugin:message: method covered
    earlier in the chapter ❹. Here, though, the plug-in passed to the method is an
    instance of BlockBlock’s Background Task Management plug-in, which I’ll discuss
    next. Notice that we pass a retained instance or copy of the Endpoint Security
    message. This is because BlockBlock needs to retain the message for later use
    (for example, to process the user’s asynchronous response). Note that the code
    will invoke the more modern es_retain_message API if running on a recent version
    of macOS, though falls back to using the es_copy_message if running on older versions
    ❸. Because it explicitly retained or copied the message, BlockBlock must free
    it when it’s no longer needed by invoking the appropriate es_release_message or
    es_free_message API.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码调用了本章之前提到的BlockBlock的processEvent:plugin:message:方法❹。不过，这里传递给该方法的插件是BlockBlock的后台任务管理插件实例，接下来我将讨论这个插件。请注意，我们传递的是Endpoint
    Security消息的保留实例或副本。这是因为BlockBlock需要保留该消息以便后续使用（例如，处理用户的异步响应）。需要注意的是，如果运行在较新的macOS版本上，代码会调用更现代的es_retain_message
    API，若运行在较旧版本上，则会回退到使用es_copy_message❸。因为消息被明确地保留或复制，所以BlockBlock在不再需要时，必须通过调用适当的es_release_message或es_free_message
    API来释放它。
- en: 'Like all other BlockBlock plug-ins, the Background Task Management plug-in
    implements methods to retrieve the name and path of the persisted item, to block
    the item if instructed by the user, and more. Of course, the logic it uses to
    do so is specific to Background Task Management persistence events. Let’s take
    a look at the plug-in’s itemObject: method, which returns the path to the persisted
    executable. As shown in [Listing 11-7](chapter11.xhtml#Lis11-7), we can extract
    this information from the delivered Endpoint Security message, although it differs
    slightly depending on whether the item persisted as a launch item or a login item.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '像所有其他 BlockBlock 插件一样，背景任务管理插件实现了方法，用于检索持久化项的名称和路径，在用户指示时阻止该项，等等。当然，它用于实现这些功能的逻辑是特定于背景任务管理持久化事件的。让我们来看一下插件的
    itemObject: 方法，它返回持久化可执行文件的路径。如 [示例 11-7](chapter11.xhtml#Lis11-7) 所示，我们可以从传递的
    Endpoint Security 消息中提取此信息，尽管它会根据该项是作为启动项还是登录项持久化有所不同。'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-7: Returning the path to the persisted item'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-7：返回持久化项的路径
- en: The code first checks the type of the persisted item ❶. Conveniently, Endpoint
    Security indicates this information with constants such as ES_BTM_ITEM_TYPE_AGENT
    and ES_BTM_ITEM_TYPE_DAEMON and specifies the item type in the item_type member
    of the item structure. Assuming the persisted item is a launch item, the code
    extracts its executable path from the executable _path member of the btm_launch_item_add
    structure. To convert it from an es_string_token_t type to an Objective-C string
    object, we invoke the BlockBlock convertStringToken helper function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查持久化项的类型 ❶。方便的是，Endpoint Security 使用常量，如 ES_BTM_ITEM_TYPE_AGENT 和 ES_BTM_ITEM_TYPE_DAEMON，来指示此信息，并在项结构的
    item_type 成员中指定项类型。假设持久化项是启动项，代码将从 btm_launch_item_add 结构的 executable_path 成员中提取其可执行路径。为了将其从
    es_string_token_t 类型转换为 Objective-C 字符串对象，我们调用 BlockBlock 的 convertStringToken
    辅助函数。
- en: For login items, we can find the path to the persisted item in the item_url
    member of the item structure ❷. Again, we invoke the convertStringToken helper
    function. However, the path to the item is really a URL object, so we must convert
    it back to a URL, then use the path property of the URL to get the filepath in
    the form of a string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于登录项，我们可以在项结构的 item_url 成员中找到持久化项的路径 ❷。同样，我们调用 convertStringToken 辅助函数。然而，项的路径实际上是一个
    URL 对象，因此我们必须将其转换回 URL，然后使用 URL 的 path 属性以字符串形式获取文件路径。
- en: The other notable method in the Background Task Management plug-in is block:,
    which BlockBlock invokes when the user clicks Block on the alert shown for a persisted
    item. Because there is logic to remove both launch and login items in the older,
    file monitor–based plug-ins, the Background Task Management plug-in can call into
    the relevant plug-ins to block the item ([Listing 11-8](chapter11.xhtml#Lis11-8)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 背景任务管理插件中的另一个显著方法是 block:，当用户点击持久化项的警报中的“阻止”时，BlockBlock 会调用该方法。因为在较旧的基于文件监控的插件中，有用于移除启动项和登录项的逻辑，所以背景任务管理插件可以调用相关插件来阻止该项（[示例
    11-8](chapter11.xhtml#Lis11-8)）。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-8: Blocking logic that calls into login and launch item plug-ins'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-8：调用登录项和启动项插件的阻止逻辑
- en: 'To determine the type of the Background Task Management item, the code once
    again makes use of the item_type member found in the Endpoint Security Background
    Task Management message. For login items (which can include persisted user applications),
    the code instantiates an instance of BlockBlock’s Login Item plug-in and then
    invokes its block: method ❶. For launch agents and daemons, it takes a similar
    approach, instantiating the launch item plug-in ❷.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确定背景任务管理项的类型，代码再次使用 Endpoint Security 背景任务管理消息中找到的 item_type 成员。对于登录项（可以包括持久化的用户应用程序），代码实例化
    BlockBlock 的登录项插件，并调用其 block: 方法 ❶。对于启动代理和守护进程，采用类似的方式，实例化启动项插件 ❷。'
- en: This wraps up the discussion of BlockBlock’s Background Task Management monitor
    and plug-in. Next, let’s look at XPC communications, which BlockBlock makes extensive
    use of.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分结束了对 BlockBlock 背景任务管理监视器和插件的讨论。接下来，让我们看看 BlockBlock 广泛使用的 XPC 通信。
- en: XPC
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XPC
- en: XPC is the de facto interprocess communication (IPC) mechanism on macOS. Anytime
    you write tools with multiple components, such as a privileged daemon or System
    Extension and an agent or app running in the user’s desktop session, the components
    will likely need to communicate via XPC. In this section, I’ll provide an overview
    of the topic, including the XPC APIs and specific examples. If you’re interested
    in learning more, you can dig deeper into BlockBlock code, which makes extensive
    use of bidirectional XPC.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: XPC 是 macOS 上事实上的进程间通信（IPC）机制。每当你编写包含多个组件的工具时，例如特权守护进程或系统扩展与在用户桌面会话中运行的代理或应用程序，这些组件通常需要通过
    XPC 进行通信。在本节中，我将概述这一主题，包括 XPC API 和具体示例。如果你有兴趣了解更多内容，可以深入研究 BlockBlock 代码，BlockBlock
    大量使用双向 XPC。
- en: To some extent, XPC conforms to a traditional client/server model. One component
    (in our case, the BlockBlock daemon) sets up an XPC server, or *listener*. An
    authorized client (for example, BlockBlock’s login item) can connect to the listener,
    then remotely invoke privileged methods implemented within the listener. Say a
    user responds to a BlockBlock alert, instructing the tool to block a persistently
    installed item, then creates a rule to automatically block related items in the
    future. Via XPC, BlockBlock’s login item can invoke the daemon’s privileged *block*
    and *create rule* methods. These methods run in the context of the privileged
    daemon to ensure that they have the appropriate permissions to remove even privileged
    persistent items. They can also create rules in a privileged context to help protect
    against malicious subversions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上来说，XPC 符合传统的客户端/服务器模型。一个组件（在我们的案例中是 BlockBlock 守护进程）设置一个 XPC 服务器，或者说是
    *监听器*。一个授权客户端（例如，BlockBlock 的登录项）可以连接到监听器，然后远程调用监听器内实现的特权方法。假设用户响应 BlockBlock
    提示，指示该工具阻止一个持久安装的项，然后创建一个规则以自动阻止未来相关的项。通过 XPC，BlockBlock 的登录项可以调用守护进程的特权 *阻止*
    和 *创建规则* 方法。这些方法在特权守护进程的上下文中运行，以确保它们具有适当的权限，能够删除即便是特权的持久项。它们还可以在特权上下文中创建规则，以帮助防止恶意篡改。
- en: Creating Listeners and Delegates
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建监听器和代理
- en: Let’s explore how the BlockBlock daemon creates the XPC listener and, more importantly,
    ensures that only authorized clients can connect to it. The latter point is essential
    for security tools, because if we leave the XPC interface unprotected, nothing
    stops malware or anything else from connecting to it and invoking the daemon’s
    privileged methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下 BlockBlock 守护进程如何创建 XPC 监听器，更重要的是，如何确保只有授权的客户端能够连接到它。后者对安全工具至关重要，因为如果我们将
    XPC 接口置于未保护状态，恶意软件或其他任何东西都可以连接到它并调用守护进程的特权方法。
- en: BlockBlock implements the XPC listener and connection logic in an interface
    named XPCListener that conforms to the NSXPCListenerDelegate protocol ([Listing
    11-9](chapter11.xhtml#Lis11-9)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock 在名为 XPCListener 的接口中实现了 XPC 监听器和连接逻辑，该接口符合 `NSXPCListenerDelegate`
    协议（[列表 11-9](chapter11.xhtml#Lis11-9)）。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-9: An XPC listener class'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-9：一个 XPC 监听器类
- en: 'To create an XPC interface, you can use the NSXPCListener initWithMachServiceName:
    initialization method, which takes the name of the XPC service as an argument.
    [Listing 11-10](chapter11.xhtml#Lis11-10) is the code from BlockBlock’s XPCListener
    class that creates its XPC listener.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 XPC 接口，你可以使用 `NSXPCListener initWithMachServiceName:` 初始化方法，该方法以 XPC 服务的名称作为参数。[列表
    11-10](chapter11.xhtml#Lis11-10) 是来自 BlockBlock 的 XPCListener 类的代码，用于创建其 XPC 监听器。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-10: Initializing an XPC listener'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-10：初始化 XPC 监听器
- en: Note that Apple built XPC atop the much older Mach message passing framework.
    This explains why you’ll run into method names such as initWithMachServiceName:.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Apple 在更古老的 Mach 消息传递框架之上构建了 XPC。这也解释了为什么你会遇到诸如 `initWithMachServiceName:`
    之类的方法名。
- en: Once you’ve created a listener, you should specify the *delegate*, which contains
    pertinent XPC delegate methods. The XPC system frameworks will automatically invoke
    these delegate methods if implemented. Once invoked, they can perform important
    tasks, such as verifying any clients.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个监听器，你应该指定 *代理*，它包含相关的 XPC 代理方法。如果实现了这些方法，XPC 系统框架会自动调用它们。一旦被调用，代理方法可以执行重要任务，例如验证任何客户端。
- en: Because BlockBlock’s XPCListener class conforms to the NSXPCListenerDelegate
    protocol, it simply sets the listener delegate to itself. Then it invokes the
    listener’s resume method to start processing client connections ([Listing 11-11](chapter11.xhtml#Lis11-11)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 BlockBlock 的 XPCListener 类符合 NSXPCListenerDelegate 协议，因此它只需将监听器的委托设置为自己。然后，它调用监听器的恢复方法以开始处理客户端连接（见[列表11-11](chapter11.xhtml#Lis11-11)）。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-11: Setting the delegate and resuming the listener'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-11：设置委托并恢复监听器
- en: Now clients such as BlockBlock’s login item can initiate a connection to the
    listener. But before we show exactly how the client can perform this action, we
    must ensure that only authorized clients can connect.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像 BlockBlock 的登录项这样的客户端可以发起连接到监听器。但在我们详细说明客户端如何执行此操作之前，我们必须确保只有授权的客户端才能连接。
- en: Extracting Audit Tokens
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取审计令牌
- en: If you allow any client to connect to your privileged XPC interface, untrusted
    code could run the listener’s privileged methods. This issue has plagued core
    macOS XPC listeners as well as many third-party tools. For a specific example,
    see my 2015 DEF CON talk, which details the exploitation of the unprotected and
    privileged macOS writeConfig XPC interface to elevate privileges to root.^([6](#chapter11-6))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您允许任何客户端连接到您的特权 XPC 接口，未经信任的代码可能会执行监听器的特权方法。这个问题困扰着核心 macOS XPC 监听器以及许多第三方工具。具体例子请参见我2015年在DEF
    CON上的演讲，其中详细介绍了利用未保护和特权的 macOS writeConfig XPC 接口来提升权限至 root 的过程。^([6](#chapter11-6))
- en: NOTE
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Versions of macOS beginning with 13 simplify the authorization process, and
    I’ll cover these steps in “Setting Client Requirements” on [page 270](chapter11.xhtml#pg_270).
    In this section, I’ll cover authorization methods that make your tools compatible
    with earlier versions of the operating system.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*从macOS 13版本开始，简化了授权流程，我将在“设置客户端要求”中介绍这些步骤，具体请参见[第270页](chapter11.xhtml#pg_270)。在这一节中，我将介绍授权方法，使您的工具与较早版本的操作系统兼容。*'
- en: 'To authorize clients, we can turn to the NSXPCListenerDelegate listener: shouldAcceptNewConnection:
    method.^([7](#chapter11-7)) If a delegate provides an implementation of this method,
    the XPC subsystem will automatically invoke it whenever a client attempts to connect.
    The method should examine the candidate client and then return a Boolean value
    indicating whether to accept the client.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '要授权客户端，我们可以使用 NSXPCListenerDelegate 协议中的 listener: shouldAcceptNewConnection:
    方法。^([7](#chapter11-7)) 如果委托实现了此方法，XPC 子系统将在每次客户端尝试连接时自动调用它。该方法应检查候选客户端，并返回一个布尔值，指示是否接受该客户端。'
- en: For authorized clients, this method should also configure the connection; I’ll
    discuss how to do this shortly. Finally, because all connections start in a suspended
    state while they’re being authorized and configured, this method should invoke
    the resume method on the passed-in NSXPCConnection object for authorized clients.
    This allows the connection to start processing any received messages, as well
    as to send its own ([Listing 11-12](chapter11.xhtml#Lis11-12)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于授权客户端，此方法还应该配置连接；稍后我将讨论如何操作。最后，由于所有连接在授权和配置过程中都会以挂起状态启动，因此此方法应调用传入的 NSXPCConnection
    对象的恢复方法，以便授权客户端开始处理任何接收到的消息，并能够发送自己的消息（见[列表11-12](chapter11.xhtml#Lis11-12)）。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-12: Resuming a connection'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-12：恢复连接
- en: While we could attempt to verify the client in several ways, many approaches
    are flawed or incomplete. For example, using the candidate client’s process ID
    is dangerous, as an attacker can exploit the fact that the system reuses process
    IDs to coerce the listener into allowing an unauthorized client.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过多种方式尝试验证客户端，但许多方法存在缺陷或不完整。例如，使用候选客户端的进程ID是危险的，因为攻击者可以利用系统重用进程ID的事实，迫使监听器允许未经授权的客户端。
- en: 'A better method is to check the client’s audit token and retrieve its code
    signing information. Unfortunately, in older versions of macOS, Apple doesn’t
    readily expose the client’s audit token, which means we have to resort to some
    Objective-C trickery. The listener:shouldAcceptNewConnection: method’s second
    argument is a pointer to an NSXPCConnection object, which contains information
    about the client attempting to connect to the XPC service. While it does contain
    the audit token in its auditToken property, this property is private, meaning
    we can’t directly access it. Luckily, Objective-C is introspective, so we can
    access private properties via a class extension. In [Listing 11-13](chapter11.xhtml#Lis11-13),
    BlockBlock creates an extension to the NSXPCConnection class.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-13: Extending the NSXPCConnection class to access its private audit
    token'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the extension defines a single property: the private audit token
    found within the NSXPCConnection class. Once we’ve declared this extension, we
    can access the private audit token of the connecting client, as shown in [Listing
    11-14](chapter11.xhtml#Lis11-14).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 11-14: Accessing the connecting client’s audit token'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This code typecasts the NSXPCConnection object, representing the connecting
    client, as an ExtendedNSXPCConnection object. Then it can readily extract the
    client’s audit token member. With an audit token in hand, the code can verify
    code signing information about the client, then securely verify the identity of
    the client and approve the connection if the client is authorized.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Code Signing Details
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To verify the client’s code signing information, BlockBlock’s implementation
    of the listener:shouldAcceptNewConnection: delegate method takes the following
    steps. First, it uses the extracted audit token to obtain a dynamic code signing
    reference for the client process. It uses this reference to validate that the
    client’s code signing information is valid, then extracts the information. Additionally,
    it extracts the client code signing flags to ensure that the client was compiled
    with the hardened runtime, guarding against runtime injection attacks. Finally,
    it checks that the validated code signing information contains the bundle ID of
    the BlockBlock helper application, the Objective-See developer code signing certificate,
    and supported client versions. [Listing 11-15](chapter11.xhtml#Lis11-15) shows
    the implementation of this requirement.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-15: A code signing requirement to validate connecting XPC clients'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) covered code signing requirements, but let’s break
    this one down. First, we require that the client be signed using a certificate
    issued by Apple to developers ❶. Next, we require the client identifier to match
    that of Objective-See’s BlockBlock helper ❷. We also require that the client be
    signed with Objective-See’s code signing certificate ❸. Finally, we require client
    versions of 2.0.0 or newer ❹, as older versions of BlockBlock’s helper don’t support
    the more recent hardened runtime, leaving them vulnerable to subversion.^([8](#chapter11-8))'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](chapter3.xhtml)讨论了代码签名要求，但让我们细分一下这个要求。首先，我们要求客户端使用苹果发给开发者的证书进行签名 ❶。接下来，我们要求客户端标识符与
    Objective-See 的 BlockBlock 助手标识符相匹配 ❷。我们还要求客户端使用 Objective-See 的代码签名证书进行签名 ❸。最后，我们要求客户端版本为
    2.0.0 或更新版本 ❹，因为旧版本的 BlockBlock 助手不支持更新的加固运行时，容易受到颠覆攻击。^([8](#chapter11-8))'
- en: If all these validation and verification steps succeed, the BlockBlock daemon
    knows that the client attempting to connect to its XPC interface is indeed a recent
    version of the BlockBlock helper component and that an attacker or malware hasn’t
    surreptitiously tampered with this component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些验证和验证步骤都成功，BlockBlock 守护进程就知道，尝试连接其 XPC 接口的客户端确实是 BlockBlock 助手组件的最新版本，并且没有攻击者或恶意软件偷偷篡改这个组件。
- en: '[Listing 11-16](chapter11.xhtml#Lis11-16) shows the code that implements the
    full client authorization. Note the use of various SecTask* code signing APIs,
    covered in [Chapter 3](chapter3.xhtml). As it’s imperative to always check the
    return value of these APIs, this code contains basic error handling.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-16](chapter11.xhtml#Lis11-16) 显示了实现完整客户端授权的代码。请注意使用了各种 SecTask* 代码签名
    API，这些内容在 [第 3 章](chapter3.xhtml) 中有介绍。由于必须始终检查这些 API 的返回值，因此这段代码包含了基本的错误处理。'
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-16: Authorizing XPC clients'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-16：授权 XPC 客户端
- en: You may be surprised by how hard it is to protect privileged XPC interfaces.
    Apple eventually realized this too, and luckily, in macOS 13, it provided two
    new APIs specifically designed to simplify the process of ensuring that only authorized
    clients could connect. If your tools will run only on versions of macOS 13 or
    newer, you should make use of these APIs so you don’t have to worry about accessing
    private audit tokens or manually extracting and verifying code signing information.
    The next section will detail these APIs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶于保护特权 XPC 接口是多么困难。苹果最终也意识到了这一点，幸运的是，在 macOS 13 中，它提供了两个专门设计的新的 API，用以简化确保只有授权客户端能够连接的过程。如果你的工具只在
    macOS 13 或更高版本上运行，你应该使用这些 API，这样你就不必担心访问私有审计令牌或手动提取和验证代码签名信息。下一节将详细介绍这些 API。
- en: Setting Client Requirements
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置客户端要求
- en: 'On macOS 13 and newer, the NSXPCListener class’s setConnectionCodeSigningRequirement:
    method^([9](#chapter11-9)) and the NSXPCConnection class’s setCodeSigningRequirement:
    method^([10](#chapter11-10)) allow you to set code signing requirements on either
    the listener or the connection object. The first option applies to all connections,
    while the second applies to only specific ones, but you can use either to keep
    unauthorized clients from connecting to an XPC interface.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '在 macOS 13 及更高版本中，NSXPCListener 类的 setConnectionCodeSigningRequirement: 方法^([9](#chapter11-9))
    和 NSXPCConnection 类的 setCodeSigningRequirement: 方法^([10](#chapter11-10)) 允许你在监听器或连接对象上设置代码签名要求。第一个选项适用于所有连接，而第二个选项仅适用于特定连接，但你可以使用任一选项防止未经授权的客户端连接到
    XPC 接口。'
- en: BlockBlock uses the listener method, which requires less granularity; it denies
    any and all connections that don’t belong to the BlockBlock helper client. Recall
    that [Listing 11-10](chapter11.xhtml#Lis11-10) showed the code for initializing
    an XPC listener. [Listing 11-17](chapter11.xhtml#Lis11-17) builds on this foundation
    by adding code to run on macOS versions 13 and newer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock 使用监听器方法，这种方法要求较低的粒度；它拒绝任何不属于 BlockBlock 助手客户端的连接。回想一下，[示例 11-10](chapter11.xhtml#Lis11-10)
    显示了初始化 XPC 监听器的代码。[示例 11-17](chapter11.xhtml#Lis11-17) 基于此基础，添加了在 macOS 13 及更高版本上运行的代码。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-17: Authorizing clients on macOS versions 13 and newer'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-17：在 macOS 13 及更高版本上授权客户端
- en: 'After allocating and initializing an NSXPCListener object, we use the Objective-C
    @available attribute with a value of macOS 13.0, * to instruct the compiler to
    execute the following lines on macOS 13 or newer only ❶, as the setConnectionCodeSigningRequirement:
    method isn’t available on earlier versions of macOS.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '在分配并初始化一个 NSXPCListener 对象后，我们使用 Objective-C 的 @available 属性，值为 macOS 13.0，*来指示编译器仅在
    macOS 13 或更新版本上执行以下代码❶，因为 setConnectionCodeSigningRequirement: 方法在较早版本的 macOS
    中不可用。'
- en: 'We then dynamically initialize a code signing requirement string ❷ with which
    to validate any clients attempting to connect to the listener. The requirement
    is identical to the one shown previously. Finally, BlockBlock invokes the setConnectionCodeSigningRequirement:
    method to instruct the XPC runtime to only accept connections from clients that
    conform to the specified code signing requirement string. Now we no longer have
    to manually verify clients; macOS will take care of it for us!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们动态初始化一个代码签名要求字符串❷，用于验证任何尝试连接到监听器的客户端。这个要求与之前展示的相同。最后，BlockBlock 调用 setConnectionCodeSigningRequirement:
    方法，指示 XPC 运行时只接受符合指定代码签名要求字符串的客户端连接。现在，我们不再需要手动验证客户端；macOS 会为我们处理这一切！'
- en: 'To confirm that the authorization works, compile and execute BlockBlock on
    macOS version 13 or newer, then attempt to connect to its XPC interface with an
    illegitimate client. The connection should fail, and the system’s XPC library
    should print the following message to the unified log:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认授权是否有效，请在 macOS 版本 13 或更新版本上编译并执行 BlockBlock，然后尝试通过不合法的客户端连接到其 XPC 接口。连接应该会失败，系统的
    XPC 库应该会将以下消息打印到统一日志中：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that BlockBlock can authorize XPC clients, it can configure and then activate
    the connection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 BlockBlock 可以授权 XPC 客户端，它可以配置并激活连接。
- en: Enabling Remote Connections
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用远程连接
- en: XPC communications usually occur in only one direction; a client connects to
    a listener and invokes its methods. BlockBlock, however, implements bidirectional
    communications. The daemon implements most of the XPC methods for tasks like blocking
    or removing persistent items and creating rules, and the client invokes these.
    However, the daemon also calls methods implemented in the client to, for example,
    display alerts to the user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: XPC 通信通常是单向的；客户端连接到监听器并调用其方法。然而，BlockBlock 实现了双向通信。守护进程实现了大多数 XPC 方法，用于诸如阻止或删除持久项和创建规则等任务，客户端调用这些方法。然而，守护进程也会调用客户端实现的方法，例如显示用户警告。
- en: To facilitate this bidirectional IPC, we must configure the NSXPCConnection
    object. First, let’s configure the listener object on the server side. This involves
    defining the remote methods that the client can invoke and specifying an object
    on the server side of the XPC interface that implements these methods. Both the
    server and the client must agree on what methods the client can remotely call.
    We can achieve this by setting the listener’s exportedInterface property to an
    NSXPCInterface object that describes the protocol for the exported object.^([11](#chapter11-11))
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种双向 IPC，我们必须配置 NSXPCConnection 对象。首先，让我们在服务器端配置监听器对象。这涉及到定义客户端可以调用的远程方法，并指定
    XPC 接口的服务器端对象来实现这些方法。服务器和客户端必须就客户端可以远程调用哪些方法达成一致。我们可以通过将监听器的 exportedInterface
    属性设置为一个描述导出对象协议的 NSXPCInterface 对象来实现这一点。^([11](#chapter11-11))
- en: In this context, a *protocol* is simply a list of methods that conformant objects
    will implement.^([12](#chapter11-12)) We normally declare these protocols in header
    (*.h*) files, making them easy to include in both server and client code. [Listing
    11-18](chapter11.xhtml#Lis11-18) is the BlockBlock daemon’s XPC protocol.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*协议*只是符合要求的对象将实现的方法列表。^([12](#chapter11-12)) 我们通常在头文件（*.h*）中声明这些协议，方便在服务器端和客户端代码中引用。[Listing
    11-18](chapter11.xhtml#Lis11-18) 是 BlockBlock 守护进程的 XPC 协议。
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 11-18: The XPC daemon protocol'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-18: XPC 守护进程协议'
- en: 'Once we’ve declared this protocol, the daemon can set the exportedInterface
    property to an NSXPCInterface object conformant to the XPCDaemonProtocol protocol.
    You can find the code to enable client connections in the listener:shouldAcceptNewConnection:
    delegate method ([Listing 11-19](chapter11.xhtml#Lis11-19)).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们声明了这个协议，守护进程可以将 exportedInterface 属性设置为符合 XPCDaemonProtocol 协议的 NSXPCInterface
    对象。你可以在监听器的 delegate 方法 listener:shouldAcceptNewConnection: 中找到启用客户端连接的代码（[Listing
    11-19](chapter11.xhtml#Lis11-19)）。'
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-19: Setting the exported interface for the NSXPCConnection'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-19: 设置 NSXPCConnection 的导出接口'
- en: Of course, you must also specify the object on the server side that implements
    these methods (in this case, the BlockBlock daemon). You can do this by setting
    the exportedObject property on the listener ([Listing 11-20](chapter11.xhtml#Lis11-20)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还必须在服务器端指定实现这些方法的对象（在这种情况下是 BlockBlock 守护进程）。你可以通过设置监听器上的 exportedObject
    属性来完成这一点（[列表 11-20](chapter11.xhtml#Lis11-20)）。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-20: Setting the object that implements the exported interface'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-20：设置实现导出接口的对象
- en: BlockBlock creates a class named XPCDaemon to implement client-callable methods.
    As expected, this class conforms to the daemon protocol, XPCDaemonProtocol ([Listing
    11-21](chapter11.xhtml#Lis11-21)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock 创建了一个名为 XPCDaemon 的类，用于实现客户端可调用的方法。正如预期的那样，这个类遵循守护进程协议 XPCDaemonProtocol（[列表
    11-21](chapter11.xhtml#Lis11-21)）。
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-21: An interface conformant to XPCDaemonProtocol'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-21：符合 XPCDaemonProtocol 的接口
- en: Next, we’ll briefly look at a few of the privileged XPC methods that the BlockBlock
    helper component running in the limited-privilege user session can invoke.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要了解一些特权 XPC 方法，这些方法可以由在受限权限用户会话中运行的 BlockBlock 辅助组件调用。
- en: Exposing Methods
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 暴露方法
- en: 'BlockBlock lets users define rules to automatically allow common persistence
    events. The privileged BlockBlock daemon manages these rules to keep unprivileged
    malware from tampering with them (for example, by adding an allow rule that permits
    the malware to persist). To display the rules to the user, the BlockBlock client
    will invoke the daemon’s getRules: method via XPC ([Listing 11-22](chapter11.xhtml#Lis11-22)).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'BlockBlock 允许用户定义规则以自动允许常见的持久性事件。特权 BlockBlock 守护进程管理这些规则，以防止无特权的恶意软件篡改它们（例如，添加允许规则让恶意软件得以持久化）。为了向用户显示这些规则，BlockBlock
    客户端将通过 XPC 调用守护进程的 getRules: 方法（[列表 11-22](chapter11.xhtml#Lis11-22)）。'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 11-22: Returning serialized rules'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-22：返回序列化规则
- en: 'Because XPC is asynchronous, methods that return data should do so in a block.
    The getRules: method declared in XPCDaemonProtocol takes such a block, which the
    caller can invoke with a data object containing the list of rules. Notice that
    the method’s implementation is rather basic; it simply serializes the rules and
    sends them back to the client.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '因为 XPC 是异步的，返回数据的方法应该通过块来返回。XPCDaemonProtocol 中声明的 getRules: 方法采用这样的块，调用者可以通过该块调用一个包含规则列表的数据对象。请注意，该方法的实现相当简单；它只是将规则序列化并将其发送回客户端。'
- en: A more involved example of an XPC method is alertReply:, which the client invokes
    via XPC once a user has interacted with a persistence alert (for example, by clicking
    Block). The method takes a dictionary that encapsulates the alert. The user doesn’t
    expect any response, so the method doesn’t use any callback block. [Listing 11-23](chapter11.xhtml#Lis11-23)
    shows the method’s main code implemented within the daemon.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的 XPC 方法示例是 alertReply:，客户端通过 XPC 在用户与持久化警报交互后（例如点击“阻止”）调用该方法。该方法接收一个封装警报的字典。用户不期望任何响应，因此该方法不使用任何回调块。[列表
    11-23](chapter11.xhtml#Lis11-23) 显示了在守护进程中实现的该方法的主要代码。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 11-23: Handling the user’s response to an alert'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-23：处理用户对警报的响应
- en: 'First, we retrieve an object representing the persistent event from the alert
    dictionary using a UUID ❶. We wrap the object in a @synchronized block to ensure
    thread synchronization. Next, we extract the user-specified action (either block
    or allow) from the alert ❷. If the user has decided to block the persistent event,
    BlockBlock will call in the relevant plug-in’s block: method. This will execute
    the plug-in–specific code to remove the persistent item ❸ and add a rule for the
    event, so long as the user didn’t click the “temporary” checkbox on the alert
    ❹.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们使用 UUID ❶ 从警报字典中检索表示持久事件的对象。我们将该对象包装在@synchronized代码块中，以确保线程同步。接下来，我们从警报
    ❷ 中提取用户指定的操作（阻止或允许）。如果用户决定阻止持久事件，BlockBlock 将调用相关插件的 block: 方法。这将执行插件特定的代码以删除持久项
    ❸ 并为事件添加规则，前提是用户没有勾选警报中的“临时”复选框 ❹。'
- en: I mentioned that the BlockBlock daemon also needs to call methods implemented
    in the helper, for example, to display an alert to the user. It can do so over
    the same XPC interface once the helper has connected, although we need to specify
    a dedicated protocol. BlockBlock names this client protocol XPCUserProtocol ([Listing
    11-24](chapter11.xhtml#Lis11-24)). It contains methods the client will implement
    and that the daemon can remotely invoke over XPC.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11-24: The XPC user protocol'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the listener:shouldAcceptNewConnection: method, we configure the listener
    to allow the daemon to invoke the client’s remote methods ([Listing 11-25](chapter11.xhtml#Lis11-25)).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 11-25: Setting the remote object interface'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We set the remoteObjectInterface property and specify the XPCUserProtocol protocol.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Initiating Connections
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, I’ve shown how the BlockBlock daemon sets up an XPC listener, exposes
    methods, and ensures that only authorized clients can connect. However, I haven’t
    yet shown how the client initiates a connection or how it and the daemon remotely
    invoke the XPC methods.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the BlockBlock daemon is running, its XPC interface becomes available
    for authorized connections. To connect to the daemon, the BlockBlock helper uses
    the NSXPCConnection object’s initWithMachServiceName:options: method, specifying
    the same name used by the daemon ([Listing 11-26](chapter11.xhtml#Lis11-26)).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 11-26: Initializing a connection to the daemon XPC service'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As we did on the server side, we must set the protocol for the remote object
    interface. Because we’re now on the client side, the “remote object interface”
    in this case refers to the XPC object on the daemon that exposes remotely invocable
    methods ([Listing 11-27](chapter11.xhtml#Lis11-27)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 11-27: Setting up the XPC connection object on the client side'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Recall that this object conforms to XPCDaemonProtocol, so we specify it here
    ❶. Also, because the daemon needs to call methods implemented in the client, the
    client needs to set up its own exported object. It does this via the exportedInterface
    and exportedObject methods ❷. The former specifies the protocol (XPCUserProtocol),
    while the latter specifies the object (XPCUser) in the client that implements
    the exported XPC methods. Finally, we resume the connection ❸, which triggers
    the actual connection to the daemon’s XPC listener.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Remote Methods
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, we’ve finished implementing the XPC connection. I’ll end this
    discussion of BlockBlock’s XPC utilization by showing how it actually invokes
    remote methods, focusing on the more common case of the client side. To abstract
    its communications with the daemon, the BlockBlock client uses a custom class
    named XPCDaemonClient. The code in [Listing 11-26](chapter11.xhtml#Lis11-26) that
    establishes an XPC connection lives in this class, as does the code that invokes
    the remote XPC methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the daemon and invoke one of its remote privileged XPC methods
    (for example, to get the current rules), the client can execute the code in [Listing
    11-28](chapter11.xhtml#Lis11-28).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 若要连接到守护进程并调用其远程特权 XPC 方法（例如，获取当前规则），客户端可以执行 [清单 11-28](chapter11.xhtml#Lis11-28)
    中的代码。
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 11-28: Invoking remote XPC methods'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-28：调用远程 XPC 方法
- en: 'Let’s take a closer look at the getRules method, which invokes the daemon’s
    remotely exposed corresponding getRules: method. This method provides a good example
    of how you can invoke XPC methods, taking into account their nuances. Note that
    though the method contains additional logic to deserialize the rules it receives
    from the daemon, here we’re only focusing on the XPC logic ([Listing 11-29](chapter11.xhtml#Lis11-29)).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们仔细看一下 getRules 方法，它调用守护进程远程暴露的相应 getRules: 方法。这个方法很好地展示了如何调用 XPC 方法，并考虑到它们的细微差别。请注意，尽管该方法包含额外的逻辑来反序列化从守护进程接收到的规则，这里我们只关注
    XPC 逻辑（[清单 11-29](chapter11.xhtml#Lis11-29)）。'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 11-29: Getting rules from the daemon'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-29：从守护进程获取规则
- en: 'First, the code invokes the NSXPCConnection class’s synchronous connection
    method ❶. While XPC is generally asynchronous, we’re expecting the daemon to return
    data, so using a synchronous call makes the most sense in this situation. In other
    places, BlockBlock uses the more common asynchronous remoteObjectProxyWithErrorHandler:
    method.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，代码调用 NSXPCConnection 类的同步连接方法 ❶。虽然 XPC 通常是异步的，但我们期望守护进程返回数据，因此在这种情况下使用同步调用最为合适。在其他地方，BlockBlock
    使用更常见的异步 remoteObjectProxyWithErrorHandler: 方法。'
- en: The XPCDaemonClient class’s init method previously established the connection
    and saved it in the instance variable named daemon. The connection method returns
    the remote object, which exposes remotely invocable XPC methods. If any errors
    occur while retrieving this object, the code invokes an error block ❷.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: XPCDaemonClient 类的 init 方法先前建立了连接，并将其保存在名为 daemon 的实例变量中。连接方法返回远程对象，该对象暴露了可以远程调用的
    XPC 方法。如果在检索此对象时发生任何错误，代码将调用错误块 ❷。
- en: 'With a remote object in hand, we can then invoke its methods, such as its getRules:
    method. To return data, this XPC call takes a reply block; [Listing 11-22](chapter11.xhtml#Lis11-22)
    showed the implementation of this method, found within the daemon. When the call
    completes, the block executes, taking as a parameter a data object containing
    the serialized rules from the daemon ❸.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '拿到远程对象后，我们就可以调用它的方法，比如 getRules: 方法。为了返回数据，这个 XPC 调用需要一个回复块；[清单 11-22](chapter11.xhtml#Lis11-22)
    展示了这个方法的实现，它位于守护进程内。当调用完成时，块会执行，并将一个包含来自守护进程的序列化规则的数据对象作为参数 ❸。'
- en: Conclusion
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'BlockBlock’s approach is simple: detect persistent items, alert the user, and
    allow them to remove unwanted items. While straightforward, this design has proved
    incredibly effective against even the most sophisticated of persistent Mac malware.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: BlockBlock 的方法很简单：检测持久化项目，提醒用户，并允许他们删除不需要的项目。尽管这种设计非常直接，但它已被证明在对抗即使是最复杂的持久化
    Mac 恶意软件时也非常有效。
- en: In this chapter, you saw how to request an Endpoint Security entitlement from
    Apple. You also looked at BlockBlock’s design, its use of Endpoint Security events,
    and its bidirectional XPC communications. If you’re building your own security
    tools, I encourage you to draw from the system frameworks, APIs, and mechanisms
    that BlockBlock employs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了如何向 Apple 请求 Endpoint Security 权限。您还了解了 BlockBlock 的设计、它对 Endpoint
    Security 事件的使用，以及它的双向 XPC 通信。如果您正在构建自己的安全工具，我鼓励您参考 BlockBlock 使用的系统框架、API 和机制。
- en: 'The next chapter explores a tool designed to heuristically detect some of the
    most insidious malware specimens: those that surreptitiously spy on victims through
    their mics and webcams.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨一个旨在启发式检测一些最隐秘的恶意软件样本的工具：那些通过受害者的麦克风和摄像头偷偷监视他们的恶意软件。
- en: Notes
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[  1](#chapter11_1).  “Writing Bad @$$ Lamware for OS X,” *reverse.put.as*,
    August 7, 2015, [*https://<wbr>reverse<wbr>.put<wbr>.as<wbr>/2015<wbr>/08<wbr>/07<wbr>/writing<wbr>-bad<wbr>-lamware<wbr>-for<wbr>-os<wbr>-x<wbr>/*](https://reverse.put.as/2015/08/07/writing-bad-lamware-for-os-x/).'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter11_1).  “为 OS X 编写 Bad @$$ Lamware,” *reverse.put.as*, 2015年8月7日，[*https://<wbr>reverse<wbr>.put<wbr>.as<wbr>/2015<wbr>/08<wbr>/07<wbr>/writing<wbr>-bad<wbr>-lamware<wbr>-for<wbr>-os<wbr>-x<wbr>/*](https://reverse.put.as/2015/08/07/writing-bad-lamware-for-os-x/).'
- en: '[  2](#chapter11_2).  “TN3125: Inside Code Signing: Provisioning Profiles,”
    Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/technotes<wbr>/tn3125<wbr>-inside<wbr>-code<wbr>-signing<wbr>-provisioning<wbr>-profiles*](https://developer.apple.com/documentation/technotes/tn3125-inside-code-signing-provisioning-profiles).'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter11_2).  “TN3125：代码签名内幕：配置文件”，苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/technotes<wbr>/tn3125<wbr>-inside<wbr>-code<wbr>-signing<wbr>-provisioning<wbr>-profiles*](https://developer.apple.com/documentation/technotes/tn3125-inside-code-signing-provisioning-profiles)。'
- en: '[  3](#chapter11_3).  “Signing a Daemon with a Restricted Entitlement,” Apple
    Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/signing<wbr>-a<wbr>-daemon<wbr>-with<wbr>-a<wbr>-restricted<wbr>-entitlement*](https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter11_3).  “使用受限权限签名守护进程”，苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/signing<wbr>-a<wbr>-daemon<wbr>-with<wbr>-a<wbr>-restricted<wbr>-entitlement*](https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement)。'
- en: '[  4](#chapter11_4).  asfdadsfasdfasdfsasdafads, “Endpoint Security Event:
    ES_EVENT _TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD is . . . broken?,” Apple Developer Forums,
    November 15, 2024, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/forums<wbr>/thread<wbr>/720468*](https://developer.apple.com/forums/thread/720468).'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter11_4).  asfdadsfasdfasdfsasdafads，“端点安全事件：ES_EVENT _TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD
    是 . . . 损坏了吗？”，苹果开发者论坛，2024年11月15日，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/forums<wbr>/thread<wbr>/720468*](https://developer.apple.com/forums/thread/720468)。'
- en: '[  5](#chapter11_5).  Keith Harrison, “Automatic Property Synthesis with Xcode
    4.4,” *Use Your Loaf*, August 1, 2012, [*https://<wbr>useyourloaf<wbr>.com<wbr>/blog<wbr>/property<wbr>-synthesis<wbr>-with<wbr>-xcode<wbr>-4<wbr>-dot<wbr>-4<wbr>/*](https://useyourloaf.com/blog/property-synthesis-with-xcode-4-dot-4/).'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter11_5).  Keith Harrison，“使用 Xcode 4.4 进行自动属性合成”，*Use Your Loaf*，2012年8月1日，[*https://<wbr>useyourloaf<wbr>.com<wbr>/blog<wbr>/property<wbr>-synthesis<wbr>-with<wbr>-xcode<wbr>-4<wbr>-dot<wbr>-4<wbr>/*](https://useyourloaf.com/blog/property-synthesis-with-xcode-4-dot-4/)。'
- en: '[  6](#chapter11_6).  Patrick Wardle, “Stick That in Your (Root) Pipe and Smoke
    It,” Speaker Deck, August 9, 2015, [*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/stick<wbr>-that<wbr>-in<wbr>-your<wbr>-root<wbr>-pipe<wbr>-and<wbr>-smoke<wbr>-it*](https://speakerdeck.com/patrickwardle/stick-that-in-your-root-pipe-and-smoke-it).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter11_6).  Patrick Wardle，“把这个塞进你的（根）管道里吸”，Speaker Deck，2015年8月9日，[*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/stick<wbr>-that<wbr>-in<wbr>-your<wbr>-root<wbr>-pipe<wbr>-and<wbr>-smoke<wbr>-it*](https://speakerdeck.com/patrickwardle/stick-that-in-your-root-pipe-and-smoke-it)。'
- en: '[  7](#chapter11_7).  “listener:shouldAcceptNewConnection:,” Apple Developer
    Documentation, accessed May 25, 2024, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpclistenerdelegate<wbr>/1410381<wbr>-listener<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/foundation/nsxpclistenerdelegate/1410381-listener?language=objc).'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter11_7).  “listener:shouldAcceptNewConnection:”，苹果开发者文档，访问日期：2024年5月25日，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpclistenerdelegate<wbr>/1410381<wbr>-listener<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/foundation/nsxpclistenerdelegate/1410381-listener?language=objc)。'
- en: '[  8](#chapter11_8).  You can read about such subversive attacks in “The Story
    Behind CVE-2019-13013,” *Objective Development*, August 26, 2019, [*https://<wbr>blog<wbr>.obdev<wbr>.at<wbr>/what<wbr>-we<wbr>-have<wbr>-learned<wbr>-from<wbr>-a<wbr>-vulnerability*](https://blog.obdev.at/what-we-have-learned-from-a-vulnerability),
    which details the exploitation of a popular commercial macOS firewall product.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter11_8).  你可以在《CVE-2019-13013背后的故事》中阅读有关此类颠覆性攻击的内容，*Objective Development*，2019年8月26日，[*https://<wbr>blog<wbr>.obdev<wbr>.at<wbr>/what<wbr>-we<wbr>-have<wbr>-learned<wbr>-from<wbr>-a<wbr>-vulnerability*](https://blog.obdev.at/what-we-have-learned-from-a-vulnerability)，其中详细描述了对一款流行的商业
    macOS 防火墙产品的利用。'
- en: '[  9](#chapter11_9).  “setConnectionCodeSigningRequirement:,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpclistener<wbr>/3943310<wbr>-setconnectioncodesigningrequirem<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/foundation/nsxpclistener/3943310-setconnectioncodesigningrequirem?language=objc).'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter11_9).  “setConnectionCodeSigningRequirement:”，苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpclistener<wbr>/3943310<wbr>-setconnectioncodesigningrequirem<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/foundation/nsxpclistener/3943310-setconnectioncodesigningrequirem?language=objc)。'
- en: '[10](#chapter11_10).  “setCodeSigningRequirement:,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpcconnection<wbr>/3943309<wbr>-setcodesigningrequirement<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/foundation/nsxpcconnection/3943309-setcodesigningrequirement?language=objc).'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter11_11).  “exportedInterface,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/nsxpcconnection<wbr>/1408106<wbr>-exportedinterface*](https://developer.apple.com/documentation/foundation/nsxpcconnection/1408106-exportedinterface).'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#chapter11_12).  “Working with Protocols,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/ProgrammingWithObjectiveC<wbr>/WorkingwithProtocols<wbr>/WorkingwithProtocols<wbr>.html*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html).'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
