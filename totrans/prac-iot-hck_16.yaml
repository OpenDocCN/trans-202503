- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Medium Range Radio: Hacking Wi-Fi'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Medium-range radio technologies can connect devices across a range of up to
    100 meters (approximately 328 feet). In this chapter, we focus on Wi-Fi, the most
    popular technology in IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: We explain how Wi-Fi works and then describe some of the most important attacks
    against it. Using a variety of tools, we perform disassociation and association
    attacks. We also abuse Wi-Fi Direct and walk through some popular ways of breaking
    WPA2 encryption.
  prefs: []
  type: TYPE_NORMAL
- en: How Wi-Fi Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other medium-range radio technologies, such as Thread, Zigbee, and Z-Wave, were
    designed for low-rate applications with a maximum of 250Kbps, but Wi-Fi was created
    for high-rate data transfers. Wi-Fi also has a higher power consumption than the
    other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi connections involve an *access point (AP)*, the networking device that
    allows Wi-Fi devices to connect to a network, and a client that can connect to
    the AP. When a client successfully connects to an AP and data moves freely between
    them, we say the client is *associated* with the AP. We often use the term *station*
    (*STA*) to refer to any device that is capable of using the Wi-Fi protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A Wi-Fi network can operate in either open or secure mode. In *open mode*, the
    AP won’t require authentication and will accept any client that attempts to connect.
    In *secure mode*, some form of authentication needs to take place before a client
    is connected to the AP. Some networks might also choose to be *hidden*; in that
    case, the network won’t broadcast its ESSID. An *ESSID* is the name of the network,
    such as “Guest” or “Free-WiFi.” A *BSSID* is the network’s MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi connections share data using *802.11*, a set of protocols that implement
    Wi-Fi communications. More than 15 different protocols are in the 802.11 spectrum,
    and they’re labeled with letters. You might already be familiar with 802.11 a/b/g/n/ac,
    because you might have used any or all of them in the last 20 years. The protocols
    support different modulations and work on different frequencies and physical layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 802.11, data is transferred via three major types of frames: data, control,
    and management. For the purpose of this chapter, we’ll work only with management
    frames. A *management frame* manages the network; for example, it’s used while
    searching for a network, authenticating clients, and even associating clients
    with APs.'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware for Wi-Fi Security Assessments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, a Wi-Fi security assessment includes attacks against APs and wireless
    stations. When it comes to testing IoT networks, both kinds of attacks are critical,
    because more and more devices are either capable of connecting to a Wi-Fi network
    or serving as APs.
  prefs: []
  type: TYPE_NORMAL
- en: When targeting IoT devices in a wireless assessment, you’ll need a wireless
    card that supports AP monitor mode and is capable of packet injection. *Monitor
    mode* lets your device monitor all traffic it receives from the wireless network.
    *Packet injection capabilities* allow your card to spoof packets to appear as
    if they originate from a different source. For the purpose of this chapter, we
    used an Alfa Atheros AWUS036NHA network card.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you might need a configurable AP to test the various Wi-Fi settings.
    We used a portable TP-Link AP, but literally any AP would do. Unless the attacks
    are part of a red teaming engagement, the AP’s transmission power or the type
    of antenna you use aren’t important.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Attacks Against Wireless Clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attacks against wireless clients usually exploit the fact that 802.11 management
    frames aren’t cryptographically protected, leaving the packets exposed to eavesdropping,
    modification, or replay. You could accomplish all of these attacks through association
    attacks, which let the attacker become a man in the middle. Attackers can also
    perform deauthentication and denial-of-service attacks, which disrupt the victim’s
    Wi-Fi connectivity to their AP.
  prefs: []
  type: TYPE_NORMAL
- en: Deauthentication and Denial-of-Service Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Management frames in 802.11 can’t stop an attacker from spoofing a device’s
    MAC address. As a result, an attacker can forge spoofed *Deauthenticate* or *Disassociate
    frames*. These are management frames normally sent to terminate a client’s connection
    to the AP. For example, they’re sent if the client connects to another AP or simply
    disconnects from the original network. If forged, an attacker can use these frames
    to disrupt existing associations to specific clients.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, instead of making the client disassociate from the AP, the attacker
    could flood the AP with authentication requests. These, in turn, cause a denial-of-service
    attack by keeping legitimate clients from connecting to the AP.
  prefs: []
  type: TYPE_NORMAL
- en: Both attacks are known denial-of-service attacks mitigated in *802.11w*, a standard
    that hasn’t yet propagated in the IoT world. In this section, we’ll perform a
    deauthentication attack that disconnects all wireless clients from an AP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the Aircrack-ng suite if you’re not using Kali, where it’s
    preinstalled. *Aircrack-ng* contains Wi-Fi assessment tools. Ensure your network
    card with packet injection capabilities is plugged in. Then use the `iwconfig`
    utility to identify the interface name belonging to the wireless card connected
    to your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that the wireless interface is `wlan0` 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because some processes in the system can interfere with the tools in the Aircrack-ng
    suite, use the Airmon-ng tool to check and automatically kill these processes.
    To do this, first disable the wireless interface using `ifconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now set the wireless card to monitor mode using Airmon-ng:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This tool creates a new interface, named `wlan0mon`, which you can use to run
    a basic sniffing session with Airodump-ng. The following command identifies the
    AP’s BSSID (its MAC address) and the channel on which it’s transmitting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, the BSSID is `82:16:F9:6E:FB:56` and the channel is `6`. We pass
    this data to Airodump-ng to identify clients connected to the AP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Based on this output, we identify one client connected to the AP. The client
    has the BSSID 50:82:D5:DE:6F:45 (the MAC address of their wireless network interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'You could now send a number of disassociation packets to the client to force
    the client to lose internet connectivity. To perform the attack, we use Aireplay-ng:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--deauth` parameter specifies the disassociation attack and the number
    of disassociation packets that will be sent. Selecting `0` means the packets will
    be sent continuously. The `-a` parameter specifies the AP’s BSSID, and the `-c`
    parameter specifies the targeted devices. The next listing shows the command’s
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the disassociation packets sent to the target. The attack succeeds
    when the target device becomes unavailable. When you check that device, you should
    see that it’s no longer connected to any network.
  prefs: []
  type: TYPE_NORMAL
- en: You can perform denial-of-service attacks against Wi-Fi in other ways, too.
    *Radio jamming,* another common method, interferes with wireless communications
    using any wireless protocol. In this attack, an attacker relies on a Software
    Defined Radio device or cheap, off-the-shelf Wi-Fi dongles to transmit radio signals
    and make a wireless channel unusable for other devices. We’ll show such an attack
    in Chapter 15\.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could perform *selective jamming*, a sophisticated version
    of a radio jamming attack in which the attacker jams only specific packets of
    high importance.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that for certain chipsets, deauthentication attacks can also
    downgrade the encryption keys used for communication between the AP and the client.
    Recent research by the antivirus company ESET identified this vulnerability, which
    is known as Kr00k (CVE-2019-15126). When present, the deauthenticated Wi-Fi chipset
    uses an all-zero encryption key upon reassociation, which allows attackers to
    decrypt packets transmitted by the vulnerable device.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Association Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *association attack* tricks a wireless station into connecting to an attacker-controlled
    AP. If the target station is already connected to some other network, the attacker
    usually starts by implementing one of the deauthentication techniques we just
    explained. Once the victims no longer have a connection, the attacker can lure
    them into the rogue network by abusing different features of their network manager.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we outline the most popular association attacks and then demonstrate
    a Known Beacons attack.
  prefs: []
  type: TYPE_NORMAL
- en: The Evil Twin Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common association attack is the *Evil Twin*, which tricks a client
    into connecting with a fake AP by making it believe it’s connecting to a known,
    legitimate one.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a fake AP using a network adapter with monitoring and packet injection
    capabilities. With that network card, we’d set up the AP and configure its channel,
    ESSID, and BSSID, making sure to copy the ESSID and encryption type the legitimate
    network uses. Then we’d send a stronger signal than the legitimate AP’s signal.
    You can enhance your signal with various techniques, most reliably by being physically
    closer to your target than the legitimate AP or by using a stronger antenna.
  prefs: []
  type: TYPE_NORMAL
- en: The KARMA Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*KARMA* attacks connect users to insecure networks by taking advantage of clients
    configured to discover wireless networks automatically. When configured in this
    way, the client issues a direct probe request asking for specific APs, then it
    connects to the one it finds without authenticating it. A *probe request* is a
    management frame that initiates the association process. Given this configuration,
    the attacker could simply confirm any of the client’s requests and connect it
    to a rogue AP.'
  prefs: []
  type: TYPE_NORMAL
- en: For a KARMA attack to work, the devices you’re targeting must meet three requirements.
    The target network must be of type Open, the client must have the AutoConnect
    flag enabled, and the client must broadcast its preferred network list. The *preferred
    network list* is a list of networks to which the client has previously connected
    and now trusts. A client with the AutoConnect flag enabled will connect to an
    AP automatically, as long as the AP sends it an ESSID already listed in the client’s
    preferred network list.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern operating systems aren’t vulnerable to KARMA attacks, because they
    don’t send their preferred network lists, but you might sometimes encounter a
    vulnerable system in older IoT devices or printers. If a device has ever connected
    to an open and hidden network, it’s definitely vulnerable to a KARMA attack. The
    reason is that the only way to connect to open hidden networks is to send a direct
    probe to them, in which case all the requirements for KARMA attacks are met.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Known Beacons Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the discovery of the KARMA attack, most operating systems stopped directly
    probing APs; instead, they only use *passive reconnaissance*, in which the device
    listens for a known ESSID from a network. This type of behavior completely eliminates
    all occurrences of KARMA attacks.
  prefs: []
  type: TYPE_NORMAL
- en: A *Known Beacons attack* bypasses this security feature by taking advantage
    of the fact that many operating systems enable the AutoConnectflag by default.
    Because APs frequently have very common names, an attacker can often guess the
    ESSID of an open network in a device’s preferred network list. Then it tricks
    that device into automatically connecting to an attacker-controlled AP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more sophisticated version of the attack, the adversary could use a dictionary
    of common ESSIDs, such as Guest, FREE Wi-Fi, and so on, that the victim has likely
    connected to in the past. This is a lot like trying to gain unauthorized access
    to a service account by just brute forcing the username when no password is required:
    a quite simple, yet effective attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-1](#figure12-1) illustrates a Known Beacons attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f12001](Images/f12001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: A Known Beacons attack'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker’s AP begins by issuing multiple *beacon frames,* a type of management
    frame that contains all the network information. It’s broadcasted periodically
    to announce the presence of the network. If the victim has this network’s information
    in its preferred network list (because the victim has connected to that network
    in the past) and if the attacker and the victim APs are of the Open type, the
    victim will issue a probe request and connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Before walking through this attack, we need to set up our devices. Some devices
    might allow you to change the AutoConnect flag. The location of this setting differs
    from device to device, but it’s usually in the Wi-Fi preferences, as shown in
    [Figure 12-2](#figure12-2), under a setting like “Auto reconnect.” Make sure it’s
    turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '![f12002](Images/f12002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Wi-Fi preferences with the AutoConnect toggle'
  prefs: []
  type: TYPE_NORMAL
- en: Next, set up an open AP with the name `my_essid.` We did this using a portable
    TP-Link AP, but you can use any device you’d like. Once you’ve set it up, connect
    your victim device to the `my_essid` network. Then install *Wifiphisher* ([https://github.com/wifiphisher/wifiphisher/](https://github.com/wifiphisher/wifiphisher/)),
    a rogue AP framework frequently used for network assessments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Wifiphisher, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Wifiphisher needs to target a specific network to start attacking that network’s
    clients. We create a test network, also called `my_essid`, to avoid affecting
    outside clients when we don’t have authorization to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We start Wifiphisher in the Known Beacons mode by adding the `–kB` argument
    1. You don’t have to provide a wordlist for the attack because Wifiphisher has
    one built in. The wordlist contains common ESSIDs that the victim might have connected
    to in the past. Once you run the command, WifiPhisher’s interface should open,
    as shown in [Figure 12-3](#figure12-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f12003](Images/f12003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: Wifiphisher’s panel showing the victim device connecting to our
    network'
  prefs: []
  type: TYPE_NORMAL
- en: Wifiphisher’s panel displays the number of connected victim devices. Currently,
    our test device is the only target device connected.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the preferred network list of the device you’re targeting in this example.
    For instance, [Figure 12-4](#figure12-4) shows the preferred network list screen
    on a Samsung Galaxy S8+ device. Notice that it has two networks saved. The first
    one, `FreeAirportWiFi`, uses an easily guessable name.
  prefs: []
  type: TYPE_NORMAL
- en: '![f12004](Images/f12004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: The victim device’s preferred network list screen'
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, once we’ve executed the attack, the device should disassociate
    from its currently connected network and connect to our malicious, fake network
    ([Figure 12-5](#figure12-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f12005](Images/f12005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: The victim device connects to a fake network as a result of the
    Known Beacons attack.'
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, the attacker can work as a man in the middle, monitoring
    the victim’s traffic or even tampering with it.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Direct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wi-Fi Direct is a Wi-Fi standard that allows devices to connect to each other
    without a wireless AP. In a traditional architecture, all devices connect to one
    AP to communicate with one another. In Wi-Fi Direct, one of the two devices acts
    as the AP instead. We call this device the *group owner*. For Wi-Fi Direct to
    work, only the group owner must comply with the Wi-Fi Direct standard.
  prefs: []
  type: TYPE_NORMAL
- en: You can find Wi-Fi Direct in devices like printers, TVs, gaming consoles, audio
    systems, and streaming devices. Many IoT devices that support Wi-Fi Direct are
    simultaneously connected to a standard Wi-Fi network. For example, a home printer
    might be able to accept photos directly from your smartphone via Wi-Fi Direct,
    but it’s also probably connected to a local network.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review how Wi-Fi Direct works, what its main modes of
    operation are, and which techniques you can use to exploit its security features.
  prefs: []
  type: TYPE_NORMAL
- en: How Wi-Fi Direct Works
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 12-6](#figure12-6) shows how devices establish a connection using Wi-Fi
    Direct.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f12006](Images/f12006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: Main phases of device connection in Wi-Fi Direct'
  prefs: []
  type: TYPE_NORMAL
- en: In the Device Discovery phase, a device sends a broadcast message to all nearby
    devices, requesting their MAC addresses. At this stage, there is no group owner,
    so any device can initiate this step. Next, in the Service Discovery phase, the
    device receives the MAC addresses and proceeds with a unicast service request
    to each device asking for more information about their services. This allows it
    to decide whether it wants to connect to each device. After the Service Discovery
    phase, the two devices decide which will be the group owner and which will be
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final phase, Wi-Fi Direct relies on Wi-Fi Protected Setup (WPS) to securely
    connect the devices. *WPS* is a protocol originally created to allow less tech-savvy
    home users to easily add new devices on the network. WPS has multiple configuration
    methods: Push-Button Configuration (PBC), PIN entry, and Near-Field Communication
    (NFC). In *PBC*, the group owner has a physical button, which, if pressed, starts
    broadcasting for 120 seconds. In that time, the clients can connect to the group
    owner using their own software or hardware button. This makes it possible for
    a confused user to press a button on a victim device, such as a TV, and grant
    access to a foreign and potentially malicious device, such as the attacker’s smartphone.
    In *PIN entry* mode, the group owner has a specific PIN code, which, if entered
    by a client, automatically connects the two devices. In *NFC* mode, just tapping
    the two devices is enough to connect them to the network.'
  prefs: []
  type: TYPE_NORMAL
- en: PIN Brute Forcing Using Reaver
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Attackers can brute force the code in the PIN entry configuration. This attack
    can resemble a one-click phishing attack, and you can use it with any device that
    supports Wi-Fi Direct with PIN entry.
  prefs: []
  type: TYPE_NORMAL
- en: This attack takes advantage of a weakness in the eight-digit WPS PIN code; because
    of this issue, the protocol discloses information about the PIN’s first four digits,
    and the last digit works as a checksum, which makes brute forcing the WPS AP easy.
    Note that some devices include brute-force protections, which usually block MAC
    addresses that repeatedly try to attack. In that case, the complexity of this
    attack increases, because you’d have to rotate MAC addresses while testing PINs.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, you’ll rarely find APs with WPS PIN mode enabled, because off-the-shelf
    tools exist to brute force their pins. One such tool, Reaver, is preinstalled
    in Kali Linux. In this example, we’ll use Reaver to brute force WPS PIN entry.
    Even though this AP enforces a brute-force protection through rate limiting, we
    should be able to recover the PIN given enough time. (*Rate limiting* restricts
    how many requests an AP will accept from a client within a predefined timeframe.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Reaver 1 targets our test network and starts brute forcing its
    PIN. Next, we encounter rate limiting 2, which severely delays our efforts, because
    Reaver automatically pauses before making another attempt. Finally, we recover
    the WPS PIN 3.
  prefs: []
  type: TYPE_NORMAL
- en: EvilDirect Hijacking Attacks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The EvilDirect attack works a lot like the Evil Twin attack described earlier
    in this chapter, except it targets devices using Wi-Fi Direct. This association
    attack takes place during the PBC connection process. During this process, the
    client issues a request to connect to the group owner and then waits for its acceptance.
    An attacking group owner with the same MAC address and ESSID, operating on the
    same channel, could intercept the request and lure the victim client to associate
    with it instead.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can attempt this attack, you’ll have to impersonate the legitimate
    group owner. Use Wifiphisher to identify the target Wi-Fi Direct network. Extract
    the group owner’s channel, ESSID, and MAC address, and then create a new group
    owner, using the extracted data to configure it. Connect the victim to your fake
    network by having a better signal than the original group owner, as described
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, kill all processes that interfere with Airmon-ng, as we did earlier in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then put your wireless interface in monitor mode using iwconfig:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `iwconfig`command 1 lets you identify the name of your wireless adapter.
    Ours is named `wlan0` 2. Once you have that name, use the command `airmon-ng start
    wlan0`3 to safely put it in monitor mode.
  prefs: []
  type: TYPE_NORMAL
- en: Next, run Airbase-ng, a multipurpose tool in the Aircrack-ng suite aimed at
    attacking Wi-Fi clients. As command line arguments, provide the channel (`-c`),
    ESSID (`-e`), BSSID (`-a`), and the monitoring interface, which in our case is
    `mon0`. We extracted this information in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that the attack worked 1; our target client is now associated
    to the malicious AP.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-7](#figure12-7) proves that our attack succeeded. We managed to
    connect the victim phone to our fake BRAVIA TV by impersonating the original TV’s
    Wi-Fi Direct network, DIRECT-5x-BRAVIA.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f12007](Images/f12007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-7: Victim device connected to a fake AP through an EvilDirect attack'
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world example, we’d also want to have a DHCP server configured to
    forward all packets to their destinations. That way, we wouldn’t disrupt the victim’s
    communication, providing a seamless experience to the victim.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Attacks Against APs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not uncommon in the IoT world for IoT devices to act as APs. This often
    occurs when a device creates an open AP for its setup process (for example, Amazon
    Alexa and Google Chromecast do this). Modern mobile devices can also serve as
    APs to share their Wi-Fi connectivity with other users, and smart cars feature
    built-in Wi-Fi hotspots enhanced by a 4G LTE connection.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking an AP usually means breaking its encryption. In this section, we’ll
    explore attacks against WPA and WPA2, two protocols used to secure wireless computer
    networks. WPA is an upgraded version of *WEP*, a highly insecure protocol you
    might still encounter in certain older IoT devices. WEP generates an Initialization
    Vector (IV) with a rather small length—just 24 bits— which is created using *RC4*,
    a deprecated and insecure cryptographic function. In turn, WPA2 is an upgraded
    version of WPA that introduced an Advanced Encryption Standard (AES)–based encryption
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss WPA/WPA2 Personal and Enterprise networks and identify key attacks
    against them.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WPA/WPA2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can crack a WPA/WPA2 network in two ways. The first targets networks that
    use preshared keys. The second targets the *Pairwise Master Key Identifier (PMKID)*
    field found in networks that enable roaming with the 802.11r standard. While roaming,
    a client can connect to different APs belonging to the same network without having
    to reauthenticate to each one. Although the PMKID attack has greater success rate,
    it doesn’t affect all the WPA/WPA2 networks, because the PMKID field is optional.
    The preshared key attack is a brute-force attack, which has a lower success rate.
  prefs: []
  type: TYPE_NORMAL
- en: Preshared Key Attacks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: WEP, WPA, and WPA2 all rely on secret keys that the two devices must share,
    ideally over a secure channel, before they can communicate. In all three protocols,
    APs use the same preshared key with all their clients.
  prefs: []
  type: TYPE_NORMAL
- en: To steal this key, we need to capture a complete four-way handshake. The *WPA/WPA2
    four-way handshake* is a communication sequence that lets the AP and wireless
    client prove to each other that they both know the preshared key without ever
    disclosing it over the air. By capturing the four-way handshake, an attacker can
    mount an offline brute-force attack and expose the key.
  prefs: []
  type: TYPE_NORMAL
- en: Also known as an *Extensible Authentication Protocol (EAP)* over LAN (EAPOL)
    handshake, the four-way handshake that WPA2 uses ([Figure 12-8](#figure12-8))
    involves the generation of multiple keys based on the preshared one.
  prefs: []
  type: TYPE_NORMAL
- en: '![f12008](Images/f12008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-8: WPA2 four-way handshake'
  prefs: []
  type: TYPE_NORMAL
- en: First, the client uses the preshared key, called the Pairwise-Master Key (PMK),
    to generate a second key, called the Pairwise Transient Key (PTK), using both
    devices’ MAC addresses and a nonce from both parties. This requires the AP to
    send the client its nonce, called the A-nonce. (The client already knows its own
    MAC address, and it receives the AP’s once the two devices begin communicating,
    so the devices don’t need to send those again.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the client has generated the PTK, it sends the AP two items: its own nonce,
    called the S-nonce, and a hash of the PTK, called a *Message Integrity Code (MIC)*.
    The AP then generates the PTK on its own and verifies the MIC it received. If
    the MIC is valid, the AP issues a third key, called the *Group Temporal Key (GTK)*,
    which is used to decrypt and broadcast traffic to all clients. The AP sends the
    GTK’s MIC and the full value of GTK. The client validates these and responds with
    an acknowledgment (ACK).'
  prefs: []
  type: TYPE_NORMAL
- en: The devices send all these messages as EAPOL frames, a type of frame that the
    802.1X protocol uses.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s attempt to crack a WPA2 network. To get the PMK, we need to extract the
    A-nonce, S-nonce, both MAC addresses, and the PTK’s MIC. Once we have these values,
    we can perform an offline brute-force attack to crack the password.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve set up an AP operating in WPA2 preshared key mode and
    then connected a smartphone to that AP. You could replace the client with a laptop,
    smartphone, IP camera, or other device. We’ll use Aircrack-ng to demonstrate the
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: First, put your wireless interface in monitor mode and extract the AP’s BSSID.
    Refer to “Deauthentication and Denial-of-Service Attacks” on page 289 for complete
    instructions on how to do this. In our case, we learned the AP’s operation channel
    is 1 and its BSSID is `0C:0C:0C:0C:0C:0C`.
  prefs: []
  type: TYPE_NORMAL
- en: Continue monitoring passively, which will require some time, because we’ll have
    to wait until a client connects to the AP. You could accelerate this process by
    sending deauthentication packets to an already connected client. By default, a
    deauthenticated client will try to reconnect to their AP, initiating the four-way
    handshake again.
  prefs: []
  type: TYPE_NORMAL
- en: Once a client has connected, use Airodump-ng`to start capturing frames sent
    to the target network:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
