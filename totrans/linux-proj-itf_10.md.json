["```\n#include <sys/time.h>\nint `gettimeofday`(struct timeval **tv*, struct timezone **tz*);\n```", "```\nstruct timeval {\n    time_t      tv_sec;     /* Seconds since 00:00:00, 1 Jan 1970 UTC */\n    suseconds_t tv_usec;    /* Additional microseconds (long int) */\n};\n```", "```\n#include <time.h>\n\ntime_t `time`(time_t **timep*);\n```", "```\nt = time(NULL);\n```", "```\n#include <time.h>\n\nchar *`ctime`(const time_t **timep*);\n```", "```\nWed Jun  8 14:22:34 2011\n```", "```\n#include <time.h>\n\nstruct tm *`gmtime`(const time_t **timep*);\nstruct tm *`localtime`(const time_t **timep*);\n```", "```\nstruct tm {\n    int tm_sec;        /* Seconds (0-60) */\n    int tm_min;        /* Minutes (0-59) */\n    int tm_hour;       /* Hours (0-23) */\n    int tm_mday;       /* Day of the month (1-31) */\n    int tm_mon;        /* Month (0-11) */\n    int tm_year;       /* Year since 1900 */\n    int tm_wday;       /* Day of the week (Sunday = 0)*/\n    int tm_yday;       /* Day in the year (0-365; 1 Jan = 0)*/\n    int tm_isdst;      /* Daylight saving time flag\n                            > 0: DST is in effect;\n                            = 0: DST is not effect;\n                            < 0: DST information not available */\n};\n```", "```\n#include <time.h>\n\ntime_t `mktime`(struct tm **timeptr*);\n```", "```\n#include <time.h>\n\nchar *`asctime`(const struct tm **timeptr*);\n```", "```\n$ `date`\nTue Dec 28 16:01:51 CET 2010\n$ `./calendar_time`\nSeconds since the Epoch (1 Jan 1970): 1293548517 (about 40.991 years)\n  gettimeofday() returned 1293548517 secs, 715616 microsecs\nBroken down by gmtime():\n  year=110 mon=11 mday=28 hour=15 min=1 sec=57 wday=2 yday=361 isdst=0\nBroken down by localtime():\n  year=110 mon=11 mday=28 hour=16 min=1 sec=57 wday=2 yday=361 isdst=0\n\nasctime() formats the gmtime() value as: Tue Dec 28 15:01:57 2010\nctime() formats the time() value as:     Tue Dec 28 16:01:57 2010\nmktime() of gmtime() value:    1293544917 secs\nmktime() of localtime() value: 1293548517 secs      *3600 secs ahead of UTC*\n```", "```\n`time/calendar_time.c`\n#include <locale.h>\n#include <time.h>\n#include <sys/time.h>\n#include \"tlpi_hdr.h\"\n#define SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60)\n\nint\nmain(int argc, char *argv[])\n{\n    time_t t;\n    struct tm *gmp, *locp;\n    struct tm gm, loc;\n    struct timeval tv;\n\n    t = time(NULL);\n    printf(\"Seconds since the Epoch (1 Jan 1970): %ld\", (long) t);\n    printf(\" (about %6.3f years)\\n\", t / SECONDS_IN_TROPICAL_YEAR);\n\n    if (gettimeofday(&tv, NULL) == -1)\n        errExit(\"gettimeofday\");\n    printf(\"  gettimeofday() returned %ld secs, %ld microsecs\\n\",\n            (long) tv.tv_sec, (long) tv.tv_usec);\n\n    gmp = gmtime(&t);\n    if (gmp == NULL)\n        errExit(\"gmtime\");\n\n    gm = *gmp;          /* Save local copy, since *gmp may be modified\n                           by asctime() or gmtime() */\n    printf(\"Broken down by gmtime():\\n\");\n    printf(\"  year=%d mon=%d mday=%d hour=%d min=%d sec=%d \", gm.tm_year,\n            gm.tm_mon, gm.tm_mday, gm.tm_hour, gm.tm_min, gm.tm_sec);\n    printf(\"wday=%d yday=%d isdst=%d\\n\", gm.tm_wday, gm.tm_yday, gm.tm_isdst);\n\n    locp = localtime(&t);\n    if (locp == NULL)\n        errExit(\"localtime\");\n\n    loc = *locp;        /* Save local copy */\n\n    printf(\"Broken down by localtime():\\n\");\n    printf(\"  year=%d mon=%d mday=%d hour=%d min=%d sec=%d \",\n            loc.tm_year, loc.tm_mon, loc.tm_mday,\n            loc.tm_hour, loc.tm_min, loc.tm_sec);\n    printf(\"wday=%d yday=%d isdst=%d\\n\\n\",\n            loc.tm_wday, loc.tm_yday, loc.tm_isdst);\n\n    printf(\"asctime() formats the gmtime() value as: %s\", asctime(&gm));\n    printf(\"ctime() formats the time() value as:     %s\", ctime(&t));\n\n    printf(\"mktime() of gmtime() value:    %ld secs\\n\", (long) mktime(&gm));\n    printf(\"mktime() of localtime() value: %ld secs\\n\", (long) mktime(&loc));\n\n    exit(EXIT_SUCCESS);\n}\n     `time/calendar_time.c`\n```", "```\n#include <time.h>\n\nsize_t `strftime`(char **outstr*, size_t *maxsize*, const char **format*,\n                const struct tm **timeptr*);\n```", "```\n#include \"curr_time.h\"\n\nchar *`currTime`(const char **format*);\n```", "```\n`time/curr_time.c`\n#include <time.h>\n#include \"curr_time.h\"          /* Declares function defined here */\n\n#define BUF_SIZE 1000\n\n/* Return a string containing the current time formatted according to\n   the specification in 'format' (see strftime(3) for specifiers).\n   If 'format' is NULL, we use \"%c\" as a specifier (which gives the\n   date and time as for ctime(3), but without the trailing newline).\n   Returns NULL on error. */\n\nchar *\ncurrTime(const char *format)\n{\n    static char buf[BUF_SIZE];  /* Nonreentrant */\n    time_t t;\n    size_t s;\n    struct tm *tm;\n\n    t = time(NULL);\n    tm = localtime(&t);\n    if (tm == NULL)\n        return NULL;\n\n    s = strftime(buf, BUF_SIZE, (format != NULL) ? format : \"%c\", tm);\n\n    return (s == 0) ? NULL : buf;\n}\n     `time/curr_time.c`\n```", "```\n#define _XOPEN_SOURCE\n\n#include <time.h>\n\nchar *`strptime`(const char **str*, const char **format*, struct tm **timeptr*);\n```", "```\n$ `./strtime \"9:39:46pm 1 Feb 2011\" \"%I:%M:%S%p %d %b %Y\"`\n\ncalendar time (seconds since Epoch): 1296592786\nstrftime() yields: 21:39:46 Tuesday, 01 February 2011 CET\n```", "```\n$ `./strtime \"9:39:46pm 1 Feb 2011\" \"%I:%M:%S%p %d %b %Y\" \"%F %T\"`\ncalendar time (seconds since Epoch): 1296592786\nstrftime() yields: 2011-02-01 21:39:46\n```", "```\n`time/strtime.c`\n#define _XOPEN_SOURCE\n#include <time.h>\n#include <locale.h>\n#include \"tlpi_hdr.h\"\n\n#define SBUF_SIZE 1000\n\nint\nmain(int argc, char *argv[])\n{\n    struct tm tm;\n    char sbuf[SBUF_SIZE];\n    char *ofmt;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s input-date-time in-format [out-format]\\n\", argv[0]);\n\n    if (setlocale(LC_ALL, \"\") == NULL)\n        errExit(\"setlocale\");   /* Use locale settings in conversions */\n\n    memset(&tm, 0, sizeof(struct tm));          /* Initialize 'tm' */\n    if (strptime(argv[1], argv[2], &tm) == NULL)\n        fatal(\"strptime\");\n\n    tm.tm_isdst = -1;           /* Not set by strptime(); tells mktime()\n                                   to determine if DST is in effect */\n    printf(\"calendar time (seconds since Epoch): %ld\\n\", (long) mktime(&tm));\n\n    ofmt = (argc > 3) ? argv[3] : \"%H:%M:%S %A, %d %B %Y %Z\";\n    if (strftime(sbuf, SBUF_SIZE, ofmt, &tm) == 0)\n        fatal(\"strftime returned 0\");\n    printf(\"strftime() yields: %s\\n\", sbuf);\n\n    exit(EXIT_SUCCESS);\n}\n     `time/strtime.c`\n```", "```\nchar *tzname[2];    /* Name of timezone and alternate (DST) timezone */\nint daylight;       /* Nonzero if there is an alternate (DST) timezone */\nlong timezone;      /* Seconds difference between UTC and local\n                       standard time */\n```", "```\n$ `./show_time`\nctime() of time() value is:  Tue Feb  1 10:25:56 2011\nasctime() of local time is:  Tue Feb  1 10:25:56 2011\nstrftime() of local time is: Tuesday, 01 Feb 2011, 10:25:56 CET\n$ `TZ=\":Pacific/Auckland\" ./show_time`\nctime() of time() value is:  Tue Feb  1 22:26:19 2011\nasctime() of local time is:  Tue Feb  1 22:26:19 2011\nstrftime() of local time is: Tuesday, 01 February 2011, 22:26:19 NZDT\n```", "```\n`time/show_time.c`\n#include <time.h>\n#include <locale.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 200\n\nint\nmain(int argc, char *argv[])\n{\n    time_t t;\n    struct tm *loc;\n    char buf[BUF_SIZE];\n\n    if (setlocale(LC_ALL, \"\") == NULL)\n        errExit(\"setlocale\");   /* Use locale settings in conversions */\n\n    t = time(NULL);\n\n    printf(\"ctime() of time() value is:  %s\", ctime(&t));\n\n    loc = localtime(&t);\n    if (loc == NULL)\n        errExit(\"localtime\");\n\n    printf(\"asctime() of local time is:  %s\", asctime(loc));\n\n    if (strftime(buf, BUF_SIZE, \"%A, %d %B %Y, %H:%M:%S %Z\", loc) == 0)\n        fatal(\"strftime returned 0\");\n    printf(\"strftime() of local time is: %s\\n\", buf);\n\n    exit(EXIT_SUCCESS);\n}\n      `time/show_time.c`\n```", "```\n*std offset* [ *dst* [ *offset* ][ , *start-date* [\n /*time* ] , *end-date* [ /*time* ]]]\n```", "```\nTZ=\"CET-1:00:00CEST-2:00:00,M3.5.0,M10.5.0\"\n```", "```\nTZ=\":Europe/Berlin\"\n```", "```\n*language*[_*territory*[.*codeset*]][@*modifier*]\n```", "```\n#include <locale.h>\n\nchar *`setlocale`(int *category*, const char **locale*);\n```", "```\nsetlocale(LC_ALL, \"\");\n```", "```\n$ `LANG=de_DE ./show_time`                        *German locale*\nctime() of time() value is:  Tue Feb  1 12:23:39 2011\nasctime() of local time is:  Tue Feb  1 12:23:39 2011\nstrftime() of local time is: Dienstag, 01 Februar 2011, 12:23:39 CET\n```", "```\n$ `LANG=de_DE LC_TIME=it_IT ./show_time`          *German and Italian locales*\nctime() of time() value is:  Tue Feb  1 12:24:03 2011\nasctime() of local time is:  Tue Feb  1 12:24:03 2011\nstrftime() of local time is: martedì, 01 febbraio 2011, 12:24:03 CET\n```", "```\n$ `LC_ALL=fr_FR LC_TIME=en_US ./show_time`        *French and US locales*\nctime() of time() value is:  Tue Feb  1 12:25:38 2011\nasctime() of local time is:  Tue Feb  1 12:25:38 2011\nstrftime() of local time is: mardi, 01 février 2011, 12:25:38 CET\n```", "```\n#define _BSD_SOURCE\n\n#include <sys/time.h>\n\nint `settimeofday`(const struct timeval **tv*, const struct timezone **tz*);\n```", "```\n#define _BSD_SOURCE\n\n#include <sys/time.h>\n\nint `adjtime`(struct timeval **delta*, struct timeval **olddelta*);\n```", "```\n$ `time ./myprog`\nreal    0m4.84s\nuser    0m1.030s\nsys     0m3.43s\n```", "```\n#include <sys/times.h>\n\nclock_t `times`(struct tms **buf*);\n```", "```\nstruct tms {\n    clock_t tms_utime;   /* User CPU time used by caller */\n    clock_t tms_stime;   /* System CPU time used by caller */\n    clock_t tms_cutime;  /* User CPU time of all (waited for) children */\n    clock_t tms_cstime;  /* System CPU time of all (waited for) children */\n};\n```", "```\n#include <time.h>\n\nclock_t `clock`(void);\n```", "```\n$ `./process_time 10000000`\nCLOCKS_PER_SEC=1000000  sysconf(_SC_CLK_TCK)=100\n\nAt program start:\n        clock() returns: 0 clocks-per-sec (0.00 secs)\n        times() yields: user CPU=0.00; system CPU: 0.00\nAfter getppid() loop:\n        clock() returns: 2960000 clocks-per-sec (2.96 secs)\n        times() yields: user CPU=1.09; system CPU: 1.87\n```", "```\n`time/process_time.c`\n#include <sys/times.h>\n#include <time.h>\n#include \"tlpi_hdr.h\"\n\nstatic void             /* Display 'msg' and process times */\ndisplayProcessTimes(const char *msg)\n{\n    struct tms t;\n    clock_t clockTime;\n    static long clockTicks = 0;\n\n    if (msg != NULL)\n        printf(\"%s\", msg);\n    if (clockTicks == 0) {      /* Fetch clock ticks on first call */\n        clockTicks = sysconf(_SC_CLK_TCK);\n        if (clockTicks == -1)\n            errExit(\"sysconf\");\n    }\n\n    clockTime = clock();\n    if (clockTime == -1)\n        errExit(\"clock\");\n\n    printf(\"        clock() returns: %ld clocks-per-sec (%.2f secs)\\n\",\n            (long) clockTime, (double) clockTime / CLOCKS_PER_SEC);\n\n    if (times(&t) == -1)\n        errExit(\"times\");\n    printf(\"        times() yields: user CPU=%.2f; system CPU: %.2f\\n\",\n            (double) t.tms_utime / clockTicks,\n            (double) t.tms_stime / clockTicks);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int numCalls, j;\n\n    printf(\"CLOCKS_PER_SEC=%ld  sysconf(_SC_CLK_TCK)=%ld\\n\\n\",\n            (long) CLOCKS_PER_SEC, sysconf(_SC_CLK_TCK));\n\n    displayProcessTimes(\"At program start:\\n\");\n\n    numCalls = (argc > 1) ? getInt(argv[1], GN_GT_0, \"num-calls\") : 100000000;\n    for (j = 0; j < numCalls; j++)\n        (void) getppid();\n\n    displayProcessTimes(\"After getppid() loop:\\n\");\n\n    exit(EXIT_SUCCESS);\n}\n      `time/process_time.c`\n```"]