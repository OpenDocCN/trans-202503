- en: '![](../images/pg46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-09.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BINARY
    OPERATORS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll implement five new operators: addition, subtraction,
    multiplication, division, and the remainder operator. These are all *binary operators*,
    which take two operands. This chapter won’t require any new compiler stages; you’ll
    just extend each of the stages you’ve already written. In the parsing stage, you’ll
    see why recursive descent parsing doesn’t work well for binary expressions. Instead,
    you’ll use a different technique, *precedence climbing*, which will be easier
    to build on in later chapters. Precedence climbing is the last major parsing technique
    you’ll need. Once it’s in place, you’ll be able to add new syntax with relatively
    little effort for the rest of the book. In the assembly generation stage, you’ll
    introduce several assembly instructions that perform binary operations. As usual,
    we’ll start with the lexer.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lexer needs to recognize four new tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> A plus sign, the operator
    for addition
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp> An asterisk, the operator
    for multiplication
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/</samp> A forward slash, the division
    operator
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%</samp> A percent sign, the remainder
    operator
  prefs: []
  type: TYPE_NORMAL
- en: This list doesn’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    token, because you added it in the last chapter. The lexing stage doesn’t distinguish
    between negation and subtraction; it should produce the same token either way.
  prefs: []
  type: TYPE_NORMAL
- en: You should lex these tokens in the same way as the single-character tokens in
    the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’re going to add another kind of expression to the AST: binary operations.
    [Listing 3-1](chapter3.xhtml#list3-1) shows the updated AST definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: The abstract syntax
    tree with binary operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parser, unlike the lexer, distinguishes between negation and subtraction.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is parsed as either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>,
    depending on where it appears in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the structure of the AST determines the order of evaluation of
    nested expressions. Let’s look at a couple of examples to see how the AST’s structure
    controls the order of operations. The AST in [Figure 3-1](#fig3-1) represents
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>, which evaluates
    to 7.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AST for 1 +
    (2 * 3) [Description](description-10.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operation has two
    operands: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>. To evaluate this expression, you calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp> first, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to the result. The AST in [Figure 3-2](#fig3-2), on the other hand, represents
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2) * 3</samp>, which evaluates to
    9.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig3-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The AST for (1
    + 2) * 3 [Description](description-11.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    first, then multiply by <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    As a general rule, before evaluating an AST node you need to evaluate both of
    its children. This pattern, where you process a node’s children before the node
    itself, is called *postorder traversal*. Note that any tree data structure can
    be traversed in postorder, not just ASTs.
  prefs: []
  type: TYPE_NORMAL
- en: Your compiler traverses the AST to generate code, not to evaluate expressions,
    but the idea is the same. When you convert the AST for a binary expression to
    TACKY, you first generate instructions to calculate both operands, then generate
    instructions for the operation itself. (You also used postorder traversal to process
    unary operations in [Chapter 2](chapter2.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial for your parser to group nested expressions correctly. If you try
    to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp> but end up with the
    AST from [Figure 3-2](#fig3-2), you’ll ultimately compile the program incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples we just looked at used parentheses to explicitly group nested
    expressions. Some expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>, don’t parenthesize every nested expression. In those cases, we group
    expressions based on the *precedence* and *associativity* of the operators. Operators
    with higher precedence are evaluated first; since <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    has higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    you’d parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>. Associativity tells you how to handle operators at the same precedence
    level. If an operation is *left-associative*, you apply the operator on the left
    first, and if it’s *right-associative*, you apply the operator on the right first.
    For example, since addition and subtraction are left-associative, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    - 3</samp> would be parsed as <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)
    - 3</samp>. All the new operators in this chapter are left-associative, and there
    are two precedence levels: <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    have higher precedence, while <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> have lower precedence.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trouble with
    Recursive Descent Parsing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s surprisingly tricky to write a recursive descent parser that correctly
    handles operator precedence and associativity. To see why, let’s try adding a
    production rule for binary expressions to the formal grammar. This new rule is
    bolded in the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    in [Listing 3-2](chapter3.xhtml#list3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A simple grammar
    rule that doesn’t work for recursive descent parsers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A binary expression consists of an expression, then a binary operator, then
    another expression, so <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp> <binop>
    <exp></samp> is the obvious way to define it in the formal grammar. But there
    are a couple of reasons a recursive descent parser can’t use this production rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, [Listing 3-2](chapter3.xhtml#list3-2) is *ambiguous*: it allows you
    to parse certain inputs in more than one way. For example, according to this grammar,
    [Figures 3-1](#fig3-1) and [3-2](#fig3-2) are equally valid parses of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>. We need to know the relative precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to decide which parse
    to use, but the grammar doesn’t capture that information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the new production rule is *left-recursive*: the leftmost symbol in
    this production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    is, itself, <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>. You can’t
    apply a left-recursive rule in a recursive descent parser; if you try, you end
    up with unbounded recursion. Imagine trying to implement this production rule
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. The first symbol
    in this rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>, so
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> would have to process
    that symbol by calling itself recursively. But <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    wouldn’t consume any tokens before the recursive call. It would call itself with
    exactly the same input, so it would never terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: We can solve these problems in a couple of ways. If we want a pure recursive
    descent parser, we can refactor the grammar to remove the ambiguity and left recursion.
    Since that approach has some drawbacks, we’ll use precedence climbing, an alternative
    to recursive descent parsing. However, it’s helpful to take a look at the pure
    recursive descent solution first.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Adequate Solution:
    Refactoring the Grammar</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we refactor the grammar, we’ll end up with one grammar rule for each precedence
    level, like in [Listing 3-3](chapter3.xhtml#list3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: A recursive descent–friendly
    grammar for binary operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using the grammar in [Listing 3-3](chapter3.xhtml#list3-3), there’s only one
    way to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>, and there’s no left
    recursion. The braces indicate repetition, so a single <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    for example, can contain any number of <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>s.
    It might be a <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>, or
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11"><term>
    - <term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>,
    and so on. The parser then groups that long string of terms into a left-associative
    tree to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node. (Note that we can’t use a rule like <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp>
    ::=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><term> "+" <exp></samp>
    because it results in a right-associative tree. The grammar in [Listing 3-3](chapter3.xhtml#list3-3),
    on the other hand, doesn’t specify the associativity, which allows the parser
    to build either a left-associative or a right-associative tree.)
  prefs: []
  type: TYPE_NORMAL
- en: This approach works, but it gets increasingly unwieldy as you add more precedence
    levels. We have three precedence levels now, if you count <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>;
    we’ll add four more when we introduce logical and relational operators in [Chapter
    4](chapter4.xhtml). If we went with this approach, we’d need to add a new symbol
    to the grammar—and a corresponding function to our parser—for each precedence
    level we add. That’s a lot of boilerplate, since the functions to parse the expressions
    at different precedence levels would be almost identical.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Better Solution:
    Precedence Climbing</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Precedence climbing is a simpler way to parse binary expressions. It can handle
    production rules like <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp> <binop>
    <exp></samp> while respecting the precedence of each binary operator. In precedence
    climbing, every operator has a numeric precedence level, and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    takes a minimum precedence level as an argument. This lets you specify the appropriate
    precedence level for whatever subexpression you’re parsing. For example, suppose
    you just saw a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> token, and
    now you want to parse what comes next as the right-hand side of an addition expression:
    you’d specify that it should include only operations that have higher precedence
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>. This solution makes
    it easy to add new operators; you have to assign each new operator a numeric precedence
    level, but you don’t need to make any other changes to your parsing code.'
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mixing Precedence Climbing
    with Recursive Descent</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use precedence climbing to parse binary expressions and still use recursive
    descent to parse other language constructs. Remember that a recursive descent
    parser uses a different function to parse each symbol. That makes it easy to parse
    different symbols with different techniques: we use precedence climbing in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> function and recursive
    descent in the functions that parse all the other symbols. The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    function will remove tokens from the input stream and return an AST node, just
    like the recursive descent–based parsing functions, but it will use a different
    strategy to get that result.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we already use recursive descent to parse unary and parenthesized expressions,
    let’s represent those with a separate symbol from binary operations. [Listing
    3-4](chapter3.xhtml#list3-4) shows the resulting grammar, with changes from [Chapter
    2](chapter2.xhtml) bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: The final grammar
    to handle binary operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol we called <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    in [Listing 2-6](chapter2.xhtml#list2-6) is now called <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>;
    it represents a constant, a unary expression, or a parenthesized expression. (We’ll
    keep the name *factor* from [Listing 3-3](chapter3.xhtml#list3-3) because this
    symbol can appear as a factor in a multiplication expression.) We parse a <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> with the usual recursive
    descent approach. It has almost exactly the same definition that <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    did in [Chapter 2](chapter2.xhtml), except that we now allow binary expressions
    as well as factors inside parentheses. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)</samp>
    is a factor, because <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" <exp> ")"</samp>
    is a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>.
    However, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> is not, because <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop>
    <exp></samp> is not a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>.
    An <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> is either a binary
    operation, defined in the obvious way, or a factor. Because the rules for <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    refer to each other, the functions to parse those symbols are mutually recursive.
    Those functions both yield <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST nodes; <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> are distinct symbols in the
    grammar, but not different types in the AST.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudocode to parse factors is shown in [Listing 3-5](chapter3.xhtml#list3-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Parsing a factor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This looks a lot like the previous chapter’s expression parsing code (shown
    in [Listing 2-7](chapter2.xhtml#list2-7)). The only difference is that we call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> where we expect
    a <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    where we expect an <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    ❷; before, we called <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    in both places.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making Operators Left-Associative</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s write the new version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    We’ll start with a simple version of the function that handles only the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    operators, which are at the same precedence level. This simplified <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    needs to group expressions in a left-associative way, but it doesn’t need to handle
    multiple precedence levels yet.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple case, we’ll encounter inputs like <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>.
    These should always be parsed in a left-associative way to produce expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>. As a result,
    the right operand of every expression, including subexpressions, will be a single
    factor. For example, the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>, and
    the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Since the right operand of an expression is always a single factor, we can parse
    these expressions with the pseudocode in [Listing 3-6](chapter3.xhtml#list3-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Parsing left-associative
    expressions without considering precedence level</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by parsing a single factor ❶, which is either the whole expression
    or the left operand of a larger expression. Next, we check whether the following
    token is a binary operator ❷. If it is, we consume it from the input and convert
    it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> AST
    node. Then, we construct a binary expression ❹ where the left operand is everything
    we’ve parsed so far and the right operand is the next factor, which we get by
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> ❸. We
    repeat this process until we see a token other than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> after a factor; this
    means there are no binary expressions left to construct, so we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Precedence</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s extend [Listing 3-6](chapter3.xhtml#list3-6) to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>.
    These operators are also left-associative, but they’re at a higher precedence
    level than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once we add these operators, the right operand of every expression can be either
    a single factor or a subexpression involving only the new higher-precedence operators.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> would be parsed as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. The right operand of the
    whole expression is a single factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
    The right operand of the inner subexpression, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>, is a product, <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if the outermost expression is a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operation, its right
    operand contains only factors and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operations. But if the outermost expression is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operation, its right operand must be single factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generalize: when we parse an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">e1
    <op> e2</samp>, all the operators in <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>
    should have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11"><op></samp>.
    We can achieve this by tweaking the code from [Listing 3-6](chapter3.xhtml#list3-6),
    which gives us [Listing 3-7](chapter3.xhtml#list3-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Parsing left-associative
    expressions with precedence climbing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This pseudocode is our entire precedence climbing algorithm. The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp>
    argument lets us state that all operators in the subexpression we’re currently
    parsing need to exceed some precedence level. For example, we could include only
    operators that have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>.
    We enforce this by comparing the precedence of the current operator to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp>
    at each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop; we exclude the operator and anything that follows it from the current expression
    if its precedence is too low. Then, when we parse the right-hand side of an operation,
    we set the minimum precedence higher than the precedence of the current operator.
    This guarantees that higher-precedence operators will be evaluated first. Since
    operators at the same precedence level as the current operator won’t be included
    in the right-hand expression, the resulting AST will be left-associative.
  prefs: []
  type: TYPE_NORMAL
- en: When you call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    from any other function (including from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse
    _factor</samp>, to handle parenthesized expressions), start with a minimum precedence
    of zero so the result includes operators at every precedence level.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 3-7](chapter3.xhtml#list3-7) requires us to assign every
    binary operator a precedence value. [Table 3-1](chapter3.xhtml#tab3-1) shows the
    values I’ve assigned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The exact precedence values don’t matter, as long as higher-precedence operators
    have higher values. The numbers in [Table 3-1](chapter3.xhtml#tab3-1) give us
    plenty of room to add lower-precedence operators later on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Precedence Climbing
    in Action</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s walk through an example where we parse the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippets trace the execution of the precedence climbing
    code from [Listing 3-7](chapter3.xhtml#list3-7) as it parses this expression.
    We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse _exp</samp>
    on the whole expression with <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    as the minimum precedence argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we parse the first factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    parses the token <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>. Next, we peek
    at the token that follows, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
    This token is a binary operator with a precedence greater than zero, so we enter
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first iteration of the loop looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Inside the loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>
    consumes <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> from
    the input and converts it to an AST node, <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>,
    which leaves <samp class="SANS_TheSansMonoCd_W5Regular_11">2 - 3 * (4</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>.
    Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively
    to get the right-hand side of this product. Since the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    is 50, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">51</samp>. In the recursive call,
    we again get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>)
    and the token that follows it (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is a binary operator,
    but its precedence is only 45; it doesn’t meet the minimum precedence of 51, so
    we don’t enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Instead, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(2)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the outer call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST
    node for <samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp> from the values
    we’ve parsed so far. Then, we check the next token to see whether we have more
    subexpressions to process. The next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>;
    we peeked at it, but didn’t remove it from the input, inside the recursive call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> is a binary operator, and it
    exceeds our minimum precedence of zero, we jump back to the beginning of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to parse the next subexpression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second time through the loop, we consume <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    from the input and make a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    This time, because the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    is 45, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">46</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Following our usual routine, we get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>)
    and the next token (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>). Since
    the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> exceeds
    the minimum precedence, we need to parse another subexpression. We consume <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, leaving <samp class="SANS_TheSansMonoCd_W5Regular_11">(4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>,
    then make yet another recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In this call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    as usual. This call consumes the rest of our input and returns the AST node for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. To handle that parenthesized
    expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    needs to recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    with the minimum precedence reset to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    but we won’t step through that here. At this point, there are no tokens left in
    our expression. Let’s assume this is a valid C program and the next token is a
    semicolon (<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>). Since the
    next token isn’t a binary operator, we exit the loop and return the expression
    we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: At the next level up, we construct the AST node for <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>
    from the subexpressions we’ve processed in this call. Once again, we peek at the
    next token, see that it isn’t a binary operator, and return.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, back in the original call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we construct the final expression from the left operand that we constructed in
    the first loop iteration (<samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp>),
    the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>), and the right operand
    that was just returned from the recursive call (<samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>).
    For the last time, we check the next token, see that it isn’t a binary operator,
    and return.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to parse binary expressions with precedence climbing,
    you’re ready to extend your parser. Remember to use precedence climbing to parse
    binary expressions and recursive descent to parse all the other symbols in the
    grammar, including factors.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s update the stage that converts the AST to TACKY. We’ll start by
    adding binary operations to TACKY. [Listing 3-8](chapter3.xhtml#list3-8) defines
    the updated TACKY IR, with this chapter’s additions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Adding binary
    operations to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction to represent binary operations, and we’ve defined all the possible
    operators. Like unary operations, binary operations in TACKY operate on constants
    and variables, not nested subexpressions. As [Listing 3-9](chapter3.xhtml#list3-9)
    illustrates, we can turn a binary expression into a sequence of TACKY instructions
    in basically the same way we handled unary expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: Converting a binary
    expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We emit the TACKY instructions to evaluate each operand, then emit the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction that uses those
    source values. The only difference from how we handled unary expressions is that
    we’re processing two operands instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to assembly generation, I want to make a slightly tangential
    point. The TACKY we emit in [Listing 3-9](chapter3.xhtml#list3-9) evaluates a
    binary expression’s first operand before the second, but it’s just as correct
    to evaluate the second operand before the first. According to the C standard,
    subexpressions of the same operation are usually *unsequenced*; that is, they
    can be evaluated in any order. If two subexpressions would be unsequenced, but
    either or both of them is a function call, they’re *indeterminately sequenced*,
    meaning that either one can execute first, but they can’t interleave. In many
    cases, unsequenced and indeterminately sequenced evaluations can lead to unpredictable
    results. Consider the following program, which includes two indeterminately sequenced
    calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You could compile this program with a C standard–compliant compiler, run it,
    and get either of these outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few exceptions where we must evaluate the first operand first:
    the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators, which we’ll cover
    in [Chapter 4](chapter4.xhtml); the conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>
    operator, which we’ll cover in [Chapter 6](chapter6.xhtml); and the comma operator,
    which we won’t implement. For a more in-depth discussion of the order in which
    expressions are evaluated, see the “Order of Evaluation” page on cppreference.com,
    the C/C++ reference wiki (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/eval<wbr>_order](https://en.cppreference.com/w/c/language/eval_order)*).
    If you’re curious about where all this is laid out in the C standard itself, see
    section 5.1.2.3 (which covers the general rules for evaluation order and defines
    the terms *unsequenced* and *indeterminately sequenced*) and section 6.5, paragraphs
    1–3 (which address the evaluation order for expression operands in particular).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsequenced operations are one example of a broader pattern: there are a lot
    of circumstances where the C standard doesn’t specify exactly how programs should
    behave. We’ll see more examples of this throughout the book. By leaving some details
    about program behavior unspecified, the C standard puts a lot of power in the
    hands of compiler writers, allowing them to write sophisticated compiler optimizations.
    But there’s an obvious trade-off: it’s easy for programmers to write code that
    might not behave the way they expect.  ### <samp class="SANS_Futura_Std_Bold_B_11">Assembly
    Generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is converting TACKY into assembly. We’ll need several new assembly
    instructions to handle addition, subtraction, multiplication, division, and the
    remainder operation. Let’s talk through how to use these instructions; then we’ll
    make the necessary updates to each pass in the assembly generation stage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic
    in Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The instructions for addition, subtraction, and multiplication all take the
    form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>,
    where:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">op</samp> is an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">src</samp> is an immediate
    value, register, or memory address.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">dst</samp> is a register
    or memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these instructions applies <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp>, storing the result
    in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>. The instructions
    for addition, subtraction, and multiplication are <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>,
    respectively. As usual, these instructions take an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    suffix if their operands are 32 bits and a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    suffix if their operands are 64 bits. [Table 3-2](chapter3.xhtml#tab3-2) shows
    an example of each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Assembly
    Instructions for Addition, Subtraction, and Multiplication</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">addl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax + 2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">subl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax - 2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">imull {@}$2, %eax</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax * 2</samp> |'
  prefs: []
  type: TYPE_TB
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>
    is the *first* operand in the corresponding mathematical expression, so <samp
    class="SANS_TheSansMonoCd_W5Regular_11">subl a, b</samp> computes <samp class="SANS_TheSansMonoCd_W5Regular_11">b
    - a</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions are pretty easy to use and understand. If we lived in a perfect
    world, we could perform division in exactly the same way. But we don’t, so we’re
    stuck with the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> to implement
    the division and remainder operations. Even though you need two numbers to perform
    division, it takes a single operand: the divisor. (In <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is the dividend
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is the divisor.) This
    operand can’t be an immediate value. In its 32-bit form, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    gets the other value it needs, the dividend, from the EDX and EAX registers, which
    it treats as a single 64-bit value. It gets the most significant 32 bits from
    EDX and the least significant 32 bits from EAX. Unlike the other arithmetic instructions,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> produces two results:
    the quotient and the remainder. It stores the quotient in EAX and the remainder
    in EDX. (The 64-bit version of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>,
    written as <samp class="SANS_TheSansMonoCd_W5Regular_11">idivq</samp>, uses RDX
    and RAX as the dividend instead of EDX and EAX.)'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, we need to take <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>—which will be either a 32-bit
    immediate value or a 32-bit value stored in memory—and turn it into a 64-bit value
    spanning both EDX and EAX. Whenever we need to convert a signed integer to a wider
    format, we use an operation called *sign extension*. This operation fills the
    upper 32 bits of the new 64-bit value with the sign bit of the original 32-bit
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Sign extending a positive number just pads the upper 32 bits (4 bytes) with
    zeros. Sign extending the binary representation of 3, for example, turns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both representations have the value 3; the second one just has more leading
    zeros. To sign extend a negative number, we fill the upper 4 bytes with ones.
    This transforms the binary representation of –3, for example, from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the magic of two’s complement, the value of both of these binary numbers
    is –3\. (If you’re not clear on how this works, check out [Chapter 2](chapter2.xhtml)’s
    “Additional Resources” section on [page 45](chapter2.xhtml#pg_45).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction does
    exactly what we want: it sign extends the value from EAX into EDX. If the number
    in EAX is positive, this instruction sets EDX to all zeros. If EAX is negative,
    it sets EDX to all ones. Putting it all together, as an example, the following
    assembly computes both <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">9 % 2</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9 /
    2</samp>, the quotient, in EAX. It stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9
    % 2</samp>, the remainder, in EDX.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve covered all the new instructions we’ll need in this chapter: <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>.
    Next, we’ll add these instructions to the assembly AST and update the conversion
    from TACKY to assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Binary
    Operations to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 3-10](chapter3.xhtml#list3-10) defines the updated assembly AST, with
    this chapter’s additions bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: The assembly
    AST with binary operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since the addition, subtraction, and multiplication instructions take the same
    form, we’ll represent all of them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp>
    node. We’ll also add constructors for the new <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instructions. Finally,
    we’ll add the EDX and R11 registers to the AST definition; we need EDX for division
    and R11 for the instruction fix-up pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to convert the new binary operations from TACKY to assembly. For
    addition, subtraction, and multiplication, we convert a single TACKY instruction
    into two assembly instructions. That is, we convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Division is a little more complicated; we move the first operand into EAX, sign
    extend it with <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, issue
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, and
    then move the result from EAX to the destination. So, we convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The remainder operation looks exactly the same, except that we ultimately want
    to retrieve the remainder from EDX instead of retrieving the quotient from EAX.
    We therefore convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction can’t
    operate on immediate values, so the assembly instructions for division and remainder
    won’t be valid if <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> is
    a constant. That’s okay; we’ll fix this problem during the instruction fix-up
    pass. [Tables 3-3](chapter3.xhtml#tab3-3) through [3-6](chapter3.xhtml#tab3-6)
    summarize the conversion from TACKY to assembly, with new and changed constructs
    bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator,
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Divide, src1, src2, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX)) Cdq'
  prefs: []
  type: TYPE_NORMAL
- en: Idiv(src2)
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Reg(AX), dst)</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX))
    Cdq'
  prefs: []
  type: TYPE_NORMAL
- en: Idiv(src2)
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Reg(DX), dst)</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src1,
    src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, dst)
    Binary(binary_operator, src2, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Subtract</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Multiply</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Note that [Table 3-4](chapter3.xhtml#tab3-4) includes three rows for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> TACKY instruction: one for
    division, one for the remainder operation, and one for everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Update this pass to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instructions. You
    should treat them like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions. When
    you see a pseudoregister in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instruction, replace
    it with the corresponding stack address. If the pseudoregister hasn’t been assigned
    to a stack address yet, assign it to the next available 4-byte address.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the idiv,
    add, sub, and imul Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the last compiler pass before emitting the final program, we rewrite any
    invalid instructions that we produced in earlier stages. We need to add a few
    more rewrite rules here. First, we need to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instructions that take constant operands. Whenever <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    needs to operate on a constant, we copy that constant into our scratch register
    first. For instance, we rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instructions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, can’t
    use memory addresses as both the source and destination operands. We rewrite them
    in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, so
    that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instruction can’t
    use a memory address as its destination, regardless of its source operand. To
    fix an instruction’s destination operand, we use the R11 register instead of R10\.
    So, to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, we load
    the destination into R11, multiply it by the source operand, and then store the
    result back to the destination address. In other words, the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using different registers to fix source and destination operands will become
    helpful in [Part II](part2.xhtml), when we’ll sometimes rewrite the source and
    destination of the same instruction. We’ll need two registers so that the fix-up
    instructions for the different operands don’t clobber each other.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated the assembly generation, pseudoregister replacement, and
    instruction fix-up compiler passes, your compiler should be able to generate complete,
    correct assembly programs that perform basic arithmetic. All that’s left is emitting
    those assembly programs in the right format.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step is extending the code emission stage to handle our new assembly
    instructions. [Tables 3-7](chapter3.xhtml#tab3-7) through [3-10](chapter3.xhtml#tab3-10)
    show how to print out each construct, with new constructs bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, operand)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src,
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Idiv(operand)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cdq</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">addl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">subl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">imull</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DX)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R11)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rbp)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  prefs: []
  type: TYPE_TB
- en: The new instructions operate on 32-bit values, so they get <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    suffixes (except <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, which
    doesn’t follow the usual naming conventions). Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">subl</samp>
    instruction we use to subtract integers and the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction we use to allocate space on the stack are 32-bit and 64-bit versions
    of the same instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Bitwise Operators</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve learned how to compile binary operators, you can implement the
    bitwise binary operators on your own. These include bitwise AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>),
    OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>), XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>),
    left shift (<samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>), and right
    shift (<samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>). Your compiler
    can handle these much like the operators you just added. You’ll need to look up
    the relative precedence of these operators, and you’ll need to check the documentation
    for the x64 instruction set to see how to use the relevant assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitwise operations are optional; later test cases don’t rely on them. If you
    do implement bitwise operations, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp>
    flag to include the test cases for this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Include this flag when you run the test script in later chapters too, to include
    any test cases for those chapters that use bitwise operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you implemented several binary arithmetic operations in your
    compiler. You used a new technique, precedence climbing, to parse expressions
    that recursive descent parsers don’t handle well. In the next chapter, you’ll
    implement even more unary and binary operations: the logical operators <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>,
    and relational operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>.
    Some of these operators don’t correspond closely to assembly instructions, so
    we’ll break them down into lower-level instructions in TACKY. We’ll also introduce
    conditional assembly instructions, which will be particularly important when we
    implement control-flow statements like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and loops later on.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'These blog posts helped me understand precedence climbing and how it relates
    to similar algorithms that solve the same problem; you might find them helpful
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: “Parsing Expressions by Precedence Climbing” by Eli Bendersky is a solid overview
    of the precedence climbing algorithm (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2012<wbr>/08<wbr>/02<wbr>/parsing<wbr>-expressions<wbr>-by<wbr>-precedence<wbr>-climbing](https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing)*).
    The precedence climbing code in [Listing 3-7](chapter3.xhtml#list3-7) is loosely
    adapted from this blog post; it also inspired the presentation of the example
    in “Precedence Climbing in Action” on [page 55](#pg_55).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Some Problems of Recursive Descent Parsers,” also by Eli Bendersky, talks about
    how to handle binary expressions with a pure recursive descent parser (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2009<wbr>/03<wbr>/14<wbr>/some<wbr>-problems<wbr>-of<wbr>-recursive<wbr>-descent<wbr>-parsers](https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Andy Chu has written two useful blog posts on precedence climbing. The first,
    “Pratt Parsing and Precedence Climbing Are the Same Algorithm,” explores the fundamental
    similarities between precedence climbing and the Pratt Parsing algorithm (*[https://<wbr>www<wbr>.oilshell<wbr>.org<wbr>/blog<wbr>/2016<wbr>/11<wbr>/01<wbr>.html](https://www.oilshell.org/blog/2016/11/01.html)*).
    The second, “Precedence Climbing Is Widely Used,” discusses their differences
    (*[https://<wbr>www<wbr>.oilshell<wbr>.org<wbr>/blog<wbr>/2017<wbr>/03<wbr>/30<wbr>.html](https://www.oilshell.org/blog/2017/03/30.html)*).
    These posts clarify some of the confusing terminology around different parsing
    algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
