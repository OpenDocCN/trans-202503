- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 LOG MONITORING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 日志监控
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: If you’ve spent time poking around macOS, you may have encountered the system’s
    unified logging mechanism, a resource that can help you understand macOS internals
    and, as you’ll soon see, uncover malware. In this chapter, I’ll start by highlighting
    the various kinds of information that can be extracted from these logs to detect
    malicious activity. We’ll then reverse engineer the macOS log utility and one
    of its core private frameworks so we can programmatically ingest real-time information
    directly and efficiently from the logging subsystem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾花时间研究macOS，你可能遇到过系统的统一日志机制，这是一种帮助你了解macOS内部结构的资源，并且正如你将很快看到的，它也可以帮助揭示恶意软件。在本章中，我将首先强调可以从这些日志中提取的各种信息，用以检测恶意活动。接着，我们将逆向工程macOS日志工具和其核心私有框架之一，以便我们能够以编程方式高效地直接从日志子系统中获取实时信息。
- en: '### Exploring Log Information'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 探索日志信息'
- en: 'I’ll begin by covering a few examples of useful activity that can show up in
    the system log, starting with webcam access. Especially insidious malware specimens,
    including FruitFly, Mokes, and Crisis, surreptitiously spy on their victims through
    the infected host’s webcam. Accessing the webcam generates system log messages,
    however. For example, depending on the version of macOS, the Core Media I/O subsystem
    may produce the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先介绍一些有用的活动示例，这些活动可能出现在系统日志中，从摄像头访问开始。尤其是那些狡猾的恶意软件样本，包括FruitFly、Mokes和Crisis，它们通过感染的主机摄像头悄悄地监视受害者。然而，访问摄像头会生成系统日志消息。例如，根据macOS的版本，Core
    Media I/O子系统可能会生成如下信息：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The bolded value contains the ID of the process accessing the webcam. Although
    the process could be legitimate, such as a Zoom or FaceTime session launched by
    the user for a virtual meeting, it’s prudent to confirm that this is the case,
    as the responsible process could also be malware attempting to spy on the user.
    Because Apple doesn’t provide an API that identifies the process accessing the
    webcam, log messages are one of the only ways to reliably get this information
    most of the time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体值包含了访问摄像头的进程ID。虽然这个进程可能是合法的，例如用户发起的Zoom或FaceTime会议，但为了谨慎起见，最好确认这一点，因为该进程也可能是恶意软件，试图监视用户。因为苹果并未提供一个API来标识访问摄像头的进程，所以日志消息通常是获取该信息的唯一可靠方式。
- en: Other activities that often show up in system logs are remote logins, which
    could indicate a compromise, such as attackers gaining initial access to a host
    or even returning to a previously infected one. For example, the IPStorm malware
    spreads to victims by brute-forcing SSH logins.^([1](#chapter6-1)) Another interesting
    case is XCSSET, which locally initiates a seemingly remote connection back to
    the host to bypass the macOS security mechanism known as Transparency, Consent,
    and Control (TCC).^([2](#chapter6-2))
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其他经常出现在系统日志中的活动是远程登录，这可能表明系统被攻破，例如攻击者通过SSH登录首次访问主机，或者甚至是回到先前被感染的主机。例如，IPStorm恶意软件通过暴力破解SSH登录传播给受害者。^([1](#chapter6-1))
    另一个有趣的案例是XCSSET，它通过本地发起一个看似是远程连接的行为，绕过macOS的透明性、同意和控制（TCC）安全机制。^([2](#chapter6-2))
- en: 'When a remote login occurs via SSH, the system generates log messages such
    as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过SSH进行远程登录时，系统会生成如下日志消息：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These log messages provide the source IP address of the connection, as well
    as the identity of the user who logged in. This information can help defenders
    determine whether the SSH session is legitimate (perhaps a remote worker connecting
    to their office machine) or unauthorized.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志消息提供了连接的源IP地址，以及登录用户的身份。这些信息可以帮助防御者判断SSH会话是否合法（例如，远程工作者连接到其办公室机器）还是未经授权的。
- en: Log messages can also provide insight into the TCC mechanism, which governs
    access to sensitive information and hardware features. In an Objective by the
    Sea conference talk, “The Clock Is TCCing,” researchers Calum Hall and Luke Roberts
    noted that messages found in the unified log enabled them to determine several
    pieces of information for a given TCC event (for example, malware attempting to
    capture the screen or access a user’s documents), including the resource for which
    the process requested access, the responsible and target processes, and whether
    the system denied or approved the request and why.^([3](#chapter6-3))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息还可以提供有关TCC机制的洞见，TCC机制控制着对敏感信息和硬件功能的访问。在一次“海边的目标”会议上，研究人员Calum Hall和Luke
    Roberts指出，他们通过统一日志中的消息，能够确定与某个TCC事件相关的几项信息（例如，恶意软件试图捕获屏幕或访问用户文档），包括进程请求访问的资源、负责和目标进程，以及系统是否拒绝或批准该请求及其原因。^([3](#chapter6-3))
- en: 'At this point, it may be tempting to treat log messages as a panacea for malware
    detection. Don’t. Apple doesn’t officially support log messages and has often
    changed their contents or removed them altogether, even between minor releases
    of macOS. For example, on older versions of the operating system, you could detect
    microphone access and identify the process responsible for it by looking for the
    following log message:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，可能会产生将日志消息视为恶意软件检测的灵丹妙药的冲动。但不要这样做。苹果并不正式支持日志消息，且经常会改变其内容或将其完全移除，甚至在macOS的小版本更新之间。例如，在旧版本的操作系统中，你可以通过查看以下日志消息来检测麦克风访问并识别负责的进程：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, Apple updated the relevant macOS framework so it no longer produces
    the message. If your security tool relied solely on this indicator to detect unauthorized
    microphone access, it would no longer function. Thus, it’s best to treat log messages
    as initial signs of suspicious behavior, then investigate further.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，苹果更新了相关的macOS框架，导致不再生成此类消息。如果你的安全工具仅依赖此指示器来检测未经授权的麦克风访问，它将不再起作用。因此，最好将日志消息视为可疑行为的初步迹象，然后进行进一步调查。
- en: The Unified Logging Subsystem
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一日志子系统
- en: We often think of log messages as a way to figure out what happened in the past.
    But macOS also lets you subscribe to the stream of messages as they’re delivered
    to the logging subsystem in essentially real time. Better yet, the logging subsystem
    supports the filtering of these messages via custom predicates, providing efficient
    and unparalleled insight into the activity happening on the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常认为日志消息是用来弄清楚过去发生了什么。但macOS还允许你订阅消息流，以便几乎实时地将它们送入日志子系统。更妙的是，日志子系统支持通过自定义谓词过滤这些消息，从而提供对系统活动的高效且无与伦比的洞察。
- en: In versions of macOS beginning with 10.12, this logging mechanism is called
    the *unified logging system*.^([4](#chapter6-4)) A replacement of the traditional
    syslog interface, it records messages from core system daemons, operating system
    components, and any third-party software that generates logging messages via the
    OSLog APIs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从macOS 10.12开始，这种日志机制被称为*统一日志系统*。^([4](#chapter6-4)) 它取代了传统的syslog接口，记录来自核心系统守护进程、操作系统组件和任何通过OSLog
    API生成日志消息的第三方软件的消息。
- en: It’s worth noting that if you examine log messages in the unified system log,
    you may encounter redactions; the logging subsystem replaces any information deemed
    sensitive with the string <private>. To disable this functionality, you could
    install a configuration profile.^([5](#chapter6-5)) While useful for understanding
    undocumented features of the operating system, however, you shouldn’t disable
    log redactions on end-user or production systems, which would make sensitive data
    available to anybody with access to the log.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你检查统一系统日志中的日志消息，可能会遇到部分内容被编辑；日志子系统会将任何被认为敏感的信息替换为字符串<private>。要禁用此功能，你可以安装一个配置文件。^([5](#chapter6-5))
    尽管这种功能有助于理解操作系统中未记录的特性，但你不应在终端用户或生产系统中禁用日志编辑，因为这会使敏感数据对任何能够访问日志的人开放。
- en: '#### Manually Querying the log Utility'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 手动查询日志工具'
- en: 'To manually interface with the logging subsystem, use the macOS log utility
    found in */usr/bin*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 若要手动与日志子系统交互，可以使用位于*/usr/bin*中的macOS日志工具：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can search previously logged data with the show flag or use the stream flag
    to view logging data as it’s generated in real time. Unless you specify otherwise,
    the output will include messages with a default log level only. To override this
    setting for past data, use the --info or --debug flag, along with show, to view
    further information and debug messages, respectively. For streaming data, specify
    both stream and --level, then either info or debug. These flags are hierarchical;
    specifying the debug level will return informational and default messages too.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `show` 标志搜索以前记录的数据，或使用 `stream` 标志查看实时生成的日志数据。除非另行指定，否则输出将仅包括默认日志级别的消息。要覆盖过去数据的此设置，可以使用
    --info 或 --debug 标志，并配合 `show` 查看更多信息或调试消息。对于流式数据，指定 `stream` 和 --level，然后选择 info
    或 debug。这些标志是层级关系的；指定调试级别时，也会返回信息性和默认消息。
- en: 'Use the --predicate flag with a predicate to filter the output. A rather extensive
    list of valid predicate fields allows you to find messages based on the process,
    subsystem, type, and much more. For example, to stream log messages from the kernel,
    execute the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 --predicate 标志和谓词来过滤输出。一个相当广泛的有效谓词字段列表使你能够根据进程、子系统、类型等多种条件查找日志消息。例如，要从内核流式传输日志消息，请执行以下命令：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is often more than one way to craft a predicate. For instance, we could
    also receive kernel messages by using 'processIdentifier == 0', as the kernel
    always has a process ID of 0.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有不止一种方式来构造谓词。例如，我们也可以通过使用 'processIdentifier == 0' 来接收内核消息，因为内核的进程 ID 总是 0。
- en: 'To stream messages from the security subsystem, enter the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要从安全子系统流式传输消息，请输入以下命令：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The examples shown here all use the equality operator (==). However, predicates
    can use many other operators, including comparative operators (such as ==, !=,
    and <), logical operators (such as AND and OR), and even membership operators
    (such as BEGINSWITH and CONTAINS). Membership operators are powerful, as they
    allow you to craft filter predicates resembling regular expressions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的示例都使用了相等运算符（==）。然而，谓词可以使用许多其他运算符，包括比较运算符（如 ==、!= 和 <）、逻辑运算符（如 AND 和 OR），甚至是成员运算符（如
    BEGINSWITH 和 CONTAINS）。成员运算符非常强大，因为它们允许你构造类似正则表达式的筛选谓词。
- en: The log man pages and the command log help predicates provide a succinct overview
    of predicates.^([6](#chapter6-6))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 手册页和命令 `log help predicates` 提供了谓词的简洁概述。^([6](#chapter6-6))'
- en: Reverse Engineering log APIs
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逆向工程日志 API
- en: To read log data programmatically, we could use the OSLog APIs.^([7](#chapter6-7))
    These APIs return only historical data, however, and in the context of malware
    detection, we’re much more interested in real-time events. No public API allows
    us to achieve this, but by reverse engineering the log utility (specifically,
    the code that backs the stream command), we can uncover exactly how to ingest
    logging messages as they enter the unified logging subsystem. Moreover, by providing
    a filter predicate, we can receive only messages of interest to us.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式读取日志数据，我们可以使用 OSLog API。^([7](#chapter6-7)) 然而，这些 API 仅返回历史数据，在恶意软件检测的背景下，我们更关心的是实时事件。没有公共
    API 允许我们实现这一点，但通过逆向工程日志工具（特别是支持 stream 命令的代码），我们可以确切地了解如何在日志消息进入统一日志子系统时获取它们。此外，通过提供筛选谓词，我们只会接收对我们有兴趣的消息。
- en: Although I won’t cover the full details of reversing the log utility, I’ll provide
    an overview of the process in this section. Of course, you could apply a similar
    process against other Apple utilities and frameworks to extract private APIs useful
    for malware detection (as we showed in [Chapter 3](chapter3.xhtml) while implementing
    package code signing checks).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不会详细讲解如何逆向日志工具，但在这一部分我将概述整个过程。当然，你也可以对其他苹果工具和框架应用类似的过程，以提取对恶意软件检测有用的私有 API（正如我们在[第
    3 章](chapter3.xhtml)中实现软件包代码签名检查时所展示的）。
- en: 'First, we need to find the binary that implements the logging subsystem’s APIs
    so we can invoke them from our own code. Normally, we’ll find such APIs in a framework
    that is dynamically linked into the utility’s binary. By executing otool with
    the -L command line option, we can view the frameworks against which the log utility
    is dynamically linked:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到实现日志子系统 API 的二进制文件，以便我们能够从自己的代码中调用它们。通常，我们会在一个动态链接到工具二进制文件的框架中找到这些
    API。通过执行 `otool -L` 命令行选项，我们可以查看日志工具动态链接的框架：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Based on its name, the *LoggingSupport* framework seems likely to contain relevant
    logging APIs. In past versions of macOS, you could find the framework in the */System/Library/PrivateFrameworks/*
    directory, while in newer versions, you’ll find it in the shared *dyld* cache.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其名称，*LoggingSupport* 框架似乎很可能包含相关的日志 API。在过去的 macOS 版本中，你可以在 */System/Library/PrivateFrameworks/*
    目录中找到该框架，而在较新的版本中，你会在共享的 *dyld* 缓存中找到它。
- en: 'After loading the framework into Hopper (which can directly load frameworks
    from the *dyld* cache), we find that the framework implements an undocumented
    class named OSLogEventLiveStream whose base class is OSLogEventStreamBase. These
    classes implement methods such as activate, setEventHandler:, and setFilterPredicate:.
    We also encounter an undocumented OSLogEventProxy class that appears to represent
    log events. Here are some of its properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '将框架加载到 Hopper 中后（Hopper 可以直接从 *dyld* 缓存加载框架），我们发现该框架实现了一个名为 OSLogEventLiveStream
    的未记录类，其基类是 OSLogEventStreamBase。 这些类实现了诸如 activate、setEventHandler: 和 setFilterPredicate:
    等方法。我们还遇到一个未记录的 OSLogEventProxy 类，似乎代表了日志事件。以下是它的一些属性：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By examining the log utility, we can see how it uses these classes and their
    methods to capture streaming log data. For example, here is a decompiled snippet
    from the log binary:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查日志工具，我们可以看到它如何使用这些类及其方法来捕获流式日志数据。例如，这是从日志二进制文件反编译得到的一个片段：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the decompilation, we first see a call to initWithLiveSource: initializing
    an OSLogEventLiveStream object. Calls to methods such as setEventHandler: and
    setFilterPredicate: then configure this object, stored in the r21 register. After
    the predicate is set, a helpful debug message indicates that a provided predicate
    can filter log data. Finally, the object activates, which triggers the ingestion
    of streaming log messages matching the specified predicate.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '在反编译中，我们首先看到调用 initWithLiveSource: 初始化一个 OSLogEventLiveStream 对象。接着调用 setEventHandler:
    和 setFilterPredicate: 等方法来配置该对象，存储在 r21 寄存器中。设置完谓词后，一条有用的调试信息表明，提供的谓词可以过滤日志数据。最后，该对象激活，触发了符合指定谓词的流式日志消息的接收。'
- en: Streaming Log Data
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式日志数据
- en: Using the information we gleaned by reverse engineering the log binary and *LoggingSupport*
    framework, we can craft code to directly stream data from the universal logging
    subsystem in our detection tools. Here, we’ll cover important parts of the code,
    though you’re encouraged to consult the full code, found in this chapter’s *logStream*
    project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逆向工程日志二进制文件和 *LoggingSupport* 框架，我们获得的信息，可以帮助我们编写代码直接从通用日志子系统中流式传输数据到我们的检测工具。在这里，我们将介绍代码的关键部分，尽管建议你查阅本章的完整代码，位于
    *logStream* 项目中。
- en: '[Listing 6-1](chapter6.xhtml#Lis6-1) shows a method that accepts a log filter
    predicate, a log level (such as default, info, or debug), and a callback function
    to invoke for each logging event that matches the specified predicate.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-1](chapter6.xhtml#Lis6-1) 显示了一个方法，该方法接受一个日志过滤谓词、一个日志级别（如默认、信息或调试），以及一个回调函数，用于对每个符合指定谓词的日志事件进行调用。'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-1: Starting a logging stream with a specified predicate'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-1：使用指定谓词启动日志流
- en: Note that I’ve omitted part of this code, such as the class definition and properties
    of the custom log class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经省略了这部分代码，如自定义日志类的类定义和属性。
- en: 'After loading the logging support framework ❶, the code retrieves the private
    OSLogEventLiveStream class by name ❷. Now we can instantiate an instance of the
    class ❸. We then configure this instance by setting the filter predicate ❹, making
    sure to wrap it in a try...catch block, as the setFilterPredicate: method can
    throw an exception if provided with an invalid predicate. Next, we set the event
    handler, which the framework will invoke anytime the universal logging subsystem
    ingests a log message matching the specified predicate ❺. We pass these values
    into the start:level:eventHandler: method, where the predicate tells the log stream
    how to filter the messages it delivers to the event handler. We set the logging
    level via the setFlags: method ❻. Finally, we start the stream with a call to
    the activate method ❼.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '加载日志支持框架 ❶ 后，代码通过名称检索私有的 OSLogEventLiveStream 类 ❷。现在我们可以实例化该类的一个实例 ❸。然后，我们通过设置过滤谓词
    ❹ 来配置这个实例，确保将其包装在 try...catch 块中，因为如果提供无效的谓词，setFilterPredicate: 方法可能会抛出异常。接下来，我们设置事件处理程序，框架将在每次通用日志子系统接收符合指定谓词的日志消息时调用该处理程序
    ❺。我们将这些值传递给 start:level:eventHandler: 方法，其中谓词告诉日志流如何过滤它传递给事件处理程序的消息。我们通过 setFlags:
    方法设置日志级别 ❻。最后，我们通过调用 activate 方法启动流 ❼。'
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows how to create an instance of the
    custom log monitor class and then use it to begin ingesting log messages.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-2](chapter6.xhtml#Lis6-2) 展示了如何创建自定义日志监视类的实例，并使用它开始接收日志消息。'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-2: Interfacing with the custom log stream class'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：与自定义日志流类进行交互
- en: 'First, the code creates a predicate object from a string ❶. Note that in production
    code, you should also wrap this action in a try...catch block, as the predicateWithFormat:
    method throws a catchable exception if the provided predicate is invalid. Next,
    we create a LogMonitor object and invoke its start:level:eventHandler: method
    ❷. Note that for the level, we pass in Log_Level_Debug. Since the level is hierarchal,
    this will ensure we capture all message types, including those whose type is info
    and default. Now the code will invoke our event handler anytime a log message
    matching the specified predicate streams to the universal logging subsystem. Currently,
    this handler simply prints out the OSLogEventProxy object.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，代码从一个字符串 ❶ 创建一个谓词对象。请注意，在生产代码中，你还应该将此操作包装在 try...catch 块中，因为如果提供的谓词无效，predicateWithFormat:
    方法会抛出一个可捕获的异常。接下来，我们创建一个 LogMonitor 对象并调用它的 start:level:eventHandler: 方法 ❷。请注意，对于级别，我们传入
    Log_Level_Debug。由于级别是分层的，这将确保我们捕获所有类型的消息，包括那些类型为 info 和 default 的消息。现在，每当一个与指定谓词匹配的日志消息流向通用日志子系统时，代码将调用我们的事件处理程序。当前，这个处理程序仅打印出
    OSLogEventProxy 对象。'
- en: To compile this code, we’ll need the undocumented class and method definitions
    we extracted from the *LoggingSupport* framework. These definitions live in the
    *logStream* project’s *LogStream.h* file; [Listing 6-3](chapter6.xhtml#Lis6-3)
    provides a snippet of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们需要从 *LoggingSupport* 框架中提取的未文档化类和方法定义。这些定义位于 *logStream* 项目的 *LogStream.h*
    文件中；[清单 6-3](chapter6.xhtml#Lis6-3) 提供了它们的一部分。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-3: The interface for the private OSLogEventLiveStream and OSLogEventProxy
    classes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：私有的 OSLogEventLiveStream 和 OSLogEventProxy 类的接口
- en: 'Once we compile this code, we can execute it with a user-specified predicate.
    For example, let’s monitor the log messages of the security subsystem, *com.apple.securityd*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了这段代码，就可以使用用户指定的谓词来执行它。例如，让我们监视安全子系统的日志消息，*com.apple.securityd*：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although we’re indeed capturing streaming log messages that match the specified
    predicate, the messages don’t appear all that useful at first glance. This is
    because our event handler simply prints out the OSLogEventProxy object via a call
    to its description method, which doesn’t include all components of the message.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确实正在捕获与指定谓词匹配的流式日志消息，但初看这些消息似乎并不那么有用。这是因为我们的事件处理程序仅通过调用其 `description` 方法打印出
    OSLogEventProxy 对象，而该方法并不包含消息的所有组成部分。
- en: Extracting Log Object Properties
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取日志对象的属性
- en: To detect activity that could indicate the presence of malware, you’ll want
    to extract the OSLogEventProxy log method object’s properties. While disassembling,
    we encountered several useful properties, such as the process ID, path, and message,
    but other interesting ones exist as well. Because Objective-C is introspective,
    you can dynamically query any object, including undocumented ones, to reveal its
    properties and values. This requires a foray into the bowels of the Objective-C
    runtime; nevertheless, you’ll find it useful to understand any undocumented classes
    you encounter, especially when leveraging Apple’s private frameworks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测可能表明恶意软件存在的活动，你需要提取 OSLogEventProxy 日志方法对象的属性。在反汇编过程中，我们遇到了几个有用的属性，如进程 ID、路径和消息，但还有其他有趣的属性。由于
    Objective-C 是反射性的，你可以动态查询任何对象，包括未文档化的对象，来揭示其属性和值。这需要深入 Objective-C 运行时的内部；尽管如此，你会发现理解你遇到的任何未文档化类是非常有用的，特别是在利用
    Apple 的私有框架时。
- en: '[Listing 6-4](chapter6.xhtml#Lis6-4) is a simple function that accepts any
    Objective-C object, then prints out its properties and their values. It’s based
    on code by Pat Zearfoss.^([8](#chapter6-8))'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-4](chapter6.xhtml#Lis6-4) 是一个简单的函数，它接受任何 Objective-C 对象，然后打印出其属性及其值。它基于
    Pat Zearfoss 的代码。^([8](#chapter6-8))'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-4: Introspecting the properties of an Objective-C object'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：检查一个 Objective-C 对象的属性
- en: First, the code imports the required Objective-C runtime header files ❶. Then
    it invokes the class_copyPropertyList API to get an array and the count of the
    object’s properties ❷. We iterate over this array to examine each property, invoking
    the property_getName method to get the name of the property ❸. Then the sel_registerName
    function retrieves a selector for the property ❹. We’ll use the property selector
    later to retrieve the object’s value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码导入所需的Objective-C运行时头文件 ❶。然后，它调用class_copyPropertyList API来获取对象属性的数组和数量
    ❷。我们遍历该数组检查每个属性，调用property_getName方法获取属性的名称 ❸。然后，sel_registerName函数为属性检索选择器 ❹。稍后我们将使用属性选择器来检索对象的值。
- en: Next, to determine the type of the property, we invoke the property _getAttributes
    method ❺. This returns an array of attributes, with the property type as the second
    item (at index 1). The code handles common types such as Objective-C objects (@),
    integers (i), and floats (f). For each type, we invoke the objc_msgSend function
    on the object with the property’s selector to retrieve the property’s value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了确定属性的类型，我们调用属性的_getAttributes方法 ❺。这将返回一个属性数组，其中属性类型是第二项（索引为1）。代码处理常见类型，如Objective-C对象（@）、整数（i）和浮点数（f）。对于每种类型，我们在对象上调用objc_msgSend函数，并使用属性的选择器来获取属性的值。
- en: If you look closely, you’ll see that the call to objc_msgSend is typecast appropriately
    for each property type. For a list of type encodings, see Apple’s “Type Encodings”
    developer documentation.^([9](#chapter6-9)) To inspect Swift objects, use Swift’s
    Mirror API.^([10](#chapter6-10))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察，你会看到调用objc_msgSend时，对于每种属性类型，都会适当地进行类型转换。有关类型编码的列表，请参见Apple的“类型编码”开发者文档。^([9](#chapter6-9))
    若要检查Swift对象，请使用Swift的Mirror API。^([10](#chapter6-10))
- en: In the log monitor code, we can now invoke the inspectObject function with each
    OSLogEventProxy object received from the logging subsystem ([Listing 6-5](chapter6.xhtml#Lis6-5)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志监控代码中，我们现在可以使用inspectObject函数，处理从日志子系统接收到的每个OSLogEventProxy对象（[示例6-5](chapter6.xhtml#Lis6-5)）。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-5: Inspecting each log message, encapsulated in an OSLogEventProxy
    object'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-5：检查每条日志消息，封装在OSLogEventProxy对象中
- en: 'If we compile and execute the program, we should now receive a more comprehensive
    view of each log message. For example, by monitoring messages related to XProtect,
    the built-in antimalware scanner found on certain versions of macOS, we can observe
    its scan of an untrusted application:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并执行该程序，应该会收到每条日志消息的更全面视图。例如，通过监控与XProtect相关的消息（这是某些版本macOS上内置的反恶意软件扫描器），我们可以观察它对一个不受信任应用程序的扫描：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The abridged output contains the properties of the OSLogEventProxy object most
    relevant to security tools. [Table 6-1](chapter6.xhtml#tab6-1) summarizes these
    alphabetically. As with many OSLogEventProxy object properties, you can use them
    in custom predicates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 精简输出包含了与安全工具最相关的OSLogEventProxy对象的属性。[表6-1](chapter6.xhtml#tab6-1)按字母顺序总结了这些属性。与许多OSLogEventProxy对象属性一样，你可以在自定义谓词中使用它们。
- en: 'Table 6-1: Security-Relevant OSLogEventProxy Properties'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：与安全相关的OSLogEventProxy属性
- en: '| Property name | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 属性名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| category | The category used to log an event |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| category | 用于记录事件的类别 |'
- en: '| composedMessage | The contents of the log message |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| composedMessage | 日志消息的内容 |'
- en: '| logType | For logEvent and traceEvent, the message’s type (default, info,
    debug, error, or fault) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| logType | 对于logEvent和traceEvent，消息的类型（默认、信息、调试、错误或故障） |'
- en: '| processIdentifier | The process ID of the process that caused the event |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| processIdentifier | 导致事件的进程的进程ID |'
- en: '| processImagePath | The full path of the process that caused the event |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| processImagePath | 导致事件的进程的完整路径 |'
- en: '| senderImagePath | The full path of the library, framework, kernel extension,
    or Mach-O image that caused the event |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| senderImagePath | 导致事件的库、框架、内核扩展或Mach-O镜像的完整路径 |'
- en: '| subsystem | The subsystem used to log an event |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| subsystem | 用于记录事件的子系统 |'
- en: '| type | The type of event (such as activityCreateEvent, activityTransitionEvent,
    or logEvent) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| type | 事件的类型（如activityCreateEvent、activityTransitionEvent或logEvent） |'
- en: Determining Resource Consumption
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定资源消耗
- en: It’s important to consider the potential resource impact of streaming log messages.
    If you take an overly consumptive approach, you can incur a significant CPU cost
    and impact to the responsiveness of the system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑流式日志消息的潜在资源影响非常重要。如果你采取过度消耗的方式，可能会导致显著的CPU开销，并影响系统的响应能力。
- en: First, pay attention to the log level. Specifying the debug level will result
    in a significant increase in the number of log messages processed against any
    predicate. Although the predicate evaluation logic is very efficient, more messages
    mean more CPU cycles. Thus, a security tool that leverages the logging subsystem’s
    streaming capabilities should probably stick to consuming the default or info
    messages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意日志级别。指定调试级别将导致处理的日志消息数量显著增加。尽管谓词评估逻辑非常高效，但更多的消息意味着更多的 CPU 循环。因此，利用日志子系统流式传输功能的安全工具最好还是只消耗默认或信息级别的消息。
- en: Equally important to efficiency is the predicate you use. Interestingly, my
    experiments have shown that the logging daemon wholly evaluates some predicates,
    while the logging subsystem frameworks loaded in client programs, such as the
    log monitor, handle others. The former is better; otherwise, the program will
    receive a copy of every single log message for predicate evaluation, which can
    chew up significant CPU cycles. If the logging daemon performs the predicate evaluation,
    you’ll receive messages that match the predicate only, which won’t discernibly
    impact the system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是你使用的谓词效率。有趣的是，我的实验表明，日志守护进程会完全评估某些谓词，而在客户端程序中加载的日志子系统框架（如日志监视器）会处理其他谓词。前者更好；否则，程序将收到每一条日志消息的副本以进行谓词评估，这可能会占用大量的
    CPU 循环。如果是日志守护进程进行谓词评估，你将只收到匹配谓词的消息，这对系统的影响几乎不可察觉。
- en: How can you craft a predicate that the logging daemon will evaluate? Trial and
    error have shown that if you specify a process or subsystem in a predicate, the
    daemon will evaluate it, meaning you’ll receive only log messages that match.
    Let’s look at a specific example from OverSight, a tool discussed in [Chapter
    12](chapter12.xhtml) that monitors the microphone and webcam.^([11](#chapter6-11))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建一个日志守护进程会评估的谓词？经过反复试验表明，如果你在谓词中指定进程或子系统，守护进程就会评估它，这意味着你只会收到匹配的日志消息。我们来看一个来自
    OverSight 的具体例子，OverSight 是在[第 12 章](chapter12.xhtml)中讨论的一款工具，用于监控麦克风和摄像头。^([11](#chapter6-11))
- en: 'OverSight requires access to log messages from the core media I/O subsystem
    to identify the process accessing the webcam. At the start of the chapter, I noted
    that certain versions of macOS store this process ID in log messages from the
    core media I/O subsystem that contain the string CMIOExtensionPropertyDeviceControlPID.
    Understandably, you might be tempted to craft a predicate that matches this string:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OverSight 需要访问核心媒体 I/O 子系统的日志消息，以识别访问摄像头的进程。在本章开始时，我提到某些版本的 macOS 会将此进程 ID 存储在包含字符串
    CMIOExtensionPropertyDeviceControlPID 的核心媒体 I/O 子系统的日志消息中。可以理解的是，你可能会想创建一个与此字符串匹配的谓词：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This predicate would lead to processing inefficiencies, however, as the logging
    daemon will send all messages that the logging frameworks loaded in our log monitor
    to perform the predicate filtering. Instead, OverSight leverages a broader predicate
    that makes use of the subsystem property:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个谓词会导致处理效率低下，因为日志守护进程将发送所有由我们日志监视器加载的日志框架进行谓词过滤的消息。相反，OverSight 利用一个更广泛的谓词，利用了子系统属性：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This approach causes the logging daemon to perform the predicate matching,
    then deliver only messages from the core media I/O subsystem. OverSight itself
    manually performs the check for the CMIOExtensionPropertyDeviceControlPID string:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使日志守护进程执行谓词匹配，然后只传送来自核心媒体 I/O 子系统的消息。OverSight 本身手动执行对 CMIOExtensionPropertyDeviceControlPID
    字符串的检查：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The tool leverages a similar process to return log messages associated with
    mic access. As a result, it can effectively detect any process (including malware)
    attempting to use either the mic or webcam.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具利用类似的过程返回与麦克风访问相关的日志消息。因此，它能够有效地检测任何尝试使用麦克风或摄像头的进程（包括恶意软件）。
- en: Conclusion
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you saw how to use code to interface with the operating system’s
    universal logging subsystem. By reverse engineering the private *LoggingSupport*
    framework, we programmatically streamed messages matching custom predicates and
    accessed the wealth of data found in the logging subsystem. Security tools could
    use this information to detect new infections or even uncover the malicious actions
    of persistently installed malware.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了如何使用代码与操作系统的通用日志子系统进行交互。通过逆向工程私有的 *LoggingSupport* 框架，我们以编程方式流式传输与自定义谓词匹配的消息，并访问日志子系统中丰富的数据。安全工具可以利用这些信息来检测新的感染，甚至揭示持久性恶意软件的恶意行为。
- en: In the next chapter, you’ll write network monitoring logic using Apple’s powerful
    and well-documented network extensions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用Apple强大且文档完善的网络扩展来编写网络监控逻辑。
- en: Notes
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[  1](#chapter6_1).  Nicole Fishbein and Avigayil Mechtinger, “A Storm Is Brewing:
    IPStorm Now Has Linux Malware,” Intezer, November 14, 2023, [*https://<wbr>www<wbr>.intezer<wbr>.com<wbr>/blog<wbr>/research<wbr>/a<wbr>-storm<wbr>-is<wbr>-brewing<wbr>-ipstorm<wbr>-now<wbr>-has<wbr>-linux<wbr>-malware<wbr>/*](https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/).'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter6_1).  Nicole Fishbein和Avigayil Mechtinger, “风暴即将来临：IPStorm现已拥有Linux恶意软件，”Intezer，2023年11月14日，[*https://<wbr>www<wbr>.intezer<wbr>.com<wbr>/blog<wbr>/research<wbr>/a<wbr>-storm<wbr>-is<wbr>-brewing<wbr>-ipstorm<wbr>-now<wbr>-has<wbr>-linux<wbr>-malware<wbr>/*](https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/).'
- en: '[  2](#chapter6_2).  “The XCSSET Malware,” TrendMicro, August 13, 2020, [*https://<wbr>documents<wbr>.trendmicro<wbr>.com<wbr>/assets<wbr>/pdf<wbr>/XCSSET<wbr>_Technical<wbr>_Brief<wbr>.pdf*](https://documents.trendmicro.com/assets/pdf/XCSSET_Technical_Brief.pdf).
    To read more about the abuse of remote logins in macOS, see Jaron Bradley, “What
    Does APT Activity Look Like on macOS?,” *The Mitten Mac*, November 14, 2021, [*https://<wbr>themittenmac<wbr>.com<wbr>/what<wbr>-does<wbr>-apt<wbr>-activity<wbr>-look<wbr>-like<wbr>-on<wbr>-macos<wbr>/*](https://themittenmac.com/what-does-apt-activity-look-like-on-macos/).'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter6_2).  “XCSSET恶意软件，”TrendMicro，2020年8月13日，[*https://<wbr>documents<wbr>.trendmicro<wbr>.com<wbr>/assets<wbr>/pdf<wbr>/XCSSET<wbr>_Technical<wbr>_Brief<wbr>.pdf*](https://documents.trendmicro.com/assets/pdf/XCSSET_Technical_Brief.pdf)。欲了解更多关于macOS中远程登录滥用的信息，请参见Jaron
    Bradley， “macOS上的APT活动是什么样的？”，“*The Mitten Mac*”，2021年11月14日，[*https://<wbr>themittenmac<wbr>.com<wbr>/what<wbr>-does<wbr>-apt<wbr>-activity<wbr>-look<wbr>-like<wbr>-on<wbr>-macos<wbr>/*](https://themittenmac.com/what-does-apt-activity-look-like-on-macos/).'
- en: '[  3](#chapter6_3).  Calum Hall and Luke Roberts, “The Clock Is TCCing,” paper
    presented at Objective by the Sea v6, Spain, October 12, 2023, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v6<wbr>/talks<wbr>/OBTS<wbr>_v6<wbr>_lRoberts<wbr>_cHall<wbr>.pdf*](https://objectivebythesea.org/v6/talks/OBTS_v6_lRoberts_cHall.pdf).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter6_3).  Calum Hall和Luke Roberts, “时钟正在TCC中，”论文发表于Objective by
    the Sea v6，西班牙，2023年10月12日，[*https://<wbr>objectivebythesea<wbr>.org<wbr>/v6<wbr>/talks<wbr>/OBTS<wbr>_v6<wbr>_lRoberts<wbr>_cHall<wbr>.pdf*](https://objectivebythesea.org/v6/talks/OBTS_v6_lRoberts_cHall.pdf).'
- en: '[  4](#chapter6_4).  “Logging,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/os<wbr>/logging*](https://developer.apple.com/documentation/os/logging).'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter6_4).  “日志记录，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/os<wbr>/logging*](https://developer.apple.com/documentation/os/logging).'
- en: '[  5](#chapter6_5).  Howard Oakley, “How to Reveal ‘Private’ Messages in the
    Log,” Eclectic Light, May 25, 2020, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/05<wbr>/25<wbr>/how<wbr>-to<wbr>-reveal<wbr>-private<wbr>-messages<wbr>-in<wbr>-the<wbr>-log<wbr>/*](https://eclecticlight.co/2020/05/25/how-to-reveal-private-messages-in-the-log/).'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter6_5).  Howard Oakley, “如何在日志中显示‘私密’信息，”Eclectic Light，2020年5月25日，[*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/05<wbr>/25<wbr>/how<wbr>-to<wbr>-reveal<wbr>-private<wbr>-messages<wbr>-in<wbr>-the<wbr>-log<wbr>/*](https://eclecticlight.co/2020/05/25/how-to-reveal-private-messages-in-the-log/).'
- en: '[  6](#chapter6_6).  See Howard Oakley, “log: A Primer on Predicates,” Eclectic
    Light, October 17, 2016, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2016<wbr>/10<wbr>/17<wbr>/log<wbr>-a<wbr>-primer<wbr>-on<wbr>-predicates<wbr>/*](https://eclecticlight.co/2016/10/17/log-a-primer-on-predicates/),
    and “Predicate Programming Guide,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/Predicates<wbr>/AdditionalChapters<wbr>/Introduction<wbr>.html*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Predicates/AdditionalChapters/Introduction.html).'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter6_6).  请参阅Howard Oakley，“日志：谓词简介，”Eclectic Light，2016年10月17日，[*https://<wbr>eclecticlight<wbr>.co<wbr>/2016<wbr>/10<wbr>/17<wbr>/log<wbr>-a<wbr>-primer<wbr>-on<wbr>-predicates<wbr>/*](https://eclecticlight.co/2016/10/17/log-a-primer-on-predicates/)，以及“谓词编程指南，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/Predicates<wbr>/AdditionalChapters<wbr>/Introduction<wbr>.html*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Predicates/AdditionalChapters/Introduction.html).'
- en: '[  7](#chapter6_7).  “OSLog,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/oslog*](https://developer.apple.com/documentation/oslog).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter6_7).  “OSLog，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/oslog*](https://developer.apple.com/documentation/oslog).'
- en: '[  8](#chapter6_8).  Pat Zearfoss, “Objective-C Quickie: Printing All Declared
    Properties of an Object,” April 14, 2011, [*https://<wbr>zearfoss<wbr>.wordpress<wbr>.com<wbr>/2011<wbr>/04<wbr>/14<wbr>/objective<wbr>-c<wbr>-quickie<wbr>-printing<wbr>-all<wbr>-declared<wbr>-properties<wbr>-of<wbr>-an<wbr>-object<wbr>/*](https://zearfoss.wordpress.com/2011/04/14/objective-c-quickie-printing-all-declared-properties-of-an-object/).'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter6_8).  Pat Zearfoss，“Objective-C Quickie: 打印对象的所有声明属性，”2011年4月14日，[*https://<wbr>zearfoss<wbr>.wordpress<wbr>.com<wbr>/2011<wbr>/04<wbr>/14<wbr>/objective<wbr>-c<wbr>-quickie<wbr>-printing<wbr>-all<wbr>-declared<wbr>-properties<wbr>-of<wbr>-an<wbr>-object<wbr>/*](https://zearfoss.wordpress.com/2011/04/14/objective-c-quickie-printing-all-declared-properties-of-an-object/)。'
- en: '[  9](#chapter6_9).  The list is available at [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/ObjCRuntimeGuide<wbr>/Articles<wbr>/ocrtTypeEncodings<wbr>.html#<wbr>/<wbr>/apple<wbr>_ref<wbr>/doc<wbr>/uid<wbr>/TP40008048<wbr>-CH100<wbr>-SW1*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1).'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter6_9).  该列表可在 [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/ObjCRuntimeGuide<wbr>/Articles<wbr>/ocrtTypeEncodings<wbr>.html#<wbr>/<wbr>/apple<wbr>_ref<wbr>/doc<wbr>/uid<wbr>/TP40008048<wbr>-CH100<wbr>-SW1*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)
    查阅。'
- en: '[10](#chapter6_10).  Read more about Swift’s Mirror API in Antoine van der
    Lee, “Reflection in Swift: How Mirror Works,” *SwiftLee*, December 21, 2021, [*https://<wbr>www<wbr>.avanderlee<wbr>.com<wbr>/swift<wbr>/reflection<wbr>-how<wbr>-mirror<wbr>-works<wbr>/*](https://www.avanderlee.com/swift/reflection-how-mirror-works/).'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter6_10).  在Antoine van der Lee的文章“Swift中的反射：Mirror如何工作”中，了解更多关于Swift的Mirror
    API，*SwiftLee*，2021年12月21日，[*https://<wbr>www<wbr>.avanderlee<wbr>.com<wbr>/swift<wbr>/reflection<wbr>-how<wbr>-mirror<wbr>-works<wbr>/*](https://www.avanderlee.com/swift/reflection-how-mirror-works/)。'
- en: '[11](#chapter6_11).  See [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/oversight<wbr>.html*](https://objective-see.org/products/oversight.html).'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter6_11).  请参阅 [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/oversight<wbr>.html*](https://objective-see.org/products/oversight.html)。'
