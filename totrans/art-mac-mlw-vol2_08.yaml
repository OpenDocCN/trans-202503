- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 6 LOG MONITORING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’ve spent time poking around macOS, you may have encountered the system’s
    unified logging mechanism, a resource that can help you understand macOS internals
    and, as you’ll soon see, uncover malware. In this chapter, I’ll start by highlighting
    the various kinds of information that can be extracted from these logs to detect
    malicious activity. We’ll then reverse engineer the macOS log utility and one
    of its core private frameworks so we can programmatically ingest real-time information
    directly and efficiently from the logging subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: '### Exploring Log Information'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll begin by covering a few examples of useful activity that can show up in
    the system log, starting with webcam access. Especially insidious malware specimens,
    including FruitFly, Mokes, and Crisis, surreptitiously spy on their victims through
    the infected host’s webcam. Accessing the webcam generates system log messages,
    however. For example, depending on the version of macOS, the Core Media I/O subsystem
    may produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The bolded value contains the ID of the process accessing the webcam. Although
    the process could be legitimate, such as a Zoom or FaceTime session launched by
    the user for a virtual meeting, it’s prudent to confirm that this is the case,
    as the responsible process could also be malware attempting to spy on the user.
    Because Apple doesn’t provide an API that identifies the process accessing the
    webcam, log messages are one of the only ways to reliably get this information
    most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Other activities that often show up in system logs are remote logins, which
    could indicate a compromise, such as attackers gaining initial access to a host
    or even returning to a previously infected one. For example, the IPStorm malware
    spreads to victims by brute-forcing SSH logins.^([1](#chapter6-1)) Another interesting
    case is XCSSET, which locally initiates a seemingly remote connection back to
    the host to bypass the macOS security mechanism known as Transparency, Consent,
    and Control (TCC).^([2](#chapter6-2))
  prefs: []
  type: TYPE_NORMAL
- en: 'When a remote login occurs via SSH, the system generates log messages such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These log messages provide the source IP address of the connection, as well
    as the identity of the user who logged in. This information can help defenders
    determine whether the SSH session is legitimate (perhaps a remote worker connecting
    to their office machine) or unauthorized.
  prefs: []
  type: TYPE_NORMAL
- en: Log messages can also provide insight into the TCC mechanism, which governs
    access to sensitive information and hardware features. In an Objective by the
    Sea conference talk, “The Clock Is TCCing,” researchers Calum Hall and Luke Roberts
    noted that messages found in the unified log enabled them to determine several
    pieces of information for a given TCC event (for example, malware attempting to
    capture the screen or access a user’s documents), including the resource for which
    the process requested access, the responsible and target processes, and whether
    the system denied or approved the request and why.^([3](#chapter6-3))
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it may be tempting to treat log messages as a panacea for malware
    detection. Don’t. Apple doesn’t officially support log messages and has often
    changed their contents or removed them altogether, even between minor releases
    of macOS. For example, on older versions of the operating system, you could detect
    microphone access and identify the process responsible for it by looking for the
    following log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Apple updated the relevant macOS framework so it no longer produces
    the message. If your security tool relied solely on this indicator to detect unauthorized
    microphone access, it would no longer function. Thus, it’s best to treat log messages
    as initial signs of suspicious behavior, then investigate further.
  prefs: []
  type: TYPE_NORMAL
- en: The Unified Logging Subsystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often think of log messages as a way to figure out what happened in the past.
    But macOS also lets you subscribe to the stream of messages as they’re delivered
    to the logging subsystem in essentially real time. Better yet, the logging subsystem
    supports the filtering of these messages via custom predicates, providing efficient
    and unparalleled insight into the activity happening on the system.
  prefs: []
  type: TYPE_NORMAL
- en: In versions of macOS beginning with 10.12, this logging mechanism is called
    the *unified logging system*.^([4](#chapter6-4)) A replacement of the traditional
    syslog interface, it records messages from core system daemons, operating system
    components, and any third-party software that generates logging messages via the
    OSLog APIs.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that if you examine log messages in the unified system log,
    you may encounter redactions; the logging subsystem replaces any information deemed
    sensitive with the string <private>. To disable this functionality, you could
    install a configuration profile.^([5](#chapter6-5)) While useful for understanding
    undocumented features of the operating system, however, you shouldn’t disable
    log redactions on end-user or production systems, which would make sensitive data
    available to anybody with access to the log.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Manually Querying the log Utility'
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually interface with the logging subsystem, use the macOS log utility
    found in */usr/bin*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can search previously logged data with the show flag or use the stream flag
    to view logging data as it’s generated in real time. Unless you specify otherwise,
    the output will include messages with a default log level only. To override this
    setting for past data, use the --info or --debug flag, along with show, to view
    further information and debug messages, respectively. For streaming data, specify
    both stream and --level, then either info or debug. These flags are hierarchical;
    specifying the debug level will return informational and default messages too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the --predicate flag with a predicate to filter the output. A rather extensive
    list of valid predicate fields allows you to find messages based on the process,
    subsystem, type, and much more. For example, to stream log messages from the kernel,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is often more than one way to craft a predicate. For instance, we could
    also receive kernel messages by using 'processIdentifier == 0', as the kernel
    always has a process ID of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stream messages from the security subsystem, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The examples shown here all use the equality operator (==). However, predicates
    can use many other operators, including comparative operators (such as ==, !=,
    and <), logical operators (such as AND and OR), and even membership operators
    (such as BEGINSWITH and CONTAINS). Membership operators are powerful, as they
    allow you to craft filter predicates resembling regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The log man pages and the command log help predicates provide a succinct overview
    of predicates.^([6](#chapter6-6))
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Engineering log APIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To read log data programmatically, we could use the OSLog APIs.^([7](#chapter6-7))
    These APIs return only historical data, however, and in the context of malware
    detection, we’re much more interested in real-time events. No public API allows
    us to achieve this, but by reverse engineering the log utility (specifically,
    the code that backs the stream command), we can uncover exactly how to ingest
    logging messages as they enter the unified logging subsystem. Moreover, by providing
    a filter predicate, we can receive only messages of interest to us.
  prefs: []
  type: TYPE_NORMAL
- en: Although I won’t cover the full details of reversing the log utility, I’ll provide
    an overview of the process in this section. Of course, you could apply a similar
    process against other Apple utilities and frameworks to extract private APIs useful
    for malware detection (as we showed in [Chapter 3](chapter3.xhtml) while implementing
    package code signing checks).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to find the binary that implements the logging subsystem’s APIs
    so we can invoke them from our own code. Normally, we’ll find such APIs in a framework
    that is dynamically linked into the utility’s binary. By executing otool with
    the -L command line option, we can view the frameworks against which the log utility
    is dynamically linked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Based on its name, the *LoggingSupport* framework seems likely to contain relevant
    logging APIs. In past versions of macOS, you could find the framework in the */System/Library/PrivateFrameworks/*
    directory, while in newer versions, you’ll find it in the shared *dyld* cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the framework into Hopper (which can directly load frameworks
    from the *dyld* cache), we find that the framework implements an undocumented
    class named OSLogEventLiveStream whose base class is OSLogEventStreamBase. These
    classes implement methods such as activate, setEventHandler:, and setFilterPredicate:.
    We also encounter an undocumented OSLogEventProxy class that appears to represent
    log events. Here are some of its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By examining the log utility, we can see how it uses these classes and their
    methods to capture streaming log data. For example, here is a decompiled snippet
    from the log binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the decompilation, we first see a call to initWithLiveSource: initializing
    an OSLogEventLiveStream object. Calls to methods such as setEventHandler: and
    setFilterPredicate: then configure this object, stored in the r21 register. After
    the predicate is set, a helpful debug message indicates that a provided predicate
    can filter log data. Finally, the object activates, which triggers the ingestion
    of streaming log messages matching the specified predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming Log Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the information we gleaned by reverse engineering the log binary and *LoggingSupport*
    framework, we can craft code to directly stream data from the universal logging
    subsystem in our detection tools. Here, we’ll cover important parts of the code,
    though you’re encouraged to consult the full code, found in this chapter’s *logStream*
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-1](chapter6.xhtml#Lis6-1) shows a method that accepts a log filter
    predicate, a log level (such as default, info, or debug), and a callback function
    to invoke for each logging event that matches the specified predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Starting a logging stream with a specified predicate'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I’ve omitted part of this code, such as the class definition and properties
    of the custom log class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the logging support framework ❶, the code retrieves the private
    OSLogEventLiveStream class by name ❷. Now we can instantiate an instance of the
    class ❸. We then configure this instance by setting the filter predicate ❹, making
    sure to wrap it in a try...catch block, as the setFilterPredicate: method can
    throw an exception if provided with an invalid predicate. Next, we set the event
    handler, which the framework will invoke anytime the universal logging subsystem
    ingests a log message matching the specified predicate ❺. We pass these values
    into the start:level:eventHandler: method, where the predicate tells the log stream
    how to filter the messages it delivers to the event handler. We set the logging
    level via the setFlags: method ❻. Finally, we start the stream with a call to
    the activate method ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows how to create an instance of the
    custom log monitor class and then use it to begin ingesting log messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Interfacing with the custom log stream class'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the code creates a predicate object from a string ❶. Note that in production
    code, you should also wrap this action in a try...catch block, as the predicateWithFormat:
    method throws a catchable exception if the provided predicate is invalid. Next,
    we create a LogMonitor object and invoke its start:level:eventHandler: method
    ❷. Note that for the level, we pass in Log_Level_Debug. Since the level is hierarchal,
    this will ensure we capture all message types, including those whose type is info
    and default. Now the code will invoke our event handler anytime a log message
    matching the specified predicate streams to the universal logging subsystem. Currently,
    this handler simply prints out the OSLogEventProxy object.'
  prefs: []
  type: TYPE_NORMAL
- en: To compile this code, we’ll need the undocumented class and method definitions
    we extracted from the *LoggingSupport* framework. These definitions live in the
    *logStream* project’s *LogStream.h* file; [Listing 6-3](chapter6.xhtml#Lis6-3)
    provides a snippet of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: The interface for the private OSLogEventLiveStream and OSLogEventProxy
    classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we compile this code, we can execute it with a user-specified predicate.
    For example, let’s monitor the log messages of the security subsystem, *com.apple.securityd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although we’re indeed capturing streaming log messages that match the specified
    predicate, the messages don’t appear all that useful at first glance. This is
    because our event handler simply prints out the OSLogEventProxy object via a call
    to its description method, which doesn’t include all components of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Log Object Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To detect activity that could indicate the presence of malware, you’ll want
    to extract the OSLogEventProxy log method object’s properties. While disassembling,
    we encountered several useful properties, such as the process ID, path, and message,
    but other interesting ones exist as well. Because Objective-C is introspective,
    you can dynamically query any object, including undocumented ones, to reveal its
    properties and values. This requires a foray into the bowels of the Objective-C
    runtime; nevertheless, you’ll find it useful to understand any undocumented classes
    you encounter, especially when leveraging Apple’s private frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-4](chapter6.xhtml#Lis6-4) is a simple function that accepts any
    Objective-C object, then prints out its properties and their values. It’s based
    on code by Pat Zearfoss.^([8](#chapter6-8))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Introspecting the properties of an Objective-C object'
  prefs: []
  type: TYPE_NORMAL
- en: First, the code imports the required Objective-C runtime header files ❶. Then
    it invokes the class_copyPropertyList API to get an array and the count of the
    object’s properties ❷. We iterate over this array to examine each property, invoking
    the property_getName method to get the name of the property ❸. Then the sel_registerName
    function retrieves a selector for the property ❹. We’ll use the property selector
    later to retrieve the object’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to determine the type of the property, we invoke the property _getAttributes
    method ❺. This returns an array of attributes, with the property type as the second
    item (at index 1). The code handles common types such as Objective-C objects (@),
    integers (i), and floats (f). For each type, we invoke the objc_msgSend function
    on the object with the property’s selector to retrieve the property’s value.
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, you’ll see that the call to objc_msgSend is typecast appropriately
    for each property type. For a list of type encodings, see Apple’s “Type Encodings”
    developer documentation.^([9](#chapter6-9)) To inspect Swift objects, use Swift’s
    Mirror API.^([10](#chapter6-10))
  prefs: []
  type: TYPE_NORMAL
- en: In the log monitor code, we can now invoke the inspectObject function with each
    OSLogEventProxy object received from the logging subsystem ([Listing 6-5](chapter6.xhtml#Lis6-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Inspecting each log message, encapsulated in an OSLogEventProxy
    object'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile and execute the program, we should now receive a more comprehensive
    view of each log message. For example, by monitoring messages related to XProtect,
    the built-in antimalware scanner found on certain versions of macOS, we can observe
    its scan of an untrusted application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The abridged output contains the properties of the OSLogEventProxy object most
    relevant to security tools. [Table 6-1](chapter6.xhtml#tab6-1) summarizes these
    alphabetically. As with many OSLogEventProxy object properties, you can use them
    in custom predicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Security-Relevant OSLogEventProxy Properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| category | The category used to log an event |'
  prefs: []
  type: TYPE_TB
- en: '| composedMessage | The contents of the log message |'
  prefs: []
  type: TYPE_TB
- en: '| logType | For logEvent and traceEvent, the message’s type (default, info,
    debug, error, or fault) |'
  prefs: []
  type: TYPE_TB
- en: '| processIdentifier | The process ID of the process that caused the event |'
  prefs: []
  type: TYPE_TB
- en: '| processImagePath | The full path of the process that caused the event |'
  prefs: []
  type: TYPE_TB
- en: '| senderImagePath | The full path of the library, framework, kernel extension,
    or Mach-O image that caused the event |'
  prefs: []
  type: TYPE_TB
- en: '| subsystem | The subsystem used to log an event |'
  prefs: []
  type: TYPE_TB
- en: '| type | The type of event (such as activityCreateEvent, activityTransitionEvent,
    or logEvent) |'
  prefs: []
  type: TYPE_TB
- en: Determining Resource Consumption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s important to consider the potential resource impact of streaming log messages.
    If you take an overly consumptive approach, you can incur a significant CPU cost
    and impact to the responsiveness of the system.
  prefs: []
  type: TYPE_NORMAL
- en: First, pay attention to the log level. Specifying the debug level will result
    in a significant increase in the number of log messages processed against any
    predicate. Although the predicate evaluation logic is very efficient, more messages
    mean more CPU cycles. Thus, a security tool that leverages the logging subsystem’s
    streaming capabilities should probably stick to consuming the default or info
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Equally important to efficiency is the predicate you use. Interestingly, my
    experiments have shown that the logging daemon wholly evaluates some predicates,
    while the logging subsystem frameworks loaded in client programs, such as the
    log monitor, handle others. The former is better; otherwise, the program will
    receive a copy of every single log message for predicate evaluation, which can
    chew up significant CPU cycles. If the logging daemon performs the predicate evaluation,
    you’ll receive messages that match the predicate only, which won’t discernibly
    impact the system.
  prefs: []
  type: TYPE_NORMAL
- en: How can you craft a predicate that the logging daemon will evaluate? Trial and
    error have shown that if you specify a process or subsystem in a predicate, the
    daemon will evaluate it, meaning you’ll receive only log messages that match.
    Let’s look at a specific example from OverSight, a tool discussed in [Chapter
    12](chapter12.xhtml) that monitors the microphone and webcam.^([11](#chapter6-11))
  prefs: []
  type: TYPE_NORMAL
- en: 'OverSight requires access to log messages from the core media I/O subsystem
    to identify the process accessing the webcam. At the start of the chapter, I noted
    that certain versions of macOS store this process ID in log messages from the
    core media I/O subsystem that contain the string CMIOExtensionPropertyDeviceControlPID.
    Understandably, you might be tempted to craft a predicate that matches this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This predicate would lead to processing inefficiencies, however, as the logging
    daemon will send all messages that the logging frameworks loaded in our log monitor
    to perform the predicate filtering. Instead, OverSight leverages a broader predicate
    that makes use of the subsystem property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach causes the logging daemon to perform the predicate matching,
    then deliver only messages from the core media I/O subsystem. OverSight itself
    manually performs the check for the CMIOExtensionPropertyDeviceControlPID string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The tool leverages a similar process to return log messages associated with
    mic access. As a result, it can effectively detect any process (including malware)
    attempting to use either the mic or webcam.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you saw how to use code to interface with the operating system’s
    universal logging subsystem. By reverse engineering the private *LoggingSupport*
    framework, we programmatically streamed messages matching custom predicates and
    accessed the wealth of data found in the logging subsystem. Security tools could
    use this information to detect new infections or even uncover the malicious actions
    of persistently installed malware.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll write network monitoring logic using Apple’s powerful
    and well-documented network extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter6_1).  Nicole Fishbein and Avigayil Mechtinger, “A Storm Is Brewing:
    IPStorm Now Has Linux Malware,” Intezer, November 14, 2023, [*https://<wbr>www<wbr>.intezer<wbr>.com<wbr>/blog<wbr>/research<wbr>/a<wbr>-storm<wbr>-is<wbr>-brewing<wbr>-ipstorm<wbr>-now<wbr>-has<wbr>-linux<wbr>-malware<wbr>/*](https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter6_2).  “The XCSSET Malware,” TrendMicro, August 13, 2020, [*https://<wbr>documents<wbr>.trendmicro<wbr>.com<wbr>/assets<wbr>/pdf<wbr>/XCSSET<wbr>_Technical<wbr>_Brief<wbr>.pdf*](https://documents.trendmicro.com/assets/pdf/XCSSET_Technical_Brief.pdf).
    To read more about the abuse of remote logins in macOS, see Jaron Bradley, “What
    Does APT Activity Look Like on macOS?,” *The Mitten Mac*, November 14, 2021, [*https://<wbr>themittenmac<wbr>.com<wbr>/what<wbr>-does<wbr>-apt<wbr>-activity<wbr>-look<wbr>-like<wbr>-on<wbr>-macos<wbr>/*](https://themittenmac.com/what-does-apt-activity-look-like-on-macos/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter6_3).  Calum Hall and Luke Roberts, “The Clock Is TCCing,” paper
    presented at Objective by the Sea v6, Spain, October 12, 2023, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v6<wbr>/talks<wbr>/OBTS<wbr>_v6<wbr>_lRoberts<wbr>_cHall<wbr>.pdf*](https://objectivebythesea.org/v6/talks/OBTS_v6_lRoberts_cHall.pdf).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter6_4).  “Logging,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/os<wbr>/logging*](https://developer.apple.com/documentation/os/logging).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter6_5).  Howard Oakley, “How to Reveal ‘Private’ Messages in the
    Log,” Eclectic Light, May 25, 2020, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/05<wbr>/25<wbr>/how<wbr>-to<wbr>-reveal<wbr>-private<wbr>-messages<wbr>-in<wbr>-the<wbr>-log<wbr>/*](https://eclecticlight.co/2020/05/25/how-to-reveal-private-messages-in-the-log/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter6_6).  See Howard Oakley, “log: A Primer on Predicates,” Eclectic
    Light, October 17, 2016, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2016<wbr>/10<wbr>/17<wbr>/log<wbr>-a<wbr>-primer<wbr>-on<wbr>-predicates<wbr>/*](https://eclecticlight.co/2016/10/17/log-a-primer-on-predicates/),
    and “Predicate Programming Guide,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/Predicates<wbr>/AdditionalChapters<wbr>/Introduction<wbr>.html*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Predicates/AdditionalChapters/Introduction.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter6_7).  “OSLog,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/oslog*](https://developer.apple.com/documentation/oslog).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter6_8).  Pat Zearfoss, “Objective-C Quickie: Printing All Declared
    Properties of an Object,” April 14, 2011, [*https://<wbr>zearfoss<wbr>.wordpress<wbr>.com<wbr>/2011<wbr>/04<wbr>/14<wbr>/objective<wbr>-c<wbr>-quickie<wbr>-printing<wbr>-all<wbr>-declared<wbr>-properties<wbr>-of<wbr>-an<wbr>-object<wbr>/*](https://zearfoss.wordpress.com/2011/04/14/objective-c-quickie-printing-all-declared-properties-of-an-object/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter6_9).  The list is available at [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Cocoa<wbr>/Conceptual<wbr>/ObjCRuntimeGuide<wbr>/Articles<wbr>/ocrtTypeEncodings<wbr>.html#<wbr>/<wbr>/apple<wbr>_ref<wbr>/doc<wbr>/uid<wbr>/TP40008048<wbr>-CH100<wbr>-SW1*](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter6_10).  Read more about Swift’s Mirror API in Antoine van der
    Lee, “Reflection in Swift: How Mirror Works,” *SwiftLee*, December 21, 2021, [*https://<wbr>www<wbr>.avanderlee<wbr>.com<wbr>/swift<wbr>/reflection<wbr>-how<wbr>-mirror<wbr>-works<wbr>/*](https://www.avanderlee.com/swift/reflection-how-mirror-works/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter6_11).  See [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/oversight<wbr>.html*](https://objective-see.org/products/oversight.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
