<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_125"/><span class="big">4</span><br/>ADVANCED MEMOIZATION AND DYNAMIC PROGRAMMING</h2>
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>
<p class="noindent">In this chapter, we’re going to continue with memoization and dynamic programming. You don’t need to read this chapter to continue through the book. But there’s more to learn if you’d like to deepen your understanding. We’ll see how to make a dynamic-programming problem easier through a change in perspective, work with more than two dimensions in our subproblem arrays, and stretch our skills to go beyond the “optimize the solution” problems we’ve seen thus far. We’ll also get a bit more practice with the fundamentals. You’ll be a dynamic-programming rock star after this.</p>
<h3 class="h3" id="lev28">Problem 1: The Jumper</h3>
<p class="noindent">We’ll start this chapter with a dynamic-programming problem that’s solvable using what we learned in <a href="ch03.xhtml">Chapter 3</a>. As in that chapter, we’ll be able to solve <span epub:type="pagebreak" id="page_126"/>the problem by focusing on what the end of the optimal solution must look like. We’ll see, though, that this isn’t the only way to do it. In particular, we’ll see that we can instead focus not on the <em>end</em> of the optimal solution, but on its <em>beginning</em>. You may find this second approach more intuitive than the first, if not for this problem then perhaps for other problems. And once you learn this change in perspective, you’ll have two approaches to throw at your next dynamic-programming problem.</p>
<p class="indent">This is DMOJ problem <span class="literal">crci07p2</span>.</p>
<h4 class="h4" id="sec57"><em>The Problem</em></h4>
<p class="noindent">Nikola is playing a game on a row of <em>n</em> squares. The leftmost square is Square 1 and the rightmost square is Square <em>n</em>. Nikola starts on Square 1 and wants to get to Square <em>n</em>. To do so, she makes one or more jumps. Her first jump is required to be from Square 1 to Square 2. After that, the jumping rules are as follows:</p>
<ul>
<li class="noindents">Nikola can jump to the right by exactly one more than the number of squares on her previous jump. For example, if Nikola jumped 3 squares on her previous jump, then she can jump to the right by 4 squares now.</li>
<li class="noindents">Nikola can jump to the left by exactly the same number of squares as on her previous jump. For example, if Nikola jumped 3 squares on her previous jump, then she can jump 3 squares to the left now.</li>
</ul>
<p class="indent">I’ll use the term <em>jump distance</em> to refer to the number of squares moved on a given jump.</p>
<p class="indent">The valid squares here are those from 1 to <em>n</em>. Therefore, if a jump would take Nikola to the left of square 1 or to the right of square <em>n</em>, that jump is not allowed.</p>
<p class="indent">Each square has an entry cost. Whenever Nikola jumps, she pays the entry cost of the square in which she lands.</p>
<p class="indent">We want to determine the minimum total cost for Nikola to get from Square 1 to Square <em>n</em>.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input consists of the following lines:</p>
<ul>
<li class="noindents">A line containing <em>n</em>, the number of squares in the row. <em>n</em> is between 2 and 1,000.</li>
<li class="noindents"> <em>n</em> lines, each giving the entry cost for a square. The first of these lines is the entry cost for Square 1, the second is the entry cost for Square 2, and so on. Each entry cost is an integer between 1 and 500.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the minimum total cost for Nikola to get from Square 1 to Square <em>n</em>.</p>
<p class="indent">The time limit for solving the test case is 0.6 seconds.<span epub:type="pagebreak" id="page_127"/></p>
<h4 class="h4" id="sec58"><em>Working Through an Example</em></h4>
<p class="noindent">Let’s work through one test case to make sure we know exactly what we are being asked to do. Here it is:</p>
<pre>7
3
5
1
9
7
2
3</pre>
<p class="indent">Nikola starts on Square 1 and has to get to Square 7. Remembering that the first jump has to be to Square 2, here’s one possible route:</p>
<p class="noindent1"><strong>Square 1 to Square 2</strong></p>
<p class="indent">Cost 5.</p>
<p class="indent">Most recent jump distance is now 1.</p>
<p class="noindent1"><strong>Square 2 to Square 4</strong></p>
<p class="indent">Cost 9.</p>
<p class="indent">Most recent jump distance is now 2.</p>
<p class="noindent1"><strong>Square 4 to Square 7</strong></p>
<p class="indent">Cost 3.</p>
<p class="indent">Most recent jump distance is now 3.</p>
<p class="indenta">We made it to Square 7! The total cost is 5 + 9 + 3 = 17. This is <em>not</em> the minimum total cost, though. Try to find it before continuing.</p>
<p class="indent">Here’s how we can get the minimum total cost:</p>
<p class="noindent1"><strong>Square 1 to Square 2</strong></p>
<p class="indent">Cost 5.</p>
<p class="indent">Most recent jump distance is now 1.</p>
<p class="noindent1"><strong>Square 2 to Square 1</strong></p>
<p class="indent">Cost 3.</p>
<p class="indent">Most recent jump distance remains 1.</p>
<p class="noindent1"><strong>Square 1 to Square 3</strong></p>
<p class="indent">Cost 1.</p>
<p class="indent">Most recent jump distance is now 2.</p>
<p class="noindent1"><strong>Square 3 to Square 6</strong></p>
<p class="indent">Cost 2.</p>
<p class="indent">Most recent jump distance is now 3.</p>
<p class="noindent1"><strong>Square 6 to Square 3</strong></p>
<p class="indent">Cost 1.</p>
<p class="indent">Most recent jump distance remains 3.<span epub:type="pagebreak" id="page_128"/></p>
<p class="noindent1"><strong>Square 3 to Square 7</strong></p>
<p class="indent">Cost 3.</p>
<p class="indent">Most recent jump distance is now 4.</p>
<p class="indenta">The total cost this time is 5 + 3 + 1 + 2 + 1 + 3 = 15.</p>
<h4 class="h4" id="sec59"><em>Solution 1: Backward Formulation</em></h4>
<p class="noindent">Before we can write any code, we need to settle on our subproblems and how to use these subproblems to characterize the structure of an optimal solution.</p>
<h5 class="h5">Finding the Subproblems</h5>
<p class="noindent">How many subproblem parameters do we need? Could we get away with just one?</p>
<p class="indent">If we have only one subproblem parameter, then we could use it to keep track of which square Nikola is on. But then how would we know which jumps were allowed for a given subproblem? Think about the end of an optimal solution for getting from Square 1 to Square 4. To get closer to a base case, we’d need to know which square Nikola was on prior to Square 4 so that we could make a recursive call to that earlier square. For example, if we knew that Nikola used a jump distance of 2 to get to Square 4, then we would know that prior to Square 4 she must have been on Square 2 or Square 6. But we don’t know the jump distance that Nikola used—it’s not one of our subproblem parameters. This isn’t going to work.</p>
<p class="indent">Let’s try one more time with just one subproblem parameter. What if we use it to keep track of the most recent jump distance? Well, then we won’t have a subproblem parameter available to tell us which square Nikola is on! And without knowing where Nikola is, we won’t have a way to know when we’ve reached the base case square.</p>
<p class="indent">It looks like we need two subproblem parameters: one to tell us the square that Nikola is on and one to tell us the jump distance that she used to get to that square.</p>
<p class="indent">For each of these parameters, we need to decide whether to use “exactly.” In <a href="ch03.xhtml">Chapter 3</a>, we saw examples of using “exactly” subproblems when we solved Burger Fervor and Moneygrubbers. We also saw an example of <em>not</em> using “exactly” when we solved Hockey Rivalry. Had we used “exactly” in Hockey Rivalry, our subproblems would have forced specific games to be matched as rivalry games, which wasn’t needed for that problem.</p>
<p class="indent">Here, it makes sense that we’d want to know <em>exactly</em> which square Nikola is on. We could use that to figure out exactly which square she was on prior to the most recent jump . . . well, not quite. We’d also need to know <em>exactly</em> the jump distance that she used to get to the current square. We could then use both the current square and jump distance to figure out exactly where Nikola must have come from. That is, we need “exactly” for both subproblem parameters.</p>
<p class="indent">The problem description specifies that we have no choice for the first jump: it has to be from Square 1 to Square 2. Instead of worrying about <span epub:type="pagebreak" id="page_129"/>maintaining that condition in our subproblems, we’ll just ignore it: our subproblems will tell us the minimum cost to get from Square 2 to some other square. Later, we’ll add the cost of jumping from Square 1 to Square 2, and that’ll give us our final solution.</p>
<p class="indent">We can’t use any old sequence of jumps from Square 2, though. Think about what would happen if our solution from Square 2 started with a jump of distance 3. We need to jump from Square 1 to Square 2 first and, uh-oh, a jump distance of 3 is not allowed to follow that! We need to ensure that our subproblems solve only for solutions that are feasible given that we’ll prepend the jump from Square 1 to Square 2. We’ll call such solutions <em>connectible</em>.</p>
<p class="indent">Okay, now we’re ready for the subproblems! The subproblem with parameters <em>i</em> and <em>j</em> will tell us the minimum cost of a connectible solution from Square 2 to exactly Square <em>i</em> using a final jump distance of exactly <em>j</em>.</p>
<p class="indent">That subproblem definition is quite a mouthful. Let’s use the test case from the prior section to nail down a few examples of how the definition works.</p>
<p class="indent">What is the solution for the subproblem when <em>i</em> = 7 and <em>j</em> = 3? This is asking us for the best connectible solution that starts at Square 2, ends at Square 7, and has a final jump distance of 3. The answer is 12, witnessed by Nikola jumping from Square 2 to Square 4 (cost 9), to Square 7 (cost 3). (Remember we’re ignoring the cost of jumping from Square 1 to Square 2 in these subproblems.)</p>
<p class="indent">What about the solution for the subproblem with <em>i</em> = 7 and <em>j</em> = 4? The answer is 10: Nikola can jump from Square 2 to Square 1 (cost 3), then to Square 3 (cost 1), to Square 6 (cost 2), to Square 3 (cost 1), and finally to Square 7 (cost 3).</p>
<p class="indent">What about <em>i</em> = 7 and <em>j</em> = 2? Try it, and you should find that achieving this is impossible: there’s no way to find a connectible solution that gets from Square 2 to Square 7 with a final jump distance of 2.</p>
<p class="indent">One more: <em>i</em> = 2 and <em>j</em> = 1. We’re already at Square 2 here. Furthermore, <em>j</em> = 1 means that we need a jump of distance 1 to get us to Square 2. No problem: the jump from square 1 to Square 2 that we’re going to prepend is exactly this kind of jump! The answer here is therefore 0. Hmm, I think we may have just found a base case.</p>
<h5 class="h5">Characterizing Optimal Solutions</h5>
<p class="noindent">Consider a subproblem with some value of <em>i</em> and some value of <em>j</em>. What might the optimal solution look like for this subproblem?</p>
<p class="noindent1"><strong>Option 1</strong></p>
<p class="block95">One option is that this optimal solution ends with a jump to the right. The <em>j</em> value gives us the distance of this jump, so we know that this jump must have been from Square <em>i</em> – <em>j</em>. In order to jump to the right by <em>j</em>, Nikola must have gotten to her previous square with a jump distance of <em>j</em> – 1. (Why <em>j</em> – 1? Because a jump to the right is required to have a jump distance that’s one more than the jump distance of the previous <span epub:type="pagebreak" id="page_130"/>jump.) So the solution for this option is the solution to the subproblem for Square <em>i</em> – <em>j</em> and jump distance <em>j</em> – 1, plus the entry cost of Square <em>i</em>.</p>
<p class="indent">Yikes—it can be confusing thinking about the solution backward like this! For example, we’re talking about jumping to the right, yet we’re using a Square <em>i</em> – <em>j</em> that’s to the left. But remember: we’re looking for the square that Nikola came from, so if she jumped to the right from that square, then she indeed came from a smaller-numbered square.</p>
<p class="noindent1"><strong>Option 2</strong></p>
<p class="block95">Our second option is that this optimal solution ends with a jump to the left. The <em>j</em> value gives us the distance of this jump, so we know that this jump must have been from Square <em>i</em> + <em>j</em>. In order to jump to the left by <em>j</em>, Nikola must have gotten to her previous square with a jump distance of <em>j</em>. So the solution for this option is the solution to the subproblem for Square <em>i</em> + <em>j</em> and jump distance <em>j</em>, plus the entry cost of Square <em>i</em>.</p>
<h5 class="h5">Solving One Subproblem</h5>
<p class="noindent">Let’s skip the bare recursive solution and work on a memoized solution. To do so, we’ll start by writing the code for the following <span class="literal">solve_ij</span> function signature:</p>
<pre>int solve_ij(int cost[], int n, int i, int j,
             int memo[SIZE + 1][SIZE + 1])</pre>
<p class="indent">This function solves the subproblem for the given values of <span class="literal">i</span> and <span class="literal">j</span>. Here’s what each parameter is for:</p>
<p class="block"><span class="codestrong">cost</span>   The array of entry costs. The entry cost for Square 1 is <span class="literal">cost[1]</span>, the entry cost for Square 2 is <span class="literal">cost[2]</span>, and so on.</p>
<p class="block"><span class="codestrong">n</span>   The number of squares in the row.</p>
<p class="block"><span class="codestrong">i</span>   The ending square for this subproblem.</p>
<p class="block"><span class="codestrong">j</span>   The final jump distance for this subproblem.</p>
<p class="block"><span class="codestrong">memo</span>   The memoization array.</p>
<p class="indent">The code for this function is given in <a href="ch04.xhtml#ch04ex01">Listing 4-1</a>.</p>
<pre>#define SIZE 1000

int min(int v1, int v2) {
  if (v1 &lt; v2)
    return v1;
  else
    return v2;
}

int solve_ij(int cost[], int n, int i, int j, int memo[SIZE + 1][SIZE + 1]) {
  int first, second;
<span class="ent">❶</span> if (memo[i][j] != -2)
     return memo[i][j];
<span class="ent">➋</span> if (i ==  2 &amp;&amp; j == 1) {
     memo[i][j] = 0;
     return memo[i][j];
  }
<span class="ent">➌</span> if (i - j &gt;= 1 &amp;&amp; j &gt;= 2)
     first = solve_ij(cost, n, i - j, j - 1, memo);
   else
     first = -1;
<span class="ent">➍</span> if (i + j &lt;= n)
     second = solve_ij(cost, n, i + j, j, memo);
   else
     second = -1;
<span class="ent">➎</span> if (first == -1 &amp;&amp; second == -1) {
     memo[i][j] = -1;
     return memo[i][j];
   } else if (second == -1) {
     memo[i][j] = first + cost[i];
     return memo[i][j];
   } else if (first == -1) {
     memo[i][j] = second + cost[i];
     return memo[i][j];
   } else {
     memo[i][j] = min(first, second) + cost[i];
     return memo[i][j];
   }
}</pre>
<p class="excap" id="ch04ex01"><span epub:type="pagebreak" id="page_131"/><em>Listing 4-1: Solving one subproblem</em></p>
<p class="indent">As we did when solving Burger Fervor in <a href="ch03.xhtml">Chapter 3</a>, we use <span class="literal">-2</span> in the <span class="literal">memo</span> array <span class="ent">➊</span> to indicate that a subproblem hasn’t been solved yet. The typical value to use here would be <span class="literal">-1</span>, but we’ll use <span class="literal">-1</span> to indicate that we’ve already tried to solve a subproblem but that it has no solution.</p>
<p class="indent">As we discovered in the previous section, an important base case is when we’re on square 2 and need to get to that square with a jump of distance 1 <span class="ent">➋</span>. In this case, we return <span class="literal">0</span>: there’s no cost to get from Square 2 to Square 2!</p>
<p class="indent">Next we try each of the two options for an optimal solution. We use the variable <span class="literal">first</span> to hold the value for Option 1 and <span class="literal">second</span> to hold the value for Option 2.</p>
<p class="noindent1"><strong>Option 1</strong></p>
<p class="block95">This is the option where Nikola jumps to the right to get to Square <span class="literal">i</span>. To use this option, we need to ensure that Nikola would have come from a valid square. We also need to ensure that <span class="literal">j</span> is at least <span class="literal">2</span> <span class="ent">➌</span>, which guarantees that she got to the previous square with a jump distance of at least 1. After all, it wouldn’t make sense to say that Nikola got to a prior square using a jump of distance 0!<span epub:type="pagebreak" id="page_132"/></p>
<p class="noindent1"><strong>Option 2</strong></p>
<p class="block95">This is the option where Nikola jumps to the left to get to Square <span class="literal">i</span>. As in the previous option, we need to ensure that Nikola came from a valid square <span class="ent">➍</span>.</p>
<p class="indenta">It’s possible for one or both options to fail to find a solution; in those cases we use a value of <span class="literal">-1</span>. If both options fail, then we return <span class="literal">-1</span> <span class="ent">➎</span>. The rest of the code determines which of the two options is best, and returns that plus <span class="literal">cost[i]</span> as the solution.</p>
<h5 class="h5">Where’s the Optimal Solution?</h5>
<p class="noindent">Now we can solve any subproblem we want. So, what call of <span class="literal">solve_ij</span> should we make to find the solution to the original problem?</p>
<p class="indent">Trick question: one call won’t be enough! We’re going to need to do some searching, much as we did when we solved Burger Fervor and Money-grubbers in <a href="ch03.xhtml">Chapter 3</a>. But why?</p>
<p class="indent">We know for sure that we need to end exactly on Square <em>n</em>, so we don’t need any searching there. What we <em>don’t</em> know is the jump distance that we should have used as the final jump. Should we have ended with a jump distance of 2? 3? 4? Who knows? We need to try them all and pick the best one. See <a href="ch04.xhtml#ch04ex02">Listing 4-2</a> for the code to do this.</p>
<pre>int solve(int cost[], int n) {
  int i, j, best, result;
<span class="ent">❶</span> static int memo[SIZE + 1][SIZE + 1];
   for (i = 1; i &lt;= SIZE; i++)
     for (j = 1; j &lt;= SIZE; j++)
       memo[i][j] = -2;
<span class="ent">➋</span> best = -1;
<span class="ent">➌</span> for (j = 1; j &lt;= n; j++) {
     result = solve_ij(cost, n, n, j, memo);
     if (result != -1) {
       if (best == -1)
      <span class="ent">➍</span> best = cost[2] + result;
       else
      <span class="ent">➎</span> best = min(best, cost[2] + result);
    }
  }
  return best;
}</pre>
<p class="excap" id="ch04ex02"><em>Listing 4-2: Solution 1</em></p>
<p class="indent">This function is where we set up the <span class="literal">memo</span> array <span class="ent">➊</span> so that it’s shared across all calls to <span class="literal">solve_ij</span>.</p>
<p class="indent">The <span class="literal">best</span> variable holds the best solution that we’ve found thus far. It begins at <span class="literal">-1</span> <span class="ent">➋</span> and is updated whenever we find a better solution <span class="ent">➍ ➎</span>. Be careful: we need to add <span class="literal">cost[2]</span> here in order to reincorporate the jump from Square 1 to Square 2.<span epub:type="pagebreak" id="page_133"/></p>
<p class="indent">Notice that we’re looping through the final jump distances between <span class="literal">1</span> and <span class="literal">n</span> <span class="ent">➌</span>. There’s no point trying any final distance larger than <span class="literal">n</span> because they can’t lead to a valid square. That is, we’re guaranteed to find the best final jump distance because we’re trying all of the valid possibilities.</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">It’s time to wrap up this solution. All we need is a <span class="literal">main</span> function to read the input and call <span class="literal">solve</span>. The code is in <a href="ch04.xhtml#ch04ex03">Listing 4-3</a>.</p>
<pre>int main(void) {
  int i, n;
  int cost[SIZE + 1];
  scanf("%d ", &amp;n);
  for (i = 1; i &lt;= n; i++)
    scanf("%d", &amp;cost[i]);
  printf("%d\n", solve(cost, n));
  return 0;
}</pre>
<p class="excap" id="ch04ex03"><em>Listing 4-3: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">If you submit our code to the judge, you should pass all test cases within the time limit.</p>
<p class="indent">But we can still do better.</p>
<h4 class="h4" id="sec60"><em>Solution 2: Forward Formulation</em></h4>
<p class="noindent">Let’s first talk about why Solution 1 is fast, and then discuss why we can still improve it.</p>
<h5 class="h5">How Fast is Solution 1?</h5>
<p class="noindent">Solution 1 is an <em>O</em>(<em>n</em><sup>2</sup>) algorithm. It’d be easier to see that from a bottom-up dynamic-programming solution, with its telltale two nested loops, but we can still make an argument using our memoized solution. Our <span class="literal">solve_ij</span> function (<a href="ch04.xhtml#ch04ex01">Listing 4-1</a>) fills in each of the <em>n</em><sup>2</sup> elements of <span class="literal">memo</span> at most once. To fill in each such element, our code makes two recursive calls. We can therefore say that our code makes at most 2<em>n</em><sup>2</sup> recursive calls. Beyond that, each recursive call of <span class="literal">solve_ij</span> performs a constant number of steps to decide whether to use <span class="literal">first</span> or <span class="literal">second</span> in the optimal solution. So <span class="literal">solve_ij</span> takes <em>O</em>(<em>n</em><sup>2</sup>) time throughout all recursive calls.</p>
<p class="indent">The maximum number of squares in a row is 1,000. Our <em>O</em>(<em>n</em><sup>2</sup>) algorithm is therefore performing something like 1,000<sup>2</sup> = 1,000,000 steps. We can do that easily within our 0.6-second time limit.</p>
<p class="indent">All right, so Solution 1 is fast. What could we possibly want to improve, then?<span epub:type="pagebreak" id="page_134"/></p>
<h5 class="h5">Backward vs. Forward</h5>
<p class="noindent">Perhaps you’ve been bothered by an incongruity between the way that Nikola’s jumps are described in the problem description and the way that we thought about jumps in our memoized solution. The problem description tells us what Nikola can do on each jump starting from the first jump. That is, it focuses on where Nikola is right now and what she can do next. Our memoized solution, by contrast, focuses on where Nikola got to and how she got there. For example, rather than thinking, “Nikola jumped from Square 2 to Square 4,” we have to think, “Nikola got to Square 4 by jumping from Square 2.” We have to think about the problem backward!</p>
<p class="indent">In addition to those extra mental gymnastics, our backward formulation has a consequence on the amount of code we have to write as well. Remember how we had to search through all possible final jump distances in <a href="ch04.xhtml#ch04ex02">Listing 4-2</a>? The reason we needed that is because we don’t know how the optimal solution ends. Maybe it ends with a jump distance of 2, or a jump distance of 3, or a jump distance of 4, and so on. But we <em>do</em> know exactly how it begins: with a jump distance of 1 from Square 1 to Square 2! As long as we keep track of the most recent jump distance, we’ll never have to guess what it might be. That is, if we solve the problem forward (keeping track of where we are) rather than backward (keeping track of where we ended up), we’ll be able to entirely avoid the jump-distance search. We’ll get to the end of the optimal solution with whatever we need the final jump distance to be.</p>
<h5 class="h5">Finding the Subproblems, Again</h5>
<p class="noindent">We’ll stick with our earlier idea of using two subproblem parameters. That’s because we need one to tell us the square that Nikola is on and one to tell us the jump distance that she used to get to that square.</p>
<p class="indent">This time, the subproblem with parameters <em>i</em> and <em>j</em> is going to tell us the minimum cost of a solution from exactly Square <em>i</em> to Square <em>n</em> given that Square <em>i</em> was reached with a jump distance of exactly <em>j</em>.</p>
<p class="indent">We need some examples of this! We’ll again use the test case from “Working Through an Example” on <a href="ch04.xhtml#sec58">page 127</a>.</p>
<p class="indent">Let’s start with the subproblem with <em>i</em> = 2 and <em>j</em> = 1. This is asking us for the best solution that starts at Square 2, ends at Square 7, and got to Square 2 using a jump distance of 1. (Notice that we don’t care at all about the jump distance that ultimately takes us to Square <em>n</em>. It could be anything!) The answer here is 10: Nikola can jump from Square 2 to Square 1 (cost 3), to Square 3 (cost 1), to Square 6 (cost 2), to Square 3 (cost 1), to Square 7 (cost 3). Hey, that’s the same answer as for the <em>i</em> = 7, <em>j</em> = 4 subproblem from the backward formulation! But in the backward formulation, we would have to try all final jump distances to confirm that this is the optimal one. No longer.</p>
<p class="indent">Now think about any subproblem with <em>i</em> = <em>n</em>. What’s the answer? It’s 0: we’re already on square <em>n</em>! We don’t care what <em>j</em> is, because we don’t care how we got to Square <em>n</em>. We’ve found our base case again.<span epub:type="pagebreak" id="page_135"/></p>
<h5 class="h5">Characterizing Optimal Solutions, Again</h5>
<p class="noindent">We need to redo our optimal substructure work from Solution 1.</p>
<p class="noindent1"><strong>Option 1</strong></p>
<p class="block95">One option is that Nikola next makes a jump to the right. The <em>j</em> value gives us the jump distance to the current square. The jump to the right will have distance <em>j</em> + 1, and Nikola will therefore land on Square <em>i</em> + <em>j</em> + 1. So the solution for this option is the entry cost of Square <em>i</em> + <em>j</em> + 1, plus the solution to the subproblem for Square <em>i</em> + <em>j</em> + 1 and jump distance <em>j</em> + 1.</p>
<p class="noindent1"><strong>Option 2</strong></p>
<p class="block95">Our second option is that Nikola next makes a jump to the left. That jump to the left will have distance <em>j</em>, and Nikola will therefore land on Square <em>i</em>–<em>j</em>. So the solution for this option is the entry cost of Square <em>i</em>–<em>j</em>, plus the solution to the subproblem for Square <em>i</em> – <em>j</em> and jump distance <em>j</em>.</p>
<h5 class="h5">Solving the Needed Subproblem</h5>
<p class="noindent">Now we can write a <span class="literal">solve</span> function that solves a subproblem of our choice. See <a href="ch04.xhtml#ch04ex04">Listing 4-4</a> for the code.</p>
<pre>int solve(int cost[], int n, int i, int j,
          int memo[SIZE + 1][SIZE + 1]) {
  int first, second;
  if (memo[i][j] != -2)
    return memo[i][j];
  if (i == n) {
    memo[i][j] = 0;
    return memo[i][j];
  }
<span class="ent">❶</span> if (i + j + 1 &lt;= n)
     first = solve(cost, n, i + j + 1, j + 1, memo);
   else
     first = -1;
<span class="ent">➋</span> if (i - j &gt;= 1)
     second = solve(cost, n, i - j, j, memo);
   else
     second = -1;
   if (first == -1 &amp;&amp; second == -1) {
     memo[i][j] = -1;
     return memo[i][j];
   } else if (second == -1) {
     memo[i][j] = cost[i + j + 1] + first;
     return memo[i][j];
   } else if (first == -1) {
     memo[i][j] = cost[i - j] + second;
     return memo[i][j];
   } else {
     memo[i][j] = min(cost[i + j + 1] + first, cost[i - j] + second);
     return memo[i][j];
  }
}</pre>
<p class="excap" id="ch04ex04"><span epub:type="pagebreak" id="page_136"/><em>Listing 4-4: Solution 2</em></p>
<p class="indent">As in our backward formulation (<a href="ch04.xhtml#ch04ex01">Listing 4-1</a>), we need to implement each of the two options for an optimal solution. In each case, we first check that the next square is a valid square <span class="ent">❶ ➋</span> prior to considering the jump.</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">What call of <span class="literal">solve</span> should we make in order to find the solution to the original problem?</p>
<p class="indent">That’s not a trick question this time—we know exactly which subproblem we need to solve! We need to solve the subproblem with <em>i</em> = 2 (starting on square 2) and <em>j</em> = 1 (getting to square 2 with a jump of distance 1). We can incorporate this in our <span class="literal">main</span> function that reads the input. Check out the code in <a href="ch04.xhtml#ch04ex05">Listing 4-5</a>.</p>
<pre>int main(void) {
  int i, j, n, result;
  int cost[SIZE + 1];
  static int memo[SIZE + 1][SIZE + 1];
  scanf("%d ", &amp;n);
  for (i = 1; i &lt;= n; i++)
    scanf("%d", &amp;cost[i]);
  for (i = 1; i &lt;= SIZE; i++)
    for (j = 1; j &lt;= SIZE; j++)
      memo[i][j] = -2;
  result = cost[2] + solve(cost, n, 2, 1, memo);
  printf("%d\n", result);
  return 0;
}</pre>
<p class="excap" id="ch04ex05"><em>Listing 4-5: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">For this problem, I prefer the forward solution, but you may instead prefer the backward solution—it’s an individual choice!</p>
<p class="indent">When I’m working on a memoization or dynamic-programming solution, I always start by trying to formulate a backward solution. Backward solutions often feel more natural to me because they more closely model the way that I think about recursion. If I get stuck for too long, though, or when there’s friction between the forward nature of the problem description and the backward formulation, I’ll give it a whirl with a forward solution. Keep both of these complementary approaches in your dynamic-programming toolbox!<span epub:type="pagebreak" id="page_137"/></p>
<h5 class="h5">What About Dynamic Programming?</h5>
<p class="noindent">We have a perfectly good forward memoized solution for this problem. Still, you might want to develop a dynamic-programming solution. If you do, there’s a bit of a surprise waiting in there!</p>
<p class="indent">Think back to how we solved Hockey Rivalry in <a href="ch03.xhtml">Chapter 3</a> with dynamic programming. In “Solution 3: Dynamic Programming” on <a href="ch03.xhtml#sec55">page 119</a>, we learned that we need to figure out the order in which to solve the subproblems. In Hockey Rivalry, we did this by solving all of the subproblems in row 0 from left to right, then all of the subproblems in row 1 from left to right, and so on.</p>
<p class="indent">But that order won’t work for us now.</p>
<p class="indent">What do we need in order to solve <span class="literal">dp[i][j]</span>? From Option 1, we need to have already solved <span class="literal">dp[i + j + 1][j + 1]</span>; that is, we need something from a higher-numbered column. From Option 2, we need to have already solved <span class="literal">dp[i - j][j]</span>; that is, we need something from a lower-numbered row in the current column. Taken together, we need to solve all of the subproblems in column <span class="literal">n</span>, then all of the subproblems in column <span class="literal">n - 1</span>, and so on. And within each column, we need to solve the subproblem in row 1, then row 2, and so on.</p>
<p class="indent">Here’s the double <span class="literal">for</span> loop that we can use to solve the subproblems in the right order:</p>
<pre>for (j = n; j &gt;= 1; j--)
  for (i = 1; i &lt; n; i++) {
    <span class="codeitalic1">code to fill in dp[i][j]</span>
}</pre>
<p class="indent">Always be careful with the order that you solve the subproblems!</p>
<p class="indent">If you’d like to see the full dynamic-programming solution, please check the online resources for this book. Otherwise, we’re ready to continue here with another dynamic-programming problem. A real doozy. You’re so ready for this.</p>
<h3 class="h3" id="lev29">Problem 2: Ways to Build</h3>
<p class="noindent">The four dynamic-programming problems that we’ve solved so far (three in <a href="ch03.xhtml">Chapter 3</a> and one in this chapter) asked us to maximize (Burger Fervor and Hockey Rivalry) or minimize (Moneygrubbers and The Jumper) the value of a solution. I’d like to end this chapter with a problem of a slightly different flavor: rather than find an optimal solution, we’ll count the number of possible solutions.</p>
<p class="indent">One other difference that will arise is in the number of dimensions of our subproblem array. In the four earlier problems, we used a one- or two-dimensional array of subproblem solutions. We’re going to need more dimensions than that to solve this one.</p>
<p class="indent">This is DMOJ problem <span class="literal">noip15p5</span>.<span epub:type="pagebreak" id="page_138"/></p>
<h4 class="h4" id="sec61"><em>The Problem</em></h4>
<p class="noindent">We’re given a source string <em>a</em>, a target string <em>b</em>, and an integer <em>k</em>. We want to build <em>b</em> from <em>a</em> by putting together <em>k</em> substrings of <em>a</em>.</p>
<p class="indent">There are some rules that we need to follow:</p>
<ul>
<li class="noindents">We have to use the substrings of <em>a</em> in the same order that they occur in <em>a</em>.</li>
<li class="noindents">We’re not allowed to use any empty substrings—each one has to have at least one character.</li>
<li class="noindents">We’re not allowed to use substrings that overlap: if we use some character from <em>a</em> in one of our substrings, then we are not allowed to use that character in some other substring.</li>
<li class="noindents">We have to use exactly <em>k</em> substrings of <em>a</em> to build <em>b</em>.</li>
</ul>
<p class="indent">For example, let’s say that <em>a</em> is <span class="literal">xxyzxyz</span>, <em>b</em> is <span class="literal">xxyz</span>, and <em>k</em> is <span class="literal">3</span>. One way to build <em>b</em> by putting together three substrings of <em>a</em> is to take the <span class="literal">x</span> from the beginning of <em>a</em>, the <span class="literal">xy</span> to the right of that, and the <span class="literal">z</span> from the end of <em>a</em>. Putting those substrings together gives us <span class="literal">xxyz</span>, exactly the string <em>b</em> that we need.</p>
<p class="indent">Now, there may be many different ways to build <em>b</em> from <em>a</em>. But notice that as long as we follow the rules it doesn’t matter how we build <em>b</em>—each way is just as good as the others. It therefore doesn’t make sense to talk about the optimal way to build <em>b</em>. What we’re asked to determine for this problem, then, is not the best way to build <em>b</em>, but the total number of ways that we can build <em>b</em>. In the previous example, there are 11 ways. Can you find them all?</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, the information for which is spread over three lines as follows:</p>
<ul>
<li class="noindents">The first line contains three numbers: the length of String <em>a</em>, the length of String <em>b</em>, and the integer <em>k</em> giving the number of substrings that we must take from <em>a</em> to build <em>b</em>. The length of String <em>a</em> is between 1 and 1,000, the length of String <em>b</em> is between 1 and 200, and <em>k</em> is between 0 and 200.</li>
<li class="noindents">The second line contains the String <em>a</em>.</li>
<li class="noindents">The third line contains the String <em>b</em>.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the number of ways we can build <em>b</em> using exactly <em>k</em> substrings of <em>a</em>.</p>
<p class="indent">This number may be huge. To spare us from integer overflow worries, the problem specifies that we output this number mod 1,000,000,007.</p>
<p class="indent">The time limit for solving the test case is two seconds.<span epub:type="pagebreak" id="page_139"/></p>
<h4 class="h4" id="sec62"><em>Working Through an Example</em></h4>
<p class="noindent">Were you able to find all 11 ways to build <em>b</em> for the example that I gave in the problem description? Let’s make sure you have them all, as we’ll be using this as a running example for this problem.</p>
<p class="indent">Here is the example in the form of a test case:</p>
<pre>7 4 3
xxyzxyz
xxyz</pre>
<p class="indent">For quick reference, here are the indices for the characters of <em>a</em>:</p>
<div class="image"><img alt="Image" src="../images/unch04fig01.jpg"/></div>
<p class="indent">How can we build <span class="literal">xxyz</span> from <span class="literal">xxyzxyz</span> using exactly three substrings? In the following, I’ll indicate each substring of <em>a</em> using a range of indices; for example, 0-0 refers to the substring of <em>a</em> that consists of the character at index 0, and 1-2 refers to the substring of <em>a</em> consisting of the characters at indices 1 and 2.</p>
<p class="indent">Here are five ways to do it:</p>
<ul>
<li class="noindents">0-1 (<span class="literal">xx</span>), 5-5 (<span class="literal">y</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">1-1 (<span class="literal">x</span>), 4-5 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 4-5 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-1 (<span class="literal">xx</span>), 2-2 (<span class="literal">y</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-2 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
</ul>
<p class="indent">Notice in each of these ways that our final substring is the final character <em>z</em> from <em>a</em>. That is, we’ve fixed the final substring to be that <span class="literal">z</span> and then searched for ways to take two substrings from <span class="literal">xxyzxy</span> to build <span class="literal">xxy</span>. We are starting to see how we can find solutions to the initial problem by finding solutions to smaller subproblems.</p>
<p class="indent">There are six remaining ways. Let’s get those down:</p>
<ul>
<li class="noindents">1-1 (<span class="literal">x</span>), 4-4 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 4-4 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-1 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
<li class="noindents">0-1 (<span class="literal">xx</span>), 2-2 (<span class="literal">y</span>), 3-3 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-2 (<span class="literal">xy</span>), 3-3 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-1 (<span class="literal">x</span>), 2-3 (<span class="literal">yz</span>)</li>
</ul>
<p class="indent">Adding up the five ways from before, we now have a total of 5 + 6 = 11 ways to solve the problem.<span epub:type="pagebreak" id="page_140"/></p>
<h4 class="h4" id="sec63"><em>Solution 1: Using “Exactly” Subproblems</em></h4>
<p class="noindent">We need to identify our subproblems and then use them to find all optimal solutions. We’ll try for a backward formulation.</p>
<h5 class="h5">Finding the Subproblems</h5>
<p class="noindent">How many subproblem parameters will we need this time?</p>
<p class="indent">We need to keep track of where we are in String <em>a</em> and keep track of where we are in String <em>b</em>. That’s a good start, but it isn’t quite enough. We also need a subproblem parameter to tell us how many more substrings to take. For the first time, we’re going to use three subproblem parameters!</p>
<p class="indent">We did well using “exactly” subproblem parameters when we solved The Jumper earlier in this chapter. As usual, we need to decide whether to use it for each of our subproblem parameters here. It makes sense to use “exactly” for the parameter that tracks how many more substrings to take, because we need to use exactly that number of substrings (not, for instance, at most that number of substrings). It’s less clear what to do for the subproblem parameters that keep track of where we are in <em>a</em> and where we are in <em>b</em>. Let’s just start with “exactly” parameters for those, too, and see what happens. In what follows, we’ll use the notation <em>s</em>[<em>i</em>..<em>j</em>] to refer to the characters from index <em>i</em> up to and including index <em>j</em> of String <em>s</em>.</p>
<p class="indent">The subproblem with parameters <em>i</em>, <em>j</em>, and <em>k</em> is going to tell us the number of ways that we can choose exactly <em>k</em> substrings from <em>a</em>[0..<em>i</em>] to build exactly <em>b</em>[0..<em>j</em>], with the restriction that the rightmost substring ends with exactly the character <em>a</em>[<em>i</em>].</p>
<p class="indent">Let’s return to our running example to clarify how these subproblems work. What’s our answer for the subproblem with <em>i</em> = 6, <em>j</em> = 3, and <em>k</em> = 3? (Don’t answer “11” too quickly!)</p>
<p class="indent">Since <em>a</em>[0..6] is all of <em>a</em>, and <em>b</em>[0..3] is all of <em>b</em>, this subproblem is asking about the full <em>a</em> and <em>b</em> strings. So we’re looking for all ways to choose exactly three substrings from <em>a</em> to build <em>b</em>, with the restriction that the rightmost substring ends with exactly the <span class="literal">z</span> at <em>a</em>[6].</p>
<p class="indent">The answer is 8! Here they are—the first five are the ones that use the final <span class="literal">z</span> in <em>a</em> as its own substring, and the remaining three use the final <span class="literal">yz</span> in <em>a</em> as its own substring:</p>
<ul>
<li class="noindents">0-1 (<span class="literal">xx</span>), 5-5 (<span class="literal">y</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">1-1 (<span class="literal">x</span>), 4-5 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 4-5 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-1 (<span class="literal">xx</span>), 2-2 (<span class="literal">y</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-2 (<span class="literal">xy</span>), 6-6 (<span class="literal">z</span>)</li>
<li class="noindents">1-1 (<span class="literal">x</span>), 4-4 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 4-4 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-1 (<span class="literal">x</span>), 5-6 (<span class="literal">yz</span>)</li>
</ul>
<p class="indent">But why can’t we include the missing solutions, like 0-1 (<span class="literal">xx</span>), 2-2 (<span class="literal">y</span>), 3-3 (<span class="literal">z</span>)? Shouldn’t those count?<span epub:type="pagebreak" id="page_141"/></p>
<p class="indent">The reason we can’t use them here is because they don’t use that final <span class="literal">z</span> at <em>a</em>[6]. They don’t satisfy the requirements of the type of “exactly” subproblem that we’re using.</p>
<p class="indent">That said, we have eight ways so far, and we do need to get to 11. Looking at the <em>i</em> = 6, <em>j</em> = 3, <em>k</em> = 3 subproblem therefore isn’t enough. We can find the three missing ways by looking at the subproblem <em>i</em> = 3, <em>j</em> = 3, <em>k</em> = 3. Those ways are as follows:</p>
<ul>
<li class="noindents">0-1 (<span class="literal">xx</span>), 2-2 (<span class="literal">y</span>), 3-3 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-2 (<span class="literal">xy</span>), 3-3 (<span class="literal">z</span>)</li>
<li class="noindents">0-0 (<span class="literal">x</span>), 1-1 (<span class="literal">x</span>), 2-3 (<span class="literal">yz</span>)</li>
</ul>
<p class="indent">As in our backward formulation of The Jumper in this chapter and Burger Fervor and Moneygrubbers in <a href="ch03.xhtml">Chapter 3</a>, we’ll need to do some postprocessing to find what we need. In those other problems, we searched the relevant subproblems to discover the optimal one; here, we’ll search the relevant subproblems to find all possible solutions.</p>
<h5 class="h5">Characterizing the Ways</h5>
<p class="noindent">Consider an <em>i</em>, <em>j</em>, <em>k</em> subproblem as described in the previous section. There are two categories of ways to satisfy this subproblem. In each category, we require that <em>a</em>[<em>i</em>] is the same character as <em>b</em>[<em>j</em>]—if it isn’t, then the requirements of the subproblem are not met and the answer is zero.</p>
<p class="noindent1"><strong>Category 1</strong></p>
<p class="block95ab">One category of ways involves using <em>a</em>[<em>i</em>] as the final substring. If we use up one substring on <em>a</em>[<em>i</em>], then we have <em>k</em> – 1 substrings to go, so we’ll continue by solving subproblems with <em>k</em> – 1 as the third parameter. Similarly, we’ll continue with <em>j</em> – 1 as the second parameter, because we just used character <em>b</em>[<em>j</em>].</p>
<p class="blocki">What about the first parameter—what do we do there? Do we just do the same thing that we did with <em>j</em> and <em>k</em> and continue with <em>i</em> – 1?</p>
<p class="blocki">Not necessarily! It’s true that continuing with <em>i</em> – 1 is one possibility, but there are others. We need to be able to skip some characters from <em>a</em> and continue at an earlier point. That is, we might want to match <em>b</em>[<em>j</em> – 1] with <em>a</em>[<em>i</em> – 2] or <em>a</em>[<em>i</em> – 3] or some even earlier character. We’re going to need a loop in here that tries all values of the first parameter up to <em>i</em> – 1, while fixing <em>j</em> – 1 for the second parameter and <em>k</em> – 1 for the third parameter.</p>
<p class="blocki">Using our running example, consider again the subproblem with <em>i</em> = 6, <em>j</em> = 3, and <em>k</em> = 3. We know that the answer for this subproblem is 8. Of those 8, there are 5 that fall into Category 1. We get 3 of those 5 from the subproblem with <em>i</em> = 5, <em>j</em> = 2, and <em>k</em> = 2 and the other 2 from the subproblem with <em>i</em> = 2, <em>j</em> = 2, and <em>k</em> = 2.</p>
<p class="noindenta"><strong>Category 2</strong></p>
<p class="block95ab">The other category of ways involves using at least two characters for the final substring.<span epub:type="pagebreak" id="page_142"/></p>
<p class="blocki">There’s a neat trick that we can use for this one. Imagine that we solve the subproblem with parameters <em>i</em> – 1, <em>j</em> – 1, and <em>k</em> (that’s right: the third parameter is <em>k</em>, not <em>k</em> – 1!). It turns out that this is the only subproblem that we need to solve!</p>
<p class="blocki">That subproblem uses all <em>k</em> substrings to find solutions that end by matching <em>a</em>[<em>i</em> – 1] with <em>b</em>[<em>j</em> – 1]. But each of those solutions can be extended to a solution that matches <em>a</em>[<em>i</em>] with <em>b</em>[<em>j</em>] by just tacking <em>a</em>[<em>i</em>] (or <em>b</em>[<em>j</em>]—they’re the same) on to the final substring. Similarly, any solution in this category that matches <em>a</em>[<em>i</em>] with <em>b</em>[<em>j</em>] and uses <em>k</em> substrings corresponds to a solution to the subproblem that matches <em>a</em>[<em>i</em> – 1] with <em>b</em>[<em>j</em> – 1] and uses <em>k</em> substrings. In conclusion, the number of solutions here is exactly the same as it is for the <em>i</em> – 1, <em>j</em> – 1, <em>k</em> subproblem.</p>
<p class="blocki">In our running example, the subproblem with <em>i</em> = 6, <em>j</em> = 3, and <em>k</em> = 3 has three solutions in this category. We get that by looking up the answer to the subproblem with <em>i</em> = 5, <em>j</em> = 2, and <em>k</em> = 3.</p>
<p class="indenta">Notice that there can not be any other categories besides these two. Category 1 uses the single-character string <em>a</em>[<em>i</em>] as the final substring; Category 2 uses a longer string that ends with <em>a</em>[<em>i</em>] as the final substring. There can’t be anything else.</p>
<h5 class="h5">Solving One Subproblem</h5>
<p class="noindent">As we did when solving The Jumper earlier in this chapter, we’ll skip the unadorned recursive solution and jump right to a memoized one. We need a function to tell us the answer for the subproblem with the given <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">k</span> values. That function will have the following signature:</p>
<pre>int solve_ijk(char a[], char b[], int i, int j, int k,
              int memo[MAX_A][MAX_B][MAX_K + 1])</pre>
<p class="indent">Here, <span class="literal">a</span> is the source string; <span class="literal">b</span> is the target string; <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">k</span> are the three subproblem parameters; and <span class="literal">memo</span> is the memoization array.</p>
<p class="indent">The code for this function is given in <a href="ch04.xhtml#ch04ex06">Listing 4-6</a>.</p>
<pre>#define MAX_A 1000
#define MAX_B 200
#define MAX_K 200
#define MOD 1000000007

int solve_ijk(char a[], char b[], int i, int j, int k,
              int memo[MAX_A][MAX_B][MAX_K + 1]) {
  int total, q;
  if (memo[i][j][k] != -1)
    return memo[i][j][k];
<span class="ent">❶</span> if (j == 0 &amp;&amp; k == 1 &amp;&amp; a[i] == b[j]) {
     memo[i][j][k] = 1;
     return memo[i][j][k];
  }
<span class="ent">➋</span> if (i == 0 || j == 0 || k == 0) {
     memo[i][j][k] = 0;
     return memo[i][j][k];
  }
<span class="ent">➌</span> if (a[i] != b[j]) {
     memo[i][j][k] = 0;
     return memo[i][j][k];
   }
   total = 0;
<span class="ent">➍</span> for (q = 0; q &lt; i; q++)
  <span class="ent">➎</span> total = (total + solve_ijk(a, b, q, j - 1, k - 1, memo)) % MOD;
<span class="ent">➏</span> total = (total + solve_ijk(a, b, i - 1, j - 1, k, memo)) % MOD;
   memo[i][j][k] = total;
   return memo[i][j][k];
}</pre>
<p class="excap" id="ch04ex06"><span epub:type="pagebreak" id="page_143"/><em>Listing 4-6: Solving one subproblem</em></p>
<p class="indent">When we solved Hockey Rivalry in <a href="ch03.xhtml">Chapter 3</a>, we started indexing our arrays at 1 rather than 0, and that simplified our solution a little. Here, however, I’ve decided to index starting at 0. You could indeed use the Hockey Rivalry indexing trick here as well; I’ve chosen not to in order to spare us the trouble of defining what subproblems mean when the empty string is in play.</p>
<p class="indent">Let’s work through the code, starting with the base cases.</p>
<p class="indent">Our first base case is when <span class="literal">j</span> is <span class="literal">0</span>, <span class="literal">k</span> is <span class="literal">1</span>, and <span class="literal">a[i]</span> and <span class="literal">b[j]</span> are the same character <span class="ent">➊</span>. What we’re being asked for here is the number of ways to build the one-character string <span class="literal">b[0]</span> using <span class="literal">a[i]</span> given that <span class="literal">a[i]</span> matches <span class="literal">b[0]</span>. The answer is <span class="literal">1</span>, because we can use <span class="literal">a[i]</span> as a match!</p>
<p class="indent">Now, in any other case where <span class="literal">i</span> is <span class="literal">0</span>, or <span class="literal">j</span> is <span class="literal">0</span>, or <span class="literal">k</span> is <span class="literal">0</span> <span class="ent">➋</span>, the answer is <span class="literal">0</span>. For example, if <span class="literal">i</span> is <span class="literal">0</span> and <span class="literal">j</span> is greater than <span class="literal">0</span>, then we’re being asked to choose substrings from a one-character string to build a string with more than one character. That would be impossible!</p>
<p class="indent">There’s actually one more base case here <span class="ent">➌</span>, and it kicks in when characters <span class="literal">a[i]</span> and <span class="literal">b[j]</span> are not equal. In this case, we return <span class="literal">0</span> right away, because there’s no way to use that final character <span class="literal">a[i]</span> to match <span class="literal">b[j]</span>.</p>
<p class="indent">Now we arrive at the code for implementing each of the two categories. Each one adds its contribution to the <span class="literal">total</span> variable.</p>
<p class="indent">For Category 1, we need a loop <span class="ent">➍</span> that tries each relevant ending point of <span class="literal">a</span>, adding the subproblem answers to <span class="literal">total</span> <span class="ent">➎</span>. We use the mod operator here as required by the problem description.</p>
<p class="indent">For Category 2, we don’t need a loop: we just solve the one subproblem that directly gives us the answer <span class="ent">➏</span>.</p>
<h5 class="h5">Collecting the Solutions</h5>
<p class="noindent">We need to call <span class="literal">solve_ijk</span> using all values of <span class="literal">i</span>. That’s because any character of <span class="literal">a</span> might match the rightmost character of <span class="literal">b</span>. The code that calls <span class="literal">solve_ijk</span> in the needed ways is in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>.<span epub:type="pagebreak" id="page_144"/></p>
<pre>int solve(char a[], char b[], int a_length, int b_length,
          int num_substrings) {
  int i, j, k, result;
  static int memo[MAX_A][MAX_B][MAX_K + 1];
  for (i = 0; i &lt; a_length; i++)
    for (j = 0; j &lt; b_length; j++)
      for (k = 0; k &lt;= num_substrings; k++)
        memo[i][j][k] = -1;
  result = 0;
  for (i = 0; i &lt; a_length; i++) {
    result = result + solve_ijk(a, b, i, b_length - 1, num_substrings, memo);
    result = result % MOD;
  }
  return result;
}</pre>
<p class="excap" id="ch04ex07"><em>Listing 4-7: Solution 1</em></p>
<p class="indent">In our prior dynamic-programming problems, we used <span class="literal">min</span> or <span class="literal">max</span> to find the best solution. But notice in <a href="ch04.xhtml#ch04ex06">Listing 4-6</a> and <a href="ch04.xhtml#ch04ex07">Listing 4-7</a> that we’re not doing that. Instead, because we want to find the total number of solutions, we are adding everything together using <span class="literal">+</span>.</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">The <span class="literal">main</span> function for this solution is in <a href="ch04.xhtml#ch04ex08">Listing 4-8</a>.</p>
<pre>int main(void) {
  int a_length, b_length, num_substrings;
  char a[MAX_A + 1], b[MAX_B + 1];
  scanf("%d%d%d", &amp;a_length, &amp;b_length, &amp;num_substrings);
  scanf("%s", a);
  scanf("%s", b);
  printf("%d\n", solve(a, b, a_length, b_length, num_substrings));
  return 0;
}</pre>
<p class="excap" id="ch04ex08"><em>Listing 4-8: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">Now we have a complete solution to this problem. Feel free to submit to the judge.</p>
<p class="indent">Prepare to be disappointed.</p>
<h4 class="h4" id="sec64"><em>Solution 2: Adding More Subproblems</em></h4>
<p class="noindent">For the first time in this book, we have received a “Time-Limit Exceeded” error when using memoization. The thing is, even if we use memoization or dynamic programming, we may still have to be concerned with the efficiency of our algorithm. Some problems admit multiple such solutions that, <span epub:type="pagebreak" id="page_145"/>while faster than exponential time, may still differ from each other in terms of their efficiency.</p>
<h5 class="h5">Runtime of Solution 1</h5>
<p class="noindent">Let’s use <em>m</em> for the length of the source string, <em>n</em> for the length of the target string, and <em>k</em> for the number of substrings we need to take. There are a total of about <em>mnk</em> subproblems that our solution may end up solving. For each, we get hammered by Category 1 solutions, which require that we loop through the source string, adding another factor of <em>m</em> to our runtime. What we have, then, is an algorithm that takes a number of steps proportional to <em>m</em><sup>2</sup><em>nk</em>. To see how bad this is, let’s substitute the maximum values for these variables here: 1,000 for <em>m</em>, 200 for <em>n</em>, and 200 for <em>k</em>. This will give us 1,000<sup>2</sup> × 200 × 200 = 40,000,000,000. Forty billion! And we need to get all of this done with a two-second time limit? Not gonna happen. We need to do better. As we’ll see, we’ll be able to drop one of the factors of <em>m</em> and solve this thing in just <em>O</em>(<em>mnk</em>) time.</p>
<p class="indent">There are two general strategies we might consider at this point. The first is to throw our existing subproblems away and try again with new subproblems. I tried doing that; you can check the online resources for this book to see what I came up with. It didn’t help.</p>
<p class="indent">Throwing those subproblems away in this case is a needlessly drastic move. After all, we have a correct and reasonably efficient solution; the only hitch is the loop that we need for each subproblem in Category 1.</p>
<p class="indent">The second strategy, and the one that we will succeed with here, is to add new subproblems to our existing subproblems. This second strategy may seem counterintuitive. You might reason that if our program is already too slow, adding and solving more subproblems would just slow us down even further. But what if our new subproblems in fact helped us solve our existing subproblems faster? In particular, what if they gave us a way to solve subproblems from Category 1 without the need of a loop? And what if we could also solve those new subproblems efficiently? Then we’d be golden! We’ll be solving more subproblems, yes, but we’ll make up for it bigtime with how efficiently we can solve each subproblem. Let’s try!</p>
<h5 class="h5">The New Subproblems</h5>
<p class="noindent">Remember this bit of code from <a href="ch04.xhtml#ch04ex06">Listing 4-6</a>?</p>
<pre>for (q = 0; q &lt; i; q++)
  total = (total + solve_ijk(a, b, q, j - 1, k - 1, memo)) % MOD;</pre>
<p class="noindent">That’s the loop that adds up all of the ways in Category 1. It’s the loop we need to eliminate.</p>
<p class="indent">This <span class="literal">q</span> loop keeps <span class="literal">j - 1</span> and <span class="literal">k - 1</span> fixed, and varies the first subproblem parameter from <span class="literal">0</span> to <span class="literal">i - 1</span>. That is, it solves the 0, <em>j</em> – 1, <em>k</em> – 1 subproblem, then the 1, <em>j</em> – 1, <em>k</em> – 1 subproblem, then the 2, <em>j</em> – 1, <em>k</em> – 1 subproblem, and so on.</p>
<p class="indent">How awesome would it be if we could look up, in one shot, the sum of all of these subproblem answers? Then we wouldn’t need the <span class="literal">q</span> loop at all. This is what our new subproblems are going to do for us. For example, a <span epub:type="pagebreak" id="page_146"/>new subproblem with parameters <em>i</em> = 4, <em>j</em>, and <em>k</em> will be the sum of five of our old subproblems: the ones with the same <em>j</em> and <em>k</em> values, but where <em>i</em> is 0, 1, 2, 3, or 4. That is, the new subproblems drop the requirement that <em>a</em>[<em>i</em>] is the same character as <em>b</em>[<em>j</em>]. Here are the definitions for both our old and new subproblems.</p>
<p class="noindenta"><strong>Old</strong></p>
<p class="block95">The old subproblem with parameters <em>i</em>, <em>j</em>, and <em>k</em> is going to tell us the number of ways that we can choose exactly <em>k</em> substrings from <em>a</em>[0..<em>i</em>] to build exactly <em>b</em>[0..<em>j</em>], with the restriction that the rightmost substring ends with exactly the character <em>a</em>[<em>i</em>].</p>
<p class="noindenta"><strong>New</strong></p>
<p class="block95">The new subproblem with parameters <em>i</em>, <em>j</em>, and <em>k</em> is going to tell us the number of ways that we can choose exactly <em>k</em> substrings from <em>a</em>[0..<em>i</em>] to build exactly <em>b</em>[0..<em>j</em>].</p>
<p class="indenta">Now, with these new subproblems, let’s return to our running example. What’s our answer for the new subproblem with <em>i</em> = 6, <em>j</em> = 3, and <em>k</em> = 3? This time it really is 11! The subproblem is asking, with no restrictions, for all the ways that we can choose exactly three substrings from <em>a</em> to build <em>b</em>. And we know that there are 11 of them. Notice, as a nice side bonus here, that we no longer need to solve multiple subproblems as in <a href="ch04.xhtml#ch04ex07">Listing 4-7</a>. All we need is the answer to one subproblem: the one that includes all characters of <em>a</em>, all characters of <em>b</em>, and the number of substrings <em>k</em>.</p>
<h5 class="h5">Solving the Needed Subproblem</h5>
<p class="noindent">Let’s jump to the new code. For each triple of values <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">k</span>, we’re going to store answers not for one, but for two subproblems. We’ll use a C struct to collect both:</p>
<pre>typedef struct pair {
  int end_at_i;
  int total;
} pair;</pre>
<p class="indent">The <span class="literal">end_at_i</span> member will store the number of solutions for our old subproblems (the ones from Solution 1), and the <span class="literal">total</span> member will store the number of solutions for our new subproblems. Our <span class="literal">memo</span> array stays as a three-dimensional array, with each element now consisting of both <span class="literal">end_at_i</span> and <span class="literal">total</span>. Other possible designs include two separate three-dimensional memo arrays or a four-dimensional array where the new dimension is of length 2.</p>
<p class="indent">Now we can write the code that will solve both our old and new subproblems.</p>
<p class="indent">In all of our memoization and dynamic-programming code thus far, we had to figure out one answer for each setting of the subproblem parameters. But here we need to figure out two, one for each member of the struct. Look out for that as you read through the code. Check it out in <a href="ch04.xhtml#ch04ex09">Listing 4-9</a>.<span epub:type="pagebreak" id="page_147"/></p>
<pre>pair solve(char a[], char b[], int i, int j, int k,
           pair memo[MAX_A][MAX_B][MAX_K + 1]) {
  int total, end_at_i;
  if (memo[i][j][k].total != -1)
    return memo[i][j][k];
  if (j == 0 &amp;&amp; k == 1) {
 <span class="ent">❶</span> if (a[i] != b[j]) {
      if (i == 0)
        total = 0;
      else
     <span class="ent">➋</span> total = solve(a, b, i - 1, j, k, memo).total;
   <span class="ent">➌</span> memo[i][j][k] = (pair){0, total};
    } else {
      if (i == 0)
        total = 1;
      else
        total = 1 + solve(a, b, i - 1, j, k, memo).total;
      memo[i][j][k] = (pair){1, total};
    }
    return memo[i][j][k];
  }
  if (i == 0 || j == 0 || k == 0) {
    memo[i][j][k] = (pair){0, 0};
    return memo[i][j][k];
  }
  if (a[i] != b[j])
    end_at_i = 0;
  else {
  <span class="ent">➍</span> end_at_i = (solve(a, b, i - 1, j - 1, k - 1, memo).total +
              <span class="ent">➎</span> solve(a, b, i - 1, j - 1, k, memo).end_at_i);
     end_at_i = end_at_i % MOD;
  }
<span class="ent">➏</span> total = (end_at_i + solve(a, b, i - 1, j, k, memo).total) % MOD;
   memo[i][j][k] = (pair){end_at_i, total};
   return memo[i][j][k];
}</pre>
<p class="excap" id="ch04ex09"><em>Listing 4-9: Solution 2</em></p>
<p class="indent">As in Solution 1, a critical case here is when <span class="literal">j</span> is <span class="literal">0</span> and <span class="literal">k</span> is <span class="literal">1</span>. There are two important subcases to consider.</p>
<p class="indent">Let’s begin with the one where <span class="literal">a[i]</span> and <span class="literal">b[j]</span> are different characters <span class="ent">➊</span>. We know that the <span class="literal">end_at_i</span> number of solutions is <span class="literal">0</span> here, as it would be in Solution 1. But the <span class="literal">total</span> number of solutions might not be 0. For example, if <span class="literal">i</span> were <span class="literal">4</span> and each of the first three characters of <span class="literal">a</span> were the same as <span class="literal">b[0]</span>, then our answer would be <span class="literal">3</span> here. To get them all, we make a recursive call to find the total number of matches using the characters from <span class="literal">a</span> up to index <span epub:type="pagebreak" id="page_148"/><span class="literal">i - 1</span> <span class="ent">➋</span>. We then store in our <span class="literal">memo</span> array both the <span class="literal">total</span> answer that we calculated and the <span class="literal">end_at_i</span> answer of <span class="literal">0</span> <span class="ent">➌</span>.</p>
<p class="indent">Our handling of the subcase where <span class="literal">a[i]</span> and <span class="literal">b[j]</span> are the same character is similar; we just need to add 1 to both <span class="literal">end_at_i</span> and <span class="literal">total</span> to account for the match between <span class="literal">a[i]</span> and <span class="literal">b[j]</span>.</p>
<p class="indent">Now let’s work on how to solve the current <span class="literal">end_at_i</span> subproblem. Recall that Category 1 involves using <em>a</em>[<em>i</em>] as the final substring, and Category 2 involves using at least two characters for the final substring.</p>
<p class="indent">It’s easier to talk through Category 2, so let’s do that one first. That code is nearly the same as before: we retrieve the number of <span class="literal">end_at_i</span> solutions using the subproblem parameters <span class="literal">i - 1</span>, <span class="literal">j - 1</span>, and <span class="literal">k</span> <span class="ent">➎</span>.</p>
<p class="indent">What about our new code for Category 1? This is our moment of victory, because we can solve such a subproblem in a single step <span class="ent">➍</span> by looking up the needed <span class="literal">total</span> subproblem directly!</p>
<p class="indent">There’s one final thing that we need to do. After all, we have those new <span class="literal">total</span> subproblems now. It’s our responsibility to solve those, too, so that they’re correct when we look them up. Fortunately, we’ll be able to solve each <span class="literal">total</span> subproblem quickly as well. To do it, we make use of the fact that we just found the number of solutions that use <span class="literal">a[i]</span>. We can just add that to the old total for <span class="literal">i - 1</span> to get our final total <span class="ent">➏</span>.</p>
<p class="indent">There’s a nice interplay here between the <span class="literal">end_at_i</span> subproblems and the <span class="literal">total</span> subproblems in that we use each to efficiently solve the other. This is the core reason why adding our new <span class="literal">total</span> subproblems helped us: they speed up the computation of the <span class="literal">end_at_i</span> subproblems and, having quickly solved the relevant <span class="literal">end_at_i</span> subproblem, we can repay the favor and quickly solve the <span class="literal">total</span> subproblem as well.</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">All we need now is our <span class="literal">main</span> function. See the code in <a href="ch04.xhtml#ch04ex010">Listing 4-10</a>.</p>
<pre>int main(void) {
  int a_length, b_length, num_substrings, i, j, k, result;
  char a[MAX_A + 1];
  char b[MAX_B + 1];
  static pair memo[MAX_A][MAX_B][MAX_K + 1];
  scanf("%d%d%d", &amp;a_length, &amp;b_length, &amp;num_substrings);
  scanf("%s", a);
  scanf("%s", b);
  for (i = 0; i &lt; a_length; i++)
    for (j = 0; j &lt; b_length; j++)
      for (k = 0; k &lt;= num_substrings; k++)
        memo[i][j][k] = (pair){-1, -1};
  result = solve(a, b, a_length - 1, b_length - 1, num_substrings, memo).total;
  printf("%d\n", result);
  return 0;
}</pre>
<p class="excap" id="ch04ex010"><em>Listing 4-10: The</em> <span class="codeitalic1">main</span> <em>function</em><span epub:type="pagebreak" id="page_149"/></p>
<p class="indent">If you submit this solution to the judge, you should be able to pass all test cases in time.</p>
<h3 class="h3" id="lev30">Summary</h3>
<p class="noindent">In this chapter, we’ve learned that dynamic-programming problems can be solved forward or backward, and that sometimes it matters a great deal which we choose. We’ve also learned that our initial solution approach may not be fast enough, at which point we need to reconsider our subproblems or add new subproblems.</p>
<p class="indent">Can’t get enough of this? You may be happy to know that ideas related to dynamic programming often make cameos in other algorithms. In the next chapter, for example, you’ll see that we’ll once again store results for later lookup. And in <a href="ch07.xhtml">Chapter 7</a>, you’ll see a problem in which dynamic programming plays a supporting role, speeding up computation required by the main algorithm of interest.</p>
<h3 class="h3" id="lev31">Notes</h3>
<p class="noindent">The Jumper is originally from the 2007 Croatian Regional Competition in Informatics. Ways to Build is originally from the 2015 National Olympiad in Informatics in Provinces.<span epub:type="pagebreak" id="page_150"/></p>
</body></html>