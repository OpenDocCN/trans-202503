- en: '**18**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18**'
- en: '**ADVANCED TEXT MAGIC**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级文本魔法**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: Although pictures of blue skies and green fields are prettier to look at than
    a screen full of words, many useful programs, such as Facebook, Twitter, and Words
    with Friends, work with text. That’s why Small Basic provides the `Text` object
    for working with text. In this chapter, you’ll learn how to use the `Text` object
    to find the length of a string, extract a small portion of a string, and perform
    many other advanced string-processing tasks. You’ll also write your own string-processing
    subroutines and apply what you learn to create some interesting applications,
    like a pig latin translator and a word scramble game!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然蓝天和绿地的图片比一屏文字更让人赏心悦目，但许多实用的程序，如 Facebook、Twitter 和 Words with Friends，都是处理文本的。这就是为什么
    Small Basic 提供了 `Text` 对象来处理文本的原因。在本章中，你将学习如何使用 `Text` 对象来查找字符串的长度、提取字符串的一小部分，并执行许多其他高级的字符串处理任务。你还将编写自己的字符串处理子程序，并将所学应用于创建一些有趣的应用程序，比如猪拉丁语翻译器和文字拼图游戏！
- en: '**The Text Object**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文本对象**'
- en: You’ve been working with strings throughout this book. To recap, a *string*
    is a sequence of characters that is enclosed between double quotes, such as `"stringY
    strinGy striNg strIng stRing"`. These characters can include letters (both uppercase
    and lowercase), digits (0 to 9), and other symbols on your keyboard (such as +,
    –, &, @, and so on). You can use strings in your programs to store names, addresses,
    phone numbers, book titles, names of *Star Trek* episodes, and more. The `Text`
    object contains many useful methods for working with strings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中一直在处理字符串。为了回顾一下，*字符串* 是由字符组成的序列，这些字符被双引号包围，例如 `"stringY strinGy striNg
    strIng stRing"`。这些字符可以包括字母（大写和小写）、数字（0 到 9）和其他键盘上的符号（如 +、–、&、@ 等）。你可以在程序中使用字符串来存储姓名、地址、电话号码、书名、*星际迷航*剧集的名称等。`Text`
    对象包含许多有用的方法来处理字符串。
- en: '[Figure 18-1](ch18.html#ch18fig1) shows the complete list of the `Text` object’s
    methods. We’ve divided these methods into four groups that we’ll discuss in the
    following sections.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](ch18.html#ch18fig1) 显示了 `Text` 对象方法的完整列表。我们将这些方法分成四组，在接下来的章节中进行讨论。'
- en: '![image](graphics/f18-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-01.jpg)'
- en: '*Figure 18-1: The* `Text` *object’s methods*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-1：* `Text` *对象的方法*'
- en: '***Appending Strings and Getting Their Length***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***追加字符串并获取它们的长度***'
- en: Combining strings and finding their length is a common task in programming.
    Let’s look at how the `Text` object can help you out.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 结合字符串并查找它们的长度是编程中的常见任务。让我们来看一下 `Text` 对象如何帮助你完成这些任务。
- en: '**Appending Strings**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**追加字符串**'
- en: 'The `Append()` method can join (or *append*) two strings together, as shown
    in the following example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Append()` 方法可以将两个字符串连接（或 *追加*）在一起，如以下示例所示：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Earlier in the book, you learned how to join strings using the + sign. But
    the `Append()` method is useful when you have text that the + sign treats as numbers,
    as shown in the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早些时候，你学习了如何使用 + 符号连接字符串。但当你处理的文本被 + 符号当作数字来处理时，`Append()` 方法就显得尤为有用，如以下示例所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first statement appends the two strings (`"1"` and `"5"`) and assigns the
    result to the variable `res` (short for *result*). The output of the second statement
    shows that the string `"5"` was appended to the string `"1"`, resulting in a new
    string `"15"`. The third statement shows that you can’t do this concatenation
    using the + sign. The + operator interprets its two operands as numbers (1 and
    5) and adds these numbers together, which is why the third statement displays
    `6`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句将两个字符串（`"1"` 和 `"5"`）连接起来，并将结果赋值给变量 `res`（*result* 的缩写）。第二条语句的输出显示，字符串
    `"5"` 被追加到了字符串 `"1"` 后面，得到一个新字符串 `"15"`。第三条语句显示，你不能使用 + 符号进行这种连接。+ 操作符将其两个操作数解释为数字（1
    和 5），并将这两个数字相加，这就是为什么第三条语句显示 `6`。
- en: Using `Append()` is the only way to concatenate numbers in Small Basic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Small Basic 中，使用 `Append()` 是连接数字的唯一方法。
- en: '**Getting the Length of a String**'
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取字符串的长度**'
- en: 'The number of characters in a string makes up its length. To find the length
    of a string, you can use the `GetLength()` method, as in the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的字符数量就是它的长度。要查找字符串的长度，你可以使用 `GetLength()` 方法，如以下示例所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`GetLength()` treats its argument as a string and returns the number of characters
    in that string. Line 1 shows that an empty string has zero length. Line 2 shows
    that the length of the string `"Careless Bears"` is 14, because this string contains
    14 characters (spaces are characters too). Line 3 calls `GetLength()` using the
    number 1023 as an argument. `GetLength()` treats this number as a string (`"1023"`)
    and returns `4` as the length of this string. A similar process happens in line
    4 for the number –101.5, where `GetLength()` returns `6` (four digits, the minus
    sign, and the decimal point).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLength()`将它的参数视为字符串，并返回该字符串中的字符数。第1行显示空字符串的长度为0。第2行显示字符串`"Careless Bears"`的长度为14，因为这个字符串包含14个字符（空格也算作字符）。第3行使用数字1023作为参数调用`GetLength()`。`GetLength()`将这个数字视为字符串（`"1023"`），并返回`4`，表示该字符串的长度。第4行的类似过程适用于数字–101.5，`GetLength()`返回`6`（包括四个数字、负号和小数点）。'
- en: '**TRY IT OUT 18-1**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 18-1**'
- en: 'Write a program that prompts the user to enter an adjective. Have the program
    display the corresponding adverb by appending *ly* to the input. For example,
    if the user enters *mad*, the program displays *madly*. Will this program work
    for all adjectives? (Hint: consider adjectives ending in *y*, such as *happy*,
    or adjectives ending in *ic*, such as *heroic*.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，提示用户输入一个形容词。让程序通过在输入后面附加*ly*来显示相应的副词。例如，如果用户输入*mad*，程序将显示*madly*。这个程序能适用于所有形容词吗？（提示：考虑以*y*结尾的形容词，如*happy*，或以*ic*结尾的形容词，如*heroic*。）
- en: '***Taking Strings Apart: Substrings***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拆分字符串：子字符串***'
- en: Just as you can join strings to create longer ones, you can also separate strings
    into smaller strings, which are called *substrings*. A substring is just a portion
    of a larger string. The `Text` object has six methods that let you work with substrings.
    Let’s look at these methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以将字符串连接起来创建更长的字符串一样，你也可以将字符串分割成更小的字符串，这些被称为*子字符串*。子字符串只是一个较大字符串的一部分。`Text`对象有六个方法可以让你处理子字符串。让我们来看一下这些方法。
- en: '**The IsSubText() Method**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**IsSubText() 方法**'
- en: 'You can use `IsSubText()` to find out if one string is part of another. This
    method takes two arguments: the string you want to search through and the substring
    you want to search for. It returns `"True"` or `"False"` depending on whether
    the substring is in the source string. Here are some examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`IsSubText()`来判断一个字符串是否是另一个字符串的一部分。这个方法有两个参数：你想要搜索的字符串和你想要查找的子字符串。它会返回`"True"`或`"False"`，取决于子字符串是否在源字符串中。以下是一些示例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As these examples show, `IsSubText()` is case sensitive when it searches for
    substrings. This is why searching for `"BROWN"` in line 3 returns `"False"`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些示例所示，`IsSubText()`在搜索子字符串时是区分大小写的。这就是为什么在第3行搜索`"BROWN"`返回`"False"`。
- en: '**The EndsWith() Method**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**EndsWith() 方法**'
- en: 'Use `EndsWith()` to find out if a string ends with a given substring. Here
    are some examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EndsWith()`来判断一个字符串是否以给定的子字符串结束。以下是一些示例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, the string’s case matters: the search for `"FOX"` in line 4 returns
    `"False"`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，字符串的大小写很重要：在第4行搜索`"FOX"`返回`"False"`。
- en: '**The StartsWith() Method**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**StartsWith() 方法**'
- en: 'Use `StartsWith()` to find out if a string starts with a given substring. Here
    are some examples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StartsWith()`来判断一个字符串是否以给定的子字符串开始。以下是一些示例：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similarly, the search for `"the"` in line 4 returns `"False"`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在第4行中搜索`"the"`返回的是`"False"`。
- en: '**The GetSubText() Method**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GetSubText() 方法**'
- en: 'To extract text from any position in a string, you can use `GetSubText()`.
    This method takes three arguments: the source string to get your substring from,
    the starting position of the substring, and the length of the substring you want.
    To understand how this method works, look at [Figure 18-2](ch18.html#ch18fig2).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中的任何位置提取文本，你可以使用`GetSubText()`。这个方法有三个参数：你要从中获取子字符串的源字符串、子字符串的起始位置以及你想要的子字符串的长度。要理解这个方法如何工作，请参见[图18-2](ch18.html#ch18fig2)。
- en: '![image](graphics/f18-02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-02.jpg)'
- en: '*Figure 18-2: Illustrating character positions in strings*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-2：字符串中字符位置的示意图*'
- en: 'The first character has a position of 1, the second character has a position
    of 2, and so on. Now consider the following examples:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符的位置是1，第二个字符的位置是2，以此类推。现在考虑以下示例：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Line 2 gets a substring of length 3 starting at position 1, which returns the
    string `"The"`. Line 3 fails to get a substring that starts at position 0, because
    the first valid position is 1\. Instead, it returns an empty string. Line 4 gets
    the three-letter substring that starts at position 17, which returns `"fox"`.
    Line 5 requests a substring of length 4 starting at position 17\. Because that
    substring extends beyond the end of the string, the length is cut short, and the
    method returns `"fox"`, whose length is 3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行获取从位置1开始，长度为3的子字符串，返回字符串`"The"`。第3行未能获取从位置0开始的子字符串，因为第一个有效位置是1，而它返回一个空字符串。第4行获取从位置17开始的三字母子字符串，返回`"fox"`。第5行请求从位置17开始的长度为4的子字符串。因为该子字符串超出了字符串的末尾，长度被截短，方法返回`"fox"`，其长度为3。
- en: 'You can use `GetSubText()` inside a `For` loop to access the individual characters
    of a string. For example, the following code writes each character of `strIn`
    on a new line. Enter and run this code to make sure you understand how it works:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`For`循环中使用`GetSubText()`来访问字符串的每个字符。例如，以下代码将`strIn`的每个字符写在新的一行上。输入并运行这段代码，确保你理解它是如何工作的：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The loop counter, `N`, runs from 1 to the end of the string. Each iteration
    requests a substring of length 1 (a single character) that starts at position
    `N` and displays that character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 循环计数器`N`从1运行到字符串的末尾。每次迭代请求一个长度为1（即一个字符）的子字符串，起始位置为`N`，并显示该字符。
- en: '**The GetSubTextToEnd() Method**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GetSubTextToEnd() 方法**'
- en: 'The `GetSubTextToEnd()` method is similar to `GetSubText()`, except it returns
    a substring from one position all the way to the end of the string. It takes two
    arguments: the source string that you want to get your substrings from and the
    starting position of the substring. Here are some examples (refer to [Figure 18-2](ch18.html#ch18fig2)
    for context):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSubTextToEnd()`方法与`GetSubText()`类似，不同之处在于它返回从某个位置到字符串结尾的子字符串。它接受两个参数：你希望从中提取子字符串的源字符串和子字符串的起始位置。这里有一些示例（请参考[图18-2](ch18.html#ch18fig2)以获取上下文）：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Line 2 gets the substring starting at position 17, which returns `"own fox"`.
    Line 3 gets the substring starting at position 19, which returns `"x"`. Line 4
    requests the substring starting at position 20\. Because the source string contains
    only 19 characters, this method returns an empty string.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行获取从位置17开始的子字符串，返回`"own fox"`。第3行获取从位置19开始的子字符串，返回`"x"`。第4行请求从位置20开始的子字符串。由于源字符串只有19个字符，该方法返回空字符串。
- en: '**The GetIndexOf() Method**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GetIndexOf() 方法**'
- en: 'You pass the `GetIndexOf()` method the substring you want to search for, and
    it returns the index position of that substring in the source text. Here are some
    examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要传递给`GetIndexOf()`方法的是你希望搜索的子字符串，它会返回该子字符串在源文本中的索引位置。以下是一些示例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The search is case sensitive, so line 4 returns `0` because `"QUICK"` isn’t
    found in the source string. Line 5 requests the index of the letter *o*, but because
    there are two, it gives you the index of the first one it finds. The last line
    returns `0` because it doesn’t find `"dog"` in the source string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是区分大小写的，因此第4行返回`0`，因为在源字符串中没有找到`"QUICK"`。第5行请求字母*o*的索引，但由于有两个`o`，它返回第一个找到的`o`的索引。最后一行返回`0`，因为它没有在源字符串中找到`"dog"`。
- en: '**TRY IT OUT 18-2**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手试试 18-2**'
- en: 'A young boy named Franklin Roosevelt once signed letters to his mother backward:
    *Tlevesoor Nilknarf*. Write a program that displays the characters of an input
    string in reverse order. (Hint: start a loop that counts from the string’s length
    down to 1, and use `GetSubText()` to extract each character.)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名叫富兰克林·罗斯福的小男孩曾经把写给母亲的信签名倒着写：*Tlevesoor Nilknarf*。写一个程序，反向显示输入字符串的字符。（提示：从字符串的长度开始，循环计数直到1，并使用`GetSubText()`提取每个字符。）
- en: '***Changing Case***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***改变大小写***'
- en: Sometimes you might want to display strings in uppercase or lowercase letters.
    The `ConvertToLowerCase()` and `ConvertToUpperCase()` methods can do that for
    you. Run the example in [Listing 18-1](ch18.html#ch18ex1).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想要将字符串显示为大写或小写字母。`ConvertToLowerCase()`和`ConvertToUpperCase()`方法可以帮助你做到这一点。运行[清单18-1](ch18.html#ch18ex1)中的示例。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 18-1: Changing the case of a string*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-1：改变字符串的大小写*'
- en: The call to `ConvertToLowerCase()` on line 3 returns the lowercase string `"ewok"`,
    which is displayed on line 4\. The statement on line 5 shows that the original
    string isn’t affected by the lowercase conversion; calling `ConvertToLowerCase()`
    returns a brand-new string whose characters are lowercase. The `ConvertToUpperCase()`
    method on line 6 returns the uppercase version of `"EWOK"`, which is displayed
    on line 7\. And line 8 also shows that the original string isn’t affected by the
    conversion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行调用`ConvertToLowerCase()`方法返回小写字符串“ewok”，并在第4行显示。第5行的语句显示原始字符串没有受到小写转换的影响；调用`ConvertToLowerCase()`返回一个全新的小写字符字符串。第6行的`ConvertToUpperCase()`方法返回大写版本的“EWOK”，并在第7行显示。第8行也显示原始字符串未受转换的影响。
- en: You can use these methods to make case-insensitive string comparisons. For example,
    let’s say your program asks a user about their favorite *Shrek* character. If
    the user likes Donkey, they win 200 points; otherwise, they win 100 points. The
    user can enter `donkey`, `DONKEY`, `Donkey`, `DOnkey`, or any other combination
    of cases in response to the question. Rather than checking for all the possible
    combinations, you can convert the user’s response to uppercase (or lowercase)
    and compare the result with that new string `"DONKEY"` (or `"donkey"` if you’re
    using lowercase). Run the program in [Listing 18-2](ch18.html#ch18ex2).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些方法来进行不区分大小写的字符串比较。例如，假设你的程序询问用户他们最喜欢的*史瑞克*角色。如果用户喜欢驴子，他们赢得200分；否则，他们赢得100分。用户可以输入`donkey`、`DONKEY`、`Donkey`、`DOnkey`，或任何其他大小写组合来回答问题。与其检查所有可能的组合，不如将用户的回答转换为大写（或小写），然后将结果与新的字符串“DONKEY”（或“donkey”，如果你使用小写的话）进行比较。在[清单18-2](ch18.html#ch18ex2)中运行程序。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 18-2: Case-insensitive string matching*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-2：不区分大小写的字符串匹配*'
- en: 'The `Read()` method on line 4 reads the text entered by the user. The user’s
    text is then converted to uppercase, and the result is stored in the `name` variable.
    Note how we used the `Read()` method directly as an argument to `ConvertToUpperCase()`;
    this is equivalent to the following two statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行的`Read()`方法读取用户输入的文本。然后，用户的文本被转换为大写，并将结果存储在`name`变量中。请注意，我们直接将`Read()`方法作为`ConvertToUpperCase()`的参数；这相当于以下两行代码：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `If` statement on line 5 compares the uppercase version of the user’s input
    with the literal string `"DONKEY"` and awards the user accordingly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行的`If`语句将用户输入的内容转换为大写，并与字面字符串“DONKEY”进行比较，并相应地奖励用户。
- en: 'Here’s an output example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个输出示例：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**TRY IT OUT 18-3**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 18-3**'
- en: Write a program that prompts the user with a yes/no question, such as “Can you
    paint with all the colors of the wind?” Create a program that accepts *y*, *yes*,
    *n*, or *no* using any casing as valid answers. If the answer is invalid, ask
    the user to re-enter their answer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，向用户提出一个是/否问题，例如“你能用风的所有颜色来画画吗？”创建一个程序，接受 *y*、*yes*、*n* 或 *no*，无论大小写，作为有效答案。如果答案无效，要求用户重新输入。
- en: '***Character Coding with Unicode***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Unicode字符编码***'
- en: All computer data (including text) is stored as *binary* sequences of 0s and
    1s. The letter *A* for example is 01000001\. The mapping between a character and
    its binary representation is called *encoding*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算机数据（包括文本）都以*二进制*序列的0和1存储。例如，字母*A*的二进制表示是01000001。字符与其二进制表示之间的映射关系称为*编码*。
- en: '*Unicode* is a universal encoding scheme that lets you encode more than a million
    characters from many languages. Each character is assigned a unique number (called
    a *code point*). For example, the code point for the character `A` is 65, and
    the code point for the dollar sign (`$`) is 36\. The `GetCharacterCode()` method
    returns a character’s code point. But the `GetCharacter()` method does the opposite;
    when you give it a character’s code point, it returns the corresponding character.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode* 是一种通用编码方案，允许你对来自多种语言的超过一百万个字符进行编码。每个字符都会分配一个唯一的数字（称为*码点*）。例如，字符`A`的码点是65，美元符号（`$`）的码点是36。`GetCharacterCode()`方法返回字符的码点。但`GetCharacter()`方法正好相反；当你给它一个字符的码点时，它会返回相应的字符。'
- en: Run the program in [Listing 18-3](ch18.html#ch18ex3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单18-3](ch18.html#ch18ex3)中运行该程序。
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 18-3: Demonstrating the* `GetCharacterCode()` *method*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-3：演示`GetCharacterCode()`方法*'
- en: 'Line 2 defines a string that contains six characters. Line 3 starts a `For`
    loop that accesses each of these characters; `GetLength()` sets the upper limit
    of the loop. Each iteration of the loop reads one character from the string and
    saves it in a variable named `ch` (line 4). Then the loop gets the Unicode code
    point for that character and saves it in the `code` variable (line 5). Line 6
    displays the character and its code point. When you run this program, you’ll see
    the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 行定义了一个包含六个字符的字符串。第 3 行启动了一个 `For` 循环，访问这些字符中的每一个；`GetLength()` 设置了循环的上限。每次循环都会从字符串中读取一个字符并将其保存在名为
    `ch` 的变量中（第 4 行）。接着，循环获取该字符的 Unicode 代码点并将其保存在 `code` 变量中（第 5 行）。第 6 行显示该字符及其代码点。当你运行此程序时，你将看到以下输出：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Fancy Characters**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**花式字符**'
- en: Let’s explore some characters not used in English. [Listing 18-4](ch18.html#ch18ex4)
    shows a simple program that displays the symbols for 140 Unicode characters, starting
    with the character whose code point is 9728\. You can change this number to explore
    other Unicode symbols.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些在英语中未使用的字符。[清单 18-4](ch18.html#ch18ex4) 显示了一个简单的程序，它显示了 140 个 Unicode
    字符的符号，从代码点为 9728 的字符开始。你可以更改这个数字以探索其他 Unicode 符号。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 18-4: Demonstrating Unicode characters*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-4：演示 Unicode 字符*'
- en: The outer `For` loop runs seven times (line 8). Each time the outer loop runs,
    the inner loop displays 20 symbols that are placed 30 pixels apart (lines 10–15).
    After drawing a complete row of symbols, we move the vertical drawing position
    down 30 pixels to draw the next row (line 16). [Figure 18-3](ch18.html#ch18fig3)
    shows the output of this program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的 `For` 循环执行七次（第 8 行）。每次外部循环执行时，内部循环显示 20 个符号，这些符号之间相隔 30 像素（第 10–15 行）。绘制完整一行符号后，我们将垂直绘制位置下移
    30 像素，以绘制下一行（第 16 行）。[图 18-3](ch18.html#ch18fig3) 显示了该程序的输出。
- en: '![image](graphics/f18-03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-03.jpg)'
- en: '*Figure 18-3: The output of* UnicodeDemo.sb'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-3：* UnicodeDemo.sb 的输出'
- en: '**More on Code Points**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更多关于代码点的内容**'
- en: 'The Unicode code points for lowercase letters are consecutive integers from
    97 (*a*) to 122 (*z*). Similarly, the code points for uppercase letters range
    from 65 (*A*) to 90 (*Z*). The code point for a lowercase *a* is greater than
    the code point for an uppercase *A*, and the difference between the code points
    for *a* and *A* (97 – 65 = 32) is the same as the difference between the code
    points for *b* and *B* (98 – 66 = 32), and so on. When given the code point for
    a lowercase letter, which we’ll represent as `ch`, the code point for its corresponding
    uppercase letter is 65 + (`ch` – 97). Here’s the formula:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母的 Unicode 代码点是从 97（*a*）到 122（*z*）的连续整数。同样，大写字母的代码点范围从 65（*A*）到 90（*Z*）。小写字母
    *a* 的代码点大于大写字母 *A* 的代码点，且 *a* 和 *A* 之间的代码点差（97 - 65 = 32）与 *b* 和 *B* 之间的差（98 -
    66 = 32）相同，依此类推。当给定一个小写字母的代码点，我们用 `ch` 来表示，它对应的大写字母的代码点为 65 + (`ch` – 97)。这是公式：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that you know that each character in a string is identified by a code point,
    you can perform many useful operations on strings. The following examples show
    what you can do.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道字符串中的每个字符都有一个代码点，你可以对字符串执行许多有用的操作。以下示例展示了你可以做的操作。
- en: '**Displaying a Quotation Mark**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示引号**'
- en: 'Let’s say you want to display the string `"Bazinga"` with the double quotes
    included in the output. If you write `TextWindow.WriteLine("Bazinga")`, Small
    Basic displays `Bazinga` without the quotation marks because the quotation marks
    identify the start and end of a string. But Small Basic returns a syntax error
    if you write `TextWindow.WriteLine(""Bazinga"")`. So how do you display the quotation
    marks? By using the quotation mark’s code point, you can append the quotation
    mark characters to the string, as shown in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在输出中显示字符串 `"Bazinga"`，并包含双引号。如果你写 `TextWindow.WriteLine("Bazinga")`，Small
    Basic 会显示 `Bazinga`，但不包括引号，因为引号用来标识字符串的开始和结束。然而，如果你写 `TextWindow.WriteLine(""Bazinga"")`，Small
    Basic 会返回语法错误。那么如何显示引号呢？通过使用引号的代码点，你可以将引号字符附加到字符串中，如下所示的代码片段所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first statement gets the quotation mark character from its Unicode code
    point (34) and assigns it to the variable `QUO`. The second statement inserts
    the string `"Bazinga"` between two `QUO` characters to output the desired result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句从其 Unicode 代码点（34）获取引号字符，并将其赋值给变量 `QUO`。第二个语句将字符串 `"Bazinga"` 插入到两个 `QUO`
    字符之间，从而输出所需的结果。
- en: '**Creating a Multiline String**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建多行字符串**'
- en: 'You can create a multiline string by embedding the *line feed* character (code
    point 10) into a string. Enter the following code snippet as an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 *换行符* 字符（代码点 10）嵌入字符串中来创建多行字符串。输入以下代码片段作为示例：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you run this code, the two strings, `"Line1"` and `"Line2"`, are displayed
    on two lines. The result is identical to what you get when you use the following
    two statements:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，两个字符串 `"Line1"` 和 `"Line2"` 会显示在两行中。结果与使用以下两条语句时的输出完全相同：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Armed with the knowledge you’ve gained so far, you’re ready to create full-sized
    programs that use strings in all kinds of fancy ways!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你迄今为止获得的知识，你已经可以编写使用字符串进行各种复杂操作的完整程序了！
- en: '**TRY IT OUT 18-4**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**实践操作 18-4**'
- en: The following program displays the letters of the English alphabet. Explain
    how the program works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序显示英文字母。请解释该程序的工作原理。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Practical Examples with Strings**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串的实际示例**'
- en: Earlier you learned how to use `GetLength()` to get a string’s length and `GetSubText()`
    to access individual characters in a string. When you use these two methods with
    a `For` loop, you can count special characters, examine multiple characters, and
    do several other useful tasks with strings. Let’s explore some examples!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，你学习了如何使用 `GetLength()` 获取字符串的长度，以及如何使用 `GetSubText()` 访问字符串中的单个字符。当你将这两个方法与
    `For` 循环结合使用时，你可以计算特殊字符、检查多个字符，并进行其他几项有用的字符串操作。让我们来看一些示例！
- en: '***Counting Special Characters***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算特殊字符***'
- en: '[Listing 18-5](ch18.html#ch18ex5) shows a program that counts the number of
    vowels in a string. It asks the user to enter a string and then counts and displays
    the number of vowels in that string.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-5](ch18.html#ch18ex5)展示了一个计算字符串中元音字母数量的程序。它要求用户输入一个字符串，然后计算并显示该字符串中的元音字母数量。'
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 18-5: Counting the number of vowels in a string*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-5：计算字符串中元音字母的数量*'
- en: After getting the user’s input (lines 2–3), the program initializes the `count`
    variable to 0, because no vowels have been found so far (line 5). Then a loop
    starts to check the characters of the input string one by one (line 6). The loop
    counter `N` points to the *N*th character of the string.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户输入（第2–3行）后，程序将 `count` 变量初始化为 0，因为到目前为止还没有找到任何元音字母（第5行）。然后，程序启动一个循环，逐一检查输入字符串中的字符（第6行）。循环计数器
    `N` 指向字符串中的第 *N* 个字符。
- en: 'Line 7 gets the *N*th character of the input string using `GetSubText()` and
    assigns it to the variable `ch` (short for character). The code then converts
    the character to uppercase (line 8) and compares that uppercase letter with the
    vowel characters (line 9). If the character is a vowel, `count` increases by 1
    (line 10). When the loop ends, the program displays the number of vowels counted
    (lines 13–14). Here’s a sample output from this program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行使用 `GetSubText()` 获取输入字符串的第 *N* 个字符，并将其赋值给变量 `ch`（字符的简称）。接着，代码将字符转换为大写字母（第8行），并将这个大写字母与元音字母进行比较（第9行）。如果字符是元音字母，`count`
    的值就增加 1（第10行）。当循环结束时，程序会显示计算出的元音字母数量（第13–14行）。以下是该程序的示例输出：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**TRY IT OUT 18-5**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**实践操作 18-5**'
- en: Convert the code in [Listing 18-5](ch18.html#ch18ex5) into a game for two players.
    The first player enters a word, and the second player has to guess the number
    of vowels in the word. Then the players alternate turns. A player scores one point
    for each correct guess. End the game after 10 rounds and display the winner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 18-5](ch18.html#ch18ex5)中的代码转换成一个两人游戏。第一个玩家输入一个单词，第二个玩家需要猜出单词中元音字母的数量。然后，玩家轮流进行。每次猜对，玩家得一分。游戏进行
    10 轮后结束，并显示获胜者。
- en: '***Palindrome Number Checker***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文数字检查器***'
- en: In this section, we’ll write a program that checks whether an integer entered
    by a user is a *palindrome*. A palindrome is a number, word, or phrase that reads
    the same backward and forward. For example, *1234321* and *1122332211* are palindromes.
    Likewise, *racecar*, *Hannah*, and *Bob* are also palindromes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将编写一个程序，检查用户输入的整数是否为*回文*。回文是指正着读和反着读都一样的数字、单词或短语。例如，*1234321* 和 *1122332211*
    都是回文。同样，*racecar*、*Hannah* 和 *Bob* 也是回文。
- en: Let’s look at the input number `12344321` shown in [Figure 18-4](ch18.html#ch18fig4).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在[图 18-4](ch18.html#ch18fig4)中显示的输入数字 `12344321`。
- en: '![image](graphics/f18-04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-04.jpg)'
- en: '*Figure 18-4: Using two variables to check whether a number is a palindrome*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-4：使用两个变量检查一个数字是否是回文*'
- en: To check whether this number is a palindrome, you need to compare the first
    and eighth digits, the second and seventh digits, the third and sixth digits,
    and so on. If any two digits in the comparison aren’t equal, the number isn’t
    a palindrome. As the figure illustrates, you can access the digits you want to
    compare by using two variables (`pos1` and `pos2`), which move in opposite directions.
    The first variable (`pos1`) starts at the first digit and moves forward, and the
    second variable (`pos2`) starts at the last digit and moves backward. The number
    of required comparisons is at most one-half the number of digits in the input
    number. In this example, you need at most four comparisons because the input number
    has eight digits. The same logic applies if the input integer has an odd number
    of digits, because the digit in the middle of the number doesn’t need to be compared.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这个数字是否是回文数，你需要比较第一个和第八个数字，第二个和第七个数字，第三个和第六个数字，依此类推。如果在比较中有任何两个数字不相等，则该数字不是回文数。如图所示，你可以通过使用两个变量（`pos1`和`pos2`）来访问你想要比较的数字，这两个变量分别朝相反的方向移动。第一个变量（`pos1`）从第一个数字开始并向前移动，第二个变量（`pos2`）从最后一个数字开始并向后移动。所需比较的次数最多为输入数字中数字个数的一半。在这个例子中，你最多需要进行四次比较，因为输入的数字有八个数字。如果输入的整数数字位数为奇数，则中间的数字无需比较，因为它不影响回文数的判断。
- en: '[Listing 18-6](ch18.html#ch18ex6) shows the complete program. The comments
    should help you understand how the program works.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-6](ch18.html#ch18ex6)展示了完整的程序。注释应该能帮助你理解程序是如何工作的。'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 18-6: Testing whether a number input by the user is a palindrome*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-6：测试用户输入的数字是否为回文数*'
- en: 'Here’s a sample run of this program:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的一次示例运行：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**TRY IT OUT 18-6**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个 18-6**'
- en: Another way to create the program in [Listing 18-6](ch18.html#ch18ex6) is to
    reverse the input string and then compare the reversed string with the original.
    Create a new palindromechecker program using this method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建[清单 18-6](ch18.html#ch18ex6)中程序的方法是反转输入字符串，然后将反转后的字符串与原始字符串进行比较。使用这种方法创建一个新的回文检查程序。
- en: '***Igpay Atinlay***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***猪拉丁语***'
- en: Let’s teach the computer a language game called *pig latin*. The rules for creating
    pig latin words are simple. To convert a word into pig latin, move the first letter
    to the end and add the letters *ay* after it. So, the word *talk* becomes *alktay*,
    *fun* becomes *unfay*, and so on. Can you decipher the original title of this
    section?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们教计算机一种语言游戏，叫做 *猪拉丁语*。创建猪拉丁语单词的规则很简单。要将一个单词转换成猪拉丁语，将第一个字母移到单词的末尾，并在后面加上字母
    *ay*。所以，单词 *talk* 变成 *alktay*，*fun* 变成 *unfay*，以此类推。你能解密这一节的原始标题吗？
- en: '[Figure 18-5](ch18.html#ch18fig5) shows the strategy you’ll use to convert
    a word into pig latin, using the word *basic*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-5](ch18.html#ch18fig5)展示了将一个单词转换为猪拉丁语时使用的策略，使用的是单词 *basic*。'
- en: '![image](graphics/f18-05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-05.jpg)'
- en: '*Figure 18-5: Translating an English word into pig latin*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-5：将英文单词翻译成猪拉丁语*'
- en: You first extract the substring from the second character to the end and assign
    it to the output string. You then add the first letter in the input string to
    the output, followed by *ay*. Enter the code in [Listing 18-7](ch18.html#ch18ex7)
    to implement these steps.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先从第二个字符到末尾提取子字符串，并将其赋值给输出字符串。然后，你将输入字符串的第一个字母加到输出字符串中，后跟 *ay*。在[清单 18-7](ch18.html#ch18ex7)中输入代码以实现这些步骤。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 18-7: Converting a word entered by the user into pig latin*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-7：将用户输入的单词转换为猪拉丁语*'
- en: The program runs an infinite loop to allow the user to try different words (line
    4). After reading the input word from the user (line 6), we extract the substring
    that starts at position 2 (that is, from the second character to the end of the
    input word) and assign it to `pigLatin`. Then we extract the first letter from
    `word` and append it to `pigLatin` (line 9), followed by `ay` (line 10). We display
    the pig latin word (line 11), followed by an empty line (line 12) and go for another
    round. *Ongratulationscay! Ouyay inishedfay ouryay rogrampay!*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序运行一个无限循环，允许用户尝试不同的单词（第4行）。在读取用户输入的单词后（第6行），我们提取从位置2开始的子字符串（即从第二个字符到输入单词的末尾），并将其赋值给`pigLatin`。然后我们从`word`中提取第一个字母并将其附加到`pigLatin`（第9行），接着加上`ay`（第10行）。我们显示猪拉丁语单词（第11行），然后是一个空行（第12行），并进入下一轮。*Ongratulationscay!
    Ouyay inishedfay ouryay rogrampay!*
- en: '**TRY IT OUT 18-7**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个 18-7**'
- en: Write a program that takes a pig latin word as input and shows its original
    English word.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个猪拉丁语单词作为输入并显示其原始的英文单词。
- en: '***Fix My Spelling***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修正我的拼写***'
- en: Now we’ll develop a game that displays misspelled words and asks the player
    to enter the correct spelling. The game creates misspelled words by inserting
    a random letter at a random position in an English word. There could be more than
    one correct spelling of misspelled simple words. For example, if the game displays
    *mwall*, either *mall* or *wall* could be correct. To keep the game simple, we’ll
    ignore that possibility and insist on a particular spelling for the correct answer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开发一个游戏，展示拼错的单词并要求玩家输入正确的拼写。该游戏通过在一个英文单词中的随机位置插入一个随机字母来生成拼错的单词。拼错的简单单词可能有多个正确拼写。例如，如果游戏显示*mwall*，那么*mall*或*wall*都可以是正确的。为了简化游戏，我们将忽略这种可能性，并坚持使用某种特定拼写作为正确答案。
- en: First, we select the word to be misspelled from a predefined array of words
    and save the selected word in a variable named `strIn`. We then pick a random
    character `randChar` to insert into `strIn`. The insertion position `charPos`
    is a random number between 1 and the length of `strIn`. [Figure 18-6](ch18.html#ch18fig6)
    shows the process of generating the misspelled word `hewlp`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个预定义的单词数组中选择一个要拼错的单词，并将选中的单词保存在名为`strIn`的变量中。然后，我们随机挑选一个字符`randChar`插入到`strIn`中。插入的位置`charPos`是`strIn`长度之间的一个随机数，范围从1到`strIn`的长度。[图18-6](ch18.html#ch18fig6)展示了生成拼错单词`hewlp`的过程。
- en: '![image](graphics/f18-06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-06.jpg)'
- en: '*Figure 18-6: Illustrating the process of generating misspelled words*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-6：展示生成拼错单词的过程*'
- en: We first extract the substring from letter 1 to the letter at position `charPos
    – 1` and assign it to `strOut` (because `charPos` is `3`, this makes `strOut =
    "he"`). We then append `randChar` to `strOut` (this makes `strOut = "hew"`). We
    extract the substring from position `charPos` to the end (`"lp"` in this case)
    and append it to `strOut` (this makes `strOut = "hewlp"`). [Listing 18-8](ch18.html#ch18ex8)
    shows the complete program. Make sure you download and open *FixMySpelling.sb*
    from this chapter’s folder to get the full list of the words we wrote for this
    program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提取从第1个字母到`charPos – 1`位置的子字符串并将其赋值给`strOut`（因为`charPos`是`3`，所以`strOut =
    "he"`）。然后我们将`randChar`追加到`strOut`（这使得`strOut = "hew"`）。接着，我们提取从`charPos`到末尾的子字符串（在这个例子中是`"lp"`），并将其追加到`strOut`（这使得`strOut
    = "hewlp"`）。[清单18-8](ch18.html#ch18ex8)展示了完整的程序。确保从本章的文件夹中下载并打开*FixMySpelling.sb*，以查看我们为此程序编写的单词列表。
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 18-8: Creating misspelled words and asking the player to fix them*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-8：创建拼错单词并要求玩家修正它们*'
- en: 'The `words` array contains the words for this game (line 2). The program randomly
    picks a word from the `words` array and saves that word as `strIn` (line 5). Note
    how we used the array’s item count to set the upper limit of the random number.
    The program then selects a random letter, `randChar`, from the alphabet (line
    6). It does that by getting a random number from 1 to 26 and adding 96 to it;
    this gives you a random number between 97 (the code point for letter *a*) and
    122 (the code point for letter *z*). Next, the program picks a random position,
    `charPos`, in `strIn` (line 7): this is the position where the random character
    is inserted. Then the program creates the misspelled word and stores it in `strOut`
    (lines 9–11).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`words`数组包含了这个游戏的单词（第2行）。程序从`words`数组中随机选取一个单词并将该单词保存为`strIn`（第5行）。注意我们如何使用数组项的数量来设置随机数的上限。接着，程序从字母表中随机选择一个字母`randChar`（第6行）。它通过获取1到26之间的随机数并加上96来实现；这样你会得到一个在97（字母
    *a* 的代码点）和122（字母 *z* 的代码点）之间的随机数。然后，程序在`strIn`中选择一个随机位置`charPos`（第7行）：这是插入随机字符的位置。接着，程序创建拼错的单词并将其存储在`strOut`中（第9到11行）。'
- en: In line 13, the program asks the player to enter the correct spelling. It reads
    the user’s answer (line 14) and converts it to lowercase (line 15). It then compares
    the answer with the correct word (line 16). If the player’s answer matches the
    original word, the game displays `Good Job!` (line 17). Otherwise, the game displays
    an error message and shows the correct spelling (line 19). In both cases, the
    program ends by displaying an empty line (line 21), and the loop repeats to give
    the user a new misspelled word.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行，程序要求玩家输入正确的拼写。它读取用户的回答（第14行）并将其转换为小写（第15行）。然后，它将答案与正确的单词进行比较（第16行）。如果玩家的答案与原始单词匹配，游戏会显示`Good
    Job!`（第17行）。否则，游戏会显示错误信息并显示正确的拼写（第19行）。无论哪种情况，程序最终会通过显示空行（第21行）结束，并且循环会重复，以便给用户一个新的拼写错误的单词。
- en: 'Here’s a sample run of this program:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该程序的一个示例运行：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**TRY IT OUT 18-8**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手试试 18-8**'
- en: Update the program in [Listing 18-8](ch18.html#ch18ex8) so the misspelled word
    contains two additional random letters instead of just one random letter. Also,
    add more words to the list for more variety.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更新程序 [清单 18-8](ch18.html#ch18ex8)，使拼写错误的单词包含两个额外的随机字母，而不仅仅是一个随机字母。同时，向列表中添加更多的单词，以增加多样性。
- en: '***Unscramble***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新排列***'
- en: Now we’ll create a word scramble game. The program starts with an English word,
    scrambles the letters, displays the scrambled word to the player, and asks them
    to guess the original word.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个字母打乱游戏。程序从一个英文单词开始，打乱字母，展示打乱后的单词给玩家，并要求他们猜测原始单词。
- en: '[Listing 18-9](ch18.html#ch18ex9) shows the main part of the program. Open
    *Unscramble.sb* from this chapter’s folder for the full list of words.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-9](ch18.html#ch18ex9) 显示了程序的主要部分。打开本章文件夹中的 *Unscramble.sb* 查看完整的单词列表。'
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 18-9: Scrambling words and asking the player to unscramble them*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-9：打乱单词并要求玩家重新排列*'
- en: 'The `words` array contains the words for this game (line 2). The program randomly
    picks a word from this array and saves that word as `strIn` (line 5). It then
    makes a call to `Scramble()` to produce `strOut`, a scrambled version of `strIn`
    (line 6): we’ll add the `Scramble()` subroutine in a moment. Next, the program
    asks the player to unscramble `strOut` (line 8). It reads their answer (line 9)
    and converts it to lowercase (line 10). It then compares the player’s answer with
    the correct word (line 12). If the player’s answer matches the original word,
    the game displays `Good Job!` (line 13). Otherwise, the game displays the correct
    word (line 15). In both cases, the program ends by displaying an empty line (line
    17) to separate the rounds and the loop repeats.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`words` 数组包含了这个游戏的单词（第2行）。程序随机从这个数组中选择一个单词，并将其保存为 `strIn`（第5行）。然后，它调用 `Scramble()`
    来生成 `strOut`，这是 `strIn` 的一个打乱版本（第6行）：稍后我们将添加 `Scramble()` 子程序。接下来，程序要求玩家将 `strOut`
    重新排列（第8行）。它读取玩家的答案（第9行），并将其转换为小写（第10行）。然后，它将玩家的答案与正确的单词进行比较（第12行）。如果玩家的答案与原始单词匹配，游戏会显示
    `Good Job!`（第13行）。否则，游戏会显示正确的单词（第15行）。无论哪种情况，程序最后通过显示一个空行来分隔回合（第17行），然后循环重复。'
- en: Now let’s look at the `Scramble()` subroutine, which shuffles the characters
    of a string into a random order. The caller sets the input string (`strIn`), and
    the subroutine returns a new string (`strOut`) that contains the characters of
    `strIn` shuffled around. [Listing 18-10](ch18.html#ch18ex10) shows this subroutine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 `Scramble()` 子程序，它将字符串的字符打乱成一个随机顺序。调用者设置输入字符串（`strIn`），然后子程序返回一个新的字符串（`strOut`），它包含了被打乱的
    `strIn` 字符。[清单 18-10](ch18.html#ch18ex10) 显示了这个子程序。
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 18-10: Word-scrambling subroutine*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 18-10：字母打乱子程序*'
- en: The subroutine saves the length of the input string into `len` (line 2). It
    then uses a `For` loop to save the individual letters of `strIn` into an array
    named `char` (lines 3–5). It empties the output string, `strOut`, and starts a
    `While` loop to assemble `strOut` letter by letter (lines 7–14). The `While` loop
    runs until `strOut` has the same length as `strIn` (which means that we’ve added
    all the letters of `strIn`). Each iteration of the loop picks a random element
    from the `char` array (line 9). If that element is empty, we loop again to pick
    another one. Otherwise, we append the selected letter to `strOut` (line 11) and
    empty that element to indicate that we’ve used it (to prevent using it again)
    in line 12\. *Ouy fishendi eth egma!*
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该子程序将输入字符串的长度保存到 `len`（第2行）。然后，它使用 `For` 循环将 `strIn` 的每个字母保存到一个名为 `char` 的数组中（第3至5行）。它清空输出字符串
    `strOut`，并开始一个 `While` 循环按字母逐个构建 `strOut`（第7至14行）。`While` 循环一直运行，直到 `strOut` 的长度与
    `strIn` 相同（这意味着我们已经添加了所有 `strIn` 的字母）。循环的每次迭代从 `char` 数组中随机选择一个元素（第9行）。如果该元素为空，我们会再次循环选择另一个。如果不是，我们将选择的字母附加到
    `strOut`（第11行），并清空该元素以表示我们已经使用过它（防止再次使用），见第12行。*Ouy fishendi eth egma!*
- en: 'Here’s a sample run of this program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的一个示例运行：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**TRY IT OUT 18-9**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 18-9**'
- en: 'Try to update the word-scrambling game using the skills you learned in previous
    chapters. Make the game last 10 rounds and then display the user’s score: how
    many words were unscrambled correctly out of the 10? Next, add 28 more words to
    unscramble so you have a total of 50\. Then show the game to your friends and
    see who can get the best score!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你在之前章节中学到的技能更新这个字母打乱游戏。让游戏持续进行10回合，然后显示用户的得分：在10个回合中，有多少个单词被正确地重新排列？接下来，添加28个新的单词进行打乱，这样你就有50个单词了。然后将游戏展示给你的朋友，看看谁能获得最高分！
- en: '**Rhyme Time: The House That Jack Built**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**押韵时间：杰克建造的房子**'
- en: Let’s finish this chapter with a program that displays a popular British nursery
    rhyme and cumulative tale. In a *cumulative tale*, an action repeats and builds
    up as the tale progresses. [Figure 18-7](ch18.html#ch18fig7) shows this program
    in progress; more rhyme lines appear each time a user clicks the Next button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个展示英国经典儿歌和累积故事的程序来结束这一章。在*累积故事*中，某个动作会随着故事的进展重复并逐步增加。[图18-7](ch18.html#ch18fig7)展示了这个程序的进展；每当用户点击“下一页”按钮时，会出现更多的押韵行。
- en: '![image](graphics/f18-07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-07.jpg)'
- en: '*Figure 18-7: The House That Jack Built rhyme*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-7：杰克建造的房子押韵故事*'
- en: Examine this rhyme closely, and you’ll notice the common strings among the story
    pages. Study [Figure 18-8](ch18.html#ch18fig8) to understand how to create this
    rhyme by appending short strings at each stage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查这个押韵故事，你会注意到故事页面中有一些共同的字符串。研究[图18-8](ch18.html#ch18fig8)，了解如何通过在每个阶段附加短字符串来创建这个押韵故事。
- en: '![image](graphics/f18-08.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f18-08.jpg)'
- en: '*Figure 18-8: The strings that make up the rhyme*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-8：构成押韵故事的字符串*'
- en: 'For example, let’s trace the third row in this figure. Following the third
    arrow, you’ll get the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来跟踪这个图中的第三行。跟随第三个箭头，你将得到以下内容：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you continue with the second arrow, you’ll get the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续跟随第二个箭头时，你会得到以下内容：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And, when you follow the first arrow, you’ll get the full rhyme that will appear
    on the third page:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 而当你跟随第一个箭头时，你将看到完整的押韵故事，这将在第三页显示：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the file *JackHouse_Incomplete.sb* from this chapter’s folder. The file
    contains the main program in [Listing 18-11](ch18.html#ch18ex11) and a placeholder
    for the `OnButtonClicked()` subroutine, which we’ll add in a moment. The folder
    also contains the 11 background images (*Page1.png*, *Page2.png*, ..., *Page11.png*)
    that we’ll display for each page of the rhyme.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*JackHouse_Incomplete.sb*文件。该文件包含[清单18-11](ch18.html#ch18ex11)中的主程序和一个`OnButtonClicked()`子程序的占位符，我们稍后会添加这个子程序。文件夹中还包含了11个背景图片（*Page1.png*、*Page2.png*、...、*Page11.png*），这些图片将展示在每一页的押韵故事中。
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 18-11: The main part of the House That Jack Built program*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-11：杰克建造的房子程序的主要部分*'
- en: Lines 2–8 set up the `GraphicsWindow` object. Line 10 defines the line feed
    character (for appending new lines to the strings). Lines 12–22 define the `rhyme`
    array, which contains the strings for this rhyme. Note how the elements of this
    array relate to the boxes in [Figure 18-8](ch18.html#ch18fig8). Line 24 creates
    the Next button, and line 25 registers the handler for the `ButtonClicked` event.
    Then the `nextLine` variable is set to 11 to point to the 11th element of the
    rhyme array, which is the first page of the story (line 26), and `OnButtonClicked()`
    is called to show the first page of the rhyme (line 27).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第2到第8行设置了`GraphicsWindow`对象。第10行定义了换行符（用于在字符串中附加新行）。第12到第22行定义了`rhyme`数组，该数组包含了这个押韵故事的字符串。注意这个数组的元素是如何与[图18-8](ch18.html#ch18fig8)中的框框对应的。第24行创建了“下一页”按钮，第25行注册了`ButtonClicked`事件的处理程序。接着，`nextLine`变量被设置为11，指向`rhyme`数组的第11个元素，这个元素是故事的第一页（第26行），然后调用`OnButtonClicked()`来展示押韵故事的第一页（第27行）。
- en: Now we’ll add the `OnButtonClicked()` subroutine in [Listing 18-12](ch18.html#ch18ex12).
    This subroutine is called when the user clicks the Next button.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在[清单18-12](ch18.html#ch18ex12)中添加`OnButtonClicked()`子程序。这个子程序会在用户点击“下一页”按钮时被调用。
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 18-12: The* `OnButtonClicked()` *subroutine*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单18-12：`OnButtonClicked()`子程序*'
- en: Line 2 fills `img` with the name of the image for the current page of the rhyme.
    When `nextLine` is 11, we’ll show *Page1.png* (which is 12 minus 11). When `nextLine`
    is 10, we’ll show *Page2.png* (12 minus 10), and when `nextLine` is 9, we’ll show
    *Page3.png* (12 minus 9), and so on. Line 3 draws the image on the graphics window.
    We then build up the output string (lines 5–8). We set `strOut` to `"This is "`
    (line 5) and then start a loop that goes from `nextLine` to 11 (lines 6–8). When
    `nextLine` is 11, the loop runs one time and appends `rhyme[11]` to `strOut`.
    When `nextLine` is 10, the loop runs from 10 to 11 and appends `rhyme[10]` and
    then `rhyme[11]` to `strOut`. Similarly, when `nextLine` is 9, the loop runs from
    9 to 11 and appends `rhyme[9]`, `rhyme[10]`, and then `rhyme[11]` to `strOut`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行将`img`填充为当前韵文页面的图像名称。当`nextLine`为11时，我们显示*Page1.png*（即12减去11）。当`nextLine`为10时，我们显示*Page2.png*（12减去10），当`nextLine`为9时，我们显示*Page3.png*（12减去9），依此类推。第3行在图形窗口中绘制图像。然后我们构建输出字符串（第5到第8行）。我们将`strOut`设置为`"This
    is "`（第5行），然后开始一个从`nextLine`到11的循环（第6到第8行）。当`nextLine`为11时，循环运行一次，并将`rhyme[11]`附加到`strOut`。当`nextLine`为10时，循环从10到11运行，并将`rhyme[10]`和`rhyme[11]`附加到`strOut`。类似地，当`nextLine`为9时，循环从9到11运行，并将`rhyme[9]`、`rhyme[10]`和`rhyme[11]`附加到`strOut`。
- en: When the loop ends, `strOut` contains the entire string for the rhyme at this
    stage of the story. We display this string using `DrawText()` in line 9.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，`strOut`包含此时故事韵文的整个字符串。我们在第9行使用`DrawText()`来显示这个字符串。
- en: Then we decrease `nextLine` by 1 to point to the previous element in the `rhyme`
    array (line 11). If `nextLine` becomes 0 (line 12), the story is done, so we set
    it back to 11 to start over (line 13). As a result, when the user clicks the Next
    button at the last page of the story, the program goes back to displaying the
    first page. We’ve finished the tale before it got stale!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`nextLine`减1，指向`rhyme`数组中的前一个元素（第11行）。如果`nextLine`变为0（第12行），说明故事结束，我们将其重置为11，以便重新开始（第13行）。因此，当用户在故事的最后一页点击“下一页”按钮时，程序会返回显示第一页。我们在故事还不无聊之前就完成了它！
- en: '**TRY IT OUT 18-10**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 18-10**'
- en: Use the techniques you learned in the House That Jack Built example to write
    a program that tells your favorite story. Don’t have one? Make one about an alien
    rat trapped in a tower with nothing but JELL-O, a slingshot, and an advanced chemistry
    set. Explain how the rat got there and how it escapes!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在《Jack所建的房子》示例中学到的技巧，编写一个程序讲述你最喜欢的故事。如果没有最喜欢的故事？那就编一个关于外星老鼠被困在一座塔中，身边只有明胶、弹弓和高级化学实验套件的故事。解释一下这只老鼠是如何被困的，以及它是如何逃脱的！
- en: '**Programming Challenges**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，可以查看* [http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*，那里有解决方案以及更多的资源和针对教师和学生的复习题。
- en: Open the file *Shoot_Incomplete.sb* from this chapter’s folder. Run the program
    to see the following interface.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*Shoot_Incomplete.sb*文件。运行程序以查看以下界面。
- en: '![image](graphics/f0284-01.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0284-01.jpg)'
- en: 'The goal of this game is to estimate the turn angle and moving distance between
    the turtle and the target. When a player enters their input, it is saved in a
    variable named `strIn`. Your task is to split `strIn` into two parts: assign the
    substring before the comma to `angle`, and assign the substring after the comma
    to `dist`. The comments in the file tell you where to add your code. If you get
    stuck, see the file *Shoot.sb*, which contains the completed program.'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个游戏的目标是估算乌龟与目标之间的转角和移动距离。当玩家输入他们的输入时，它会保存在一个名为`strIn`的变量中。你的任务是将`strIn`分成两部分：将逗号前的子字符串赋值给`angle`，将逗号后的子字符串赋值给`dist`。文件中的注释告诉你在哪里添加代码。如果你卡住了，可以查看*Shoot.sb*文件，其中包含完成的程序。
- en: Open the file *BinaryToDecimal_Incomplete.sb* from this chapter’s folder. This
    program converts binary numbers to decimal numbers and then asks the user to input
    an 8-bit binary number. It then shows the input number in the graphics window,
    computes its decimal number, and displays the result of the conversion, as shown
    in the following figure.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*BinaryToDecimal_Incomplete.sb*文件。此程序将二进制数字转换为十进制数字，然后要求用户输入一个8位的二进制数。接着，它会在图形窗口中显示输入的数字，计算其十进制数，并显示转换结果，如下图所示。
- en: '![image](graphics/f0285-01.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0285-01.jpg)'
- en: Complete the `GetInput()` subroutine, which prompts the user to enter an 8-bit
    binary number. You need to verify that the user’s input isn’t empty and has at
    most eight binary digits (so it contains only 1s and 0s). When the user enters
    a valid input, save it in `strIn` and return from the subroutine. The comments
    in the file tell you what to do. If you get stuck, see the file *BinaryToDecimal.sb*,
    which contains the completed code.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成`GetInput()`子程序，提示用户输入一个8位二进制数。你需要验证用户输入的内容不能为空，并且最多只能包含八个二进制数字（即只能包含1和0）。当用户输入有效时，将其保存在`strIn`中，并从子程序返回。文件中的注释会告诉你该怎么做。如果遇到困难，可以参考文件*BinaryToDecimal.sb*，其中包含已完成的代码。
