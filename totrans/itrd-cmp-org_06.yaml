- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6  '
- en: COMBINATIONAL LOGIC CIRCUITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '组合逻辑电路**  '
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)  '
- en: In the previous chapter, you learned about a computer’s basic component, the
    logic gate. Computers are constructed from assemblages of logic gates, called
    *logic circuits*, that process digital information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，你了解了计算机的基本组成部分——逻辑门。计算机是由逻辑门的组合构成的，这些逻辑门被称为*逻辑电路*，用于处理数字信息。  '
- en: In this and the following two chapters, we’ll look at how to build some of the
    logic circuits that make up CPUs, memory, and other devices. I won’t describe
    any of these units in their entirety; instead, we’ll look at a few small parts
    and discuss the concepts behind them. The goal is to provide an introductory overview
    of the ideas that underlie these logic circuits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章以及接下来的两章中，我们将探讨如何构建一些构成 CPU、内存和其他设备的逻辑电路。我不会描述这些单元的全部内容；相反，我们将查看其中的一些小部分，并讨论其背后的概念。目标是提供一个关于这些逻辑电路背后思想的入门概览。  '
- en: '**The Two Types of Logic Circuits**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑电路的两种类型**'
- en: There are two types of logic circuits. A *combinational logic circuit* has output
    that depends only on the inputs given at any specific time and not on any previous
    inputs. A *sequential logic circuit* has output that depends on both previous
    and current inputs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '逻辑电路有两种类型。*组合逻辑电路*的输出仅依赖于任何特定时刻给定的输入，而不依赖于任何先前的输入。*时序逻辑电路*的输出依赖于先前和当前的输入。  '
- en: To elucidate these two types, let’s consider a TV remote. You can select a specific
    channel by entering a number on the remote. The channel selection depends only
    on the number you entered and ignores the channels you were viewing before. Thus,
    the relationship between the input and the output is combinational.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '为了阐明这两种类型，我们考虑一个电视遥控器。你可以通过在遥控器上输入数字来选择一个特定的频道。频道选择仅依赖于你输入的数字，而忽略了你之前正在查看的频道。因此，输入与输出之间的关系是组合的。  '
- en: The remote control also has an input for going up or down one channel. This
    input depends on the previously selected channel and the previous sequence of
    up/down button pushes. The channel up/down buttons illustrate a sequential input/output
    relationship.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '遥控器还有一个输入，用于调节频道的升高或降低。这个输入依赖于先前选择的频道和之前上下频道按钮的序列。频道上下按钮展示了一个时序输入/输出的关系。  '
- en: We’ll explore sequential logic circuits in the next chapter. In this chapter,
    we’ll go through several examples of combinational logic circuits to see how they
    function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在下一章探讨时序逻辑电路。在本章中，我们将通过几个组合逻辑电路的例子来了解它们是如何工作的。  '
- en: '**SIGNAL VOLTAGE LEVELS**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号电压水平**  '
- en: Electronic logic circuits represent `1`s and `0`s with either a high voltage
    or a low voltage. We call the voltage that represents `1` the *active voltage*.
    If we use a higher voltage to represent `1`, then the signal is called *active
    high*. If we use a lower voltage to represent `1`, then the signal is called *active
    low*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '电子逻辑电路用高电压或低电压来表示`1`和`0`。我们将表示`1`的电压称为*有效电压*。如果我们使用更高的电压来表示`1`，那么该信号称为*高电平有效*。如果我们使用较低的电压来表示`1`，那么该信号称为*低电平有效*。  '
- en: An active-high signal can be connected to an active-low input, but the hardware
    designer must take the difference into account. For example, if the required logical
    input to an active-low input is `1`, the required voltage is the lower of the
    two voltages; if the signal to be connected to this input is active high, then
    a logical `1` is the higher of the two voltages, and the signal must first be
    complemented to be interpreted as a `1` at the active-low input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '一个高电平信号可以连接到一个低电平输入，但硬件设计师必须考虑到这种差异。例如，如果所需的逻辑输入为低电平输入的是`1`，则所需电压是两种电压中较低的；如果连接到该输入的信号是高电平的，则逻辑`1`是两种电压中较高的，信号必须先被反向才能在低电平输入中被解释为`1`。  '
- en: I will use only logic levels—`0` and `1`—in the discussions of logic circuits
    in this book and avoid the actual voltage levels being used in the hardware, but
    you should know the terminology because it can come up when talking to others
    or reading component specification sheets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '我在本书中讨论逻辑电路时只使用逻辑电平——`0`和`1`——而避免使用硬件中实际的电压水平，但你应该了解这些术语，因为它们在与他人交谈或阅读组件规格书时可能会出现。  '
- en: '**Adders**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加法器**  '
- en: 'We’ll start with one of the most fundamental operations performed in the CPU:
    adding two bits. Our eventual goal is to add two *n*-bit numbers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从 CPU 中执行的最基本操作之一开始：加法运算两个比特。我们的最终目标是加法运算两个 *n* 位数。  '
- en: Recall from [Chapter 2](ch02.xhtml) that the bits in a binary number are numbered
    from right (the least significant bit) to left (the most significant bit), starting
    with 0\. I’ll start by showing you how to add two bits in the *i*th bit position
    and complete the discussion by showing you how to add two 4-bit numbers, taking
    into account the carry from each bit position.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第 2 章](ch02.xhtml)回顾，二进制数中的位从右向左编号（最低有效位到最高有效位），从0开始。我将从展示如何在第*i*位位置添加两个位开始，并通过展示如何添加两个4位数并考虑每个位位置的进位来完成讨论。
- en: '***Half Adder***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***半加器***'
- en: Addition can be done with several kinds of circuits. We’ll start with the *half
    adder*, which simply adds the two bits in the current bit position of a number
    (expressed in binary). This is shown by the truth table in [Table 6-1](ch06.xhtml#ch6tab1),
    where *x[i]* is the *i*th bit of the number *x* and the values in the *y[i]* column
    represent the *i*th bit of the number *y*. *Sum[i]* is the *i*th bit of the number
    *Sum*, and *Carry[i]* [+ 1] is the carry from adding bits *x[i]* and *y[i]*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用几种电路进行加法运算。我们将从*半加器*开始，它简单地将一个数的当前位位置上的两个位相加（以二进制表示）。这在[表 6-1](ch06.xhtml#ch6tab1)中的真值表中展示，其中*x[i]*是数*x*的第*i*位，*y[i]*列中的值表示数*y*的第*i*位。*Sum[i]*是数*Sum*的第*i*位，*Carry[i]*
    [+ 1]是从添加位*x[i]*和*y[i]*得到的进位。
- en: '**Table 6-1:** A Truth Table for Adding Two Bits Using a Half Adder'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1:** 使用半加器添加两个位的真值表'
- en: '| ***x******[i]*** | ***y******[i]*** | ***Carry*****[*i* + 1]** | ***Sum***[***i***]
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| ***x******[i]*** | ***y******[i]*** | ***Carry*****[*i* + 1]** | ***Sum***[***i***]
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `1` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` |'
- en: '| `1` | `0` | `0` | `1` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` |'
- en: '| `1` | `1` | `1` | `0` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` |'
- en: The sum is the XOR of the two inputs, and the carry is the AND of the two inputs.
    [Figure 6-1](ch06.xhtml#ch6fig1) shows the logic circuit for a half adder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和是两个输入的异或，进位是两个输入的与。[图 6-1](ch06.xhtml#ch6fig1)展示了半加器的逻辑电路。
- en: '![Image](../images/pg137_Image_174.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_174.jpg)'
- en: '*Figure 6-1: A half adder logic circuit*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：半加器逻辑电路*'
- en: 'But there’s a flaw here: the half adder works with only two input bits. It
    can be used to add the two bits from the same bit position of two numbers, but
    it doesn’t take into account a possible carry from the next lower-order bit position.
    Including this carry as a third input will give us a full adder.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个缺陷：半加器只能处理两个输入位。它可以用来添加两个数的同一位位置的两个位，但它不考虑可能来自下一个低阶位位置的进位。将此进位作为第三个输入包括进来将得到一个全加器。
- en: '***Full Adder***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***全加器***'
- en: 'Unlike the half adder, a *full adder* circuit has three 1-bit inputs: *Carry[i]*,
    *x[i]*, and *y[i]*. *Carry[i]* is the carry that resulted when you added the two
    bits in the previous bit position (the bit to the right). For example, if we’re
    adding the two bits in bit position 5, the inputs to the full adder are the two
    bits in position 5 plus the carry from adding the bits in position 4\. [Table
    6-2](ch06.xhtml#ch6tab2) shows the results.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与半加器不同，*全加器*电路有三个1位输入：*Carry[i]*、*x[i]*和*y[i]*。*Carry[i]*是将两个上一个位位置的位相加时产生的进位（右边的位）。例如，如果我们正在添加位位置5的两个位，那么全加器的输入是位位置5的两个位加上位于位置4的进位。[表
    6-2](ch06.xhtml#ch6tab2)显示了结果。
- en: '**Table 6-2:** A Truth Table for Adding Two Bits Using a Full Adder'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-2:** 使用全加器添加两个位的真值表'
- en: '| ***Carry****[i]*** | ***x******[i]*** | ***y****[i]*** | ***Carry***[***i***
    + 1] | ***Sum***[***i***] |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ***Carry****[i]*** | ***x******[i]*** | ***y****[i]*** | ***Carry***[***i***
    + 1] | ***Sum***[***i***] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `1` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `1` |'
- en: '| `0` | `1` | `0` | `0` | `1` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `1` |'
- en: '| `0` | `1` | `1` | `1` | `0` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` |'
- en: '| `1` | `0` | `0` | `0` | `1` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `0` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `1` | `0` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `0` |'
- en: '| `1` | `1` | `1` | `1` | `1` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` |'
- en: 'To design a full adder circuit, we start with the function that specifies when
    *Sum[i]* is `1` as a sum of product terms from [Table 6-2](ch06.xhtml#ch6tab2):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计一个全加器电路，我们从指定*Sum[i]*为`1`的函数开始，作为来自[表 6-2](ch06.xhtml#ch6tab2)的积和项：
- en: '![Image](../images/pg138_Image_175.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_175.jpg)'
- en: There are no obvious simplifications in this equation, so let’s look at the
    Karnaugh map for *Sum[i]*, shown in [Figure 6-2](ch06.xhtml#ch6fig2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此方程式中没有明显的简化，因此让我们看看*Sum[i]*的卡诺图，如[图 6-2](ch06.xhtml#ch6fig2)所示。
- en: '![Image](../images/pg138_Image_176.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_176.jpg)'
- en: '*Figure 6-2: A Karnaugh map for the sum of three bits,* Carry[i], x[i]*, and*
    y[i]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：三个比特的和的卡诺图，*进位[i]*，x[i]*和*y[i]*'
- en: There are no obvious groupings in [Figure 6-2](ch06.xhtml#ch6fig2), so we are
    left with the four product terms to compute *Sum[i]* in the previous equation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-2](ch06.xhtml#ch6fig2)中没有明显的分组，因此我们剩下四个积项来计算前面方程中的*Sum[i]*。
- en: 'You learned in [Chapter 4](ch04.xhtml) that *Carry[i]* [+ 1](*Carry[i]*, *x[i]*,
    *y[i]*) can be expressed by the equation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 4 章](ch04.xhtml)中学到，*进位[i]* [+ 1](*进位[i]*, *x[i]*, *y[i]*)可以通过以下方程表示：
- en: '![Image](../images/pg138_Image_177.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_177.jpg)'
- en: Together, these two functions give the circuit for a full adder, as shown in
    [Figure 6-3](ch06.xhtml#ch6fig3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数共同构成了全加器的电路，如[图 6-3](ch06.xhtml#ch6fig3)所示。
- en: '![Image](../images/pg138_Image_178.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_178.jpg)'
- en: '*Figure 6-3: A full adder circuit*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：全加器电路*'
- en: The full adder uses nine logic gates. In the next section, we’ll see if we can
    find a simpler circuit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器使用九个逻辑门。在接下来的部分中，我们将看到是否能找到一个更简单的电路。
- en: '#### ***Full Adder from Two Half Adders***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***由两个半加器构成的全加器***'
- en: 'To see if we can find a simpler solution for adding two bits and the carry
    from the next lower-order bit position, let’s go back to the equation for *Sum[i]*.
    Using the distribution rule, we can rearrange it as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看是否能找到一个更简单的方案来加法两位和来自下一低阶位的进位，让我们回到*Sum[i]*的方程。利用分配法则，我们可以将其重新排列如下：
- en: '![Image](../images/pg139_Image_179.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_179.jpg)'
- en: 'In [Chapter 4](ch04.xhtml), you learned that the quantity in the parentheses
    in the first product term is the XOR of *x[i]* and *y[i]*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.xhtml)中，你学到了第一个积项中括号里的量是*x[i]*和*y[i]*的异或（XOR）：
- en: '![Image](../images/pg139_Image_180.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_180.jpg)'
- en: 'Thus, we have:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出：
- en: '![Image](../images/pg139_Image_181.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_181.jpg)'
- en: 'Let’s manipulate the quantity in the parentheses in the second product term.
    Recall that in Boolean algebra *x ∧ ¬x* = 0, so we can write the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们操作第二个积项中的括号里的量。回忆一下布尔代数中 *x ∧ ¬x* = 0，所以我们可以写出如下式子：
- en: '![Image](../images/pg139_Image_182.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_182.jpg)'
- en: 'Thus:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '![Image](../images/pg139_Image_183.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_183.jpg)'
- en: We’ll do something to develop a Boolean function for *Carry[i]* [+ 1] that will
    probably seem counterintuitive. Let’s start with the Karnaugh map for carry when
    adding three bits (see [Figure 4-14](ch04.xhtml#ch4fig14)), but remove two of
    the groupings, as shown by the dotted lines in [Figure 6-4](ch06.xhtml#ch6fig4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些操作，开发出一个*进位[i]* [+ 1]的布尔函数，这个操作可能会显得违反直觉。让我们从加法三个比特时的进位卡诺图开始（见[图 4-14](ch04.xhtml#ch4fig14)），但去除两个分组，如[图
    6-4](ch06.xhtml#ch6fig4)中虚线所示。
- en: '![Image](../images/pg139_Image_184.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_184.jpg)'
- en: '*Figure 6-4: The Karnaugh map for carry from [Figure 4-14](ch04.xhtml#ch4fig14),
    redrawn without two overlapping groupings (dotted lines)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：来自[图 4-14](ch04.xhtml#ch4fig14)的卡诺图，重新绘制去除了两个重叠分组（虚线）*'
- en: 'This will give us the following equation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下方程：
- en: '![Image](../images/pg139_Image_185.jpg) Notice that two of the terms in this
    equation, (*x[i] ∧ y[i]*) and (*x[i]* ⊻ *y[i]*), are already generated by a half
    adder (see [Figure 6-1](ch06.xhtml#ch6fig1)). With a second half adder and an
    OR gate, we can implement a full adder, as shown in [Figure 6-5](ch06.xhtml#ch6fig5).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg139_Image_185.jpg) 注意，这个方程中的两个项，(*x[i] ∧ y[i]*) 和 (*x[i]*
    ⊻ *y[i]*), 已经通过半加器生成（见[图 6-1](ch06.xhtml#ch6fig1)）。通过第二个半加器和一个或门，我们可以实现一个全加器，如[图
    6-5](ch06.xhtml#ch6fig5)所示。'
- en: '![Image](../images/pg140_Image_186.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg140_Image_186.jpg)'
- en: '*Figure 6-5: A full adder using two half adders*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：使用两个半加器的全加器*'
- en: Now you should understand where the terms *half adder* and *full adder* come
    from.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解了*半加器*和*全加器*这两个术语的来源。
- en: A simpler circuit is not always better. In truth, we cannot say which of the
    two full adder circuits in [Figures 6-3](ch06.xhtml#ch6fig3) and [6-5](ch06.xhtml#ch6fig6)
    is better just by looking at the logic circuits. Good engineering design depends
    on many factors, such as how each logic gate is implemented, the cost of the logic
    gates and their availability, and so forth. I’ve presented two alternatives here
    to show that different approaches can lead to different, but functionally equivalent,
    designs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的电路不一定更好。事实上，我们不能仅凭观察[图6-3](ch06.xhtml#ch6fig3)和[6-5](ch06.xhtml#ch6fig6)中的两个全加器电路就判断哪一个更好。好的工程设计取决于许多因素，例如每个逻辑门的实现方式、逻辑门的成本及其可用性等等。我在这里展示了两种替代方案，以表明不同的方法可以导致不同但功能等效的设计。
- en: '***Ripple-Carry Addition and Subtraction Circuits***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***波纹进位加法和减法电路***'
- en: Now you know how to add the two bits in a given bit position, plus a carry from
    the next lower-order bit position. But most values that a program works with have
    many bits, so we need a way to add the corresponding bits in each bit position
    of two *n*-bit numbers. This can be done with an *n-bit adder*, which can be implemented
    with *n* full adders. [Figure 6-6](ch06.xhtml#ch6fig6) shows a 4-bit adder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何加两个给定位置的比特，并加上来自下一个低位位置的进位。但是大多数程序处理的数值都有很多比特，因此我们需要一种方法来加两个*n*位数的每个位的对应比特。这可以通过*n*位加法器来实现，它可以通过*n*个全加器来构建。[图6-6](ch06.xhtml#ch6fig6)展示了一个4位加法器。
- en: '![Image](../images/pg140_Image_187.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg140_Image_187.jpg)'
- en: '*Figure 6-6: A 4-bit adder*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：一个4位加法器*'
- en: Addition begins with the full adder on the right receiving the two lowest-order
    bits, *x*[0] and *y*[0]. Since this is the lowest-order bit, there is no carry,
    and *c*[0] = `0`. The bit sum is *s*[0], and the carry from this addition, *c*[1],
    is connected to the carry input of the next full adder to the left, where it is
    added to *x*[1] and *y*[1]. Thus, the *i*th full adder adds the two *i*th bits
    of the operands, plus the carry (which is either `0` or `1`) from the (*i* – 1)th
    full adder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加法从右侧的全加器开始，接收两个最低位的比特，*x*[0]和*y*[0]。由于这是最低位，因此没有进位，*c*[0] = `0`。该位的和是*s*[0]，并且来自此加法的进位*c*[1]被连接到左侧下一个全加器的进位输入，在那里它与*x*[1]和*y*[1]相加。因此，第*i*个全加器将操作数的两个*i*位加起来，并加上来自(*i*
    - 1)个全加器的进位（其值为`0`或`1`）。
- en: Each full adder handles one bit (often referred to as a *slice*) of the total
    width of the values being added. The carry from each bit position is added to
    the bits in the next higher-order bit position. The addition process flows from
    the lowest-order bit to the highest-order in a sort of rippling effect, which
    gives this method of adding the name *ripple-carry addition*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个全加器处理一个比特（通常称为*切片*）的总宽度。每个位位置的进位将加到下一个更高位位置的比特上。加法过程从最低位流向最高位，以一种波动效应进行，这也赋予了这种加法方法名称——*波纹进位加法*。
- en: Notice that in [Figure 6-6](ch06.xhtml#ch6fig6), we have `C` and `V`, the *carry
    flag* and *overflow flag*. You learned about carry and overflow in [Chapter 3](ch03.xhtml).
    The AArch64 architecture includes addition and subtraction instructions that record
    whether carry and overflow occurred in the CPU. You’ll learn more about this in
    [Chapter 9](ch09.xhtml).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图6-6](ch06.xhtml#ch6fig6)中，我们有`C`和`V`，分别是*进位标志*和*溢出标志*。你在[第3章](ch03.xhtml)中已经学习了进位和溢出。AArch64架构包括记录进位和溢出是否发生的加法和减法指令。你将在[第9章](ch09.xhtml)中学到更多内容。
- en: 'Let’s see how we can use a similar idea to implement subtraction. Recall that
    in two’s complement, a number is negated by taking its two’s complement, flipping
    all the bits, and adding `1`. Thus, we can subtract *y* from *x* by doing this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用类似的思路来实现减法。回想一下，在二进制补码表示法中，一个数的负值是通过取它的二进制补码，翻转所有位并加上`1`来实现的。因此，我们可以通过以下方式从*x*中减去*y*：
- en: '![Image](../images/pg141_Image_188.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg141_Image_188.jpg)'
- en: We can perform subtraction with our adder in [Figure 6-5](ch06.xhtml#ch6fig5)
    if we complement each *y[i]* and set the initial carry in to `1` instead of `0`.
    Each *y[i]* can be complemented by XOR-ing it with `1`. This leads to the 4-bit
    circuit in [Figure 6-7](ch06.xhtml#ch6fig7), which will add two 4-bit numbers
    when *func* = `0` and subtract them when *func* = `1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对每个*y[i]*取反，并将初始进位设为`1`，而不是`0`，那么我们就可以在[图6-5](ch06.xhtml#ch6fig5)中的加法器实现减法。每个*y[i]*可以通过与`1`进行异或操作来取反。这就得到了[图6-7](ch06.xhtml#ch6fig7)中的4位电路，当*func*
    = `0`时，它会加两个4位数，当*func* = `1`时，它会减这两个数。
- en: '![Image](../images/pg141_Image_189.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg141_Image_189.jpg)'
- en: '*Figure 6-7: A 4-bit adder/subtractor*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：一个4位加法器/减法器*'
- en: There is, of course, a time delay as the sum is computed from right to left.
    The computation time can be significantly reduced through circuit designs that
    make use of what can be known about the values of the intermediate carries, *c[i]*,
    but I won’t go into such details in this book. Let’s turn to our next type of
    circuit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 6.1     In [Chapter 3](ch03.xhtml), you learned about the carry flag (`C`) and
    the overflow flag (`V`). The CPU also has a zero flag (`Z`) and a negative flag
    (`N`). The `Z` flag is `1` when the result of an arithmetic operation is zero,
    and the `N` flag is `1` when the result is a negative number if the number is
    considered to be in two’s complement notation. Design a circuit that uses the
    outputs of the full adders in [Figure 6-7](ch06.xhtml#ch6fig7), *s*[0], *s*[1],
    *s*[2], *s*[3], *c*[3], and *c*[4], and outputs the `C`, `V`, `N`, and `Z` flags.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoders**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many places in a computer require selecting one of several connections based
    on a number. For example, as you will see in [Chapter 8](ch08.xhtml), the CPU
    has a small amount of memory organized in *registers*, which are used for computations.
    The AArch64 architecture provides 31 general-purpose 64-bit registers. If an instruction
    uses one of the registers, 5 bits in the instruction must be used to select which
    of the 31 registers should be used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This selection can be done with a *decoder*. The input to the decoder is the
    4-bit number of the register, and the output is one of 16 possible connections
    to the specified register.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: A decoder has *n* binary inputs that can produce up to 2*^n* binary outputs.
    The most common type of decoder, sometimes called a *line decoder*, selects only
    one of the output lines to set to `1` for each input bit pattern. It’s also common
    for a decoder to include an *Enable* input. [Table 6-3](ch06.xhtml#ch6tab3) is
    a truth table for a 3×8 (three inputs, eight outputs) decoder with an *Enable*
    input that shows how this works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** A Truth Table for a 3×8 Decoder with *Enable*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Input** | **Output** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| ***Enable*** | ***x***[2] | ***x***[1] | ***x***[0] | ***y***[7] | ***y***[6]
    | ***y***[5] | ***y***[4] | ***y***[3] | ***y***[2] | ***y***[1] | ***y***[0]
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `1` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: When *Enable* = `0`, all the output lines are `0`. When *Enable* = `1`, the
    3-bit number at the input, *x* = *x*[2]*x*[1]*x*[0], selects which output line
    is set to `1`. So, this decoder could be used to select one of eight registers
    with a 3-bit number. (I’m not using all of the 31 registers in the AArch64 architecture
    to keep the table a reasonable size here.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The 3×8 line decoder specified in [Table 6-3](ch06.xhtml#ch6tab3) can be implemented
    with four-input AND gates, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg143_Image_190.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: The circuit for a 3×8 decoder with* Enable'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Decoders are more versatile than they might seem at first glance. Each possible
    input can be seen as a minterm (for a refresher on minterms, see “Canonical Sum
    or Sum of Minterms” on [page 62](ch04.xhtml#ch04lev2sec3) in [Chapter 4](ch04.xhtml)).
    The line decoder in [Table 6-3](ch06.xhtml#ch6tab3) shows that only a single output
    is `1` when a minterm evaluates to `1` and *Enable* is `1`. Thus, a decoder can
    be viewed as a “minterm generator.”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: We know from [Chapter 4](ch04.xhtml) that any logical expression can be represented
    as the OR of minterms, so it follows that we can implement any logical expression
    by OR-ing the output(s) of a decoder. For example, if you look back at the Karnaugh
    maps for the full adder ([Figures 6-2](ch06.xhtml#ch6fig2) and [6-4](ch06.xhtml#ch6fig4)),
    you might see that *Sum[i]*(*Carry[i]*, *x[i]*, *y[i]*) and *Carry*[*i* + 1](*Carry[i]*,
    *x[i]*, *y[i]*) can be expressed as the OR of minterms,
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg144_Image_191.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: where the subscript *i* on *x*, *y*, and *Carry* refers to the bit slice and
    the subscripts on *m* are part of the minterm notation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We can implement each bit slice of a full adder with a 3×8 decoder and two four-input
    OR gates, as shown in [Figure 6-9](ch06.xhtml#ch6fig9). An *n*-bit adder would
    require *n* of these circuits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg144_Image_192.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: A 1-bit slice of a full adder implemented with a 3×8 decoder*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The decoder circuit in [Figure 6-8](ch06.xhtml#ch6fig8) requires eight AND gates
    and three NOT gates. The full adder in [Figure 6-9](ch06.xhtml#ch6fig9) adds two
    OR gates, for a total of 13 logic gates. Comparing this with the full adder design
    in [Figure 6-5](ch06.xhtml#ch6fig5), which requires only five logic gates (two
    XOR, two AND, and one OR), it would seem that using a decoder to construct a full
    adder increases the complexity of the circuit. Keep in mind, however, that designs
    must take into account other factors, such as availability of components, cost
    of components, and so forth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-8](ch06.xhtml#ch6fig8)中的解码器电路需要八个与门和三个非门。[图6-9](ch06.xhtml#ch6fig9)中的全加器增加了两个或门，总共需要13个逻辑门。与[图6-5](ch06.xhtml#ch6fig5)中的全加器设计相比，该设计仅需要五个逻辑门（两个异或门、两个与门和一个或门），看起来使用解码器构建全加器会增加电路的复杂性。然而，请记住，设计必须考虑其他因素，如元件的可用性、元件成本等。'
- en: '**YOUR TURN**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: '6.2     You have probably seen seven-segment displays, which are used to display
    numerals. Each segment in a seven-segment display is lit by applying a `1` to
    the input pin connected to that segment. Suppose you have a seven-segment display
    with an 8-bit input that lights the segments and the decimal point, as shown in
    the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2    你可能见过七段显示器，它们用于显示数字。七段显示器中的每个段通过将`1`应用到连接该段的输入引脚来点亮。假设你有一个8位输入的七段显示器，它点亮段和小数点，如下图所示：
- en: '![Image](../images/pg145_Image_193.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg145_Image_193.jpg)'
- en: For example, you could display a 5 with the bit pattern `0110 1101`. However,
    it would be more convenient to write a program to use BCD for individual numerals.
    Design a decoder that transforms numerals in BCD to segment patterns on the seven-segment
    display.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用位模式`0110 1101`显示数字5。然而，写一个程序使用BCD编码来表示单个数字会更方便。设计一个解码器，将BCD中的数字转换为七段显示器上的段模式。
- en: '**Multiplexers**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多路复用器**'
- en: In the previous section, you learned how an *n*-bit number can be used to select
    which one of 2*^n* output lines should be set to `1`. The opposite situation also
    occurs, where we need to select which of several inputs should be passed on. For
    example, when performing arithmetic operations, such as addition, the numbers
    can come from different locations within the CPU. (You will learn more about this
    in the next few chapters.) The operation itself will be performed by one arithmetic
    unit, and the CPU needs to select the inputs to the operation from all the possible
    locations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你了解了如何使用*n*位数来选择应设置为`1`的2*^n*个输出线路中的一个。相反的情况也会发生，即我们需要选择哪些输入应该被传递。例如，在进行加法等算术操作时，数字可能来自CPU内部的不同位置。（你将在接下来的几章中学习更多内容。）操作本身将由一个算术单元执行，而CPU需要从所有可能的位置中选择操作的输入。
- en: A device that can make this selection is called a *multiplexer (MUX)*. It can
    switch between 2*^n* input lines by using *n* selection lines. [Figure 6-10](ch06.xhtml#ch6fig10)
    shows a circuit for a four-way multiplexer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 能够做出这种选择的设备叫做*多路复用器（MUX）*。它可以通过使用*n*个选择线路，在2*^n*个输入线路之间切换。[图6-10](ch06.xhtml#ch6fig10)展示了一个四路多路复用器的电路。
- en: '![Image](../images/pg146_Image_194.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_194.jpg)'
- en: '*Figure 6-10: A four-way multiplexer circuit*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：四路多路复用器电路*'
- en: 'The output is given by:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '![Image](../images/pg146_Image_195.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_195.jpg)'
- en: When using AND and OR gates, the number of transistors required to implement
    a multiplexer gets large as the number of inputs grows. A three-input AND gate
    is required for each input to the multiplexer, with the output of each AND gate
    connected to one of the inputs to the OR gate. So, the number of inputs to the
    OR gate equals the number of multiplexer inputs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用与门和或门时，随着输入数量的增加，实施一个多路复用器所需的晶体管数量会变得很大。每个输入到多路复用器的输入都需要一个三输入与门，每个与门的输出连接到或门的一个输入。所以，或门的输入数量等于多路复用器的输入数量。
- en: This four-way multiplexer requires a four-input OR gate. If we try to scale
    this up, the *n*-input OR gate will present some technical electronic problems
    for a large *n*. The use of an *n*-input OR gate can be avoided by using a type
    of gate that can disconnect its output signal from its input, which we’ll look
    at next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个四路多路复用器需要一个四输入的或门。如果我们尝试扩大规模，*n*输入的或门将为较大的*n*带来一些技术电子问题。通过使用一种能够断开其输出信号与输入信号连接的门，可以避免使用*n*输入的或门，接下来我们将讨论这种门。
- en: '**Tristate Buffer**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**三态缓冲器**'
- en: 'The logic gate called a *tristate buffer* has three possible outputs: `0`,
    `1`, and “no connection.” The “no connection” output is actually a high-impedance
    connection, also called *high Z* or *open*. A tristate buffer has both a data
    input and an *Enable* input, which behaves as shown in [Figure 6-11](ch06.xhtml#ch6fig11).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg146_Image_196.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A tristate buffer*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: When *Enable* = `1`, the output, which is equal to the input, is connected to
    whatever circuit element follows the tristate buffer. But when *Enable* = `0`,
    the output is essentially disconnected. This is different from `0`; being disconnected
    means it has no effect on the circuit element to which it is connected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The “no connection” output lets us physically connect the outputs of many tristate
    buffers but select only one to pass its input to the common output line. The four-way
    multiplexer in [Figure 6-12](ch06.xhtml#ch6fig12) shows how we avoid using an
    *n*-input OR gate by using *n* tristate buffers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_197.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: A four-way multiplexer built from a decoder and tristate buffers*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The 2×4 decoder in [Figure 6-12](ch06.xhtml#ch6fig12) selects which of the tristate
    buffers connects one of the inputs, *w*, *x*, *y*, or *z*, to the output to create
    a four-way multiplexer. [Figure 6-13](ch06.xhtml#ch6fig13) shows the circuit symbol
    used for a multiplexer, along with the truth table that shows its behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_198.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: A four-way multiplexer*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: As an example of where we might use a four-way multiplexer like this one, consider
    a computer with four registers and one adder. Let’s name the registers *w*, *x*,
    *y*, and *z*. If we connect the bits in the corresponding bit position from each
    register to a multiplexer, then we can use the 2-bit selector *s*[1]*s*[0] to
    choose which register will provide the input to the adder. For example, each bit
    in position 5, *w*[5], *x*[5], *y*[5], and *z*[5], would be connected to one of
    the inputs in multiplexer 5\. If *s*[1]*s*[0] = `10`, the input to the adder would
    be *y*[5].
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable Logic Devices**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve been discussing hardware designs that use individual logic gates.
    If the design changes, the logic gate configuration changes. This almost always
    means that the circuit board that holds the logic gates and connects them will
    need to be redesigned. A change also often means ordering a different kind of
    logic gate, which can be expensive and take time. These problems can be reduced
    by using *programmable logic devices (PLDs)* to implement the required logic function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: PLDs contain many AND gates and OR gates, which can be programmed to implement
    Boolean functions. The inputs, and their complemented value, are connected to
    the AND gates. The AND gates, taken together, are referred to as the *AND plane*
    or *AND array*. The outputs from the AND gates are connected to OR gates, which
    taken together are referred to as the *OR plane* or *OR array*. Depending on the
    type, one or both planes can be programmed to implement combinational logic. When
    using a PLD, a design change requires changing only how the device is programmed,
    not buying different devices, meaning the circuit board does not need to be redesigned.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: PLDs come in several types. Most can be programmed by a user. Some are preprogrammed
    at the time of manufacture, and some can even be erased and reprogrammed by the
    user. Programming technologies range from specifying the manufacturing mask (for
    the preprogrammed devices) to inexpensive electronic programming systems. We’ll
    look at the three main categories of PLDs in this section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '***Programmable Logic Array***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a *programmable logic array (PLA)*, both the AND and OR planes are programmable.
    PLAs are used to implement logic functions. [Figure 6-14](ch06.xhtml#ch6fig14)
    gives the general idea for a PLA that has two input variables and two possible
    output functions of these variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg148_Image_199.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: A simplified circuit for a programmable logic array*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Each input variable, in both its uncomplemented and complemented form, is an
    input to the AND gates through fuses. A *fuse* is a thin piece of conductor used
    to protect an electrical circuit. If the current flowing through it is high enough,
    the conductor melts, opening the circuit and stopping current flow. PLDs can be
    programmed by breaking (or *blowing*) the appropriate fuses, removing the input
    to the logic gate. Some devices use *antifuses* instead of fuses; these are normally
    open, and programming them consists of completing the connection instead of removing
    it. Devices that can be reprogrammed have fuses that can be broken and then remade.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-14](ch06.xhtml#ch6fig14), the S-shaped lines in the circuit diagram
    represent the fuses. The fuses can be blown or left in place so as to program
    each AND gate to output a product of the inputs, *x*,¬*x*, *y*, and ¬*y*. Since
    every input, plus its complement, is input to each AND gate, any of the AND gates
    can be programmed to output a minterm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The products produced by the AND gate plane are all connected to the inputs
    of the OR gates, also through fuses. Thus, depending on which OR gate fuses are
    left in place, the output of each OR gate is a sum of products. There may be additional
    logic circuitry to select between the different outputs. You have already seen
    that any Boolean function can be expressed as a sum of products, so this logic
    device can be programmed to implement any Boolean function by blowing the fuses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: A PLA is typically larger than the one shown in [Figure 6-14](ch06.xhtml#ch6fig14),
    which is already complicated to draw. To simplify the drawing, it is typical to
    use a diagram similar to [Figure 6-15](ch06.xhtml#ch6fig15) to specify the design.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg149_Image_200.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: A diagram for a programmable logic array where the dots represent
    connections*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram can be a little tricky to understand. In [Figure 6-14](ch06.xhtml#ch6fig14),
    each AND gate has multiple inputs: one for each variable and one for its complement.
    In [Figure 6-15](ch06.xhtml#ch6fig15), we use a single horizontal line leading
    to the input of each AND gate to represent multiple wires (variable and complement),
    so each AND gate in [Figure 6-15](ch06.xhtml#ch6fig15) has eight inputs, even
    though we draw only one line.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The dots at the intersections of the vertical and horizontal lines represent
    places where the fuses have been left intact, thus creating a connection. For
    example, the three dots on the topmost horizontal line indicate that there are
    three inputs left connected to that AND gate. The output of the topmost AND gate
    is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg150_Image_201.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Referring again to [Figure 6-14](ch06.xhtml#ch6fig14), you can see that the
    output from each AND gate is connected to each of the OR gates (through fuses).
    Therefore, the OR gates also have multiple inputs—one for each AND gate—and the
    vertical lines leading to the OR gate inputs represent multiple wires. The PLA
    in [Figure 6-15](ch06.xhtml#ch6fig15) has been programmed to provide these three
    functions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg150_Image_202.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Since the AND plane can produce all possible minterms and the OR plane can provide
    any sum of the minterms, a PLA can be used to implement any possible logical function.
    If we want to change the function, it’s a simple matter of programming another
    PLA and replacing the old one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '***Read-Only Memory***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although PLDs have no memory (meaning the current state isn’t affected by previous
    states of the inputs), they can be used to make *nonvolatile* memory—memory whose
    contents remain intact when the power is turned off. *Read-only memory (ROM)*
    is used to store bit patterns that can represent data or program instructions.
    A program can only read the data or program stored in ROM; the contents of the
    ROM cannot be changed by writing new data or program instructions to it. ROM is
    commonly used in devices that have a fixed set of functionalities, such as watches,
    automobile engine control units, and appliances. In fact, our lives are surrounded
    by devices that are controlled by programs stored in ROM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: ROM can be implemented as a PLD where only the OR gate plane can be programmed.
    The AND gate plane remains wired to provide all the min-terms. We can think of
    the inputs to the ROM as addresses; then, the OR gate plane is programmed to provide
    the bit pattern at each address. For example, the ROM diagrammed in [Figure 6-16](ch06.xhtml#ch6fig16)
    has two inputs, *a*[1] and *a*[0], which provide a 2-bit address.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg151_Image_203.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: A 4-byte ROM device*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The *×* connections in [Figure 6-16](ch06.xhtml#ch6fig16) represent permanent
    connections, showing that the AND gate plane is fixed. Each AND gate produces
    a min-term at each address in this ROM device. The OR gate plane produces up to
    2*^n* 8-bit bytes, where *n* is the width, in number of bits, of the address input
    to the AND gate plane. The connections (dots) to the OR gates represent the bit
    pattern stored at the corresponding address. [Table 6-4](ch06.xhtml#ch6tab4) shows
    a ROM device in which the OR gate plane has been programmed to store the four
    characters 0, 1, 2, and 3 (in ASCII code).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-4:** A ROM Device Holding Four ASCII Characters'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '| **Minterm** | **Address** | **Contents** | **ASCII character** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| ¬*a*[1]¬*a*[0] | `00` | `00110000` | 0 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| ¬*a*[1]*a*[0] | `01` | `00110001` | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| *a*[1] ¬*a*[0] | `10` | `00110010` | 2 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| *a*[1]*a*[0] | `11` | `00110011` | 3 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: Although we have stored only data in this example, computer instructions are
    bit patterns, so we could just as easily store an entire program in a ROM device.
    As with a PLA, if you need to change the program, you can just program another
    ROM device and replace the old one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of ROM devices. While the bit pattern is set in a ROM
    device during manufacturing, a *programmable read-only memory (PROM)* device is
    programmed by the person who uses it. There are also *erasable programmable read-only
    memory (EPROM)* devices that can be erased with an ultraviolet light and then
    reprogrammed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Programmable Array Logic***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In a *programmable array logic (PAL)* device, each OR gate is permanently wired
    to a group of AND gates. Only the AND gate plane is programmable. The PAL device
    diagrammed in [Figure 6-17](ch06.xhtml#ch6fig17) has four inputs and two outputs,
    each of which can be the sum of up to four products.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_204.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: A two-function programmable array logic device*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The “*×*” connections in the OR gate plane show that the top four AND gates
    are OR-ed to produce *F*[1](*w*, *x*, *y*, *z*) and the lower four are OR-ed to
    produce *F*[2](*w*, *x*, *y*, *z*). The AND gate plane in this figure has been
    programmed to produce these two functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_205.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Of the three types of programmable logic devices presented here, the PLA device
    is the most flexible, as we can program both the OR and the AND plane, but it
    is also the most expensive. The ROM device is less flexible: it can be programmed
    to produce any combination of minterms, which are then OR-ed together. We know
    that any function can be implemented as the OR of minterms, so we can produce
    any function with a ROM device, but a ROM device doesn’t allow us to minimize
    the function since all the product terms must be minterms.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The PAL device is the least flexible, because all the product terms programmed
    in the AND plane will be OR-ed together. So, we cannot select which minterms are
    in the function by programming the OR plane. However, PAL devices allow us to
    do some Boolean function minimization. If the required function can be implemented
    in a PAL device, this will be less expensive than using a ROM or PLA device.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 6.3     Design a ROM device that holds the four characters a, b, c, and d.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 6.4     Design a ROM device that holds the four characters A, B, C, and D.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '6.5     Comparing two values to determine which is larger, or whether they
    are the same, is a common operation in computing. The hardware device used to
    perform such a comparison is called a *comparator*. Use a programmable logic device
    to design a comparator that compares two 2-bit values. Your comparator will have
    three outputs: equal, greater than, and less than.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Combinational logic circuits**   These depend only on their input at any
    point in time. They have no memory of previous effects of the inputs. Examples
    include adders, decoders, multiplexers, and programmable logic devices.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Half adder**   This circuit has two 1-bit inputs and produces two 1-bit outputs:
    the sum of the inputs and the carry from that sum.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Full adder**   This circuit has three 1-bit inputs and produces two 1-bit
    outputs: the sum of the inputs and the carry from that sum.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Ripple-carry adder**   This circuit uses *n* full adders to add *n*-bit numbers.
    The carry output from each full adder is one of the three inputs to the full adders
    in the next higher-order bit position.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoder**   A device used to select one of *n* outputs based on 2*^n* inputs.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplexer (MUX)**   A device used to select one of 2*^n* inputs based on
    an *n*-bit selector signal.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable logic array (PLA)**   A device used to generate an OR-ed combination
    of minterms to implement Boolean functions in hardware.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only memory (ROM)**   Nonvolatile memory, with the input being the address
    of the data or instruction.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable array logic (PAL)**   A device used to implement Boolean functions
    in hardware. It’s less flexible than a PLA or ROM device, but also less expensive.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about sequential logic circuits, which use
    feedback to maintain a memory of their activity.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
