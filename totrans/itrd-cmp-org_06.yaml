- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COMBINATIONAL LOGIC CIRCUITS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, you learned about a computer’s basic component, the
    logic gate. Computers are constructed from assemblages of logic gates, called
    *logic circuits*, that process digital information.
  prefs: []
  type: TYPE_NORMAL
- en: In this and the following two chapters, we’ll look at how to build some of the
    logic circuits that make up CPUs, memory, and other devices. I won’t describe
    any of these units in their entirety; instead, we’ll look at a few small parts
    and discuss the concepts behind them. The goal is to provide an introductory overview
    of the ideas that underlie these logic circuits.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Two Types of Logic Circuits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of logic circuits. A *combinational logic circuit* has output
    that depends only on the inputs given at any specific time and not on any previous
    inputs. A *sequential logic circuit* has output that depends on both previous
    and current inputs.
  prefs: []
  type: TYPE_NORMAL
- en: To elucidate these two types, let’s consider a TV remote. You can select a specific
    channel by entering a number on the remote. The channel selection depends only
    on the number you entered and ignores the channels you were viewing before. Thus,
    the relationship between the input and the output is combinational.
  prefs: []
  type: TYPE_NORMAL
- en: The remote control also has an input for going up or down one channel. This
    input depends on the previously selected channel and the previous sequence of
    up/down button pushes. The channel up/down buttons illustrate a sequential input/output
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore sequential logic circuits in the next chapter. In this chapter,
    we’ll go through several examples of combinational logic circuits to see how they
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIGNAL VOLTAGE LEVELS**'
  prefs: []
  type: TYPE_NORMAL
- en: Electronic logic circuits represent `1`s and `0`s with either a high voltage
    or a low voltage. We call the voltage that represents `1` the *active voltage*.
    If we use a higher voltage to represent `1`, then the signal is called *active
    high*. If we use a lower voltage to represent `1`, then the signal is called *active
    low*.
  prefs: []
  type: TYPE_NORMAL
- en: An active-high signal can be connected to an active-low input, but the hardware
    designer must take the difference into account. For example, if the required logical
    input to an active-low input is `1`, the required voltage is the lower of the
    two voltages; if the signal to be connected to this input is active high, then
    a logical `1` is the higher of the two voltages, and the signal must first be
    complemented to be interpreted as a `1` at the active-low input.
  prefs: []
  type: TYPE_NORMAL
- en: I will use only logic levels—`0` and `1`—in the discussions of logic circuits
    in this book and avoid the actual voltage levels being used in the hardware, but
    you should know the terminology because it can come up when talking to others
    or reading component specification sheets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with one of the most fundamental operations performed in the CPU:
    adding two bits. Our eventual goal is to add two *n*-bit numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](ch02.xhtml) that the bits in a binary number are numbered
    from right (the least significant bit) to left (the most significant bit), starting
    with 0\. I’ll start by showing you how to add two bits in the *i*th bit position
    and complete the discussion by showing you how to add two 4-bit numbers, taking
    into account the carry from each bit position.
  prefs: []
  type: TYPE_NORMAL
- en: '***Half Adder***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Addition can be done with several kinds of circuits. We’ll start with the *half
    adder*, which simply adds the two bits in the current bit position of a number
    (expressed in binary). This is shown by the truth table in [Table 6-1](ch06.xhtml#ch6tab1),
    where *x[i]* is the *i*th bit of the number *x* and the values in the *y[i]* column
    represent the *i*th bit of the number *y*. *Sum[i]* is the *i*th bit of the number
    *Sum*, and *Carry[i]* [+ 1] is the carry from adding bits *x[i]* and *y[i]*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** A Truth Table for Adding Two Bits Using a Half Adder'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***x******[i]*** | ***y******[i]*** | ***Carry*****[*i* + 1]** | ***Sum***[***i***]
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: The sum is the XOR of the two inputs, and the carry is the AND of the two inputs.
    [Figure 6-1](ch06.xhtml#ch6fig1) shows the logic circuit for a half adder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg137_Image_174.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A half adder logic circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a flaw here: the half adder works with only two input bits. It
    can be used to add the two bits from the same bit position of two numbers, but
    it doesn’t take into account a possible carry from the next lower-order bit position.
    Including this carry as a third input will give us a full adder.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Full Adder***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike the half adder, a *full adder* circuit has three 1-bit inputs: *Carry[i]*,
    *x[i]*, and *y[i]*. *Carry[i]* is the carry that resulted when you added the two
    bits in the previous bit position (the bit to the right). For example, if we’re
    adding the two bits in bit position 5, the inputs to the full adder are the two
    bits in position 5 plus the carry from adding the bits in position 4\. [Table
    6-2](ch06.xhtml#ch6tab2) shows the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** A Truth Table for Adding Two Bits Using a Full Adder'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***Carry****[i]*** | ***x******[i]*** | ***y****[i]*** | ***Carry***[***i***
    + 1] | ***Sum***[***i***] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: 'To design a full adder circuit, we start with the function that specifies when
    *Sum[i]* is `1` as a sum of product terms from [Table 6-2](ch06.xhtml#ch6tab2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are no obvious simplifications in this equation, so let’s look at the
    Karnaugh map for *Sum[i]*, shown in [Figure 6-2](ch06.xhtml#ch6fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_176.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: A Karnaugh map for the sum of three bits,* Carry[i], x[i]*, and*
    y[i]'
  prefs: []
  type: TYPE_NORMAL
- en: There are no obvious groupings in [Figure 6-2](ch06.xhtml#ch6fig2), so we are
    left with the four product terms to compute *Sum[i]* in the previous equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned in [Chapter 4](ch04.xhtml) that *Carry[i]* [+ 1](*Carry[i]*, *x[i]*,
    *y[i]*) can be expressed by the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Together, these two functions give the circuit for a full adder, as shown in
    [Figure 6-3](ch06.xhtml#ch6fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg138_Image_178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A full adder circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: The full adder uses nine logic gates. In the next section, we’ll see if we can
    find a simpler circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Full Adder from Two Half Adders***'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if we can find a simpler solution for adding two bits and the carry
    from the next lower-order bit position, let’s go back to the equation for *Sum[i]*.
    Using the distribution rule, we can rearrange it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_179.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 4](ch04.xhtml), you learned that the quantity in the parentheses
    in the first product term is the XOR of *x[i]* and *y[i]*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_181.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s manipulate the quantity in the parentheses in the second product term.
    Recall that in Boolean algebra *x ∧ ¬x* = 0, so we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_182.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_183.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll do something to develop a Boolean function for *Carry[i]* [+ 1] that will
    probably seem counterintuitive. Let’s start with the Karnaugh map for carry when
    adding three bits (see [Figure 4-14](ch04.xhtml#ch4fig14)), but remove two of
    the groupings, as shown by the dotted lines in [Figure 6-4](ch06.xhtml#ch6fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_184.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The Karnaugh map for carry from [Figure 4-14](ch04.xhtml#ch4fig14),
    redrawn without two overlapping groupings (dotted lines)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg139_Image_185.jpg) Notice that two of the terms in this
    equation, (*x[i] ∧ y[i]*) and (*x[i]* ⊻ *y[i]*), are already generated by a half
    adder (see [Figure 6-1](ch06.xhtml#ch6fig1)). With a second half adder and an
    OR gate, we can implement a full adder, as shown in [Figure 6-5](ch06.xhtml#ch6fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg140_Image_186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: A full adder using two half adders*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you should understand where the terms *half adder* and *full adder* come
    from.
  prefs: []
  type: TYPE_NORMAL
- en: A simpler circuit is not always better. In truth, we cannot say which of the
    two full adder circuits in [Figures 6-3](ch06.xhtml#ch6fig3) and [6-5](ch06.xhtml#ch6fig6)
    is better just by looking at the logic circuits. Good engineering design depends
    on many factors, such as how each logic gate is implemented, the cost of the logic
    gates and their availability, and so forth. I’ve presented two alternatives here
    to show that different approaches can lead to different, but functionally equivalent,
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ripple-Carry Addition and Subtraction Circuits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you know how to add the two bits in a given bit position, plus a carry from
    the next lower-order bit position. But most values that a program works with have
    many bits, so we need a way to add the corresponding bits in each bit position
    of two *n*-bit numbers. This can be done with an *n-bit adder*, which can be implemented
    with *n* full adders. [Figure 6-6](ch06.xhtml#ch6fig6) shows a 4-bit adder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg140_Image_187.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: A 4-bit adder*'
  prefs: []
  type: TYPE_NORMAL
- en: Addition begins with the full adder on the right receiving the two lowest-order
    bits, *x*[0] and *y*[0]. Since this is the lowest-order bit, there is no carry,
    and *c*[0] = `0`. The bit sum is *s*[0], and the carry from this addition, *c*[1],
    is connected to the carry input of the next full adder to the left, where it is
    added to *x*[1] and *y*[1]. Thus, the *i*th full adder adds the two *i*th bits
    of the operands, plus the carry (which is either `0` or `1`) from the (*i* – 1)th
    full adder.
  prefs: []
  type: TYPE_NORMAL
- en: Each full adder handles one bit (often referred to as a *slice*) of the total
    width of the values being added. The carry from each bit position is added to
    the bits in the next higher-order bit position. The addition process flows from
    the lowest-order bit to the highest-order in a sort of rippling effect, which
    gives this method of adding the name *ripple-carry addition*.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in [Figure 6-6](ch06.xhtml#ch6fig6), we have `C` and `V`, the *carry
    flag* and *overflow flag*. You learned about carry and overflow in [Chapter 3](ch03.xhtml).
    The AArch64 architecture includes addition and subtraction instructions that record
    whether carry and overflow occurred in the CPU. You’ll learn more about this in
    [Chapter 9](ch09.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can use a similar idea to implement subtraction. Recall that
    in two’s complement, a number is negated by taking its two’s complement, flipping
    all the bits, and adding `1`. Thus, we can subtract *y* from *x* by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg141_Image_188.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can perform subtraction with our adder in [Figure 6-5](ch06.xhtml#ch6fig5)
    if we complement each *y[i]* and set the initial carry in to `1` instead of `0`.
    Each *y[i]* can be complemented by XOR-ing it with `1`. This leads to the 4-bit
    circuit in [Figure 6-7](ch06.xhtml#ch6fig7), which will add two 4-bit numbers
    when *func* = `0` and subtract them when *func* = `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg141_Image_189.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: A 4-bit adder/subtractor*'
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a time delay as the sum is computed from right to left.
    The computation time can be significantly reduced through circuit designs that
    make use of what can be known about the values of the intermediate carries, *c[i]*,
    but I won’t go into such details in this book. Let’s turn to our next type of
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1     In [Chapter 3](ch03.xhtml), you learned about the carry flag (`C`) and
    the overflow flag (`V`). The CPU also has a zero flag (`Z`) and a negative flag
    (`N`). The `Z` flag is `1` when the result of an arithmetic operation is zero,
    and the `N` flag is `1` when the result is a negative number if the number is
    considered to be in two’s complement notation. Design a circuit that uses the
    outputs of the full adders in [Figure 6-7](ch06.xhtml#ch6fig7), *s*[0], *s*[1],
    *s*[2], *s*[3], *c*[3], and *c*[4], and outputs the `C`, `V`, `N`, and `Z` flags.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many places in a computer require selecting one of several connections based
    on a number. For example, as you will see in [Chapter 8](ch08.xhtml), the CPU
    has a small amount of memory organized in *registers*, which are used for computations.
    The AArch64 architecture provides 31 general-purpose 64-bit registers. If an instruction
    uses one of the registers, 5 bits in the instruction must be used to select which
    of the 31 registers should be used.
  prefs: []
  type: TYPE_NORMAL
- en: This selection can be done with a *decoder*. The input to the decoder is the
    4-bit number of the register, and the output is one of 16 possible connections
    to the specified register.
  prefs: []
  type: TYPE_NORMAL
- en: A decoder has *n* binary inputs that can produce up to 2*^n* binary outputs.
    The most common type of decoder, sometimes called a *line decoder*, selects only
    one of the output lines to set to `1` for each input bit pattern. It’s also common
    for a decoder to include an *Enable* input. [Table 6-3](ch06.xhtml#ch6tab3) is
    a truth table for a 3×8 (three inputs, eight outputs) decoder with an *Enable*
    input that shows how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** A Truth Table for a 3×8 Decoder with *Enable*'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ***Enable*** | ***x***[2] | ***x***[1] | ***x***[0] | ***y***[7] | ***y***[6]
    | ***y***[5] | ***y***[4] | ***y***[3] | ***y***[2] | ***y***[1] | ***y***[0]
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: When *Enable* = `0`, all the output lines are `0`. When *Enable* = `1`, the
    3-bit number at the input, *x* = *x*[2]*x*[1]*x*[0], selects which output line
    is set to `1`. So, this decoder could be used to select one of eight registers
    with a 3-bit number. (I’m not using all of the 31 registers in the AArch64 architecture
    to keep the table a reasonable size here.)
  prefs: []
  type: TYPE_NORMAL
- en: The 3×8 line decoder specified in [Table 6-3](ch06.xhtml#ch6tab3) can be implemented
    with four-input AND gates, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg143_Image_190.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: The circuit for a 3×8 decoder with* Enable'
  prefs: []
  type: TYPE_NORMAL
- en: Decoders are more versatile than they might seem at first glance. Each possible
    input can be seen as a minterm (for a refresher on minterms, see “Canonical Sum
    or Sum of Minterms” on [page 62](ch04.xhtml#ch04lev2sec3) in [Chapter 4](ch04.xhtml)).
    The line decoder in [Table 6-3](ch06.xhtml#ch6tab3) shows that only a single output
    is `1` when a minterm evaluates to `1` and *Enable* is `1`. Thus, a decoder can
    be viewed as a “minterm generator.”
  prefs: []
  type: TYPE_NORMAL
- en: We know from [Chapter 4](ch04.xhtml) that any logical expression can be represented
    as the OR of minterms, so it follows that we can implement any logical expression
    by OR-ing the output(s) of a decoder. For example, if you look back at the Karnaugh
    maps for the full adder ([Figures 6-2](ch06.xhtml#ch6fig2) and [6-4](ch06.xhtml#ch6fig4)),
    you might see that *Sum[i]*(*Carry[i]*, *x[i]*, *y[i]*) and *Carry*[*i* + 1](*Carry[i]*,
    *x[i]*, *y[i]*) can be expressed as the OR of minterms,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg144_Image_191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the subscript *i* on *x*, *y*, and *Carry* refers to the bit slice and
    the subscripts on *m* are part of the minterm notation.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement each bit slice of a full adder with a 3×8 decoder and two four-input
    OR gates, as shown in [Figure 6-9](ch06.xhtml#ch6fig9). An *n*-bit adder would
    require *n* of these circuits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg144_Image_192.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: A 1-bit slice of a full adder implemented with a 3×8 decoder*'
  prefs: []
  type: TYPE_NORMAL
- en: The decoder circuit in [Figure 6-8](ch06.xhtml#ch6fig8) requires eight AND gates
    and three NOT gates. The full adder in [Figure 6-9](ch06.xhtml#ch6fig9) adds two
    OR gates, for a total of 13 logic gates. Comparing this with the full adder design
    in [Figure 6-5](ch06.xhtml#ch6fig5), which requires only five logic gates (two
    XOR, two AND, and one OR), it would seem that using a decoder to construct a full
    adder increases the complexity of the circuit. Keep in mind, however, that designs
    must take into account other factors, such as availability of components, cost
    of components, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '6.2     You have probably seen seven-segment displays, which are used to display
    numerals. Each segment in a seven-segment display is lit by applying a `1` to
    the input pin connected to that segment. Suppose you have a seven-segment display
    with an 8-bit input that lights the segments and the decimal point, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg145_Image_193.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, you could display a 5 with the bit pattern `0110 1101`. However,
    it would be more convenient to write a program to use BCD for individual numerals.
    Design a decoder that transforms numerals in BCD to segment patterns on the seven-segment
    display.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplexers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you learned how an *n*-bit number can be used to select
    which one of 2*^n* output lines should be set to `1`. The opposite situation also
    occurs, where we need to select which of several inputs should be passed on. For
    example, when performing arithmetic operations, such as addition, the numbers
    can come from different locations within the CPU. (You will learn more about this
    in the next few chapters.) The operation itself will be performed by one arithmetic
    unit, and the CPU needs to select the inputs to the operation from all the possible
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: A device that can make this selection is called a *multiplexer (MUX)*. It can
    switch between 2*^n* input lines by using *n* selection lines. [Figure 6-10](ch06.xhtml#ch6fig10)
    shows a circuit for a four-way multiplexer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg146_Image_194.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: A four-way multiplexer circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg146_Image_195.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using AND and OR gates, the number of transistors required to implement
    a multiplexer gets large as the number of inputs grows. A three-input AND gate
    is required for each input to the multiplexer, with the output of each AND gate
    connected to one of the inputs to the OR gate. So, the number of inputs to the
    OR gate equals the number of multiplexer inputs.
  prefs: []
  type: TYPE_NORMAL
- en: This four-way multiplexer requires a four-input OR gate. If we try to scale
    this up, the *n*-input OR gate will present some technical electronic problems
    for a large *n*. The use of an *n*-input OR gate can be avoided by using a type
    of gate that can disconnect its output signal from its input, which we’ll look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tristate Buffer**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logic gate called a *tristate buffer* has three possible outputs: `0`,
    `1`, and “no connection.” The “no connection” output is actually a high-impedance
    connection, also called *high Z* or *open*. A tristate buffer has both a data
    input and an *Enable* input, which behaves as shown in [Figure 6-11](ch06.xhtml#ch6fig11).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg146_Image_196.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A tristate buffer*'
  prefs: []
  type: TYPE_NORMAL
- en: When *Enable* = `1`, the output, which is equal to the input, is connected to
    whatever circuit element follows the tristate buffer. But when *Enable* = `0`,
    the output is essentially disconnected. This is different from `0`; being disconnected
    means it has no effect on the circuit element to which it is connected.
  prefs: []
  type: TYPE_NORMAL
- en: The “no connection” output lets us physically connect the outputs of many tristate
    buffers but select only one to pass its input to the common output line. The four-way
    multiplexer in [Figure 6-12](ch06.xhtml#ch6fig12) shows how we avoid using an
    *n*-input OR gate by using *n* tristate buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: A four-way multiplexer built from a decoder and tristate buffers*'
  prefs: []
  type: TYPE_NORMAL
- en: The 2×4 decoder in [Figure 6-12](ch06.xhtml#ch6fig12) selects which of the tristate
    buffers connects one of the inputs, *w*, *x*, *y*, or *z*, to the output to create
    a four-way multiplexer. [Figure 6-13](ch06.xhtml#ch6fig13) shows the circuit symbol
    used for a multiplexer, along with the truth table that shows its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg147_Image_198.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: A four-way multiplexer*'
  prefs: []
  type: TYPE_NORMAL
- en: As an example of where we might use a four-way multiplexer like this one, consider
    a computer with four registers and one adder. Let’s name the registers *w*, *x*,
    *y*, and *z*. If we connect the bits in the corresponding bit position from each
    register to a multiplexer, then we can use the 2-bit selector *s*[1]*s*[0] to
    choose which register will provide the input to the adder. For example, each bit
    in position 5, *w*[5], *x*[5], *y*[5], and *z*[5], would be connected to one of
    the inputs in multiplexer 5\. If *s*[1]*s*[0] = `10`, the input to the adder would
    be *y*[5].
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable Logic Devices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve been discussing hardware designs that use individual logic gates.
    If the design changes, the logic gate configuration changes. This almost always
    means that the circuit board that holds the logic gates and connects them will
    need to be redesigned. A change also often means ordering a different kind of
    logic gate, which can be expensive and take time. These problems can be reduced
    by using *programmable logic devices (PLDs)* to implement the required logic function.
  prefs: []
  type: TYPE_NORMAL
- en: PLDs contain many AND gates and OR gates, which can be programmed to implement
    Boolean functions. The inputs, and their complemented value, are connected to
    the AND gates. The AND gates, taken together, are referred to as the *AND plane*
    or *AND array*. The outputs from the AND gates are connected to OR gates, which
    taken together are referred to as the *OR plane* or *OR array*. Depending on the
    type, one or both planes can be programmed to implement combinational logic. When
    using a PLD, a design change requires changing only how the device is programmed,
    not buying different devices, meaning the circuit board does not need to be redesigned.
  prefs: []
  type: TYPE_NORMAL
- en: PLDs come in several types. Most can be programmed by a user. Some are preprogrammed
    at the time of manufacture, and some can even be erased and reprogrammed by the
    user. Programming technologies range from specifying the manufacturing mask (for
    the preprogrammed devices) to inexpensive electronic programming systems. We’ll
    look at the three main categories of PLDs in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Programmable Logic Array***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a *programmable logic array (PLA)*, both the AND and OR planes are programmable.
    PLAs are used to implement logic functions. [Figure 6-14](ch06.xhtml#ch6fig14)
    gives the general idea for a PLA that has two input variables and two possible
    output functions of these variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg148_Image_199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: A simplified circuit for a programmable logic array*'
  prefs: []
  type: TYPE_NORMAL
- en: Each input variable, in both its uncomplemented and complemented form, is an
    input to the AND gates through fuses. A *fuse* is a thin piece of conductor used
    to protect an electrical circuit. If the current flowing through it is high enough,
    the conductor melts, opening the circuit and stopping current flow. PLDs can be
    programmed by breaking (or *blowing*) the appropriate fuses, removing the input
    to the logic gate. Some devices use *antifuses* instead of fuses; these are normally
    open, and programming them consists of completing the connection instead of removing
    it. Devices that can be reprogrammed have fuses that can be broken and then remade.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-14](ch06.xhtml#ch6fig14), the S-shaped lines in the circuit diagram
    represent the fuses. The fuses can be blown or left in place so as to program
    each AND gate to output a product of the inputs, *x*,¬*x*, *y*, and ¬*y*. Since
    every input, plus its complement, is input to each AND gate, any of the AND gates
    can be programmed to output a minterm.
  prefs: []
  type: TYPE_NORMAL
- en: The products produced by the AND gate plane are all connected to the inputs
    of the OR gates, also through fuses. Thus, depending on which OR gate fuses are
    left in place, the output of each OR gate is a sum of products. There may be additional
    logic circuitry to select between the different outputs. You have already seen
    that any Boolean function can be expressed as a sum of products, so this logic
    device can be programmed to implement any Boolean function by blowing the fuses.
  prefs: []
  type: TYPE_NORMAL
- en: A PLA is typically larger than the one shown in [Figure 6-14](ch06.xhtml#ch6fig14),
    which is already complicated to draw. To simplify the drawing, it is typical to
    use a diagram similar to [Figure 6-15](ch06.xhtml#ch6fig15) to specify the design.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg149_Image_200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: A diagram for a programmable logic array where the dots represent
    connections*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram can be a little tricky to understand. In [Figure 6-14](ch06.xhtml#ch6fig14),
    each AND gate has multiple inputs: one for each variable and one for its complement.
    In [Figure 6-15](ch06.xhtml#ch6fig15), we use a single horizontal line leading
    to the input of each AND gate to represent multiple wires (variable and complement),
    so each AND gate in [Figure 6-15](ch06.xhtml#ch6fig15) has eight inputs, even
    though we draw only one line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dots at the intersections of the vertical and horizontal lines represent
    places where the fuses have been left intact, thus creating a connection. For
    example, the three dots on the topmost horizontal line indicate that there are
    three inputs left connected to that AND gate. The output of the topmost AND gate
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg150_Image_201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Referring again to [Figure 6-14](ch06.xhtml#ch6fig14), you can see that the
    output from each AND gate is connected to each of the OR gates (through fuses).
    Therefore, the OR gates also have multiple inputs—one for each AND gate—and the
    vertical lines leading to the OR gate inputs represent multiple wires. The PLA
    in [Figure 6-15](ch06.xhtml#ch6fig15) has been programmed to provide these three
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg150_Image_202.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the AND plane can produce all possible minterms and the OR plane can provide
    any sum of the minterms, a PLA can be used to implement any possible logical function.
    If we want to change the function, it’s a simple matter of programming another
    PLA and replacing the old one.
  prefs: []
  type: TYPE_NORMAL
- en: '***Read-Only Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although PLDs have no memory (meaning the current state isn’t affected by previous
    states of the inputs), they can be used to make *nonvolatile* memory—memory whose
    contents remain intact when the power is turned off. *Read-only memory (ROM)*
    is used to store bit patterns that can represent data or program instructions.
    A program can only read the data or program stored in ROM; the contents of the
    ROM cannot be changed by writing new data or program instructions to it. ROM is
    commonly used in devices that have a fixed set of functionalities, such as watches,
    automobile engine control units, and appliances. In fact, our lives are surrounded
    by devices that are controlled by programs stored in ROM.
  prefs: []
  type: TYPE_NORMAL
- en: ROM can be implemented as a PLD where only the OR gate plane can be programmed.
    The AND gate plane remains wired to provide all the min-terms. We can think of
    the inputs to the ROM as addresses; then, the OR gate plane is programmed to provide
    the bit pattern at each address. For example, the ROM diagrammed in [Figure 6-16](ch06.xhtml#ch6fig16)
    has two inputs, *a*[1] and *a*[0], which provide a 2-bit address.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg151_Image_203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: A 4-byte ROM device*'
  prefs: []
  type: TYPE_NORMAL
- en: The *×* connections in [Figure 6-16](ch06.xhtml#ch6fig16) represent permanent
    connections, showing that the AND gate plane is fixed. Each AND gate produces
    a min-term at each address in this ROM device. The OR gate plane produces up to
    2*^n* 8-bit bytes, where *n* is the width, in number of bits, of the address input
    to the AND gate plane. The connections (dots) to the OR gates represent the bit
    pattern stored at the corresponding address. [Table 6-4](ch06.xhtml#ch6tab4) shows
    a ROM device in which the OR gate plane has been programmed to store the four
    characters 0, 1, 2, and 3 (in ASCII code).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-4:** A ROM Device Holding Four ASCII Characters'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Minterm** | **Address** | **Contents** | **ASCII character** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ¬*a*[1]¬*a*[0] | `00` | `00110000` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| ¬*a*[1]*a*[0] | `01` | `00110001` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *a*[1] ¬*a*[0] | `10` | `00110010` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| *a*[1]*a*[0] | `11` | `00110011` | 3 |'
  prefs: []
  type: TYPE_TB
- en: Although we have stored only data in this example, computer instructions are
    bit patterns, so we could just as easily store an entire program in a ROM device.
    As with a PLA, if you need to change the program, you can just program another
    ROM device and replace the old one.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of ROM devices. While the bit pattern is set in a ROM
    device during manufacturing, a *programmable read-only memory (PROM)* device is
    programmed by the person who uses it. There are also *erasable programmable read-only
    memory (EPROM)* devices that can be erased with an ultraviolet light and then
    reprogrammed.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Programmable Array Logic***'
  prefs: []
  type: TYPE_NORMAL
- en: In a *programmable array logic (PAL)* device, each OR gate is permanently wired
    to a group of AND gates. Only the AND gate plane is programmable. The PAL device
    diagrammed in [Figure 6-17](ch06.xhtml#ch6fig17) has four inputs and two outputs,
    each of which can be the sum of up to four products.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_204.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: A two-function programmable array logic device*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “*×*” connections in the OR gate plane show that the top four AND gates
    are OR-ed to produce *F*[1](*w*, *x*, *y*, *z*) and the lower four are OR-ed to
    produce *F*[2](*w*, *x*, *y*, *z*). The AND gate plane in this figure has been
    programmed to produce these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg152_Image_205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of the three types of programmable logic devices presented here, the PLA device
    is the most flexible, as we can program both the OR and the AND plane, but it
    is also the most expensive. The ROM device is less flexible: it can be programmed
    to produce any combination of minterms, which are then OR-ed together. We know
    that any function can be implemented as the OR of minterms, so we can produce
    any function with a ROM device, but a ROM device doesn’t allow us to minimize
    the function since all the product terms must be minterms.'
  prefs: []
  type: TYPE_NORMAL
- en: The PAL device is the least flexible, because all the product terms programmed
    in the AND plane will be OR-ed together. So, we cannot select which minterms are
    in the function by programming the OR plane. However, PAL devices allow us to
    do some Boolean function minimization. If the required function can be implemented
    in a PAL device, this will be less expensive than using a ROM or PLA device.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.3     Design a ROM device that holds the four characters a, b, c, and d.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4     Design a ROM device that holds the four characters A, B, C, and D.
  prefs: []
  type: TYPE_NORMAL
- en: '6.5     Comparing two values to determine which is larger, or whether they
    are the same, is a common operation in computing. The hardware device used to
    perform such a comparison is called a *comparator*. Use a programmable logic device
    to design a comparator that compares two 2-bit values. Your comparator will have
    three outputs: equal, greater than, and less than.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Combinational logic circuits**   These depend only on their input at any
    point in time. They have no memory of previous effects of the inputs. Examples
    include adders, decoders, multiplexers, and programmable logic devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Half adder**   This circuit has two 1-bit inputs and produces two 1-bit outputs:
    the sum of the inputs and the carry from that sum.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full adder**   This circuit has three 1-bit inputs and produces two 1-bit
    outputs: the sum of the inputs and the carry from that sum.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ripple-carry adder**   This circuit uses *n* full adders to add *n*-bit numbers.
    The carry output from each full adder is one of the three inputs to the full adders
    in the next higher-order bit position.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoder**   A device used to select one of *n* outputs based on 2*^n* inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiplexer (MUX)**   A device used to select one of 2*^n* inputs based on
    an *n*-bit selector signal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable logic array (PLA)**   A device used to generate an OR-ed combination
    of minterms to implement Boolean functions in hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only memory (ROM)**   Nonvolatile memory, with the input being the address
    of the data or instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmable array logic (PAL)**   A device used to implement Boolean functions
    in hardware. It’s less flexible than a PLA or ROM device, but also less expensive.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about sequential logic circuits, which use
    feedback to maintain a memory of their activity.
  prefs: []
  type: TYPE_NORMAL
