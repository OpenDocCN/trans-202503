- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6  '
- en: COMBINATIONAL LOGIC CIRCUITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '组合逻辑电路**  '
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)  '
- en: In the previous chapter, you learned about a computer’s basic component, the
    logic gate. Computers are constructed from assemblages of logic gates, called
    *logic circuits*, that process digital information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，你了解了计算机的基本组成部分——逻辑门。计算机是由逻辑门的组合构成的，这些逻辑门被称为*逻辑电路*，用于处理数字信息。  '
- en: In this and the following two chapters, we’ll look at how to build some of the
    logic circuits that make up CPUs, memory, and other devices. I won’t describe
    any of these units in their entirety; instead, we’ll look at a few small parts
    and discuss the concepts behind them. The goal is to provide an introductory overview
    of the ideas that underlie these logic circuits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章以及接下来的两章中，我们将探讨如何构建一些构成 CPU、内存和其他设备的逻辑电路。我不会描述这些单元的全部内容；相反，我们将查看其中的一些小部分，并讨论其背后的概念。目标是提供一个关于这些逻辑电路背后思想的入门概览。  '
- en: '**The Two Types of Logic Circuits**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑电路的两种类型**'
- en: There are two types of logic circuits. A *combinational logic circuit* has output
    that depends only on the inputs given at any specific time and not on any previous
    inputs. A *sequential logic circuit* has output that depends on both previous
    and current inputs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '逻辑电路有两种类型。*组合逻辑电路*的输出仅依赖于任何特定时刻给定的输入，而不依赖于任何先前的输入。*时序逻辑电路*的输出依赖于先前和当前的输入。  '
- en: To elucidate these two types, let’s consider a TV remote. You can select a specific
    channel by entering a number on the remote. The channel selection depends only
    on the number you entered and ignores the channels you were viewing before. Thus,
    the relationship between the input and the output is combinational.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '为了阐明这两种类型，我们考虑一个电视遥控器。你可以通过在遥控器上输入数字来选择一个特定的频道。频道选择仅依赖于你输入的数字，而忽略了你之前正在查看的频道。因此，输入与输出之间的关系是组合的。  '
- en: The remote control also has an input for going up or down one channel. This
    input depends on the previously selected channel and the previous sequence of
    up/down button pushes. The channel up/down buttons illustrate a sequential input/output
    relationship.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '遥控器还有一个输入，用于调节频道的升高或降低。这个输入依赖于先前选择的频道和之前上下频道按钮的序列。频道上下按钮展示了一个时序输入/输出的关系。  '
- en: We’ll explore sequential logic circuits in the next chapter. In this chapter,
    we’ll go through several examples of combinational logic circuits to see how they
    function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在下一章探讨时序逻辑电路。在本章中，我们将通过几个组合逻辑电路的例子来了解它们是如何工作的。  '
- en: '**SIGNAL VOLTAGE LEVELS**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号电压水平**  '
- en: Electronic logic circuits represent `1`s and `0`s with either a high voltage
    or a low voltage. We call the voltage that represents `1` the *active voltage*.
    If we use a higher voltage to represent `1`, then the signal is called *active
    high*. If we use a lower voltage to represent `1`, then the signal is called *active
    low*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '电子逻辑电路用高电压或低电压来表示`1`和`0`。我们将表示`1`的电压称为*有效电压*。如果我们使用更高的电压来表示`1`，那么该信号称为*高电平有效*。如果我们使用较低的电压来表示`1`，那么该信号称为*低电平有效*。  '
- en: An active-high signal can be connected to an active-low input, but the hardware
    designer must take the difference into account. For example, if the required logical
    input to an active-low input is `1`, the required voltage is the lower of the
    two voltages; if the signal to be connected to this input is active high, then
    a logical `1` is the higher of the two voltages, and the signal must first be
    complemented to be interpreted as a `1` at the active-low input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '一个高电平信号可以连接到一个低电平输入，但硬件设计师必须考虑到这种差异。例如，如果所需的逻辑输入为低电平输入的是`1`，则所需电压是两种电压中较低的；如果连接到该输入的信号是高电平的，则逻辑`1`是两种电压中较高的，信号必须先被反向才能在低电平输入中被解释为`1`。  '
- en: I will use only logic levels—`0` and `1`—in the discussions of logic circuits
    in this book and avoid the actual voltage levels being used in the hardware, but
    you should know the terminology because it can come up when talking to others
    or reading component specification sheets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '我在本书中讨论逻辑电路时只使用逻辑电平——`0`和`1`——而避免使用硬件中实际的电压水平，但你应该了解这些术语，因为它们在与他人交谈或阅读组件规格书时可能会出现。  '
- en: '**Adders**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加法器**  '
- en: 'We’ll start with one of the most fundamental operations performed in the CPU:
    adding two bits. Our eventual goal is to add two *n*-bit numbers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从 CPU 中执行的最基本操作之一开始：加法运算两个比特。我们的最终目标是加法运算两个 *n* 位数。  '
- en: Recall from [Chapter 2](ch02.xhtml) that the bits in a binary number are numbered
    from right (the least significant bit) to left (the most significant bit), starting
    with 0\. I’ll start by showing you how to add two bits in the *i*th bit position
    and complete the discussion by showing you how to add two 4-bit numbers, taking
    into account the carry from each bit position.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第 2 章](ch02.xhtml)回顾，二进制数中的位从右向左编号（最低有效位到最高有效位），从0开始。我将从展示如何在第*i*位位置添加两个位开始，并通过展示如何添加两个4位数并考虑每个位位置的进位来完成讨论。
- en: '***Half Adder***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***半加器***'
- en: Addition can be done with several kinds of circuits. We’ll start with the *half
    adder*, which simply adds the two bits in the current bit position of a number
    (expressed in binary). This is shown by the truth table in [Table 6-1](ch06.xhtml#ch6tab1),
    where *x[i]* is the *i*th bit of the number *x* and the values in the *y[i]* column
    represent the *i*th bit of the number *y*. *Sum[i]* is the *i*th bit of the number
    *Sum*, and *Carry[i]* [+ 1] is the carry from adding bits *x[i]* and *y[i]*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用几种电路进行加法运算。我们将从*半加器*开始，它简单地将一个数的当前位位置上的两个位相加（以二进制表示）。这在[表 6-1](ch06.xhtml#ch6tab1)中的真值表中展示，其中*x[i]*是数*x*的第*i*位，*y[i]*列中的值表示数*y*的第*i*位。*Sum[i]*是数*Sum*的第*i*位，*Carry[i]*
    [+ 1]是从添加位*x[i]*和*y[i]*得到的进位。
- en: '**Table 6-1:** A Truth Table for Adding Two Bits Using a Half Adder'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1:** 使用半加器添加两个位的真值表'
- en: '| ***x******[i]*** | ***y******[i]*** | ***Carry*****[*i* + 1]** | ***Sum***[***i***]
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| ***x******[i]*** | ***y******[i]*** | ***Carry*****[*i* + 1]** | ***Sum***[***i***]
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `1` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` |'
- en: '| `1` | `0` | `0` | `1` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` |'
- en: '| `1` | `1` | `1` | `0` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` |'
- en: The sum is the XOR of the two inputs, and the carry is the AND of the two inputs.
    [Figure 6-1](ch06.xhtml#ch6fig1) shows the logic circuit for a half adder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和是两个输入的异或，进位是两个输入的与。[图 6-1](ch06.xhtml#ch6fig1)展示了半加器的逻辑电路。
- en: '![Image](../images/pg137_Image_174.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_174.jpg)'
- en: '*Figure 6-1: A half adder logic circuit*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：半加器逻辑电路*'
- en: 'But there’s a flaw here: the half adder works with only two input bits. It
    can be used to add the two bits from the same bit position of two numbers, but
    it doesn’t take into account a possible carry from the next lower-order bit position.
    Including this carry as a third input will give us a full adder.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个缺陷：半加器只能处理两个输入位。它可以用来添加两个数的同一位位置的两个位，但它不考虑可能来自下一个低阶位位置的进位。将此进位作为第三个输入包括进来将得到一个全加器。
- en: '***Full Adder***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***全加器***'
- en: 'Unlike the half adder, a *full adder* circuit has three 1-bit inputs: *Carry[i]*,
    *x[i]*, and *y[i]*. *Carry[i]* is the carry that resulted when you added the two
    bits in the previous bit position (the bit to the right). For example, if we’re
    adding the two bits in bit position 5, the inputs to the full adder are the two
    bits in position 5 plus the carry from adding the bits in position 4\. [Table
    6-2](ch06.xhtml#ch6tab2) shows the results.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与半加器不同，*全加器*电路有三个1位输入：*Carry[i]*、*x[i]*和*y[i]*。*Carry[i]*是将两个上一个位位置的位相加时产生的进位（右边的位）。例如，如果我们正在添加位位置5的两个位，那么全加器的输入是位位置5的两个位加上位于位置4的进位。[表
    6-2](ch06.xhtml#ch6tab2)显示了结果。
- en: '**Table 6-2:** A Truth Table for Adding Two Bits Using a Full Adder'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-2:** 使用全加器添加两个位的真值表'
- en: '| ***Carry****[i]*** | ***x******[i]*** | ***y****[i]*** | ***Carry***[***i***
    + 1] | ***Sum***[***i***] |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ***Carry****[i]*** | ***x******[i]*** | ***y****[i]*** | ***Carry***[***i***
    + 1] | ***Sum***[***i***] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `1` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `1` |'
- en: '| `0` | `1` | `0` | `0` | `1` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `1` |'
- en: '| `0` | `1` | `1` | `1` | `0` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` |'
- en: '| `1` | `0` | `0` | `0` | `1` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `0` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `1` | `0` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `0` |'
- en: '| `1` | `1` | `1` | `1` | `1` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` |'
- en: 'To design a full adder circuit, we start with the function that specifies when
    *Sum[i]* is `1` as a sum of product terms from [Table 6-2](ch06.xhtml#ch6tab2):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计一个全加器电路，我们从指定*Sum[i]*为`1`的函数开始，作为来自[表 6-2](ch06.xhtml#ch6tab2)的积和项：
- en: '![Image](../images/pg138_Image_175.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_175.jpg)'
- en: There are no obvious simplifications in this equation, so let’s look at the
    Karnaugh map for *Sum[i]*, shown in [Figure 6-2](ch06.xhtml#ch6fig2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此方程式中没有明显的简化，因此让我们看看*Sum[i]*的卡诺图，如[图 6-2](ch06.xhtml#ch6fig2)所示。
- en: '![Image](../images/pg138_Image_176.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_176.jpg)'
- en: '*Figure 6-2: A Karnaugh map for the sum of three bits,* Carry[i], x[i]*, and*
    y[i]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：三个比特的和的卡诺图，*进位[i]*，x[i]*和*y[i]*'
- en: There are no obvious groupings in [Figure 6-2](ch06.xhtml#ch6fig2), so we are
    left with the four product terms to compute *Sum[i]* in the previous equation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-2](ch06.xhtml#ch6fig2)中没有明显的分组，因此我们剩下四个积项来计算前面方程中的*Sum[i]*。
- en: 'You learned in [Chapter 4](ch04.xhtml) that *Carry[i]* [+ 1](*Carry[i]*, *x[i]*,
    *y[i]*) can be expressed by the equation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 4 章](ch04.xhtml)中学到，*进位[i]* [+ 1](*进位[i]*, *x[i]*, *y[i]*)可以通过以下方程表示：
- en: '![Image](../images/pg138_Image_177.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_177.jpg)'
- en: Together, these two functions give the circuit for a full adder, as shown in
    [Figure 6-3](ch06.xhtml#ch6fig3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数共同构成了全加器的电路，如[图 6-3](ch06.xhtml#ch6fig3)所示。
- en: '![Image](../images/pg138_Image_178.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_178.jpg)'
- en: '*Figure 6-3: A full adder circuit*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：全加器电路*'
- en: The full adder uses nine logic gates. In the next section, we’ll see if we can
    find a simpler circuit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器使用九个逻辑门。在接下来的部分中，我们将看到是否能找到一个更简单的电路。
- en: '#### ***Full Adder from Two Half Adders***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***由两个半加器构成的全加器***'
- en: 'To see if we can find a simpler solution for adding two bits and the carry
    from the next lower-order bit position, let’s go back to the equation for *Sum[i]*.
    Using the distribution rule, we can rearrange it as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看是否能找到一个更简单的方案来加法两位和来自下一低阶位的进位，让我们回到*Sum[i]*的方程。利用分配法则，我们可以将其重新排列如下：
- en: '![Image](../images/pg139_Image_179.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_179.jpg)'
- en: 'In [Chapter 4](ch04.xhtml), you learned that the quantity in the parentheses
    in the first product term is the XOR of *x[i]* and *y[i]*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.xhtml)中，你学到了第一个积项中括号里的量是*x[i]*和*y[i]*的异或（XOR）：
- en: '![Image](../images/pg139_Image_180.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_180.jpg)'
- en: 'Thus, we have:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出：
- en: '![Image](../images/pg139_Image_181.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_181.jpg)'
- en: 'Let’s manipulate the quantity in the parentheses in the second product term.
    Recall that in Boolean algebra *x ∧ ¬x* = 0, so we can write the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们操作第二个积项中的括号里的量。回忆一下布尔代数中 *x ∧ ¬x* = 0，所以我们可以写出如下式子：
- en: '![Image](../images/pg139_Image_182.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_182.jpg)'
- en: 'Thus:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '![Image](../images/pg139_Image_183.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_183.jpg)'
- en: We’ll do something to develop a Boolean function for *Carry[i]* [+ 1] that will
    probably seem counterintuitive. Let’s start with the Karnaugh map for carry when
    adding three bits (see [Figure 4-14](ch04.xhtml#ch4fig14)), but remove two of
    the groupings, as shown by the dotted lines in [Figure 6-4](ch06.xhtml#ch6fig4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些操作，开发出一个*进位[i]* [+ 1]的布尔函数，这个操作可能会显得违反直觉。让我们从加法三个比特时的进位卡诺图开始（见[图 4-14](ch04.xhtml#ch4fig14)），但去除两个分组，如[图
    6-4](ch06.xhtml#ch6fig4)中虚线所示。
- en: '![Image](../images/pg139_Image_184.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_184.jpg)'
- en: '*Figure 6-4: The Karnaugh map for carry from [Figure 4-14](ch04.xhtml#ch4fig14),
    redrawn without two overlapping groupings (dotted lines)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：来自[图 4-14](ch04.xhtml#ch4fig14)的卡诺图，重新绘制去除了两个重叠分组（虚线）*'
- en: 'This will give us the following equation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下方程：
- en: '![Image](../images/pg139_Image_185.jpg) Notice that two of the terms in this
    equation, (*x[i] ∧ y[i]*) and (*x[i]* ⊻ *y[i]*), are already generated by a half
    adder (see [Figure 6-1](ch06.xhtml#ch6fig1)). With a second half adder and an
    OR gate, we can implement a full adder, as shown in [Figure 6-5](ch06.xhtml#ch6fig5).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg139_Image_185.jpg) 注意，这个方程中的两个项，(*x[i] ∧ y[i]*) 和 (*x[i]*
    ⊻ *y[i]*), 已经通过半加器生成（见[图 6-1](ch06.xhtml#ch6fig1)）。通过第二个半加器和一个或门，我们可以实现一个全加器，如[图
    6-5](ch06.xhtml#ch6fig5)所示。'
- en: '![Image](../images/pg140_Image_186.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg140_Image_186.jpg)'
- en: '*Figure 6-5: A full adder using two half adders*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：使用两个半加器的全加器*'
- en: Now you should understand where the terms *half adder* and *full adder* come
    from.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解了*半加器*和*全加器*这两个术语的来源。
- en: A simpler circuit is not always better. In truth, we cannot say which of the
    two full adder circuits in [Figures 6-3](ch06.xhtml#ch6fig3) and [6-5](ch06.xhtml#ch6fig6)
    is better just by looking at the logic circuits. Good engineering design depends
    on many factors, such as how each logic gate is implemented, the cost of the logic
    gates and their availability, and so forth. I’ve presented two alternatives here
    to show that different approaches can lead to different, but functionally equivalent,
    designs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的电路不一定更好。事实上，我们不能仅凭观察[图6-3](ch06.xhtml#ch6fig3)和[6-5](ch06.xhtml#ch6fig6)中的两个全加器电路就判断哪一个更好。好的工程设计取决于许多因素，例如每个逻辑门的实现方式、逻辑门的成本及其可用性等等。我在这里展示了两种替代方案，以表明不同的方法可以导致不同但功能等效的设计。
- en: '***Ripple-Carry Addition and Subtraction Circuits***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***波纹进位加法和减法电路***'
- en: Now you know how to add the two bits in a given bit position, plus a carry from
    the next lower-order bit position. But most values that a program works with have
    many bits, so we need a way to add the corresponding bits in each bit position
    of two *n*-bit numbers. This can be done with an *n-bit adder*, which can be implemented
    with *n* full adders. [Figure 6-6](ch06.xhtml#ch6fig6) shows a 4-bit adder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何加两个给定位置的比特，并加上来自下一个低位位置的进位。但是大多数程序处理的数值都有很多比特，因此我们需要一种方法来加两个*n*位数的每个位的对应比特。这可以通过*n*位加法器来实现，它可以通过*n*个全加器来构建。[图6-6](ch06.xhtml#ch6fig6)展示了一个4位加法器。
- en: '![Image](../images/pg140_Image_187.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg140_Image_187.jpg)'
- en: '*Figure 6-6: A 4-bit adder*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：一个4位加法器*'
- en: Addition begins with the full adder on the right receiving the two lowest-order
    bits, *x*[0] and *y*[0]. Since this is the lowest-order bit, there is no carry,
    and *c*[0] = `0`. The bit sum is *s*[0], and the carry from this addition, *c*[1],
    is connected to the carry input of the next full adder to the left, where it is
    added to *x*[1] and *y*[1]. Thus, the *i*th full adder adds the two *i*th bits
    of the operands, plus the carry (which is either `0` or `1`) from the (*i* – 1)th
    full adder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加法从右侧的全加器开始，接收两个最低位的比特，*x*[0]和*y*[0]。由于这是最低位，因此没有进位，*c*[0] = `0`。该位的和是*s*[0]，并且来自此加法的进位*c*[1]被连接到左侧下一个全加器的进位输入，在那里它与*x*[1]和*y*[1]相加。因此，第*i*个全加器将操作数的两个*i*位加起来，并加上来自(*i*
    - 1)个全加器的进位（其值为`0`或`1`）。
- en: Each full adder handles one bit (often referred to as a *slice*) of the total
    width of the values being added. The carry from each bit position is added to
    the bits in the next higher-order bit position. The addition process flows from
    the lowest-order bit to the highest-order in a sort of rippling effect, which
    gives this method of adding the name *ripple-carry addition*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个全加器处理一个比特（通常称为*切片*）的总宽度。每个位位置的进位将加到下一个更高位位置的比特上。加法过程从最低位流向最高位，以一种波动效应进行，这也赋予了这种加法方法名称——*波纹进位加法*。
- en: Notice that in [Figure 6-6](ch06.xhtml#ch6fig6), we have `C` and `V`, the *carry
    flag* and *overflow flag*. You learned about carry and overflow in [Chapter 3](ch03.xhtml).
    The AArch64 architecture includes addition and subtraction instructions that record
    whether carry and overflow occurred in the CPU. You’ll learn more about this in
    [Chapter 9](ch09.xhtml).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图6-6](ch06.xhtml#ch6fig6)中，我们有`C`和`V`，分别是*进位标志*和*溢出标志*。你在[第3章](ch03.xhtml)中已经学习了进位和溢出。AArch64架构包括记录进位和溢出是否发生的加法和减法指令。你将在[第9章](ch09.xhtml)中学到更多内容。
- en: 'Let’s see how we can use a similar idea to implement subtraction. Recall that
    in two’s complement, a number is negated by taking its two’s complement, flipping
    all the bits, and adding `1`. Thus, we can subtract *y* from *x* by doing this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用类似的思路来实现减法。回想一下，在二进制补码表示法中，一个数的负值是通过取它的二进制补码，翻转所有位并加上`1`来实现的。因此，我们可以通过以下方式从*x*中减去*y*：
- en: '![Image](../images/pg141_Image_188.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg141_Image_188.jpg)'
- en: We can perform subtraction with our adder in [Figure 6-5](ch06.xhtml#ch6fig5)
    if we complement each *y[i]* and set the initial carry in to `1` instead of `0`.
    Each *y[i]* can be complemented by XOR-ing it with `1`. This leads to the 4-bit
    circuit in [Figure 6-7](ch06.xhtml#ch6fig7), which will add two 4-bit numbers
    when *func* = `0` and subtract them when *func* = `1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对每个*y[i]*取反，并将初始进位设为`1`，而不是`0`，那么我们就可以在[图6-5](ch06.xhtml#ch6fig5)中的加法器实现减法。每个*y[i]*可以通过与`1`进行异或操作来取反。这就得到了[图6-7](ch06.xhtml#ch6fig7)中的4位电路，当*func*
    = `0`时，它会加两个4位数，当*func* = `1`时，它会减这两个数。
- en: '![Image](../images/pg141_Image_189.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg141_Image_189.jpg)'
- en: '*Figure 6-7: A 4-bit adder/subtractor*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：一个4位加法器/减法器*'
- en: There is, of course, a time delay as the sum is computed from right to left.
    The computation time can be significantly reduced through circuit designs that
    make use of what can be known about the values of the intermediate carries, *c[i]*,
    but I won’t go into such details in this book. Let’s turn to our next type of
    circuit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在从右到左计算和时会有时间延迟。通过电路设计，利用已知的中间进位值 *c[i]*，可以显著减少计算时间，但我在本书中不会详细讲解这些细节。让我们转到下一个电路类型。
- en: '**YOUR TURN**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 6.1     In [Chapter 3](ch03.xhtml), you learned about the carry flag (`C`) and
    the overflow flag (`V`). The CPU also has a zero flag (`Z`) and a negative flag
    (`N`). The `Z` flag is `1` when the result of an arithmetic operation is zero,
    and the `N` flag is `1` when the result is a negative number if the number is
    considered to be in two’s complement notation. Design a circuit that uses the
    outputs of the full adders in [Figure 6-7](ch06.xhtml#ch6fig7), *s*[0], *s*[1],
    *s*[2], *s*[3], *c*[3], and *c*[4], and outputs the `C`, `V`, `N`, and `Z` flags.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 6.1 在[第 3 章](ch03.xhtml)中，你学习了进位标志（`C`）和溢出标志（`V`）。CPU 还具有零标志（`Z`）和负标志（`N`）。当算术操作的结果为零时，`Z`
    标志为 `1`；如果结果是负数，并且该数字被认为是二补码表示，则 `N` 标志为 `1`。设计一个电路，使用[图 6-7](ch06.xhtml#ch6fig7)中的全加器输出，*s*[0]、*s*[1]、*s*[2]、*s*[3]、*c*[3]
    和 *c*[4]，并输出 `C`、`V`、`N` 和 `Z` 标志。
- en: '**Decoders**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解码器**'
- en: Many places in a computer require selecting one of several connections based
    on a number. For example, as you will see in [Chapter 8](ch08.xhtml), the CPU
    has a small amount of memory organized in *registers*, which are used for computations.
    The AArch64 architecture provides 31 general-purpose 64-bit registers. If an instruction
    uses one of the registers, 5 bits in the instruction must be used to select which
    of the 31 registers should be used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的许多地方需要根据一个数字选择多个连接中的一个。例如，正如你将在[第 8 章](ch08.xhtml)中看到的，CPU 有一小部分组织成 *寄存器*
    的内存，用于计算。AArch64 架构提供了 31 个通用的 64 位寄存器。如果一条指令使用其中一个寄存器，则必须使用指令中的 5 位来选择应该使用哪个
    31 个寄存器之一。
- en: This selection can be done with a *decoder*. The input to the decoder is the
    4-bit number of the register, and the output is one of 16 possible connections
    to the specified register.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择可以通过 *解码器* 完成。解码器的输入是寄存器的 4 位数字，输出是连接到指定寄存器的 16 个可能连接中的一个。
- en: A decoder has *n* binary inputs that can produce up to 2*^n* binary outputs.
    The most common type of decoder, sometimes called a *line decoder*, selects only
    one of the output lines to set to `1` for each input bit pattern. It’s also common
    for a decoder to include an *Enable* input. [Table 6-3](ch06.xhtml#ch6tab3) is
    a truth table for a 3×8 (three inputs, eight outputs) decoder with an *Enable*
    input that shows how this works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器有 *n* 个二进制输入，可以产生最多 2*^n* 个二进制输出。最常见的解码器类型，有时称为 *线路解码器*，它根据每个输入位模式只选择一个输出线并将其设为
    `1`。解码器通常还包括一个 *使能* 输入。[表 6-3](ch06.xhtml#ch6tab3)是一个带有 *使能* 输入的 3×8（三个输入，八个输出）解码器的真值表，展示了其工作原理。
- en: '**Table 6-3:** A Truth Table for a 3×8 Decoder with *Enable*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-3：** 带有*使能*的 3×8 解码器真值表'
- en: '|  | **Input** | **Output** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  | **输入** | **输出** |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ***Enable*** | ***x***[2] | ***x***[1] | ***x***[0] | ***y***[7] | ***y***[6]
    | ***y***[5] | ***y***[4] | ***y***[3] | ***y***[2] | ***y***[1] | ***y***[0]
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| ***使能*** | ***x***[2] | ***x***[1] | ***x***[0] | ***y***[7] | ***y***[6]
    | ***y***[5] | ***y***[4] | ***y***[3] | ***y***[2] | ***y***[1] | ***y***[0]
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `1` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` |'
- en: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` |'
- en: '| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | `0` | `0` | `0` | `1` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `1` | `0` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `1` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | `0` | `1` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `1` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` | `0` | `0` | `0` | `0` | `0` | `0` | `0` |'
- en: When *Enable* = `0`, all the output lines are `0`. When *Enable* = `1`, the
    3-bit number at the input, *x* = *x*[2]*x*[1]*x*[0], selects which output line
    is set to `1`. So, this decoder could be used to select one of eight registers
    with a 3-bit number. (I’m not using all of the 31 registers in the AArch64 architecture
    to keep the table a reasonable size here.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *Enable* = `0` 时，所有输出线都是 `0`。当 *Enable* = `1` 时，输入的 3 位数 *x* = *x*[2]*x*[1]*x*[0]
    会选择哪个输出线被设置为 `1`。因此，该解码器可用于用 3 位数字选择八个寄存器中的一个。（我这里没有使用 AArch64 架构中的所有 31 个寄存器，以保持表格的合理大小。）
- en: The 3×8 line decoder specified in [Table 6-3](ch06.xhtml#ch6tab3) can be implemented
    with four-input AND gates, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 6-3](ch06.xhtml#ch6tab3)中指定的 3×8 行解码器可以通过四输入与门实现，如[图 6-8](ch06.xhtml#ch6fig8)所示。
- en: '![Image](../images/pg143_Image_190.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg143_Image_190.jpg)'
- en: '*Figure 6-8: The circuit for a 3×8 decoder with* Enable'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：带有 Enable 的 3×8 解码器电路*'
- en: Decoders are more versatile than they might seem at first glance. Each possible
    input can be seen as a minterm (for a refresher on minterms, see “Canonical Sum
    or Sum of Minterms” on [page 62](ch04.xhtml#ch04lev2sec3) in [Chapter 4](ch04.xhtml)).
    The line decoder in [Table 6-3](ch06.xhtml#ch6tab3) shows that only a single output
    is `1` when a minterm evaluates to `1` and *Enable* is `1`. Thus, a decoder can
    be viewed as a “minterm generator.”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器比初看起来的更具多功能性。每一个可能的输入可以视为一个最小项（如需复习最小项，参见[第 4 章](ch04.xhtml#ch04lev2sec3)中的“标准和或最小项”部分，见[第
    62 页](ch04.xhtml#ch04lev2sec3)）。[表 6-3](ch06.xhtml#ch6tab3)中的行解码器显示，当最小项为 `1`
    且 *Enable* 为 `1` 时，只有一个输出为 `1`。因此，解码器可以看作是一个“最小项生成器”。
- en: We know from [Chapter 4](ch04.xhtml) that any logical expression can be represented
    as the OR of minterms, so it follows that we can implement any logical expression
    by OR-ing the output(s) of a decoder. For example, if you look back at the Karnaugh
    maps for the full adder ([Figures 6-2](ch06.xhtml#ch6fig2) and [6-4](ch06.xhtml#ch6fig4)),
    you might see that *Sum[i]*(*Carry[i]*, *x[i]*, *y[i]*) and *Carry*[*i* + 1](*Carry[i]*,
    *x[i]*, *y[i]*) can be expressed as the OR of minterms,
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第 4 章](ch04.xhtml)知道，任何逻辑表达式都可以表示为最小项的或，因此可以通过对解码器的输出进行或运算来实现任何逻辑表达式。例如，如果回顾全加器的卡诺图（参见[图
    6-2](ch06.xhtml#ch6fig2)和[图 6-4](ch06.xhtml#ch6fig4)），你可能会看到 *Sum[i]*(*Carry[i]*,
    *x[i]*, *y[i]*) 和 *Carry*[*i* + 1](*Carry[i]*, *x[i]*, *y[i]*) 可以表示为最小项的或运算，
- en: '![Image](../images/pg144_Image_191.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg144_Image_191.jpg)'
- en: where the subscript *i* on *x*, *y*, and *Carry* refers to the bit slice and
    the subscripts on *m* are part of the minterm notation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，下标 *i* 表示 *x*、*y* 和 *Carry* 的位切片，*m* 上的下标是最小项符号的一部分。
- en: We can implement each bit slice of a full adder with a 3×8 decoder and two four-input
    OR gates, as shown in [Figure 6-9](ch06.xhtml#ch6fig9). An *n*-bit adder would
    require *n* of these circuits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 3×8 解码器和两个四输入或门实现全加器的每个位切片，如[图 6-9](ch06.xhtml#ch6fig9)所示。一个 *n* 位加法器需要
    *n* 个这样的电路。
- en: '![Image](../images/pg144_Image_192.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg144_Image_192.jpg)'
- en: '*Figure 6-9: A 1-bit slice of a full adder implemented with a 3×8 decoder*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：用 3×8 解码器实现的全加器的 1 位切片*'
- en: The decoder circuit in [Figure 6-8](ch06.xhtml#ch6fig8) requires eight AND gates
    and three NOT gates. The full adder in [Figure 6-9](ch06.xhtml#ch6fig9) adds two
    OR gates, for a total of 13 logic gates. Comparing this with the full adder design
    in [Figure 6-5](ch06.xhtml#ch6fig5), which requires only five logic gates (two
    XOR, two AND, and one OR), it would seem that using a decoder to construct a full
    adder increases the complexity of the circuit. Keep in mind, however, that designs
    must take into account other factors, such as availability of components, cost
    of components, and so forth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-8](ch06.xhtml#ch6fig8)中的解码器电路需要八个与门和三个非门。[图6-9](ch06.xhtml#ch6fig9)中的全加器增加了两个或门，总共需要13个逻辑门。与[图6-5](ch06.xhtml#ch6fig5)中的全加器设计相比，该设计仅需要五个逻辑门（两个异或门、两个与门和一个或门），看起来使用解码器构建全加器会增加电路的复杂性。然而，请记住，设计必须考虑其他因素，如元件的可用性、元件成本等。'
- en: '**YOUR TURN**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: '6.2     You have probably seen seven-segment displays, which are used to display
    numerals. Each segment in a seven-segment display is lit by applying a `1` to
    the input pin connected to that segment. Suppose you have a seven-segment display
    with an 8-bit input that lights the segments and the decimal point, as shown in
    the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2    你可能见过七段显示器，它们用于显示数字。七段显示器中的每个段通过将`1`应用到连接该段的输入引脚来点亮。假设你有一个8位输入的七段显示器，它点亮段和小数点，如下图所示：
- en: '![Image](../images/pg145_Image_193.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg145_Image_193.jpg)'
- en: For example, you could display a 5 with the bit pattern `0110 1101`. However,
    it would be more convenient to write a program to use BCD for individual numerals.
    Design a decoder that transforms numerals in BCD to segment patterns on the seven-segment
    display.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用位模式`0110 1101`显示数字5。然而，写一个程序使用BCD编码来表示单个数字会更方便。设计一个解码器，将BCD中的数字转换为七段显示器上的段模式。
- en: '**Multiplexers**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多路复用器**'
- en: In the previous section, you learned how an *n*-bit number can be used to select
    which one of 2*^n* output lines should be set to `1`. The opposite situation also
    occurs, where we need to select which of several inputs should be passed on. For
    example, when performing arithmetic operations, such as addition, the numbers
    can come from different locations within the CPU. (You will learn more about this
    in the next few chapters.) The operation itself will be performed by one arithmetic
    unit, and the CPU needs to select the inputs to the operation from all the possible
    locations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你了解了如何使用*n*位数来选择应设置为`1`的2*^n*个输出线路中的一个。相反的情况也会发生，即我们需要选择哪些输入应该被传递。例如，在进行加法等算术操作时，数字可能来自CPU内部的不同位置。（你将在接下来的几章中学习更多内容。）操作本身将由一个算术单元执行，而CPU需要从所有可能的位置中选择操作的输入。
- en: A device that can make this selection is called a *multiplexer (MUX)*. It can
    switch between 2*^n* input lines by using *n* selection lines. [Figure 6-10](ch06.xhtml#ch6fig10)
    shows a circuit for a four-way multiplexer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 能够做出这种选择的设备叫做*多路复用器（MUX）*。它可以通过使用*n*个选择线路，在2*^n*个输入线路之间切换。[图6-10](ch06.xhtml#ch6fig10)展示了一个四路多路复用器的电路。
- en: '![Image](../images/pg146_Image_194.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_194.jpg)'
- en: '*Figure 6-10: A four-way multiplexer circuit*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：四路多路复用器电路*'
- en: 'The output is given by:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '![Image](../images/pg146_Image_195.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_195.jpg)'
- en: When using AND and OR gates, the number of transistors required to implement
    a multiplexer gets large as the number of inputs grows. A three-input AND gate
    is required for each input to the multiplexer, with the output of each AND gate
    connected to one of the inputs to the OR gate. So, the number of inputs to the
    OR gate equals the number of multiplexer inputs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用与门和或门时，随着输入数量的增加，实施一个多路复用器所需的晶体管数量会变得很大。每个输入到多路复用器的输入都需要一个三输入与门，每个与门的输出连接到或门的一个输入。所以，或门的输入数量等于多路复用器的输入数量。
- en: This four-way multiplexer requires a four-input OR gate. If we try to scale
    this up, the *n*-input OR gate will present some technical electronic problems
    for a large *n*. The use of an *n*-input OR gate can be avoided by using a type
    of gate that can disconnect its output signal from its input, which we’ll look
    at next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个四路多路复用器需要一个四输入的或门。如果我们尝试扩大规模，*n*输入的或门将为较大的*n*带来一些技术电子问题。通过使用一种能够断开其输出信号与输入信号连接的门，可以避免使用*n*输入的或门，接下来我们将讨论这种门。
- en: '**Tristate Buffer**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**三态缓冲器**'
- en: 'The logic gate called a *tristate buffer* has three possible outputs: `0`,
    `1`, and “no connection.” The “no connection” output is actually a high-impedance
    connection, also called *high Z* or *open*. A tristate buffer has both a data
    input and an *Enable* input, which behaves as shown in [Figure 6-11](ch06.xhtml#ch6fig11).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*三态缓冲器*的逻辑门有三个可能的输出：`0`、`1`和“无连接”。“无连接”输出实际上是一个高阻抗连接，也称为*高Z*或*开放*。三态缓冲器有一个数据输入和一个*Enable*输入，其行为如[图6-11](ch06.xhtml#ch6fig11)所示。
- en: '![Image](../images/pg146_Image_196.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg146_Image_196.jpg)'
- en: '*Figure 6-11: A tristate buffer*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：三态缓冲器*'
- en: When *Enable* = `1`, the output, which is equal to the input, is connected to
    whatever circuit element follows the tristate buffer. But when *Enable* = `0`,
    the output is essentially disconnected. This is different from `0`; being disconnected
    means it has no effect on the circuit element to which it is connected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当*Enable* = `1`时，输出等于输入，并且连接到三态缓冲器之后的电路元件上。但当*Enable* = `0`时，输出实际上是断开的。这与`0`不同，断开意味着它对连接的电路元件没有任何影响。
- en: The “no connection” output lets us physically connect the outputs of many tristate
    buffers but select only one to pass its input to the common output line. The four-way
    multiplexer in [Figure 6-12](ch06.xhtml#ch6fig12) shows how we avoid using an
    *n*-input OR gate by using *n* tristate buffers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: “无连接”输出使我们可以物理连接多个三态缓冲器的输出，但只选择其中一个将其输入传递到公共输出线上。[图6-12](ch06.xhtml#ch6fig12)中的四路多路复用器展示了我们如何通过使用*n*个三态缓冲器来避免使用*n*输入的或门。
- en: '![Image](../images/pg147_Image_197.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg147_Image_197.jpg)'
- en: '*Figure 6-12: A four-way multiplexer built from a decoder and tristate buffers*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：由解码器和三态缓冲器构建的四路多路复用器*'
- en: The 2×4 decoder in [Figure 6-12](ch06.xhtml#ch6fig12) selects which of the tristate
    buffers connects one of the inputs, *w*, *x*, *y*, or *z*, to the output to create
    a four-way multiplexer. [Figure 6-13](ch06.xhtml#ch6fig13) shows the circuit symbol
    used for a multiplexer, along with the truth table that shows its behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-12](ch06.xhtml#ch6fig12)中的2×4解码器选择连接输入*w*、*x*、*y*或*z*的三态缓冲器，以将其中一个输入连接到输出，形成四路多路复用器。[图6-13](ch06.xhtml#ch6fig13)展示了多路复用器使用的电路符号，以及展示其行为的真值表。'
- en: '![Image](../images/pg147_Image_198.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg147_Image_198.jpg)'
- en: '*Figure 6-13: A four-way multiplexer*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：四路多路复用器*'
- en: As an example of where we might use a four-way multiplexer like this one, consider
    a computer with four registers and one adder. Let’s name the registers *w*, *x*,
    *y*, and *z*. If we connect the bits in the corresponding bit position from each
    register to a multiplexer, then we can use the 2-bit selector *s*[1]*s*[0] to
    choose which register will provide the input to the adder. For example, each bit
    in position 5, *w*[5], *x*[5], *y*[5], and *z*[5], would be connected to one of
    the inputs in multiplexer 5\. If *s*[1]*s*[0] = `10`, the input to the adder would
    be *y*[5].
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个使用这种四路多路复用器的例子，考虑一台有四个寄存器和一个加法器的计算机。我们将寄存器命名为*w*、*x*、*y* 和 *z*。如果我们将每个寄存器中对应位置的比特连接到多路复用器，那么我们可以使用2位选择器*s*[1]*s*[0]来选择哪个寄存器将提供输入给加法器。例如，位置5的每个比特，*w*[5]、*x*[5]、*y*[5]
    和 *z*[5]，将连接到多路复用器5的一个输入。如果*s*[1]*s*[0] = `10`，则加法器的输入将是*y*[5]。
- en: '**Programmable Logic Devices**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**可编程逻辑器件**'
- en: So far, we’ve been discussing hardware designs that use individual logic gates.
    If the design changes, the logic gate configuration changes. This almost always
    means that the circuit board that holds the logic gates and connects them will
    need to be redesigned. A change also often means ordering a different kind of
    logic gate, which can be expensive and take time. These problems can be reduced
    by using *programmable logic devices (PLDs)* to implement the required logic function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的是使用单独逻辑门的硬件设计。如果设计发生变化，逻辑门的配置也会发生变化。这几乎总是意味着承载逻辑门并将它们连接起来的电路板需要重新设计。变化也通常意味着需要订购不同类型的逻辑门，这可能既昂贵又需要时间。通过使用*可编程逻辑器件（PLDs）*来实现所需的逻辑功能，可以减少这些问题。
- en: PLDs contain many AND gates and OR gates, which can be programmed to implement
    Boolean functions. The inputs, and their complemented value, are connected to
    the AND gates. The AND gates, taken together, are referred to as the *AND plane*
    or *AND array*. The outputs from the AND gates are connected to OR gates, which
    taken together are referred to as the *OR plane* or *OR array*. Depending on the
    type, one or both planes can be programmed to implement combinational logic. When
    using a PLD, a design change requires changing only how the device is programmed,
    not buying different devices, meaning the circuit board does not need to be redesigned.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PLD包含许多AND门和OR门，可以编程实现布尔函数。输入及其补码值连接到AND门。所有AND门一起称为*AND平面*或*AND阵列*。从AND门输出的信号连接到OR门，所有OR门一起称为*OR平面*或*OR阵列*。根据类型，一个或两个平面可以编程实现组合逻辑。在使用PLD时，设计变更仅需要改变设备的编程方式，而不是购买不同的设备，这意味着电路板无需重新设计。
- en: PLDs come in several types. Most can be programmed by a user. Some are preprogrammed
    at the time of manufacture, and some can even be erased and reprogrammed by the
    user. Programming technologies range from specifying the manufacturing mask (for
    the preprogrammed devices) to inexpensive electronic programming systems. We’ll
    look at the three main categories of PLDs in this section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PLD有多种类型。大多数可以由用户编程。有些在制造时预编程，有些甚至可以由用户擦除和重新编程。编程技术范围从指定制造掩模（对于预编程设备）到廉价的电子编程系统。在本节中，我们将看看PLD的三个主要类别。
- en: '***Programmable Logic Array***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可编程逻辑阵列***'
- en: In a *programmable logic array (PLA)*, both the AND and OR planes are programmable.
    PLAs are used to implement logic functions. [Figure 6-14](ch06.xhtml#ch6fig14)
    gives the general idea for a PLA that has two input variables and two possible
    output functions of these variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在*可编程逻辑阵列（PLA）*中，AND平面和OR平面都是可编程的。PLA用于实现逻辑函数。[图 6-14](ch06.xhtml#ch6fig14)提供了具有两个输入变量和这些变量两种可能输出函数的PLA的一般思路。
- en: '![Image](../images/pg148_Image_199.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg148_Image_199.jpg)'
- en: '*Figure 6-14: A simplified circuit for a programmable logic array*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：可编程逻辑阵列的简化电路*'
- en: Each input variable, in both its uncomplemented and complemented form, is an
    input to the AND gates through fuses. A *fuse* is a thin piece of conductor used
    to protect an electrical circuit. If the current flowing through it is high enough,
    the conductor melts, opening the circuit and stopping current flow. PLDs can be
    programmed by breaking (or *blowing*) the appropriate fuses, removing the input
    to the logic gate. Some devices use *antifuses* instead of fuses; these are normally
    open, and programming them consists of completing the connection instead of removing
    it. Devices that can be reprogrammed have fuses that can be broken and then remade.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入变量，无论是其未补码形式还是补码形式，都通过保险丝输入到AND门中。*保险丝*是用于保护电路的薄导体片。如果通过它的电流足够大，导体会熔化，打开电路并停止电流流动。可编程逻辑器件可以通过断开（或*烧断*）适当的保险丝来编程，从而移除输入到逻辑门的信号。某些设备使用*反保险丝*代替保险丝；这些通常是开路的，编程它们意味着完成连接而不是移除连接。可以重新编程的设备具有可以烧断然后再连接的保险丝。
- en: In [Figure 6-14](ch06.xhtml#ch6fig14), the S-shaped lines in the circuit diagram
    represent the fuses. The fuses can be blown or left in place so as to program
    each AND gate to output a product of the inputs, *x*,¬*x*, *y*, and ¬*y*. Since
    every input, plus its complement, is input to each AND gate, any of the AND gates
    can be programmed to output a minterm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-14](ch06.xhtml#ch6fig14)中，电路图中的S形线代表保险丝。这些保险丝可以被烧断或保持不变，以便编程每个AND门输出输入变量*x*,¬*x*,
    *y*, 和 ¬*y*的乘积。由于每个输入及其补码都作为输入到每个AND门中，任何AND门都可以被编程以输出一个最小项。
- en: The products produced by the AND gate plane are all connected to the inputs
    of the OR gates, also through fuses. Thus, depending on which OR gate fuses are
    left in place, the output of each OR gate is a sum of products. There may be additional
    logic circuitry to select between the different outputs. You have already seen
    that any Boolean function can be expressed as a sum of products, so this logic
    device can be programmed to implement any Boolean function by blowing the fuses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由AND门平面产生的乘积连接到OR门的输入，同样通过保险丝。因此，根据哪些OR门的保险丝保持不变，每个OR门的输出就是一个乘积和的总和。可能还有额外的逻辑电路用于选择不同的输出之间。您已经看到，任何布尔函数都可以表达为乘积和，因此通过烧断保险丝，此逻辑器件可以编程实现任何布尔函数。
- en: A PLA is typically larger than the one shown in [Figure 6-14](ch06.xhtml#ch6fig14),
    which is already complicated to draw. To simplify the drawing, it is typical to
    use a diagram similar to [Figure 6-15](ch06.xhtml#ch6fig15) to specify the design.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PLA通常比[图6-14](ch06.xhtml#ch6fig14)中显示的更大，后者已经复杂到难以绘制。为了简化绘制，通常使用类似[图6-15](ch06.xhtml#ch6fig15)的示意图来指定设计。
- en: '![Image](../images/pg149_Image_200.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg149_Image_200.jpg)'
- en: '*Figure 6-15: A diagram for a programmable logic array where the dots represent
    connections*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：可编程逻辑阵列的示意图，其中的点表示连接*'
- en: 'This diagram can be a little tricky to understand. In [Figure 6-14](ch06.xhtml#ch6fig14),
    each AND gate has multiple inputs: one for each variable and one for its complement.
    In [Figure 6-15](ch06.xhtml#ch6fig15), we use a single horizontal line leading
    to the input of each AND gate to represent multiple wires (variable and complement),
    so each AND gate in [Figure 6-15](ch06.xhtml#ch6fig15) has eight inputs, even
    though we draw only one line.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图可能有点难以理解。在[图6-14](ch06.xhtml#ch6fig14)中，每个与门有多个输入：每个变量一个，每个变量的补集一个。在[图6-15](ch06.xhtml#ch6fig15)中，我们使用一条单独的水平线连接到每个与门的输入，以表示多根导线（变量和补集），因此[图6-15](ch06.xhtml#ch6fig15)中的每个与门有八个输入，尽管我们只画了一条线。
- en: 'The dots at the intersections of the vertical and horizontal lines represent
    places where the fuses have been left intact, thus creating a connection. For
    example, the three dots on the topmost horizontal line indicate that there are
    three inputs left connected to that AND gate. The output of the topmost AND gate
    is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直线和水平线交点处的点表示保险丝未被切断的地方，从而形成连接。例如，最上方水平线上的三个点表示有三个输入连接到那个与门。最上方与门的输出为：
- en: '![Image](../images/pg150_Image_201.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg150_Image_201.jpg)'
- en: 'Referring again to [Figure 6-14](ch06.xhtml#ch6fig14), you can see that the
    output from each AND gate is connected to each of the OR gates (through fuses).
    Therefore, the OR gates also have multiple inputs—one for each AND gate—and the
    vertical lines leading to the OR gate inputs represent multiple wires. The PLA
    in [Figure 6-15](ch06.xhtml#ch6fig15) has been programmed to provide these three
    functions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次参考[图6-14](ch06.xhtml#ch6fig14)，你可以看到每个与门的输出都连接到每个或门（通过保险丝）。因此，或门也有多个输入——每个与门一个——而通向或门输入的垂直线代表多根导线。[图6-15](ch06.xhtml#ch6fig15)中的PLA已被编程以提供以下三种功能：
- en: '![Image](../images/pg150_Image_202.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg150_Image_202.jpg)'
- en: Since the AND plane can produce all possible minterms and the OR plane can provide
    any sum of the minterms, a PLA can be used to implement any possible logical function.
    If we want to change the function, it’s a simple matter of programming another
    PLA and replacing the old one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与门阵列可以产生所有可能的最小项，而或门阵列可以提供任何最小项的和，PLA可以用来实现任何可能的逻辑功能。如果我们想改变功能，只需简单地编程另一个PLA并替换旧的即可。
- en: '***Read-Only Memory***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***只读存储器***'
- en: Although PLDs have no memory (meaning the current state isn’t affected by previous
    states of the inputs), they can be used to make *nonvolatile* memory—memory whose
    contents remain intact when the power is turned off. *Read-only memory (ROM)*
    is used to store bit patterns that can represent data or program instructions.
    A program can only read the data or program stored in ROM; the contents of the
    ROM cannot be changed by writing new data or program instructions to it. ROM is
    commonly used in devices that have a fixed set of functionalities, such as watches,
    automobile engine control units, and appliances. In fact, our lives are surrounded
    by devices that are controlled by programs stored in ROM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PLD没有内存（意味着当前状态不受输入先前状态的影响），但它们可以用来制造*非易失性*内存——即在断电时仍能保持内容的内存。*只读存储器（ROM）*用于存储比特模式，这些模式可以表示数据或程序指令。程序只能读取存储在ROM中的数据或程序；ROM的内容不能通过写入新的数据或程序指令来改变。ROM通常用于具有固定功能集的设备中，如手表、汽车发动机控制单元和家电。事实上，我们的生活中充满了由存储在ROM中的程序控制的设备。
- en: ROM can be implemented as a PLD where only the OR gate plane can be programmed.
    The AND gate plane remains wired to provide all the min-terms. We can think of
    the inputs to the ROM as addresses; then, the OR gate plane is programmed to provide
    the bit pattern at each address. For example, the ROM diagrammed in [Figure 6-16](ch06.xhtml#ch6fig16)
    has two inputs, *a*[1] and *a*[0], which provide a 2-bit address.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ROM可以作为PLD实现，其中只有或门平面可以编程。与门平面保持连接，提供所有最小项。我们可以将ROM的输入视为地址；然后，或门平面被编程以在每个地址提供位模式。例如，在[图6-16](ch06.xhtml#ch6fig16)中示意的ROM设备有两个输入，*a*[1]和*a*[0]，它们提供一个2位的地址。
- en: '![Image](../images/pg151_Image_203.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg151_Image_203.jpg)'
- en: '*Figure 6-16: A 4-byte ROM device*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-16：一个4字节ROM设备*'
- en: The *×* connections in [Figure 6-16](ch06.xhtml#ch6fig16) represent permanent
    connections, showing that the AND gate plane is fixed. Each AND gate produces
    a min-term at each address in this ROM device. The OR gate plane produces up to
    2*^n* 8-bit bytes, where *n* is the width, in number of bits, of the address input
    to the AND gate plane. The connections (dots) to the OR gates represent the bit
    pattern stored at the corresponding address. [Table 6-4](ch06.xhtml#ch6tab4) shows
    a ROM device in which the OR gate plane has been programmed to store the four
    characters 0, 1, 2, and 3 (in ASCII code).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-16](ch06.xhtml#ch6fig16)中的*×*连接表示永久连接，显示与门平面是固定的。每个与门在ROM设备中的每个地址生成一个最小项。或门平面可以生成最多2*^n*个8位字节，其中
    *n* 是输入到与门平面的地址输入位数。到或门的连接（点）表示存储在相应地址的位模式。[表6-4](ch06.xhtml#ch6tab4)显示了一个ROM设备，其中或门平面已经被编程为存储四个字符0、1、2和3（以ASCII码表示）。
- en: '**Table 6-4:** A ROM Device Holding Four ASCII Characters'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-4：** 一个存储四个ASCII字符的ROM设备'
- en: '| **Minterm** | **Address** | **Contents** | **ASCII character** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **最小项** | **地址** | **内容** | **ASCII字符** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ¬*a*[1]¬*a*[0] | `00` | `00110000` | 0 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| ¬*a*[1]¬*a*[0] | `00` | `00110000` | 0 |'
- en: '| ¬*a*[1]*a*[0] | `01` | `00110001` | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| ¬*a*[1]*a*[0] | `01` | `00110001` | 1 |'
- en: '| *a*[1] ¬*a*[0] | `10` | `00110010` | 2 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| *a*[1] ¬*a*[0] | `10` | `00110010` | 2 |'
- en: '| *a*[1]*a*[0] | `11` | `00110011` | 3 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| *a*[1]*a*[0] | `11` | `00110011` | 3 |'
- en: Although we have stored only data in this example, computer instructions are
    bit patterns, so we could just as easily store an entire program in a ROM device.
    As with a PLA, if you need to change the program, you can just program another
    ROM device and replace the old one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此示例中我们仅存储了数据，但计算机指令是位模式，因此我们同样可以将整个程序存储在ROM设备中。与PLA一样，如果需要更改程序，只需重新编程另一个ROM设备并替换旧的设备。
- en: There are several types of ROM devices. While the bit pattern is set in a ROM
    device during manufacturing, a *programmable read-only memory (PROM)* device is
    programmed by the person who uses it. There are also *erasable programmable read-only
    memory (EPROM)* devices that can be erased with an ultraviolet light and then
    reprogrammed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ROM设备有多种类型。尽管在制造过程中ROM设备的位模式是固定的，*可编程只读存储器（PROM）*设备则由使用者进行编程。此外，还有*可擦除可编程只读存储器（EPROM）*设备，可以通过紫外线光擦除后再进行重新编程。
- en: '#### ***Programmable Array Logic***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***可编程阵列逻辑***'
- en: In a *programmable array logic (PAL)* device, each OR gate is permanently wired
    to a group of AND gates. Only the AND gate plane is programmable. The PAL device
    diagrammed in [Figure 6-17](ch06.xhtml#ch6fig17) has four inputs and two outputs,
    each of which can be the sum of up to four products.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在*可编程阵列逻辑（PAL）*设备中，每个或门都被永久连接到一组与门上。只有与门平面是可编程的。[图6-17](ch06.xhtml#ch6fig17)中示意的PAL设备有四个输入和两个输出，每个输出最多可以是四个乘积的和。
- en: '![Image](../images/pg152_Image_204.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg152_Image_204.jpg)'
- en: '*Figure 6-17: A two-function programmable array logic device*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：一个具有两种功能的可编程阵列逻辑设备*'
- en: 'The “*×*” connections in the OR gate plane show that the top four AND gates
    are OR-ed to produce *F*[1](*w*, *x*, *y*, *z*) and the lower four are OR-ed to
    produce *F*[2](*w*, *x*, *y*, *z*). The AND gate plane in this figure has been
    programmed to produce these two functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在或门平面中，“*×*”连接表示顶部四个与门进行或运算，产生 *F*[1](*w*, *x*, *y*, *z*)，底部四个与门进行或运算，产生 *F*[2](*w*,
    *x*, *y*, *z*)。此图中的与门平面已经被编程为生成这两个功能：
- en: '![Image](../images/pg152_Image_205.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg152_Image_205.jpg)'
- en: 'Of the three types of programmable logic devices presented here, the PLA device
    is the most flexible, as we can program both the OR and the AND plane, but it
    is also the most expensive. The ROM device is less flexible: it can be programmed
    to produce any combination of minterms, which are then OR-ed together. We know
    that any function can be implemented as the OR of minterms, so we can produce
    any function with a ROM device, but a ROM device doesn’t allow us to minimize
    the function since all the product terms must be minterms.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里介绍的三种可编程逻辑设备中，PLA设备是最灵活的，因为我们可以编程OR平面和AND平面，但它也是最昂贵的。ROM设备的灵活性较差：它可以编程生成任意组合的最小项，然后将它们OR在一起。我们知道任何函数都可以作为最小项的OR来实现，因此我们可以用ROM设备生成任何函数，但ROM设备不允许我们最小化函数，因为所有的积项必须是最小项。
- en: The PAL device is the least flexible, because all the product terms programmed
    in the AND plane will be OR-ed together. So, we cannot select which minterms are
    in the function by programming the OR plane. However, PAL devices allow us to
    do some Boolean function minimization. If the required function can be implemented
    in a PAL device, this will be less expensive than using a ROM or PLA device.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PAL设备是最不灵活的，因为在AND平面中编程的所有积项都会被OR在一起。因此，我们不能通过编程OR平面来选择哪些最小项包含在函数中。然而，PAL设备允许我们进行一些布尔函数最小化。如果所需的函数可以在PAL设备中实现，那么使用PAL设备将比使用ROM或PLA设备更便宜。
- en: '**YOUR TURN**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 6.3     Design a ROM device that holds the four characters a, b, c, and d.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 6.3 设计一个ROM设备，存储四个字符a、b、c和d。
- en: 6.4     Design a ROM device that holds the four characters A, B, C, and D.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 6.4 设计一个ROM设备，存储四个字符A、B、C和D。
- en: '6.5     Comparing two values to determine which is larger, or whether they
    are the same, is a common operation in computing. The hardware device used to
    perform such a comparison is called a *comparator*. Use a programmable logic device
    to design a comparator that compares two 2-bit values. Your comparator will have
    three outputs: equal, greater than, and less than.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 6.5 比较两个值以确定哪个较大，或者它们是否相同，是计算中的常见操作。执行此类比较的硬件设备称为*比较器*。使用可编程逻辑设备设计一个比较器，用于比较两个2位值。你的比较器将有三个输出：相等、大于和小于。
- en: '**What You’ve Learned**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Combinational logic circuits**   These depend only on their input at any
    point in time. They have no memory of previous effects of the inputs. Examples
    include adders, decoders, multiplexers, and programmable logic devices.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合逻辑电路** 这些电路仅依赖于任何时刻的输入。它们没有记忆输入之前的效果。示例包括加法器、解码器、多路复用器和可编程逻辑设备。'
- en: '**Half adder**   This circuit has two 1-bit inputs and produces two 1-bit outputs:
    the sum of the inputs and the carry from that sum.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**半加器** 该电路有两个1位输入，并产生两个1位输出：输入的和以及该和的进位。'
- en: '**Full adder**   This circuit has three 1-bit inputs and produces two 1-bit
    outputs: the sum of the inputs and the carry from that sum.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**全加器** 该电路有三个1位输入，并产生两个1位输出：输入的和以及该和的进位。'
- en: '**Ripple-carry adder**   This circuit uses *n* full adders to add *n*-bit numbers.
    The carry output from each full adder is one of the three inputs to the full adders
    in the next higher-order bit position.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉冲进位加法器** 该电路使用*n*个全加器来加法*n*位数。每个全加器的进位输出是下一个更高位位置的全加器的三个输入之一。'
- en: '**Decoder**   A device used to select one of *n* outputs based on 2*^n* inputs.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码器** 一种根据2*^n*个输入选择*n*个输出之一的设备。'
- en: '**Multiplexer (MUX)**   A device used to select one of 2*^n* inputs based on
    an *n*-bit selector signal.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**多路复用器（MUX）** 一种根据*n*位选择信号选择2*^n*个输入中的一个的设备。'
- en: '**Programmable logic array (PLA)**   A device used to generate an OR-ed combination
    of minterms to implement Boolean functions in hardware.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**可编程逻辑阵列（PLA）** 一种用于生成最小项的或逻辑组合以实现布尔函数的硬件设备。'
- en: '**Read-only memory (ROM)**   Nonvolatile memory, with the input being the address
    of the data or instruction.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读存储器（ROM）** 非易失性存储器，输入为数据或指令的地址。'
- en: '**Programmable array logic (PAL)**   A device used to implement Boolean functions
    in hardware. It’s less flexible than a PLA or ROM device, but also less expensive.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**可编程阵列逻辑（PAL）** 一种用于在硬件中实现布尔函数的设备。它比PLA或ROM设备灵活性较差，但也更便宜。'
- en: In the next chapter, you will learn about sequential logic circuits, which use
    feedback to maintain a memory of their activity.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习顺序逻辑电路，它们使用反馈来保持其活动的记忆。
