<html><head></head><body>
<h2 class="h2a" id="app01"><span epub:type="pagebreak" id="page_277"/><strong>NETWORK PROTOCOL ANALYSIS TOOLKIT</strong></h2>&#13;
<p class="noindent_first">Throughout this book, I’ve demonstrated several tools and libraries you can use in network protocol analysis, but I didn’t discuss many that I use regularly. This appendix describes the tools that I’ve found useful during analysis, investigation, and exploitation. Each tool is categorized based on its primary use, although some tools would fit several categories.</p>&#13;
<h3 class="h3" id="ch00lev1sec318"><span epub:type="pagebreak" id="page_278"/><strong>Passive Network Protocol Capture and Analysis Tools</strong></h3>&#13;
<p class="noindent">As discussed in <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, passive network capture refers to listening and capturing packets without disrupting the flow of traffic.</p>&#13;
<h4 class="h4" id="ch00lev1sec319"><strong><em>Microsoft Message Analyzer</em></strong></h4>&#13;
<p class="noindent1"><strong>Website</strong> <em><a href="http://blogs.technet.com/b/messageanalyzer/">http://blogs.technet.com/b/messageanalyzer/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Commercial; free of charge</p>&#13;
<p class="noindent1b"><strong>Platform</strong> Windows</p>&#13;
<p class="noindent">The Microsoft Message Analyzer is an extensible tool for analyzing network traffic on Windows. The tool includes many parsers for different protocols and can be extended with a custom programming language. Many of its features are similar to those of Wireshark except Message Analyzer has added support for Windows events.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0278-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec320"><strong><em>TCPDump and LibPCAP</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://www.tcpdump.org/">http://www.tcpdump.org/</a></em>; <em><a href="http://www.winpcap.org/">http://www.winpcap.org/</a></em> for Windows implementation (WinPcap/WinDump)</p>&#13;
<p class="noindent1"><span epub:type="pagebreak" id="page_279"/><strong>License</strong> BSD License</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Solaris, Windows</p>&#13;
<p class="noindent">The TCPDump utility installed on many operating systems is the grandfather of network packet capture tools. You can use it for basic network data analysis. Its LibPCAP development library allows you to write your own tools to capture traffic and manipulate PCAP files.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0279-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec321"><strong><em>Wireshark</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://www.wireshark.org/">https://www.wireshark.org/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Solaris, Windows</p>&#13;
<p class="noindent">Wireshark is the most popular tool for passive packet capture and analysis. Its GUI and large library of protocol analysis modules make it more robust and easier to use than TCPDump. Wireshark supports almost every well-known capture file format, so even if you capture traffic using a different tool, you can use Wireshark to do the analysis. It even includes support for analyzing nontraditional protocols, such as USB or serial port communication. Most Wireshark distributions also include <code>tshark</code>, a replacement for TCPDump that has most of the features offered in the main Wireshark GUI, such as the protocol dissectors. It allows you to view a wider range of protocols on the command line.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_280"/><img alt="image" src="../Images/f0280-01.jpg"/></div>&#13;
<h3 class="h3" id="ch00lev1sec322"><strong>Active Network Capture and Analysis</strong></h3>&#13;
<p class="noindent">To modify, analyze, and exploit network traffic as discussed in <a href="../Text/ch02.xhtml#ch02">Chapters 2</a> and <a href="../Text/ch08.xhtml#ch08">8</a>, you’ll need to use active network capture techniques. I use the following tools on a daily basis when I’m analyzing and testing network protocols.</p>&#13;
<h4 class="h4" id="ch00lev1sec323"><strong><em>Canape</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://github.com/ctxis/canape/">https://github.com/ctxis/canape/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv3</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Windows (with .NET 4)</p>&#13;
<p class="noindent">I developed the Canape tool as a generic network protocol man-in-the-middle testing, analyzing, and exploitation tool with a usable GUI. Canape contains tools that allow users to develop protocol parsers, C# and IronPython scripted extensions, and different types of man-in-the-middle proxies. It’s open source as of version 1.4, so users can contribute to its development.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_281"/><img alt="image" src="../Images/f0281-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec324"><strong><em>Canape Core</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://github.com/tyranid/CANAPE.Core/releases/">https://github.com/tyranid/CANAPE.Core/releases/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv3</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> .NET Core 1.1 and 2.0 (Linux, macOS, Windows)</p>&#13;
<p class="noindent">The Canape Core libraries, a stripped-down fork of the original Canape code base, are designed for use from the command line. In the examples throughout this book, I’ve used Canape Core as the library of choice. It has much the same power as the original Canape tool while being usable on any OS supported by .NET Core instead of only on Windows.</p>&#13;
<h4 class="h4" id="ch00lev1sec325"><strong><em>Mallory</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://github.com/intrepidusgroup/mallory/">https://github.com/intrepidusgroup/mallory/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Python Software Foundation License v2; GPLv3 if using the GUI</p>&#13;
<p class="noindent1b"><strong>Platform</strong> Linux</p>&#13;
<p class="noindent">Mallory is an extensible man-in-the-middle tool that acts as a network gateway, which makes the process of capturing, analyzing, and modifying traffic transparent to the application being tested. You can configure Mallory <span epub:type="pagebreak" id="page_282"/>using Python libraries as well as a GUI debugger. You’ll need to configure a separate Linux VM to use it. Some useful instructions are available at <em><a href="https://bitbucket.org/IntrepidusGroup/mallory/wiki/Mallory_Minimal_Guide/">https://bitbucket.org/IntrepidusGroup/mallory/wiki/Mallory_Minimal_Guide/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec326"><strong>Network Connectivity and Protocol Testing</strong></h3>&#13;
<p class="noindent">If you’re trying to test an unknown protocol or network device, basic network testing can be very useful. The tools listed in this section help you discover and connect to exposed network servers on the target device.</p>&#13;
<h4 class="h4" id="ch00lev1sec327"><strong><em>Hping</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://www.hping.org/">http://www.hping.org/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Windows</p>&#13;
<p class="noindent">The Hping tool is similar to the traditional <code>ping</code> utility, but it supports more than just ICMP echo requests. You can also use it to craft custom network packets, send them to a target, and display any responses. This is a very useful tool to have in your kit.</p>&#13;
<h4 class="h4" id="ch00lev1sec328"><strong><em>Netcat</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> Find the original at <em><a href="http://nc110.sourceforge.net/">http://nc110.sourceforge.net/</a></em> and the GNU version at <em><a href="http://netcat.sourceforge.net/">http://netcat.sourceforge.net/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2, public domain</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Windows</p>&#13;
<p class="noindent">Netcat is a command line tool that connects to an arbitrary TCP or UDP port and allows you to send and receive data. It supports the creation of sending or listening sockets and is about as simple as it gets for network testing. Netcat has many variants, which, annoyingly, all use different command line options. But they all do pretty much the same thing.</p>&#13;
<h4 class="h4" id="ch00lev1sec329"><strong><em>Nmap</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://nmap.org/">https://nmap.org/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Windows</p>&#13;
<p class="noindent">If you need to scan the open network interface on a remote system, nothing is better than Nmap. It supports many different ways to elicit responses from TCP and UDP socket servers, as well as different analysis scripts. It’s invaluable when you’re testing an unknown device.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_283"/><img alt="image" src="../Images/f0283-01.jpg"/></div>&#13;
<h3 class="h3" id="ch00lev1sec330"><strong>Web Application Testing</strong></h3>&#13;
<p class="noindent">Although this book does not focus heavily on testing web applications, doing so is an important part of network protocol analysis. One of the most widely used protocols on the internet, HTTP is even used to proxy other protocols, such as DCE/RPC, to bypass firewalls. Here are some of the tools I use and recommend.</p>&#13;
<h4 class="h4" id="ch00lev1sec331"><strong><em>Burp Suite</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://portswigger.net/burp/">https://portswigger.net/burp/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Commercial; limited free version is available</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Supported Java platforms (Linux, macOS, Solaris, Windows)</p>&#13;
<p class="noindent">Burp Suite is the gold standard of commercial web application–testing tools. Written in Java for maximum cross-platform capability, it provides all the features you need for testing web applications, including built-in proxies, SSL decryption support, and easy extensibility. The free version has fewer features than the commercial version, so consider buying the commercial version if you plan to use it a lot.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_284"/><img alt="image" src="../Images/f0284-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec332"><strong><em>Zed Attack Proxy (ZAP)</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://www.owasp.org/index.php/ZAP">https://www.owasp.org/index.php/ZAP</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Apache License v2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Supported Java platforms (Linux, macOS, Solaris, Windows)</p>&#13;
<p class="noindent">If Burp Suite’s price is beyond reach, ZAP is a great free option. Developed by OWASP, ZAP is written in Java, can be scripted, and can be easily extended because it’s open source.</p>&#13;
<h4 class="h4" id="ch00lev1sec333"><strong><em>Mitmproxy</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://mitmproxy.org/">https://mitmproxy.org/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> MIT</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Any Python-supported platform, although the program is somewhat limited on Windows</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_285"/>Mitmproxy is a command line–based web application–testing tool written in Python. Its many standard features include interception, modification, and replay of requests. You can also include it as a separate library within your own applications.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0285-01.jpg"/></div>&#13;
<h3 class="h3" id="ch00lev1sec334"><strong>Fuzzing, Packet Generation, and Vulnerability Exploitation Frameworks</strong></h3>&#13;
<p class="noindent">Whenever you’re developing exploits for and finding new vulnerabilities, you’ll usually need to implement a lot of common functionality. The following tools provide a framework, allowing you to reduce the amount of standard code and common functionality you need to implement.</p>&#13;
<h4 class="h4" id="ch00lev1sec335"><strong><em>American Fuzzy Lop (AFL)</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Apache License v2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Linux; some support for other Unix-like platforms</p>&#13;
<p class="noindent">Don’t let its cute name throw you off. American Fuzzy Lop (AFL) may be named after a breed of rabbit, but it’s an amazing tool for fuzz testing, especially on applications that can be recompiled to include special instrumentation. It has an almost magical ability to generate valid inputs for a program from the smallest of examples.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_286"/><img alt="image" src="../Images/f0286-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec336"><strong><em>Kali Linux</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://www.kali.org/">https://www.kali.org/</a></em></p>&#13;
<p class="noindent1"><strong>Licenses</strong> A range of open source and non-free licenses depending on the packages used</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> ARM, Intel x86 and x64</p>&#13;
<p class="noindent">Kali is a Linux distribution designed for penetration testing. It comes pre-installed with Nmap, Wireshark, Burp Suite, and various other tools listed in this appendix. Kali is invaluable for testing and exploiting network protocol vulnerabilities, and you can install it natively or run it as a live distribution.</p>&#13;
<h4 class="h4" id="ch00lev1sec337"><strong><em>Metasploit Framework</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://github.com/rapid7/metasploit-framework/">https://github.com/rapid7/metasploit-framework/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> BSD, with some parts under different licenses</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> BSD, Linux, macOS, Windows</p>&#13;
<p class="noindent">Metasploit is pretty much the only game in town when you need a generic vulnerability exploitation framework, at least if you don’t want to pay for one. Metasploit is open source, is actively updated with new vulnerabilities, and will run on almost all platforms, making it useful for testing new devices. Metasploit provides many built-in libraries to perform typical exploitation tasks, such as generating and encoding shell code, spawning reverse shells, and gaining elevated privileges, allowing you to concentrate on developing your exploit without having to deal with various implementation details.</p>&#13;
<h4 class="h4" id="ch00lev1sec338"><span epub:type="pagebreak" id="page_287"/><strong><em>Scapy</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://www.secdev.org/projects/scapy/">http://www.secdev.org/projects/scapy/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Any Python-supported platform, although it works best on Unix-like platforms</p>&#13;
<p class="noindent">Scapy is a network packet generation and manipulation library for Python. You can use it to build almost any packet type, from Ethernet packets through TCP or HTTP packets. You can replay packets to test what a network server does when it receives them. This functionality makes it a very flexible tool for testing, analysis, or fuzzing of network protocols.</p>&#13;
<h4 class="h4" id="ch00lev1sec339"><strong><em>Sulley</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://github.com/OpenRCE/sulley/">https://github.com/OpenRCE/sulley/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Any Python-supported platform</p>&#13;
<p class="noindent">Sulley is a Python-based fuzzing library and framework designed to simplify data representation, transmission, and instrumentation. You can use it to fuzz anything from file formats to network protocols.</p>&#13;
<h3 class="h3" id="ch00lev1sec340"><strong>Network Spoofing and Redirection</strong></h3>&#13;
<p class="noindent">To capture network traffic, sometimes you have to redirect that traffic to a listening machine. This section lists a few tools that provide ways to implement network spoofing and redirection without needing much configuration.</p>&#13;
<h4 class="h4" id="ch00lev1sec341"><strong><em>DNSMasq</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">http://www.thekelleys.org.uk/dnsmasq/doc.html</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platform</strong> Linux</p>&#13;
<p class="noindent">The DNSMasq tool is designed to quickly set up basic network services, such as DNS and DHCP, so you don’t have to hassle with complex service configuration. Although DNSMasq isn’t specifically designed for network spoofing, you can repurpose it to redirect a device’s network traffic for capture, analysis, and exploitation.</p>&#13;
<h4 class="h4" id="ch00lev1sec342"><strong><em>Ettercap</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://ettercap.github.io/ettercap/">https://ettercap.github.io/ettercap/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv2</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Linux, macOS</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_288"/>Ettercap (discussed in <a href="../Text/ch04.xhtml#ch04">Chapter 4</a>) is a man-in-the-middle tool designed to listen to network traffic between two devices. It allows you to spoof DHCP or ARP addresses to redirect a network’s traffic.</p>&#13;
<h3 class="h3" id="ch00lev1sec343"><strong>Executable Reverse Engineering</strong></h3>&#13;
<p class="noindent">Reviewing the source code of an application is often the easiest way to determine how a network protocol works. However, when you don’t have access to the source code, or the protocol is complex or proprietary, network traffic–based analysis is difficult. That’s where reverse engineering tools come in. Using these tools, you can disassemble and sometimes decompile an application into a form that you can inspect. This section lists several reverse engineering tools that I use. (See the discussion in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a> for more details, examples, and explanation.)</p>&#13;
<h4 class="h4" id="ch00lev1sec344"><strong><em>Java Decompiler (JD)</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://jd.benow.ca/">http://jd.benow.ca/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> GPLv3</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Supported Java platforms (Linux, macOS, Solaris, Windows)</p>&#13;
<p class="noindent">Java uses a bytecode format with rich metadata, which makes it fairly easy to reverse engineer Java bytecode into Java source code using a tool such as the Java Decompiler. The Java Decompiler is available with a stand-alone GUI as well as plug-ins for the Eclipse IDE.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0288-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec345"><span epub:type="pagebreak" id="page_289"/><strong><em>IDA Pro</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://www.hex-rays.com/">https://www.hex-rays.com/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Commercial; limited free version available</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Linux, macOS, Windows</p>&#13;
<p class="noindent">IDA Pro is the best-known tool for reverse engineering executables. It disassembles and decompiles many different process architectures, and it provides an interactive environment to investigate and analyze the disassembly. Combined with support for custom scripts and plug-ins, IDA Pro is the best tool for reverse engineering executables. Although the full professional version is quite expensive, a free version is available for noncommercial use; however, it is restricted to 32-bit x86 binaries and has other limitations.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0289-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec346"><strong><em>Hopper</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://www.hopperapp.com/">http://www.hopperapp.com/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Commercial; a limited free trial version is also available</p>&#13;
<p class="noindent1b"><strong>Platforms</strong> Linux, macOS</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_290"/>Hopper is a very capable disassembler and basic decompiler that can more than match many of the features of IDA Pro. Although as of this writing Hopper doesn’t support the range of processor architectures that IDA Pro does, it should prove more than sufficient in most situations due to its support of x86, x64, and ARM processors. The full commercial version is considerably cheaper than IDA Pro, so it’s definitely worth a look.</p>&#13;
<h4 class="h4" id="ch00lev1sec347"><strong><em>ILSpy</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="http://ilspy.net/">http://ilspy.net/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> MIT</p>&#13;
<p class="noindent1b"><strong>Platform</strong> Windows (with .NET4)</p>&#13;
<p class="noindent">ILSpy, with its Visual Studio–like environment, is the best supported of the free .NET decompiler tools.</p>&#13;
<div class="image"><img alt="image" src="../Images/f0290-01.jpg"/></div>&#13;
<h4 class="h4" id="ch00lev1sec348"><strong><em>.NET Reflector</em></strong></h4>&#13;
<p class="noindent1t"><strong>Website</strong> <em><a href="https://www.red-gate.com/products/dotnet-development/reflector/">https://www.red-gate.com/products/dotnet-development/reflector/</a></em></p>&#13;
<p class="noindent1"><strong>License</strong> Commercial</p>&#13;
<p class="noindent1b"><strong>Platform</strong> Windows</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_291"/>Reflector is the original .NET decompiler. It takes a .NET executable or library and converts it into C# or Visual Basic source code. Reflector is very effective at producing readable source code and allowing simple navigation through an executable. It’s a great tool to have in your arsenal.<span epub:type="pagebreak" id="page_292"/></p>&#13;
<div class="image"><img alt="image" src="../Images/f0291-01.jpg"/></div>&#13;
</body></html>