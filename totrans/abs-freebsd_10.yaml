- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: DISKS, PARTITIONING, AND GEOM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘、分区和几何**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: A sysadmin can’t overemphasize the importance of managing disks and filesystems.
    (Go ahead, try to emphasize it too much. I’ll wait.) Your disks contain your data,
    making reliability and flexibility paramount to the operating system. FreeBSD
    supports a variety of filesystems and has many different ways to handle them.
    In this chapter, we’ll consider the most common disk tasks every sysadmin performs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员不能过分强调管理磁盘和文件系统的重要性。（去吧，试着过分强调。我会等着的。）你的磁盘存储着你的数据，这使得操作系统对其可靠性和灵活性要求极高。FreeBSD支持多种文件系统，并有许多不同的方法来处理它们。在本章中，我们将讨论每个系统管理员都会执行的最常见的磁盘任务。
- en: First, let’s discuss the most important thing to remember about storage devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论存储设备最重要的一点。
- en: '**Disks Lie**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**磁盘会撒谎**'
- en: 'Once upon a time, a sysadmin could make decisions about a disk based on the
    information it provided. You could plug in a hard drive and query it for the number
    of platters, cylinders, sectors, and more. Those days are long, long past. Yes,
    you can perform the same query and get an answer, but those answers don’t reflect
    any reality. Today, a disk is a magic box that regurgitates data on request. Some
    of those magic boxes contain spinning platters. Others lack moving parts. The
    magic boxes provide numbered sectors for storing bits and bytes. The relationship
    between those numbers and the contents of the box? That’s magic: inscrutable and
    unknowable.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，系统管理员可以根据磁盘提供的信息做出决策。你可以插入硬盘，查询其盘片数、气缸数、扇区数等更多信息。那时候已经是很久很久以前的事了。是的，你现在可以执行相同的查询并得到答案，但这些答案并不反映任何现实。今天，磁盘就像是一个魔法盒子，根据需求吐出数据。这个魔法盒子有的包含旋转的盘片，另一些则没有活动部件。这个魔法盒子提供带编号的扇区来存储比特和字节。那些数字和盒子内容之间的关系？那就是魔法：不可理解且无法知晓。
- en: In previous books, including earlier editions of this one, I’ve discussed the
    importance of proper data placement on the disk, but all of that knowledge is
    completely obsolete. If you still retain any of that knowledge, discard it in
    favor of something more useful, like the complete biographies of all the actors
    who appeared in any role in classic *Doctor Who*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的书籍中，包括本书的早期版本，我讨论过数据在磁盘上正确放置的重要性，但这些知识如今已经完全过时。如果你仍然保留这些知识，请抛弃它，转而学习更有用的东西，比如所有出演经典*神秘博士*角色的演员的完整传记。
- en: As far as disk design goes, the only thing you need to know about is *logical
    block addressing (LBA)*. Each sector on a disk is assigned a number. Filesystems
    call disk sectors by number. That’s it. Anything beneath LBA is pure guesswork
    on your part.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就磁盘设计而言，你需要知道的唯一事情就是*逻辑块寻址（LBA）*。磁盘上的每个扇区都会分配一个编号。文件系统通过编号来调用磁盘扇区。就是这样。LBA以下的任何内容，都只是你个人的猜测而已。
- en: 'Unfortunately, disks now have a new category of lies they tell: sector size.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，磁盘现在有了一类新的谎言：扇区大小。
- en: Up through the 1990s, disk sector sizes varied from 128 bytes to 2KB. Even the
    original IBM PC could understand different sector sizes on floppy disks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到了1990年代，磁盘扇区大小从128字节到2KB不等。即使是最早的IBM PC也能理解软盘上不同的扇区大小。
- en: In the early 2000s, though, manufacturers settled on 512-byte sectors. Today’s
    hard drives are much larger, and the files are similarly larger. In the last few
    years, the 512-byte sectors have mostly been replaced with 4,096-byte sectors,
    called *4K drives*. This sector size makes more sense for the type of data we
    store today.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在2000年代初期，制造商决定使用512字节的扇区。今天的硬盘容量大得多，文件也同样更大。在过去的几年里，512字节的扇区大多被4,096字节的扇区取代，这种硬盘被称为*4K硬盘*。这种扇区大小对于我们今天存储的数据类型来说更为合理。
- en: The problem is, operating systems like Windows XP know that a disk sector always
    has been, and always will be, 512 bytes. These operating systems won’t tolerate
    hard drives that reported having 4KB sectors because everybody knows there’s no
    such thing. If you manufacture 4K drives, what do you do?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，像Windows XP这样的操作系统知道磁盘扇区一直是，而且永远会是，512字节。这些操作系统无法容忍报告拥有4KB扇区的硬盘，因为大家都知道根本没有这种东西。如果你制造了4K硬盘，你该怎么办？
- en: The same thing you always do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就是你一直在做的事。
- en: You teach the hard drive to lie.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你教硬盘撒谎。
- en: Best of all, different 4K drives lie in different ways. If the OS asks a drive
    its sector size, most drives state that they have 512-byte sectors. Drives that
    claim to have both 512-byte and 4KB sectors are probably 4K drives, struggling
    to tell the truth. Very few admit to having solely 4KB sectors. To complicate
    matters even more, some solid state drives have sectors as large as 8KB or 16KB,
    or they support multiple sector sizes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，不同的4K驱动方式不同。如果操作系统询问驱动其扇区大小，大多数驱动会声明它们有512字节的扇区。那些宣称有512字节和4KB扇区的驱动可能是4K驱动，正在努力说出真相。很少有驱动承认只使用4KB扇区。更复杂的是，一些固态硬盘的扇区甚至达到8KB或16KB，或者它们支持多种扇区大小。
- en: Both of FreeBSD’s main filesystems must know the sector size of the underlying
    disk and the logical block address of that sector. If you use the wrong sector
    size on your disk, performance suffers. I could go into long detailed discussions
    of how this happens, but to keep it simple, always align partitions on even megabyte
    boundaries. You might waste a few bytes here and there, but that’s trivial compared
    to the truly appalling performance you’ll get from having a filesystem misaligned
    with the disk.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的两个主要文件系统都必须知道底层磁盘的扇区大小以及该扇区的逻辑块地址。如果在磁盘上使用了错误的扇区大小，性能会受到影响。我可以详细讨论这种情况发生的原因，但为了简化，始终将分区对齐到偶数MB边界。这可能会浪费一些字节，但与磁盘和文件系统不对齐所带来的严重性能问题相比，这点浪费是微不足道的。
- en: '**Device Nodes**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设备节点**'
- en: We touched briefly on device nodes in [Chapter 4](ch04.xhtml#ch04), but let’s
    consider them in more detail here. Device nodes are special files that represent
    a hardware device or an operating system feature. They’re used as logical interfaces
    to provide features to user programs. By using a command on a device node, sending
    information to a device node, or reading data from a device node, you’re telling
    the kernel to perform an action. If the device node represents a physical device,
    you’re acting on that device. These actions can be very different for different
    devices—writing data to disk is very different than writing data to a sound card.
    While you can expose device nodes anywhere, the standard device nodes exist in
    */dev*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.xhtml#ch04)中简要讨论过设备节点，但在这里我们将更详细地探讨它们。设备节点是表示硬件设备或操作系统功能的特殊文件。它们作为逻辑接口提供功能给用户程序。通过对设备节点使用命令、发送信息或读取数据，你实际上是在告诉内核执行某个动作。如果设备节点代表物理设备，那你正在对该设备进行操作。这些操作在不同设备间可能大不相同——写数据到磁盘与写数据到声卡是完全不同的操作。虽然你可以在任何地方暴露设备节点，但标准的设备节点存在于*/dev*目录中。
- en: Before you can work with a disk or disk partition, you must know its device
    name. FreeBSD disk device nodes come from the names of the device driver for that
    type of hardware. Device driver names, in turn, often come from the type of device
    and not the device’s role or function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用磁盘或磁盘分区之前，你必须知道它的设备名称。FreeBSD的磁盘设备节点来自该类型硬件的设备驱动程序名称。设备驱动程序名称反过来通常来源于设备的类型，而不是设备的角色或功能。
- en: Table 10-1 shows the most common disk device nodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-1展示了最常见的磁盘设备节点。
- en: '**Table 10-1:** Storage Device Nodes and Types'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-1：** 存储设备节点和类型'
- en: '| **Device node** | **Man page** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **设备节点** | **手册页** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| */dev/ada** | ada(4) | ATA-style direct access disks (SATA, IDE, etc.) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| */dev/ada** | ada(4) | ATA风格直接访问磁盘（SATA, IDE等） |'
- en: '| */dev/cd** | cd(4) | Optical media drives (CD, Blu-Ray, etc.) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| */dev/cd** | cd(4) | 光学媒体驱动（CD，Blu-Ray等） |'
- en: '| */dev/da** | da(4) | SCSI-style direct access disks (USB storage, SAS, etc.)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| */dev/da** | da(4) | SCSI风格直接访问磁盘（USB存储、SAS等） |'
- en: '| */dev/md** | md(4) | Memory disks |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| */dev/md** | md(4) | 内存磁盘 |'
- en: '| */dev/mmcsd** | mmcsd(4) | MMC and SD memory cards |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| */dev/mmcsd** | mmcsd(4) | MMC和SD存储卡 |'
- en: '| */dev/nvd** | nvd(4) | NVM express drives |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| */dev/nvd** | nvd(4) | NVM express驱动 |'
- en: '| */dev/vtbd** | virtio_blk(4) | Virtio-based virtual machine disk |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| */dev/vtbd** | virtio_blk(4) | 基于Virtio的虚拟机磁盘 |'
- en: '| */dev/xbd** | xen(4) | Xen virtual disks |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| */dev/xbd** | xen(4) | Xen虚拟磁盘 |'
- en: Many RAID controllers present their RAID containers as SCSI devices, so they
    show up as */dev/da* device nodes. Others present their disks as “SCSI plus special
    vendor topping,” so they get special device node names such as */dev/raid* (ATA
    RAID), */dev/mfid* (certain LSI MegaRAID cards), and so on. Check the man page
    for your RAID controller to see the device node it presents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 RAID 控制器将它们的 RAID 容器呈现为 SCSI 设备，因此它们显示为 */dev/da* 设备节点。其他一些则将它们的磁盘呈现为“带有特殊厂商标识的
    SCSI”，因此它们会有特别的设备节点名称，如 */dev/raid*（ATA RAID）、*/dev/mfid*（某些 LSI MegaRAID 卡）等。查看你
    RAID 控制器的 man 页面，了解它所呈现的设备节点。
- en: '**The Common Access Method**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通用访问方法**'
- en: The *Common Access Method (CAM)* is a standardized device driver architecture
    originally written to support the complex command set of 20th-century SCSI-2 disks.
    The idea was that standardizing based on this architecture would simplify writing
    device drivers. Only FreeBSD and DEC OSF/1 actually shipped with CAM, however,
    and each filled in the specification’s gaps differently.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用访问方法（CAM）* 是一种标准化的设备驱动架构，最初是为了支持 20 世纪的 SCSI-2 磁盘的复杂命令集而编写的。其理念是，基于这种架构的标准化将简化设备驱动程序的编写。然而，实际上只有
    FreeBSD 和 DEC OSF/1 配备了 CAM，并且每个操作系统都以不同的方式填补了规范中的空白。'
- en: FreeBSD 9 and later consolidates management of all physical disks that support
    CAM in the CAM interface. Use camcontrol(8) to gather information from disks and
    issue commands to them. The camcontrol(8) command has a variety of subcommands
    that let you issue instructions to hard drives.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 9 及之后的版本将支持 CAM 的所有物理磁盘的管理整合到了 CAM 接口中。使用 camcontrol(8) 从磁盘收集信息并向其发出命令。camcontrol(8)
    命令有多种子命令，可以向硬盘发出指令。
- en: '***What Disks Do You Have?***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你有什么磁盘？***'
- en: 'To identify a host’s storage devices, you can trawl */var/run/dmesg.boot* looking
    for disk device nodes or see which filesystems are mounted and backtrack from
    there. But the easiest way to identify your storage is to have camcontrol(8) ask
    the CAM system what disks it sees. Let’s look at one of my test systems:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别主机的存储设备，你可以扫描 */var/run/dmesg.boot* 查找磁盘设备节点，或者查看挂载的文件系统并从中倒推。但识别存储设备的最简单方法是让
    camcontrol(8) 查询 CAM 系统，看看它识别出了哪些磁盘。让我们看一下我的一台测试系统：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This output is broken up into three fields. The first gives the name of the
    device, as reported by the device itself. This is usually a vendor and the vendor’s
    model number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出分为三个字段。第一个字段给出了设备的名称，由设备本身报告。通常是厂商和厂商的型号。
- en: The second section gives SCSI connection information. These drives aren’t actually
    SCSI drives—they’re SATA connections managed via CAM. But you now know which disk
    devices are plugged into which port on the SATA controller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分给出了 SCSI 连接信息。这些驱动器实际上并不是 SCSI 驱动器——它们是通过 CAM 管理的 SATA 连接。但现在你知道哪些磁盘设备插入了
    SATA 控制器的哪个端口。
- en: Finally, in parentheses, we have the SCSI device and what we probably want,
    the storage device node. This host has four disks, named da0, da1, da2, and da3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在括号中，我们有 SCSI 设备和我们可能需要的存储设备节点。这个主机有四个磁盘，分别命名为 da0、da1、da2 和 da3。
- en: '***Non-CAM Devices***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非 CAM 设备***'
- en: Generally speaking, everything except proprietary RAID controllers and virtual
    disks support CAM.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除了专有的 RAID 控制器和虚拟磁盘外，其他都支持 CAM。
- en: RAID controllers have usually embraced and extended the CAM protocol, for what
    the manufacturer thought was a good reason at the time. A protocol written in
    the early 1990s wasn’t sufficient for a 2010 RAID controller. These controllers
    usually have their own control programs. The RAID containers show up in `devlist`
    and some other camcontrol(8) subcommands.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RAID 控制器通常已经拥抱并扩展了 CAM 协议，出于制造商当时认为合理的原因。一个在 1990 年代初期编写的协议对于 2010 年的 RAID 控制器来说已经不够用了。这些控制器通常有自己的控制程序。RAID
    容器会出现在 `devlist` 和其他 camcontrol(8) 子命令中。
- en: Similarly, virtual disks don’t respond to CAM commands. There’s no disk to command
    there—you’re just writing blocks to a file. You can view the disk with `camcontrol
    devlist`, but that’s about it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虚拟磁盘不会响应 CAM 命令。那里没有磁盘可供操作——你只是在文件中写入数据块。你可以通过 `camcontrol devlist` 查看磁盘，但就仅此而已。
- en: For most applications, I recommend using FreeBSD’s RAIDZ or GEOM RAID, rather
    than a hardware RAID controller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用，我推荐使用 FreeBSD 的 RAIDZ 或 GEOM RAID，而不是硬件 RAID 控制器。
- en: '**The GEOM Storage Architecture**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GEOM 存储架构**'
- en: FreeBSD has an incredibly flexible storage infrastructure system called *GEOM*
    (short for “disk geometry”). GEOM lives between device driver nodes and the underlying
    hardware, handling data exchanged between them. From this position, GEOM can arbitrarily
    transform input/output requests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 拥有一个极其灵活的存储基础设施系统，称为 *GEOM*（即“磁盘几何”）。GEOM 位于设备驱动程序节点与底层硬件之间，处理它们之间交换的数据。从这个位置，GEOM
    可以任意转换输入/输出请求。
- en: '**DEVICE CONTROL PROGRAMS**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备控制程序**'
- en: Some storage devices have special features that aren’t addressed in the generic
    CAM framework. RAID controllers often have vendor-specific features, and FreeBSD
    includes many small programs to individually manage these controllers. You’ll
    find programs like mfiutil(8) and mptutil(8) for older LSI controllers, mpsutil(8)
    for newer LSI controllers, and so on. If you have a nonvolatile memory express
    (NVMe) drive, check out nvmecontrol(8).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些存储设备具有特殊功能，这些功能在通用 CAM 框架中并未涵盖。RAID 控制器通常具有厂商特定的功能，FreeBSD 包含许多小程序来单独管理这些控制器。你会发现像
    mfiutil(8) 和 mptutil(8) 用于较旧的 LSI 控制器，mpsutil(8) 用于较新的 LSI 控制器，等等。如果你有非易失性存储器高速缓存（NVMe）驱动器，可以查看
    nvmecontrol(8)。
- en: GEOM is built out of kernel modules, called *GEOM classes*, that let you perform
    specific types of transformation or management. Disks have a GEOM class that lets
    the kernel put data on the disk. But if you want to encrypt your disks, that’s
    a GEOM class. Software-based RAID? A GEOM class. FreeBSD implements all storage
    modifications as GEOM classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 是由内核模块构建的，称为 *GEOM 类*，它们让你执行特定类型的转换或管理。磁盘有一个 GEOM 类，允许内核将数据写入磁盘。但如果你想加密你的磁盘，那也是一个
    GEOM 类。基于软件的 RAID？一个 GEOM 类。FreeBSD 将所有存储修改实现为 GEOM 类。
- en: GEOM classes are *stackable*. They use the output of one class as the input
    for another. You want to encrypt your hard drive and then mirror it to another
    hard drive? Sure! Stack an encryption module on top of your hard drive and then
    stack the drive-mirroring module on top of that. You want to mirror that drive
    across the network? Add that GEOM class to the stack. This flexible modularity
    makes GEOM one of FreeBSD’s most powerful features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 类是 *可堆叠* 的。它们使用一个类的输出作为另一个类的输入。如果你想加密硬盘，然后将其镜像到另一个硬盘？当然可以！在硬盘上堆叠一个加密模块，然后再堆叠一个驱动器镜像模块。你想将那个驱动器跨网络镜像？把那个
    GEOM 类加到堆栈中。这种灵活的模块化使得 GEOM 成为 FreeBSD 最强大的特性之一。
- en: '***GEOM Autoconfiguration***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 自动配置***'
- en: When FreeBSD finds a new storage device, either at boot or when you plug a new
    drive in, the GEOM subsystem checks the device for known formats, like a master
    boot record, a BSD disklabel, or other metadata. GEOM also checks for physical
    identifiers, such as the disk’s serial number. This is called *tasting*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 FreeBSD 发现新存储设备时，无论是在启动时还是插入新硬盘时，GEOM 子系统会检查该设备是否包含已知的格式，比如主引导记录、BSD 磁盘标签或其他元数据。GEOM
    还会检查物理标识符，如磁盘的序列号。这被称为 *品尝*。
- en: When GEOM finds identifying information, it configures the device as that metadata
    dictates. If a disk’s metadata says, “I’m part of a mirror called *garbage*, along
    with two other disks,” GEOM looks for the other disks and assembles the mirror.
    If GEOM can identify a storage device by format, label, or other information,
    it starts the device, fires up an instance of the GEOM class, makes the appropriate
    device nodes, and performs any other configuration it understands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GEOM 发现标识信息时，它会根据该元数据的指示配置设备。如果磁盘的元数据说，“我是名为 *garbage* 的镜像的一部分，和另外两块磁盘一起，”GEOM
    会寻找其他磁盘并组装镜像。如果 GEOM 能通过格式、标签或其他信息识别存储设备，它会启动该设备，启动一个 GEOM 类实例，创建适当的设备节点，并执行任何它理解的其他配置。
- en: If GEOM can’t identify any other metadata on the disk, such as on an unformatted
    and unpartitioned disk, GEOM creates the device node for the storage device and
    leaves it alone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GEOM 无法识别磁盘上的其他元数据，例如在未格式化且未分区的磁盘上，GEOM 会为该存储设备创建设备节点并保持原样。
- en: An instance of a GEOM class is called a *geom*. The gmirror(8) class makes disks
    mirror each other, but the specific pair of mirrored disks named *garbage* is
    a geom. Each disk in that mirror is also a geom.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 类的实例称为 *geom*。gmirror(8) 类让磁盘彼此镜像，但名为 *garbage* 的特定镜像磁盘对就是一个 geom。该镜像中的每个磁盘也是一个
    geom。
- en: '***GEOM vs. Volume Managers***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 与卷管理器***'
- en: Traditional volume managers expect you to do things their way, whether that
    makes sense for your environment and hardware or not. If the volume manager says
    that you create an encrypted disk mirror by encrypting the individual drives and
    then mirroring on top of them, that’s what you do. It might make more sense in
    your environment to mirror the drives and then encrypt them, but if that’s not
    what the volume manager does, too bad. Worse, some volume managers make poor choices
    and then implement fixes sideways to minimize the consequences of those decisions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的卷管理器期望你按它们的方式做事，无论这对你的环境和硬件是否合理。如果卷管理器说你通过加密单个驱动器并在其上进行镜像来创建加密的磁盘镜像，那么你就必须这么做。或许在你的环境中，先镜像驱动器然后加密它们更合适，但如果这不是卷管理器的做法，那也没办法。更糟糕的是，一些卷管理器做出糟糕的选择，然后通过旁路方式修复这些选择，以最小化这些决策的后果。
- en: GEOM differs from volume managers in that it assumes you know what you’re doing.
    It gives you flexibility to arrange your storage in the manner that best fits
    your hardware and benefits your use case. GEOM classes let you easily insert new
    data transformations into your storage. You can’t, say, add an encryption layer
    into your commercial volume manager.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 与卷管理器的不同之处在于，它假设你知道自己在做什么。它给你灵活性，让你以最适合硬件并能为你的用例带来好处的方式安排存储。GEOM 类让你可以轻松地将新的数据转换功能插入到存储中。而你不能在商业卷管理器中加入加密层之类的功能。
- en: Volume managers cover the most common cases for hardware that existed at the
    time they were conceived. As time passes, though, that most common case becomes
    increasingly uncommon. People continue to use volume managers long after the hardware
    they were designed for becomes obsolete. GEOM lets you evolve your designs with
    your hardware, environment, and application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 卷管理器涵盖了它们设计时硬件中最常见的情况。然而，随着时间的推移，这些常见的情况变得越来越不常见。人们继续使用卷管理器，即使它们最初为已经过时的硬件设计。GEOM
    让你随着硬件、环境和应用程序的变化，演化你的设计。
- en: 'FreeBSD includes two software suites that look much like volume managers: gvinum(8)
    and ZFS. Vinum was the FreeBSD volume manager in the 1990s, and while gvinum(8)
    reimplements it as a GEOM class, its use is strongly discouraged. ZFS is very
    powerful, as we saw in [Chapter 5](ch05.xhtml#ch05), but it does have the “do
    it our way” ethos of a volume manager.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了两个看起来很像卷管理器的软件套件：gvinum(8) 和 ZFS。Vinum 是 1990 年代的 FreeBSD 卷管理器，尽管
    gvinum(8) 重新实现了它作为 GEOM 类，但强烈不建议使用它。ZFS 非常强大，正如我们在[第 5 章](ch05.xhtml#ch05)中看到的，但它确实有卷管理器的“按我们的方式做事”的理念。
- en: While you can theoretically stack GEOM modules forever, you must consider your
    hardware resources. Mirroring a busy disk across a network can require a dedicated
    network interface and an otherwise empty cross-connect cable. Encrypting and decrypting
    data eats processor time and memory. GEOM doesn’t prevent you from thrashing your
    disks; it merely gives you new and interesting opportunities for doing so.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上你可以永远堆叠 GEOM 模块，但你必须考虑硬件资源。通过网络镜像一个繁忙的磁盘可能需要专用的网络接口和空闲的交叉连接电缆。加密和解密数据会消耗处理器时间和内存。GEOM
    不会阻止你对磁盘进行过度操作；它只是为你提供了进行这些操作的新机会和有趣的可能性。
- en: '***Providers, Consumers, and Slicers***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***提供者、消费者和分割器***'
- en: Individual geoms are either consumers, providers, or both.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 各个 geom 要么是消费者，要么是提供者，或者两者兼具。
- en: A *provider* offers services to another geom. If you’re mirroring two hard drives,
    the geoms for the hard drive provide the disk to the mirror. A provider usually
    has a device node, such as */dev/ada1p1*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *提供者* 为另一个 geom 提供服务。如果你正在镜像两个硬盘，硬盘的 geom 提供磁盘给镜像使用。一个提供者通常具有一个设备节点，比如 */dev/ada1p1*。
- en: A *consumer* uses the provider’s services. A disk-mirror geom consumes the underlying
    disk drives. The consumer part of a geom doesn’t need a device node.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *消费者* 使用提供者的服务。磁盘镜像 geom 消耗底层磁盘驱动器。一个 geom 的消费者部分不需要设备节点。
- en: A geom can be both a provider and a consumer—indeed, every geom in the middle
    of a stack must be both. A disk-mirror geom consumes the underlying physical storage
    media, but it provides a mirrored disk for the filesystem to live on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 geom 可以既是提供者又是消费者——实际上，堆栈中间的每个 geom 必须既是提供者又是消费者。磁盘镜像 geom 消耗底层的物理存储介质，但它为文件系统提供了一个镜像磁盘。
- en: FreeBSD treats all providers and consumers identically. A physical hard drive
    is just another provider, exactly like a mirror or encryption layer or import
    from the network. This characteristic lets you arbitrarily stack GEOM classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 对待所有提供者和消费者的方式是相同的。一个物理硬盘只是另一个提供者，就像镜像、加密层或网络导入一样。这一特点使得你可以任意堆叠 GEOM
    类。
- en: A GEOM class that subdivides a class is called a *slicer* and is usually responsible
    for managing partitions. The GEOM class that handles master boot record (MBR)
    partitions is a slicer, as is the GUID Partition Table (GPT) class. We discussed
    both of these partitioning methods in [Chapter 2](ch02.xhtml#ch02), and we’ll
    go deeper into both in this chapter. Slicers must make sure that disk partitions
    don’t overlap and that the partitions conform to the rules of the partitioning
    scheme.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将一个类细分为多个子类的 GEOM 类称为 *切片器*，通常负责管理分区。处理主引导记录（MBR）分区的 GEOM 类是一个切片器，GUID 分区表（GPT）类也是如此。我们在[第
    2 章](ch02.xhtml#ch02)中讨论了这两种分区方法，在本章中我们将进一步探讨这两种方法。切片器必须确保磁盘分区不重叠，并且分区符合分区方案的规则。
- en: '***GEOM Control Programs***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 控制程序***'
- en: Many GEOM classes have a control program that lets you administer the module
    or interrogate the device. Some widely used classes use geom(8), while other classes
    use programs like gmirror(8) or geli(8). The *disk* GEOM class talks to the physical
    storage media and provides consumers for upper layers. That’s a really commonly
    used class. Here, I interrogate a host to see what geoms of type *disk* it has
    and print out the information the disk offers the operating system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 GEOM 类都有一个控制程序，让你管理模块或查询设备。一些广泛使用的类使用 geom(8)，而其他类使用如 gmirror(8) 或 geli(8)
    之类的程序。*disk* GEOM 类与物理存储介质进行通信，并为上层提供消费者。这是一个非常常用的类。在这里，我查询主机以查看它具有的 *disk* 类型的
    geoms，并打印出磁盘提供给操作系统的信息。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hard drive provides a disk device called da0 ➊. The *mediasize* field gives
    its size in bytes and converts it to a more convenient 932GB ➋.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该硬盘提供一个名为 da0 ➊ 的磁盘设备。*mediasize* 字段提供其大小（以字节为单位），并将其转换为更便捷的 932GB ➋。
- en: This disk claims to have a *sector size* of 512 bytes ➌. Many disks lie about
    their sector size. Check the drive manufacturer’s documentation to determine the
    actual sector size. Drives might offer a *Stripesize* value of 4,096 to indicate
    that they’re actually 4K drives.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该磁盘声称其 *扇区大小* 为 512 字节 ➌。许多磁盘会虚报其扇区大小。请查看硬盘制造商的文档，以确定实际的扇区大小。驱动器可能会提供 *Stripesize*
    值 4,096，表示它们实际上是 4K 驱动器。
- en: A GEOM class’s *mode* looks an awful lot like file permissions ➍, but it’s really
    the number of GEOM classes reading from (r2) and writing to (w2) the device, plus
    the number of devices that have requested exclusive access to the device (e3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GEOM 类的 *mode* 看起来非常像文件权限 ➍，但它实际上是读取（r2）和写入（w2）设备的 GEOM 类的数量，以及请求独占访问设备的设备的数量（e3）。
- en: The *descr* field ➎ offers the drive’s model number.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*descr* 字段 ➎ 提供驱动器的型号。'
- en: The *lunname* field ➏ gives the model number plus the serial number. Yes, it’s
    a combination of the descr and ident fields. The hard drive really, really wants
    you to believe this is its name and identifier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*lunname* 字段 ➏ 提供型号和序列号。是的，它是 *descr* 和 *ident* 字段的组合。硬盘确实很希望你相信这就是它的名称和标识符。'
- en: The *lunid* ➐ gives the logical-unit-number (LUN) identifier, which describes
    how this drive attaches to this host.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*lunid* ➐ 提供逻辑单元号（LUN）标识符，描述此驱动器如何连接到此主机。'
- en: The disk’s *ident* ➑ is the drive’s serial number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的 *ident* ➑ 是驱动器的序列号。
- en: The *rotationrate* ➒ tells us how fast this drive spins. It’s a 7,200 RPM disk.
    Nonspinning disks, like SSDs, have a rotationrate of 0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*rotationrate* ➒ 告诉我们该驱动器的旋转速度。它是一个 7,200 RPM 磁盘。非旋转磁盘，如 SSD，其 rotationrate
    为 0。'
- en: The *fwsectors* and *fwheads* fields ➓ give us the drive geometry. These are
    examples of the lies mentioned in the beginning of this chapter. Even SSDs offer
    these values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*fwsectors* 和 *fwheads* 字段 ➓ 提供磁盘几何信息。这些是本章开头提到的谎言的例子。即使是 SSD 也会提供这些值。'
- en: Some drives offer less information. Virtual disks offer almost no information,
    and anything they do say, you can’t trust. (While the VM system might say this
    disk offers 32,212,254,720 512-byte sectors, who knows what the actual disk beneath
    the virtual disk has?)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些驱动器提供较少的信息。虚拟磁盘几乎不提供任何信息，而且它们提供的任何信息都不可信。（尽管虚拟机系统可能会说该磁盘提供 32,212,254,720
    个 512 字节扇区，但谁知道虚拟磁盘下方的实际磁盘是什么样子呢？）
- en: '***GEOM Device Nodes and Stacks***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 设备节点和堆栈***'
- en: Many sysadmin tools expect to run on a disk or disk partition. Unix-like systems
    offer disks and partitions as device nodes. GEOM offers device nodes so that these
    tools remain compatible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员工具期望在磁盘或磁盘分区上运行。类Unix系统提供磁盘和分区作为设备节点。GEOM 提供设备节点，以确保这些工具保持兼容性。
- en: Most active GEOM modules have their own directory in */dev*. Device nodes within
    that directory represent the current providers of that module. The directory is
    often, but not always, named after the GEOM module using it. For example, the
    gmirror(8) class uses */dev/mirror*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数活跃的GEOM模块在*/dev/*下都有自己的目录。该目录中的设备节点表示该模块当前的提供者。该目录通常（但不总是）以使用该模块的GEOM模块命名。例如，gmirror(8)类使用*/dev/mirror*。
- en: The directory name might be changed to avoid ambiguity or overlaps. The *glabel
    (GEOM label)* class uses */dev/label*. The */dev/gpt* directory contains the labels
    stored on GPT partitions, where */dev/gptid* contains the numerical identifiers
    integral to GPT partitions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目录名称可能会更改，以避免歧义或重叠。*glabel（GEOM标签）*类使用*/dev/label*。*/dev/gpt*目录包含存储在GPT分区上的标签，而*/dev/gptid*目录包含与GPT分区相关的数字标识符。
- en: Some classes don’t create a directory and instead piggyback on existing devices.
    The gnop(8) class creates a new node right next to the node it’s attached to but
    appends *.nop* to the end of the device name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类不会创建目录，而是附加到现有设备上。gnop(8)类会在附加的节点旁边创建一个新的节点，但会在设备名称末尾附加*.nop*。
- en: '**Hard Disks, Partitions, and Schemes**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**硬盘、分区和方案**'
- en: While we discussed partitioning in [Chapter 9](ch09.xhtml#ch09), consider partitions
    from a disk drive perspective. The first possible SATA disk on our first SATA
    controller is called */dev/ada0*. Subsequent disks are */dev/ada1*, */dev/ada2*,
    and so on. If you also have SAS disks, they’ll start their numbering over at 0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在[第9章](ch09.xhtml#ch09)中讨论了分区，但请从磁盘驱动器的角度考虑分区。我们第一个SATA控制器上的第一个可能的SATA磁盘叫做*/dev/ada0*。后续的磁盘分别是*/dev/ada1*、*/dev/ada2*，依此类推。如果你还拥有SAS磁盘，它们的编号将从0开始。
- en: Disks get further divided into *partitions*. Even average consumer-grade systems
    running Microsoft operating systems ship with multiple partitions on the hard
    drive. Sysadmins chop huge disk arrays into smaller, more manageable units with
    dedicated purposes—or perhaps they go the other way and merge multiple disks into
    one monster partition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘被进一步划分为*分区*。即使是运行Microsoft操作系统的普通消费级系统，其硬盘上也通常会有多个分区。系统管理员将巨大的磁盘阵列划分为更小、更易于管理的单元，具有特定用途——或者他们也可能采取相反的做法，将多个磁盘合并为一个庞大的分区。
- en: A *partitioning scheme* is the system for organizing partitions on a disk. The
    traditional master boot record (MBR) is one partitioning scheme. Old Apple and
    SPARC hardware have their own schemes. Today, the scheme used by most hardware
    and operating systems is *GUID Partition Tables (GPT)*. Each scheme has its own
    requirements for boot blocks, hardware architecture, and partitions. This book
    discusses the MBR and GPT schemes, but you should be aware that other schemes
    exist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*分区方案*是用于组织磁盘分区的系统。传统的主引导记录（MBR）是一种分区方案。旧的苹果和SPARC硬件有它们自己的分区方案。今天，大多数硬件和操作系统使用的方案是*GUID分区表（GPT）*。每种方案都有其对引导块、硬件架构和分区的要求。本书讨论了MBR和GPT方案，但你应该意识到其他方案也存在。'
- en: 'Each disk partition gets its own device node, created by adding something to
    the end of the underlying device node name. Here, I look at the device node for
    a default FreeBSD install using UFS on a virtual disk:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘分区都会获得自己的设备节点，这些设备节点是通过在底层设备节点名称末尾添加内容来创建的。在这里，我查看了一个默认的FreeBSD安装，使用UFS格式在虚拟磁盘上进行的设备节点：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have a device node for the disk itself and then three others ending in p1,
    p2, and p3\. What are those subdivisions? The *p* indicates that they’re GPT partitions.
    In a default install, p1 is the boot partition, p2 is the swap space, and p3 is
    the main filesystem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个磁盘本身的设备节点，然后还有三个其他设备节点，分别以p1、p2和p3结尾。那些子分区是什么？*p*表示它们是GPT分区。在默认安装中，p1是引导分区，p2是交换空间，p3是主文件系统。
- en: Each partitioning scheme has its own device node extensions. We’ll read about
    those later this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区方案都有自己独特的设备节点扩展。我们将在本章后面阅读到这些内容。
- en: '**The Filesystem Table: /etc/fstab**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件系统表：/etc/fstab**'
- en: FreeBSD, like most Unix-like operating systems, uses the file system table */etc/fstab*
    to map on-disk partitions to filesystems and swap space. While ZFS doesn’t use
    */etc/fstab*, every other FreeBSD filesystem can appear therein. Each partition
    in use appears on a separate line, along with mounting and management instructions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD像大多数类Unix操作系统一样，使用文件系统表*/etc/fstab*将磁盘上的分区映射到文件系统和交换空间。虽然ZFS不使用*/etc/fstab*，但其他所有FreeBSD文件系统都可以出现在其中。每个使用中的分区都会出现在单独的一行上，并附有挂载和管理指令。
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first field gives the GEOM provider name. This might be a physical disk
    partition such as */dev/ada0p1* or perhaps a partition of a GEOM device node.
    The first two lines here offer device nodes under */dev/gpt*. They’re GPT labels,
    which we’ll see later this chapter. Our third entry lists the word *proc* rather
    than a device node: it’s the procfs(5) virtual filesystem, which we’ll examine
    in [Chapter 13](ch13.xhtml#ch13).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段给出了 GEOM 提供者的名称。这可能是一个物理磁盘分区，例如 */dev/ada0p1*，或者可能是一个 GEOM 设备节点的分区。这里的前两行提供了
    */dev/gpt* 下的设备节点。这是 GPT 标签，我们将在本章稍后看到。我们的第三项列出了 *proc*，而不是设备节点：它是 procfs(5) 虚拟文件系统，我们将在
    [第13章](ch13.xhtml#ch13) 中详细讨论。
- en: The second field gives the directory where the filesystem is available, called
    the *mount point*. Every partition you can read or write files on is attached
    to a mount point, such as */usr*, */var*, and so on. A few special partitions,
    such as swap space (line 2 here), have a mount point of none. You can’t read or
    write usable files to the swap space because they’re not attached to the directory
    tree and because the system would overwrite those files when it swapped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段给出了文件系统可用的目录，称为 *挂载点*。每个可以读写文件的分区都会附加到一个挂载点，例如 */usr*、*/var* 等等。一些特殊的分区，例如
    swap 空间（这里是第二行），其挂载点为 none。因为它们没有连接到目录树，且系统在交换时会覆盖这些文件，所以你不能在 swap 空间上读写文件。
- en: Next, we have the filesystem type. The first line shows a type of *ufs*, or
    Unix File System. The second line is defined as *swap* space, while the third
    is type *procfs*. Other types include *cd9660* (CD disks or images), *nfs* (Network
    File System mounts), and *ext4fs* (Linux filesystems). The filesystem table tells
    FreeBSD how to mount this partition. [Chapter 13](ch13.xhtml#ch13) discusses alternate
    filesystems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看文件系统类型。第一行显示的是 *ufs* 类型，或者说是 Unix 文件系统。第二行定义为 *swap* 空间，而第三行是 *procfs*
    类型。其他类型包括 *cd9660*（CD 光盘或映像）、*nfs*（网络文件系统挂载）和 *ext4fs*（Linux 文件系统）。文件系统表告诉 FreeBSD
    如何挂载这个分区。[第13章](ch13.xhtml#ch13)讨论了其他文件系统。
- en: 'The fourth field shows the mount(8) options used for this particular partition.
    Each filesystem has its own mount options, but here are a few that multiple filesystems
    use and that frequently appear in */etc/fstab*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个字段显示了用于此特定分区的 mount(8) 选项。每个文件系统都有其自己的挂载选项，但这里列出了一些多个文件系统都使用且经常出现在 */etc/fstab*
    中的选项：
- en: '**ro** The filesystem is mounted read-only. Not even root can write to it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**ro** 文件系统以只读方式挂载。连 root 用户也不能对其进行写操作。'
- en: '**rw** The filesystem is mounted read-write.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw** 文件系统以读写方式挂载。'
- en: '**noauto** FreeBSD won’t automatically mount the filesystem, neither at boot
    nor when using `mount -a`. This option is useful for removable media drives that
    might not have media in them at boot.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**noauto** FreeBSD 不会自动挂载文件系统，无论是在启动时还是在使用 `mount -a` 时。这个选项对于可能在启动时没有介质的可移动媒体驱动器非常有用。'
- en: The fifth field is used to tell dump(8) what backup level is needed to back
    up this filesystem. Dump is largely obsolete these days; people perform file-level
    backup with tar(1) or use more advanced backup software, like Bacula (*[http://www.bacula.org/](http://www.bacula.org/)*)
    or Tarsnap (*[https://www.tarsnap.com/](https://www.tarsnap.com/)*).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字段用于告诉 dump(8) 需要哪个备份级别来备份这个文件系统。现在，dump 已经基本过时；人们使用 tar(1) 进行文件级备份，或者使用更先进的备份软件，如
    Bacula (*[http://www.bacula.org/](http://www.bacula.org/)*) 或 Tarsnap (*[https://www.tarsnap.com/](https://www.tarsnap.com/)*）。
- en: The last field tells the FreeBSD boot process when to check filesystem integrity.
    All the partitions with the same number get checked in parallel with fsck(8).
    The root filesystem gets marked with a 1, meaning it’s checked first. Only the
    root filesystem should get a 1\. Any other partitions should get a 2 or higher,
    meaning they get checked later. Swap, read-only media, and logical filesystems
    don’t require integrity checking, so they get set to 0.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段告诉 FreeBSD 启动过程在何时检查文件系统的完整性。所有具有相同编号的分区会与 fsck(8) 一起并行检查。根文件系统标记为 1，意味着它是第一个被检查的。只有根文件系统应该标记为
    1，任何其他分区应该标记为 2 或更高，意味着它们稍后会被检查。交换分区、只读介质和逻辑文件系统不需要完整性检查，因此它们会设置为 0。
- en: FreeBSD configures all filesystems found in */etc/fstab* at boot. As the system
    runs, though, the sysadmin can mount other filesystems. And she can unmount ones
    listed there. That leads to our next question . . .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 在启动时配置所有在 */etc/fstab* 中找到的文件系统。然而，随着系统运行，系统管理员可以挂载其他文件系统，并且她也可以卸载那些列在其中的文件系统。这就引出了我们的下一个问题……
- en: '**What’s Mounted Now?**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**现在挂载的是什么？**'
- en: If not all filesystems are mounted automatically at boot, and if the sysadmin
    can add and remove mounted filesystems, how can you determine what’s mounted right
    now? Use mount(8) without any options to see all mounted filesystems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是所有的文件系统在启动时都被自动挂载，并且如果系统管理员可以添加和移除挂载的文件系统，如何确定当前已挂载的文件系统呢？使用mount(8)命令，不带任何选项，可以查看所有挂载的文件系统。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a small UFS-based host. It has one disk partition and an instance of
    devfs(5) (see [Chapter 13](ch13.xhtml#ch13)). The word *local* means that the
    partition is on a hard drive attached to this machine. The journaled soft-updates
    option is a UFS feature we’ll discuss in [Chapter 11](ch11.xhtml#ch11). If you’re
    using NFS or SMB to mount partitions, they’ll appear here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小型的基于UFS的主机。它只有一个磁盘分区和一个devfs(5)实例（参见[第13章](ch13.xhtml#ch13)）。*local*一词意味着该分区位于连接到此计算机的硬盘上。日志化软更新选项是UFS的一个特性，我们将在[第11章](ch11.xhtml#ch11)中讨论。如果你正在使用NFS或SMB来挂载分区，它们会出现在这里。
- en: 'More complicated hosts give larger results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的主机会产生更大的结果：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This host uses many ZFS datasets, each with its own mount point. The mount(8)
    output shows selected ZFS options, such as noatime and nfsv4acls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该主机使用多个ZFS数据集，每个数据集都有自己的挂载点。mount(8)命令的输出显示了选定的ZFS选项，例如noatime和nfsv4acls。
- en: At the end of this output, we have a procfs(5) entry and one for a devfs(5)
    mount. A working FreeBSD system needs devfs mounted at */dev* or it won’t work
    very well or for very long.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的最后，我们有一个procfs(5)条目和一个devfs(5)挂载条目。一个正常工作的FreeBSD系统需要在*/dev*挂载devfs，否则它的运行将不太顺利，或者根本无法长时间工作。
- en: '**Disk Labeling**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**磁盘标签**'
- en: At the lowest level, operating systems identify disks by their physical attachment
    to the system. Traditionally, the filesystem table says something like, “Use the
    disk attached at ATA port 3 as the */var/log* filesystem.” This worked fine with
    less flexible hardware, but as hardware technology improved, such connections
    became much more flexible. If you assign drive roles based on the physical attachment,
    sometimes that attachment changes. I’ve had more than one mainboard explode at
    an inconvenient hour, forcing a desperate emergency replacement. Tracking which
    cable goes to which connecter under such circumstances never goes well. In older
    versions of FreeBSD, you needed to “wire down” devices so that a specific disk
    always showed up as a specific device node. This is no longer needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低层次上，操作系统通过硬件与系统的物理连接来识别磁盘。传统上，文件系统表可能会写道：“将连接在ATA端口3的磁盘用作*/var/log*文件系统。”在硬件灵活性较差时，这种方法工作得很好，但随着硬件技术的发展，这种连接变得更加灵活。如果你根据物理连接来分配磁盘角色，有时这种连接会发生变化。我曾经有过多次主板在不合时宜的时刻爆炸，迫使我进行紧急替换。在这种情况下，追踪哪个电缆连接到哪个接口通常都会失败。在旧版本的FreeBSD中，你需要“固定”设备，使得特定的磁盘总是作为特定的设备节点出现。现在不再需要这样做。
- en: Today, a sysadmin uses on-disk *labels* to refer to the disk by something other
    than the physical attachment. A label identifies an instance of a geom. Rather
    than telling FreeBSD that */var/www* is on the disk attached to SATA port 2, you
    declare that */var/www* is on the disk labeled *website*. While the former easily
    goes wrong, the latter is mostly immune to sleepy hardware techs. One disk can
    have several labels simultaneously, if they’re different types of label. FreeBSD
    automatically derives many labels from inherent disk characteristics; the sysadmin
    can define others.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，系统管理员使用磁盘上的*标签*来通过其他方式引用磁盘，而不是依赖于物理连接。标签标识了一个geom实例。与其告诉FreeBSD*/var/www*在连接到SATA端口2的磁盘上，不如声明*/var/www*在标签为*website*的磁盘上。前者容易出错，而后者则大多能避免因为硬件技术人员的疏忽。一个磁盘可以同时有多个标签，只要它们是不同类型的标签。FreeBSD会自动根据磁盘的固有特征推导出许多标签；系统管理员也可以定义其他标签。
- en: Most label types have a dedicated device node directory. Each GPT partition
    has a *globally unique identifier (GUID)*, and the autocreated labels for those
    partitions live in */dev/gptid*. Disks get unique disk IDs based on their serial
    number, which gets entries in */dev/diskid*. Manually created GPT labels appear
    in */dev/gpt*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标签类型都有一个专门的设备节点目录。每个GPT分区都有一个*全局唯一标识符(GUID)*，这些分区的自动创建标签存储在*/dev/gptid*中。磁盘根据其序列号获得唯一的磁盘ID，这些ID会出现在*/dev/diskid*中。手动创建的GPT标签出现在*/dev/gpt*中。
- en: Use these labels as you would any other device name. If you label the disk ada5
    as *stuff1*, you can partition the disk stuff into *stuff1p1* and *stuff1p2*,
    use those partitions in configuration files, and more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像使用其他设备名称一样使用这些标签。如果你将磁盘ada5标记为*stuff1*，你可以将磁盘stuff分区为*stuff1p1*和*stuff1p2*，并在配置文件中使用这些分区，等等。
- en: Not all labels come from GEOM. ZFS uses its own internal labeling method for
    filesystems and pools. You can also add labels to UFS filesystems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有标签都来自GEOM。ZFS使用自己内部的标签方法来标识文件系统和池。你还可以向UFS文件系统添加标签。
- en: Don’t let swapped SATA cables ruin your weekend. Label everything.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让交换的SATA电缆毁了你的周末。给所有东西加上标签。
- en: '***Viewing Labels***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看标签***'
- en: View labels with glabel(8), a shortcut for `geom label`. Here are parts of a
    label from a small virtual machine. The labels on real hardware can quickly become
    very complex.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用glabel(8)，即`geom label`的快捷方式来查看标签。以下是来自一个小型虚拟机的标签部分。实际硬件上的标签可能会变得非常复杂。
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This host has a single geom ➊ on the disk partition */dev/ada0p1*. It provides
    an appallingly long label based on the GPT partition ID ➋. We’ll see a bunch of
    information on the underlying disk, such as the number of sectors on the disk,
    the sector size, and other information you might see in `geom` `disk list` output.
    This information comes from the partition, however. The physical drive information
    is passed up from the underlying disk.^([1](footnote.xhtml#ch10fn1))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主机在磁盘分区*/dev/ada0p1*上有一个单一的GEOM ➊。它提供了一个基于GPT分区ID ➋的非常长的标签。我们将在底层磁盘上看到一些信息，例如磁盘上的扇区数量、扇区大小以及你可能在`geom`
    `disk list`输出中看到的其他信息。然而，这些信息来自于分区。物理驱动器信息是从底层磁盘传递上来的。^([1](footnote.xhtml#ch10fn1))
- en: This drive has a single consumer ➌, the actual underlying partition. We’re at
    the very bottom of this simple GEOM stack, right up against the disk, so it’s
    consuming itself. If you add cryptographic layers or software RAID, you’ll see
    what other device this geom consumes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个驱动器有一个单一的消费者 ➌，即实际的底层分区。我们处于这个简单GEOM堆栈的最底层，紧贴磁盘，因此它正在自我消费。如果你添加了加密层或软件RAID，你将看到该GEOM消费的其他设备。
- en: '***Sample Labels***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例标签***'
- en: Here are some examples of the kinds of labels you’ll see on most FreeBSD systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在大多数FreeBSD系统上看到的标签类型的示例。
- en: '**Disk ID Labels**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**磁盘ID标签**'
- en: A physical machine offers labels not available on virtual machines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 物理机器提供虚拟机无法获得的标签。
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The drive ada3 provides a geom called *diskid/DISK-WD-WCAW36477141*. The *diskid*
    geom is named after the hard drive’s serial number, based on information provided
    by the drive. You can remove the disk from this machine and attach it to a completely
    different FreeBSD host, and that new host will generate the exact same disk ID
    label. Using the diskid label in your configurations guarantees that FreeBSD will
    use the exact disk you intend. Here’s how you might list partition 3 on this disk
    in */etc/fstab*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器ada3提供了一个名为*diskid/DISK-WD-WCAW36477141*的GEOM。*diskid* GEOM以硬盘的序列号命名，基于硬盘提供的信息。你可以将磁盘从这台机器上取下，并将其连接到完全不同的FreeBSD主机上，新的主机将生成完全相同的磁盘ID标签。在配置中使用diskid标签可以确保FreeBSD使用你打算使用的确切磁盘。以下是在*/etc/fstab*中列出该磁盘分区3的方式：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This disk could attach to the host as */dev/ada3* or */dev/ada300*, and FreeBSD
    would still mount this partition as */usr/local*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘可以作为*/dev/ada3*或*/dev/ada300*连接到主机，FreeBSD仍然会将该分区挂载为*/usr/local*。
- en: The problem with disk ID labels is that they’re painful to read and more painful
    to type. I’m describing them because they can appear by default, but I’d encourage
    you to choose a different label. Eliminate these labels from your host by setting
    the tunable `kern.geom.label.disk_ident.enable` to 0 in */boot/loader.conf*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘ID标签的问题在于它们难以阅读，也更难输入。我之所以提到它们，是因为它们可能是默认出现的，但我鼓励你选择其他标签。通过在*/boot/loader.conf*中将可调项`kern.geom.label.disk_ident.enable`设置为0，来从你的主机中移除这些标签。
- en: '**GPT GUID Labels**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GPT GUID 标签**'
- en: 'Every GPT partition includes a GUID. FreeBSD can treat the GUID as a label.
    Here, we see a GPT ID label for partition 1 on the disk attached as ada0:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPT分区都包括一个GUID。FreeBSD可以将GUID视为标签。在这里，我们看到了附加为ada0的磁盘上分区1的GPT ID标签：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This disk partition is conveniently available as */dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594*
    ➊. Much like disk serial numbers, GUIDs are integral to the partition. You can
    move the disk to another host and still get the same GPT ID. By using the GPT
    ID label in configurations like */etc/fstab*, you guarantee that FreeBSD uses
    this particular partition, rather than partition 1, on whatever device happens
    to get assigned ada0 at system boot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘分区可以方便地表示为*/dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594* ➊。类似于磁盘序列号，GUID是分区的一部分。你可以将磁盘移动到另一台主机，仍然能够获得相同的GPT
    ID。通过在像*/etc/fstab*这样的配置文件中使用GPT ID标签，可以确保FreeBSD在系统启动时使用这个特定的分区，而不是分区1，无论哪个设备被分配到ada0。
- en: Using a GPT ID label makes sense when you have many automatically configured
    disks, such as large storage arrays. On smaller systems, though, the 128-bit GUID
    is annoyingly long. If you decide not to use these labels, remove them from your
    system by setting the tunable `kern.geom.label.gptid.enable` to 0 in */boot/loader.conf*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: For most hosts, I recommend assigning GPT labels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**GPT Labels**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'GPT partitions let you manually assign a label name within the partition table.
    I highly recommend doing so whenever possible. Here’s a partition that I assigned
    a name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I’ve assigned the label *swap2* ➊ to partition 1 on disk ada2\. This label
    is physically stored on the disk partition. I can use this label in my configurations
    just like any other device name. Using manually assigned labels is much more manageable
    for small systems, as this */etc/fstab* shows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An assigned label is much more human-friendly than a long serial number or GUID.
    If you have the choice, I encourage you to label GPT partitions. We’ll assign
    labels when we partition disks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**GEOM Labels**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In addition to spilling the standard labels on your system, the glabel(8) command
    lets you configure GEOM labels. A GEOM label is specific to FreeBSD’s GEOM infrastructure
    and appears in */dev/label*. Use GEOM labels with the `glabel label` command.
    Here, I apply the GEOM label *root* to the GPT partition da0p1:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There’s also a `glabel create` command, but those labels disappear at system
    reboot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**GEOM Withering**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A provider can have multiple labels. One partition might have a label based
    on the disk ID of the underlying storage device (*/dev/diskid/somethinglong*),
    a GPT ID (*/dev/gptid/somethingevenlonger*), a manually assigned label (*/dev/gpt/swap0*),
    and a device node based on the underlying device’s attachment point (*/dev/ada0p1*).
    While any number of processes can look at a disk device simultaneously, many disk
    operations—such as mounting a partition—require exclusive, dedicated control of
    the device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: To prevent accessing geoms by multiple names, when you access a device by one
    label, the kernel removes the unused labels. This is called *withering*. If I,
    say, mount a swap partition using the GPT label */dev/gpt/swap0*, all the other
    labels for that partition disappear from */dev*. Anyone who tries to access the
    corresponding */dev/gptid* partition will find that the device node is missing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Once all exclusive locks on a device are removed, the kernel de-withers the
    other device labels. If I deactivate that swap space, the GPT ID and raw device
    name reappear.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**The gpart(8) Command**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like many operating systems, FreeBSD once had specific partitioning tools for
    each partitioning scheme. Today, all disk partitioning functions, for MBR and
    GPT alike, are included in the gpart(8) program. Embedded devices with specialized
    storage might occasionally need older tools like fdisk(8) and bsdlabel(8), but
    gpart(8) works perfectly well for servers and desktops.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This common tool means you perform many functions the same way no matter which
    partitioning scheme you’re using. For example, no matter whether you’re working
    with the MBR or GPT scheme, you’ll need a way to indicate a particular partition.
    Both schemes let you indicate a partition with `-i` and the partition number.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and deleting partitions are great examples of common functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing Partitions***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use `gpart show` to see a brief summary of all GPT and MBR partitions on a
    geom. Give the name of a geom as an argument to see only the partitions on that
    geom. The output from `gpart show` doesn’t look that different from fdisk(8) and
    other more traditional disk management tools. Here, I look at a storage device
    by its traditional device node, but I could use diskid or gptid or any other label:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first column gives the first block in the partition; the second, the partition
    size in blocks. The third gives the partition number, while the fourth gives the
    partition type. (We’ll discuss partition types later this chapter: for the moment,
    just go with the flow.) At the end, we have the disk size.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Our first partition begins on the disk’s sector number 40 and fills almost two
    billion sectors ➊. The third field shows that this isn’t a partition on the disk,
    but rather an entry for the entire disk. The fourth field gives the partitioning
    scheme used. This is a GPT disk. The entire disk is about 932GB.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The second entry also starts on sector 40, and it fills 1,024 sectors ➋. This
    is partition 1, and it’s of type *freebsd-boot*. If we want to boot off this disk,
    we need a boot loader on this partition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The third entry begins on sector 1,064 and fills 984 sectors ➌. Why 1,064? The
    first partition started on sector 40 and filled 1,024 sectors, so the first (1,024
    + 40) 1,064 sectors are filled with other partitions. But this partition doesn’t
    have a partition number, and its type is `- free -`. This partition is aligned
    for disks with 4K sectors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The fourth entry is swap space, according to the partition type ➍. It begins
    on sector 2,048, is 4,194,304 sectors long, and is partition 2\. You’ll often
    see swap space near the beginning of a disk, a hangover from the days when partition
    placement on the disk impacted performance. If you’re using a virtual machine,
    however, putting the swap near the beginning of the disk leaves you room to expand
    a partition at the end of the disk.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The fifth entry is a FreeBSD ZFS filesystem, starting in sector 4,196,352 and
    going on for about 1.9 billion sectors ➎. This freebsd-zfs partition has our data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The very end of the disk has 1,416 free sectors ➏. There’s not quite enough
    space to add space to the partition while still aligning the partition to the
    1MB boundaries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: A MBR disk looks much like a GPT disk.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Views***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add command line flags to modify the output of `gpart show`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: You can assemble each partition’s device node from the underlying device name
    and the partition number. If you want to see the device node rather than the partition
    number, add the `-p` flag.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过底层设备名称和分区编号来组装每个分区的设备节点。如果你想看到设备节点而不是分区编号，可以添加`-p`标志。
- en: To replace the partition type with the partition label, use `-l`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要用分区标签替代分区类型，请使用`-l`。
- en: 'Here, I show both the device node and the labels on this disk:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了这个磁盘的设备节点和标签：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The partition number now contains complete device names, like *ada0p3*. Rather
    than the GPT partition type, you get the label applied to the GPT partition, such
    as *swap0* and *zfs0*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分区编号包含完整的设备名称，比如*ada0p3*。你不再看到GPT分区类型，而是看到应用于GPT分区的标签，例如*swap0*和*zfs0*。
- en: To see the human-hostile GPT partition type rather than the name FreeBSD presents,
    use `-r`. I mostly use this when examining disks from other operating systems.
    It’s possible that FreeBSD will label multiple partition types as being type *ntfs*;
    while that’s good enough for most uses, if I’m doing digital forensics, the precise
    partitioning scheme might be extremely important.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看人类不友好的GPT分区类型，而不是FreeBSD显示的名称，请使用`-r`。我通常在检查其他操作系统的磁盘时使用它。FreeBSD可能会将多个分区类型标记为*ntfs*；虽然这对大多数用途来说足够，但如果我在做数字取证，精确的分区方案可能非常重要。
- en: To see a more detailed description of your GPT partitions, use `gpart list`.
    This creates output much like `glabel list` or other GEOM class commands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看GPT分区的更详细描述，请使用`gpart list`。这会产生类似于`glabel list`或其他GEOM类命令的输出。
- en: '***Removing Partitions***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除分区***'
- en: Maybe you screw up when creating your partitions and need to remove one. No,
    you haven’t created partitions yet, in either MBR or GPT, but the process you
    follow is the same either way. Delete partitions by number.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在创建分区时出错，需要删除其中一个。不是的，你还没有在MBR或GPT中创建分区，但你遵循的过程无论哪种方式都是一样的。通过编号删除分区。
- en: Take a look at the partition table in the previous section. We have partitions
    for boot, swap, and ZFS. Maybe you don’t want swap space on your boot drive. Remove
    that partition with the gpart delete command. Use the `-i` flag and the number
    of the partition you want to remove. The gpart show command said the swap space
    was partition 2\. Let’s remove it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上一节中的分区表。我们有用于启动、交换和ZFS的分区。也许你不希望在启动磁盘上有交换空间。使用gpart delete命令删除该分区。使用`-i`标志和你想删除的分区编号。gpart
    show命令显示交换空间是分区2。让我们删除它。
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now resize your ZFS partition to use that space. How you resize a partition
    varies with the partitioning scheme.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以调整ZFS分区的大小以使用这些空间。调整分区大小的方式取决于分区方案。
- en: '**Scheming Disks**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设计磁盘**'
- en: No, not the sort of scheming where the disk deliberately lies to you. We’re
    talking about the disk’s partitioning scheme. Destruction is easier than creation,
    in both meatspace and with storage. Before you can partition a disk, you need
    to assign it a partitioning scheme.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是那种故意欺骗你的磁盘。我们谈论的是磁盘的分区方案。在现实世界和存储中，摧毁比创建更容易。在你能够分区磁盘之前，你需要为它分配一个分区方案。
- en: '***Removing the Disk Partitioning Scheme***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除磁盘分区方案***'
- en: You could go through and painstakingly delete every partition on the disk and
    then obliterate the partitioning scheme. That’s a bunch of work, though. It’s
    much simpler to just trash the entire disk partition table.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以逐个删除磁盘上的每个分区，然后摧毁分区方案。然而，这样做工作量很大。更简单的方法是直接丢弃整个磁盘分区表。
- en: You can’t erase a disk with mounted partitions. Unmount those partitions first,
    and remove them from any ZFS pools. Once the disk is truly unused, erase any existing
    partitioning table with `gpart destroy`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能擦除带有已挂载分区的磁盘。首先卸载这些分区，并从任何ZFS池中删除它们。一旦磁盘真正未使用，使用`gpart destroy`擦除任何现有的分区表。
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the command returns immediately, the disk had no partitions. It might have
    had a partition scheme, but no partitions. If you get a “device busy” error, either
    the disk is still in use or the disk has partitions. You could methodically delete
    all existing partitions with `gpart delete` and then destroy the partitioning
    scheme, but it’s easier to burn the existing scheme to the ground by adding `-F`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令立即返回，说明磁盘没有分区。它可能有一个分区方案，但没有分区。如果你遇到“设备繁忙”错误，要么磁盘仍在使用中，要么磁盘有分区。你可以通过`gpart
    delete`逐个删除所有现有分区，然后销毁分区方案，但通过添加`-F`更容易彻底删除现有方案。
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This forcibly erases all partitions and the partitioning scheme. Running `gpart
    show da3` will show that there’s no partition table. You can now create new disk
    partitions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '***Assigning the Partitioning Scheme***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before you can create disk partitions, you need to mark the disk with the type
    of partitioning scheme you’ll be using. Use `gpart create` with the `-s` flag
    and the scheme, such as `gpt` or `mbr`. Here, I mark a disk as using the GPT scheme:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Use `gpart show` to verify that the disk now has a GPT partition table. You
    can now add GPT partitions or recreate the partition table with MBR and add those
    partitions. But we’ll start by diving deep into GPT.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**The GPT Partitioning Scheme**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GUID Partition Table, or GPT, is the modern standard for hard drive partitioning.
    This is the recommended standard for new installations. Always use the GPT partitioning
    scheme unless you have a deeply compelling reason not to, such as a lack of hardware
    support.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: GPT supports disks up to 9.4ZB. One zettabyte is one billion terabytes. While
    our technology will eventually outgrow 9.4ZB, I expect GPT will last the rest
    of my career.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD’s GPT implementation currently supports 128 partitions. Each partition
    gets assigned a GUID, which is a 128-bit number displayed as 32 hexadecimal characters.
    While GUIDs aren’t guaranteed to be truly unique across all of civilization, they’re
    certainly going to be unique within your organization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Most modern operating systems support GPT and its predecessor, the master boot
    record (MBR). MBR-based systems put partition records in the first sector on the
    disk. If a host supports only MBR, but the first sector of a disk contains something
    that isn’t an MBR, the system gets confused and might refuse to boot. The GPT
    scheme puts a *protective master boot record (PMBR)* in the first sector of every
    disk. The PMBR indicates that the disk contains one MBR partition of type GPT.
    The second sector contains the actual GUID Partition Table. GPT also puts a backup
    copy of the partition table on the last sector of the disk so you can more easily
    recover from damage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: GPT requires allocating a partition for bootstrap code. The PMBR boot code searches
    the disk for a FreeBSD boot partition. This boot partition must be larger than
    the boot code, smaller than 545KB, and reserved for the FreeBSD boot loader. FreeBSD
    has two GPT boot loaders, gptboot(8) and gptzfsboot(8). You must install one of
    these on the boot partition.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Use gptboot(8) to start UFS-based systems. At system boot, gptboot searches
    for a FreeBSD partition marked with the *bootme* or *bootonce* attributes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Use gptzfsboot(8) on systems running ZFS.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Use gpart(8) and its many subcommands to view, create, edit, and destroy GPT
    partitions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '***GPT Device Nodes***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each disk partition has a device node. GPT partition device nodes are an extension
    of the geom they’re built on, indicated by the letter *p* and the partition number.
    If you’ve created GPT partitions directly on the disk ada0, the first partition
    will be */dev/ada0p1*, the second */dev/ada0p2*, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Many systems put their partitions on an upper-layer geom. One of my systems
    uses SATA RAID and offers the disk as */dev/raid/r0*. The partitions on this drive
    are */dev/raid/r0p1*, */dev/raid/r0p2*, and so on. You might also put partitions
    on a device by its GUID or disk ID, giving you partitions like */dev/diskid/DISK-WD-WCAW36477062p1*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '***GPT Partition Types***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you create a GPT partition, you must mark it with a *partition type*. The
    type indicates the partition’s intended use. FreeBSD makes decisions based on
    the partition types, so assign them correctly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, a partition type is another 128-bit GUID. FreeBSD marks GUIDs
    used as partition types with a leading exclamation point, such as `!516e7cb5-6ecf-11d6-8ff8-00022d09712b`.
    These partition types are common across all operating system, but most OSs provide
    human-friendly names for these human-hostile GUIDs. This book uses the human-friendly
    names; check gpart(8) for the human-hostile ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common partition types you’ll see on a FreeBSD system include the
    following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd-boot** FreeBSD boot loader'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd-ufs** FreeBSD UFS filesystem'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd-zfs** FreeBSD ZFS filesystem'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd-swap** FreeBSD swap partition'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**efi** An EFI system partition, used to boot from EFI'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: You might also see these GPT partition types. Don’t use them in modern FreeBSD,
    but know that their presence might help you identify just what that weird disk
    is and how to crack it open.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd** A GPT partition that’s divided into bsdlabel(8) partitions'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**freebsd-vinum** A partition controlled by gvinum(8)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**mbr** A partition subdivided into MBR partitions'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**ntfs** A partition containing a Microsoft NTFS filesystem'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**fat16, fat32** Partitions containing FAT'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For a complete listing of recognized partition types, see gpart(8).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating GPT Partitions***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Partitioning disks is easy: figure out which partitions you want, create them,
    and go. The tricky part is living with your partitioning. Before creating partitions,
    decide what you’re going to do with this disk. How much space do you have? How
    do you want to divide it? Before you start creating partitions, write down exactly
    what you want to achieve.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’m manually partitioning a 1TB disk for a UFS FreeBSD install. It’ll
    need a 512KB boot partition (type *freebsd-boot*) and 8GB for swap (type *freebsd-swap*).
    The other partitions will be type *freebsd-ufs*: 5GB for root, 5GB for */tmp*,
    100GB for */var*, and the rest for */usr*. I’ll label each partition for its intended
    role.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Create partitions with gpart(8). Use the `-t` flag to specify the partition
    type, `-s` to give the size, and `-l` to assign a GPT label to the new partition.
    I’ll start with the boot partition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Use `gpart show` to check your work. Add the `-l` flag to see the GPT label.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This disk has one partition, a 512K partition labeled *boot*. The command succeeded.
    Now add the swap space.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command is much like the one to add the boot partition: we give the partition
    type, size, and label.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Hang on, though—what’s this `-a 1m` thing? The `-a` flag lets you set a partition
    alignment, enabling you to set where partitions can begin and end relative to
    the beginning of the disk. Remember back at the beginning of this chapter when
    I discussed that misaligning a filesystem with the physical sectors on a 4K disk
    could cause problems? The `-a 1m` tells gpart to create partition on an even multiple
    of 1MB from the beginning of the disk. You’ll have some empty space between partitions
    1 and 2, as we saw in “[Viewing Partitions](ch10.xhtml#lev343)” on [page 215](ch10.xhtml#page_215)
    in this chapter, but that’s okay. That gives you room to change that partition
    to support UEFI if necessary (see “[Unified Extensible Firmware Interface and
    GPT](ch10.xhtml#lev356)” on [page 222](ch10.xhtml#page_222) later this chapter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Retain that 1MB alignment as you create the 5GB root and */tmp* partitions and
    the 100GB */var* partition.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you create the last partition, don’t give a size. This tells gpart to make
    the partition as large as possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You have partitioned the disk, and it’s ready for your install.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '***Resizing GPT Partitions***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On second thought, perhaps having a huge */usr* partition isn’t wise. A */usr*
    partition of 100GB or so would have all the room you might desire for operating
    system files, while leaving several hundred gigabytes for an isolated */home*
    partition. I trust most of my users, but a few^([2](footnote.xhtml#ch10fn2)) are
    just the sort to dump */dev/random* into a file until they absorb all available
    space. Here, I’ll resize */usr* to create space for */home*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Use `gpart resize` to change the size of a partition. You must know the target
    partition’s partition number. Running `gpart show da3` tells us that */usr* is
    partition 6\. Use the `-i` flag and the partition number to resize a partition.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run `gpart show` to see the new disk size.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This disk has 714GB free at the end. We can now create a spacious */home* for
    all our troublesome users.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Each partition is assigned specific sectors on the disk. You can’t increase
    the size of a partition if there’s no free space on either side of the partition.
    While this sample disk has a bunch of free space after partition 6, you can’t
    use it to increase the size of partitions 1 through 5\. You must delete and recreate
    partitions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Changing the size of a partition doesn’t change the size of the filesystem on
    that partition. Shrinking a partition with a filesystem will chop off part of
    the filesystem. Increasing the partition size won’t expand the filesystem. Both
    UFS and ZFS have tools to handle increased partition sizes, but you must handle
    that as a separate process.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '***Changing Labels and Types***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can modify a GPT partition’s type or GPT label with the `gpart modify`
    command. Give the partition number with `-i`. Use `-l` to give the new label.
    Here, I change the GPT label on partition 2 of disk vtbd0:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, change the type of partition with `-t`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The disk’s GPT table now declares that partition 2 is labeled `rootfs` and is
    of type *freebsd-zfs*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '***Booting on Legacy Hardware***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Older hardware expects to see a master boot record at the start of the disk
    and won’t recognize a GPT partition table. FreeBSD uses a protective MBR (PMBR)
    to give legacy hardware a recognizable partition table and help that hardware
    boot a GPT-partitioned disk. A bootable disk formatted with GPT needs both a protective
    MBR and a GPT boot loader.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Install a PMBR with the `gpart bootcode` command and the `-b` flag. FreeBSD
    provides a PMBR as */boot/pmbr*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This disk will no longer confuse hosts that look for an MBR.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: You also need a boot loader. UFS hosts need the *gptboot* boot loader, while
    ZFS hosts need *gptzfsboot*. For convenience, FreeBSD provides a copy of each
    in the */boot* directory. These copies are not the on-disk boot loader, only the
    version of the bootloaders needed for that version of FreeBSD. Install the selected
    boot loader with the `-p` flag to `gpart bootcode`. Use the `-i` option to tell
    gpart(8) which partition to copy the boot loader to. The sample disk we used in
    the last section had partition 1 as type *freebsd-boot*, so we’ll use that.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can combine `-p` and `-b` into a single command.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '***Unified Extensible Firmware Interface and GPT***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Unified Extensible Firmware Interface (UEFI)* is a newer standard for booting
    amd64 hardware without using BIOS emulation. FreeBSD 10 and later have early support
    for UEFI booting to UFS, while FreeBSD 11 can boot ZFS off of UEFI.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: UEFI uses a partition of type *efi*, which must be 800KB or larger. Create an
    efi partition on a new disk with `gpart create`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FreeBSD provides an efi partition as */boot/boot1.efifat*. Copy that to the
    new boot partition with dd(1).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Partition the rest of the disk as you desire.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: An efi partition is actually a FAT filesystem with a very specific directory
    hierarchy. Feel free to mount the file *boot1.efifat* and explore it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '***Expanding GPT Disks***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen how to expand a partition, but what about a disk? Expanding disks
    often happens with virtual hosts. Expand a virtual disk, and gpart(8) will complain
    that the disk’s GPT is invalid. GPT and GEOM store information in the first and
    last sectors of the disk. Expanding a virtual disk means adding sectors. The new
    last sector will be empty. Create a new metadata block for the last sector with
    `gpart recover`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can now create or expand partitions on the expanded virtual disk.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a handle on GPT partitions, let’s look at MBR and see why
    GPT seemed like such an improvement.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**The MBR Partitioning Scheme**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old hardware, or new but small hardware, might need master boot record partitioning
    on its disks. Intel-style hardware has used MBR partitions for decades, and millions
    of devices running a plethora of operating systems use it. The MBR scheme works
    only on disks of 2TB or smaller. Larger disks must use GPT partitioning.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is the Master Boot Record?***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *master boot record (MBR)* is a file that takes up the first 512 bytes of
    a traditional disk, also known as *Sector 0*. The MBR contains partition information
    and a boot loader to allow the BIOS to find the operating system. The term *MBR*
    might refer to the actual first sector on the disk or the partition scheme used
    by that format.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: A master boot record describes four *primary partitions*, called *slices* in
    the BSD community. Each slice description includes the disk sectors included in
    the partition and the type of filesystem expected on that slice. If a disk has
    only one slice on it, the MBR still lists four slices, but three of those slices
    have no sectors assigned to them. While the MBR format supports a linked list
    of up to 20 extended partitions, FreeBSD doesn’t need them thanks to BSD labels.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: One of the four primary slices is considered active. When the system powers
    on, the bootstrap code looks for the active slice and tries to boot it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The MBR sector also contains bootstrap code. You don’t need to allocate space
    specifically for a boot loader. In FreeBSD, the bootstrap code finds and executes
    the kernel. FreeBSD includes two different boot loaders, *mbr* and *boot0*. The
    mbr loader is for a host with a single operating system. If you have multiple
    operating systems installed on your hardware, use the boot0 loader—or, better
    still, dedicate your host to FreeBSD and virtualize the other operating systems.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The main function of a slice is to contain a bsdlabel(8) partition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '***BSD Labels***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BSD existed before either the MBR or the IBM PC. BSD used its own disk partition
    format, called a *disklabel*. Now that labeling disks is much more common, disklabels
    are also called *BSD labels* or *bsdlabels*. (If you want to start a spirited
    discussion, ask a room of FreeBSD developers which is more correct.) BSD systems
    had several partitions including at least */* (root), */usr*, */var*, */tmp*,
    and swap space, plus separate partitions for whatever actual work the system did.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: When BSD was ported to the i386 platform, they could have switched disks to
    using MBR partitions. With extended MBR partitions, one disk could have had up
    to 24 partitions. Disklabel partitions were embedded throughout the kernel, however,
    often in icky places that nobody dared touch. The porting group decided to treat
    an MBR slice as a BSD disk and to partition each slice with a BSD disklabel. Sysadmins
    needed to create MBR partitions and then nest disklabel partitions inside those
    MBR partitions.^([3](footnote.xhtml#ch10fn3))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: This worked but also made the word *partition* ambiguous. Does *partition* mean
    an MBR partition or a disklabel partition? FreeBSD dusted off the word *slices*
    for MBR partitions. Each MBR slice will have its own disklabel, listing the BSD
    partitions contained within the slice. If you come from a Linux or Microsoft Windows
    background, the MBR partitions you’re familiar with are called *slices* over here.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: You can’t label slices or disklabel partitions. These formats have no space
    for labels. Instead, label the ZFS or UFS filesystem on the partition.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to skip slicing a disk, instead installing a disklabel directly
    on the hard drive. Some hardware refused to boot from such disks, so they’re called
    *dangerously dedicated*. With the advent of GPT, dangerously dedicated disks aren’t
    really used any more.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '***MBR Device Nodes***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every disk, slice, and partition has a device node. The slice device node is
    an extension of the underlying disk, and the partition device node is an extension
    of the device’s node. Here are the device nodes on disk ada0 of an MBR-based system:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first subdivision of the disk is the slice. Device nodes indicate a slice
    with the letter *s* and a number from 1 to 4\. The first slice is s1, the second
    is s2, and so on. Unused MBR partitions don’t get device nodes. Here, */dev/ada0s1*
    is slice 1 on the disk.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The second layer of subdivision is the disklabel partition inside the slice.
    Each partition has a unique device node name created by adding a letter to the
    slice’s device node. Here, we have four disklabel partitions, */dev/ada0s1a* through
    */dev/ada0s1e*. Traditionally, the node ending in *a* (*/dev/ada0s1a*) is the
    root partition, while the node ending in *b* (*/dev/ada0s1b*) is swap space.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Note that the list of device nodes doesn’t use the letter *c*. The c partition
    represents the entire slice. These days, you run disk partitioning tools on the
    slice entry rather than the disklabel for the slice.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Assign partitions d through h any way you like. A default disklabel can have
    up to seven usable partitions. With up to four slices on each drive, you can have
    up to 28 partitions on a drive. A disklabel can support up to 20 partitions, but
    you must indicate you want extra partitions when first creating the label.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '***MBR and Disklabel Alignment***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Slices have their own disk sector and filesystem block alignment issues. Traditionally,
    MBR partitions end on a cylinder boundary. Cylinder boundaries don’t mean anything
    on modern hardware, but even newer drives provide them as a comforting lie for
    older or less capable hardware. If you create MBR partitions that don’t end on
    a cylinder boundary, and you put that disk in a machine that requires respecting
    cylinder boundaries, the machine will have some sort of nervous breakdown. A disk
    you slice today could theoretically find its way into an older system. FreeBSD
    therefore arranges slices so that they end on cylinder boundaries. Cylinder boundaries
    not only can but probably do conflict with 4K disk sector sizes. If nothing else,
    the MBR itself takes up the first cylinder, or sixty-three 512-byte sectors!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately you rarely write to slice tables, and the performance of writing
    slice tables is rarely an issue. If you align your disklabel partitions within
    a slice to 1MB boundaries, you’ll lose a few sectors between the slice partition
    table and the disklabel partition, but you’ll have proper performance.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'So: align disklabel partitions. Don’t align slices.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Slices***'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use gpart(8) to manage MBR slices. To create a slice, you need a partition type
    and a size. FreeBSD slices use type *freebsd*. If you don’t specify a size, gpart(8)
    uses all available space. On an empty disk, this dedicates the whole disk to a
    single slice.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I erase the existing partitioning, tell the disk to use the MBR scheme,
    and create a single FreeBSD slice:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run `gpart show` and you’ll see that this disk now has a single slice. Add the
    `-p` flag to see the slice’s device node.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our slice ada3s1 is now ready for disklabel partitions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'To create multiple slices, specify a size with `-s`. A common configuration
    for small embedded systems is to put three slices on a disk. Two smaller slices
    contain different versions of the operating system, while the third contains any
    data. Here, I divide this 1TB disk into two 150GB slices and give the rest to
    a third slice:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***Removing Slices***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use `gpart delete` to remove unwanted slices. Give the slice number with `-i`.
    Here, I remove the third, larger slice from our multislice disk created in the
    last section:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***Activating Slices***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The active slice is the one that the BIOS tries to boot. Set the active slice
    with the `-a` active flag. Use `-i` to give the number of the active slice.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Change which slice gets booted by setting a different active slice.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The boot disk also needs a boot loader. While the MBR boot loader is different
    from the GPT or UEFI boot loaders, it uses the same gpart(8) `-b` flag. FreeBSD
    provides a copy of the MBR boot loader as */boot/mbr*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Slice 1 on disk ada3 is now bootable. Now that you’ve sliced your disk, you
    can create BSD labels inside the slices.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**BSD Labels**'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating BSD label (or disklabel) partitions inside a slice is much like creating
    slices or GPT partitions. You must tell the storage device the scheme to be used,
    create and remove partitions until you’re satisfied with them, and install a boot
    loader.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a BSD Label***'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Where GPT and MBR specifically provide space for partition tables, you must
    create a BSD label and write it to the beginning of the slice. As with any scheme,
    use `-s` and the name of the scheme. Install this scheme on the slice, not on
    the disk.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to create a BSD label on the slice ada3s1\. Use the BSD scheme.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a default disklabel, with room for 8 disklabel partitions. You can increase
    the number of partitions, up to 20, by using the `-n` flag. Here, I create a whole
    bunch of partitions on ada3s3, the large partition.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are no actual disklabel partitions on this slice; there’s merely a label
    that can contain disklabel partitions. Now that the label exists, you can create
    those partitions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating BSD Label Partitions***'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before blindly entering partitioning commands, plan how to partition the disk.
    Figuring things out on paper beforehand is much easier than figuring them out
    at the command line. I’m going to partition the first 150GB slice on this disk
    for UFS filesystems. This slice will get 5GB partitions for */* (root), swap,
    and */tmp*. The rest will go to */usr*. Why no */var*? I’ll dedicate the big slice,
    ada3s3, to */var*. I don’t need to add a boot partition because MBR disks don’t
    need one.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: To create a disklabel partition, you must specify the type with `-t` and the
    size with `-s`—exactly as you would for GPT partitions. FreeBSD UFS filesystems
    are of type *freebsd-ufs*. Let’s start with the root partition.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To view this partition, you must give `gpart show` the slice device, not the
    disk device. Using the disk device displays the slices.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The third line of output shows our 5GB partition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: At the very beginning of this slice, we have 1,985 free blocks, or 993KB. I
    requested that the partition be aligned to 1MB boundaries, so gpart wasted a bit
    of space to meet that request. I’ll happily lose that 993KB, rather than halve
    the system’s performance.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Now create the swap partition of type *freebsd-swap*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The 5GB */tmp* comes next. Then, I dump the rest of the space into a partition
    for */usr* by omitting the size.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `gpart show` reveals our disklabel partitions have wasted 63 blocks, or 32KB,
    at the end of the disk. Watch me not care.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: These partitions are now ready to receive filesystems. We discuss UFS in [Chapter
    11](ch11.xhtml#ch11).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '***Assigning Specific Partition Letters***'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On a traditional BSD label, the *a* partition is for the root filesystem, while
    *b* is for swap. The *c* partition represents the entire slice. This isn’t mandatory,
    but I recommend not using any of these letters for any other purpose.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? I once added a hard drive to a server so that we had
    more space for a database. We moved the database software to partition *a* and
    the actual data to partition *b*.^([4](footnote.xhtml#ch10fn4)) When I went on
    vacation a few months later, the system ran short on virtual memory. I got a call
    from a sysadmin who had found and activated the unconfigured swap space on the
    new drive—but now the database data was missing. Yes, the company lost several
    customers and many thousands of dollars of revenue, which is sad—but more importantly,
    it ruined one day of my vacation and cast a shadow over the rest. This was unacceptable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Don’t bother fighting these traditions, especially on a decreasingly common
    disk format. Don’t use the letters *a*, *b*, or *c* for partitions other than
    those decreed by the Berkeley elders.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The gpart program is designed to work with partition numbers, not letters. When
    you’re creating disklabels, however, `gpart add` maps index numbers onto letters.
    Partition 1 is *a*, partition 2 is *b*, and so on. By specifying a partition index
    when you create the partition, you assign the letter to the partition.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify a partition number, `gpart add` assigns partition letters
    starting with *a*. You might assign your first partition number 18, but if you
    don’t specify a number for the next partition, it’ll wind up getting partition
    *a*. To avoid using *a*, *b*, or *c*, use a number for every partition you create.
    You can use letters only up to the number of disklabel slots the partition has.
    A standard disklabel can use only letters *a* through *h*, while a 20-partition
    label can use *a* through *t*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: On my three-slice system, I want to put */var* on ada3s3\. I want to use a letter
    other than *a*, *b*, or *c*, so I randomly pick index 18\. It’s almost exactly
    the same as the partition for */usr*, but we’re adding it to a different slice.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To see that disklabel partition, you’ll need to run `gpart show ada3s3`. Add
    `-p` to see the device name.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What do you know? The 18th letter of our alphabet is *R*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: With partitions, we can start to look at filesystems.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
