<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_15"/><span class="big">1</span><br/>BY THE C, BY THE C, BY THE BEAUTIFUL C</h2>&#13;
<p class="aff">“By the Beautiful Sea"<br/>—Carroll and Atteridge, 1914</p>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">This chapter presents an overview of C programming written for students who have some experience programming in another language. It’s specifically written for Python programmers and uses a few Python examples for comparison purposes. However, it should be useful as an introduction to C programming for anyone with basic programming experience in any language.</p>&#13;
<p class="indent">C is a high-level programming language like other languages you might know, such as Python, Java, Ruby, or C++. It’s an imperative and a procedural programming language, which means that a C program is expressed as a sequence of statements (steps) for the computer to execute and that C programs are structured as a set of functions (procedures). Every C program must have at least one function, the <code>main</code> function, which contains the set of statements that execute when the program begins.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/>The C programming language is less abstracted from the computer’s machine language than some other languages with which you might be familiar. This means that C doesn’t have support for object-oriented programming (like Python, Java, and C++) or have a rich set of high-level programming abstractions (such as strings, lists, and dictionaries in Python). As a result, if you want to use a dictionary data structure in your C program, you need to implement it yourself, as opposed to just importing the one that is part of the programming language (as in Python).</p>&#13;
<p class="indent">C’s lack of high-level abstractions might make it seem like a less appealing programming language to use. However, being less abstracted from the underlying machine makes C easier for a programmer to see and understand the relationship between a program’s code and the computer’s execution of it. C programmers retain more control over how their programs execute on the hardware, and they can write code that runs more efficiently than equivalent code written using the higher-level abstractions provided by other programming languages. In particular, they have more control over how their programs manage memory, which can have a significant impact on performance. Thus, C remains the <em>de facto</em> language for computer systems programming where low-level control and efficiency are crucial.</p>&#13;
<p class="indent">We use C in this book because of its expressiveness of program control and its relatively straightforward translation to assembly and machine code that a computer executes. This chapter introduces programming in C, beginning with an overview of its features. <a href="ch02.xhtml#ch02">Chapter 2</a> then describes C’s features in more detail.</p>&#13;
<h3 class="h3" id="lev1_1">1.1 Getting Started Programming in C</h3>&#13;
<p class="noindent">Let’s start by looking at a “hello world" program that includes an example of calling a function from the math library. We compare the Python version of this program (first) to the C version (second). The C version might be put in a file named <code>hello.c</code> (<code>.c</code> is the suffix convention for C source code files), whereas the Python version might be in a file named <code>hello.py</code>.</p>&#13;
<pre>'''<br/>&#13;
    The Hello World Program in Python<br/>&#13;
'''<br/>&#13;
<br/>&#13;
# Python math library<br/>&#13;
from math import *<br/>&#13;
<br/>&#13;
 <br/>&#13;
# main function definition:<br/>&#13;
def main():<br/>&#13;
    # statements on their own line<br/>&#13;
    print("Hello World")<br/>&#13;
    print("sqrt(4) is %f" % (sqrt(4)))<br/>&#13;
<span epub:type="pagebreak" id="page_17"/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/*<br/>&#13;
    The Hello World Program in C<br/>&#13;
 */<br/>&#13;
<br/>&#13;
/* C math and I/O libraries */<br/>&#13;
#include &lt;math.h&gt;<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
/* main function definition: */<br/>&#13;
int main() {<br/>&#13;
    // statements end in a semicolon (;)<br/>&#13;
    printf("Hello World\n");<br/>&#13;
    printf("sqrt(4) is %f\n", sqrt(4));<br/>&#13;
<br/>&#13;
    return 0;  // main returns value 0<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="note"><strong><span class="black">Note</span></strong> Both the C version<sup><a href="ch01.xhtml#fn1_1" id="rfn1_1">1</a></sup> and Python version<sup><a href="ch01.xhtml#fn1_2" id="rfn1_2">2</a></sup> are available for download.</p>&#13;
<p class="indent">Notice that both versions of this program have similar structure and language constructs, albeit with different language syntax. In particular:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Comments:</strong></p>&#13;
<p class="ul-noindent">In Python, multiline comments begin and end with <code>'''</code>, and single-line comments begin with <code>#</code>.</p>&#13;
<p class="ul-noindent">In C, multiline comments begin with <code>/*</code> and end with <code>*/</code>, and single-line comments begin with <code>//</code>.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Importing library code:</strong></p>&#13;
<p class="ul-noindent">In Python, libraries are included (imported) using <code>import</code>.</p>&#13;
<p class="ul-noindent">In C, libraries are included (imported) using <code>#include</code>. All <code>#include</code> statements appear at the top of the program, outside of function bodies.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Blocks:</strong></p>&#13;
<p class="ul-noindent">In Python, indentation denotes a block.</p>&#13;
<p class="ul-noindent">In C, blocks (for example, function, loop, and conditional bodies) start with <code>{</code> and end with <code>}</code>.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>The main function:</strong></p>&#13;
<p class="ul-noindent">In Python, <code>def main():</code> defines the main function.</p>&#13;
<p class="ul-noindent"><span epub:type="pagebreak" id="page_18"/>In C, <code>int main(){ }</code> defines the main function. The <code>main</code> function returns a value of type <code>int</code>, which is C’s name for specifying the signed integer type (signed integers are values like –3, 0, 1234). The <code>main</code> function returns the <code>int</code> value 0 to signify running to completion without error.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Statements:</strong></p>&#13;
<p class="ul-noindent">In Python, each statement is on a separate line.</p>&#13;
<p class="ul-noindent">In C, each statement ends with a semicolon <code>;</code>. In C, statements must be within the body of some function (in <code>main</code> in this example).</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Output:</strong></p>&#13;
<p class="ul-noindent">In Python, the <code>print</code> function prints a formatted string. Values for the placeholders in the format string follow a <code>%</code> symbol in a comma-separated list of values (for example, the value of <code>sqrt(4)</code> will be printed in place of the <code>%f</code> placeholder in the format string).</p>&#13;
<p class="ul-noindent">In C, the <code>printf</code> function prints a formatted string. Values for the placeholders in the format string are additional arguments separated by commas (for example, the value of <code>sqrt(4)</code> will be printed in place of the <code>%f</code> placeholder in the format string).</p>&#13;
</div>&#13;
<p class="indent">There are a few important differences to note in the C and Python versions of this program:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Indentation:</strong></p>&#13;
<p class="ul-noindent">In C, indentation doesn’t have meaning, but it’s good programming style to indent statements based on the nested level of their containing block.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Output:</strong></p>&#13;
<p class="ul-noindent">C’s <code>printf</code> function doesn’t automatically print a newline character at the end like Python’s <code>print</code> function does. As a result, C programmers need to explicitly specify a newline character (<code>\n</code>) in the format string when a newline is desired in the output.</p>&#13;
</div>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">main</span> <strong>function:</strong></p>&#13;
<p class="ul-noindent">A C program must have a function named <code>main</code>, and its return type must be <code>int</code>. This means that the <code>main</code> function returns a signed integer type value. Python programs don’t need to name their main function <code>main</code>, but they often do by convention.</p>&#13;
<p class="ul-noindent">The C <code>main</code> function has an explicit <code>return</code> statement to return an <code>int</code> value (by convention, <code>main</code> should return <code>0</code> if the main function is successfully executed without errors).</p>&#13;
<p class="ul-noindent">A Python program needs to include an explicit call to its <code>main</code> function to run it when the program executes. In C, its <code>main</code> function is automatically called when the C program executes.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_1"><span epub:type="pagebreak" id="page_19"/>1.1.1 Compiling and Running C Programs</h4>&#13;
<p class="noindent">Python is an interpreted programming language, which means that another program, the Python interpreter, runs Python programs: the Python interpreter acts like a virtual machine on which Python programs are run. To run a Python program, the program source code (<code>hello.py</code>) is given as input to the Python interpreter program that runs it. For example (<code>$</code> is the Linux shell prompt):</p>&#13;
<pre>$ <span class="codestrong1">python hello.py</span></pre>&#13;
<p class="indent">The Python interpreter is a program that is in a form that can be run directly on the underlying system (this form is called <em>binary executable</em>) and takes as input the Python program that it runs (<a href="ch01.xhtml#ch1fig1">Figure 1-1</a>).</p>&#13;
<div class="imagec" id="ch1fig1"><img alt="image" src="../images/01fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-1: A Python program is directly executed by the Python interpreter, which is a binary executable program that is run on the underlying system (OS and hardware).</em></p>&#13;
<p class="indent">To run a C program, it must first be translated into a form that a computer system can directly execute. A C <em>compiler</em> is a program that translates C source code into a <em>binary executable</em> form that the computer hardware can directly execute. A binary executable consists of a series of 0’s and 1’s in a well-defined format that a computer can run.</p>&#13;
<p class="indent">For example, to run the C program <code>hello.c</code> on a Unix system, the C code must first be compiled by a C compiler (for example, the GNU C compiler, GCC <sup><a href="ch01.xhtml#fn1_3" id="rfn1_3">3</a></sup>) that produces a binary executable (by default named <code>a.out</code>). The binary executable version of the program can then be run directly on the system (<a href="ch01.xhtml#ch1fig2">Figure 1-2</a>):</p>&#13;
<pre>$ <span class="codestrong1">gcc hello.c</span> <br/>&#13;
$ <span class="codestrong1">./a.out</span></pre>&#13;
<p class="indent">(Note that some C compilers might need to be explicitly told to link in the math library: <code>-lm</code>):</p>&#13;
<span epub:type="pagebreak" id="page_20"/>&#13;
<pre>$ <span class="codestrong1">gcc hello.c -lm</span></pre>&#13;
<div class="imagec" id="ch1fig2"><img alt="image" src="../images/01fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-2: The C compiler (gcc) builds C source code into a binary executable file (a.out). The underlying system (OS and hardware) directly executes the a.out file to run the program.</em></p>&#13;
<h5 class="h5" id="lev3_1">Detailed Steps</h5>&#13;
<p class="noindent">In general, the following sequence describes the necessary steps for editing, compiling, and running a C program on a Unix system.</p>&#13;
<p class="indent">First, using a text editor (e.g., <code>vim</code><sup><a href="ch01.xhtml#fn1_4" id="rfn1_4">4</a></sup>), write and save your C source code program in a file (e.g., <code>hello.c</code>):</p>&#13;
<pre>$ <span class="codestrong1">vim hello.c</span></pre>&#13;
<p class="indent">Next, compile the source to an executable form, and then run it. The most basic syntax for compiling with <code>gcc</code> is:</p>&#13;
<pre>$ <span class="codestrong1">gcc</span> <span class="codeitalic1">&lt;input_source_file&gt;</span></pre>&#13;
<p class="indent">If compilation yields no errors, the compiler creates a binary executable file named <code>a.out</code>. The compiler also allows you to specify the name of the binary executable file to generate using the <code>-o</code> flag:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o</span> <span class="codeitalic1">&lt;output_executable_file&gt; &lt;input_source_file&gt;</span></pre>&#13;
<p class="indent">For example, this command instructs <code>gcc</code> to compile <code>hello.c</code> into an executable file named <code>hello</code>:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o hello hello.c</span></pre>&#13;
<p class="indent">We can invoke the executable program using <code>./hello</code>:</p>&#13;
<pre><span epub:type="pagebreak" id="page_21"/>$ <span class="codestrong1">./hello</span></pre>&#13;
<p class="indent">Any changes made to the C source code (the <code>hello.c</code> file) must be recompiled with <code>gcc</code> to produce a new version of <code>hello</code>. If the compiler detects any errors during compilation, the <code>./hello</code> file won’t be created/re-created (but beware, an older version of the file from a previous successful compilation might still exist).</p>&#13;
<p class="indent">Often when compiling with <code>gcc</code>, you want to include several command line options. For example, these options enable more compiler warnings and build a binary executable with extra debugging information:</p>&#13;
<pre>$ <span class="codestrong1">gcc -Wall -g -o hello hello.c</span></pre>&#13;
<p class="indent">Because the <code>gcc</code> command line can be long, frequently the <code>make</code> utility is used to simplify compiling C programs and for cleaning up files created by <code>gcc</code>. Using <code>make</code> and writing a <code>Makefile</code> are important skills that you will develop as you build up experience with C programming.<sup><a href="ch01.xhtml#fn1_5" id="rfn1_5">5</a></sup></p>&#13;
<p class="indent">We cover compiling and linking with C library code in more detail at the end of <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<h4 class="h4" id="lev2_2">Variables and C Numeric Types</h4>&#13;
<p class="noindent">Like Python, C uses variables as named storage locations for holding data. Thinking about the scope and type of program variables is important to understand the semantics of what your program will do when you run it. A variable’s <em>scope</em> defines when the variable has meaning (that is, where and when in your program it can be used) and its lifetime (that is, it could persist for the entire run of a program or only during a function activation). A variable’s <em>type</em> defines the range of values that it can represent and how those values will be interpreted when performing operations on its data.</p>&#13;
<p class="indent">In C, all variables must be declared before they can be used. To declare a variable, use the following syntax:</p>&#13;
<pre>type_name variable_name;</pre>&#13;
<p class="indent">A variable can have only a single type. The basic C types include <code>char</code>, <code>int</code>, <code>float</code>, and <code>double</code>. By convention, C variables should be declared at the beginning of their scope (at the top of a <code>{ }</code> block), before any C statements in that scope.</p>&#13;
<p class="indent">Below is an example C code snippet that shows declarations and uses of variables of some different types. We discuss types and operators in more detail after the example.</p>&#13;
<p class="margnote">vars.c</p>&#13;
<pre>{<br/>&#13;
    /* 1. Define variables in this block's scope at the top of the block. */<br/>&#13;
<br/>&#13;
    int x; // declares x to be an int type variable and allocates space for it<br/>&#13;
<br/>&#13;
    int i, j, k;  // can define multiple variables of the same type like this<br/>&#13;
<span epub:type="pagebreak" id="page_22"/><br/>&#13;
    char letter;  // a char stores a single-byte integer value<br/>&#13;
                  // it is often used to store a single ASCII character<br/>&#13;
                  // value (the ASCII numeric encoding of a character)<br/>&#13;
                  // a char in C is a different type than a string in C<br/>&#13;
<br/>&#13;
    float winpct; // winpct is declared to be a float type<br/>&#13;
    double pi;    // the double type is more precise than float<br/>&#13;
<br/>&#13;
    /* 2. After defining all variables, you can use them in C statements. */<br/>&#13;
<br/>&#13;
    x = 7;        // x stores 7 (initialize variables before using their value)<br/>&#13;
    k = x + 2;    // use x's value in an expression<br/>&#13;
<br/>&#13;
    letter = 'A';        // a single quote is used for single character value<br/>&#13;
    letter = letter + 1; // letter stores 'B' (ASCII value one more than 'A')<br/>&#13;
<br/>&#13;
    pi = 3.1415926;<br/>&#13;
<br/>&#13;
    winpct = 11 / 2.0; // winpct gets 5.5, winpct is a float type<br/>&#13;
    j = 11 / 2;        // j gets 5: int division truncates after the decimal<br/>&#13;
    x = k % 2;         // % is C's mod operator, so x gets 9 mod 2 (1)<br/>&#13;
}</pre>&#13;
<p class="indent">Note the semicolons galore. Recall that C statements are delineated by <code>;</code>, not line breaks—C expects a semicolon after every statement. You’ll forget some, and <code>gcc</code> almost never informs you that you missed a semicolon, even though that might be the only syntax error in your program. In fact, often when you forget a semicolon, the compiler indicates a syntax error on the line <em>after</em> the one with the missing semicolon: the reason is that <code>gcc</code> interprets it as part of the statement from the previous line. As you continue to program in C, you’ll learn to correlate <code>gcc</code> errors with the specific C syntax mistakes that they describe.</p>&#13;
<h4 class="h4" id="lev2_3">1.1.2 C Types</h4>&#13;
<p class="noindent">C supports a small set of built-in data types, and it provides a few ways in which programmers can construct basic collections of types (arrays and structs). From these basic building blocks, a C programmer can build complex data structures.</p>&#13;
<p class="indent">C defines a set of basic types for storing numeric values. Here are some examples of numeric literal values of different C types:</p>&#13;
<pre>8     // the int value 8<br/>&#13;
3.4   // the double value 3.4<br/>&#13;
'h'   // the char value 'h' (its value is 104, the ASCII value of h)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>The C <code>char</code> type stores a numeric value. However, it’s often used by programmers to store the value of an ASCII character. A character literal value is specified in C as a single character between single quotes.</p>&#13;
<p class="indent">C doesn’t support a string type, but programmers can create strings from the <code>char</code> type and C’s support for constructing arrays of values, which we discuss in later sections. C does, however, support a way of expressing string literal values in programs: a string literal is any sequence of characters between double quotes. C programmers often pass string literals as the format string argument to <code>printf</code>:</p>&#13;
<pre>printf("this is a C string\n");</pre>&#13;
<p class="indent">Python supports strings, but it doesn’t have a <code>char</code> type. In C, a string and a <code>char</code> are two very different types, and they evaluate differently. This difference is illustrated by contrasting a C string literal that contains one character with a C <code>char</code> literal. For example:</p>&#13;
<pre>'h'  // this is a char literal value   (its value is 104, the ASCII value of h)<br/>&#13;
"h"  // this is a string literal value (its value is NOT 104, it is not a char)</pre>&#13;
<p class="indent">We discuss C strings and <code>char</code> variables in more detail in the “Strings and the String Library” section on <a href="ch02.xhtml#lev1_14">page 93</a>. Here, we’ll mainly focus on C’s numeric types.</p>&#13;
<h5 class="h5" id="lev3_2">C Numeric Types</h5>&#13;
<p class="noindent">C supports several different types for storing numeric values. The types differ in the format of the numeric values they represent. For example, the <code>float</code> and <code>double</code> types can represent real values, <code>int</code> represents signed integer values, and <code>unsigned int</code> represents unsigned integer values. Real values are positive or negative values with a decimal point, such as – 1<em>.</em>23 or 0<em>.</em>0056. Signed integers store positive, negative, or zero integer values, such as – 333, 0, or 3456. Unsigned integers store strictly non-negative integer values, such as 0 or 1234.</p>&#13;
<p class="indent">C’s numeric types also differ in the range and precision of the values they can represent. The range or precision of a value depends on the number of bytes associated with its type. Types with more bytes can represent a larger range of values (for integer types), or higher-precision values (for real types), than types with fewer bytes.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch1tab1">Table 1-1</a> shows the number of storage bytes, the kind of numeric values stored, and how to declare a variable for a variety of common C numeric types (note that these are typical sizes—the exact number of bytes depends on the hardware architecture).</p>&#13;
<span epub:type="pagebreak" id="page_24"/>&#13;
<p class="tabcap" id="ch1tab1"><strong>Table 1-1:</strong> C Numeric Types</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type name</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Usual size</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Values stored</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>How to declare</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>char</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">1 byte</p></td>&#13;
<td style="vertical-align: top"><p class="tab">integers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>char x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>short</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">2 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed integers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>short x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">4 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed integers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>long</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">4 or 8 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed integers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>long x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>long long</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">8 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed integers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>long long x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>float</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">4 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed real numbers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>float x;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>double</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">8 bytes</p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed real numbers</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>double x;</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">C also provides <em>unsigned</em> versions of the integer numeric types (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code>). To declare a variable as unsigned, add the keyword <code>unsigned</code> before the type name. For example:</p>&#13;
<pre>int x;           // x is a signed int variable<br/>&#13;
unsigned int y;  // y is an unsigned int variable</pre>&#13;
<p class="indent">The C standard doesn’t specify whether the <code>char</code> type is signed or unsigned. As a result, some implementations might implement <code>char</code> as signed integer values and others as unsigned. It’s good programming practice to explicitly declare <code>unsigned char</code> if you want to use the unsigned version of a <code>char</code> variable.</p>&#13;
<p class="indent">The exact number of bytes for each of the C types might vary from one architecture to the next. The sizes in <a href="ch01.xhtml#ch1tab1">Table 1-1</a> are minimum (and common) sizes for each type. You can print the exact size on a given machine using C’s <code>sizeof</code> operator, which takes the name of a type as an argument and evaluates to the number of bytes used to store that type. For example:</p>&#13;
<pre>printf("number of bytes in an int: %lu\n", sizeof(int));<br/>&#13;
printf("number of bytes in a short: %lu\n", sizeof(short));</pre>&#13;
<p class="indent">The <code>sizeof</code> operator evaluates to an unsigned long value, so in the call to <code>printf</code>, use the placeholder <code>%lu</code> to print its value. On most architectures the output of these statements will be:</p>&#13;
<pre>number of bytes in an int: 4 <br/>&#13;
number of bytes in a short: 2</pre>&#13;
<h5 class="h5" id="lev3_3">Arithmetic Operators</h5>&#13;
<p class="noindent">Arithmetic operators combine values of numeric types. The resulting type of the operation is based on the types of the operands. For example, if two <code>int</code> values are combined with an arithmetic operator, the resulting type is also an integer.</p>&#13;
<p class="indent">C performs automatic type conversion when an operator combines operands of two different types. For example, if an <code>int</code> operand is combined with a <code>float</code> operand, the integer operand is first converted to its floating-point <span epub:type="pagebreak" id="page_25"/>equivalent before the operator is applied, and the type of the operation’s result is <code>float</code>.</p>&#13;
<p class="indent">The following arithmetic operators can be used on most numeric type operands:</p>&#13;
<ul>&#13;
<li class="noindent">add (<code>+</code>) and subtract (<code>-</code>)</li>&#13;
<li class="noindent">multiply (<code>*</code>), divide (<code>/</code>), and mod(<code>%</code>):&#13;
<p class="noindentt">The mod operator (<code>%</code>) can only take integer-type operands (<code>int</code>, <code>unsigned int</code>, <code>short</code>, and so on).</p>&#13;
<p class="noindentt">If both operands are <code>int</code> types, the divide operator (<code>/</code>) performs integer division (the resulting value is an <code>int</code>, truncating anything beyond the decimal point from the division operation). For example <code>8/3</code> evaluates to <code>2</code>.</p>&#13;
<p class="noindentt">If one or both of the operands are <code>float</code> (or <code>double</code>), <code>/</code> performs real division and evaluates to a <code>float</code> (or <code>double</code>) result. For example, <code>8/3.0</code> evaluates to approximately <code>2.666667</code>.</p></li>&#13;
<li class="noindent">assignment (<code>=</code>):&#13;
<pre>variable = value of expression;   // e.g., x = 3 + 4;</pre></li>&#13;
<li class="noindent">assignment with update (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, and <code>%=</code>):&#13;
<pre>variable op= expression;  // e.g., x += 3; is shorthand for x = x + 3;</pre></li>&#13;
<li class="noindent">increment (<code>++</code>) and decrement (<code>--</code>):&#13;
<pre>variable++;   // e.g., x++; assigns to x the value of x + 1</pre></li>&#13;
</ul>&#13;
<p class="note"><strong><span class="black">Warning</span> PRE- VERSUS POST-INCREMENT</strong></p>&#13;
<p class="note-w">The operators <code>++variable</code> and <code>variable++</code> are both valid, but they’re evaluated slightly differently:</p>&#13;
<ul>&#13;
<li class="note-w"><code>++x</code>: increment <code>x</code> first, then use its value.</li>&#13;
<li class="note-w"><code>x++</code>: use <code>x</code>’s value first, then increment it.</li>&#13;
</ul>&#13;
<p class="note-w">In many cases, it doesn’t matter which you use because the value of the incremented or decremented variable isn’t being used in the statement. For example, these two statements are equivalent (although the first is the most commonly used syntax for this statement):</p>&#13;
<p class="programs-l">x++; <br/>&#13;
++x;</p>&#13;
<p class="note-w"><span epub:type="pagebreak" id="page_26"/>In some cases, the context affects the outcome (when the value of the incremented or decremented variable <em>is</em> being used in the statement). For example:</p>&#13;
<p class="programs-l">x = 6;<br/>&#13;
y = ++x + 2;  // y is assigned 9: increment x first, then evaluate x + 2 (9)<br/>&#13;
<br/>&#13;
x = 6;<br/>&#13;
y = x++ + 2;  // y is assigned 8: evaluate x + 2 first (8), then increment x</p>&#13;
<p class="note-w">Code like the preceding example that uses an arithmetic expression with an increment operator is often hard to read, and it’s easy to get wrong. As a result, it’s generally best to avoid writing code like this; instead, write separate statements for exactly the order you want. For example, if you want to first increment <code>x</code> and then assign <code>x + 1</code> to <code>y</code>, just write it as two separate statements.</p>&#13;
<p class="note-w">Instead of writing this</p>&#13;
<p class="programs-l">y = ++x + 1;</p>&#13;
<p class="note-w">write it as two separate statements:</p>&#13;
<p class="programs-l">x++; <br/>&#13;
y = x + 1;</p>&#13;
<h3 class="h3" id="lev1_2">1.2 Input/Output (printf and scanf)</h3>&#13;
<p class="noindent">C’s <code>printf</code> function prints values to the terminal, and the <code>scanf</code> function reads in values entered by a user. The <code>printf</code> and <code>scanf</code> functions belong to C’s standard I/O library, which needs to be explicitly included at the top of any <code>.c</code> file that uses these functions by using <code>#include &lt;stdio.h&gt;</code>. In this section, we introduce the basics of using <code>printf</code> and <code>scanf</code> in C programs. “I/O in C (Standard and File)” on <a href="ch02.xhtml#lev1_16">page 113</a> discusses C’s input and output functions in more detail.</p>&#13;
<h4 class="h4" id="lev2_4">1.2.1 printf</h4>&#13;
<p class="noindent">C’s <code>printf</code> function is very similar to formatted print in Python, where the caller specifies a format string to print. The format string often contains formatting specifiers, such as special characters that will print tabs (<code>\t</code>) or newlines (<code>\n</code>), or placeholders for values in the output. Placeholders consist of <code>%</code> followed by a type specifier letter (for example, <code>%d</code> represents a placeholder for an integer value). For each placeholder in the format string, <code>printf</code> expects an additional argument. Here, you can see an example program in Python and C with formatted output:</p>&#13;
<pre># Python formatted print example<br/>&#13;
<br/>&#13;
 <br/>&#13;
def main():<br/><span epub:type="pagebreak" id="page_27"/>&#13;
    print("Name: %s,  Info:" % "Vijay")<br/>&#13;
    print("\tAge: %d \t Ht: %g" %(20,5.9))<br/>&#13;
    print("\tYear: %d \t Dorm: %s" %(3, "Alice Paul"))<br/>&#13;
<br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/* C printf example */<br/>&#13;
#include &lt;stdio.h&gt; // needed for printf<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
<br/>&#13;
    printf("Name: %s,  Info:\n", "Vijay");<br/>&#13;
    printf("\tAge: %d \t Ht: %g\n",20,5.9);<br/>&#13;
    printf("\tYear: %d \t Dorm: %s\n",3,"Alice Paul");<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="indent">When run, both versions of this program produce identically formatted output:</p>&#13;
<pre>Name: Vijay,  Info:<br/>&#13;
    Age: 20   Ht: 5.9<br/>&#13;
    Year: 3   Dorm: Alice Paul</pre>&#13;
<p class="indent">The main difference between C’s <code>printf</code> and Python’s <code>print</code> functions are that the Python version implicitly prints a newline character at the end of the output string, but the C version does not. As a result, the C format strings in this example have newline (<code>\n</code>) characters at the end to explicitly print a newline character. The syntax for listing the argument values for the placeholders in the format string is also slightly different in C’s <code>printf</code> and Python’s <code>print</code> functions.</p>&#13;
<p class="indent">C uses the same formatting placeholders as Python for specifying different types of values. The preceding example demonstrates the following formatting placeholders:</p>&#13;
<pre>%g:  placeholder for a float (or double) value<br/>&#13;
%d:  placeholder for a decimal value (int, short, char)<br/>&#13;
%s:  placeholder for a string value</pre>&#13;
<p class="indent">C additionally supports the <code>%c</code> placeholder for printing a character value. This placeholder is useful when a programmer wants to print the ASCII <span epub:type="pagebreak" id="page_28"/>character associated with a particular numeric encoding. Here’s a C code snippet that prints a <code>char</code> as its numeric value (<code>%d</code>) and as its character encoding (<code>%c</code>):</p>&#13;
<pre>// Example printing a char value as its decimal representation (%d)<br/>&#13;
// and as the ASCII character that its value encodes (%c)<br/>&#13;
<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
ch = 'A';<br/>&#13;
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);<br/>&#13;
<br/>&#13;
ch = 99;<br/>&#13;
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);</pre>&#13;
<p class="indent">When run, the program’s output looks like this:</p>&#13;
<pre>ch value is 65 which is the ASCII value of  A<br/>&#13;
ch value is 99 which is the ASCII value of  c</pre>&#13;
<h4 class="h4" id="lev2_5">1.2.2 scanf</h4>&#13;
<p class="noindent">C’s <code>scanf</code> function represents one method for reading in values entered by the user (via the keyboard) and storing them in program variables. The <code>scanf</code> function can be a bit picky about the exact format in which the user enters data, which means that it’s not very robust to badly formed user input. In “I/O in C (Standard and File)” on <a href="ch02.xhtml#lev1_16">page 113</a>, we discuss more robust ways of reading input values from the user. For now, remember that if your program gets into an infinite loop due to badly formed user input, you can always press CTRL-C to terminate it.</p>&#13;
<p class="indent">Reading input is handled differently in Python and C: Python uses the <code>input</code> function to read in a value as a string, and then the program converts the string value to an <code>int</code>, whereas C uses <code>scanf</code> to read in an <code>int</code> value and to store it at the location in memory of an <code>int</code> program variable (for example, <code>&amp;num1</code>). This code displays example programs for reading user input values in Python and C:</p>&#13;
<pre># Python input example<br/>&#13;
<br/>&#13;
 <br/>&#13;
def main():<br/>&#13;
<br/>&#13;
 <br/>&#13;
    num1 = input("Enter a number:")<br/>&#13;
    num1 = int(num1)<br/>&#13;
    num2 = input("Enter another:")<br/>&#13;
    num2 = int(num2)<br/><span epub:type="pagebreak" id="page_29"/>&#13;
    print("%d + %d = %d" % (num1, num2, (num1+num2)))<br/>&#13;
<br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/* C input (scanf) example */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num1, num2;<br/>&#13;
<br/>&#13;
    printf("Enter a number: ");<br/>&#13;
    scanf("%d", &amp;num1);<br/>&#13;
    printf("Enter another: ");<br/>&#13;
    scanf("%d", &amp;num2);<br/>&#13;
<br/>&#13;
    printf("%d + %d = %d\n", num1, num2, (num1+num2));<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="indent">When run, both programs read in two values (here, 30 and 67):</p>&#13;
<pre>Enter a number: <span class="codestrong1">30</span> <br/>&#13;
Enter another: <span class="codestrong1">67</span> <br/>&#13;
30 + 67 = 97</pre>&#13;
<p class="indent">Like <code>printf</code>, <code>scanf</code> takes a format string that specifies the number and types of values to read in (for example, <code>"%d"</code> specifies one <code>int</code> value). The <code>scanf</code> function skips over leading and trailing whitespace as it reads in a numeric value, so its format string only needs to contain a sequence of formatting placeholders, usually with no whitespace or other formatting characters between the placeholders in its format string. The arguments for the placeholders in the format string specify the <em>locations</em> of program variables into which the values read in will be stored. Prefixing the name of a variable with the <code>&amp;</code> operator produces the location of that variable in the program’s memory — the memory address of the variable. “C’s Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 66</a> discusses the <code>&amp;</code> operator in more detail. For now, we use it only in the context of the <code>scanf</code> function.</p>&#13;
<p class="indent">Here’s another <code>scanf</code> example, in which the format string has placeholders for two values, the first an <code>int</code> and the second a <code>float</code>:</p>&#13;
<p class="margnote">scanf_ex.c</p>&#13;
<pre>int x;<br/>&#13;
float pi;<br/>&#13;
<br/>&#13;
// read in an int value followed by a float value ("%d%g")<br/>&#13;
<span epub:type="pagebreak" id="page_30"/>&#13;
// store the int value at the memory location of x (&amp;x)<br/>&#13;
// store the float value at the memory location of pi (&amp;pi)<br/>&#13;
scanf("%d%g", &amp;x, &amp;pi);</pre>&#13;
<p class="indent">When inputting data to a program via <code>scanf</code>, individual numeric input values must be separated by at least one whitespace character. However, because <code>scanf</code> skips over additional leading and trailing whitespace characters (for example, spaces, tabs, and newlines), a user could enter input values with any amount of space before or after each input value. For instance, if a user enters the following for the call to <code>scanf</code> in the preceding example, <code>scanf</code> will read in 8 and store it in the <code>x</code> variable, and then read in 3.14 and store it in the <code>pi</code> variable:</p>&#13;
<pre><span class="codestrong1">          8                   3.14</span></pre>&#13;
<h3 class="h3" id="lev1_3">1.3 Conditionals and Loops</h3>&#13;
<p class="noindent">The code examples that follow show that the syntax and semantics of <code>if</code>–<code>else</code> statements in C and Python are very similar. The main syntactic difference is that Python uses indentation to indicate “body” statements, whereas C uses curly braces (but you should still use good indentation in your C code).</p>&#13;
<pre># Python if-else example<br/>&#13;
<br/>&#13;
 <br/>&#13;
def main():<br/>&#13;
<br/>&#13;
 <br/>&#13;
    num1 = input("Enter the 1st number:")<br/>&#13;
    num1 = int(num1)<br/>&#13;
    num2 = input("Enter the 2nd number:")<br/>&#13;
    num2 = int(num2)<br/>&#13;
<br/>&#13;
    if num1 &gt; num2:<br/>&#13;
        print("%d is biggest" % num1)<br/>&#13;
        num2 = num1<br/>&#13;
    else:<br/>&#13;
        print("%d is biggest" % num2)<br/>&#13;
        num1 = num2<br/>&#13;
<br/>&#13;
 <br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre><span epub:type="pagebreak" id="page_31"/>/* C if-else example */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num1, num2;<br/>&#13;
<br/>&#13;
    printf("Enter the 1st number: ");<br/>&#13;
    scanf("%d", &amp;num1);<br/>&#13;
    printf("Enter the 2nd number: ");<br/>&#13;
    scanf("%d", &amp;num2);<br/>&#13;
<br/>&#13;
    if (num1 &gt; num2) {<br/>&#13;
        printf("%d is biggest\n", num1);<br/>&#13;
        num2 = num1;<br/>&#13;
    } else {<br/>&#13;
        printf("%d is biggest\n", num2);<br/>&#13;
        num1 = num2;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="indent">The Python and C syntax for <code>if</code>–<code>else</code> statements is almost identical with only minor differences. In both, the <code>else</code> part is optional. Python and C also support multiway branching by chaining <code>if</code> and <code>else if</code> statements. The following describes the full <code>if</code>–<code>else</code> C syntax:</p>&#13;
<pre>    // a one-way branch:<br/>&#13;
    if ( <span class="codeitalic1">&lt;boolean expression&gt;</span> ) {<br/>&#13;
        <span class="codeitalic1">&lt;true body&gt;</span><br/>&#13;
    }<br/>&#13;
<br/>&#13;
    // a two-way branch:<br/>&#13;
    if ( <span class="codeitalic1">&lt;boolean expression&gt;</span> ) {<br/>&#13;
        <span class="codeitalic1">&lt;true body&gt;</span><br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        <span class="codeitalic1">&lt;false body&gt;</span><br/>&#13;
    }<br/>&#13;
<br/>&#13;
    // a multibranch (chaining if-else if-...-else)<br/>&#13;
    // (has one or more 'else if' following the first if):<br/>&#13;
    if ( <span class="codeitalic1">&lt;boolean expression 1&gt;</span> ) {<br/>&#13;
        <span class="codeitalic1">&lt;true body&gt;</span><br/>&#13;
    }<br/>&#13;
    else if ( <span class="codeitalic1">&lt;boolean expression 2&gt;</span> ) {<br/>&#13;
        <span epub:type="pagebreak" id="page_32"/>// first expression is false, second is true<br/>&#13;
        <span class="codeitalic1">&lt;true 2 body&gt;</span><br/>&#13;
    }<br/>&#13;
    else if ( <span class="codeitalic1">&lt;boolean expression 3&gt;</span> ) {<br/>&#13;
        // first and second expressions are false, third is true<br/>&#13;
        <span class="codeitalic1">&lt;true 3 body&gt;</span><br/>&#13;
    }<br/>&#13;
    // ... more else if's ...<br/>&#13;
    else if ( <span class="codeitalic1">&lt;boolean expression N&gt;</span> ) {<br/>&#13;
        // first N-1 expressions are false, Nth is true<br/>&#13;
        <span class="codeitalic1">&lt;true N body&gt;</span><br/>&#13;
    }<br/>&#13;
    else { // the final else part is optional<br/>&#13;
        // if all previous expressions are false<br/>&#13;
        <span class="codeitalic1">&lt;false body&gt;</span><br/>&#13;
    }</pre>&#13;
<h4 class="h4" id="lev2_6">1.3.1 Boolean Values in C</h4>&#13;
<p class="noindent">C doesn’t provide a Boolean type with true or false values. Instead, integer values evaluate to <em>true</em> or <em>false</em> when used in conditional statements. When used in conditional expressions, an integer expression that is:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><em>zero</em> (0) evaluates to <em>false</em>;</p>&#13;
<p class="ul-noindent"><em>nonzero</em> (any positive or negative value) evaluates to <em>true</em>.</p>&#13;
</div>&#13;
<p class="indent">C has a set of relational and logical operators for Boolean expressions. The <em>relational operators</em> take operand(s) of the same type and evaluate to zero (false) or nonzero (true). The set of relational operators are:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent">equality (<code>==</code> and inequality (not equal, <code>!=</code>);</p>&#13;
<p class="ul-noindent">comparison operators: less than (<code>&lt;</code>), less than or equal (<code>&lt;=</code>), greater than (<code>&gt;</code>), and greater than or equal (<code>&gt;=</code>).</p>&#13;
</div>&#13;
<p class="indent">The following C code snippets show examples of relational operators:</p>&#13;
<pre>// assume x and y are ints, and have been assigned<br/>&#13;
// values before this point in the code<br/>&#13;
<br/>&#13;
if (y &lt; 0) {<br/>&#13;
    printf("y is negative\n");<br/>&#13;
} else if (y != 0) {<br/>&#13;
    printf("y is positive\n");<br/>&#13;
} else {<br/>&#13;
    printf("y is zero\n");<br/>&#13;
}<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_33"/>&#13;
// set x and y to the larger of the two values<br/>&#13;
if (x &gt;= y) {<br/>&#13;
    y = x;<br/>&#13;
} else {<br/>&#13;
    x = y;<br/>&#13;
}</pre>&#13;
<p class="indent">C’s <em>logical operators</em> take integer “Boolean” operand(s) and evaluate to either zero (false) or nonzero (true). The set of logical operators are:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent">logical negation (<code>!</code>);</p>&#13;
<p class="ul-noindent">logical and (<code>&amp;&amp;</code>): stops evaluating at the first false expression (short-circuiting);</p>&#13;
<p class="ul-noindent">logical or (<code>||</code>): stops evaluating at the first true expression (short-circuiting).</p>&#13;
</div>&#13;
<p class="indent">C’s <em>short-circuit</em> logical operator evaluation stops evaluating a logical expression as soon as the result is known. For example, if the first operand to a logical and (<code>&amp;&amp;</code>) expression evaluates to false, the result of the <code>&amp;&amp;</code> expression must be false. As a result, the second operand’s value need not be evaluated, and it is not evaluated.</p>&#13;
<p class="indent">The following is an example of conditional statements in C that use logical operators (it’s always best to use parentheses around complex Boolean expressions to make them easier to read):</p>&#13;
<pre>if ( (x &gt; 10) &amp;&amp; (y &gt;= x) ) {<br/>&#13;
    printf("y and x are both larger than 10\n");<br/>&#13;
    x = 13;<br/>&#13;
} else if ( ((-x) == 10) || (y &gt; x) ) {<br/>&#13;
    printf("y might be bigger than x\n");<br/>&#13;
    x = y * x;<br/>&#13;
} else {<br/>&#13;
    printf("I have no idea what the relationship between x and y is\n");<br/>&#13;
}</pre>&#13;
<h4 class="h4" id="lev2_7">1.3.2 Loops in C</h4>&#13;
<p class="noindent">Like Python, C supports <code>for</code> and <code>while</code> loops. Additionally, C provides <code>do</code>–<code>while</code> loops.</p>&#13;
<h5 class="h5" id="lev3_4">while Loops</h5>&#13;
<p class="noindent">The <code>while</code> loop syntax in C and Python is almost identical, and the behavior is the same. Here, you can see example programs with <code>while</code> loops in C and Python:</p>&#13;
<pre># Python while loop example<br/>&#13;
def main():<br/>&#13;
    num = input("Enter a value: ")<br/>&#13;
    num = int(num)<br/>&#13;
<span epub:type="pagebreak" id="page_34"/>&#13;
    # make sure num is not negative<br/>&#13;
    if num &lt; 0:<br/>&#13;
        num = -num<br/>&#13;
    val = 1<br/>&#13;
    while val &lt; num:<br/>&#13;
        print("%d" % (val))<br/>&#13;
        val = val * 2<br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/* C while loop example */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num, val;<br/>&#13;
<br/>&#13;
    printf("Enter a value: ");<br/>&#13;
    scanf("%d", &amp;num);<br/>&#13;
    // make sure num is not negative<br/>&#13;
    if (num &lt; 0) {<br/>&#13;
        num = -num;<br/>&#13;
    }<br/>&#13;
    val = 1;<br/>&#13;
    while (val &lt; num) {<br/>&#13;
        printf("%d\n", val);<br/>&#13;
        val = val * 2;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="indent">The <code>while</code> loop syntax in C is very similar in Python, and both are evaluated in the same way:</p>&#13;
<pre>while ( <span class="codeitalic1">&lt;boolean expression&gt;</span> ) {<br/>&#13;
    <span class="codeitalic1">&lt;true body&gt;</span><br/>&#13;
}</pre>&#13;
<p class="indent">The <code>while</code> loop checks the Boolean expression first and executes the body if true. In the preceding example program, the value of the <code>val</code> variable will be repeatedly printed in the <code>while</code> loop until its value is greater than the value of the <code>num</code> variable. If the user enters <code>10</code>, the C and Python programs will print:</p>&#13;
<pre><span epub:type="pagebreak" id="page_35"/>1 <br/>&#13;
2 <br/>&#13;
4 <br/>&#13;
8</pre>&#13;
<p class="indent">C also has a <code>do</code>–<code>while</code> loop that is similar to its <code>while</code> loop, but it executes the loop body first and then checks a condition and repeats executing the loop body for as long as the condition is true. That is, a <code>do</code>–<code>while</code> loop will always execute the loop body at least one time:</p>&#13;
<pre>do {<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
} while ( <span class="codeitalic1">&lt;boolean expression&gt;</span> );</pre>&#13;
<p class="indent">For additional <code>while</code> loop examples, have a look at <code>whileLoop1.c</code><sup><a href="ch01.xhtml#fn1_6" id="rfn1_6">6</a></sup> and <code>whileLoop2.c</code>.<sup><a href="ch01.xhtml#fn1_7" id="rfn1_7">7</a></sup></p>&#13;
<h5 class="h5" id="lev3_5">for Loops</h5>&#13;
<p class="noindent">The <code>for</code> loop is different in C than it is in Python. In Python, <code>for</code> loops are iterations over sequences, whereas in C, <code>for</code> loops are more general looping constructs. Here are example programs that use <code>for</code> loops to print all the values between 0 and a user-provided input number:</p>&#13;
<pre># Python for loop example<br/>&#13;
def main():<br/>&#13;
    num = input("Enter a value: ")<br/>&#13;
    num = int(num)<br/>&#13;
    # make sure num is not negative<br/>&#13;
    if num &lt; 0:<br/>&#13;
        num = -num<br/>&#13;
    for i in range(num):<br/>&#13;
        print("%d" % i)<br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/* C for loop example */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num, i;<br/>&#13;
<br/>&#13;
    printf("Enter a value: ");<br/>&#13;
    scanf("%d", &amp;num);<br/>&#13;
    // make sure num is not negative<br/>&#13;
    if (num &lt; 0) {<br/>&#13;
        num = -num;<br/>&#13;
    }&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_36"/>&#13;
    for (i = 0; i &lt; num; i++) {<br/>&#13;
        printf("%d\n", i);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line">C version</p>&#13;
<p class="indent">In this example, you can see that the C <code>for</code> loop syntax is quite different from the Python <code>for</code> loop syntax. It’s also evaluated differently.</p>&#13;
<p class="indent">The C <code>for</code> loop syntax is:</p>&#13;
<pre>for ( <span class="codeitalic1">&lt;initialization&gt;</span>; <span class="codeitalic1">&lt;boolean expression&gt;</span>; <span class="codeitalic1">&lt;step&gt;</span> ) {<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
}</pre>&#13;
<p class="indent">The <code>for</code> loop evaluation rules are:</p>&#13;
<div class="number">&#13;
<p class="number">1. Evaluate <span class="codeitalic">&lt;initialization&gt;</span> one time when first entering the loop.</p>&#13;
<p class="number">2. Evaluate the <span class="codeitalic">&lt;boolean expression&gt;</span> . If it’s 0 (false), drop out of the <code>for</code> loop (in other words, the program is done repeating the loop body statements).</p>&#13;
<p class="number">3. Evaluate the statements inside the loop <span class="codeitalic">&lt;body&gt;</span> .</p>&#13;
<p class="number">4. Evaluate the <span class="codeitalic">&lt;step&gt;</span> expression.</p>&#13;
<p class="number">5. Repeat from step (2).</p>&#13;
</div>&#13;
<p class="indent">Here’s a simple example <code>for</code> loop to print the values 0, 1, and 2:</p>&#13;
<pre>int i;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; 3; i++) {<br/>&#13;
    printf("%d\n", i);<br/>&#13;
}</pre>&#13;
<p class="indent">Executing the <code>for</code> loop evaluation rules on the preceding loop yields the following sequence of actions:</p>&#13;
<pre>(1) eval init: i is set to 0  (i=0)<br/>&#13;
(2) eval bool expr: i &lt; 3 is true<br/>&#13;
(3) execute loop body: print the value of i (0)<br/>&#13;
(4) eval step: i is set to 1  (i++)<br/>&#13;
(2) eval bool expr: i &lt; 3 is true<br/>&#13;
(3) execute loop body: print the value of i (1)<br/>&#13;
(4) eval step: i is set to 2  (i++)<br/>&#13;
(2) eval bool expr: i &lt; 3 is true<br/>&#13;
(3) execute loop body: print the value of i (2)<br/><span epub:type="pagebreak" id="page_37"/>&#13;
(4) eval step: i is set to 3  (i++)<br/>&#13;
(2) eval bool expr: i &lt; 3 is false, drop out of the for loop</pre>&#13;
<p class="indent">The following program shows a more complicated <code>for</code> loop example (it’s also available to download<sup><a href="ch01.xhtml#fn1_8" id="rfn1_8">8</a></sup>). Note that just because C supports <code>for</code> loops with a list of statements for its <span class="codeitalic">&lt;initialization&gt;</span> and <span class="codeitalic">&lt;step&gt;</span> parts, it’s best to keep it simple. (This example illustrates a more complicated <code>for</code> loop syntax, but the <code>for</code> loop would be easier to read and understand if it were simplified by moving the <code>j</code> <code>+= 10</code> step statement to the end of the loop body and having just a single step statement, <code>i += 1</code>.)</p>&#13;
<pre>/* An example of a more complex for loop which uses multiple variables.<br/>&#13;
 * (it is unusual to have for loops with multiple statements in the<br/>&#13;
 * init and step parts, but C supports it and there are times when it<br/>&#13;
 * is useful...don't go nuts with this just because you can)<br/>&#13;
 */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int i, j;<br/>&#13;
<br/>&#13;
    for (i=0, j=0; i &lt; 10; i+=1, j+=10) {<br/>&#13;
        printf("i+j = %d\n", i+j);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
// the rules for evaluating a for loop are the same no matter how<br/>&#13;
// simple or complex each part is:<br/>&#13;
// (1) evaluate the initialization statements once on the first<br/>&#13;
//     evaluation of the for loop:  i=0 and j=0<br/>&#13;
// (2) evaluate the boolean condition: i &lt; 10<br/>&#13;
//     if false (when i is 10), drop out of the for loop<br/>&#13;
// (3) execute the statements inside the for loop body: printf<br/>&#13;
// (4) evaluate the step statements:  i += 1, j += 10<br/>&#13;
// (5) repeat, starting at step (2)</pre>&#13;
<p class="indent">In C, <code>for</code> loops and <code>while</code> loops are equivalent in power, meaning that any <code>while</code> loop can be expressed as a <code>for</code> loop, and vice versa. The same is not true in Python, where <code>for</code> loops are iterations over a sequence of values. As such, they cannot express some looping behavior that the more general Python <code>while</code> loop can express. Indefinite loops are one example that can only be written as a <code>while</code> loop in Python.</p>&#13;
<p class="indent">Consider the following <code>while</code> loop in C:</p>&#13;
<pre>int guess = 0;<br/>&#13;
<br/>&#13;
while (guess != num) {<br/>&#13;
<span epub:type="pagebreak" id="page_38"/>&#13;
    printf("%d is not the right number\n", guess);<br/>&#13;
    printf("Enter another guess: ");<br/>&#13;
    scanf("%d", &amp;guess);<br/>&#13;
}</pre>&#13;
<p class="indent">This loop can be translated to an equivalent <code>for</code> loop in C:</p>&#13;
<pre>int guess;<br/>&#13;
<br/>&#13;
for (guess = 0; guess != num; ) {<br/>&#13;
    printf("%d is not the right number\n", guess);<br/>&#13;
    printf("Enter another guess: ");<br/>&#13;
    scanf("%d", &amp;guess);<br/>&#13;
}</pre>&#13;
<p class="indent">In Python, however, this type of looping behavior can be expressed only by using a <code>while</code> loop.</p>&#13;
<p class="indent">Because <code>for</code> and <code>while</code> loops are equally expressive in C, only one looping construct is needed in the language. However, <code>for</code> loops are a more natural language construct for definite loops (like iterating over a range of values), whereas <code>while</code> loops are a more natural language construct for indefinite loops (like repeating until the user enters an even number). As a result, C provides both to programmers.</p>&#13;
<h3 class="h3" id="lev1_4">1.4 Functions</h3>&#13;
<p class="noindent">Functions break code into manageable pieces and reduce code duplication. Functions might take zero or more <em>parameters</em> as input and they <em>return</em> a single value of a specific type. A function <em>declaration</em> or <em>prototype</em> specifies the function’s name, its return type, and its parameter list (the number and types of all the parameters). A function <em>definition</em> includes the code to be executed when the function is called. All functions in C must be declared before they’re called. This can be done by declaring a function prototype or by fully defining the function before calling it:</p>&#13;
<pre>// function definition format:<br/>&#13;
// ---------------------------<br/>&#13;
<span class="codeitalic1">&lt;return type&gt; &lt;function name&gt;</span> (<span class="codeitalic1">&lt;parameter list&gt;</span>)<br/>&#13;
{<br/>&#13;
    <span class="codeitalic1">&lt;function body&gt;</span><br/>&#13;
}<br/>&#13;
<br/>&#13;
// parameter list format:<br/>&#13;
// ---------------------<br/>&#13;
<span class="codeitalic1">&lt;type&gt; &lt;param1 name&gt;</span>, <span class="codeitalic1">&lt;type&gt; &lt;param2 name&gt;</span>, ...,  <span class="codeitalic1">&lt;type&gt; &lt;last param name&gt;</span></pre>&#13;
<p class="indent">Here’s an example function definition. Note that the comments describe what the function does, the details of each parameter (what it’s used for and what it should be passed), and what the function returns:</p>&#13;
<pre><span epub:type="pagebreak" id="page_39"/>/* This program computes the larger of two<br/>&#13;
 * values entered by the user.<br/>&#13;
 */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
/* max: computes the larger of two integer values<br/>&#13;
 *   x: one integer value<br/>&#13;
 *   y: the other integer value<br/>&#13;
 *   returns: the larger of x and y<br/>&#13;
 */<br/>&#13;
int max(int x, int y) {<br/>&#13;
    int bigger;<br/>&#13;
<br/>&#13;
    bigger = x;<br/>&#13;
    if (y &gt; x) {<br/>&#13;
        bigger = y;<br/>&#13;
    }<br/>&#13;
    printf("  in max, before return x: %d y: %d\n", x, y);<br/>&#13;
    return bigger;<br/>&#13;
}</pre>&#13;
<p class="indent">Functions that don’t return a value should specify the <code>void</code> return type. Here’s an example of a <code>void</code> function:</p>&#13;
<pre>/* prints out the squares from start to stop<br/>&#13;
 *   start: the beginning of the range<br/>&#13;
 *   stop: the end of the range<br/>&#13;
 */<br/>&#13;
void print_table(int start, int stop) {<br/>&#13;
    int i;<br/>&#13;
<br/>&#13;
    for (i = start; i &lt;= stop; i++) {<br/>&#13;
        printf("%d\t", i*i);<br/>&#13;
    }<br/>&#13;
    printf("\n");<br/>&#13;
}</pre>&#13;
<p class="indent">As in any programming language that supports functions or procedures, a <em>function call</em> invokes a function, passing specific argument values for the particular call. A function is called by its name and is passed arguments, with one argument for each corresponding function parameter. In C, calling a function looks like this:</p>&#13;
<pre>// function call format:<br/>&#13;
// ---------------------<br/>&#13;
function_name(<span class="codeitalic1">&lt;argument list&gt;</span>);<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_40"/>&#13;
// argument list format:<br/>&#13;
// ---------------------<br/>&#13;
<span class="codeitalic1">&lt;argument 1 expression&gt;, &lt;argument 2 expression&gt;, ..., &lt;last argument expression&gt;</span></pre>&#13;
<p class="indent">Arguments to C functions are <em>passed by value</em>: each function parameter is assigned the <em>value</em> of the corresponding argument passed to it in the function call by the caller. Pass by value semantics mean that any change to a parameter’s value in the function (that is, assigning a parameter a new value in the function) is <em>not visible</em> to the caller.</p>&#13;
<p class="indent">Here are some example function calls to the <code>max</code> and <code>print_table</code> functions listed earlier:</p>&#13;
<pre>int val1, val2, result;<br/>&#13;
<br/>&#13;
val1 = 6;<br/>&#13;
val2 = 10;<br/>&#13;
<br/>&#13;
/* to call max, pass in two int values, and because max returns an<br/>&#13;
   int value, assign its return value to a local variable (result)<br/>&#13;
 */<br/>&#13;
result = max(val1, val2);     /* call max with argument values 6 and 10 */<br/>&#13;
printf("%d\n", result);       /* prints out 10 */<br/>&#13;
<br/>&#13;
result = max(11, 3);          /* call max with argument values 11 and 3 */<br/>&#13;
printf("%d\n", result);       /* prints out 11 */<br/>&#13;
<br/>&#13;
result = max(val1 * 2, val2); /* call max with argument values 12 and 10 */<br/>&#13;
printf("%d\n", result);       /* prints out 12 */<br/>&#13;
<br/>&#13;
/* print_table does not return a value, but takes two arguments */<br/>&#13;
print_table(1, 20);           /* prints a table of values from 1 to 20 */<br/>&#13;
print_table(val1, val2);      /* prints a table of values from 6 to 10 */</pre>&#13;
<p class="indent">Here is another example of a full program that shows a call to a slightly different implementation of the <code>max</code> function that has an additional statement to change the value of its parameter (<code>x = y</code>):</p>&#13;
<pre>/* max: computes the larger of two int values<br/>&#13;
 *   x: one value<br/>&#13;
 *   y: the other value<br/>&#13;
 *   returns: the larger of x and y<br/>&#13;
 */<br/>&#13;
int max(int x, int y) {<br/>&#13;
    int bigger;<br/>&#13;
<br/>&#13;
    bigger = x;<br/>&#13;
    if (y &gt; x) {<br/>&#13;
        bigger = y;<br/>&#13;
        // note: changing the parameter x's value here will not<br/>&#13;
<span epub:type="pagebreak" id="page_41"/>&#13;
        //       change the value of its corresponding argument<br/>&#13;
        x = y;<br/>&#13;
    }<br/>&#13;
    printf("  in max, before return x: %d y: %d\n", x, y);<br/>&#13;
<br/>&#13;
    return bigger;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/* main: shows a call to max */<br/>&#13;
int main() {<br/>&#13;
    int a, b, res;<br/>&#13;
<br/>&#13;
    printf("Enter two integer values: ");<br/>&#13;
    scanf("%d%d", &amp;a, &amp;b);<br/>&#13;
<br/>&#13;
    res = max(a, b);<br/>&#13;
    printf("The larger value of %d and %d is %d\n", a, b, res);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The following output shows what two runs of this program might look like. Note the difference in the parameter <code>x</code>’s value (printed from inside the <code>max</code> function) in the two runs. Specifically, notice that changing the value of parameter <code>x</code> in the second run does <em>not</em> affect the variable that was passed in as an argument to <code>max</code> after the call returns:</p>&#13;
<pre>$ <span class="codestrong1">./a.out</span><br/>&#13;
Enter two integer values: <span class="codestrong1">11  7</span><br/>&#13;
  in max, before return x: 11 y: 7<br/>&#13;
The larger value of 11 and 7 is 11<br/>&#13;
<br/>&#13;
$ <span class="codestrong1">./a.out</span><br/>&#13;
Enter two integer values: <span class="codestrong1">13  100</span><br/>&#13;
  in max, before return x: 100 y: 100<br/>&#13;
The larger value of 13 and 100 is 100</pre>&#13;
<p class="indent">Because arguments are <em>passed by value</em> to functions, the preceding version of the <code>max</code> function that changes one of its parameter values behaves identically to the original version of <code>max</code> that does not.</p>&#13;
<h4 class="h4" id="lev2_8">1.4.1 The Stack</h4>&#13;
<p class="noindent">The <em>execution stack</em> keeps track of the state of active functions in a program. Each function call creates a new <em>stack frame</em> (sometimes called an <em>activation frame</em> or <em>activation record</em>) containing its parameter and local variable values. The frame on the top of the stack is the active frame; it represents the function activation that is currently executing, and only its local variables and parameters are in scope. When a function is called, a new stack frame is <span epub:type="pagebreak" id="page_42"/>created for it (<em>pushed</em> on the top of the stack), and space for its local variables and parameters is allocated in the new frame. When a function returns, its stack frame is removed from the stack (<em>popped</em> from the top of the stack), leaving the caller’s stack frame on the top of the stack.</p>&#13;
<p class="indent">For the preceding example program, at the point in its execution right before <code>max</code> executes the <code>return</code> statement, the execution stack will look like <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>. Recall that the argument values to <code>max</code> passed by <code>main</code> are <em>passed by value</em>, meaning that the parameters to <code>max</code>, <code>x</code> and <code>y</code>, are assigned the values of their corresponding arguments, <code>a</code> and <code>b</code> from the call in <code>main</code>. Despite the <code>max</code> function changing the value of <code>x</code>, the change doesn’t affect the value of <code>a</code> in <code>main</code>.</p>&#13;
<div class="imagec" id="ch1fig3"><img alt="image" src="../images/01fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-3: The execution stack contents just before returning from the <code>max</code> function</em></p>&#13;
<p class="indent">The following full program includes two functions and shows examples of calling them from the <code>main</code> function. In this program, we declare function prototypes for <code>max</code> and <code>print_table</code> above the <code>main</code> function so that <code>main</code> can access them despite being defined first. The <code>main</code> function contains the high-level steps of the full program, and defining it first echoes the top-down design of the program. This example includes comments describing the parts of the program that are important to functions and function calls. You can also download and run the full program.<sup><a href="ch01.xhtml#fn1_9" id="rfn1_9">9</a></sup></p>&#13;
<pre>/* This file shows examples of defining and calling C functions.<br/>&#13;
 * It also demonstrates using scanf().<br/>&#13;
 */<br/>&#13;
<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
/* This is an example of a FUNCTION PROTOTYPE.  It declares just the type<br/><span epub:type="pagebreak" id="page_43"/>&#13;
 * information for a function (the function's name, return type, and parameter<br/>&#13;
 * list). A prototype is used when code in main wants to call the function<br/>&#13;
 * before its full definition appears in the file.<br/>&#13;
 */<br/>&#13;
int max(int n1, int n2);<br/>&#13;
<br/>&#13;
/* A prototype for another function.  void is the return type of a function<br/>&#13;
 * that does not return a value<br/>&#13;
 */<br/>&#13;
void print_table(int start, int stop);<br/>&#13;
<br/>&#13;
/* All C programs must have a main function.  This function defines what the<br/>&#13;
 * program does when it begins executing, and it's typically used to organize<br/>&#13;
 * the big-picture behavior of the program.<br/>&#13;
 */<br/>&#13;
int main() {<br/>&#13;
    int x, y, larger;<br/>&#13;
<br/>&#13;
    printf("This program will operate over two int values.\n");<br/>&#13;
<br/>&#13;
    printf("Enter the first value: ");<br/>&#13;
    scanf("%d", &amp;x);<br/>&#13;
<br/>&#13;
    printf("Enter the second value: ");<br/>&#13;
    scanf("%d", &amp;y);<br/>&#13;
<br/>&#13;
    larger = max(x, y);<br/>&#13;
<br/>&#13;
    printf("The larger of %d and %d is %d\n", x, y, larger);<br/>&#13;
<br/>&#13;
    print_table(x, larger);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/* This is an example of a FUNCTION DEFINITION.  It specifies not only the<br/>&#13;
 * function name and type, but it also fully defines the code of its body.<br/>&#13;
 * (Notice, and emulate, the complete function comment!)<br/>&#13;
 */<br/>&#13;
/* Computes the max of two integer values.<br/>&#13;
 *   n1: the first value<br/>&#13;
 *   n2: the other value<br/>&#13;
 *   returns: the larger of n1 and n2<br/>&#13;
 */<br/>&#13;
int max(int n1, int n2)  {<br/>&#13;
    int result;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_44"/>&#13;
    result = n1;<br/>&#13;
<br/>&#13;
    if (n2 &gt; n1) {<br/>&#13;
        result = n2;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return result;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/* prints out the squares from start to stop<br/>&#13;
 *   start: the beginning of the range<br/>&#13;
 *   stop: the end of the range<br/>&#13;
 */<br/>&#13;
void print_table(int start, int stop) {<br/>&#13;
    int i;<br/>&#13;
<br/>&#13;
    for (i = start; i &lt;= stop; i++) {<br/>&#13;
        printf("%d\t", i*i);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("\n");<br/>&#13;
}</pre>&#13;
<h3 class="h3" id="lev1_5">1.5 Arrays and Strings</h3>&#13;
<p class="noindent">An <em>array</em> is a C construct that creates an ordered collection of data elements of the same type and associates this collection with a single program variable. <em>Ordered</em> means that each element is in a specific position in the collection of values (that is, there is an element in position 0, position 1, and so on), not that the values are necessarily sorted. Arrays are one of C’s primary mechanisms for grouping multiple data values and referring to them by a single name. Arrays come in several flavors, but the basic form is a <em>one-dimensional array</em>, which is useful for implementing list-like data structures and strings in C.</p>&#13;
<h4 class="h4" id="lev2_9">1.5.1 Introduction to Arrays</h4>&#13;
<p class="noindent">C arrays can store multiple data values of the <em>same</em> type. In this chapter, we discuss <em>statically declared</em> arrays, meaning that the total capacity (the maximum number of elements that can be stored in an array) is fixed and is defined when the array variable is declared. In the next chapter, we discuss other array types such as “Dynamically Allocated” on <a href="ch02.xhtml#lev3_9">page 153</a> and “Two-Dimensional Arrays” on <a href="ch02.xhtml#lev2_23">page 84</a>.</p>&#13;
<p class="indent">The following code shows Python and C versions of a program that initializes and then prints a collection of integer values. The Python version uses its built-in list type to store the list of values, whereas the C version uses an array of <code>int</code> types to store the collection of values.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>In general, Python provides a high-level list interface to the programmer that hides much of the low-level implementation details. C, on the other hand, exposes a low-level array implementation to the programmer and leaves it up to the programmer to implement higher-level functionality. In other words, arrays enable low-level data storage without higher-level list functionality, such as <code>len</code>, <code>append</code>, <code>insert</code>, and so on.</p>&#13;
<pre># An example Python program using a list.<br/>&#13;
<br/>&#13;
def main():<br/>&#13;
    # create an empty list<br/>&#13;
    my_lst = []<br/>&#13;
<br/>&#13;
    # add 10 integers to the list<br/>&#13;
    for i in range(10):<br/>&#13;
        my_lst.append(i)<br/>&#13;
<br/>&#13;
    # set value at position 3 to 100<br/>&#13;
    my_lst[3] = 100<br/>&#13;
<br/>&#13;
    # print the number of list items<br/>&#13;
    print("list %d items:" % len(my_lst))<br/>&#13;
<br/>&#13;
    # print each element of the list<br/>&#13;
    for i in range(10):<br/>&#13;
        print("%d" % my_lst[i])<br/>&#13;
<br/>&#13;
# call the main function:<br/>&#13;
main()</pre>&#13;
<p class="line">Python version</p>&#13;
<pre>/* An example C program using an array. */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int i, size = 0;<br/>&#13;
<br/>&#13;
    // declare array of 10 ints<br/>&#13;
    int my_arr[10];<br/>&#13;
<br/>&#13;
    // set the value of each array element<br/>&#13;
    for (i = 0; i &lt; 10; i++) {<br/>&#13;
        my_arr[i] = i;<br/>&#13;
        size++;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    // set value at position 3 to 100<br/>&#13;
<span epub:type="pagebreak" id="page_46"/>&#13;
    my_arr[3] = 100;<br/>&#13;
<br/>&#13;
    // print the number of array elements<br/>&#13;
    printf("array of %d items:\n", size);<br/>&#13;
<br/>&#13;
    // print each element of the array<br/>&#13;
    for (i = 0; i &lt; 10; i++) {<br/>&#13;
        printf("%d\n", my_arr[i]);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="line"><em>C version</em></p>&#13;
<p class="indent">The C and Python versions of this program have several similarities, most notably that individual elements can be accessed via <em>indexing</em>, and that index values start at <code>0</code>. That is, both languages refer to the very first element in a collection as the element at position <code>0</code>.</p>&#13;
<p class="indent">The main differences in the C and Python versions of this program relate to the capacity of the list or array and how their sizes (number of elements) are determined. For a Python list:</p>&#13;
<pre>my_lst[3] = 100   # Python syntax to set the element in position 3 to 100.<br/>&#13;
<br/>&#13;
my_lst[0] = 5     # Python syntax to set the first element to 5.</pre>&#13;
<p class="noindent">For a C array:</p>&#13;
<pre>my_arr[3] = 100;  // C syntax to set the element in position 3 to 100.<br/>&#13;
<br/>&#13;
my_arr[0] = 5;    // C syntax to set the first element to 5.</pre>&#13;
<p class="indent">In the Python version, the programmer doesn’t need to specify the capacity of a list in advance: Python automatically increases a list’s capacity as needed by the program. For example, the Python <code>append</code> function automatically increases the size of the Python list and adds the passed value to the end.</p>&#13;
<p class="indent">In contrast, when declaring an array variable in C, the programmer must specify its type (the type of each value stored in the array) and its total capacity (the maximum number of storage locations). For example:</p>&#13;
<pre>int  arr[10];  // declare an array of 10 ints<br/>&#13;
<br/>&#13;
char str[20];  // declare an array of 20 chars</pre>&#13;
<p class="indent">The preceding declarations create one variable named <code>arr</code>, an array of <code>int</code> values with a total capacity of 10, and another variable named <code>str</code>, an array of <code>char</code> values with a total capacity of 20.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>To compute the size of a list (size meaning the total number of values in the list), Python provides a <code>len</code> function that returns the size of any list passed to it. In C, the programmer has to explicitly keep track of the number of elements in the array (for example, the <code>size</code> variable in the C listing on <a href="ch01.xhtml#lev2_10">page 47</a>).</p>&#13;
<p class="indent">Another difference that might not be apparent from looking at the Python and C versions of this program is how the Python list and the C array are stored in memory. C dictates the array layout in program memory, whereas Python hides how lists are implemented from the programmer. In C, individual array elements are allocated in consecutive locations in the program’s memory. For example, the third array position is located in memory immediately following the second array position and immediately before the fourth array position.</p>&#13;
<h4 class="h4" id="lev2_10">1.5.2 Array Access Methods</h4>&#13;
<p class="noindent">Python provides multiple ways to access elements in its lists. C, however, supports only indexing, as described earlier. Valid index values range from 0 to the capacity of the array minus 1. Here are some examples:</p>&#13;
<pre>int i, num;<br/>&#13;
int arr[10];  // declare an array of ints, with a capacity of 10<br/>&#13;
<br/>&#13;
num = 6;      // keep track of how many elements of arr are used<br/>&#13;
<br/>&#13;
// initialize first 5 elements of arr (at indices 0-4)<br/>&#13;
for (i=0; i &lt; 5; i++) {<br/>&#13;
    arr[i] = i * 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
arr[5] = 100; // assign the element at index 5 the value 100</pre>&#13;
<p class="indent">This example declares the array with a capacity of 10 (it has 10 elements), but it only uses the first six (our current collection of values is size 6, not 10). It’s often the case when using statically declared arrays that some of an array’s capacity will remain unused. As a result, we need another program variable to keep track of the actual size (number of elements) in the array (<code>num</code> in this example).</p>&#13;
<p class="indent">Python and C differ in their error-handling approaches when a program attempts to access an invalid index. Python throws an <code>IndexError</code> exception if an invalid index value is used to access elements in a list (e.g., indexing beyond the number of elements in a list). In C, it’s up to the programmer to ensure that their code uses only valid index values when indexing into arrays. As a result, for code like the following that accesses an array element beyond the bounds of the allocated array, the program’s runtime behavior is undefined.</p>&#13;
<pre><span epub:type="pagebreak" id="page_48"/>int array[10];   // an array of size 10 has valid indices 0 through 9<br/>&#13;
<br/>&#13;
array[10] = 100;  // 10 is not a valid index into the array</pre>&#13;
<p class="indent">The C compiler is happy to compile code that accesses array positions beyond the bounds of the array; there is no bounds checking by the compiler or at runtime. As a result, running this code can lead to unexpected program behavior (and the behavior might differ from run to run). It can lead to your program crashing, it can change another variable’s value, or it might have no effect on your program’s behavior. In other words, this situation leads to a program bug that might or might not show up as unexpected program behavior. Thus, as a C programmer, it’s up to you to ensure that your array accesses refer to valid positions!</p>&#13;
<h4 class="h4" id="lev2_11">1.5.3 Arrays and Functions</h4>&#13;
<p class="noindent">The semantics of passing arrays to functions in C is similar to that of passing lists to functions in Python: the function can alter the elements in the passed array or list. Here’s an example function that takes two parameters, an <code>int</code> array parameter (<code>arr</code>), and an <code>int</code> parameter (<code>size</code>):</p>&#13;
<pre>void print_array(int arr[], int size) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; size; i++) {<br/>&#13;
        printf("%d\n", arr[i]);<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>[]</code> after the parameter name tells the compiler that the type of the parameter <code>arr</code> is <em>array of int</em>, not <code>int</code> like the parameter <code>size</code>. In the next chapter, we show an alternate syntax for specifying array parameters. The capacity of the array parameter <code>arr</code> isn’t specified: <code>arr[]</code> means that this function can be called with an array argument of any capacity. Because there is no way to get an array’s size or capacity just from the array variable, functions that are passed arrays almost always also have a second parameter that specifies the array’s size (the <code>size</code> parameter in the preceding example).</p>&#13;
<p class="indent">To call a function that has an array parameter, pass <em>the name of the array</em> as the argument. Here is a C code snippet with example calls to the <code>print_array</code> function:</p>&#13;
<pre>int some[5], more[10], i;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; 5; i++) {  // initialize the first 5 elements of both arrays<br/>&#13;
    some[i] = i * i;<br/>&#13;
    more[i] = some[i];<br/>&#13;
}<br/>&#13;
<br/>&#13;
for (i = 5; i &lt; 10; i++) { // initialize the last 5 elements of "more" array<br/>&#13;
<span epub:type="pagebreak" id="page_49"/>&#13;
    more[i] = more[i-1] + more[i-2];<br/>&#13;
}<br/>&#13;
<br/>&#13;
print_array(some, 5);    // prints all 5 values of "some"<br/>&#13;
print_array(more, 10);   // prints all 10 values of "more"<br/>&#13;
print_array(more, 8);    // prints just the first 8 values of "more"</pre>&#13;
<p class="indent">In C, the name of the array variable is equivalent to the <em>base address</em> of the array (i.e., the memory location of its 0th element). Due to C’s <em>pass by value</em> function call semantics, when you pass an array to a function, each element of the array is <em>not</em> individually passed to the function. In other words, the function isn’t receiving a copy of each array element. Instead, an array parameter gets the <em>value of the array’s base address</em>. This behavior implies that when a function modifies the elements of an array that was passed as a parameter, the changes <em>will</em> persist when the function returns. For example, consider this C program snippet:</p>&#13;
<pre>void test(int a[], int size) {<br/>&#13;
    if (size &gt; 3) {<br/>&#13;
        a[3] = 8;<br/>&#13;
    }<br/>&#13;
    size = 2; // changing parameter does NOT change argument<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int arr[5], n = 5, i;<br/>&#13;
<br/>&#13;
    for (i = 0; i &lt; n; i++) {<br/>&#13;
        arr[i] = i;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("%d %d", arr[3], n);  // prints: 3 5<br/>&#13;
<br/>&#13;
    test(arr, n);<br/>&#13;
    printf("%d %d", arr[3], n);  // prints: 8 5<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The call in <code>main</code> to the <code>test</code> function is passed the argument <code>arr</code>, whose value is the base address of the <code>arr</code> array in memory. The parameter <code>a</code> in the test function gets a copy of this base address value. In other words, parameter <code>a</code> <em>refers to the same array storage locations as its argument</em>, <code>arr</code>. As a result, when the test function changes a value stored in the <code>a</code> array (<code>a[3] = 8</code>), it affects the corresponding position in the argument array (<code>arr[3]</code> is now 8). The reason is that the value of <code>a</code> is the base address of <code>arr</code>, and the value of <code>arr</code> is the base address of <code>arr</code>, so both <code>a</code> and <code>arr</code> refer to the same array (the <span epub:type="pagebreak" id="page_50"/>same storage locations in memory)! <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> shows the stack contents at the point in the execution just before the test function returns.</p>&#13;
<div class="imagec" id="ch1fig4"><img alt="image" src="../images/01fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-4: The stack contents for a function with an array parameter</em></p>&#13;
<p class="indent">Parameter <code>a</code> is passed the value of the base address of the array argument <code>arr</code>, which means they both refer to the same set of array storage locations in memory. We indicate this with the arrow from <code>a</code> to <code>arr</code>. Values that get modified by the function <code>test</code> are highlighted. Changing the value of the parameter <code>size</code> does <em>not</em> change the value of its corresponding argument <code>n</code>, but changing the value of one of the elements referred to by <code>a</code> (e.g., <code>a[3] = 8</code>) does affect the value of the corresponding position in <code>arr</code>.</p>&#13;
<h4 class="h4" id="lev2_12">1.5.4 Introduction to Strings and the C String Library</h4>&#13;
<p class="noindent">Python implements a string type and provides a rich interface for using strings, but there is no corresponding string type in C. Instead, strings are implemented as arrays of <code>char</code> values. Not every character array is used as a C string, but every C string is a character array.</p>&#13;
<p class="indent">Recall that arrays in C might be defined with a larger size than a program ultimately uses. For example, we saw in the “Array Access Methods” section on <a href="ch01.xhtml#lev2_10">page 47</a> that we might declare an array of size 10 but only use the first six positions. This behavior has important implications for strings: we can’t assume that a string’s length is equal to that of the array that stores it. For this reason, strings in C must end with a special character value, the <em>null character</em> (<code>’\0’</code>), to indicate the end of the string.</p>&#13;
<p class="indent">Strings that end with a null character are said to be <em>null-terminated</em>. Although all strings in C <em>should</em> be null-terminated, failing to properly account for null characters is a common source of errors for novice C programmers. When using strings, it’s important to keep in mind that your character arrays must be declared with enough capacity to store each character value in the string plus the null character (<code>’\0’</code>). For example, to store the string <code>"hi"</code>, <span epub:type="pagebreak" id="page_51"/>you need an array of at least three chars (one to store <code>'h'</code>, one to store <code>'i'</code>, and one to store <code>'\0'</code>).</p>&#13;
<p class="indent">Because strings are commonly used, C provides a string library that contains functions for manipulating strings. Programs that use these string library functions need to include the <code>string.h</code> header.</p>&#13;
<p class="indent">When printing the value of a string with <code>printf</code>, use the <code>%s</code> placeholder in the format string. The <code>printf</code> function will print all the characters in the array argument until it encounters the <code>’\0’</code> character. Similarly, string library functions often either locate the end of a string by searching for the <code>’\0’</code> character or add a <code>’\0’</code> character to the end of any string that they modify.</p>&#13;
<p class="indent">Here’s an example that uses strings and string library functions:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;   // include the C string library<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    char str1[10];<br/>&#13;
    char str2[10];<br/>&#13;
    int len;<br/>&#13;
<br/>&#13;
    str1[0] = 'h';<br/>&#13;
    str1[1] = 'i';<br/>&#13;
    str1[2] = '\0';<br/>&#13;
<br/>&#13;
    len = strlen(str1);<br/>&#13;
<br/>&#13;
    printf("%s %d\n", str1, len);  // prints: hi 2<br/>&#13;
<br/>&#13;
    strcpy(str2, str1);     // copies the contents of str1 to str2<br/>&#13;
    printf("%s\n", str2);   // prints:  hi<br/>&#13;
<br/>&#13;
    strcpy(str2, "hello");  // copy the string "hello" to str2<br/>&#13;
    len = strlen(str2);<br/>&#13;
    printf("%s has %d chars\n", str2, len);   // prints: hello has 5 chars<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>strlen</code> function in the C string library returns the number of characters in its string argument. A string’s terminating null character doesn’t count as part of the string’s length, so the call to <code>strlen(str1)</code> returns 2 (the length of the string <code>"hi"</code>). The <code>strcpy</code> function copies one character at a time from a source string (the second parameter) to a destination string (the first parameter) until it reaches a null character in the source.</p>&#13;
<p class="indent">Note that most C string library functions expect the call to pass in a character array that has enough capacity for the function to perform its job. For example, you wouldn’t want to call <code>strcpy</code> with a destination string that isn’t large enough to contain the source; doing so will lead to undefined behavior in your program!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>C string library functions also require that string values passed to them are correctly formed, with a terminating <code>’\0’</code> character. It’s up to you as the C programmer to ensure that you pass in valid strings for C library functions to manipulate. Thus, in the call to <code>strcpy</code> in the preceding example, if the source string (<code>str1</code>) was not initialized to have a terminating <code>’\0’</code> character, <code>strcpy</code> would continue beyond the end of the <code>str1</code> array’s bounds, leading to undefined behavior that could cause it to crash.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> STRCPY CAN BE AN UNSAFE FUNCTION</strong></p>&#13;
<p class="note-w">The previous example uses the <code>strcpy</code> function safely. In general, though, <code>strcpy</code> poses a security risk because it assumes that its destination is large enough to store the entire string, which may not always be the case (for example, if the string comes from user input).</p>&#13;
<p class="note-w">We chose to show <code>strcpy</code> now to simplify the introduction to strings, but we illustrate safer alternatives in the “Strings and the String Library" section.</p>&#13;
<p class="indent">In the next chapter, we discuss C strings and the string library in more detail.</p>&#13;
<h3 class="h3" id="lev1_6">1.6 Structs</h3>&#13;
<p class="noindent">Arrays and structs are the two ways in which C supports creating collections of data elements. Arrays are used to create an ordered collection of data elements of the same type, whereas <em>structs</em> are used to create a collection of data elements of <em>different types</em>. A C programmer can combine array and struct building blocks in many different ways to create more complex data types and structures. This section introduces structs, and in the next chapter we characterize structs in more detail (“C Structs” on <a href="ch02.xhtml#lev1_15">page 103</a>) and show how you can combine them with arrays (“Arrays of Structs” on <a href="ch02.xhtml#lev2_30">page 198</a>).</p>&#13;
<p class="indent">C is not an object-oriented language; thus, it doesn’t support classes. It does, however, support defining structured types, which are like the data part of classes. A <code>struct</code> is a type used to represent a heterogeneous collection of data; it’s a mechanism for treating a set of different types as a single, coherent unit. C structs provide a level of abstraction on top of individual data values, treating them as a single type. For example, a student has a name, age, grade point average (GPA), and graduation year. A programmer could define a new <code>struct</code> type to combine those four data elements into a single <code>struct student</code> variable that contains a name value (type <code>char []</code>, to hold a string), an age value (type <code>int</code>), a GPA value (type <code>float</code>), and a graduation year value (type <code>int</code>). A single variable of this struct type can store all four pieces of data for a particular student; for example, (“Freya”, 19, 3.7, 2021).</p>&#13;
<p class="indent">There are three steps to defining and using <code>struct</code> types in C programs:</p>&#13;
<div class="number">&#13;
<p class="number">1. Define a new <code>struct</code> type that represents the structure.</p>&#13;
<p class="number">2. Declare variables of the new <code>struct</code> type.</p>&#13;
<p class="number">3. Use dot (<code>.</code>) notation to access individual field values of the variable.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_13"><span epub:type="pagebreak" id="page_53"/>1.6.1 Defining a Struct Type</h4>&#13;
<p class="noindent">A struct type definition should appear <em>outside of any function</em>, typically near the top of the program’s <code>.c</code> file. The syntax for defining a new struct type is the following (<code>struct</code> is a reserved keyword):</p>&#13;
<pre>struct <span class="codeitalic1">&lt;struct_name&gt;</span> {<br/>&#13;
    <span class="codeitalic1">&lt;field 1 type&gt; &lt;field 1 name&gt;</span>;<br/>&#13;
    <span class="codeitalic1">&lt;field 2 type&gt; &lt;field 2 name&gt;</span>;<br/>&#13;
    <span class="codeitalic1">&lt;field 3 type&gt; &lt;field 3 name&gt;</span>;<br/>&#13;
    ...<br/>&#13;
};</pre>&#13;
<p class="indent">Here’s an example of defining a new <code>struct studentT</code> type for storing student data:</p>&#13;
<pre>struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int age;<br/>&#13;
    float gpa;<br/>&#13;
    int grad_yr;<br/>&#13;
};</pre>&#13;
<p class="indent">This struct definition adds a new type to C’s type system, and the type’s name is <code>struct studentT</code>. This struct defines four fields, and each field definition includes the type and name of the field. Note that in this example, the <code>name</code> field’s type is a character array, for use as a string (see “Introduction to Strings and the C String Library” on <a href="ch01.xhtml#lev2_12">page 50</a>).</p>&#13;
<h4 class="h4" id="lev2_14">1.6.2 Declaring Variables of Struct Types</h4>&#13;
<p class="noindent">Once the type has been defined, you can declare variables of the new type, <code>struct</code> <code>studentT</code>. Note that unlike the other types we’ve encountered so far that consist of just a single word (for example, <code>int</code>, <code>char</code>, and <code>float</code>), the name of our new struct type is two words, <code>struct studentT</code>.</p>&#13;
<pre>struct studentT student1, student2; // student1, student2 are struct studentT</pre>&#13;
<h4 class="h4" id="lev2_15">1.6.3 Accessing Field Values</h4>&#13;
<p class="noindent">To access field values in a struct variable, use <em>dot notation</em>:</p>&#13;
<pre><span class="codeitalic1">&lt;variable name&gt;</span>.<span class="codeitalic1">&lt;field name&gt;</span></pre>&#13;
<p class="indent">When accessing structs and their fields, carefully consider the types of the variables you’re using. Novice C programmers often introduce bugs into their programs by failing to account for the types of struct fields. <a href="ch01.xhtml#ch1tab2">Table 1-2</a> shows the types of several expressions surrounding our <code>struct studentT</code> type.</p>&#13;
<p class="tabcap" id="ch1tab2"><span epub:type="pagebreak" id="page_54"/><strong>Table 1-2:</strong> The Types Associated with Various <code>struct studentT</code> Expressions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>C type</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>student1</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>struct studentT</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>student1.age</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">integer (<code>int</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>student1.name</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">array of characters (<code>char []</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>student1.name[3]</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">character (<code>char</code>), the type stored in each position of the <code>name</code> array</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Here are some examples of assigning a <code>struct studentT</code> variable’s fields:</p>&#13;
<pre>// The 'name' field is an array of characters, so we can use the 'strcpy'<br/>&#13;
// string library function to fill in the array with a string value.<br/>&#13;
strcpy(student1.name, "Kwame Salter");<br/>&#13;
<br/>&#13;
// The 'age' field is an integer.<br/>&#13;
student1.age = 18 + 2;<br/>&#13;
<br/>&#13;
// The 'gpa' field is a float.<br/>&#13;
student1.gpa = 3.5;<br/>&#13;
<br/>&#13;
// The 'grad_yr' field is an int<br/>&#13;
student1.grad_yr = 2020;<br/>&#13;
student2.grad_yr = student1.grad_yr;</pre>&#13;
<p class="indent"><a href="ch01.xhtml#ch1fig5">Figure 1-5</a> illustrates the layout of the <code>student1</code> variable in memory after the field assignments in the preceding example. Only the struct variable’s fields (the areas in boxes) are stored in memory. The field names are labeled on the figure for clarity, but to the C compiler, fields are simply storage locations or <em>offsets</em> from the start of the struct variable’s memory. For example, based on the definition of a <code>struct studentT</code>, the compiler knows that to access the field named <code>gpa</code>, it must skip past an array of 64 characters (<code>name</code>) and one integer (<code>age</code>). Note that in the figure, the <code>name</code> field only depicts the first six characters of the 64-character array.</p>&#13;
<div class="imagec" id="ch1fig5"><img alt="image" src="../images/01fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-5: The <code>student1</code> variable’s memory after assigning each of its fields</em></p>&#13;
<p class="indent">C struct types are <em>lvalues</em>, meaning they can appear on the left side of an assignment statement. Thus, a struct variable can be assigned the value of another struct variable using a simple assignment statement. The field values of the struct on the right side of the assignment statement are <em>copied</em> to <span epub:type="pagebreak" id="page_55"/>the field values of the struct on the left side of the assignment statement. In other words, the contents of memory of one struct are copied to the memory of the other. Here’s an example of assigning a struct’s values in this way:</p>&#13;
<pre>student2 = student1;  // student2 gets the value of student1<br/>&#13;
                      // (student1's field values are copied to<br/>&#13;
                      //  corresponding field values of student2)<br/>&#13;
<br/>&#13;
strcpy(student2.name, "Frances Allen");  // change one field value</pre>&#13;
<p class="indent"><a href="ch01.xhtml#ch1fig6">Figure 1-6</a> shows the values of the two student variables after the assignment statement and call to <code>strcpy</code> have executed. Note that the figure depicts the <code>name</code> fields as the string values they contain rather than the full array of 64 characters.</p>&#13;
<div class="imagec" id="ch1fig6"><img alt="image" src="../images/01fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-6: Layout of the <code>student1</code> and <code>student2</code> structs after executing the struct assignment and <code>strcpy</code> call</em></p>&#13;
<p class="indent">C provides a <code>sizeof</code> operator that takes a type and returns the number of bytes used by the type. The <code>sizeof</code> operator can be used on any C type, including struct types, to see how much memory space a variable of that type needs. For example, we can print the size of a <code>struct studentT</code> type:</p>&#13;
<pre>// Note: the '%lu' format placeholder specifies an unsigned long value.<br/>&#13;
printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));</pre>&#13;
<p class="indent">When run, this line should print out a value of <em>at least</em> 76 bytes, because 64 characters are in the <code>name</code> array (1 byte for each <code>char</code>), 4 bytes for the <code>int age</code> field, 4 bytes for the <code>float gpa</code> field, and 4 bytes for the <code>int</code> <code>grad_yr</code> field. The exact number of bytes might be larger than 76 on some machines.</p>&#13;
<p class="indent">Here’s a full example program (available for download<sup><a href="ch01.xhtml#fn1_10" id="rfn1_10">10</a></sup>) that defines and demonstrates the use of our <code>struct studentT</code> type:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
// Define a new type: struct studentT<br/>&#13;
// Note that struct definitions should be outside function bodies.<br/>&#13;
struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int age;<br/>&#13;
    float gpa;<br/>&#13;
    int grad_yr;<br/>&#13;
<span epub:type="pagebreak" id="page_56"/>&#13;
};<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    struct studentT student1, student2;<br/>&#13;
<br/>&#13;
    strcpy(student1.name, "Kwame Salter");  // name field is a char array<br/>&#13;
    student1.age = 18 + 2;                  // age field is an int<br/>&#13;
    student1.gpa = 3.5;                     // gpa field is a float<br/>&#13;
    student1.grad_yr = 2020;                // grad_yr field is an int<br/>&#13;
<br/>&#13;
    /* Note: printf doesn't have a format placeholder for printing a<br/>&#13;
     * struct studentT (a type we defined).  Instead, we'll need to<br/>&#13;
     * individually pass each field to printf. */<br/>&#13;
    printf("name: %s age: %d gpa: %g, year: %d\n",<br/>&#13;
           student1.name, student1.age, student1.gpa, student1.grad_yr);<br/>&#13;
<br/>&#13;
    /* Copy all the field values of student1 into student2. */<br/>&#13;
    student2 = student1;<br/>&#13;
<br/>&#13;
    /* Make a few changes to the student2 variable. */<br/>&#13;
    strcpy(student2.name, "Frances Allen");<br/>&#13;
    student2.grad_yr = student1.grad_yr + 1;<br/>&#13;
<br/>&#13;
    /* Print the fields of student2. */<br/>&#13;
    printf("name: %s age: %d gpa: %g, year: %d\n",<br/>&#13;
           student2.name, student2.age, student2.gpa, student2.grad_yr);<br/>&#13;
<br/>&#13;
    /* Print the size of the struct studentT type. */<br/>&#13;
    printf("number of bytes in student struct: %lu\n", sizeof(struct studentT));<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">When run, this program outputs the following:</p>&#13;
<pre>name: Kwame Salter age: 20 gpa: 3.5, year: 2020 <br/>&#13;
name: Frances Allen age: 20 gpa: 3.5, year: 2021 <br/>&#13;
number of bytes in student struct: 76</pre>&#13;
<div class="g-box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_57"/>LVALUES</p>&#13;
<p class="noindentt">An <em>lvalue</em> is an expression that can appear on the left side of an assignment statement. It’s an expression that represents a memory storage location. As we introduce C pointer types and examples of creating more complicated structures that combine C arrays, structs, and pointers, it’s important to think carefully about types and to keep in mind which C expressions are valid lvalues (which can be used on the left side of an assignment statement).</p>&#13;
<p class="noindentt">From what we know about C so far, single variables of base types, array elements, and structs are all lvalues. The name of a statically declared array is <em>not</em> an lvalue (you cannot change the base address of a statically declared array in memory). The following example code snippet illustrates valid and invalid C assignment statements based on the lvalue status of different types:</p>&#13;
<pre>struct studentT {<br/>&#13;
    char name[32];<br/>&#13;
    int  age;<br/>&#13;
    float gpa;<br/>&#13;
    int  grad_yr;<br/>&#13;
};<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    struct studentT  student1, student2;<br/>&#13;
    int x;<br/>&#13;
    char arr[10], ch;<br/>&#13;
<br/>&#13;
    x = 10;                 // Valid C: x is an lvalue<br/>&#13;
    ch = 'm';               // Valid C: ch is an lvalue<br/>&#13;
    student1.age = 18;      // Valid C: age field is an lvalue<br/>&#13;
    student2 = student1;    // Valid C: student2 is an lvalue<br/>&#13;
    arr[3] = ch;            // Valid C: arr[3] is an lvalue<br/>&#13;
<br/>&#13;
    x + 1 = 8;       // Invalid C: x+1 is not an lvalue<br/>&#13;
    arr = "hello";   // Invalid C: arr is not an lvalue<br/>&#13;
                     //  cannot change base addr of statically declared array<br/>&#13;
                     //  (use strcpy to copy the string value "hello" to arr)<br/>&#13;
<br/>&#13;
    student1.name = student2.name;  // Invalid C: name field is not an lvalue<br/>&#13;
                                    // (the base address of a statically<br/>&#13;
                                    //  declared array cannot be changed)</pre>&#13;
</div>&#13;
<h4 class="h4" id="lev2_16"><span epub:type="pagebreak" id="page_58"/>1.6.4 Passing Structs to Functions</h4>&#13;
<p class="noindent">In C, arguments of all types are <em>passed by value</em> to functions. Thus, if a function has a struct type parameter, then when called with a struct argument, the argument’s <em>value</em> is passed to its parameter, meaning that the parameter gets a copy of its argument’s value. The value of a struct variable is the contents of its memory, which is why we can assign the fields of one struct to be the same as another struct in a single assignment statement like this:</p>&#13;
<pre>student2 = student1;</pre>&#13;
<p class="indent">Because the value of a struct variable represents the full contents of its memory, passing a struct as an argument to a function gives the parameter a <em>copy</em> of all the argument struct’s field values. If the function changes the field values of a struct parameter, the changes to the parameter’s field values have <em>no effect</em> on the corresponding field values of the argument. That is, changes to the parameter’s fields only modify values in the parameter’s memory locations for those fields, not in the argument’s memory locations for those fields.</p>&#13;
<p class="indent">Here’s a full example program (available for download<sup><a href="ch01.xhtml#fn1_11" id="rfn1_11">11</a></sup>) using the <code>checkID</code> function that takes a struct parameter:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
/* struct type definition: */<br/>&#13;
struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int  age;<br/>&#13;
    float gpa;<br/>&#13;
    int  grad_yr;<br/>&#13;
};<br/>&#13;
<br/>&#13;
/* function prototype (prototype: a declaration of the<br/>&#13;
 *    checkID function so that main can call it, its full<br/>&#13;
 *    definition is listed after main function in the file):<br/>&#13;
 */<br/>&#13;
int checkID(struct studentT s1, int min_age);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int can_vote;<br/>&#13;
    struct studentT student;<br/>&#13;
<br/>&#13;
    strcpy(student.name, "Ruth");<br/>&#13;
    student.age = 17;<br/>&#13;
    student.gpa = 3.5;<br/>&#13;
    student.grad_yr = 2021;<br/>&#13;
<br/>&#13;
    can_vote = checkID(student, 18);<br/>&#13;
<span epub:type="pagebreak" id="page_59"/>&#13;
    if (can_vote) {<br/>&#13;
        printf("%s is %d years old and can vote.\n",<br/>&#13;
                student.name, student.age);<br/>&#13;
    } else {<br/>&#13;
        printf("%s is only %d years old and cannot vote.\n",<br/>&#13;
                student.name, student.age);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*  check if a student is at least the min age<br/>&#13;
 *    s: a student<br/>&#13;
 *    min_age: a minimum age value to test<br/>&#13;
 *    returns: 1 if the student is min_age or older, 0 otherwise<br/>&#13;
 */<br/>&#13;
int checkID(struct studentT s, int min_age) {<br/>&#13;
    int ret = 1;  // initialize the return value to 1 (true)<br/>&#13;
<br/>&#13;
    if (s.age &lt; min_age) {<br/>&#13;
        ret = 0;  // update the return value to 0 (false)<br/>&#13;
<br/>&#13;
        // let's try changing the student's age<br/>&#13;
        s.age = min_age + 1;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("%s is %d years old\n", s.name, s.age);<br/>&#13;
<br/>&#13;
    return ret;<br/>&#13;
}</pre>&#13;
<p class="indent">When <code>main</code> calls <code>checkID</code>, the value of the <code>student</code> struct (a copy of the memory contents of all its fields) is passed to the <code>s</code> parameter. When the function changes the value of its parameter’s <code>age</code> field, it <em>doesn’t</em> affect the <code>age</code> field of its argument (<code>student</code>). This behavior can be seen by running the program, which outputs the following:</p>&#13;
<pre>Ruth is 19 years old<br/>&#13;
Ruth is only 17 years old and cannot vote.</pre>&#13;
<p class="indent">The output shows that when <code>checkID</code> prints the <code>age</code> field, it reflects the function’s change to the <code>age</code> field of the parameter <code>s</code>. However, after the function call returns, <code>main</code> prints the <code>age</code> field of <code>student</code> with the same value it had prior to the <code>checkID</code> call. <a href="ch01.xhtml#ch1fig7">Figure 1-7</a> illustrates the contents of the call stack just before the <code>checkID</code> function returns.</p>&#13;
<span epub:type="pagebreak" id="page_60"/>&#13;
<div class="imagec" id="ch1fig7"><img alt="image" src="../images/01fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 1-7: The contents of the call stack before returning from the <code>checkID</code> function</em></p>&#13;
<p class="indent">Understanding the pass by value semantics of struct parameters is particularly important when a struct contains a statically declared array field (like the <code>name</code> field in <code>struct studentT</code>). When such a struct is passed to a function, the struct argument’s entire memory contents, including every array element in the array field, is copied to its parameter. If the parameter struct’s array contents are changed by the function, those changes will <em>not</em> persist after the function returns. This behavior might seem odd given what we know about how arrays are passed to functions (“Arrays and Functions” on <a href="ch01.xhtml#lev2_11">page 48</a>), but it’s consistent with the struct copying behavior described earlier.</p>&#13;
<h3 class="h3" id="lev1_7">1.7 Summary</h3>&#13;
<p class="noindent">In this chapter, we introduced many parts of the C programming language by comparing them to similar language constructs in Python, a language that many readers might know. C has similar language features to those of many other high-level imperative and object-oriented programming languages, including variables, loops, conditionals, functions, and I/O. Some key differences between the C and Python features we discussed include C requiring that all variables be declared of a specific type before they’re used, and that C arrays and strings are a lower-level abstraction than Python’s lists and strings. The lower-level abstractions allow a C programmer more control over how their program accesses its memory and thus more control over their program’s efficiency.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_61"/>In the next chapter, we cover the C programming language in detail. We revisit in more depth the many language features presented in this chapter, and we introduce some new C language features, most notably C pointer variables and support for dynamic memory allocation.</p>&#13;
<h3 class="h3" id="lev1_8">Notes</h3>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_1" id="fn1_1">1.</a> <em><a href="https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c">https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c</a></em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_2" id="fn1_2">2.</a> <em><a href="https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py">https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py</a></em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_3" id="fn1_3">3.</a> <em><a href="https://gcc.gnu.org">https://gcc.gnu.org</a></em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_4" id="fn1_4">4.</a> See <em><a href="https://www.cs.swarthmore.edu/help/editors.html">https://www.cs.swarthmore.edu/help/editors.html</a></em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_5" id="fn1_5">5.</a> See “Using make and writing Makefile” at <em><a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html">https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html</a></em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_6" id="fn1_6">6.</a> <em>book/modules/C_intro/assets/attachments/whileLoop1.c</em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_7" id="fn1_7">7.</a> <em>book/modules/C_intro/assets/attachments/whileLoop2.c</em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_8" id="fn1_8">8.</a> <em>book/modules/C_intro/assets/attachments/forLoop2.c</em></p>&#13;
<p class="fnote"><a href="ch01.xhtml#rfn1_9" id="fn1_9">9.</a> <em>book/modules/C_intro/assets/attachments/function.c</em></p>&#13;
<p class="fnote1"><a href="ch01.xhtml#rfn1_10" id="fn1_10">10.</a> <em>book/modules/C_intro/assets/attachments/studentTstruct.c</em></p>&#13;
<p class="fnote1"><a href="ch01.xhtml#rfn1_11" id="fn1_11">11.</a> <em>book/modules/C_intro/assets/attachments/structfunc.c</em></p>&#13;
<span epub:type="pagebreak" id="page_62"/>&#13;
</body></html>