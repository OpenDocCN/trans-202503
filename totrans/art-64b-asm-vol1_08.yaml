- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses arithmetic computation in assembly language. By the end
    of this chapter, you should be able to translate arithmetic expressions and assignment
    statements from high-level languages like Pascal and C/C++ into x86-64 assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 x86-64 Integer Arithmetic Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you learn how to encode arithmetic expressions in assembly language,
    it would be a good idea to first discuss the remaining arithmetic instructions
    in the x86-64 instruction set. Previous chapters have covered most of the arithmetic
    and logical instructions, so this section covers the few remaining instructions
    you’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 Sign- and Zero-Extension Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several arithmetic operations require sign- or zero-extended values before the
    operation. So let’s first consider the sign- and zero-extension instructions.
    The x86-64 provides several instructions to sign- or zero-extend a smaller number
    to a larger number. [Table 6-1](#table6-1) lists instructions that will sign-extend
    the AL, AX, EAX, and RAX registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Instructions for Extending AL, AX, EAX, and RAX'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cbw` | Converts the byte in AL to a word in AX via sign extension |'
  prefs: []
  type: TYPE_TB
- en: '| `cwd` | Converts the word in AX to a double word in DX:AX via sign extension
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cdq` | Converts the double word in EAX to a quad word in EDX:EAX via sign
    extension |'
  prefs: []
  type: TYPE_TB
- en: '| `cqo` | Converts the quad word in RAX to an octal word in RDX:RAX via sign
    extension |'
  prefs: []
  type: TYPE_TB
- en: '| `cwde` | Converts the word in AX to a double word in EAX via sign extension
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cdqe` | Converts the double word in EAX to a quad word in RAX via sign extension
    |'
  prefs: []
  type: TYPE_TB
- en: Note that the `cwd` (*convert word to double word*) instruction does not sign-extend
    the word in AX to a double word in EAX. Instead, it stores the HO word of the
    sign extension into the DX register (the notation DX:AX indicates that you have
    a double-word value, with DX containing the upper 16 bits and AX containing the
    lower 16 bits of the value). If you want the sign extension of AX to go into EAX,
    you should use the `cwde` (*convert word to double word, extended*) instruction.
    In a similar fashion, the `cdq` instruction sign-extends EAX into EDX:EAX. Use
    the `cdqe` instruction if you want to sign-extend EAX into RAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'For general sign-extension operations, the x86-64 provides an extension of
    the `mov` instruction, `movsx` (*move with sign extension*), that copies data
    and sign-extends the data while copying it. The `movsx` instruction’s syntax is
    similar to that of `mov`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The big difference in syntax between these instructions and the `mov` instruction
    is that the destination operand must usually be larger than the source operand.^([1](#c06-footnote-1))
    For example, if the source operand is a byte, then the destination operand must
    be a word, dword, or qword. The destination operand must also be a register; the
    source operand, however, can be a memory location.^([2](#c06-footnote-2)) The
    `movsx` instruction does not allow constant operands.
  prefs: []
  type: TYPE_NORMAL
- en: For whatever reason, MASM requires a different instruction mnemonic (instruction
    name) when sign-extending a 32-bit operand into a 64-bit register (`movsxd` rather
    than `movsx`).
  prefs: []
  type: TYPE_NORMAL
- en: To zero-extend a value, you can use the `movzx` instruction. It does not have
    the restrictions of `movsx`; as long as the destination operand is larger than
    the source operand, the instruction works fine. It allows 8 to 16, 32, or 64 bits,
    and 16 to 32 or 64 bits. There is no 32- to 64-bit version (it turns out this
    is unnecessary).
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 CPUs, for historical reasons, will always zero-extend a register
    from 32 bits to 64 bits when performing 32-bit operations. Therefore, to zero-extend
    a 32-bit register into a 64-bit register, you need only move the (32-bit) register
    into itself; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Zero-extending certain 8-bit registers (AL, BL, CL, and DL) into their corresponding
    16-bit registers is easily accomplished without using `movzx` by loading the complementary
    HO register (AH, BH, CH, or DH) with 0\. To zero-extend AX into DX:AX or EAX into
    EDX:EAX, all you need to do is load DX or EDX with 0.^([3](#c06-footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: Because of instruction-encoding limitations, the x86-64 does not allow you to
    zero- or sign-extend the AH, BH, CH, or DH registers into any of the 64-bit registers.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2 The mul and imul Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve already seen a subset of the `imul` instructions available in the x86-64
    instruction set (see “The imul Instruction” in Chapter 4). This section presents
    the extended-precision version of `imul` along with the unsigned `mul` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication instructions provide you with another taste of irregularity
    in the x86-64’s instruction set. Instructions like `add`, `sub`, and many others
    in the x86-64 instruction set support two operands, just like the `mov` instruction.
    Unfortunately, there weren’t enough bits in the original 8086 opcode byte to support
    all instructions, so the x86-64 treats the `mul` (*unsigned multiply*) and `imul`
    (*signed integer multiply*) instructions as single-operand instructions, just
    like the `inc`, `dec`, and `neg` instructions. Of course, multiplication *is*
    a two-operand function. To work around this fact, the x86-64 always assumes the
    accumulator (AL, AX, EAX, or RAX) is the destination operand.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the `mul` and `imul` instructions is that you cannot use
    them to multiply the accumulator by a constant. Intel quickly discovered the need
    to support multiplication by a constant and added the more general versions of
    the `imul` instruction to overcome this problem. Nevertheless, you must be aware
    that the basic `mul` and `imul` instructions do not support the full range of
    operands as the `imul` appearing in Chapter 4 does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiply instruction has two forms: unsigned multiplication (`mul`) and
    signed multiplication (`imul`). Unlike addition and subtraction, you need separate
    instructions for signed and unsigned operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The single-operand multiply instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsigned multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Signed (integer) multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result of multiplying two *n*-bit values may require as many as 2 × *n*
    bits. Therefore, if the operand is an 8-bit quantity, the result could require
    16 bits. Likewise, a 16-bit operand produces a 32-bit result, a 32-bit operand
    produces 64 bits, and a 64-bit operand requires as many as 128 bits to hold the
    result. [Table 6-2](#table6-2) lists the various computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: `mul` and `imul` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Computes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mul` `operand`[8] | AX = AL × *operand*[8] (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `imul` `operand`[8] | AX = AL × *operand*[8] (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `mul` `operand`[16] | DX:AX = AX × *operand*[16] (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `imul` `operand`[16] | DX:AX = AX × *operand*[16] (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `mul` `operand`[32] | EDX:EAX = EAX × *operand*[32] (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `imul` `operand`[32] | EDX:EAX = EAX × *operand*[32] (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `mul` `operand`[64] | RDX:RAX = RAX × *operand*[64] (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `imul` `operand`[64] | RDX:RAX = RAX × *operand*[64] (signed) |'
  prefs: []
  type: TYPE_TB
- en: If an 8×8-, 16×16-, 32×32-, or 64×64-bit product requires more than 8, 16, 32,
    or 64 bits (respectively), the `mul` and `imul` instructions set the carry and
    overflow flags. `mul` and `imul` scramble the sign and zero flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the single-operand `mul` and `imul` instructions quite a lot when
    you learn about extended-precision arithmetic in Chapter 8. Unless you’re doing
    multiprecision work, however, you’ll probably want to use the more generic multi-operand
    version of the `imul` instruction in place of the extended-precision `mul` or
    `imul`. However, the generic `imul` (see Chapter 4) is not a complete replacement
    for these two instructions; in addition to the number of operands, several differences
    exist. The following rules apply specifically to the generic (multi-operand) `imul`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t an 8×8-bit multi-operand `imul` instruction available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generic `imul` instruction does not produce a 2×*n*-bit result, but truncates
    the result to *n* bits. That is, a 16×16-bit multiplication produces a 16-bit
    result. Likewise, a 32×32-bit multiplication produces a 32-bit result. These instructions
    set the carry and overflow flags if the result does not fit into the destination
    register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.3 The div and idiv Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The x86-64 divide instructions perform a 128/64-bit division, a 64/32-bit division,
    a 32/16-bit division, or a 16/8-bit division. These instructions take the following
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `div` instruction is an unsigned division operation. If the operand is an
    8-bit operand, `div` divides the AX register by the operand, leaving the quotient
    in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, the
    `div` instruction divides the 32-bit quantity in DX:AX by the operand, leaving
    the quotient in AX and the remainder in DX. With 32-bit operands, `div` divides
    the 64-bit value in EDX:EAX by the operand, leaving the quotient in EAX and the
    remainder in EDX. Finally, with 64-bit operands, `div` divides the 128-bit value
    in RDX:RAX by the operand, leaving the quotient in RAX and the remainder in RDX.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no variant of the `div` or `idiv` instructions that allows you to
    divide a value by a constant. If you want to divide a value by a constant, you
    need to create a memory object (preferably in the `.const` section) that is initialized
    with the constant, and then use that memory value as the `div`/`idiv` operand.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `idiv` instruction computes a signed quotient and remainder. The syntax
    for the `idiv` instruction is identical to `div` (except for the use of the `idiv`
    mnemonic), though creating signed operands for `idiv` may require a different
    sequence of instructions prior to executing `idiv` than for `div`.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot, on the x86-64, simply divide one unsigned 8-bit value by another.
    If the denominator is an 8-bit value, the numerator must be a 16-bit value. If
    you need to divide one unsigned 8-bit value by another, you must zero-extend the
    numerator to 16 bits by loading the numerator into the AL register and then moving
    0 into the AH register. *Failing to zero-extend AL before executing* `div` *may
    cause the x86-64 to produce incorrect results*! When you need to divide two 16-bit
    unsigned values, you must zero-extend the AX register (which contains the numerator)
    into the DX register. To do this, just load 0 into the DX register. If you need
    to divide one 32-bit value by another, you must zero-extend the EAX register into
    EDX (by loading a 0 into EDX) before the division. Finally, to divide one 64-bit
    number by another, you must zero-extend RAX into RDX (for example, using an `xor
    rdx, rdx` instruction) prior to the division.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with signed integer values, you will need to sign-extend AL into
    AX, AX into DX, EAX into EDX, or RAX into RDX before executing `idiv`. To do so,
    use the `cbw`, `cwd`, `cdq`, or `cqo` instructions.^([4](#c06-footnote-4)) Failure
    to do so may produce incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64’s divide instructions have one other issue: you can get a fatal
    error when using this instruction. First, of course, you can attempt to divide
    a value by 0\. Another problem is that the quotient may be too large to fit into
    the RAX, EAX, AX, or AL register. For example, the 16/8-bit division 8000h/2 produces
    the quotient 4000h with a remainder of 0\. 4000h will not fit into 8 bits. If
    this happens, or you attempt to divide by 0, the x86-64 will generate a division
    exception or integer overflow exception. This usually means your program will
    crash. If this happens to you, chances are you didn’t sign- or zero-extend your
    numerator before executing the division operation. Because this error may cause
    your program to crash, you should be very careful about the values you select
    when using division.'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 leaves the carry, overflow, sign, and zero flags undefined after
    a division operation. Therefore, you cannot test for problems after a division
    operation by checking the flag bits.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.4 The cmp Instruction, Revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in “The cmp Instruction and Corresponding Conditional Jumps” in Chapter
    2, the `cmp` instruction updates the x86-64’s flags according to the result of
    the subtraction operation (`leftOperand` `-` `rightOperand`). The x86-64 sets
    the flags in an appropriate fashion so that we can read this instruction as “compare
    `leftOperand` to `rightOperand`.” You can test the result of the comparison by
    using the conditional set instructions to check the appropriate flags in the FLAGS
    register (see “The setcc Instructions” on page 295) or the conditional jump instructions
    (Chapter 2 or Chapter 7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the first place to start when exploring the `cmp` instruction is to
    look at exactly how it affects the flags. Consider the following `cmp` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction performs the computation AX – BX and sets the flags depending
    on the result of the computation. The flags are set as follows (also see [Table
    6-3](#table6-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ZF**'
  prefs: []
  type: TYPE_NORMAL
- en: The zero flag is set if and only if AX = BX. This is the only time AX – BX produces
    a 0 result. Hence, you can use the zero flag to test for equality or inequality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SF**'
  prefs: []
  type: TYPE_NORMAL
- en: The sign flag is set to 1 if the result is negative. At first glance, you might
    think that this flag would be set if AX is less than BX, but this isn’t always
    the case. If AX = 7FFFh and BX = –1 (0FFFFh), then subtracting AX from BX produces
    8000h, which is negative (and so the sign flag will be set). So, for signed comparisons
    anyway, the sign flag doesn’t contain the proper status. For unsigned operands,
    consider AX = 0FFFFh and BX = 1\. Here, AX is greater than BX, but their difference
    is 0FFFEh, which is still negative. As it turns out, the sign flag and the overflow
    flag, taken together, can be used for comparing two signed values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OF**'
  prefs: []
  type: TYPE_NORMAL
- en: The overflow flag is set after a `cmp` operation if the difference of AX and
    BX produced an overflow or underflow. As mentioned previously, the sign and overflow
    flags are both used when performing signed comparisons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CF**'
  prefs: []
  type: TYPE_NORMAL
- en: The carry flag is set after a `cmp` operation if subtracting BX from AX requires
    a borrow. This occurs only when AX is less than BX, where AX and BX are both unsigned
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 6-3: Condition Code Settings After `cmp`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unsigned operands** | **Signed operands** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ZF: Equality/inequality | ZF: Equality/inequality |'
  prefs: []
  type: TYPE_TB
- en: '| CF: Left `<` Right (C = 1) Left `≥` Right (C = 0) | CF: No meaning |'
  prefs: []
  type: TYPE_TB
- en: '| SF: No meaning | SF: See discussion in this section |'
  prefs: []
  type: TYPE_TB
- en: '| OF: No meaning | OF: See discussion in this section |'
  prefs: []
  type: TYPE_TB
- en: 'Given that the `cmp` instruction sets the flags in this fashion, you can test
    the comparison of the two operands with the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For signed comparisons, the SF (sign) and OF (overflow) flags, taken together,
    have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: If [(SF = 0) and (OF = 1)] or [(SF = 1) and (OF = 0)], then `Left` `<` `Right`
    for a signed comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If [(SF = 0) and (OF = 0)] or [(SF = 1) and (OF = 1)], then `Left` `≥` `Right`
    for a signed comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that (SF `xor` OF) is 1 if the left operand is less than the right operand.
    Conversely, (SF `xor` OF) is 0 if the left operand is greater than or equal to
    the right operand.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why these flags are set in this manner, consider the examples
    in [Table 6-4](#table6-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-4: Sign and Overflow Flag Settings After Subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Left** | **Minus** | **Right** | **SF** | **OF** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0FFFFh (–1) | – | 0FFFEh (–2) | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 8000h (–32,768) | – | 0001h | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0FFFEh (–2) | – | 0FFFFh (–1) | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7FFFh (32767) | – | 0FFFFh (–1) | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Remember, the `cmp` operation is really a subtraction; therefore, the first
    example in [Table 6-4](#table6-4) computes (–1) – (–2), which is (+1). The result
    is positive and an overflow did not occur, so both the S and O flags are 0\. Because
    (SF `xor` OF) is 0, `Left` is greater than or equal to `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `cmp` instruction computes (–32,768) – (+1), which
    is (–32,769). Because a 16-bit signed integer cannot represent this value, the
    value wraps around to 7FFFh (+32,767) and sets the overflow flag. The result is
    positive (at least as a 16-bit value), so the CPU clears the sign flag. (SF `xor`
    OF) is 1 here, so `Left` is less than `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, `cmp` computes (–2) – (–1), which produces (–1). No overflow
    occurred, so the OF is 0, and the result is negative, so the SF is 1\. Because
    (SF `xor` OF) is 1, `Left` is less than `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth (and final) example, `cmp` computes (+32,767) – (–1). This produces
    (+32,768), setting the overflow flag. Furthermore, the value wraps around to 8000h
    (–32,768), so the sign flag is set as well. Because (SF `xor` OF) is 0, `Left`
    is greater than or equal to `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.5 The setcc Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `set``cc` (*set on condition*) instructions set a single-byte operand (register
    or memory) to 0 or 1 depending on the values in the FLAGS register. The general
    formats for the `set``cc` instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `set``cc` represents a mnemonic appearing in Tables 6-5, 6-6, and 6-7\.
    These instructions store a 0 in the corresponding operand if the condition is
    false, and they store a 1 in the 8-bit operand if the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-5: `set``cc` Instructions That Test Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setc` | Set if carry | Carry = 1 | Same as `setb`, `setnae` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnc` | Set if no carry | Carry = 0 | Same as `setnb`, `setae` |'
  prefs: []
  type: TYPE_TB
- en: '| `setz` | Set if zero | Zero = 1 | Same as `sete` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnz` | Set if not zero | Zero = 0 | Same as `setne` |'
  prefs: []
  type: TYPE_TB
- en: '| `sets` | Set if sign | Sign = 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `setns` | Set if no sign | Sign = 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `seto` | Set if overflow | Overflow = 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `setno` | Set if no overflow | Overflow = 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `setp` | Set if parity | Parity = 1 | Same as `setpe` |'
  prefs: []
  type: TYPE_TB
- en: '| `setpe` | Set if parity even | Parity = 1 | Same as `setp` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnp` | Set if no parity | Parity = 0 | Same as `setpo` |'
  prefs: []
  type: TYPE_TB
- en: '| `setpo` | Set if parity odd | Parity = 0 | Same as `setnp` |'
  prefs: []
  type: TYPE_TB
- en: The `set``cc` instructions in [Table 6-5](#table6-5) simply test the flags without
    any other meaning attached to the operation. You could, for example, use `setc`
    to check the carry flag after a shift, rotate, bit test, or arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `setp`/`setpe` and `setnp`/`setpo` instructions check the parity flag. These
    instructions appear here for completeness, but this book will not spend much time
    discussing the parity flag; in modern code, it’s typically used only to check
    for an FPU not-a-number (NaN) condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmp` instruction works synergistically with the `set``cc` instructions.
    Immediately after a `cmp` operation, the processor flags provide information concerning
    the relative values of those operands. They allow you to see if one operand is
    less than, equal to, or greater than the other.
  prefs: []
  type: TYPE_NORMAL
- en: Two additional groups of `set``cc` instructions are useful after a `cmp` operation.
    The first group deals with the result of an unsigned comparison ([Table 6-6](#table6-6));
    the second group deals with the result of a signed comparison ([Table 6-7](#table6-7)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-6: `set``cc` Instructions for Unsigned Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `seta` | Set if above (`>`) | Carry `=` 0, Zero `=` 0 | Same as `setnbe`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setnbe` | Set if not below or equal (not `≤`) | Carry `=` 0, Zero `=` 0
    | Same as `seta` |'
  prefs: []
  type: TYPE_TB
- en: '| `setae` | Set if above or equal (`≥`) | Carry `=` 0 | Same as `setnc`, `setnb`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setnb` | Set if not below (not `<`) | Carry `=` 0 | Same as `setnc`, `setae`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setb` | Set if below (`<`) | Carry `=` 1 | Same as `setc`, `setnae` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnae` | Set if not above or equal (not `≥`) | Carry `=` 1 | Same as `setc`,
    `setb` |'
  prefs: []
  type: TYPE_TB
- en: '| `setbe` | Set if below or equal (`≤`) | Carry `=` 1 or Zero `=` 1 | Same
    as `setna` |'
  prefs: []
  type: TYPE_TB
- en: '| `setna` | Set if not above (not `>`) | Carry `=` 1 or Zero `=` 1 | Same as
    `setbe` |'
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (`==`) | Zero `=` 1 | Same as `setz` |'
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (`≠`) | Zero `=` 0 | Same as `setnz` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6-7: `set``cc` Instructions for Signed Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setg` | Set if greater (`>`) | Sign `==` Overflow and Zero `==` 0 | Same
    as `setnle` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnle` | Set if not less than or equal (not `≤`) | Sign `==` Overflow or
    Zero `==` 0 | Same as `setg` |'
  prefs: []
  type: TYPE_TB
- en: '| `setge` | Set if greater than or equal (`≥`) | Sign `==` Overflow | Same
    as `setnl` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnl` | Set if not less than (not `<`) | Sign `==` Overflow | Same as `setge`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setl` | Set if less than (`<`) | Sign `≠` Overflow | Same as `setnge` |'
  prefs: []
  type: TYPE_TB
- en: '| `setnge` | Set if not greater or equal (not `≥`) | Sign `≠` Overflow | Same
    as `setl` |'
  prefs: []
  type: TYPE_TB
- en: '| `setle` | Set if less than or equal (`≤`) | Sign `≠` Overflow or Zero `==`
    1 | Same as `setng` |'
  prefs: []
  type: TYPE_TB
- en: '| `setng` | Set if not greater than (not `>`) | Sign `≠` Overflow or Zero `==`
    1 | Same as `setle` |'
  prefs: []
  type: TYPE_TB
- en: '| `sete` | Set if equal (`=`) | Zero `==` 1 | Same as `setz` |'
  prefs: []
  type: TYPE_TB
- en: '| `setne` | Set if not equal (`≠`) | Zero `==` 0 | Same as `setnz` |'
  prefs: []
  type: TYPE_TB
- en: 'The `set``cc` instructions are particularly valuable because they can convert
    the result of a comparison to a Boolean value (false/true or 0/1). This is especially
    important when translating statements from a high-level language like Swift or
    C/C++ into assembly language. The following example shows how to use these instructions
    in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `set``cc` instructions always produce 0 or 1, you can use the results
    with the `and` and `or` instructions to compute complex Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.6 The test Instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The x86-64 `test` instruction is to the `and` instruction what the `cmp` instruction
    is to `sub`. That is, the `test` instruction computes the logical AND of its two
    operands and sets the condition code flags based on the result; it does not, however,
    store the result of the logical AND back into the destination operand. The syntax
    for the `test` instruction is similar to `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `test` instruction sets the zero flag if the result of the logical AND operation
    is 0\. It sets the sign flag if the HO bit of the result contains a 1\. The `test`
    instruction always clears the carry and overflow flags.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `test` instruction is to check whether an individual
    bit contains a 0 or a 1\. Consider the instruction `test al, 1`. This instruction
    logically ANDs AL with the value 1; if bit 0 of AL contains 0, the result will
    be 0 (setting the zero flag) because all the other bits in the constant 1 are
    0\. Conversely, if bit 0 of AL contains 1, then the result is not 0, so `test`
    clears the zero flag. Therefore, you can test the zero flag after this `test`
    instruction to see if bit 0 contains a 0 or a 1 (for example, using `setz` or
    `setnz` instructions, or the `jz`/`jnz` instructions).
  prefs: []
  type: TYPE_NORMAL
- en: The `test` instruction can also check whether all the bits in a specified set
    of bits contain 0\. The instruction `test al, 0fh` sets the zero flag if and only
    if the LO 4 bits of AL all contain 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important use of the `test` instruction is to check whether a register
    contains 0\. The instruction `test` `reg``,` `reg`, where both operands are the
    same register, will logically AND that register with itself. If the register contains
    0, the result is 0 and the CPU will set the zero flag. However, if the register
    contains a nonzero value, logically ANDing that value with itself produces that
    same nonzero value, so the CPU clears the zero flag. Therefore, you can check
    the zero flag immediately after the execution of this instruction (for example,
    using the `setz` or `setnz` instructions or the `jz` and `jnz` instructions) to
    see if the register contains 0\. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One major failing of the `test` instruction is that immediate (constant) operands
    can be no larger than 32 bits (as is the case with most instructions), which makes
    it difficult to use this instruction to test for set bits beyond bit position
    31\. For testing individual bits, you can use the `bt` (*bit test*) instruction
    (see “Instructions That Manipulate Bits” in Chapter 12). Otherwise, you’ll have
    to move the 64-bit constant into a register (the `mov` instruction does support
    64-bit immediate operands) and then test your target register against the 64-bit
    constant value in the newly loaded register.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Arithmetic Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the biggest shock to beginners facing assembly language for the first
    time is the lack of familiar arithmetic expressions. *Arithmetic expressions*,
    in most high-level languages, look similar to their algebraic equivalents. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In assembly language, you’ll need several statements to accomplish this same
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the HLL version is much easier to type, read, and understand. Although
    a lot of typing is involved, converting an arithmetic expression into assembly
    language isn’t difficult at all. By attacking the problem in steps, the same way
    you would solve the problem by hand, you can easily break any arithmetic expression
    into an equivalent sequence of assembly language statements.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Simple Assignments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest expressions to convert to assembly language are simple assignments.
    *Simple assignments* copy a single value into a variable and take one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the first form to assembly language is simple—just use this assembly
    language statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This `mov` instruction copies the constant into the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second assignment is slightly more complicated because the x86-64 doesn’t
    provide a memory-to-memory `mov` instruction. Therefore, to copy one memory variable
    into another, you must move the data through a register. By convention (and for
    slight efficiency reasons), most programmers tend to favor AL, AX, EAX, or RAX
    for this purpose. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: assuming that `var1` and `var2` are 32-bit variables. Use AL if they are 8-bit
    variables, use AX if they are 16-bit variables, or use RAX if they are 64-bit
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re already using AL, AX, EAX, or RAX for something else, one
    of the other registers will suffice. Regardless, you will generally use a register
    to transfer one memory location to another.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Simple Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next level of complexity is a simple expression. A *simple expression* takes
    the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: where `var1` is a variable, `term1` and `term2` are variables or constants,
    and `op` is an arithmetic operator (addition, subtraction, multiplication, and
    so on). Most expressions take this form. It should come as no surprise, then,
    that the x86-64 architecture was optimized for just this type of expression.
  prefs: []
  type: TYPE_NORMAL
- en: A typical conversion for this type of expression takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: where `op` is the mnemonic that corresponds to the specified operation (for
    example, + is `add`, – is `sub`, and so forth).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the simple expression `var1` `=` `const1``op``const2``;` is easily
    handled with a compile-time expression and a single `mov` instruction. For example,
    to compute `var1` `= 5 + 3;`, use the single instruction `mov` `var1``, 5 + 3`.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be aware of a few inconsistencies. When dealing with the `(``i``)mul`
    and `(``i``)div` instructions on the x86-64, you must use the AL, AX, EAX, and
    RAX registers and the AH, DX, EDX, and RDX registers. You cannot use arbitrary
    registers as you can with other operations. Also, don’t forget the sign-extension
    instructions if you’re performing a division operation to divide one 16-, 32-,
    or 64-bit number by another. Finally, don’t forget that some instructions may
    cause overflow. You may want to check for an overflow (or underflow) condition
    after an arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of common simple expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Certain unary operations also qualify as simple expressions, producing additional
    inconsistencies to the general rule. A good example of a unary operation is *negation*.
    In a high-level language, negation takes one of two possible forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `var` `= –``constant` is really a simple assignment, not a simple
    expression. You can specify a negative constant as an operand to the `mov` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle `var1` `= –``var1`, use this single assembly language statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If two different variables are involved, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 6.2.3 Complex Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *complex* *expression* is any arithmetic expression involving more than two
    terms and one operator. Such expressions are commonly found in programs written
    in a high-level language. Complex expressions may include parentheses to override
    operator precedence, function calls, array accesses, and so on. This section outlines
    the rules for converting such expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complex expression that is easy to convert to assembly language is one that
    involves three terms and two operators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly the straightforward assembly language conversion of this statement
    requires two `sub` instructions. However, even with an expression as simple as
    this, the conversion is not trivial. There are actually *two ways* to convert
    the preceding statement into assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second conversion, because it is shorter, looks better. However, it produces
    an incorrect result (assuming C-like semantics for the original statement). Associativity
    is the problem. The second sequence in the preceding example computes `w = w –
    (y – z)`, which is not the same as `w = (w – y) – z`. How we place the parentheses
    around the subexpressions can affect the result. Note that if you are interested
    in a shorter form, you can use the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This computes `w = w – (y + z)`, equivalent to `w = (w – y) – z`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Precedence* is another issue. Consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we can evaluate this expression in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By now, you’re probably thinking that this explanation is crazy. Everyone knows
    the correct way to evaluate these expressions is by the former form. However,
    you’d be wrong. The APL programming language, for example, evaluates expressions
    solely from right to left and does not give one operator precedence over another.
    Which way is “correct” depends entirely on how you define precedence in your arithmetic
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If `op1` takes precedence over `op2`, then this evaluates to `(x` `op1` `y)`
    `op2` `z`*.* Otherwise, if `op2` takes precedence over `op1`, this evaluates to
    `x` `op1` `(y` `op2` `z)`. Depending on the operators and operands involved, these
    two computations could produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: Most high-level languages use a fixed set of precedence rules to describe the
    order of evaluation in an expression involving two or more different operators.
    Such programming languages usually compute multiplication and division before
    addition and subtraction. Those that support exponentiation (for example, FORTRAN
    and BASIC) usually compute that before multiplication and division. These rules
    are intuitive because almost everyone learns them before high school.
  prefs: []
  type: TYPE_NORMAL
- en: 'When converting expressions into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If two operators appearing within an expression have the same precedence, you
    determine the order of evaluation by using associativity rules. Most operators
    are *left-associative*, meaning they evaluate from left to right. Addition, subtraction,
    multiplication, and division are all left-associative. A *right-associative* operator
    evaluates from right to left. The exponentiation operator in FORTRAN is a good
    example of a right-associative operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: is equal to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: not
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The associativity rule has one exception: if an expression involves multiplication
    and division, it is generally better to perform the multiplication first. For
    example, given an expression of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: it is usually better to compute `x * z` and then divide the result by `y` rather
    than divide `x` by `y` and multiply the quotient by `z`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is better for two reasons. First, remember that the `imul` instruction
    always produces a 64-bit result (assuming 32-bit operands). By doing the multiplication
    first, you automatically *sign-extend* the product into the EDX register so you
    do not have to sign-extend EAX prior to the division.
  prefs: []
  type: TYPE_NORMAL
- en: A second reason for doing the multiplication first is to increase the accuracy
    of the computation. Remember, (integer) division often produces an inexact result.
    For example, if you compute 5 / 2, you will get the value 2, not 2.5\. Computing
    (5 / 2) × 3 produces 6\. However, if you compute (5 × 3) / 2, you get the value
    7, which is a little closer to the real quotient (7.5). Therefore, if you encounter
    an expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'you can usually convert it to the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the algorithm you’re encoding depends on the truncation effect of the division
    operation, you cannot use this trick to improve the algorithm. Moral of the story:
    always make sure you fully understand any expression you are converting to assembly
    language. If the semantics dictate that you must perform the division first, then
    do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Because subtraction is not commutative, you cannot compute `y * x` and then
    subtract `x` from this result. Rather than use a straightforward multiplication-and-addition
    sequence, you’ll have to load `x` into a register, multiply ``y and `x` (leaving
    their product in a different register), and then subtract this product from `x`.
    For example:``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
