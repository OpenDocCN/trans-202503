<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_167"/><strong><span class="big">17</span><br/>OAUTH VULNERABILITIES</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><em>OAuth</em> is an open protocol that simplifies and standardizes secure authorization on web, mobile, and desktop applications. It allows users to create accounts on websites without having to create a username or password. It’s commonly seen on websites as the Sign in with <em>platform</em> button like the one shown in <a href="ch17.xhtml#ch17fig01">Figure 17-1</a>, where the platform is Facebook, Google, LinkedIn, Twitter, or so on.</p>&#13;
<div class="image"><a id="ch17fig01"/><img alt="image" src="../images/17fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 17-1: Example OAuth Sign in with Google button</em></p>&#13;
<p class="indent">OAuth vulnerabilities are a type of application configuration vulnerability, meaning they rely on a developer’s implementation mistakes. However, given the impact and frequency of OAuth vulnerabilities, they’re worth <span epub:type="pagebreak" id="page_168"/>devoting an entire chapter to. Although there are many kinds of OAuth vulnerabilities, the examples in this chapter will mainly include cases when an attacker is able to exploit OAuth to steal authentication tokens and access a targeted user’s account information on the resource server.</p>&#13;
<p class="indent">At the time of writing, OAuth has two versions, 1.0a and 2.0, which are incompatible with each other. Entire books have been written on OAuth, but this chapter focuses on OAuth 2.0 and the basic OAuth workflow.</p>&#13;
<h3 class="h3" id="ch17lev1sec1"><strong>The OAuth Workflow</strong></h3>&#13;
<p class="noindent">The OAuth process is complex, so let’s begin with basic terms. Three actors are involved in the most basic OAuth flow:</p>&#13;
<ul>&#13;
<li class="noindent">The <em>resource owner</em> is the user attempting to log in via OAuth.</li>&#13;
<li class="noindent">The <em>resource server</em> is a third-party API that authenticates the resource owner. Any site can be a resource server, but the most popular ones include Facebook, Google, LinkedIn, and so on.</li>&#13;
<li class="noindent">The <em>client</em> is the third-party application that the resource owner visits. The client is allowed to access data on the resource server.</li>&#13;
</ul>&#13;
<p class="indent">When you attempt to log in using OAuth, the client requests access to your information from the resource server and asks the resource owner (in this case, you) for approval to access the data. The client might ask for access to all your information or only specific pieces. The information that a client requests is defined by scopes. Scopes are similar to permissions in that they restrict what information an application can access from the resource server. For example, Facebook scopes include the user’s <span class="literal">email</span>, <span class="literal">public_profile</span>, <span class="literal">user_friends</span>, and so on. If you grant a client access to only the <span class="literal">email</span> scope, the client can’t access your profile information, friends list, and other information.</p>&#13;
<p class="indent">Now that you understand the actors involved, let’s examine the OAuth process when logging into a client for the first time using Facebook as the example resource server. The OAuth process begins when you visit a client and click the Login with Facebook button. This results in a <span class="literal">GET</span> request to an authentication endpoint on the client. Often, the path looks like this: <em>https://www.&lt;example&gt;.com/oauth/facebook/</em>. Shopify, for example, uses Google for OAuth with the URL <em>https://&lt;STORE&gt;.myshopify.com/admin/auth/login?google_apps=1/</em>.</p>&#13;
<p class="indent">The client responds to this HTTP request with a 302 redirect to the resource server. The redirect URL will include parameters to facilitate the OAuth process, which are defined as follows:</p>&#13;
<ul>&#13;
<li class="noindent">The <em>client_id</em> identifies the client to the resource server. Each client will have its own <em>client_id</em> so the resource server can identify the application initiating the request to access the resource owner’s information.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_169"/>The <em>redirect_uri</em> identifies where the resource server should redirect the resource owner’s browser after the resource server has authenticated the resource owner.</li>&#13;
<li class="noindent">The <em>response_type</em> identifies what type of response to provide. This is usually a token or code, although a resource server can define other accepted values. A token response type provides an access token that immediately allows access to information from the resource server. A code response type provides an access code that must be exchanged for an access token via an extra step in the OAuth process.</li>&#13;
<li class="noindent">The <em>scope</em>, mentioned earlier, identifies the permissions a client is requesting to access from the resource server. During the first authorization request, the resource owner should be presented with a dialog to review and approve the requested scopes.</li>&#13;
<li class="noindent">The <em>state</em> is an unguessable value that prevents cross-site request forgeries. This value is optional but should be implemented on all OAuth applications. It should be included in the HTTP request to the resource server. Then it should be returned and validated by the client to ensure an attacker can’t maliciously invoke the OAuth process on another user’s behalf.</li>&#13;
</ul>&#13;
<p class="indent">An example URL initiating the OAuth process with Facebook would look like this: <em>https://www.facebook.com/v2.0/dialog/oauth?client_id=123&amp;redirect_uri=https%3A%2F%2Fwww.&lt;example&gt;.com%2Foauth%2Fcallback&amp;response_type=token&amp;scope=email&amp;state=XYZ</em></p>&#13;
<p class="indent">After receiving the 302 redirect response, the browser sends a <span class="literal">GET</span> request to the resource server. Assuming you’re logged in to the resource server, you should see a dialog to approve the client’s requested scopes. <a href="ch17.xhtml#ch17fig02">Figure 17-2</a> shows an example of the website Quora (the client) requesting access to information from Facebook (the resource server) on the resource owner’s behalf.</p>&#13;
<p class="indent">Clicking the Continue as John button approves Quora’s request to access the listed scopes, including the resource owner’s public profile, friends list, birthday, hometown, and so on. After the resource owner clicks the button, Facebook returns a 302 HTTP response redirecting the browser back to the URL defined by the <em>redirect_uri</em> parameter discussed previously. The redirect also includes a token and the state parameter. Here’s an example of a URL redirect from Facebook to Quora (which has been modified for this book):</p>&#13;
<p class="hangtb"><em>https://www.quora.com?access_token=EAAAAH86O7bQBAApUu2ZBTuEo0MZA5xBXTQixBUYxrauhNqFtdxViQQ3CwtliGtKqljBZA8&amp;expires_in=5625&amp;state=F32AB83299DADDBAACD82DA</em></p>&#13;
<p class="indent">In this case, Facebook returned an access token that Quora (the client) could use to immediately query the resource owner’s information. Once the client has the <em>access_token</em>, the resource owner’s involvement in the OAuth process is complete. The client would query the Facebook API directly to obtain the information it requires about the resource owner. The resource owner would be able to use the client without being aware of the interaction between the client and API.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_170"/><a id="ch17fig02"/><img alt="image" src="../images/17fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 17-2: Quora login with Facebook OAuth scope authorization</em></p>&#13;
<p class="indent">However, if Facebook returned a code instead of an access token, Quora would need to exchange that code for an access token to query information from the resource server. This process is completed between the client and the resource server without the resource owner’s browser. To obtain a token, the client makes its own HTTP request to the resource server that includes three URL parameters: an access <em>code</em>, the <em>client_id</em>, and a <em>client_secret</em>. The access <em>code</em> is the value returned from the resource server through the 302 HTTP redirect. The <em>client_secret</em> is a value meant to be kept private by the client. It is generated by the resource server when the application is configured and the <em>client_id</em> is assigned.</p>&#13;
<p class="indent">Finally, once the resource server receives a request from the client with the <em>client_secret</em>, <em>client_id</em>, and access <em>code</em>, it validates the values and returns an <em>access_token</em> to the client. At this stage, the client can query the resource server for information about the resource owner, and the OAuth process is complete. Once you’ve approved a resource server to access your information, the next time you log in to the client using Facebook, the OAuth authentication process will usually happen in the background. You won’t see any of this interaction unless you monitor your HTTP requests. Clients can change this default behavior to require resource owners to reauthenticate and approve scopes; however, this is very uncommon.</p>&#13;
<p class="indent">The severity of an OAuth vulnerability depends on the permitted scopes associated with the stolen token, as you’ll see in the following examples.</p>&#13;
<h3 class="h3" id="ch17lev1sec2"><span epub:type="pagebreak" id="page_171"/><strong>Stealing Slack OAuth Tokens</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://slack.com/oauth/authorize/">https://slack.com/oauth/authorize/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://hackerone.com/reports/2575/">http://hackerone.com/reports/2575/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> March 1, 2013</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $100</p>&#13;
<p class="noindent">A common OAuth vulnerability occurs when a developer improperly configures or compares permitted <em>redirect_uri</em> parameters, allowing attackers to steal OAuth tokens. In March 2013, Prakhar Prasad found just that on Slack’s OAuth implementation. Prasad informed Slack that he could bypass their <em>redirect_uri</em> restrictions by appending anything to a whitelisted <em>redirect_uri</em>. In other words, Slack was only validating the beginning of the <em>redirect_uri</em> parameter. If a developer registered a new application with Slack and whitelisted <em>https://www.&lt;example&gt;.com</em>, an attacker could append a value to the URL and cause the redirect to go somewhere unintended. For example, modifying the URL to pass <em>redirect_uri=https://&lt;attacker&gt;.com</em> would be rejected, but passing <em>redirect_uri=https://www.&lt;example&gt;.com.mx</em> would be accepted.</p>&#13;
<p class="indent">To exploit this behavior, an attacker only has to create a matching subdomain on their malicious site. If a targeted user visits the maliciously modified URL, Slack sends the OAuth token to the attacker’s site. An attacker could invoke the request on behalf of the targeted user by embedding an <span class="literal">&lt;img&gt;</span> tag on a malicious web page, such as <span class="literal">&lt;img src=https://slack.com/oauth/authorize?response_type=token&amp;client_id=APP_ID&amp;redirect_uri=https://www.</span><span class="codeitalic">example</span><span class="literal">.com.</span><span class="codeitalic">attacker</span><span class="literal">.com&gt;</span>. Using an <span class="literal">&lt;img&gt;</span> tag automatically invokes an HTTP <span class="literal">GET</span> request when rendered.</p>&#13;
<h4 class="h4" id="ch17lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Vulnerabilities in which the <em>redirect_uri</em> haven’t been strictly checked are a common OAuth misconfiguration. Sometimes, the vulnerability is the result of an application registering a domain, such as <em>*.&lt;example&gt;.com</em>, as an acceptable <em>redirect_uri</em>. Other times, it’s the result of a resource server not performing a strict check on the beginning and end of the <em>redirect_uri</em> parameter. In this example, it was the latter. When you’re looking for OAuth vulnerabilities, always be sure to test any parameter that indicates a redirection is being used.</p>&#13;
<h3 class="h3" id="ch17lev1sec3"><strong>Passing Authentication with Default Passwords</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://flurry.com/auth/v1/account/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://lightningsecurity.io/blog/password-not-provided/">https://lightningsecurity.io/blog/password-not-provided/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> June 30, 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_172"/>Looking for vulnerabilities in any OAuth implementation involves reviewing the entire authentication process, from start to finish. This includes recognizing HTTP requests that aren’t part of the standardized process. Such requests commonly indicate that the developers have customized the process and might have introduced bugs. Jack Cable noticed such a situation in June 2017, when he looked at Yahoo’s bug bounty program.</p>&#13;
<p class="indent">Yahoo’s bounty program included the analytics site <em><a href="http://Flurry.com">Flurry.com</a></em>. To begin his testing, Cable registered for a Flurry account using his <em>@yahoo.com</em> email address through Yahoo’s OAuth implementation. After Flurry and Yahoo! exchanged the OAuth token, the final <span class="literal">POST</span> request to Flurry was the following:</p>&#13;
<p class="programs">POST /auth/v1/account HTTP/1.1<br/>&#13;
Host: auth.flurry.com<br/>&#13;
Connection: close<br/>&#13;
Content-Length: 205<br/>&#13;
Content-Type: application/vnd.api+json<br/>&#13;
DNT: 1<br/>&#13;
Referer: https://login.flurry.com/signup<br/>&#13;
Accept-Language: en-US,en;q=0.8,la;q=0.6<br/>&#13;
{"data":{"type":"account","id":"...","attributes":{"email":...@yahoo.com,<br/>&#13;
"companyName":"1234","firstname":"jack","lastname":"cable",<span class="ent">➊</span>"password":<br/>&#13;
"not-provided"}}}</p>&#13;
<p class="indent">The <span class="literal">"password":"not-provided"</span> part of the request <span class="ent">➊</span> caught Cable’s eye. Logging out of his account, he revisited <em><a href="https://login.flurry.com/">https://login.flurry.com/</a></em> and signed in without using OAuth. Instead, he provided his email address and the password <span class="literal">not-provided</span>. This worked and Cable was logged into his account.</p>&#13;
<p class="indent">If any user registered for Flurry using their Yahoo! account and the OAuth process, Flurry would register the account in their system as the client. Then Flurry would save the user account with the default password <span class="literal">not-provided</span>. Cable submitted the vulnerability, and Yahoo! fixed it with within five hours of receiving his report.</p>&#13;
<h4 class="h4" id="ch17lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">In this case, Flurry included an extra, custom step in the authentication process that used a <span class="literal">POST</span> request to create a user account after a user was authenticated. Custom OAuth implementation steps are often misconfigured and result in vulnerabilities, so be sure to test these processes thoroughly. In this example, Flurry likely built its OAuth workflow on top of the existing user registration process to match the rest of the application. Flurry likely didn’t require users to create an account prior to implementing Yahoo! OAuth. To accommodate users without accounts, the Flurry developers probably decided to invoke the same registration <span class="literal">POST</span> request to create users. But the request required a password parameter, so Flurry set an insecure default one.</p>&#13;
<h3 class="h3" id="ch17lev1sec4"><span epub:type="pagebreak" id="page_173"/><strong>Stealing Microsoft Login Tokens</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://login.microsoftonline.com">https://login.microsoftonline.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em>https://whitton.io/articles/obtaining-tokens-outlook-office-azure-account/</em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 24, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $13,000</p>&#13;
<p class="noindent">Although Microsoft doesn’t implement the standard OAuth flow, it uses a process that is very similar and applicable to testing OAuth applications. When you’re testing OAuth or any similar authentication processes, be sure to thoroughly test how redirect parameters are being validated. One way you can do this is by passing different URL structures to the application. This is exactly what Jack Whitton did in January 2016, when he tested Microsoft’s login process and found he could steal authentication tokens.</p>&#13;
<p class="indent">Because it owns so many properties, Microsoft authenticates users through requests to <em><a href="http://login.live.com">login.live.com</a></em>, <em><a href="http://login.microsoftonline.com">login.microsoftonline.com</a></em>, and <em><a href="http://login.windows.net">login.windows.net</a></em> depending on the service the user is being authenticated to. These URLs would return a session for the user. For example, the flow for <em><a href="http://outlook.office.com">outlook.office.com</a></em> was the following:</p>&#13;
<ol>&#13;
<li class="noindent">A user would visit <em><a href="https://outlook.office.com">https://outlook.office.com</a></em>.</li>&#13;
<li class="noindent">The user would be redirected to <em><a href="https://login.microsoftonline.com/login.srf?wa=wsignin1.0&amp;rpsnv=4&amp;wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&amp;id=260563">https://login.microsoftonline.com/login.srf?wa=wsignin1.0&amp;rpsnv=4&amp;wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&amp;id=260563</a></em>.</li>&#13;
<li class="noindent">If the user was logged in, a <span class="literal">POST</span> request would be made to the <span class="literal">wreply</span> parameter with a <span class="literal">t</span> parameter containing a token for the user.</li>&#13;
</ol>&#13;
<p class="indent">Changing the <span class="literal">wreply</span> parameter to any other domain returned a process error. Whitton also tried double encoding characters by adding a <em>%252f</em> to the end of the URL to create <em>https%3a%2f%2foutlook.office.com%252f</em>. In this URL, special characters are encoded such that a colon (<em>:</em>) is <em>%3a</em> and a slash (<em>/</em>) is <em>%2f</em>. When <em>double encoding</em>, the attacker would also encode the percent sign (<em>%</em>) in the initial encoding. Doing so would make a double-encoded slash <em>%252f</em> (encoding special characters was discussed in “<a href="ch06.xhtml#ch06lev1sec3">Twitter HTTP Response Splitting</a>” on <a href="ch06.xhtml#page_52">page 52</a>). When Whitton changed the <span class="literal">wreply</span> parameter to the double-encoded URL, the application returned an error that indicated <em>https://outlook.office.com%f</em> wasn’t a valid URL.</p>&#13;
<p class="indent">Next, Whitton appended <em>@example.com</em> to the domain, which didn’t result in an error. Instead, it returned <em><a href="mailto:https://outlook.office.com%2f@example.com/?wa=wsignin1.0">https://outlook.office.com%2f@example.com/?wa=wsignin1.0</a></em>. The reason it did this is that the structure of a URL is the scheme: <em>[//[username:password@]host[:port]][/]path[?query][#fragment]</em>. The <span class="literal">username</span> and <span class="literal">password</span> parameters pass basic authorization credentials to a website. So, by adding <em>@example.com</em>, the redirect host was no longer <em><a href="http://outlook.office.com">outlook.office.com</a></em>. Instead, the redirect could be set to any attacker-controlled host.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>According to Whitton, the cause of this vulnerability was the way in which Microsoft was handling decoding and URL validation. Microsoft was likely using a two-step process. First, Microsoft would perform a sanity check and ensure the domain was valid and conforming to the URL structure scheme. The URL <em><a href="mailto:https://outlook.office.com%2f@example.com">https://outlook.office.com%2f@example.com</a></em> was valid because <em><a href="http://outlook.office.com%2f">outlook.office.com%2f</a></em> would be recognized as a valid username.</p>&#13;
<p class="indent">Second, Microsoft would decode the URL recursively until there were no other characters to decode. In this case, <em>https%3a%2f%2foutlook.office.com%252f@example.com</em> would be recursively decoded until it returned <em><a href="mailto:https://outlook.office.com/@example.com">https://outlook.office.com/@example.com</a></em>. This meant <em>@example.com</em> was recognized as part of the URL path but not the host. The host would be validated as <em><a href="http://outlook.office.com">outlook.office.com</a></em> because <em>@example.com</em> comes after a slash.</p>&#13;
<p class="indent">When the parts of the URL were combined, Microsoft validated the URL structure, decoded the URL, and validated it as being whitelisted but returned a URL that was only decoded once. This meant that any targeted user who visited <em>https://login.microsoftonline.com/login.srf?wa=wsignin1.0&amp;rpsnv=4&amp;wreply=https%3a%2f%2foutlook.office.com%252f@example.com&amp;id=260563</em> would have their access token sent to <em>example.com</em>. The malicious owner of <em>example.com</em> could then log in to the Microsoft service associated with the received token and access other people’s accounts.</p>&#13;
<h4 class="h4" id="ch17lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">When you’re testing redirect parameters in the OAuth flow, include <em>@example.com</em> as part of the redirect URI to see how the application handles it. You should do this especially when you notice that the process is utilizing encoded characters that the application needs to decode to validate a whitelisted redirect URL. Additionally, always note any subtle differences in application behavior while you’re testing. In this case, Whitton noticed that the errors being returned were different when he fully changed the <span class="literal">wreply</span> parameter instead of appending a double-encoded forward slash. This put him on to Microsoft’s misconfigured validation logic.</p>&#13;
<h3 class="h3" id="ch17lev1sec5"><strong>Swiping Facebook Official Access Tokens</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://www.facebook.com">https://www.facebook.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://philippeharewood.com/swiping-facebook-official-access-tokens/">http://philippeharewood.com/swiping-facebook-official-access-tokens/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> February 29, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent">When you’re looking for vulnerabilities, be sure to consider forgotten assets that the target application relies on. In this example, Philippe Harewood began with a single goal in mind: to capture a targeted user’s Facebook <span epub:type="pagebreak" id="page_175"/>token and access their private information. But he wasn’t able to find any mistakes in Facebook’s OAuth implementation. Undeterred, he pivoted and started looking for a Facebook application he could take over, using an idea similar to a subdomain takeover.</p>&#13;
<p class="indent">The idea was predicated on recognizing that the main Facebook functionality includes some Facebook-owned apps that rely on OAuth and are automatically authorized by all Facebook accounts. The list of these preauthorized apps was at <em>https://www.facebook.com/search/me/apps-used/</em>.</p>&#13;
<p class="indent">Reviewing the list, Harewood found one application that was authorized, even though Facebook no longer owned or used the domain. This meant Harewood could register the whitelisted domain as the <em>redirect_uri</em> parameter to receive the Facebook tokens of any targeted user that visited the OAuth authorization endpoint <em><a href="https://facebook.com/v2.5/dialog/oauth?response_type=token&amp;display=popup&amp;client_id=APP_ID&amp;redirect_uri=REDIRECT_URI/">https://facebook.com/v2.5/dialog/oauth?response_type=token&amp;display=popup&amp;client_id=APP_ID&amp;redirect_uri=REDIRECT_URI/</a></em>.</p>&#13;
<p class="indent">In the URL, the vulnerable app’s ID is denoted by <em>APP_ID</em>, which included access to all OAuth scopes. The whitelisted domain is denoted by <em>REDIRECT_URI</em> (Harewood didn’t disclose the misconfigured application). Because the application was already authorized for every Facebook user, any targeted user would never be required to approve requested scopes. In addition, the OAuth process would proceed entirely in background HTTP requests. By visiting the Facebook OAuth URL for this application, users would be redirected to the URL <em>http://REDIRECT_URI/#token=access_token_appended_here/</em>.</p>&#13;
<p class="indent">Because Harewood registered the address for <em>REDIRECT_URI</em>, he was able to log the access token of any user who visited the URL, which gave him access to their entire Facebook account. Additionally, all official Facebook access tokens include access to other Facebook-owned properties, such as Instagram. As a result, Harewood could access all Facebook properties on behalf of a targeted user.</p>&#13;
<h4 class="h4" id="ch17lev2sec4"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Consider potential forgotten assets when you’re looking for vulnerabilities. In this example, the forgotten asset was a sensitive Facebook application with full scope permissions. But other examples include subdomain CNAME records and application dependencies, such as Ruby Gems, JavaScript libraries, and so on. If an application relies on external assets, developers might someday stop using that asset and forget to disconnect it from the application. If an attacker can take over the asset, that could have severe consequences for the application and its users. Additionally, it’s important to recognize that Harewood began his testing with a hacking goal in mind. Doing the same is an effective way to focus your energy when you’re hacking on large applications, where there are an infinite number of areas to test and it’s easy to get distracted.</p>&#13;
<h3 class="h3" id="ch17lev1sec6"><span epub:type="pagebreak" id="page_176"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Despite its standardization as an authentication workflow, OAuth is easy for developers to misconfigure. Subtle bugs could allow attackers to steal authorization tokens and access the private information of targeted users. When you’re hacking on OAuth applications, be sure to thoroughly test the <em>redirect_uri</em> parameter to see whether an application is properly validating when access tokens are sent. Also, be on the lookout for custom implementations that support the OAuth workflow; the functionality won’t be defined by the OAuth standardized process and is more likely to be vulnerable. Before giving up on any OAuth hacking, be sure to consider whitelisted assets. Confirm whether the client has trusted any application by default that its developers might have forgotten about.</p>&#13;
</body></html>