<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_243"/><strong><span class="big">13</span><br/>CONTROL FLOW CONSTRUCTS</strong></h2>&#13;
<div class="image1"><img src="../images/pg271_Image_273.jpg" alt="Image" width="189" height="190"/></div>&#13;
<p class="noindentz">When writing a program in C or assembly language, we specify the order in which each statement or instruction is executed. This order is called the <em>control flow</em>. Programming by specifying the control flow is known as <em>imperative programming</em>. This is in contrast to <em>declarative programming</em>, where we state the logic of the computation and another program figures out the control flow to perform it.</p>&#13;
<p class="indent">If you have been using <span class="literal">make</span> to build your programs, as recommended in <a href="ch02.xhtml">Chapter 2</a>, the statements in your makefile are an example of declarative programming. You specify the logic of the results, and the <span class="literal">make</span> program figures out the control flow to produce the results.</p>&#13;
<p class="indent">There are three fundamental control flow constructs: sequence, iteration, and selection. You’ve already seen sequence in the programs we’ve written thus far: each instruction, or subfunction, is executed in the order in which it’s written. In this chapter, I’ll show you how to alter the control flow from the written order to iterate the same block of written instructions or to select between several blocks of written instructions. You’ll see how each of these control flow constructs is implemented at the assembly language <span epub:type="pagebreak" id="page_244"/>level. In <a href="ch14.xhtml">Chapter 14</a>, I’ll cover the details of altering control flow by calling a subfunction.</p>&#13;
<h3 class="h3" id="ch13lev1sec1"><strong>Branches</strong></h3>&#13;
<p class="noindent">A <em>branch instruction</em> transfers control flow to the memory location specified by the instruction. There are two types of branches: unconditional and conditional. Both iteration and selection use conditional branches to alter control flow based on a true/false condition. You’ll also often use unconditional branches when implementing the iteration and selection flow constructs. We’ll start with those and then look at conditional branches.</p>&#13;
<h4 class="h4" id="ch13lev2sec1"><em><strong>Unconditional</strong></em></h4>&#13;
<p class="noindent">As you learned in <a href="ch09.xhtml">Chapter 9</a>, when an instruction is executed, the CPU automatically increments the program counter, <span class="literal">pc</span>, by 4 to hold the address of the next instruction in memory. Instead of adding 4 to the program counter, an unconditional branch instruction changes the program counter to the branch target address, which causes the CPU to continue program execution at the target address.</p>&#13;
<p class="indent">You already learned about one unconditional branch instruction—<span class="literal">ret</span>, which is used to return from functions—in <a href="ch10.xhtml">Chapter 10</a>. There are two others, <span class="literal">b</span> and <span class="literal">br</span>:</p>&#13;
<p class="noindenttL"><span class="codestrong">b</span><strong>—Branch unconditionally</strong></p>&#13;
<p class="hang"><span class="literal">b</span> <span class="codeitalic">label</span> branches to the address of <span class="codeitalic">label</span> within the range of ±128MB from this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">br</span><strong>—Branch register unconditionally</strong></p>&#13;
<p class="hang"><span class="literal">br x</span><span class="codeitalic">s</span> branches to the 64-bit address in <span class="literal">x</span><span class="codeitalic">s</span>.</p>&#13;
<p class="indenttL">The <span class="literal">b</span> instruction is commonly used together with a conditional branch instruction to skip blocks of code or to go back to the beginning of a block of code and execute it again. For the <span class="literal">b</span> instruction, the CPU sign-extends the 26-bit word offset between the <span class="literal">b</span> instruction and <span class="codeitalic">label</span> to 64 bits and adds this signed number to <span class="literal">pc</span>. The <span class="literal">br</span> instruction simply copies the 64 bits in <span class="literal">x</span><span class="codeitalic">s</span> to <span class="literal">pc</span>.</p>&#13;
<p class="indent">Although <span class="literal">br x30</span> would seem to have the same effect as <span class="literal">ret</span>, the <span class="literal">br</span> and <span class="literal">ret</span> instructions are not aliases for each other; they are different instructions. The difference is that <span class="literal">br</span> tells the CPU that this is probably <em>not</em> a function return, while <span class="literal">ret</span> tells the CPU that this probably <em>is</em> a function return. The details are beyond the scope of this book, but these hints can help the CPU optimize some of the specifics of executing instructions.</p>&#13;
<h4 class="h4" id="ch13lev2sec2"><em><strong>Conditional</strong></em></h4>&#13;
<p class="noindent">There are two types of conditional branch instructions. One tests the settings of the condition flags in the <span class="literal">nzcv</span> register (see <a href="ch09.xhtml#ch9fig4">Figure 9-4</a> in <a href="ch09.xhtml">Chapter 9</a>). We need to use another instruction to set the flags before testing them to determine whether to branch or not.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/>The other type of conditional branch instruction tests the value in a register to determine whether to branch. Instructions in this group do not depend on the condition flags, nor do they change them.</p>&#13;
<p class="indent">I’ll start with the instructions that branch according to the settings of the condition flags:</p>&#13;
<p class="noindenttL"><span class="codestrong">b.</span><span class="codestrongitalic">cond</span><strong>—Branch conditionally</strong></p>&#13;
<p class="hang"><span class="literal">b.</span><span class="codeitalic">cond label</span> tests the settings in the <span class="literal">nzcv</span> register and branches to <span class="codeitalic">label</span> if they match <span class="codeitalic">cond</span>, in the range of ±128MB from this instruction. The possible values for <span class="codeitalic">cond</span> are given in <a href="ch13.xhtml#ch13tab1">Table 13-1</a>.</p>&#13;
<p class="tabcap" id="ch13tab1"><strong>Table 13-1:</strong> Allowable Branching Condition Codes</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Code</strong></th>&#13;
<th class="tab_th"><span class="codestrongitalic">cond</span></th>&#13;
<th class="tab_th"><strong>Meaning</strong></th>&#13;
<th class="tab_th"><strong>Condition flags</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0000</span></td>&#13;
<td class="bg1"><span class="literal">eq</span></td>&#13;
<td class="bg1">Equal</td>&#13;
<td class="bg1"><em>Z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0001</span></td>&#13;
<td class="bg"><span class="literal">ne</span></td>&#13;
<td class="bg">Not equal</td>&#13;
<td class="bg">¬<em>Z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0010</span></td>&#13;
<td class="bg1"><span class="literal">cs</span> or <span class="literal">hs</span></td>&#13;
<td class="bg1">Carry set; unsigned higher or same</td>&#13;
<td class="bg1"><em>C</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0011</span></td>&#13;
<td class="bg"><span class="literal">cc</span> or <span class="literal">lo</span></td>&#13;
<td class="bg">Carry not set; unsigned lower</td>&#13;
<td class="bg">¬<em>C</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0100</span></td>&#13;
<td class="bg1"><span class="literal">mi</span></td>&#13;
<td class="bg1">Minus; negative</td>&#13;
<td class="bg1"><em>N</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0101</span></td>&#13;
<td class="bg"><span class="literal">pl</span></td>&#13;
<td class="bg">Plus; positive or zero</td>&#13;
<td class="bg">¬<em>N</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0110</span></td>&#13;
<td class="bg1"><span class="literal">vs</span></td>&#13;
<td class="bg1">Overflow</td>&#13;
<td class="bg1"><em>V</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0111</span></td>&#13;
<td class="bg"><span class="literal">vc</span></td>&#13;
<td class="bg">No overflow</td>&#13;
<td class="bg">¬<em>V</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1000</span></td>&#13;
<td class="bg1"><span class="literal">hi</span></td>&#13;
<td class="bg1">Unsigned higher</td>&#13;
<td class="bg1"><em>C</em> ∧ ¬<em>Z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1001</span></td>&#13;
<td class="bg"><span class="literal">ls</span></td>&#13;
<td class="bg">Unsigned lower or same</td>&#13;
<td class="bg">¬(<em>C</em> ∧ ¬<em>Z</em>)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1010</span></td>&#13;
<td class="bg1"><span class="literal">ge</span></td>&#13;
<td class="bg1">Signed greater than or equal</td>&#13;
<td class="bg1"><em>N</em> = <em>V</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1011</span></td>&#13;
<td class="bg"><span class="literal">lt</span></td>&#13;
<td class="bg">Signed less than</td>&#13;
<td class="bg">¬(<em>N</em> = <em>V</em> )</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1100</span></td>&#13;
<td class="bg1"><span class="literal">gt</span></td>&#13;
<td class="bg1">Signed greater than</td>&#13;
<td class="bg1">¬<em>Z</em> ∧ (<em>N</em> = <em>V</em> )</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1101</span></td>&#13;
<td class="bg"><span class="literal">le</span></td>&#13;
<td class="bg">Signed less than or equal</td>&#13;
<td class="bg">¬(¬<em>Z</em> ∧ (<em>N</em> = <em>V</em> ))</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1110</span></td>&#13;
<td class="bg1"><span class="literal">al</span></td>&#13;
<td class="bg1">Always</td>&#13;
<td class="bg1">Any</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1111</span></td>&#13;
<td class="bg"><span class="literal">nv</span></td>&#13;
<td class="bg">Always</td>&#13;
<td class="bg">Any</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You should use the <span class="literal">b.</span><span class="codeitalic">cond</span> instruction when you want to take one of two branches in your program, depending on the result of another operation. It’s important that the <span class="literal">b.</span><span class="codeitalic">cond</span> instruction immediately follow the instruction whose result is driving the decision to branch. An intervening instruction or function call might change the settings of the condition flags, giving an erroneous basis for the decision.</p>&#13;
<p class="indent">In addition to this, there are four instructions that branch depending on the value in a general-purpose register:</p>&#13;
<p class="noindenttL"><span class="codestrong">cbz</span><strong>—Compare and branch if zero</strong></p>&#13;
<p class="hang"><span class="literal">cbz w</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if the value in <span class="literal">w</span><span class="codeitalic">s</span> is <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="hang"><span class="literal">cbz x</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if the value in <span class="literal">x</span><span class="codeitalic">s</span> is <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_246"/><span class="codestrong">cbnz</span><strong>—Compare and branch if not zero</strong></p>&#13;
<p class="hang"><span class="literal">cbnz w</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if the value in <span class="literal">w</span><span class="codeitalic">s</span> is not <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="hang"><span class="literal">cbnz x</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if the value in <span class="literal">x</span><span class="codeitalic">s</span> is not <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">tbz</span><strong>—Test bit and branch if zero</strong></p>&#13;
<p class="hang"><span class="literal">tbz w</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">imm</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if bit number <span class="codeitalic">imm</span> in <span class="literal">w</span><span class="codeitalic">s</span> is <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="hang"><span class="literal">tbz x</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">imm</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if bit number <span class="codeitalic">imm</span> in <span class="literal">x</span><span class="codeitalic">s</span> is <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">tbnz</span><strong>—Test bit and branch if not zero</strong></p>&#13;
<p class="hang"><span class="literal">tbnz w</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">imm</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if bit number <span class="codeitalic">imm</span> in <span class="literal">w</span><span class="codeitalic">s</span> is not <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<p class="hang"><span class="literal">tbnz x</span><span class="codeitalic">s</span><span class="literal">,</span> <span class="codeitalic">imm</span><span class="literal">,</span> <span class="codeitalic">label</span> branches to <span class="codeitalic">label</span> if bit number <span class="codeitalic">imm</span> in <span class="literal">x</span><span class="codeitalic">s</span> is not <span class="literal">0</span>, in the range of ±1MB from this instruction.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When using a conditional branch like</em> <span class="codeitalic">b.gt</span> <em>or</em> <span class="codeitalic">b.le</span>, <em>it’s easy to forget the order of the test: source compared to destination, or destination compared to source. When testing my program, I almost always start by using</em> <span class="codeitalic">gdb</span> <em>and putting a breakpoint at the conditional branch instruction. When the program breaks, I check the values and use the</em> <span class="codeitalic">si</span> <em>command to see which way the branch went.</em></p>&#13;
</div>&#13;
<p class="indent">Now that you know how to control the flow of instruction execution, I’ll show you some programming constructs. We’ll start with repetition. This can be implemented in two ways: <em>iteration</em>, in which the program loops through a block of code repeatedly until a condition is met, and <em>recursion</em>, where a function calls itself repeatedly until a condition is met.</p>&#13;
<p class="indent">I’ll cover iteration in the next section and explain how recursion works when I discuss special uses of subfunctions in <a href="ch15.xhtml">Chapter 15</a>.</p>&#13;
<h3 class="h3" id="ch13lev1sec2"><strong>Iteration</strong></h3>&#13;
<p class="noindent">Many algorithms use iteration, also known as <em>looping</em>. A loop continues the iteration of a block of code until the value(s) of the <em>loop control variable(s)</em> meet a <em>termination condition</em> that causes the loop to end. With a looping construct, the value(s) of the loop control variable(s) must be changed within the iterated block of instructions.</p>&#13;
<p class="indent">Processing a text string one character at a time provides a good example of looping. I will use the two system call functions from <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> in <a href="ch02.xhtml">Chapter 2</a>, <span class="literal">write</span> and <span class="literal">read</span>, to illustrate the concepts. That figure shows that <span class="literal">printf</span> converts data from its memory storage format to a character format and calls the <span class="literal">write</span> system call function to display the characters on the screen. When reading characters from the keyboard, <span class="literal">scanf</span> calls the <span class="literal">read</span> system call function and converts the characters to a memory storage format.</p>&#13;
<h4 class="h4" id="ch13lev2sec3"><span epub:type="pagebreak" id="page_247"/><em><strong>write and read System Call Functions</strong></em></h4>&#13;
<p class="noindent">The <span class="literal">write</span> and <span class="literal">read</span> system call functions see the screen and keyboard as files. When a program is first launched, the operating system opens three files—<em>standard input</em>, <em>standard output</em>, and <em>standard error</em>—and assigns an integer to each file, which is called the <em>file descriptor</em>. The program interacts with each file by using the file descriptor. The C interfaces for calling <span class="literal">write</span> and <span class="literal">read</span> are specified in the <em>Portable Operating System Interface (POSIX)</em> standard, which you can find at <em><a href="https://pubs.opengroup.org/onlinepubs/9699919799/">https://pubs.opengroup.org/onlinepubs/9699919799/</a></em>.</p>&#13;
<p class="indent">The general formats for calling these two functions are</p>&#13;
<pre class="pre">int write(int <span class="codeitalic1">fd</span>, char *<span class="codeitalic1">buf</span>, int <span class="codeitalic1">n</span>);</pre>&#13;
<p class="noindent">and</p>&#13;
<pre class="pre">int read(int <span class="codeitalic1">fd</span>, char *<span class="codeitalic1">buf</span>, int <span class="codeitalic1">n</span>);</pre>&#13;
<p class="noindent">where <span class="codeitalic">fd</span> is the file descriptor, <span class="codeitalic">buf</span> is the address of the character storage, and <span class="codeitalic">n</span> is the number of characters to write or read. You can read more details in the man pages for <span class="literal">write</span> and <span class="literal">read</span>:</p>&#13;
<pre class="pre">&gt; <span class="codestrong1">man 2 write</span>&#13;
&gt; <span class="codestrong1">man 2 read</span></pre>&#13;
<p class="indent"><a href="ch13.xhtml#ch13tab2">Table 13-2</a> shows the file descriptors I’ll use and the device each is normally associated with.</p>&#13;
<p class="tabcap" id="ch13tab2"><strong>Table 13-2:</strong> The File Descriptors for the <span class="literal">write</span> and <span class="literal">read</span> System Call Functions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Name</strong></th>&#13;
<th class="tab_th"><strong>Number</strong></th>&#13;
<th class="tab_th"><strong>Use</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">STDIN_FILENO</span></td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">Read characters from the keyboard</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">STDOUT_FILENO</span></td>&#13;
<td class="bg">1</td>&#13;
<td class="bg">Write characters to the screen</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">STDERR_FILENO</span></td>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1">Write error messages to the screen</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These names are defined in the system header file, <em>unistd.h</em>, which is located at <em>/usr/include/unistd.h</em> on my Raspberry Pi O (note that the location on your system may be different). Now, let’s move on to looping constructs.</p>&#13;
<h4 class="h4" id="ch13lev2sec4"><em><strong>while Loop</strong></em></h4>&#13;
<p class="noindent">The <span class="literal">while</span> loop is a fundamental form of looping. Here is the form in C:</p>&#13;
<pre class="pre"><span class="codeitalic1">initialize loop control variable</span>&#13;
while (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">body</span>&#13;
    <span class="codeitalic1">change loop control variable</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>Before entering the <span class="literal">while</span> loop, you need to initialize the loop control variable. At the beginning of the <span class="literal">while</span> loop, <span class="codeitalic">expression</span> is evaluated as a Boolean. If it evaluates to false (<span class="literal">0</span> in C), control flow continues to <span class="codeitalic">next statement</span>. If <span class="codeitalic">expression</span> evaluates to true—that is, any nonzero value in C—the statements in <span class="codeitalic">body</span> are executed, the loop control variable is changed, and control flow continues at the top with the reevaluation of <span class="codeitalic">expression</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows the control flow of a <span class="literal">while</span> loop. Although the loop termination condition can be dependent on more than one variable, I’ll use just one here to clarify the discussion.</p>&#13;
<div class="image"><img id="ch13fig1" src="../images/pg276_Image_274.jpg" alt="image" width="220" height="642"/></div>&#13;
<p class="figcap"><em>Figure 13-1: The control flow of the</em> <span class="codeitalic">while</span> <em>loop</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list1">Listing 13-1</a> shows how to use a <span class="literal">while</span> loop to write a text string in the terminal window one character at a time.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world.c</em></p>&#13;
</div>&#13;
<pre class="pre">   // Write Hello, World! one character at a time.&#13;
 &#13;
   #include &lt;unistd.h&gt;&#13;
<span class="ent"><span epub:type="pagebreak" id="page_249"/>➊</span> #define NUL '\x00'&#13;
 &#13;
   int main(void)&#13;
{&#13;
  <span class="ent">➋</span> char *message_ptr = "Hello, World!\n";&#13;
 &#13;
  <span class="ent">➌</span> while (*message_ptr != NUL) {&#13;
      <span class="ent">➍</span> write(STDOUT_FILENO, message_ptr, 1);&#13;
      <span class="ent">➎</span> message_ptr++;&#13;
    }&#13;
 &#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list1"><em>Listing 13-1: A program to write “Hello, World!” one character at a time</em></p>&#13;
<p class="indent">I use the <span class="literal">#define</span> directive to give a symbolic name to the <span class="literal">NUL</span> character <span class="ent">❶</span>. The <span class="literal">message_ptr</span> variable is defined to be a pointer to a <span class="literal">char</span> type and is used as the loop control variable. It’s initialized to point to a text string <span class="ent">❷</span>. As you’ll see when we look at the assembly language for this code, the compiler will store the text string in a read-only part of memory and store the address of the first character in that text string in the <span class="literal">message_ptr</span> pointer variable.</p>&#13;
<p class="indent">The <span class="literal">while</span> statement first checks to see if the loop control variable, <span class="literal">message_ptr</span>, is pointing to the <span class="literal">NUL</span> character <span class="ent">❸</span>; if not, program flow enters the <span class="literal">while</span> loop body and writes the character pointed to by <span class="literal">message_ptr</span> to the screen <span class="ent">❹</span>. The loop control variable is then incremented to point to the next character in the text string <span class="ent">❺</span>. Program flow returns to the top of the loop, where the next character is checked to see if it’s the <span class="literal">NUL</span> character. This loop terminates when <span class="literal">message_ptr</span> points to the <span class="literal">NUL</span> character <span class="ent">❸</span>. Testing for this condition first means the program won’t even enter the body of the <span class="literal">while</span> loop if the string is empty, as <span class="literal">message_ptr</span> will only point to a <span class="literal">NUL</span> character. This is a subtle but important point about <span class="literal">while</span> loops: the code in the body is never executed if the termination condition is already met.</p>&#13;
<p class="indent">For <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, the compiler generated the assembly language shown in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "hello_world.c"&#13;
        .text&#13;
     <span class="ent">➊</span> .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "Hello, World!\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
     <span class="ent">➋</span> adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0<span epub:type="pagebreak" id="page_250"/>&#13;
        str     x0, [sp, 24]      /// message_ptr variable&#13;
     <span class="ent">➌</span> b       .L2               /// Go to check&#13;
.L3:&#13;
        mov     x2, 1             /// One character&#13;
        ldr     x1, [sp, 24]      /// Address in message_ptr&#13;
        mov     w0, 1             /// STDOUT_FILENO&#13;
        bl      write&#13;
        ldr     x0, [sp, 24]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp, 24]      /// message_ptr++;&#13;
.L2:&#13;
        ldr     x0, [sp, 24]&#13;
        ldrb    w0, [x0]          /// Current char&#13;
     <span class="ent">➍</span> cmp     w0, 0             /// NUL?&#13;
     <span class="ent">➎</span> bne     .L3               /// No, back to top&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch13list2"><em>Listing 13-2: The compiler-generated assembly language for the function in <a href="ch13.xhtml#ch13list1">Listing 13-1</a></em></p>&#13;
<p class="indent">The assembly language shows that the text string is stored in the <span class="literal">.rodata</span> section <span class="ent">❶</span>. Then, <span class="literal">message_ptr</span> is initialized to contain the address of the beginning of the text string <span class="ent">❷</span>.</p>&#13;
<p class="indent">Although this assembly language seems to be testing for the termination condition at the end of the loop <span class="ent">❹</span>, it follows the logical flow shown in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>. It first branches down to <span class="literal">.L2</span> <span class="ent">❸</span>, where the test is made for the terminating condition, before branching up to <span class="literal">.L3</span> to start execution of the body of the <span class="literal">while</span> loop <span class="ent">❺</span>. You might notice that the compiler used a <span class="literal">bne</span> instruction. This is the same as <span class="literal">b.ne</span>; the <span class="literal">.</span> character is optional when writing the conditional branch instructions.</p>&#13;
<p class="indent">There is a new instruction, <span class="literal">cmp</span> <span class="ent">❹</span>, in this code:</p>&#13;
<p class="noindenttL"><span class="codestrong">cmp</span><strong>—Compare</strong></p>&#13;
<p class="hang"><span class="literal">cmp</span> <span class="codeitalic">reg</span><span class="literal">,</span> <span class="codeitalic">imm</span> subtracts <span class="codeitalic">imm</span> from the value in <span class="codeitalic">reg</span> and sets the condition flags accordingly. The result of the subtraction is discarded.</p>&#13;
<p class="hang"><span class="literal">cmp</span> <span class="codeitalic">reg1</span><span class="literal">,</span> <span class="codeitalic">reg2</span> subtracts the value in <span class="codeitalic">reg2</span> from the value in <span class="codeitalic">reg1</span> and sets the condition flags accordingly. The result of the subtraction is discarded.</p>&#13;
<p class="noindenttL">A <span class="literal">cmp</span> instruction immediately followed by a conditional branch instruction is commonly used to make decisions in a program.</p>&#13;
<p class="indent">For comparison with what the compiler did, we’ll follow the <span class="literal">while</span> loop pattern in my assembly language version, shown in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_251"/><em>hello_world.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Write Hello, World! one character at a time.&#13;
        .arch armv8-a&#13;
// Useful names&#13;
        .equ    NUL, 0&#13;
        .equ    STDOUT, 1&#13;
// Stack frame&#13;
        .equ    save19, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
message:&#13;
        .string "Hello, World!\n"&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
        str     x19, [sp, save19]     // Save for caller&#13;
        adr     x19, message          // Address of message&#13;
loop:&#13;
        ldrb    w0, [x19]             // Load character&#13;
     <span class="ent">➊</span> cmp     w0, NUL               // End of string?&#13;
        b.eq    done                  // Yes&#13;
        mov     w2, 1                 // No, one char&#13;
        mov     x1, x19               // Address of char&#13;
        mov     x0, STDOUT            // Write on screen&#13;
        bl      write&#13;
        add     x19, x19, 1           // Increment pointer&#13;
        b       loop                  //   and continue&#13;
done:&#13;
        mov     w0, wzr               // Return 0&#13;
        ldr     x19, [sp, save 19]    // Restore reg&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch13list3"><em>Listing 13-3: An assembly language program to write Hello, World! one character at a time</em></p>&#13;
<p class="indent">We could have used a <span class="literal">cbz</span> instruction in our condition check instead of the <span class="literal">cmp</span> and <span class="literal">b.eq</span> sequence <span class="ent">❶</span>, but I think the use of <span class="literal">NUL</span> here is clearer. This solution will also work for any terminating character.</p>&#13;
<p class="indent">My assembly language solution is less efficient than what the compiler generated (<a href="ch13.xhtml#ch13list2">Listing 13-2</a>), because the <span class="literal">b</span> instruction is executed in addition to the conditional <span class="literal">b.eq</span> instruction with each iteration of the loop. The slight increase in execution time is usually worth the code readability improvement.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>A <span class="literal">while</span> loop works well when a <em>sentinel value</em>, which is a unique value that marks the end of a data sequence, is used as the termination condition. For example, the <span class="literal">while</span> loop in <a href="ch13.xhtml#ch13list1">Listings 13-1</a> and <a href="ch13.xhtml#ch13list3">13-3</a> works for any length of text string and continues writing one character at a time to the screen until it reaches the sentinel value, a <span class="literal">NUL</span> character. C has another looping construct, the <span class="literal">for</span> loop, that many programmers find to be more natural for some algorithms; we’ll look at that next.</p>&#13;
<h4 class="h4" id="ch13lev2sec5"><em><strong>for Loop</strong></em></h4>&#13;
<p class="noindent">Although their C syntax differs, the looping constructs <span class="literal">while</span> and <span class="literal">for</span> are semantically equivalent. The syntactical difference is that the <span class="codeitalic">for</span> <em>loop</em> allows you to group all three control elements—loop control variable initialization, checking, and changing—within the parentheses. The general form of a <span class="literal">for</span> loop in C is as follows:</p>&#13;
<pre class="pre">for (<span class="codeitalic1">initialize loop control variable</span>; <span class="codeitalic1">expression</span>; <span class="codeitalic1">change loop control variable</span>) {&#13;
    <span class="codeitalic1">body</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">Placing all the control elements within the parentheses is not required. In fact, we could also write a <span class="literal">for</span> loop as follows:</p>&#13;
<pre class="pre"><span class="codeitalic1">initialize loop control variable</span>&#13;
for (;<span class="codeitalic1">expression</span>;) {&#13;
    <span class="codeitalic1">body</span>&#13;
    <span class="codeitalic1">change loop control variable</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">Note that the <span class="literal">for</span> loop syntax does require the inclusion of both semicolons in the parentheses.</p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list4">Listing 13-4</a>, I have rewritten the program from <a href="ch13.xhtml#ch13list1">Listing 13-1</a> using a <span class="literal">for</span> loop.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world_for.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Write Hello, World! one character at a time.&#13;
 &#13;
#include &lt;unistd.h&gt;&#13;
#define NUL '\x00'&#13;
 &#13;
int main(void)&#13;
{&#13;
    char *message_ptr;&#13;
 &#13;
    for (message_ptr = "Hello, World!\n"; *message_ptr != NUL; message_ptr++) {&#13;
        write(STDOUT_FILENO, message_ptr, 1);&#13;
    }<span epub:type="pagebreak" id="page_253"/>&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list4"><em>Listing 13-4: A program to write Hello, World! using a</em> <span class="codeitalic">for</span> <em>loop</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Since the</em> <span class="codeitalic">for</span> <em>statement in this program controls only one C statement, you really don’t need the curly brackets around that statement. I usually include them anyway, because if I later modify the program and add another statement, I often forget that I then need the curly brackets.</em></p>&#13;
</div>&#13;
<p class="indent">You may wonder if either looping construct is better than the other. Here’s where your knowledge of assembly language becomes useful. When I used <span class="literal">gcc</span> to generate the assembly language for <a href="ch13.xhtml#ch13list4">Listing 13-4</a>, I got the same assembly language code I did for the <span class="literal">while</span> loop version in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>. Since the assembly language for the <span class="literal">for</span> loop is shown in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, I won’t repeat it here.</p>&#13;
<p class="indent">The conclusion we can reach from this comparison of a <span class="literal">for</span> loop with a <span class="literal">while</span> loop is that you should use the high-level language looping construct that feels natural for the problem you’re solving. It’s usually a subjective choice.</p>&#13;
<p class="indent">A <span class="literal">for</span> loop is often used for a <em>count-controlled loop</em>, in which the number of iterations is known before the loop is started. You’ll see an example of this usage in a moment, when we look at the selection constructs. First, though, let’s look at the third looping construct in C. This provides a different behavior: whereas the <span class="literal">while</span> loop and <span class="literal">for</span> loop constructs will skip the body of the loop if the termination conditions are met by the initial value of the loop control variable, it will always execute the loop body at least once.</p>&#13;
<h4 class="h4" id="ch13lev2sec6"><em><strong>do-while Loop</strong></em></h4>&#13;
<p class="noindent">In some situations, your algorithm needs to execute the body of the loop at least once. In these cases, the <span class="codeitalic">do-while</span> <em>loop</em> may be more natural. It has the following general form:</p>&#13;
<pre class="pre">do {&#13;
    <span class="codeitalic1">body</span>&#13;
    <span class="codeitalic1">change loop control variable</span>&#13;
} while (<span class="codeitalic1">expression</span>)&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">In the <span class="literal">do-while</span> looping construct, the value of the expression is computed at the end of the loop body. Looping continues until this evaluation results in a Boolean false.</p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list5">Listing 13-5</a>, I have rewritten the Hello, World! program using a <span class="literal">do-while</span> loop.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world_do.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Write Hello, World! one character at a time.&#13;
 &#13;
#include &lt;unistd.h&gt;<span epub:type="pagebreak" id="page_254"/>&#13;
#define NUL '\x00'&#13;
 &#13;
int main(void)&#13;
{&#13;
    char *message_ptr = "Hello, World!\n";&#13;
 &#13;
    do {&#13;
        write(STDOUT_FILENO, message_ptr, 1);&#13;
        message_ptr++;&#13;
    } while (*message_ptr != NUL);&#13;
 &#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list5"><em>Listing 13-5: A program to write Hello, World! using a</em> <span class="codeitalic">do-while</span> <em>loop</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This program has a potential bug! The</em> <span class="codeitalic">do-while</span> <em>loop construct will always execute the body of the loop at least once. Consider an empty text string, which is a single byte containing the</em> <span class="codeitalic">NUL</span> <em>character. A</em> <span class="codeitalic">do-while</span> <em>loop writes the</em> <span class="codeitalic">NUL</span> <em>character to the screen (which does nothing) and then checks the next byte in memory, which could be anything. If this byte is not a</em> <span class="codeitalic">NUL</span> <em>character, the</em> <span class="codeitalic">do-while</span> <em>loop will continue to execute, writing whatever characters this and the following bytes represent, until it reaches a</em> <span class="codeitalic">NUL</span> <em>character. The behavior of the program could be different each time it’s run, so the error may not show up in your testing.</em></p>&#13;
</div>&#13;
<p class="indent">We can use the assembly language generated by <span class="literal">gcc</span>, which is shown in <a href="ch13.xhtml#ch13list6">Listing 13-6</a>, to illustrate the difference between the <span class="literal">do-while</span> construct and the <span class="literal">while</span> and <span class="literal">for</span> constructs.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hello_world_do.s</em></p>&#13;
</div>&#13;
<pre class="pre">           .arch armv8-a&#13;
           .file   "hello_world_do.c"&#13;
           .text&#13;
           .section        .rodata&#13;
           .align  3&#13;
   .LC0:&#13;
           .string "Hello, World!\n"&#13;
           .text&#13;
           .align  2&#13;
           .global main&#13;
           .type   main, %function&#13;
   main:&#13;
           stp     x29, x30, [sp, -32]!&#13;
           mov     x29, sp&#13;
           adrp    x0, .LC0&#13;
           add     x0, x0, :lo12:.LC0&#13;
           str     x0, [sp, 24]      /// message_ptr variable&#13;
<span class="ent">➊</span> .L2:&#13;
           mov     x2, 1             /// One character<span epub:type="pagebreak" id="page_255"/>&#13;
           ldr     x1, [sp, 24]      /// Address in message_ptr&#13;
           mov     w0, 1             /// STDOUT_FILENO&#13;
           bl      write&#13;
           ldr     x0, [sp, 24]&#13;
           add     x0, x0, 1&#13;
           str     x0, [sp, 24]      /// message_ptr++;&#13;
           ldr     x0, [sp, 24]&#13;
           ldrb    w0, [x0]          /// Current char&#13;
        <span class="ent">➋</span> cmp     w0, 0             /// NUL?&#13;
           bne     .L2               /// No, back to top&#13;
           mov     w0, 0&#13;
           ldp     x29, x30, [sp], 32&#13;
           ret&#13;
           .size   main, .-main&#13;
           .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
           .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch13list6"><em>Listing 13-6: The compiler-generated assembly language for the function in <a href="ch13.xhtml#ch13list5">Listing 13-5</a></em></p>&#13;
<p class="indent">If you compare the assembly language shown in <a href="ch13.xhtml#ch13list6">Listing 13-6</a> with that in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, which shows the assembly language generated for both the <span class="literal">while</span> and <span class="literal">for</span> loops, you’ll see that the only difference is that the <span class="literal">do-while</span> loop doesn’t branch down to perform the loop control check <span class="ent">❷</span> before executing the loop for the first time <span class="ent">❶</span>. The <span class="literal">do-while</span> construct might seem more efficient, but in the assembly language, the only saving is a single branch the first time the loop is executed.</p>&#13;
<p class="indent">Next, we’ll look at how to select whether to execute a block of code.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch13exe1">13.1     Enter the three C programs in <a href="ch13.xhtml#ch13list1">Listings 13-1</a>, <a href="ch13.xhtml#ch13list4">13-4</a>, and <a href="ch13.xhtml#ch13list5">13-5</a>, and use the compiler to generate the assembly language for each of them. Compare the assembly language for the three looping constructs. Compilers change with version changes, so you should look at what your version of the compiler does.</p>&#13;
<p class="box-list1" id="ch13exe2">13.2     Write a program in assembly language that:</p>&#13;
<p class="alpha">(a)     Prompts the user to enter some text</p>&#13;
<p class="alpha">(b)     Uses the <span class="literal">read</span> system call function to read the entered text</p>&#13;
<p class="alpha">(c)     Echoes the user’s entered text in the terminal window</p>&#13;
<p class="box-listpL">You will need to allocate space on the stack for storing the characters entered by the user.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch13lev1sec3"><strong>Conditionals</strong></h3>&#13;
<p class="noindent">Another common flow construct is selection, where we determine whether to execute a block of code. I’ll start with the simplest case, determining whether to execute a single block based on a Boolean conditional statement, then I’ll show you how to use a Boolean conditional statement to select one <span epub:type="pagebreak" id="page_256"/>of two blocks. I’ll end the chapter by discussing ways to select between several blocks based on an integral value.</p>&#13;
<h4 class="h4" id="ch13lev2sec7"><em><strong>if</strong></em></h4>&#13;
<p class="noindent">The general form of an <span class="codeitalic">if</span> <em>conditional</em> in C is as follows:</p>&#13;
<pre class="pre">if (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">block</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">The <span class="codeitalic">expression</span> is evaluated as a Boolean. If it evaluates to false, or <span class="literal">0</span> in C, control flow continues to <span class="codeitalic">next statement</span>. If <span class="codeitalic">expression</span> evaluates to true (a nonzero value in C), the statements in <span class="codeitalic">block</span> are executed, and control flow continues to <span class="codeitalic">next statement</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list7">Listing 13-7</a> gives an example of an <span class="literal">if</span> statement that simulates flipping a coin 10 times and showing when it comes up heads.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>coin_flips1.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Flip a coin, show heads.&#13;
 &#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#define N_TIMES 10&#13;
 &#13;
int main()&#13;
{&#13;
    register int random_number;&#13;
    register int i;&#13;
 &#13;
 <span class="ent">➊</span> for (i = 0; i &lt; N_TIMES; i++) {&#13;
     <span class="ent">➋</span> random_number = random();&#13;
     <span class="ent">➌</span> if (random_number &lt; RAND_MAX/2) {&#13;
         <span class="ent">➍</span> puts("heads");&#13;
        }&#13;
    }&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list7"><em>Listing 13-7: A program to flip a coin and show when it comes up heads</em></p>&#13;
<p class="indent">This program uses a count-controlled <span class="literal">for</span> loop to simulate flipping a coin 10 times <span class="ent">❶</span>. The simulation involves calling the <span class="literal">random</span> function in the C standard library <span class="ent">❷</span>. If the random number is in the lower half of all possible values from the <span class="literal">random</span> function <span class="ent">❸</span>, we call that “heads.” To display this result we use the <span class="literal">puts</span> function in the C standard library, which prints a simple text string to the screen with an appended newline character <span class="ent">❹</span>. For <a href="ch13.xhtml#ch13list7">Listing 13-7</a>, the compiler generated the assembly language shown in <a href="ch13.xhtml#ch13list8">Listing 13-8</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_257"/><em>coin_flips1.s</em></p>&#13;
</div>&#13;
<pre class="pre">           .arch armv8-a&#13;
           .file   "coin_flips1.c"&#13;
           .text&#13;
           .section        .rodata&#13;
           .align  3&#13;
   .LC0:&#13;
           .string "heads"&#13;
           .text&#13;
           .align  2&#13;
           .global main&#13;
           .type   main, %function&#13;
   main:&#13;
           stp     x29, x30, [sp, -32]!&#13;
           mov     x29, sp&#13;
           stp     x19, x20, [sp, 16]  /// Use for i and random_number&#13;
           mov     w19, 0&#13;
           b       .L2&#13;
   .L4:&#13;
           bl      random&#13;
           mov     w20, w0             /// Random number&#13;
           mov     w0, 1073741822      /// RAND_MAX/2&#13;
           cmp     w20, w0&#13;
        <span class="ent">➊</span> bgt     .L3                 /// Skip message&#13;
           adrp    x0, .LC0&#13;
           add     x0, x0, :lo12:.LC0&#13;
           bl      puts&#13;
<span class="ent">➋</span> .L3:&#13;
           add     w19, w19, 1         /// i++;&#13;
   .L2:&#13;
           cmp     w19, 9&#13;
           ble     .L4                 /// Continue if &lt;= 9&#13;
           mov     w0, 0&#13;
           ldp     x19, x20, [sp, 16]  /// Restore regs for caller&#13;
           ldp     x29, x30, [sp], 32&#13;
           ret&#13;
           .size   main, .-main&#13;
           .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
           .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch13list8"><em>Listing 13-8: The compiler-generated assembly language for the function in <a href="ch13.xhtml#ch13list7">Listing 13-7</a></em></p>&#13;
<p class="indent">The <span class="literal">if</span> statement is implemented with a simple conditional branch. If the condition—in this case, <span class="literal">bgt</span>, for branch if greater than <span class="ent">❶</span>—is true, the program flow branches over the block of code that is controlled by the <span class="literal">if</span> statement <span class="ent">❷</span>. Next, I’ll show you how to select between two different blocks of code.</p>&#13;
<h4 class="h4" id="ch13lev2sec8"><span epub:type="pagebreak" id="page_258"/><em><strong>if-then-else</strong></em></h4>&#13;
<p class="noindent">The general form of an <span class="codeitalic">if-then-else</span> <em>conditional</em> in C is as follows (C does not use a <span class="literal">then</span> keyword):</p>&#13;
<pre class="pre">if (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">then block</span>&#13;
} else {&#13;
    <span class="codeitalic1">else block</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">The <span class="codeitalic">expression</span> is evaluated as a Boolean. If <span class="codeitalic">expression</span> evaluates to true, the statements in <span class="codeitalic">then block</span> are executed and control flow branches to <span class="codeitalic">next statement</span>. If it evaluates to false (<span class="literal">0</span> in C), control flow branches to <span class="codeitalic">else block</span> and then continues to <span class="codeitalic">next statement</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13fig2">Figure 13-2</a> shows the control flow of the <span class="literal">if-then-else</span> conditional.</p>&#13;
<div class="image"><img id="ch13fig2" src="../images/pg286_Image_275.jpg" alt="image" width="543" height="386"/></div>&#13;
<p class="figcap"><em>Figure 13-2: The control flow of an</em> <span class="codeitalic">if-then-else</span> <em>conditional</em></p>&#13;
<p class="indent">The coin-flipping program in <a href="ch13.xhtml#ch13list7">Listing 13-7</a> isn’t user-friendly because the user doesn’t know the total number of times the coin was flipped. We can improve the program by using an <span class="literal">if-then-else</span> conditional to print a message stating when the coin came up tails, as shown in <a href="ch13.xhtml#ch13list9">Listing 13-9</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>coin_flips2.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Flip a coin, showing heads or tails.&#13;
 &#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#define N_TIMES 10&#13;
 &#13;
int main()&#13;
{<span epub:type="pagebreak" id="page_259"/>&#13;
    register int random_number;&#13;
    register int i;&#13;
 &#13;
    for (i = 0; i &lt; N_TIMES; i++) {&#13;
        random_number = random();&#13;
        if (random_number &lt; RAND_MAX/2) {&#13;
            puts("heads");&#13;
        } else {&#13;
            puts("tails");&#13;
        }&#13;
    }&#13;
 &#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list9"><em>Listing 13-9: A program to flip a coin and declare it heads or tails</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list10">Listing 13-10</a> shows the assembly language the compiler generates for <a href="ch13.xhtml#ch13list9">Listing 13-9</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>coin_flips2.s</em></p>&#13;
</div>&#13;
<pre class="pre">           .arch armv8-a&#13;
           .file   "coin_flips2.c"&#13;
           .text&#13;
           .section        .rodata&#13;
           .align  3&#13;
   .LC0:&#13;
           .string "heads"&#13;
           .align  3&#13;
   .LC1:&#13;
           .string "tails"&#13;
           .text&#13;
           .align  2&#13;
           .global main&#13;
           .type   main, %function&#13;
   main:&#13;
           stp     x29, x30, [sp, -32]!&#13;
           mov     x29, sp&#13;
           stp     x19, x20, [sp, 16]&#13;
           mov     w19, 0&#13;
           b       .L2&#13;
   .L5:&#13;
           bl      random&#13;
           mov     w20, w0&#13;
           mov     w0, 1073741822&#13;
           cmp     w20, w0&#13;
           bgt     .L3                 /// Go to else block&#13;
           adrp    x0, .LC0            /// Then block&#13;
           add     x0, x0, :lo12:.LC0&#13;
           bl      puts<span epub:type="pagebreak" id="page_260"/>&#13;
        <span class="ent">➊</span> b       .L4                 /// Branch over else block&#13;
   .L3:&#13;
           adrp    x0, .LC1            /// Else block&#13;
           add     x0, x0, :lo12:.LC1&#13;
           bl      puts&#13;
<span class="ent">➋</span> .L4:&#13;
           add     w19, w19, 1         /// Next statement&#13;
   .L2:&#13;
           cmp     w19, 9&#13;
           ble     .L5&#13;
           mov     w0, 0&#13;
           ldp     x19, x20, [sp, 16]&#13;
           ldp     x29, x30, [sp], 32&#13;
           ret&#13;
           .size   main, .-main&#13;
           .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
           .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch13list10"><em>Listing 13-10: The compiler-generated assembly language for the function in <a href="ch13.xhtml#ch13list9">Listing 13-9</a></em></p>&#13;
<p class="indent">The assembly language shows that we need an unconditional branch at the end of the <span class="literal">then</span> block <span class="ent">❶</span> to branch over the <span class="literal">else</span> block <span class="ent">❷</span>.</p>&#13;
<p class="indent">My assembly language design of the coin-flipping program differs slightly, as shown in <a href="ch13.xhtml#ch13list11">Listing 13-11</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>coin_flips2.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Flip a coin, showing heads or tails.&#13;
        .arch armv8-a&#13;
// Useful names&#13;
        .equ    N_TIMES, 10           // Number of flips&#13;
        .equ    RAND_MID, 1073741822  // RAND_MAX/2&#13;
// Stack frame&#13;
        .equ    save19, 28&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
heads_msg:&#13;
        .string "heads"&#13;
tails_msg:&#13;
        .string "tails"&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
        str     w19, [sp, save19]     // Save for i local var&#13;
        mov     w19, wzr              // i = 0<span epub:type="pagebreak" id="page_261"/>&#13;
loop:&#13;
        mov     w0, N_TIMES           // Total number of times&#13;
        cmp     w19, w0               // Is i at end?&#13;
        b.hs    done                  // Yes&#13;
        bl      random                // No, get random number&#13;
        mov     w1, RAND_MID          // Halfway&#13;
     <span class="ent">➊</span> cmp     w1, w0                // Above or below middle?&#13;
        b.hi    tails                 // Above -&gt; tails&#13;
        adr     x0, heads_msg         // Below -&gt; heads message&#13;
        bl      puts                  // Print message&#13;
        b       continue              // Skip else part&#13;
tails:&#13;
        adr     x0, tails_msg         // Tails message address&#13;
        bl      puts                  // Print message&#13;
continue:&#13;
        add     w19, w19, 1           // Increment i&#13;
        b       loop                  //   and continue loop&#13;
done:&#13;
        mov     w0, wzr               // Return 0&#13;
        ldr     w19, [sp, save19]     // Restore reg&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret                           // Back to caller</pre>&#13;
<p class="list" id="ch13list11"><em>Listing 13-11: An assembly language design for the coin-flipping program</em></p>&#13;
<p class="indent">The <span class="literal">random</span> function returns a random number in the <span class="literal">w0</span> register. I leave it there for comparison with the halfway point, which I’ve loaded into the <span class="literal">w1</span> register <span class="ent">❶</span>. The <span class="literal">w0</span> and <span class="literal">w1</span> registers don’t need to be saved in a function. The compiler used <span class="literal">w20</span> for the <span class="literal">random_number</span> variable, which does need to be saved.</p>&#13;
<p class="indent">When deciding which registers to use for variables in a function, it’s important that you check the rules in <a href="ch11.xhtml#ch11tab3">Table 11-3</a> in <a href="ch11.xhtml">Chapter 11</a>. That table says that a function must preserve the value in <span class="literal">x19</span> for the calling function. You can probably see the importance of having agreed-upon rules here. Not only must our function return to the calling function with its value in <span class="literal">x19</span> preserved, but we can assume that the functions that our function calls also preserve our value in <span class="literal">x19</span>. So, it’s safe to assume that the value remains the same through a function call.</p>&#13;
<p class="indent">I won’t go into the details here, but if you need to select one of several blocks of code to execute, you can use the <span class="literal">else-if</span> statement in a <em>ladder construct</em>. The general form is as follows:</p>&#13;
<pre class="pre">if (<span class="codeitalic1">expression_1</span>) {&#13;
    <span class="codeitalic1">block_1</span>&#13;
} else if (<span class="codeitalic1">expression_2</span>)  {&#13;
    <span class="codeitalic1">block_2</span>&#13;
}&#13;
⋮<span epub:type="pagebreak" id="page_262"/>&#13;
} else if (<span class="codeitalic1">expression_n-1</span>) {&#13;
    <span class="codeitalic1">block_n-1</span>&#13;
} else {&#13;
    <span class="codeitalic1">block_n</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">The <span class="literal">if-then-else</span> selection is based on a Boolean evaluation of the controlling expression, but as you’ll see in the next section, there are algorithms in which the selection is based on a discrete value, which is used to select one of several cases.</p>&#13;
<h4 class="h4" id="ch13lev2sec9"><em><strong>switch</strong></em></h4>&#13;
<p class="noindent">C provides a <span class="codeitalic">switch</span> <em>conditional</em>, where control flow branches to a place in a list of code blocks depending on the value of a selector. The general form of the <span class="literal">switch</span> is as follows:</p>&#13;
<pre class="pre">switch (<span class="codeitalic1">selector</span>) {&#13;
    case <span class="codeitalic1">selector_1</span>:&#13;
        <span class="codeitalic1">block_1</span>&#13;
    case <span class="codeitalic1">selector_2</span>:&#13;
        <span class="codeitalic1">block_2</span>&#13;
    ⋮&#13;
    case <span class="codeitalic1">selector_n</span>:&#13;
        <span class="codeitalic1">block_n</span>&#13;
    default:&#13;
        <span class="codeitalic1">default block</span>&#13;
}&#13;
<span class="codeitalic1">next statement</span></pre>&#13;
<p class="indent">The <span class="codeitalic">selector</span> can be any expression that evaluates to an integer. Each <span class="codeitalic">selector_1</span>, <span class="codeitalic">selector_2</span>, . . . , <span class="codeitalic">selector_n</span> must be an integer constant. The <span class="literal">switch</span> will branch to the <span class="literal">case</span> whose <span class="codeitalic">selector_1</span>, <span class="codeitalic">selector_2</span>, . . . , <span class="codeitalic">selector_n</span> is equal to the <span class="codeitalic">selector</span> evaluation. If <span class="codeitalic">selector</span> does not evaluate to any of the <span class="codeitalic">selector_1</span>, <span class="codeitalic">selector_2</span>, . . . , <span class="codeitalic">selector_n</span> integers, the <span class="literal">switch</span> branches to <span class="literal">default</span>. After executing the corresponding <span class="codeitalic">block_1</span>, <span class="codeitalic">block_2</span>, . . . , <span class="codeitalic">block_n</span>, program flow continues through the remaining blocks of code. A <span class="literal">break</span> statement at any place in the <span class="literal">switch</span> will exit the <span class="literal">switch</span> at that point and branch down to <span class="codeitalic">next statement</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list12">Listing 13-12</a> shows how to use a <span class="literal">switch</span> statement in C.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>switch.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Select one of three or default.&#13;
 &#13;
#include &lt;stdio.h&gt;&#13;
#define N_TIMES 10&#13;
 &#13;
int main(void)&#13;
{<span epub:type="pagebreak" id="page_263"/>&#13;
    register int selector;&#13;
    register int i;&#13;
 &#13;
    for (i = 1; i &lt;= N_TIMES; i++) {&#13;
        selector = i;&#13;
        switch (selector) {&#13;
            case 1:&#13;
                puts("i = 1");&#13;
             <span class="ent">➊</span> break;&#13;
            case 2:&#13;
                puts("i = 2");&#13;
                break;&#13;
            case 3:&#13;
                puts("i = 3");&#13;
                break;&#13;
            default:&#13;
                puts("i &gt; 3");&#13;
        }&#13;
    }&#13;
 &#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch13list12"><em>Listing 13-12: A</em> <span class="codeitalic">switch</span> <em>statement</em></p>&#13;
<p class="indent">I want this program to execute only the case corresponding to the value of <span class="literal">i</span>. To prevent it from executing the following cases in the <span class="literal">switch</span>, I end each block with a <span class="literal">break</span> statement, which causes an exit from the <span class="literal">switch</span> <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows how the compiler implemented this <span class="literal">switch</span>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>switch.s</em></p>&#13;
</div>&#13;
<pre class="pre">           .arch armv8-a&#13;
           .file   "switch.c"&#13;
           .text&#13;
           .section        .rodata&#13;
           .align  3&#13;
   .LC0:&#13;
           .string "i = 1"&#13;
           .align  3&#13;
   .LC1:&#13;
           .string "i = 2"&#13;
           .align  3&#13;
   .LC2:&#13;
           .string "i = 3"&#13;
           .align  3&#13;
   .LC3:&#13;
           .string "i &gt; 3"&#13;
           .text&#13;
           .align  2&#13;
           .global main<span epub:type="pagebreak" id="page_264"/>&#13;
           .type   main, %function&#13;
   main:&#13;
           stp     x29, x30, [sp, -32]!&#13;
           mov     x29, sp&#13;
           mov     w0, 1&#13;
           str     w0, [sp, 28]&#13;
           b       .L2&#13;
<span class="ent">➊</span> .L8:                              /// Branch logic to decide&#13;
           ldr     w0, [sp, 28]      ///   which block to execute&#13;
           cmp     w0, 3&#13;
           beq     .L3&#13;
           ldr     w0, [sp, 28]&#13;
           cmp     w0, 3&#13;
           bgt     .L4&#13;
           ldr     w0, [sp, 28]&#13;
           cmp     w0, 1&#13;
           beq     .L5&#13;
           ldr     w0, [sp, 28]&#13;
           cmp     w0, 2&#13;
           beq     .L6&#13;
           b       .L4&#13;
<span class="ent">➋</span> .L5:                              /// Blocks to select from&#13;
           adrp    x0, .LC0&#13;
           add     x0, x0, :lo12:.LC0&#13;
           bl      puts&#13;
           b       .L7&#13;
   .L6:&#13;
           adrp    x0, .LC1&#13;
           add     x0, x0, :lo12:.LC1&#13;
           bl      puts&#13;
           b       .L7&#13;
   .L3:&#13;
           adrp    x0, .LC2&#13;
           add     x0, x0, :lo12:.LC2&#13;
           bl      puts&#13;
           b       .L7&#13;
   .L4:&#13;
           adrp    x0, .LC3&#13;
           add     x0, x0, :lo12:.LC3&#13;
           bl      puts&#13;
   .L7:&#13;
           ldr     w0, [sp, 28]&#13;
           add     w0, w0, 1&#13;
           str     w0, [sp, 28]&#13;
   .L2:&#13;
           ldr     w0, [sp, 28]&#13;
           cmp     w0, 10<span epub:type="pagebreak" id="page_265"/>&#13;
           ble     .L8&#13;
           mov     w0, 0&#13;
           ldp     x29, x30, [sp], 32&#13;
           ret&#13;
           .size   main, .-main&#13;
           .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
           .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch13list13"><em>Listing 13-13: Compiler-generated assembly language for the function in <a href="ch13.xhtml#ch13list12">Listing 13-12</a></em></p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list13">Listing 13-13</a>, the compiler creates two parts for the <span class="literal">switch</span>. The first part is the logic to decide which block of code to execute <span class="ent">❶</span>. Depending on the value of the selector, this will transfer program flow to the correct block in the second part <span class="ent">❷</span>.</p>&#13;
<p class="indent">Now, let’s look at another way to implement a <span class="literal">switch</span>: a <em>branch table</em>, also called a <em>jump table</em>. A branch table is a table of the block addresses that we need to select from. We need to design an algorithm that will select the correct address in the table, based on the value of the selector, and then branch to that address.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows one way to do this for our current example.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>switch.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Select one of three or default.&#13;
        .arch armv8-a&#13;
// Useful names&#13;
        .equ    N_TIMES, 10           // Number of loops&#13;
        .equ    DEFAULT, 4            // Default case&#13;
// Stack frame&#13;
        .equ    save1920, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
one_msg:&#13;
        .string "i = 1"&#13;
two_msg:&#13;
        .string "i = 2"&#13;
three_msg:&#13;
        .string "i = 3"&#13;
over_msg:&#13;
        .string "i &gt; 3"&#13;
// Branch table&#13;
     <span class="ent">➊</span> .align  3&#13;
br_table:&#13;
     <span class="ent">➋</span> .quad   one                   // Addresses where messages&#13;
        .quad   two                   //   are printed&#13;
        .quad   three&#13;
        .quad   default&#13;
// Program code&#13;
        .text&#13;
        .align  2<span epub:type="pagebreak" id="page_266"/>&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
     <span class="ent">➌</span> stp     x19, x20, [sp, save1920]  // Save for caller&#13;
        mov     x19, 1                // i = 1&#13;
        mov     x20, DEFAULT          // Default case&#13;
loop:&#13;
        cmp     x19, N_TIMES          // Is i at end?&#13;
        b.hi    done                  // Yes, leave loop&#13;
     <span class="ent">➍</span> adr     x0, br_table          // Address of branch table&#13;
        cmp     x19, x20              // Default case?&#13;
     <span class="ent">➎</span> csel    x1, x19, x20, lo      // Low, use i&#13;
     <span class="ent">➏</span> sub     x1, x1, 1             // Relative to first table entry&#13;
     <span class="ent">❼</span> add     x0, x0, x1, lsl 3     // Add address offset in table&#13;
     <span class="ent">❽</span> ldr     x0, [x0]              // Load address from table&#13;
        br      x0                    //   and branch there&#13;
one:&#13;
        adr     x0, one_msg           // = 1&#13;
        bl      puts                  // Write to screen&#13;
        b       continue&#13;
two:&#13;
        adr     x0, two_msg           // = 2&#13;
        bl      puts                  // Write to screen&#13;
        b       continue&#13;
three:&#13;
        adr     x0, three_msg         // = 3&#13;
        bl      puts                  // Write to screen&#13;
        b       continue&#13;
default:&#13;
        adr     x0, over_msg          // &gt; 3&#13;
        bl      puts                  // Write to screen&#13;
continue:&#13;
        add     x19, x19, 1           // Increment i&#13;
        b       loop                  //   and continue loop&#13;
done:&#13;
        mov     w0, wzr               // Return 0&#13;
        ldp     x19, x20, [sp, save1920]  // Restore reg&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret                           // Back to caller</pre>&#13;
<p class="list" id="ch13list14"><em>Listing 13-14: An assembly language design for using a branch table</em></p>&#13;
<p class="indent">Each entry in the branch table is the address of the code block to execute for the corresponding value of the selector variable. The <span class="literal">.quad</span> assembler directive tells the assembler to allocate 8 bytes of memory and initialize it to the value of the operand <span class="ent">❷</span>. We’re using it to store the address of each of the <span epub:type="pagebreak" id="page_267"/>code blocks our algorithm will select from. Since the items in our branch table are 64-bit addresses, we need to align the beginning of the table at a 64-bit address boundary <span class="ent">❶</span>.</p>&#13;
<p class="indent">Our algorithm uses <span class="literal">x19</span> and <span class="literal">x20</span> as local variables, and the procedure call standard states that we need to save their contents for the calling function (see <a href="ch11.xhtml#ch11tab3">Table 11-3</a> in <a href="ch11.xhtml">Chapter 11</a>) <span class="ent">❸</span>. We can also assume that their contents will be preserved by the functions we call from this function.</p>&#13;
<p class="indent">We need to determine which block address to load from the branch table. We start with the address of the beginning of the table <span class="ent">❹</span>. Then, we compare the current value of <span class="literal">i</span>, in <span class="literal">x19</span>, with the number of the default case. If the value of <span class="literal">i</span> is lower than the default case, we’ll use the <span class="literal">csel</span> instruction to move that value into <span class="literal">x1</span>. If it’s the same or higher, the <span class="literal">csel</span> instruction moves the number of the default case in <span class="literal">x20</span> to <span class="literal">x1</span> <span class="ent">❹</span>. Now that we have the case number in <span class="literal">x1</span>, we need to subtract 1 to get the offset in the table from the first item in the table <span class="ent">❻</span>.</p>&#13;
<p class="indent">Next, we need to convert the case offset to an address offset so we can add it to the address of the beginning of the branch table. Each item in the branch table is 8 bytes wide. We use an option of the <span class="literal">add</span> instruction to shift the value of our offset, in <span class="literal">x1</span>, 3 bits to the left <span class="ent">❼</span>. This multiplies the offset by 8 before adding it to the beginning address of the branch table, in <span class="literal">x0</span>.</p>&#13;
<p class="indent">Now, <span class="literal">x0</span> contains the address in the branch table of the item we want. We replace the address of the item with the item itself, which is the address of the block to execute <span class="ent">❽</span>.</p>&#13;
<p class="indent">The <span class="literal">csel</span> instruction can be useful for a simple <span class="literal">if-then-else</span> construct when you’re selecting between two values in registers. It takes this form:</p>&#13;
<p class="noindenttL"><span class="codestrong">csel</span><strong>—Conditional select</strong></p>&#13;
<p class="hang"><span class="literal">csel</span> <span class="codeitalic">reg1, reg2, reg3, cond</span> tests the settings in the <span class="literal">nzcv</span> register and moves <span class="codeitalic">reg2</span> to <span class="codeitalic">reg1</span> if <span class="codeitalic">cond</span> is true or moves <span class="codeitalic">reg3</span> to <span class="codeitalic">reg1</span> if <span class="codeitalic">cond</span> is false.</p>&#13;
<p class="indenttL">You now know two ways to implement a <span class="literal">switch</span> construct. It’s difficult to say whether a branch table is more efficient than an <span class="literal">if-else</span> ladder. For a large number of cases, an <span class="literal">if-else</span> ladder may require many tests before reaching the correct case to select. The efficiency also depends on things such as cache usage and the internal CPU design, and it can vary between CPU implementations that use the same instruction set. Any differences between the two techniques will probably be insignificant, so you should choose the one that seems to better match the problem you’re solving.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch13exe3">13.3     Change the assembly language program in <a href="ch13.xhtml#ch13list11">Listing 13-11</a> so that it sees the lowest one-fourth and the highest one-fourth of the random numbers (<span class="literal">0</span> to <span class="literal">RAND_MAX/4</span> and <span class="literal">3*RAND_MAX/4</span> to <span class="literal">RAND_MAX</span>) as heads. It will see the middle half of the random numbers (<span class="literal">RAND_MAX/4</span> to <span class="literal">3*RAND_MAX/4</span>) as tails.</p>&#13;
<p class="box-list1"><span epub:type="pagebreak" id="page_268"/>13.4     Remove the <span class="literal">break</span> statements in the program in <a href="ch13.xhtml#ch13list12">Listing 13-12</a>. How does this change the behavior of the program? Generate the assembly language from your changed program and compare it to that in <a href="ch13.xhtml#ch13list13">Listing 13-13</a>.</p>&#13;
<p class="box-list1" id="ch13exe5">13.5     Change the program in <a href="ch13.xhtml#ch13list14">Listing 13-14</a> so that it uses <span class="literal">if</span> conditionals instead of the <span class="literal">csel</span> instruction.</p>&#13;
<p class="box-list1" id="ch13exe6">13.6     Rewrite the program in <a href="ch13.xhtml#ch13list14">Listing 13-14</a> so that it uses a ladder of <span class="literal">if-else</span> conditionals instead of a <span class="literal">switch</span>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch13lev1sec4"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Unconditional branch</strong> Changes the program counter to alter the control flow.</p>&#13;
<p class="noindentin"><strong>Conditional branch</strong> Evaluates Boolean combinations of the status flags in the <span class="literal">nzcv</span> register and alters control flow if the combination evaluates to true.</p>&#13;
<p class="noindentin"><span class="codestrong">while</span> <strong>loop</strong> Checks for a Boolean condition and then iterates a block of code until the condition becomes false.</p>&#13;
<p class="noindentin"><span class="codestrong">for</span> <strong>loop</strong> Checks for a Boolean condition and then iterates a block of code until the condition becomes false.</p>&#13;
<p class="noindentin"><span class="codestrong">do-while</span> <strong>loop</strong> Executes a block of code once and iterates it until a Boolean condition becomes false.</p>&#13;
<p class="noindentin"><span class="codestrong">if</span> <strong>conditional</strong> Checks for a Boolean condition and then executes a block of code if the condition is true.</p>&#13;
<p class="noindentin"><span class="codestrong">if-then-else</span> <strong>conditional</strong> Checks for a Boolean condition and then executes one of two blocks of code, depending on whether the condition is true or false.</p>&#13;
<p class="noindentin"><span class="codestrong">switch</span> <strong>conditional</strong> Evaluates an expression and then branches to a location in a list of blocks of code, depending on the integer value of the expression.</p>&#13;
</div>&#13;
<p class="indent">Now that you know about control flow constructs and the <span class="literal">main</span> function, we’ll move on to discuss how to write your own subfunctions. In the next chapter, you’ll learn how to pass arguments and how to access those arguments in the subfunction.</p>&#13;
</div>
</div>
</body></html>