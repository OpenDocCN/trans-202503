<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_233"/><strong><span class="big">14</span><br/>UEFI BOOT VS. THE MBR/VBR BOOT PROCESS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">As we’ve seen, bootkit development follows the evolution of the boot process. With Windows 7’s introduction of the Kernel-Mode Code Signing Policy, which made it hard to load arbitrary code into the kernel, came the resurgence of bootkits that targeted the boot process logic before any signing checks applied (for example, by targeting the VBR, which could not be protected at the time). Likewise, because the UEFI standard supported in Windows 8 is replacing legacy boot processes like the MBR/VBR boot flow, it is also becoming the next boot infection target.</p>
<p class="indent">The modern UEFI is very different from legacy approaches. The legacy BIOS developed alongside the first PC-compatible computer firmware and, in its early days, was a simple piece of code that configured the PC hardware during initial setup to boot all other software. But as PC hardware grew in complexity, more complex firmware code was needed to configure it, so <span epub:type="pagebreak" id="page_234"/>the UEFI standard was developed to control the sprawling complexity in a uniform structure. Nowadays, almost all modern computer systems are expected to employ UEFI firmware for their configuration; the legacy BIOS process is increasingly relegated to simpler embedded systems.</p>
<p class="indent">Prior to the introduction of the UEFI standard, BIOS implementations by different vendors shared no common structure. This lack of consistency created obstacles for attackers, who were forced to target every BIOS implementation separately, but it was also a challenge for defenders, who had no unified mechanism for protecting the integrity of the boot process and control flow. The UEFI standard enabled defenders to create such a mechanism, which became known as the UEFI Secure Boot.</p>
<p class="indent">Partial support for UEFI started with Windows 7, but support for UEFI Secure Boot was not introduced until Windows 8. Alongside Secure Boot, Microsoft continues supporting the MBR-based legacy boot process via UEFI’s Compatibility Support Module (CSM), which is not compatible with Secure Boot and does not offer its integrity guarantees, as discussed shortly. Whether or not this legacy support via CSM is disabled in the future, UEFI is clearly the next step in the evolution of the boot process and, thus, the arena where the bootkit’s and the boot defense’s codevelopment will occur.</p>
<p class="indent">In this chapter, we’ll focus on the specifics of the UEFI boot process, specifically on its differences from the legacy boot MBR/VBR infection approaches.</p>
<h3 class="h3" id="ch14lev1sec1"><strong>The Unified Extensible Firmware Interface</strong></h3>
<p class="noindent">UEFI is a specification (<em><a href="https://www.uefi.org">https://www.uefi.org</a></em>) that defines a software interface between an operating system and the firmware. It was originally developed by Intel to replace the widely divergent legacy BIOS boot software, which was also limited to 16-bit mode and thus unsuitable for new hardware. These days, UEFI firmware dominates in the PC market with Intel CPUs, and ARM vendors are also moving toward it. As mentioned, for compatibility reasons, some UEFI-based firmware contains a Compatibility Support Module to support the legacy BIOS boot process for previous generations of operating systems; however, Secure Boot cannot be supported under CSM.</p>
<p class="indent">The UEFI firmware resembles a miniature operating system that even has its own network stack. It contains a few million lines of code, mostly in C, with some assembly language mixed in for platform-specific parts. The UEFI firmware is thus much more complex and provides more functionality than its legacy BIOS precursors. And, unlike the legacy BIOS, its core parts are open source, a characteristic that, along with code leaks (for example, the AMI source code leak of 2013), has opened up possibilities for external vulnerability researchers. Indeed, a wealth of information about UEFI vulnerabilities and attack vectors has been released over the years, some of which will be covered in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_235"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The inherent complexity of UEFI firmware is one of the main causes of a number of UEFI vulnerabilities and attack vectors reported over the years. The availability of the source code and greater openness of UEFI firmware implementation details, however, is not. Source code availability shouldn’t have a negative impact on security and, in fact, has the opposite effect.</em></p>
</div>
<h3 class="h3" id="ch14lev1sec2"><strong>Differences Between the Legacy BIOS and UEFI Boot Processes</strong></h3>
<p class="noindent">From a security standpoint, the main differences in UEFI’s boot process derive from the aim of supporting Secure Boot: the flow logic of the MBR/VBR is eliminated and completely replaced by UEFI components. We’ve mentioned Secure Boot a few times already, and now we’ll look at it more closely as we examine the UEFI process.</p>
<p class="indent">Let’s first review the examples of malicious OS boot modifications we’ve seen so far and the bootkits that inflict them:</p>
<ul>
<li class="noindent">MBR boot code modification (TDL4)</li>
<li class="noindent">MBR partition table modification (Olmasco)</li>
<li class="noindent">VBR BIOS parameter block (Gapz)</li>
<li class="noindent">IPL bootstrap code modification (Rovnix)</li>
</ul>
<p class="indent">From this list, we can see that the techniques for infecting the boot process all depend on violating the integrity of the next stage that’s loaded. UEFI Secure Boot is meant to change that pattern by establishing a chain of trust through which the integrity of each stage in the flow is verified before that stage is loaded and given control.</p>
<h4 class="h4" id="ch14lev2sec1"><strong><em>The Boot Process Flow</em></strong></h4>
<p class="noindent">The task of the MBR-based legacy BIOS was merely to apply the necessary hardware configurations and then transfer control to each succeeding stage of the boot code—from boot code to MBR to VBR and finally to an OS bootloader (for instance, to <em>bootmgr</em> and <em>winload.exe</em> in the case of Windows); the rest of the flow logic was beyond its responsibility.</p>
<p class="indent">The boot process in UEFI is substantially different. The MBR and VBR no longer exist; instead, UEFI’s own single piece of boot code is responsible for loading the <em>bootmgr</em>.</p>
<h4 class="h4" id="ch14lev2sec2"><strong><em>Disk Partitioning: MBR vs. GPT</em></strong></h4>
<p class="noindent">UEFI also differs from the legacy BIOS in the kind of partition table it uses. Unlike the legacy BIOS, which uses an MBR-style partition table, UEFI supports the <em>GUID Partition Table (GPT)</em>. The GPT is rather different from the MBR. MBR tables support only four primary or extended partition slots (with multiple logical partitions in an extended partition, if needed), whereas a GPT supports a much larger number of partitions, <span epub:type="pagebreak" id="page_236"/>each of which is identified by a unique 16-byte identification Globally Unique Identifier, or GUID. Overall, MBR partitioning rules are more complex than those of the GPT; the GPT style allows larger partition sizes and has a flat table structure, at the cost of using GUID labels rather than small integers to identify partitions. This flat table structure simplifies certain aspects of partition management under UEFI.</p>
<p class="indent">To support the UEFI boot process, the new GPT partitioning scheme specifies a dedicated partition from which the UEFI OS bootloader is loaded (in the legacy MBR table, this role was played by an “active” bit flag set on a primary partition). This special partition is referred to as the <em>EFI system partition</em>, and it is formatted with the FAT32 filesystem (although FAT12 and FAT16 are also possible). The path to this bootloader within the partition’s filesystem is specified in a dedicated <em>nonvolatile random access memory (NVRAM)</em> variable, also known as a UEFI variable. NVRAM is a small memory storage module, located on PC motherboards, that is used to store the BIOS and operating system configuration settings.</p>
<p class="indent">For Microsoft Windows, the path to the bootloader on a UEFI system looks like <em>\EFI\Microsoft\Boot\bootmgfw.efi</em>. The purpose of this module is to locate the operating system kernel loader—<em>winload.efi</em> for modern Windows versions with UEFI support—and transfer control to it. The functionality of <em>winload.efi</em> is essentially the same as that of <em>winload.exe</em>: to load and initialize the operating system kernel image.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig01">Figure 14-1</a> shows the boot process flow for legacy BIOS versus UEFI, skipping those MBR and VBR steps.</p>
<div class="image"><a id="ch14fig01"/><img src="../images/14fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-1: The difference in boot flow between legacy BIOS and UEFI systems</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_237"/>As you can see, UEFI-based systems do much more in firmware before transferring control to the operating system bootloader than does a legacy BIOS. There are no intermediate stages like the MBR/VBR bootstrap code; the boot process is fully controlled by the UEFI firmware alone, whereas the BIOS firmware only took care of platform initialization, letting the operating system loaders (<em>bootmgr</em> and <em>winload.exe</em>) do the rest.</p>
<h4 class="h4" id="ch14lev2sec3"><strong><em>Other Differences</em></strong></h4>
<p class="noindent">Another huge change introduced by UEFI is that almost all of its code runs in protected mode, except for the small initial stub that is given control by the CPU when it is powered up or reset. Protected mode provides support for executing 32- or 64-bit code (although it also allows for emulating other legacy modes that are not used by modern boot logic). By contrast, legacy boot logic executed most of its code in 16-bit mode until it transferred control to the OS loaders.</p>
<p class="indent">Another difference between UEFI firmware and legacy BIOS is that most UEFI firmware is written in C (and could even be compiled with a C++ compiler, as certain vendors do), with only a small part written in assembly language. This makes for better code quality compared to the all-assembly implementations of legacy BIOS firmware.</p>
<p class="indent">Further differences between legacy BIOS and UEFI firmware are presented in <a href="ch14.xhtml#ch14tab01">Table 14-1</a>.</p>
<p class="tabcap" id="ch14tab01"><strong>Table 14-1:</strong> Comparison of Legacy BIOS and UEFI Firmware</p>
<table class="topbot-d">
<colgroup>
<col style="width:20%"/>
<col style="width:40%"/>
<col style="width:40%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"> </p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Legacy BIOS</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>UEFI firmware</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Architecture</strong></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Unspecified firmware development process; all BIOS vendors independently support their own codebase</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Unified specification for firmware development and Intel reference code (EDKI/EDKII)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Implementation</strong></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Mostly assembly language</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">C/C++</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Memory model</strong></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">16-bit real mode</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">32-/64-bit protected mode</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Bootstrap code</strong></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">MBR and VBR</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">None (firmware controls the boot process)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Partition scheme</strong></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">MBR partition table</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">GUID Partition Table (GPT)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Disk I/O</strong></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">System interrupts</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">UEFI services</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Bootloaders</strong></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>bootmgr</em> and <em>winload.exe</em></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><em>bootmgfw.efi</em> and <em>winload.efi</em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>OS interaction</strong></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">BIOS interrupts</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">UEFI services</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba"><strong>Boot configuration information</strong></p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">CMOS memory, no notion of NVRAM variables</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">UEFI NVRAM variable store</p></td>
</tr>
</tbody>
</table>
<p class="indent">Before we go into the details of the UEFI boot process and its operating system bootloader, we’ll take a close look at the GPT specifics. Understanding the differences between the MBR and GPT partitioning schemes is essential for learning the UEFI boot process.</p>
<h3 class="h3" id="ch14lev1sec3"><span epub:type="pagebreak" id="page_238"/><strong>GUID Partition Table Specifics</strong></h3>
<p class="noindent">If you look at a primary Windows hard drive formatted with a GPT in a hex editor, you’ll find no MBR or VBR boot code in the first two sectors (1 sector = 512 bytes). The space that in a legacy BIOS would contain MBR code is almost entirely zeroed out. Instead, at the beginning of the second sector, you can see an <code>EFI PART</code> signature at offset 0x200 (<a href="ch14.xhtml#ch14fig02">Figure 14-2</a>), just after the familiar <code>55 AA</code> end-of-MBR tag. This is the EFI partition table signature of the GPT header, which identifies it as such.</p>
<div class="image"><a id="ch14fig02"/><img src="../images/14fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-2: GUID Partition Table signature dumped from</em> \\.\PhysicalDrive0</p>
<p class="indent"><span epub:type="pagebreak" id="page_239"/>The MBR partition table structure is not all gone, however. In order to be compatible with legacy boot processes and tools such as pre-GPT low-level disk editors, the GPT emulates the old MBR table as it starts. This emulated MBR partition table now contains just one entry for the entire GPT disk, shown in <a href="ch14.xhtml#ch14fig03">Figure 14-3</a>. This form of MBR scheme is known as <em>Protective MBR</em>.</p>
<div class="image"><a id="ch14fig03"/><img src="../images/14fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-3: Legacy MBR header parsed in 010 Editor by the <code>Drive.bt</code> template</em></p>
<p class="indent">This Protective MBR prevents legacy software such as disk utilities from accidentally destroying GUID partitions by marking the entire disk space as claimed by a single partition; legacy tools unaware of GPT do not mistake its GPT-partitioned parts for free space. The Protective MBR has the same format as a normal MBR, despite being only a stub. The UEFI firmware will recognize this Protective MBR for what it is and will not attempt to execute any code from it.</p>
<p class="indent">The main departure from the legacy BIOS boot process is that all of the code responsible for the early boot stages of the system is now encapsulated in the UEFI firmware itself, residing in the flash chip rather than on the disk. This means that MBR infection methods that infected or modified the MBR or VBR on the disk (used by the likes of TDL4 and Olmasco, as discussed in <a href="ch07.xhtml#ch07">Chapters 7</a> and <a href="ch10.xhtml#ch10">10</a>, respectively) will have no effect on GPT-based systems’ boot flow, even without Secure Boot being enabled.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_240"/><strong>CHECKING FOR GPT SUPPORT</strong></p>
<p class="spara">You can check whether your Windows system includes GPT support by using Microsoft’s PowerShell commands. Specifically, the <code>Get-Disk</code> command (<a href="ch14.xhtml#ch14list01">Listing 14-1</a>) will return a table, the last column of which, named Partition Style, shows the supported partition table type. If it is GPT compatible, you’ll see GPT listed as the Partition Style; otherwise, you’ll see MBR in that column.</p>
<pre>PS C:\&gt; Get-Disk<br/>
Number Friendly Name  Operational Status  Total Size  Partition Style<br/>
------ -------------  ------------------  ----------  ---------------<br/>
0      Microsoft      Online                   127GB  GPT<br/>
       Virtual Disk</pre>
<p class="listing" id="ch14list01"><em>Listing 14-1: The output from <code>Get-Disk</code></em></p>
</div>
<p class="indent"><a href="ch14.xhtml#ch14tab02">Table 14-2</a> lists descriptions of the values found in the GPT header.</p>
<p class="tabcap" id="ch14tab02"><strong>Table 14-2:</strong> GPT Header</p>
<table class="topbot-d">
<colgroup>
<col style="width:60%"/>
<col style="width:20%"/>
<col style="width:20%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Offset</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Length</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Signature “EFI PART”</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x00</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Revision for GPT version</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x08</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Header size</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x0C</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">CRC32 of header</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x10</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Reserved</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x14</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Current LBA (logical block addressing)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x18</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Backup LBA</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x20</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">First usable LBA for partitions</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x28</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Last usable LBA</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x30</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Disk GUID</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x38</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">16 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Starting LBA of array of partition entries</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x48</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">8 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Number of partition entries in array</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x50</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Size of a single partition entry</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0x54</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">CRC32 of partition array</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x58</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">4 bytes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba">Reserved</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">0x5C</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">*</p></td>
</tr>
</tbody>
</table>
<p class="indent">As you can see, the GPT header contains only constant fields rather than code. From a forensic perspective, the most important of these fields are <em>Starting LBA of array of partition entries</em> and the <em>Number of partition entries in array</em>. These entries define the location and size of the partition table on the hard drive, respectively.</p>
<p class="indent"><span epub:type="pagebreak" id="page_241"/>Another interesting field in the GPT header is <em>Backup LBA</em>, which provides the location of a backup copy of the GPT header. This allows you to recover the primary GPT header in case it becomes corrupted. We touched upon the backup GPT header in <a href="ch13.xhtml#ch13">Chapter 13</a> when we discussed the Petya ransomware, which encrypted both the primary and backup GPT headers to make system recovery more difficult.</p>
<p class="indent">As shown in <a href="ch14.xhtml#ch14fig04">Figure 14-4</a>, each entry in the partition table provides information on the properties and location of a partition on the hard drive.</p>
<div class="image"><a id="ch14fig04"/><img src="../images/14fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-4: GUID Partition Table</em></p>
<p class="indent">The two 64-bit fields <em>First LBA</em> and <em>Last LBA</em> define the address of the very first and last sectors of a partition, respectively. The <em>Partition type GUID</em> field contains a GUID value that identifies the type of the partition. For instance, for the EFI system partition mentioned earlier in “<a href="ch14.xhtml#ch14lev2sec2">Disk Partitioning: MBR vs. GPT</a>” on <a href="ch14.xhtml#page_235">page 235</a>, the type is <em>C12A7328-F81F-11D2-BA4B-00A0C93EC93B.</em></p>
<p class="indent">The absence of any executable code from the GPT scheme presents a problem for bootkit infections: how can malware developers transfer control of the boot process to their malicious code in the GPT scheme? One idea is to modify EFI bootloaders before they transfer control to the OS kernel. Before we explore this, though, we’ll look at the basics of the UEFI firmware architecture and boot process.</p>
<div class="sidebar">
<p class="sidebart"><strong>PARSING A GPT DRIVE WITH SWEETSCAPE</strong></p>
<p class="spara">To parse the fields of a GPT drive on a live machine or in a dumped partition, you can use the shareware SweetScape 010 Editor (<em><a href="https://www.sweetscape.com">https://www.sweetscape.com</a></em>) with the <code>Drive.bt</code> template by Benjamin Vernoux, found on the SweetScape site in the <em>Templates</em> repository in the Downloads section. The 010 Editor has a really powerful template-based parsing engine based on C-like structures (see <a href="ch14.xhtml#ch14fig03">Figure 14-3</a>).</p>
</div>
<h3 class="h3" id="ch14lev1sec4"><span epub:type="pagebreak" id="page_242"/><strong>How UEFI Firmware Works</strong></h3>
<p class="noindent">Having explored the GPT partitioning scheme, we now understand where the OS bootloader is located and how the UEFI firmware finds it on the hard drive. Next, let’s look at how the UEFI firmware loads and executes the OS loader. We’ll provide background information on the stages the UEFI boot process goes through in order to prepare the environment for executing the loader.</p>
<p class="indent">The UEFI firmware, which interprets the aforementioned data structures in the GPT table to locate OS loader, is stored on a motherboard’s flash chip (also known as the <em>SPI flash</em>, where “SPI” refers to the bus interface that connects the chip to the rest of the chipset). When the system starts up, the chipset logic maps the contents of the flash chip’s memory onto a specific RAM region, whose start and end addresses are configured in the hardware chipset itself and depend on CPU-specific configuration. Once the mapped SPI flash chip code receives control upon power-on, it initializes the hardware and loads various drivers, the OS boot manager, the OS loader, and then finally the OS kernel itself. The steps of this sequence can be summarized as follows:</p>
<ol>
<li class="noindent">The UEFI firmware performs UEFI platform initialization, performs CPU and chipset initialization, and loads UEFI platform modules (aka UEFI drivers; these are distinct from the device-specific code loaded in the next step).</li>
<li class="noindent">The UEFI boot manager enumerates devices on the external buses (such as the PCI bus), loads UEFI device drivers, and then loads the boot application.</li>
<li class="noindent">The Windows Boot Manager (<em>bootmgfw.efi</em>) loads the Windows Boot Loader.</li>
<li class="noindent">The Windows Boot Loader (<em>winload.efi</em>) loads the Windows OS.</li>
</ol>
<p class="indent">The code responsible for steps 1 and 2 resides on the SPI flash; the code for steps 3 and 4 is extracted from the filesystem in the special UEFI partition of the hard drive, once 1 and 2 have made it possible to read the hard drive. The UEFI specification further divides the firmware into components responsible for the different parts of hardware initialization or boot process activity, as illustrated in <a href="ch14.xhtml#ch14fig05">Figure 14-5</a>.</p>
<p class="indent">The OS loader essentially relies on the EFI boot services and EFI runtime services provided by the UEFI firmware to boot and manage the system. As we’ll explain in “<a href="ch14.xhtml#ch14lev2sec5">Inside the Operating System Loader</a>” on <a href="ch14.xhtml#page_245">page 245</a>, the OS loader relies on these services to establish an environment in which it can load the OS kernel. Once the OS loader takes control of the boot flow from the UEFI firmware, the boot services are removed and no longer available to the operating system. Runtime services, however, do remain available to the operating system at runtime and provide an interface for reading and writing NVRAM UEFI variables, performing firmware updates (via <em>Capsule Update</em>), and rebooting or shutting down the system.</p>
<div class="image"><span epub:type="pagebreak" id="page_243"/><a id="ch14fig05"/><img src="../images/14fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-5: The UEFI framework overview</em></p>
<div class="sidebar">
<p class="sidebart"><strong>FIRMWARE CAPSULE UPDATE</strong></p>
<p class="spara">Capsule Update is a technology for securely updating UEFI firmware. The operating system loads the capsule firmware update image into memory and signals to the UEFI firmware, via a runtime service, that the capsule is present. As a result, the UEFI firmware reboots the system and processes the update capsule upon the next boot. Capsule Update attempts to standardize and improve the security of the UEFI firmware update process. We’ll discuss it in more depth in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
</div>
<h4 class="h4" id="ch14lev2sec4"><strong><em>The UEFI Specification</em></strong></h4>
<p class="noindent">In contrast to the legacy BIOS boot, the UEFI specification covers every step from the beginning of hardware initialization onward. Before this specification, hardware vendors had more freedom in the firmware development process, but this freedom also allowed for confusion and, hence, vulnerabilities. The specification outlines four main consecutive stages of the boot process, each with its own responsibilities:</p>
<p class="hangt"><strong>Security (SEC)</strong> Initializes temporary memory using CPU caches and locates the loader for the PEI phase. Code executed at the SEC phase runs from SPI flash memory.</p>
<p class="hang"><strong>Pre-EFI Initialization (PEI)</strong> Configures the memory controller, initializes the chipset, and handles the S3 resume process. Code executed at this phase runs in temporary memory until the memory controller is initialized. Once this is done, the PEI code is executed from the permanent memory.</p>
<p class="hang"><span epub:type="pagebreak" id="page_244"/><strong>Driver Execution Environment (DXE)</strong> Initializes System Management Mode (SMM) and DXE services (the core, dispatcher, drivers, and so forth), as well as the boot and runtime services.</p>
<p class="hangb"><strong>Boot Device Selection (BDS)</strong> Discovers the hardware device from which the OS can be booted, for example, by enumerating peripheral devices on the PCI bus that may contain a UEFI-compatible bootloader (such as an OS loader).</p>
<p class="indent">All of the components used in the boot process reside on the SPI flash, except for the OS loader, which resides in the disk’s filesystem and is found by the SPI flash–based DXE/BDS-phase code via a filesystem path stored in an NVRAM UEFI variable (as discussed earlier).</p>
<p class="indent">The SMM and DXE initialization stages are some of the most interesting areas for implanting rootkits. The SMM, at ring –2, is the most privileged system mode—more privileged than hypervisors at ring –1. (See the “<a href="ch14.xhtml#ch14sb01">System Management Mode</a>” box for more on SMM and the ring privilege levels.) From this mode, malicious code can exercise full control of the system.</p>
<p class="indent">Similarly, DXE drivers offer another powerful point for implementing bootkit functionality. A good example of DXE-based malware is Hacking Team’s firmware rootkit implementation, discussed in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
<div class="sidebar">
<p class="sidebart" id="ch14sb01"><strong>SYSTEM MANAGEMENT MODE</strong></p>
<p class="spara">System Management Mode is a special mode of the x86 CPUs, executed with special higher “ring –2” privileges (that’s “minus two,” which is lower and more powerful than “ring –1,” which in turn is more powerful than “ring 0,” historically the most trusted privilege—isn’t it lucky that we have an infinite supply of integers less than zero?). SMM was introduced in Intel 386 processors primarily as a means of aiding power management, but it has grown in both complexity and importance in modern CPUs. SMM is now an integral part of the firmware, responsible for all initialization and memory separation setup in the boot process. SMM’s code executes in a separate address space meant to be isolated from the normal operating system address space layout (including the OS kernel space). In <a href="ch15.xhtml#ch15">Chapters 15</a> and <a href="ch16.xhtml#ch16">16</a>, we’ll focus more on how UEFI rootkits leverage SMM.</p>
</div>
<p class="indent">We’ll now explore this last stage and the process through which the operating system kernel receives control. We’ll go into more detail about DXE and SMM in the next chapter.</p>
<h4 class="h4" id="ch14lev2sec5"><span epub:type="pagebreak" id="page_245"/><strong><em>Inside the Operating System Loader</em></strong></h4>
<p class="noindent">Now that the SPI-stored UEFI firmware code has done its work, it passes control to the OS loader stored on disk. The loader code is also 64-bit or 32-bit (depending on the operating system version); there’s no place for the MBR’s or VBR’s 16-bit loader code in the boot process.</p>
<p class="indent">The OS loader consists of several files stored in the EFI system partition, including the modules <em>bootmgfw.efi</em> and <em>winload.efi</em>. The first is referred to as the <em>Windows Boot Manager</em> and the second as the <em>Windows Boot Loader</em>. The location of these modules is also specified by NVRAM variables. In particular, the UEFI path of the drive (defined by how the UEFI standard enumerates the ports and buses of a motherboard) containing the ESP is stored in the boot order NVRAM variable <code>BOOT_ORDER</code> (which the user usually can change via BIOS configuration); the path within the ESP’s filesystem is stored in another variable, <code>BOOT</code> (which is typically in <em>\EFI\Microsoft\Boot\</em>).</p>
<h5 class="h5" id="ch14lev3sec1"><strong>Accessing the Windows Boot Manager</strong></h5>
<p class="noindent">The UEFI firmware boot manager consults the NVRAM UEFI variables to find the ESP and then, in the case of Windows, the OS-specific boot manager <em>bootmgfw.efi</em> inside it. The boot manager then creates a runtime image of this file in memory. To do so, it relies on the UEFI firmware to read the startup hard drive and parse its filesystem. Under a different OS, the NVRAM variable would contain a path to that OS’s loader; for example, for Linux it points to the GRUB bootloader (<em>grub.efi</em>).</p>
<p class="indent">Once <em>bootmgfw.efi</em> is loaded, the UEFI firmware boot manager jumps to the entry point of <em>bootmgfw.efi</em>, <code>EfiEntry</code>. This is the start of the OS boot process, at which point the SPI flash–stored firmware gives control to code stored on the hard disk.</p>
<h5 class="h5" id="ch14lev3sec2"><strong>Establishing an Execution Environment</strong></h5>
<p class="noindent">The <code>EfiEntry</code> entry, the prototype of which is shown in <a href="ch14.xhtml#ch14list02">Listing 14-2</a>, calls the Windows Boot Manager, <em>bootmgfw.efi</em>, and is used to configure the UEFI firmware callbacks for the Windows Boot Loader, <em>winload.efi</em>, which is called right after it. These callbacks connect <em>winload.efi</em> code with the UEFI firmware runtime services, which it needs for operations on peripherals, like reading the hard drive. These services will continue to be used by Windows even when it’s fully loaded, via hardware abstraction layer (HAL) wrappers, which we’ll see being set up shortly.</p>
<pre>EFI_STATUS EfiEntry (<br/>
<span class="ent">➊</span> EFI_HANDLE ImageHandle,       // UEFI image handle for loaded application<br/>
<span class="ent">➋</span> EFI_SYSTEM_TABLE *SystemTable // Pointer to UEFI system table<br/>
);</pre>
<p class="listing" id="ch14list02"><em>Listing 14-2: Prototype of the <code>EfiEntry</code> routine (<code>EFI_IMAGE_ENTRY_POINT</code>)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_246"/>The first parameter of <code>EfiEntry</code> <span class="ent">➊</span> points to the <em>bootmgfw.efi</em> module that is responsible for continuing the boot process and calling <em>winload.efi</em>. The second parameter <span class="ent">➋</span> contains the pointer to the UEFI configuration table (<code>EFI_SYSTEM_TABLE</code>), which is the key to accessing most of an EFI environment service’s configuration data (<a href="ch14.xhtml#ch14fig06">Figure 14-6</a>).</p>
<div class="image"><a id="ch14fig06"/><img src="../images/14fig06.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-6: <code>EFI_SYSTEM_TABLE</code> high-level structure</em></p>
<p class="indent">The <em>winload.efi</em> loader uses UEFI services to load the operating system kernel with the boot device driver stack and to initialize <code>EFI_RUNTIME_TABLE</code> in the kernel space for future access by the kernel through the HAL library code module (<em>hal.dll</em>). HAL consumes the <code>EFI_SYSTEM_TABLE</code> and exports the functions that wrap the UEFI runtime functions to the rest of the kernel. The kernel calls these functions to perform tasks like reading the NVRAM variables and handling BIOS updates via the so-called Capsule Update handed to the UEFI firmware.</p>
<p class="indent">Note the pattern of multiple wrappings created over the UEFI hardware-specific code configured at the earliest stages of boot by each subsequent layer. You never know how deep into the UEFI rabbit hole an OS system call might go!</p>
<p class="indent">The structure of the <code>EFI_RUNTIME_SERVICES</code> used by the HAL module <em>hal.dll</em> is shown in <a href="ch14.xhtml#ch14fig07">Figure 14-7</a>.</p>
<div class="image"><a id="ch14fig07"/><img src="../images/14fig07.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-7: <code>EFI_RUNTIME_SERVICES</code> in</em> hal.dll<em>’s representation</em></p>
<p class="indent"><code>HalEfiRuntimeServiceTable</code> holds a pointer to <code>EFI_RUNTIME_SERVICES</code>, which in turn contains the addresses of entry points of service routines that will do things like get or set the NVRAM variable, perform a Capsule Update, and so on.</p>
<p class="indent"><span epub:type="pagebreak" id="page_247"/>In the next chapters, we’ll analyze these structures in the context of firmware vulnerabilities, exploitation, and rootkits. For now, we simply want to stress that <code>EFI_SYSTEM_TABLE</code> and (especially) <code>EFI_RUNTIME_SERVICES</code> within it are the keys to finding the structures responsible for accessing UEFI configuration information and that some of this information is accessible from the kernel mode of the operating system.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig08">Figure 14-8</a> shows the disassembled <code>EfiEntry</code> routine. One of its first instructions triggers a call to the function <code>EfiInitCreateInputParametersEx()</code>, which converts the <code>EfiEntry</code> parameters to the format expected by <em>bootmgfw.efi</em>. Inside <code>EfiInitCreateInputParametersEx()</code>, a routine called <code>EfiInitpCreateApplicationEntry()</code> creates an entry for the <em>bootmgfw.efi</em> in the Boot Configuration Data (BCD), a binary storage of configuration parameters for a Windows bootloader. After <code>EfiInitCreateInputParametersEx()</code> returns, the <code>BmMain</code> routine (highlighted in <a href="ch14.xhtml#ch14fig08">Figure 14-8</a>) receives control. Note that at this point, to properly access hardware device operations, including any hard drive input and output, and to initialize memory, the Windows Boot Manager must use only EFI services, as the main Windows driver stacks are not yet loaded and thus are unavailable.</p>
<div class="image"><a id="ch14fig08"/><img src="../images/14fig08.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-8: Disassembled <code>EfiEntry</code> routine</em></p>
<h5 class="h5" id="ch14lev3sec3"><strong>Reading the Boot Configuration Data</strong></h5>
<p class="noindent">As the next step, <code>BmMain</code> calls the following routines:</p>
<p class="hangt"><span class="codestrong">BmFwInitializeBootDirectoryPath</span> Routine used to initialize the boot application’s path (<em>\EFI\Microsoft\Boot</em>)</p>
<p class="hang"><span class="codestrong">BmOpenDataStore</span> Routine used to mount and read the BCD database file (<em>\EFI\Microsoft\Boot\BCD</em>) via UEFI services (disk I/O)</p>
<p class="hangb"><span epub:type="pagebreak" id="page_248"/><span class="codestrong">BmpLaunchBootEntry</span> <strong>and</strong> <span class="codestrong">ImgArchEfiStartBootApplication</span> Routines used to execute boot application (<em>winload.efi</em>)</p>
<p class="indent"><a href="ch14.xhtml#ch14list03">Listing 14-3</a> shows Boot Configuration Data as output by the standard command line tool <em>bcdedit.exe</em>, which is included in all recent versions of Microsoft Windows. The paths to the Windows Boot Manager and Windows Boot Loader modules are marked with <span class="ent">➊</span> and <span class="ent">➋</span> respectively.</p>
<pre>   PS C:\WINDOWS\system32&gt; bcdedit<br/>
<br/>
   Windows Boot Manager<br/>
   --------------------<br/>
   identifier              {bootmgr}<br/>
   device                  partition=\Device\HarddiskVolume2<br/>
<span class="ent">➊</span> path                    \EFI\Microsoft\Boot\bootmgfw.efi<br/>
   description             Windows Boot Manager<br/>
   locale                  en-US<br/>
   inherit                 {globalsettings}<br/>
   default                 {current}<br/>
   resumeobject            {c68c4e64-6159-11e8-8512-a4c49440f67c}<br/>
   displayorder            {current}<br/>
   toolsdisplayorder       {memdiag}<br/>
   timeout                 30<br/>
<br/>
   Windows Boot Loader<br/>
   -------------------<br/>
   identifier              {current}<br/>
   device                  partition=C:<br/>
<span class="ent">➋</span> path                    \WINDOWS\system32\winload.efi<br/>
   description             Windows 10<br/>
   locale                  en-US<br/>
   inherit                 {bootloadersettings}<br/>
   recoverysequence        {f5b4c688-6159-11e8-81bd-8aecff577cb6}<br/>
   displaymessageoverride  Recovery<br/>
   recoveryenabled         Yes<br/>
   isolatedcontext         Yes<br/>
   allowedinmemorysettings 0x15000075<br/>
   osdevice                partition=C:<br/>
   systemroot              \WINDOWS<br/>
   resumeobject            {c68c4e64-6159-11e8-8512-a4c49440f67c}<br/>
   nx                      OptIn<br/>
   bootmenupolicy          Standard</pre>
<p class="listing" id="ch14list03"><em>Listing 14-3: Output from the <code>bcdedit</code> console command</em></p>
<p class="indent">The Windows Boot Manager (<em>bootmgfw.efi</em>) is also responsible for the boot policy verification and for the initialization of the Code Integrity and Secure Boot components, covered in the following chapters.</p>
<p class="indent">At the next stage of the boot process, <em>bootmgfw.efi</em> loads and verifies the Windows Boot Loader (<em>winload.efi</em>). Before starting to load <em>winload.efi</em>, the Windows Boot Manager initializes the memory map for transition <span epub:type="pagebreak" id="page_249"/>to the protected memory mode, which provides both virtual memory and paging. Importantly, it performs this setup via UEFI runtime services rather than directly. This creates a strong layer of abstraction for the OS virtual memory data structures, such as the GDT, which were previously handled by a legacy BIOS in 16-bit assembly code.</p>
<h5 class="h5" id="ch14lev3sec4"><strong>Transferring Control to Winload</strong></h5>
<p class="noindent">In the final stage of the Windows Boot Manager, the <code>BmpLaunchBootEntry()</code> routine loads and executes <em>winload.efi</em>, the Windows Boot Loader. <a href="ch14.xhtml#ch14fig09">Figure 14-9</a> presents the complete call graph from <code>EfiEntry()</code> to <code>BmpLaunchBootEntry()</code>, as generated by the Hex-Rays IDA Pro disassembler with the IDAPathFinder script (<em><a href="http://www.devttys0.com/tools/">http://www.devttys0.com/tools/</a></em>).</p>
<div class="image"><a id="ch14fig09"/><img src="../images/14fig09.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-9: Call graph flow from <code>EfiEntry()</code> to <code>BmpLaunchBootEntry()</code></em></p>
<p class="indent">The control flow preceding the <code>BmpLaunchBootEntry()</code> function chooses the right boot entry, based on the values from the BCD store. If Full Volume Encryption (BitLocker) is enabled, the Boot Manager decrypts the system partition before it can transfer control to the Boot Loader. The <code>BmpLaunchBootEntry()</code> function followed by <code>BmpTransferExecution()</code> checks the boot options and passes execution to <code>BlImgLoadBootApplication()</code>, which then calls <code>ImgArchEfiStartBootApplication()</code>. The <code>ImgArchEfiStartBootApplication()</code> routine is responsible for initializing the protected memory mode for <em>winload.efi</em>. After that, control is passed to the function <code>Archpx64TransferTo64BitApplicationAsm()</code>, which finalizes the preparation for starting <em>winload.efi</em> (<a href="ch14.xhtml#ch14fig10">Figure 14-10</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_250"/><a id="ch14fig10"/><img src="../images/14fig10.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-10: Call graph flow from <code>BmpLaunchBootEntry()</code> to <code>Archpx64TransferTo64BitApplicationAsm()</code></em></p>
<p class="indent">After this crucial point, all execution flow is transferred to <em>winload.efi</em>, which is responsible for loading and initializing the Windows kernel. Prior to this moment, execution happens in the UEFI environment over boot services and operates under the flat physical memory model.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If Secure Boot is disabled, malicious code can make any memory modifications at this stage of the boot process, because kernel-mode modules are not yet protected by the Windows Kernel Patch Protection (KPP) technology (also known as PatchGuard). PatchGuard will initialize only in the later steps of the boot process. Once PatchGuard is activated, though, it will make malicious modifications of kernel modules much harder.</em></p>
</div>
<h4 class="h4" id="ch14lev2sec6"><strong><em>The Windows Boot Loader</em></strong></h4>
<p class="noindent">The Windows Boot Loader performs the following configuration actions:</p>
<ul>
<li class="noindent">Initializes the kernel debugger if the OS boots in debug mode (including the hypervisor debug mode).</li>
<li class="noindent">Wraps UEFI Boot Services into HAL abstractions for later use by the Windows kernel-mode code and calls Exit Boot Services.</li>
<li class="noindent">Checks the CPU for the Hyper-V hypervisor support features and sets them up if supported.</li>
<li class="noindent">Checks for Virtual Secure Mode (VSM) and DeviceGuard policies (Windows 10 only).</li>
<li class="noindent">Runs integrity checks on the kernel itself and on the Windows components, then transfers control to the kernel.</li>
</ul>
<p class="indent">The Windows Boot Loader starts execution from the <code>OslMain()</code> routine, as shown in <a href="ch14.xhtml#ch14list04">Listing 14-4</a>, which performs all the previously described actions.</p>
<pre><span epub:type="pagebreak" id="page_251"/>__int64 __fastcall OslpMain(__int64 a1)<br/>
{<br/>
  __int64 v1; // rbx@1<br/>
  unsigned int v2; // eax@3<br/>
  __int64 v3; //rdx@3<br/>
  __int64 v4; //rcx@3<br/>
  __int64 v5; //r8@3<br/>
  __int64 v6; //rbx@5<br/>
  unsigned int v7; // eax@7<br/>
  __int64 v8; //rdx@7<br/>
  __int64 v9; //rcx@7<br/>
  __int64 v10; //rdx@9<br/>
  __int64 v11; //rcx@9<br/>
  unsigned int v12; // eax@10<br/>
  char v14; // [rsp+20h] [rbp-18h]@1<br/>
  int v15; // [rsp+2Ch] [rbp-Ch]@1<br/>
  char v16; // [rsp+48h] [rbp+10h]@3<br/>
<br/>
  v1 = a1;<br/>
  BlArchCpuId(0x80000001, 0i64, &amp;v14);<br/>
  if ( !(v15 &amp; 0x100000) )<br/>
    BlArchGetCpuVendor();<br/>
  v2 = OslPrepareTarget (v1, &amp;v16);<br/>
  LODWORD(v5) = v2;<br/>
  if ( (v2 &amp; 0x80000000) == 0 &amp;&amp; v16 )<br/>
  {<br/>
    v6 = OslLoaderBlock;<br/>
    if ( !BdDebugAfterExitBootServices )<br/>
      BlBdStop(v4, v3, v2);<br/>
  <span class="ent">➊</span> v7 = OslFwpKernelSetupPhase1(v6);<br/>
    LODWORD(v5) = v7;<br/>
    if ( (v7 &amp; 0x80000000) == 0 )<br/>
    {<br/>
      ArchRestoreProcessorFeatures(v9, v8, v7);<br/>
      OslArchHypervisorSetup(1i64, v6);<br/>
    <span class="ent">➋</span> LODWORD(v5) = BlVsmCheckSystemPolicy(1i64);<br/>
      if ( (signed int)v5 &gt;= 0 )<br/>
      {<br/>
        if ( (signed int)OslVsmSetup(1i64, 0xFFFFFFFFi64, v6) &gt;= 0<br/>
         <span class="ent">➌</span> || (v12 = BlVsmCheckSystemPolicy(2i64), v5 = v12, (v12 &amp; 0x80000000) == 0 ) )<br/>
        {<br/>
          BlBdStop(v11, v10, v5);<br/>
        <span class="ent">➍</span> OslArchTransferToKernel(v6, OslEntryPoint);<br/>
          while ( 1 )<br/>
            ;<br/>
        }<br/>
      }<br/>
    }<br/>
  }<br/>
}</pre>
<p class="listing" id="ch14list04"><em>Listing 14-4: The decompiled <code>OslMain()</code> function (Windows 10)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_252"/>The Windows Boot Loader starts with configuring the kernel memory address space by calling the <code>OslBuildKernelMemoryMap()</code> function (<a href="ch14.xhtml#ch14fig11">Figure 14-11</a>). Next, it prepares for loading the kernel with the call to the <code>OslFwpKernelSetupPhase1()</code> function <span class="ent">➊</span>. The <code>OslFwpKernelSetupPhase1()</code> function calls <code>EfiGetMemoryMap()</code> to get the pointer to the <code>EFI_BOOT_SERVICE</code> structure configured earlier, and then stores it in a global variable for future operations from kernel mode, via the HAL services.</p>
<div class="image"><a id="ch14fig11"/><img src="../images/14fig11.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 14-11: Call graph flow from <code>OslMain()</code> to <code>OslBuildKernelMemoryMap()</code></em></p>
<p class="indent">After that, the <code>OslFwpKernelSetupPhase1()</code> routine calls the EFI function <code>ExitBootServices()</code>. This function notifies the operating system that it is about to receive full control; this callback allows for making any last-minute configurations before jumping into the kernel.</p>
<p class="indent">The VSM boot policy checks are implemented in the routine <code>BlVsmCheckSystemPolicy</code> <span class="ent">➋</span> <span class="ent">➌</span>, which checks the environment against the Secure Boot policy and reads the UEFI variable <code>VbsPolicy</code> into memory, filling the <code>BlVsmpSystemPolicy</code> structure in memory.</p>
<p class="indent">Finally, execution flow reaches the operating system kernel (which in our case is the <em>ntoskrnl.exe</em> image) <span class="ent">➍</span> via <code>OslArchTransferToKernel()</code> (<a href="ch14.xhtml#ch14list05">Listing 14-5</a>).</p>
<pre>.text:0000000180123C90 OslArchTransferToKernel proc near<br/>
.text:0000000180123C90                 xor     esi, esi<br/>
.text:0000000180123C92                 mov     r12, rcx<br/>
.text:0000000180123C95                 mov     r13, rdx<br/>
.text:0000000180123C98                 wbinvd<br/>
.text:0000000180123C9A                 sub     rax, rax<br/>
.text:0000000180123C9D                 mov     ss, ax<br/>
.text:0000000180123CA0                 mov     rsp, cs:OslArchKernelStack<br/>
.text:0000000180123CA7                 lea     rax, OslArchKernelGdt<br/>
.text:0000000180123CAE                 lea     rcx, OslArchKernelIdt<br/>
.text:0000000180123CB5                 lgdt    fword ptr [rax]<br/>
.text:0000000180123CB8                 lidt    fword ptr [rcx]<br/>
.text:0000000180123CBB                 mov     rax, cr4<br/>
.text:0000000180123CBE                 or      rax, 680h<br/>
.text:0000000180123CC4                 mov     cr4, rax<br/>
.text:0000000180123CC7                 mov     rax, cr0<br/>
.text:0000000180123CCA                 or      rax, 50020h<br/>
.text:0000000180123CD0                 mov     cr0, rax<br/>
.text:0000000180123CD3                 xor     ecx, ecx<br/>
.text:0000000180123CD5                 mov     cr8, rcx<br/>
.text:0000000180123CD9                 mov     ecx, 0C0000080h<br/>
.text:0000000180123CDE                 rdmsr<br/>
.text:0000000180123CE0                 or      rax, cs:OslArchEferFlags<br/>
.text:0000000180123CE7                 wrmsr<br/>
.text:0000000180123CE9                 mov     eax, 40h<br/>
.text:0000000180123CEE                 ltr     ax<br/>
<span epub:type="pagebreak" id="page_253"/>.text:0000000180123CF1                 mov     ecx, 2Bh<br/>
.text:0000000180123CF6                 mov     gs, ecx<br/>
.text:0000000180123CF8                 assume gs:nothing<br/>
.text:0000000180123CF8                 mov     rcx, r12<br/>
.text:0000000180123CFB                 push    rsi<br/>
.text:0000000180123CFC                 push    10h<br/>
.text:0000000180123CFE                 push    r13<br/>
.text:0000000180123D00                 retfq<br/>
.text:0000000180123D00 OslArchTransferToKernel endp</pre>
<p class="listing" id="ch14list05"><em>Listing 14-5: Disassembled <code>OslArchTransferToKernel()</code> function</em></p>
<p class="indent">This function has been mentioned in previous chapters, because some bootkits (such as Gapz) hook it to insert their own hooks into the kernel image.</p>
<h4 class="h4" id="ch14lev2sec7"><strong><em>Security Benefits of UEFI Firmware</em></strong></h4>
<p class="noindent">As we’ve seen, legacy MBR- and VBR-based bootkits are unable to get control of the UEFI booting scheme, since the bootstrap code they infect is no longer executed in the UFEI boot process flow. Yet the biggest security impact of UEFI is due to its support for Secure Boot technology. Secure Boot changes the rootkit and bootkit infection game, because it prevents attackers from modifying any pre-OS boot components—that is, unless they find a way to bypass Secure Boot.</p>
<p class="indent">Moreover, the recent Boot Guard technology released by Intel marks another step in the evolution of Secure Boot. Boot Guard is a hardware-based integrity protection technology that attempts to protect the system even before Secure Boot starts. In a nutshell, Boot Guard allows a platform vendor to install cryptographic keys that maintain the integrity of Secure Boot.</p>
<p class="indent">Another recent technology delivered since Intel’s Skylake CPU (a generation of the Intel CPU) release is BIOS Guard, which armors platforms against firmware flash storage modifications. Even if an attacker gains access to flash memory, BIOS Guard can protect it from the installation of a malicious implant, thereby also preventing execution of malicious code at boot time.</p>
<p class="indent">These security technologies directly influenced the direction of modern bootkits, forcing malware developers to evolve their approaches in order to contend with these defenses.</p>
<h3 class="h3" id="ch14lev1sec5"><strong>Conclusion</strong></h3>
<p class="noindent">The switch of modern PCs to UEFI firmware since Microsoft Windows 7 was a first step to changing the boot process flow and reshaping the bootkit ecology. The methods that relied on legacy BIOS interrupts for transferring control to malicious code became obsolete, as such structures disappeared from systems booting through UEFI.</p>
<p class="indent"><span epub:type="pagebreak" id="page_254"/>Secure Boot technology completely changed the game, because it was no longer possible to directly modify the bootloader components such as <em>bootmgfw.efi</em> and <em>winload.efi</em>.</p>
<p class="indent">Now all boot process flow is trusted and verified from firmware with hardware support. Attackers need to go deeper into firmware to search out and exploit BIOS vulnerabilities to bypass these UEFI security features. <a href="ch16.xhtml#ch16">Chapter 16</a> will provide an overview of the modern BIOS vulnerabilities landscape, but first, <a href="ch15.xhtml#ch15">Chapter 15</a> will touch upon the evolution of rootkit and bootkit threats in light of firmware attacks.</p>
</body></html>