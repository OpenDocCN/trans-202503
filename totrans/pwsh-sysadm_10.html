<html><head></head><body>
<h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_107"/><span class="big">9</span><br/>TESTING WITH PESTER</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">There’s no way around it: you need to test your code. It’s easy to assume your code has no flaws; it’s even easier to be proven wrong. When you test with Pester, you can stop assuming and start knowing.</span></p>&#13;
<p class="indent">Testing has been a feature of traditional software development for decades. But while concepts like <em>unit</em>, <em>functional</em>, <em>integration</em>, and <em>acceptance</em> testing may be familiar to seasoned software developers, they’re relatively new to scripters—those of us who want to automate with PowerShell but don’t hold a software engineer job title. Since many organizations are depending more on PowerShell code to run critical production systems, we’ll take a page from the programming world and apply it to PowerShell.</p>&#13;
<p class="indent">In this chapter, you’ll learn how to create tests for your scripts and modules so you can be sure your code works, and stays working when you’ve changed it. You’ll do this with the testing framework known as Pester.</p>&#13;
<h3 class="h3" id="ch9lev1"><span epub:type="pagebreak" id="page_108"/>Introducing Pester</h3>&#13;
<p class="noindent"><em>Pester</em> is an open source testing PowerShell module available in the PowerShell Gallery. Because it’s effective, and written in PowerShell, it’s become the de facto standard for testing in PowerShell. It allows you to write multiple types of tests, including unit, integration, and acceptance tests. If these test names don’t ring a bell, don’t worry. In this book, we’ll use Pester only to test environmental changes such as whether a virtual machine was created with the right name, whether IIS was installed, or whether the proper operating system was installed. We’ll refer to these tests as <em>infrastructure tests</em>.</p>&#13;
<p class="indent">We won’t cover how to test for things like whether a function was called, whether a variable was set correctly, or whether a script returned a specific object type—that’s all in the world of <em>unit testing</em>. If you’re curious about unit testing with Pester and want to learn how to use Pester in different situations, check out <em>The Pester Book</em> (LeanPub, 2019, <em><a href="https://leanpub.com/pesterbook/">https://leanpub.com/pesterbook/</a></em>), which explains just about everything you need to know about testing with PowerShell.</p>&#13;
<h3 class="h3" id="ch9lev2">Pester Basics</h3>&#13;
<p class="noindent">To use Pester, you must first get it installed. If you have Windows 10, Pester is installed by default, but it’s also available in the PowerShell Gallery if you’re on another Windows operating system. If you’re on Windows 10, chances are Pester will be outdated anyway, so you might as well grab the latest copy from the PowerShell Gallery. Since Pester is available via the PowerShell Gallery, you can run <span class="literal">Install-Module -Name Pester</span> to download and install it. Once installed, it will have all the commands you need.</p>&#13;
<p class="indent">It’s worth repeating that you’ll be using Pester to write and run infrastructure tests, which are meant to validate any expected changes a script performs against its environment. For example, you might run an infrastructure test after creating a new file path by using <span class="literal">Test-Path</span> to ensure that the file path was created. Infrastructure tests are safeguards put in place to confirm that your code did what you expected it to do.</p>&#13;
<h4 class="h4" id="ch9lev2sec1">A Pester File</h4>&#13;
<p class="noindent">In its most basic form, a Pester test script consists of a PowerShell script ending in <em>.Tests.ps1</em>. You can name the main script anything you like; the naming convention and test structure are entirely up to you. Here, you’ll name the script <em>Sample.Tests.ps1</em>.</p>&#13;
<p class="indent">The basic structure of a Pester test script is one or more <span class="literal">describe</span> blocks that each contain (optional) <span class="literal">context</span> blocks that each contain <span class="literal">it</span> blocks that each contain assertions. If that was a lot to process, <a href="ch09.xhtml#ch9list1">Listing 9-1</a> provides a visual guide.</p>&#13;
<pre><span epub:type="pagebreak" id="page_109"/>C:\Sample.Tests.ps1&#13;
    describe&#13;
        context&#13;
          it&#13;
            <span class="codeitalic1">assertions</span></pre>&#13;
<p class="caption" id="ch9list1"><em>Listing 9-1: A basic Pester test structure</em></p>&#13;
<p class="indent">Let’s go through each of these parts.</p>&#13;
<h4 class="h4" id="ch9lev2sec2">The describe Block</h4>&#13;
<p class="noindent">A <span class="literal">describe</span> block is a way to group like tests together. In <a href="ch09.xhtml#ch9list2">Listing 9-2</a>, you create a <span class="literal">describe</span> block called <span class="literal">IIS</span>, which you could use to include all the code to test things like Windows features, app pools, and websites.</p>&#13;
<p class="indent">The basic syntax for a <span class="literal">describe</span> block is the word <span class="literal">describe</span> followed by a name, in single quotes, followed by an opening and closing curly bracket.</p>&#13;
<pre>describe 'IIS' {&#13;
}</pre>&#13;
<p class="caption" id="ch9list2"><em>Listing 9-2: A Pester <span class="literal">describe</span> block</em></p>&#13;
<p class="indent">Although this structure looks like an <span class="literal">if/then</span> condition, don’t be fooled! This is a scriptblock that is passed to the <span class="literal">describe</span> function under the covers. Note that if you’re the type who prefers curly brackets on a new line, you’re out of luck: the opening curly bracket must come on the same line as the <span class="literal">describe</span> keyword.</p>&#13;
<h4 class="h4" id="ch9lev2sec3">The context Block</h4>&#13;
<p class="noindent">Once you create the <span class="literal">describe</span> block, you can add an optional <span class="literal">context</span> block. The <span class="literal">context</span> block groups together similar <span class="literal">it</span> blocks, which helps organize tests when infrastructure testing. In <a href="ch09.xhtml#ch9list3">Listing 9-3</a>, you’ll add a <span class="literal">context</span> block that will contain all the tests for Windows features. It’s a good idea to classify tests this way in <span class="literal">context</span> blocks to more easily manage them.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list3"><em>Listing 9-3: A Pester <span class="literal">context</span> block</em></p>&#13;
<p class="indent">Although optional, the <span class="literal">context</span> block will become invaluable later when you’ve created tests to test dozens or hundreds of components!</p>&#13;
<h4 class="h4" id="ch9lev2sec4"><span epub:type="pagebreak" id="page_110"/>The it Block</h4>&#13;
<p class="noindent">Now let’s add an <span class="literal">it</span> block inside the <span class="literal">context</span> block. An <span class="literal">it</span> block is a smaller component that labels the actual test. Its syntax, shown in <a href="ch09.xhtml#ch9list4">Listing 9-4</a>, has a name followed by a block, just as you saw with the <span class="literal">describe</span> block.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
        it 'installs the Web-Server Windows feature' {&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list4"><em>Listing 9-4: A Pester <span class="literal">describe</span> block with a <span class="literal">context</span> and <span class="literal">it</span> block</em></p>&#13;
<p class="indent">Notice that so far, you more or less just added different labels for the test, in varying scopes. In the next section, you’ll add the test itself.</p>&#13;
<h4 class="h4" id="ch9lev2sec5">Assertions</h4>&#13;
<p class="noindent">Inside the <span class="literal">it</span> block, you include one or more assertions. An <em>assertion</em> can be thought of as the actual test, or the code that compares the expected state to an actual state. The most common assertion in Pester is the <span class="literal">should</span> assertion. The <span class="literal">should</span> assertion has different operators that can be used with it, such as <span class="literal">be</span>, <span class="literal">bein</span>, <span class="literal">belessthan</span>, and so on. If you’d like a full list of available operators, the Pester wiki (<em><a href="https://github.com/pester/Pester/wiki/">https://github.com/pester/Pester/wiki/</a></em>) has a full list.</p>&#13;
<p class="indent">In our IIS example, let’s check whether the app pool named <span class="literal">test</span> was created on our server. To do that, you first have to write the code to find the current state of the <span class="literal">Web-Server</span> Windows feature on the server (we’ll call it <span class="literal">WEBSRV1</span>). After a little investigation by browsing through the available PowerShell commands with <span class="literal">Get-Command</span> and sifting through the <span class="literal">Get-WindowsFeature</span> command’s help text, you find that the code to do so looks like this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-WindowsFeature -ComputerName WEBSRV1 -Name Web-Server).Installed</span>&#13;
True</pre>&#13;
<p class="indent">You know that if the <span class="literal">Web-Server</span> feature is installed, the <span class="literal">Installed</span> property will return <span class="literal">True</span>; otherwise, it will return <span class="literal">False</span>. Knowing this, you can then assert that when you run this <span class="literal">Get-WindowsFeature</span> command, you expect the <span class="literal">Installed</span> property to be <span class="literal">True</span>. You want to test whether this command’s output will <em>be</em> equal to <span class="literal">True</span>. You can represent this scenario inside an <span class="literal">it</span> block, as shown in <a href="ch09.xhtml#ch9list5">Listing 9-5</a>.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
        it 'installs the Web-Server Windows feature' {&#13;
            $parameters = @{&#13;
<span epub:type="pagebreak" id="page_111"/>                  ComputerName = 'WEBSRV1'&#13;
                  Name         = 'Web-Server'&#13;
            }&#13;
            (Get-WindowsFeature @parameters).Installed | should -Be $true&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list5"><em>Listing 9-5: Asserting a test condition with Pester</em></p>&#13;
<p class="indent">Here, you created a rudimentary Pester test to test whether a Windows feature is installed. You first enter the test you want to run, and then pass the results of that test through the pipeline to your testing condition, which, in this case, is <span class="literal">should be $true</span>.</p>&#13;
<p class="indent">There’s much more to writing Pester tests, and I encourage you to learn the details via <em>The Pester Book</em> (<em><a href="https://leanpub.com/pesterbook/">https://leanpub.com/pesterbook/</a></em>) or perhaps a series of articles on 4sysops (<em><a href="https://4sysops.com/archives/powershell-pester-testing-getting-started/">https://4sysops.com/archives/powershell-pester-testing-getting-started/</a></em>). This should be enough for you to be able to read the tests I provide with this book. Once you finish this book, writing your own Pester tests will be a good way to test your PowerShell skills.</p>&#13;
<p class="indent">You have a Pester script now. And of course, once you have a script, you need to run it!</p>&#13;
<h3 class="h3" id="ch9lev3">Executing a Pester Test</h3>&#13;
<p class="noindent">The most common way to execute tests with Pester is by using the <span class="literal">Invoke-Pester</span> command. This command is a part of the Pester module and allows the tester to pass it a path to the test script, which Pester will then interpret and execute, as in <a href="ch09.xhtml#ch9list6">Listing 9-6</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester -Path C:\Sample.Tests.ps1</span>&#13;
Executing all tests in 'C:\Sample.Tests.ps1'&#13;
&#13;
Executing script C:\Sample.Tests.ps1&#13;
&#13;
  Describing IIS&#13;
    [+] installs the Web-Server Windows feature 2.85s&#13;
Tests completed in 2.85s&#13;
Tests Passed: 1, Failed: 0, Skipped: 0, Pending: 0, Inconclusive: 0</pre>&#13;
<p class="caption" id="ch9list6"><em>Listing 9-6: Running a Pester test</em></p>&#13;
<p class="indent">You can see that the <span class="literal">Invoke-Pester</span> command has executed the <em>Sample.Tests.ps1</em> script and has provided basic information such as displaying the name of the <span class="literal">describe</span> block, the result of the test, as well as a summary of all the tests that ran during that test run. Note that the <span class="literal">Invoke-Pester</span> command will always show a summary of the status of each test performed. In this case, the <span class="literal">installs the Web-Server Windows feature</span> test was successful, indicated by the <span class="literal">+</span> symbol and a green output.</p>&#13;
<h3 class="h3" id="ch9lev4"><span epub:type="pagebreak" id="page_112"/>Summary</h3>&#13;
<p class="noindent">This chapter covered the basics of the Pester testing framework. You downloaded, installed, and built a simple Pester test. This should help you understand how a Pester test is structured and how to execute it. In the coming chapters, you’ll use this framework over and over again. You’ll be adding lots of <span class="literal">describe</span> blocks, <span class="literal">it</span> blocks, and various assertions, but the basic structure will remain relatively unchanged.</p>&#13;
<p class="indent">This wraps up our final chapter of <a href="part1.xhtml#part1">Part I</a>. You’ve seen the fundamental syntax and concepts you’ll use when scripting with PowerShell. Now let’s get to the good stuff in <a href="part2.xhtml#part2">Part II</a>, where you’ll get hands-on experience and start looking at real-world problems!</p>&#13;
</body></html>