<html><head></head><body>
<h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_107"/><span class="big">9</span><br/>TESTING WITH PESTER</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">There’s no way around it: you need to test your code. It’s easy to assume your code has no flaws; it’s even easier to be proven wrong. When you test with Pester, you can stop assuming and start knowing.</span></p>&#13;
<p class="indent">Testing has been a feature of traditional software development for decades. But while concepts like <em>unit</em>, <em>functional</em>, <em>integration</em>, and <em>acceptance</em> testing may be familiar to seasoned software developers, they’re relatively new to scripters—those of us who want to automate with PowerShell but don’t hold a software engineer job title. Since many organizations are depending more on PowerShell code to run critical production systems, we’ll take a page from the programming world and apply it to PowerShell.</p>&#13;
<p class="indent">In this chapter, you’ll learn how to create tests for your scripts and modules so you can be sure your code works, and stays working when you’ve changed it. You’ll do this with the testing framework known as Pester.</p>&#13;
<h3 class="h3" id="ch9lev1"><span epub:type="pagebreak" id="page_108"/>Introducing Pester</h3>&#13;
<p class="noindent"><em>Pester</em> is an open source testing PowerShell module available in the PowerShell Gallery. Because it’s effective, and written in PowerShell, it’s become the de facto standard for testing in PowerShell. It allows you to write multiple types of tests, including unit, integration, and acceptance tests. If these test names don’t ring a bell, don’t worry. In this book, we’ll use Pester only to test environmental changes such as whether a virtual machine was created with the right name, whether IIS was installed, or whether the proper operating system was installed. We’ll refer to these tests as <em>infrastructure tests</em>.</p>&#13;
<p class="indent">We won’t cover how to test for things like whether a function was called, whether a variable was set correctly, or whether a script returned a specific object type—that’s all in the world of <em>unit testing</em>. If you’re curious about unit testing with Pester and want to learn how to use Pester in different situations, check out <em>The Pester Book</em> (LeanPub, 2019, <em><a href="https://leanpub.com/pesterbook/">https://leanpub.com/pesterbook/</a></em>), which explains just about everything you need to know about testing with PowerShell.</p>&#13;
<h3 class="h3" id="ch9lev2">Pester Basics</h3>&#13;
<p class="noindent">To use Pester, you must first get it installed. If you have Windows 10, Pester is installed by default, but it’s also available in the PowerShell Gallery if you’re on another Windows operating system. If you’re on Windows 10, chances are Pester will be outdated anyway, so you might as well grab the latest copy from the PowerShell Gallery. Since Pester is available via the PowerShell Gallery, you can run <code>Install-Module -Name Pester</code> to download and install it. Once installed, it will have all the commands you need.</p>&#13;
<p class="indent">It’s worth repeating that you’ll be using Pester to write and run infrastructure tests, which are meant to validate any expected changes a script performs against its environment. For example, you might run an infrastructure test after creating a new file path by using <code>Test-Path</code> to ensure that the file path was created. Infrastructure tests are safeguards put in place to confirm that your code did what you expected it to do.</p>&#13;
<h4 class="h4" id="ch9lev2sec1">A Pester File</h4>&#13;
<p class="noindent">In its most basic form, a Pester test script consists of a PowerShell script ending in <em>.Tests.ps1</em>. You can name the main script anything you like; the naming convention and test structure are entirely up to you. Here, you’ll name the script <em>Sample.Tests.ps1</em>.</p>&#13;
<p class="indent">The basic structure of a Pester test script is one or more <code>describe</code> blocks that each contain (optional) <code>context</code> blocks that each contain <code>it</code> blocks that each contain assertions. If that was a lot to process, <a href="ch09.xhtml#ch9list1">Listing 9-1</a> provides a visual guide.</p>&#13;
<pre><span epub:type="pagebreak" id="page_109"/>C:\Sample.Tests.ps1&#13;
    describe&#13;
        context&#13;
          it&#13;
            <span class="codeitalic1">assertions</span></pre>&#13;
<p class="caption" id="ch9list1"><em>Listing 9-1: A basic Pester test structure</em></p>&#13;
<p class="indent">Let’s go through each of these parts.</p>&#13;
<h4 class="h4" id="ch9lev2sec2">The describe Block</h4>&#13;
<p class="noindent">A <code>describe</code> block is a way to group like tests together. In <a href="ch09.xhtml#ch9list2">Listing 9-2</a>, you create a <code>describe</code> block called <code>IIS</code>, which you could use to include all the code to test things like Windows features, app pools, and websites.</p>&#13;
<p class="indent">The basic syntax for a <code>describe</code> block is the word <code>describe</code> followed by a name, in single quotes, followed by an opening and closing curly bracket.</p>&#13;
<pre>describe 'IIS' {&#13;
}</pre>&#13;
<p class="caption" id="ch9list2"><em>Listing 9-2: A Pester <code>describe</code> block</em></p>&#13;
<p class="indent">Although this structure looks like an <code>if/then</code> condition, don’t be fooled! This is a scriptblock that is passed to the <code>describe</code> function under the covers. Note that if you’re the type who prefers curly brackets on a new line, you’re out of luck: the opening curly bracket must come on the same line as the <code>describe</code> keyword.</p>&#13;
<h4 class="h4" id="ch9lev2sec3">The context Block</h4>&#13;
<p class="noindent">Once you create the <code>describe</code> block, you can add an optional <code>context</code> block. The <code>context</code> block groups together similar <code>it</code> blocks, which helps organize tests when infrastructure testing. In <a href="ch09.xhtml#ch9list3">Listing 9-3</a>, you’ll add a <code>context</code> block that will contain all the tests for Windows features. It’s a good idea to classify tests this way in <code>context</code> blocks to more easily manage them.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list3"><em>Listing 9-3: A Pester <code>context</code> block</em></p>&#13;
<p class="indent">Although optional, the <code>context</code> block will become invaluable later when you’ve created tests to test dozens or hundreds of components!</p>&#13;
<h4 class="h4" id="ch9lev2sec4"><span epub:type="pagebreak" id="page_110"/>The it Block</h4>&#13;
<p class="noindent">Now let’s add an <code>it</code> block inside the <code>context</code> block. An <code>it</code> block is a smaller component that labels the actual test. Its syntax, shown in <a href="ch09.xhtml#ch9list4">Listing 9-4</a>, has a name followed by a block, just as you saw with the <code>describe</code> block.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
        it 'installs the Web-Server Windows feature' {&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list4"><em>Listing 9-4: A Pester <code>describe</code> block with a <code>context</code> and <code>it</code> block</em></p>&#13;
<p class="indent">Notice that so far, you more or less just added different labels for the test, in varying scopes. In the next section, you’ll add the test itself.</p>&#13;
<h4 class="h4" id="ch9lev2sec5">Assertions</h4>&#13;
<p class="noindent">Inside the <code>it</code> block, you include one or more assertions. An <em>assertion</em> can be thought of as the actual test, or the code that compares the expected state to an actual state. The most common assertion in Pester is the <code>should</code> assertion. The <code>should</code> assertion has different operators that can be used with it, such as <code>be</code>, <code>bein</code>, <code>belessthan</code>, and so on. If you’d like a full list of available operators, the Pester wiki (<em><a href="https://github.com/pester/Pester/wiki/">https://github.com/pester/Pester/wiki/</a></em>) has a full list.</p>&#13;
<p class="indent">In our IIS example, let’s check whether the app pool named <code>test</code> was created on our server. To do that, you first have to write the code to find the current state of the <code>Web-Server</code> Windows feature on the server (we’ll call it <code>WEBSRV1</code>). After a little investigation by browsing through the available PowerShell commands with <code>Get-Command</code> and sifting through the <code>Get-WindowsFeature</code> command’s help text, you find that the code to do so looks like this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-WindowsFeature -ComputerName WEBSRV1 -Name Web-Server).Installed</span>&#13;
True</pre>&#13;
<p class="indent">You know that if the <code>Web-Server</code> feature is installed, the <code>Installed</code> property will return <code>True</code>; otherwise, it will return <code>False</code>. Knowing this, you can then assert that when you run this <code>Get-WindowsFeature</code> command, you expect the <code>Installed</code> property to be <code>True</code>. You want to test whether this command’s output will <em>be</em> equal to <code>True</code>. You can represent this scenario inside an <code>it</code> block, as shown in <a href="ch09.xhtml#ch9list5">Listing 9-5</a>.</p>&#13;
<pre>describe 'IIS' {&#13;
    context 'Windows features' {&#13;
        it 'installs the Web-Server Windows feature' {&#13;
            $parameters = @{&#13;
<span epub:type="pagebreak" id="page_111"/>                  ComputerName = 'WEBSRV1'&#13;
                  Name         = 'Web-Server'&#13;
            }&#13;
            (Get-WindowsFeature @parameters).Installed | should -Be $true&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list5"><em>Listing 9-5: Asserting a test condition with Pester</em></p>&#13;
<p class="indent">Here, you created a rudimentary Pester test to test whether a Windows feature is installed. You first enter the test you want to run, and then pass the results of that test through the pipeline to your testing condition, which, in this case, is <code>should be $true</code>.</p>&#13;
<p class="indent">There’s much more to writing Pester tests, and I encourage you to learn the details via <em>The Pester Book</em> (<em><a href="https://leanpub.com/pesterbook/">https://leanpub.com/pesterbook/</a></em>) or perhaps a series of articles on 4sysops (<em><a href="https://4sysops.com/archives/powershell-pester-testing-getting-started/">https://4sysops.com/archives/powershell-pester-testing-getting-started/</a></em>). This should be enough for you to be able to read the tests I provide with this book. Once you finish this book, writing your own Pester tests will be a good way to test your PowerShell skills.</p>&#13;
<p class="indent">You have a Pester script now. And of course, once you have a script, you need to run it!</p>&#13;
<h3 class="h3" id="ch9lev3">Executing a Pester Test</h3>&#13;
<p class="noindent">The most common way to execute tests with Pester is by using the <code>Invoke-Pester</code> command. This command is a part of the Pester module and allows the tester to pass it a path to the test script, which Pester will then interpret and execute, as in <a href="ch09.xhtml#ch9list6">Listing 9-6</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester -Path C:\Sample.Tests.ps1</span>&#13;
Executing all tests in 'C:\Sample.Tests.ps1'&#13;
&#13;
Executing script C:\Sample.Tests.ps1&#13;
&#13;
  Describing IIS&#13;
    [+] installs the Web-Server Windows feature 2.85s&#13;
Tests completed in 2.85s&#13;
Tests Passed: 1, Failed: 0, Skipped: 0, Pending: 0, Inconclusive: 0</pre>&#13;
<p class="caption" id="ch9list6"><em>Listing 9-6: Running a Pester test</em></p>&#13;
<p class="indent">You can see that the <code>Invoke-Pester</code> command has executed the <em>Sample.Tests.ps1</em> script and has provided basic information such as displaying the name of the <code>describe</code> block, the result of the test, as well as a summary of all the tests that ran during that test run. Note that the <code>Invoke-Pester</code> command will always show a summary of the status of each test performed. In this case, the <code>installs the Web-Server Windows feature</code> test was successful, indicated by the <code>+</code> symbol and a green output.</p>&#13;
<h3 class="h3" id="ch9lev4"><span epub:type="pagebreak" id="page_112"/>Summary</h3>&#13;
<p class="noindent">This chapter covered the basics of the Pester testing framework. You downloaded, installed, and built a simple Pester test. This should help you understand how a Pester test is structured and how to execute it. In the coming chapters, you’ll use this framework over and over again. You’ll be adding lots of <code>describe</code> blocks, <code>it</code> blocks, and various assertions, but the basic structure will remain relatively unchanged.</p>&#13;
<p class="indent">This wraps up our final chapter of <a href="part1.xhtml#part1">Part I</a>. You’ve seen the fundamental syntax and concepts you’ll use when scripting with PowerShell. Now let’s get to the good stuff in <a href="part2.xhtml#part2">Part II</a>, where you’ll get hands-on experience and start looking at real-world problems!</p>&#13;
</body></html>