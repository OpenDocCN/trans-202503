<html><head></head><body>
<section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<span aria-label="13" epub:type="pagebreak" id="pg_13" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch2">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">OBJECTS, FUNCTIONS, AND TYPES</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In this chapter, you’ll learn about objects, functions, and types. We’ll examine how to declare variables (objects with named identifiers) and functions, take the addresses of objects, and dereference those object pointers. Each object or function instance has a type. You’ve already seen some types that are available to C programmers. The first thing you’ll learn in this chapter is one of the last things that I learned: every type in C is either an object type or a function type.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-13"/><samp class="SANS_Futura_Std_Bold_B_11">Entities</samp></h2>
<p class="TNI">An <i>object</i> is storage in which you can represent values. To be precise, an object is defined by the C standard (ISO/IEC 9899:2024) as a “region of <span aria-label="14" epub:type="pagebreak" id="pg_14" role="doc-pagebreak"/>data storage in the execution environment, the contents of which can represent values,” with the added note, “when referenced, an object can be interpreted as having a particular type.” A variable is an example of an object.</p>
<p class="TX"><i>Variables</i> have a declared <i>type</i> that tells you the kind of object its value represents. For example, an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> contains an integer value. Type is important because the collection of bits that represent one type of object can have a different value if interpreted as a different type of object. For example, the number 1 is represented in the IEEE Standard for Floating-Point Arithmetic by the bit pattern <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp> (IEEE 754-2019). But if you were to interpret this same bit pattern as an integer, you’d get the value 1,065,353,216 instead of 1.</p>
<p class="TX"><i>Functions</i> are not objects but do have types. A function type is characterized by both its return type and the number and types of its parameters.</p>
<p class="TX">The C language also has <i>pointers</i>, which can be thought of as an <i>address</i>—a location in memory where an object or function is stored.</p>
<p class="TX">Just like objects and functions, object pointers and function pointers are different things and must not be interchanged. In the following section, you’ll write a simple program that attempts to swap the values of two variables to help you better understand objects, functions, pointers, and types.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">

<h2 class="H1" id="sec2"><span id="h1-14"/><samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp></h2>
<p class="TNI">When you declare a variable, you assign it a type and provide it a name, or <i>identifier</i>, by which the variable is referenced. Optionally, you can also <i>initialize</i> the variable.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-1">Listing 2-1</a> declares two integer objects with initial values. This simple program also declares, but doesn’t define, a <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function to swap those values.</p>
<span id="Lis2-1"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void swap(int, int); // defined in Listing 2-2

int main() {
  int a = 21;
  int b = 17;
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> swap(a, b);
  printf("main: a = %d, b = %d\n", a, b);
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A program meant to swap two integers</samp></p>
<p class="TX">This example program shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function with a single <i>compound statement</i> that includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> characters and all the statements between them (also referred to as a <i>block</i>). We define two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function. We declare the variables as having the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and initialize them to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. Each variable must have a <span aria-label="15" epub:type="pagebreak" id="pg_15" role="doc-pagebreak"/>declaration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function <span aria-label="annotation2" class="CodeAnnotation">❷</span> to try to swap the values of the two integers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function is declared in this program <span aria-label="annotation1" class="CodeAnnotation">❶</span> but not defined. We’ll look at some possible implementations of this function later in this section.</p>
<aside aria-label="box-1" class="box">
<p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">DECLARING MULTIPLE VARIABLES</samp></p>
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">You can declare multiple variables in any single declaration, but doing so can become confusing if the variables are pointers or arrays or if the variables are of different types. For example, the following declarations are all correct:</samp></p>

<pre><code>char *src, c;
int x, y[5];
int m[12], n[15][3], o[21];</code></pre>
<p class="Box"><samp class="SANS_Futura_Std_Book_11">The first line declares two variables,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp><samp class="SANS_Futura_Std_Book_11">, which have different types. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> <samp class="SANS_Futura_Std_Book_11">variable has a type of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <samp class="SANS_Futura_Std_Book_11">has a type of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp><samp class="SANS_Futura_Std_Book_11">. The second line again declares two variables,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">, with different types. The variable</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">has a type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_Futura_Std_Book_11">is an array of five elements of type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp><samp class="SANS_Futura_Std_Book_11">. The third line declares three arrays (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp><samp class="SANS_Futura_Std_Book_11">) with different dimensions and numbers of elements.</samp></p>
<p class="Box"><samp class="SANS_Futura_Std_Book_11">These declarations are easier to understand if each is on its own line:</samp></p>

<pre><code>char *src;    // src has a type of char *
char c;       // c has a type of char
int x;        // x has a type int
int y[5];     // y is an array of 5 elements of type int
int m[12];    // m is an array of 12 elements of type int
int n[15][3]; // n is an array of 15 arrays of 3 elements of type int
int o[21];    // o is an array of 21 elements of type int</code></pre>
<p class="Box"><samp class="SANS_Futura_Std_Book_11">Readable and understandable code is less likely to have defects.</samp></p>
</aside>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values, First Attempt</samp></h3>
<p class="TNI">Each object has a storage duration that determines its <i>lifetime</i>, which is the time during program execution for which the object exists, has storage, has a constant address, and retains its last-stored value. Objects must not be referenced outside their lifetime.</p>
<p class="TX">Local variables such as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from <a href="chapter2.xhtml#Lis2-1">Listing 2-1</a> have <i>automatic storage duration</i>, meaning that they exist until execution leaves the block in which they’re declared. We’re going to try to swap the values stored in these two variables. <a href="chapter2.xhtml#Lis2-2">Listing 2-2</a> shows our first attempt to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function.</p>
<span id="Lis2-2"/>
<pre><code>void swap(int a, int b) {
  int t = a;
  a = b;
<span aria-label="16" epub:type="pagebreak" id="pg_16" role="doc-pagebreak"/>  b = t;
  printf("swap: a = %d, b = %d\n", a, b);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A first attempt at implementing the</samp> <samp class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function is declared with two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, that we use to pass arguments to this function. C distinguishes between <i>parameters</i>, which are objects declared as part of the function declaration that acquire a value on entry to the function, and <i>arguments</i>, which are comma-separated expressions we include in the function call expression. We also declare a temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function and initialize it to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This variable is used to temporarily save the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> so that it’s not lost during the swap.</p>
<p class="TX">We can now run the generated executable to test the program:</p>

<pre><code>% <b>./a.out</b>
swap: a = 17, b = 21
main: a = 21, b = 17</code></pre>
<p class="TX">This result may be surprising. The variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. The first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function shows that these two values were swapped, but the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> shows the original values unchanged. Let’s examine what happened.</p>
<p class="TX">C is a <i>call-by-value</i> (also called a <i>pass-by-value</i>) language, which means that when you provide an argument to a function, the value of that argument is copied into a distinct variable for use within the function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function assigns the values of the objects you pass as arguments to their respective parameters. When the parameter values in the function are changed, the argument values in the caller are unaffected because they are distinct objects. Consequently, the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> retain their original values in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> during the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>. The goal of the program was to swap the values of these two objects. By testing the program, we’ve discovered it has a bug, or defect.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values, Second Attempt</samp></h3>
<p class="TNI">To repair this bug, we can use pointers to rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function. We use the indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) operator to both declare pointers and dereference them, as shown in <a href="chapter2.xhtml#Lis2-3">Listing 2-3</a>.</p>
<span id="Lis2-3"/>
<pre><code>void swap(int *pa, int *pb) {
  int t = *pa;
  *pa = *pb;
  *pb = t;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: The revised</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function using pointers</samp></p>
<p class="TX">When used in a function declaration or definition, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> acts as part of a pointer declarator indicating that the parameter is a pointer to an object <span aria-label="17" epub:type="pagebreak" id="pg_17" role="doc-pagebreak"/>or function of a specific type. In the rewritten <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function, we declare two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>, both having the type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<p class="TX">The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator denotes indirection. If its operand has type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, the result of the operation has type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. For example, consider the following assignment:</p>

<pre><code>pa = pb;</code></pre>
<p class="TX">This replaces the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> with the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>. Now consider the assignment in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function:</p>

<pre><code>*pa = *pb;</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> operation reads the value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> operation reads the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>. The value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> is then written to the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.</p>
<p class="TX">When you call the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, you must also place an ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>) character before each variable name:</p>

<pre><code>swap(&amp;a, &amp;b);</code></pre>
<p class="TX">The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> (<i>address-of</i>) operator generates a pointer to its operand. This change is necessary because the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function now accepts arguments of type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> instead of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-4">Listing 2-4</a> shows the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> program with comments describing the objects created during execution of this code and their values.</p>
<span id="Lis2-4"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void swap(int *pa, int *pb) {   // pa → a: 21    pb → b: 17
  int t = *pa;                  // t: 21
  *pa = *pb;                    // pa → a: 17    pb → b: 17
  *pb = t;                      // pa → a: 17    pb → b: 21
}

int main() {
  int a = 21;                   // a: 21
  int b = 17;                   // b: 17
  swap(&amp;a, &amp;b);
  printf("a = %d, b = %d\n", a, b);    // a: 17    b: 21
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A simulated call by reference</samp></p>
<p class="TX">Upon entering the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function block, the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. The code then takes the addresses of these objects and passes them to the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function as arguments.</p>
<p class="TX">Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function, the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> are now both declared as type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and contain copies of the arguments passed <span aria-label="18" epub:type="pagebreak" id="pg_18" role="doc-pagebreak"/>to <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> from the calling function (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>). These address copies still refer to the exact same objects, so when the values of their referenced objects are swapped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function, the contents of the original objects declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> are also swapped. This approach simulates <i>call by</i> reference (also known as <i>pass by</i> reference) by generating object addresses, passing those by value, and then dereferencing the copied addresses to access the original objects.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h2 class="H1" id="sec5"><span id="h1-15"/><samp class="SANS_Futura_Std_Bold_B_11">Object Types</samp></h2>
<p class="TNI">This section introduces object types in C. Specifically, we’ll cover the Boolean type, character types, and arithmetic types (including both integer and floating types).</p>
<section aria-labelledby="sec6" epub:type="division">

<h3 class="H2" id="sec6"><span id="h2-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boolean</samp></h3>
<p class="TNI">A Boolean data type has one of two possible values (<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>) that represent the two truth values of logic and Boolean algebra. Objects declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> can store only the values <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</p>
<aside aria-label="box-2" class="box">
<p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">RESERVED IDENTIFIERS</samp></p>
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Boolean type</samp> <samp class="SANS_Futura_Std_Book_11">was introduced in C99 starting with an underscore (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp><samp class="SANS_Futura_Std_Book_11">) to differentiate it in existing programs that had already declared their own identifiers named</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp><samp class="SANS_Futura_Std_Book_11">. Identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved. The C standards committee often creates new keywords such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp> <samp class="SANS_Futura_Std_Book_11">under the assumption that you have avoided the use of reserved identifiers. If you haven’t, as far as the C standards committee is concerned, it’s your fault for not having read the standard more carefully. C23 added the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> <samp class="SANS_Futura_Std_Book_11">keyword but retained</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp> <samp class="SANS_Futura_Std_Book_11">as an alternative spelling, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> <samp class="SANS_Futura_Std_Book_11">is now the preferred spelling. The keywords</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> <samp class="SANS_Futura_Std_Book_11">are constants of type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> <samp class="SANS_Futura_Std_Book_11">with a value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <samp class="SANS_Futura_Std_Book_11">for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp><samp class="SANS_Futura_Std_Book_11">. If you are using an older version of C, you can include the header</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdbool.h&gt;</samp><samp class="SANS_Futura_Std_Book_11">, still spell this type as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp><samp class="SANS_Futura_Std_Book_11">, and assign it the values</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>
<p class="TX">The following example declares a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> that takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument and returns a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>:</p>

<pre><code>bool arm_detonator(int);

void arm_missile(void) {
  bool armed = arm_detonator(3);
  if (armed) puts("missile armed");
  else puts("missile disarmed");
}</code></pre>
<p class="TX"><span aria-label="19" epub:type="pagebreak" id="pg_19" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> function calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> function and assigns the return value to the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>. This value can then be tested to determine whether the missile is armed.</p>
<p class="TX">Historically, Boolean values were represented by integers and still behave as integers. They can be stored in integer variables and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. C guarantees that any two true values will compare equally (which was impossible to achieve before the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> type). You should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> type to represent Boolean values.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h3 class="H2" id="sec7"><span id="h2-13"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character</samp></h3>
<p class="TNI">The C language defines the following character types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>. Each compiler implementation defines <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to have the same alignment, size, range, representation, and behavior as either <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>. Regardless of the choice made, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is a separate type from the other two and is incompatible with both.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type is commonly used to represent character data in C language programs. Objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> can represent the <i>basic execution character set</i>—the minimum set of characters required in the execution environment—including upper- and lowercase letters, the 10 decimal digits, the space character, punctuation, and control characters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type is inappropriate for integer data; use <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> to represent small, signed integer values, and use <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> to represent small, unsigned integer values.</p>
<p class="TX">The size of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is always 1 byte, and its width is <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> macro from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> defines the number of bits in a byte. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> macro cannot be less than 8, and on most modern platforms, it is 8.</p>
<p class="TX">The basic execution character set suits the needs of many conventional data processing applications, but its lack of non-English letters is an obstacle to acceptance by international users. To address this need, the C standards committee specified a new wide type to allow large character sets. You can represent the characters of a large character set as <i>wide characters</i> by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type, which generally takes more space than a basic character. Typically, implementations choose 16 or 32 bits to represent a wide character. The C standard library provides functions that support both narrow and wide character types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type was not designed to support Unicode and has consequently fallen out of favor for most implementations with the notable exception of Microsoft Visual Studio.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic</samp></h3>
<p class="TNI">C provides several <i>arithmetic types</i> that can be used to represent integers, enumerators, and floating-point values. <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> covers some of these in more detail, but here’s a brief introduction.</p>
<section aria-labelledby="sec9" epub:type="division">
<span aria-label="20" epub:type="pagebreak" id="pg_20" role="doc-pagebreak"/>
<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer</samp></h4>
<p class="TNI"><i>Signed integer types</i> can be used to represent negative numbers, positive numbers, and zero. The standard signed integer types include <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.</p>
<p class="TX">For each signed integer type, there is a corresponding <i>unsigned integer type</i> that uses the same amount of storage: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long int</samp>. The unsigned types can represent positive numbers and zero. These unsigned integer types along with type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> make up the standard unsigned integer types.</p>
<p class="TX">Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> itself, the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> may be omitted in the declarations for these types, so you might, for example, declare a type by using <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.</p>
<p class="TX">The signed and unsigned integer types are used to represent integers of various widths. Each platform determines the width for each of these types, given some constraints. Each type has a minimum representable range. The types are ordered by width, guaranteeing that wider types are at least as large as narrower types. This means that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp> can represent all values that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> can represent, an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> can represent all values that can be represented by an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and so forth. The implementation-defined minimum and maximum representable values for integer types are specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> header file.</p>
<p class="TX"><i>Extended integer types</i> may be provided in addition to the standard integer types. They are implementation defined, meaning that their width, precision, and behavior are up to the compiler. Extended integer types are typically larger than the standard integer types (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>).</p>
<p class="TX">In addition to the standard and extended integer types, C23 adds <i>bit-precise integer types</i>. These types accept an operand specifying the width of the integer, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp> is a signed 32-bit integer, and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types do not require their width to be a power of two; the maximum width supported is specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp> (which must be at least the same as the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp>).</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type is typically assigned the natural width suggested by the architecture of the execution environment (for example, 16 bits on a 16-bit architecture and 32 bits on a 32-bit or 64-bit architecture). You can specify actual-width integers by using type definitions from the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdint.h&gt;</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;inttypes.h&gt;</samp> header, like <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>. These headers also provide type definitions for the greatest-width integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp> type, for example, can represent any value of any signed integer type with the possible exceptions of signed bit-precise integer types and of signed extended integer types.</p>
<p class="TX"><span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> covers integer types in excruciating detail.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<span aria-label="21" epub:type="pagebreak" id="pg_21" role="doc-pagebreak"/>
<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp></h4>
<p class="TNI">An <i>enumeration</i>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>, allows you to define a type that assigns names (<i>enumerators</i>) to integer values in cases with an enumerable set of constant values. The following are examples of enumerations:</p>

<pre><code>enum day {sun, mon, tue, wed, thu, fri, sat};
enum cardinal_points {north = 0, east = 90, south = 180, west = 270};
enum months {jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec};</code></pre>
<p class="TX">If you don’t specify a value to the first enumerator with the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator, the value of its enumeration constant is 0, and each subsequent enumerator without an <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> adds 1 to the value of the previous enumeration constant. Consequently, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">sun</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">day</samp> enumeration is 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">mon</samp> is 1, and so forth.</p>
<p class="TX">You can also assign specific values to each enumerator, as shown by the <samp class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp> enumeration. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> with enumerators may produce enumeration constants with duplicate values, which can be a problem if you incorrectly assume that all the values are unique. The <samp class="SANS_TheSansMonoCd_W5Regular_11">months</samp> enumeration sets the first enumerator at 1, and each subsequent enumerator that isn’t specifically assigned a value will be incremented by 1.</p>
<p class="TX">Starting with C23, you can specify the underlying type of the enumeration. For portability and other reasons (Meneide and Pygott 2022), it is always better to specify the enumeration type. In the following example, the enumeration constant <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp> can be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp> because the type is specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp>:</p>

<pre><code>enum a : unsigned long long {
  a0 = 0xFFFFFFFFFFFFFFFFULL
};</code></pre>
<p class="TX">An omitted type is implementation defined. Visual C++ uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> for the type, and GCC uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp></h4>
<p class="TNI">Floating-point arithmetic is similar to, and often used as a model for, the arithmetic of real numbers. The C language supports a variety of floating-point representations including, on most systems, representations in the IEEE Standard for Floating-Point Arithmetic (IEEE 754-2019). ISO/IEC 60559:2011 has content identical to IEEE 754-2019 but is referenced by the C standard because it is published by the same standards organization. The choice of floating-point representation is implementation defined. <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> covers floating types in detail.</p>
<p class="TX">The C language supports three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>. The set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>; the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>.</p>
<p class="TX"><span aria-label="22" epub:type="pagebreak" id="pg_22" role="doc-pagebreak"/>C23 adds three <i>decimal floating types</i> (ISO/IEC TS 18661-2:2015), designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>. Respectively, these have the decimal32, decimal64, and decimal128 IEC 60559 formats.</p>
<p class="TX">The standard floating types and the decimal floating types are collectively called the <i>real floating types</i>.</p>
<p class="TX">There are also three <i>complex types</i>, designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">float complex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double complex</samp>.</p>
<p class="TX">The real floating and complex types are collectively called the <i>floating types</i>. <a href="chapter2.xhtml#fig2-1">Figure 2-1</a> shows the hierarchy of floating types.</p>
<figure class="IMG"><img alt="" class="img1" id="fig2-1" src="../images/f02001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The hierarchy of floating types</samp></p></figcaption>
</figure>
<p class="TX">Complex types and decimal floating types are not covered in detail in this book.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h3 class="H2" id="sec12"><span id="h2-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is a rather strange type. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> (by itself) means “cannot hold any value.” For example, you can use it to indicate that a function doesn’t return a value or as the sole parameter of a function to indicate that the function takes no arguments. On the other hand, the <i>derived type</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> means that the pointer can reference <i>any</i> object.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h2 class="H1" id="sec13"><span id="h1-16"/><samp class="SANS_Futura_Std_Bold_B_11">Derived Types</samp></h2>
<p class="TNI"><i>Derived types</i> are constructed from other types. These include function types, pointer types, array types, type definitions, structure types, and union types—all of which are covered here.</p>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2" id="sec14"><span id="h2-16"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function</samp></h3>
<p class="TNI">A <i>function type</i> is derived from the return type and the number and types of its parameters. A function can return any complete object type except for an array type.</p>
<p class="TX">When you declare a function, you use the <i>function declarator</i> to specify the name of the function and the return type. If the declarator includes a parameter type list and a definition, the declaration of each parameter must include an identifier, except parameter lists with only a single parameter of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, which needs no identifier.</p>
<p class="TX"><span aria-label="23" epub:type="pagebreak" id="pg_23" role="doc-pagebreak"/>Here are a few function type declarations:</p>

<pre><code>int f(void);
int fprime();
int *fip();
void g(int i, int j);
void h(int, int);</code></pre>
<p class="TX">First, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>, with no parameter that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Next, we declare a function <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> with no parameters that return a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Finally, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, each returning <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and taking two parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<p class="TX">Specifying parameters with identifiers (as done here with <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) can be problematic if an identifier is a macro. However, providing parameter names is good practice for self-documenting code, so omitting the identifiers (as done with <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) is not typically recommended.</p>
<p class="TX">In a function declaration, specifying parameters is optional. However, failing to do so can be problematic. Prior to C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> declares a function accepting any number of arguments of any type and returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. The same function declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> in C++ declares a function accepting no arguments and returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Starting with C23, a function declarator with an empty parameter list declares a prototype for a function that takes no arguments (like it does in C++).</p>
<p class="TX">A function type is also known as a <i>function prototype</i>. A function prototype informs the compiler about the number and types of parameters a function accepts. Compilers use this information to verify that the correct number and type of parameters are used in the function definition and any calls to the function.</p>
<p class="TX">The <i>function definition</i> provides the actual implementation of the function. Consider the following function definition:</p>

<pre><code>int max(int a, int b)
{return a &gt; b ? a : b;}</code></pre>
<p class="TX">The return type specifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>; the function declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">max(int a, int b)</samp>; and the function body is <samp class="SANS_TheSansMonoCd_W5Regular_11">{return a &gt; b ? a : b;}</samp>. The specification of a function type must not include any type qualifiers (see “<span class="Xref">Type Qualifiers</span>” on <span class="Xref"><a href="#pg_31">page 31</a></span>). The function body itself uses the conditional operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>), which is explained in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. This expression states that if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>; otherwise, return <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h3 class="H2" id="sec15"><span id="h2-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer</samp></h3>
<p class="TNI">A <i>pointer type</i> is derived from a function or object type called the <i>referenced type</i>. A pointer type derived from the referenced type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is called a <i>pointer to</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. A pointer provides a reference to an entity of the referenced type.</p>
<p class="TX"><span aria-label="24" epub:type="pagebreak" id="pg_24" role="doc-pagebreak"/>The following three declarations declare a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, and a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:</p>

<pre><code>int *ip = 0; // compliant
char *cp = NULL; // good
void *vp = nullptr; // better</code></pre>
<p class="TX">Each pointer is initialized to a null pointer constant. A null pointer constant can be specified as an integer constant expression with the value 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp>, or the predefined constant <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> macro is defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stddef.h&gt;</samp>. If a null pointer constant is converted to a pointer type, the resulting null pointer is guaranteed to compare unequally to a pointer to any object or function.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant was introduced in C23 and has advantages to using <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> (Gustedt 2022). <a href="chapter2.xhtml#tab2-1">Table 2-1</a> shows common values for <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> and their associated types.</p>
<p class="TT" id="tab2-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common Values for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> <samp class="SANS_Futura_Std_Book_11">and Their Associated Types</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">These different types can have surprising results when invoking a type-generic macro with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument. The conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true ? 0 : NULL)</samp> is always defined, regardless of the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>. However, the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true ? 1 : NULL)</samp> is a constraint violation if <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> has type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.</p>
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument passed as a sentinel value to a variadic function, such as the Portable Operating System Interface (POSIX) <samp class="SANS_TheSansMonoCd_W5Regular_11">execl</samp> function, which expects a pointer, can have unexpected results. On most modern architectures, the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> types have different sizes. If <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> is defined as 0 on such an architecture, an incorrectly sized argument is passed to the variadic function.</p>
<p class="TX">Earlier in the chapter, I introduced the address-of (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>) and indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) operators. You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator to take the address of an object or function. For example, taking the address of an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object results in an address with the type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>int i = 17;
int *ip = &amp;i;</code></pre>
<p class="TX">The second declaration declares the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp> as a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and initializes it to the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator on the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator:</p>

<pre><code><span aria-label="25" epub:type="pagebreak" id="pg_25" role="doc-pagebreak"/>ip = &amp;*ip;</code></pre>
<p class="TX">Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator resolves to the actual object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Taking the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator retrieves the pointer, so these two operations cancel each other out.</p>
<p class="TX">The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator converts a pointer to a type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> into a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. It denotes <i>indirection</i> and operates only on pointers. If the operand points to a function, the result of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator is the function designator, and if it points to an object, the result is a value of the designated object. For example, if the operand is a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result of the indirection operator has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. If the pointer is not pointing to a valid object or function, the behavior is undefined.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h3 class="H2" id="sec16"><span id="h2-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array</samp></h3>
<p class="TNI">An <i>array</i> is a contiguously allocated sequence of objects that all have the same element type. Array types are characterized by their element types and the number of elements in the array. Here we declare an array of 11 elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp> and an array of 17 elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>:</p>

<pre><code>int ia[11];
float *afp[17];</code></pre>
<p class="TX">You can use square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) to identify an element of an array. For example, the following contrived code snippet creates the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp> to demonstrate how to assign values to the elements of an array:</p>

<pre><code>char str[11];
for (unsigned int i = 0; i &lt; 10; ++i) {
  str[i] = '0' + i;
}
str[10] = '\0';</code></pre>
<p class="TX">The first line declares an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> with a bound of 11. This allocates sufficient storage to create a string with 10 characters plus a null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates 10 times, with the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> ranging from 0 to 9. Each iteration assigns the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>. Following the end of the loop, the null character is copied to the final element of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> now contains the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>.</p>
<p class="TX">In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is automatically converted to a pointer to the first member of the array (pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>), and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an unsigned integer type. The subscript (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) and addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operators are defined so that <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> is identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is an array object (as it is here), the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> designates the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>th element of the array (counting from 0). Because arrays are indexed starting at 0, the array <samp class="SANS_TheSansMonoCd_W5Regular_11">char str[11]</samp> is indexed from 0 to 10, with 10 being the last element, as referenced on the last line of this example.</p>
<p class="TX"><span aria-label="26" epub:type="pagebreak" id="pg_26" role="doc-pagebreak"/>If the operand of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator is the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operator, the result is as if the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator were removed and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operator were changed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;str[10]</samp> is the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>:</p>

<pre><code>&amp;str[10] → &amp;*(str + 10) → str + 10</code></pre>
<p class="TX">You can also declare multidimensional arrays. <a href="chapter2.xhtml#Lis2-5">Listing 2-5</a> declares <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> in the function <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as a two-dimensional 3×5 array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, also referred to as a <i>matrix</i>.</p>
<span id="Lis2-5"/>
<pre><code>#include &lt;stdlib.h&gt;
void func(int arr[5]);
int main() {
  unsigned int i = 0;
  unsigned int j = 0;
  int arr[3][5];
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> func(arr[i]);
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> int x = arr[i][j];
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Matrix operations</samp></p>
<p class="TX">More precisely, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is an array of three elements, each of which is an array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When you use the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span> (which is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>), the following occurs:</p>
<div class="spc">
<p class="ListNumber">  1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is converted to a pointer to the initial array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.</p>
<p class="ListNumber">  2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is scaled to the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> by multiplying <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by the size of one array of five <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects.</p>
<p class="ListNumber">  3.  The results from steps 1 and 2 are added.</p>
<p class="ListNumber">  4.  Indirection is applied to the sum to produce an array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
</div>
<p class="TX">When used in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, that array is converted to a pointer to the first element of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> produces an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<aside aria-label="box-3" class="box">
<p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">TYPE DEFINITIONS</samp></p>
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">You use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> <samp class="SANS_Futura_Std_Book_11">to declare an alias for an existing type; it never creates a new type. For example, each of the following declarations creates at least one new type alias:</samp></p>

<pre><code>typedef unsigned int uint_type;
typedef signed char schar_type, *schar_p, (*fp)(void);</code></pre>
<p class="Box"><span aria-label="27" epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">On the first line, we declare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">uint_type</samp> <samp class="SANS_Futura_Std_Book_11">as an alias for the type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp><samp class="SANS_Futura_Std_Book_11">. On the second line, we declare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">schar_type</samp> <samp class="SANS_Futura_Std_Book_11">as an alias for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp><samp class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">schar_p</samp> <samp class="SANS_Futura_Std_Book_11">as an alias for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char *</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp> <samp class="SANS_Futura_Std_Book_11">as an alias for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char(*)(void)</samp><samp class="SANS_Futura_Std_Book_11">. Identifiers that end in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_t</samp> <samp class="SANS_Futura_Std_Book_11">in the standard headers are type definitions (aliases for existing types). You should not follow this convention in your own code because the C standard reserves identifiers that match the patterns</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int[0-9a-z_]*_t</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">uint[0-9a-z_]*_t</samp><samp class="SANS_Futura_Std_Book_11">, and POSIX reserves all identifiers that end in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_t</samp><samp class="SANS_Futura_Std_Book_11">. If you define identifiers that use these names, they may collide with names used by the implementation, which can cause problems that are difficult to debug.</samp></p>
</aside>
</section>
<section aria-labelledby="sec17" epub:type="division">

<h3 class="H2" id="sec17"><span id="h2-19"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure</samp></h3>
<p class="TNI">A <i>structure type</i> (also known as a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>) contains sequentially allocated members. Each member has its own name and may have a distinct type—unlike array elements, which must all be of the same type. Structures are like record types found in other programming languages.</p>
<p class="TX">Structures are useful for declaring collections of related objects and may be used to represent things such as a date, customer, or personnel record. They are especially useful for grouping objects that are frequently passed together as arguments to a function, so you don’t need to repeatedly pass individual objects separately.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-6">Listing 2-6</a> declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> named <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> with type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> and a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> named <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>.</p>
<span id="Lis2-6"/>
<pre><code>struct sigrecord {
  int signum;
  char signame[20];
  char sigdesc[100];
} sigline, *sigline_p;</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A</samp> <samp class="I">struct sigrecord</samp></p>
<p class="TX">The structure has three member objects: <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp> is an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp> is an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 20 elements, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> is an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 100 elements.</p>
<p class="TX">Once you have defined a structure, you’ll likely want to reference its members. You reference members of an object of the structure type by using the structure member (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator. If you have a pointer to a structure, you can reference its members with the structure pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp>) operator. <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a> demonstrates the use of each operator.</p>
<span id="Lis2-7"/>
<pre><code>sigline.signum = 5;
strcpy(sigline.signame, "SIGINT");
strcpy(sigline.sigdesc, "Interrupt from keyboard");

<span aria-label="28" epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> sigline_p = &amp;sigline;

sigline_p-&gt;signum = 5;
strcpy(sigline_p-&gt;signame, "SIGINT");
strcpy(sigline_p-&gt;sigdesc, "Interrupt from keyboard");</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Referencing structure members</samp></p>
<p class="TX">The first three lines of <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a> directly access members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object by using the dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator. We assign the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object to the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In the final three lines of the program, we indirectly access the members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator through the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h3 class="H2" id="sec18"><span id="h2-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union</samp></h3>
<p class="TNI"><i>Union types</i> are like structures, except that the memory used by the member objects overlaps. Unions provide multiple different ways to look at the same memory.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-8">Listing 2-8</a> shows a union that contains a single member <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> that contains three bitfields of type <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>: <samp class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>.</p>
<span id="Lis2-8"/>
<pre><code>static_assert(
  (__STDC_IEC_60559_BFP__ &gt;= 202311L || __STDC_IEC_559__ == 1)
  &amp;&amp; __STDC_ENDIAN_LITTLE__
);

union {
  float f;
  struct {
    uint32_t significand : 23;
    uint32_t exponent : 8;
    uint32_t sign : 1;
  };
} float_encoding;</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: Decomposing a</samp> <samp class="I">float</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">using a</samp> <samp class="I">union</samp></p>
<p class="TX">This allows a (low-level) C programmer to use the entire floating-point value and examine (and possibly modify) its constituent parts. This union is not portable because implementations may use a different floating-point representation or endianness. The <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> tests to ensure this union matches the implementation.</p>
<p class="TX"><a href="chapter2.xhtml#Lis2-9">Listing 2-9</a> shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct n</samp> that contains a member <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> and a union <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> that itself contains four members: <samp class="SANS_TheSansMonoCd_W5Regular_11">inode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnode</samp>.</p>
<span id="Lis2-9"/>
<pre><code>enum node_type {
  integer_type,
  float_type,
  double_float_type,
<span aria-label="29" epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>  long_double_type
};

struct node {
  enum node_type type;
  union {
    int inode;
    float fnode;
    double dnode;
    long double ldnode;
  } u;
} n;

n.type = double_type;
n.u.dnode = 3.14;</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Saving memory with a union</samp></p>
<p class="TX">This structure might be used in a tree, a graph, or some other data structure that contains differently typed nodes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> member might contain a value between 0 and 3, which indicates the type of the value stored in the structure. It is declared directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct n</samp> because it is common to all nodes.</p>
<p class="TX">As with structures, you can access union members via the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operator. Using a pointer to a union, you can reference its members with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator. In <a href="chapter2.xhtml#Lis2-9">Listing 2-9</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp> member is referenced as <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>. Code that uses this union will typically check the type of the node by examining the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> and then accessing the value using <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.inode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.ldnode</samp>, depending on the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp>. Without the union, each node would contain separate storage for all four data types. The use of a union allows the same storage to be used for all union members. On the x86-64 GCC version 13.2 compiler, using a union saved 16 bytes per node.</p>
<p class="TX">Unions are commonly used to describe network or device protocols in cases where you do not know in advance which protocol will be used.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h2 class="H1" id="sec19"><span id="h1-17"/><samp class="SANS_Futura_Std_Bold_B_11">Tags</samp></h2>
<p class="TNI"><i>Tags</i> are a special naming mechanism for structures, unions, and enumerations. For example, the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> in the following structure is a tag:</p>

<pre><code>struct s {
  // <var>--snip--</var>
};</code></pre>
<p class="TX">By itself, a tag is not a type name and cannot be used to declare a variable (Saks 2002). Instead, you must declare variables of this type as follows:</p>

<pre><code>struct s v;   // instance of struct s
struct s *p;  // pointer to struct s</code></pre>
<p class="TX"><span aria-label="30" epub:type="pagebreak" id="pg_30" role="doc-pagebreak"/>The names of unions and enumerations are also tags and not types, meaning that they cannot be used alone to declare a variable. For example:</p>

<pre><code>enum day {sun, mon, tue, wed, thu, fri, sat};
day today;  // error
enum day tomorrow;  // OK</code></pre>
<p class="TX">The tags of structures, unions, and enumerations are defined in a separate <i>namespace</i> from ordinary identifiers. This allows a C program to have both a tag and another identifier with the same spelling in the same scope:</p>

<pre><code>enum status {ok, fail};    // enumeration
enum status status(void);  // function</code></pre>
<p class="TX">You can even declare an object <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>:</p>

<pre><code>struct s s;</code></pre>
<p class="TX">This may not be good practice, but it is valid C. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> tags as type names and define an alias for the tag by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>. Here’s an example:</p>

<pre><code>typedef struct s {int x;} t;</code></pre>
<p class="TX">This now allows you to declare variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. The tag name in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> is optional, so you can just dispense with it entirely:</p>

<pre><code>typedef struct {int x;} t;</code></pre>
<p class="TX">This works fine except in the case of self-referential structures that contain pointers to themselves:</p>

<pre><code>struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
};</code></pre>
<p class="TX">C requires the use of tag types (<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>) to include the tag name. The compiler will emit a diagnostic if you do not use <samp class="SANS_TheSansMonoCd_W5Regular_11">struct tnode</samp> in the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> pointers. Consequently, you must declare a tag for the structure.</p>
<p class="TX">You can create an alias for the structure using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>:</p>

<pre><code>typedef struct tnode {
  int count;
  struct tnode *left;
  struct tnode *right;
} tnode;</code></pre>
<p class="TX"><span aria-label="31" epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/>The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> pointers must still use the tag name because the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> name is not introduced until after the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> declaration is complete. You can use the same name for the tag and the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>, but a common idiom is to name the tag something ugly such as <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode_</samp> to encourage programmers to use the type name:</p>

<pre><code>typedef struct tnode_ {
  int count;
  struct tnode_ *left;
  struct tnode_ *right;
} tnode;</code></pre>
<p class="TX">You can also define this type before the structure so that you can use it to declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> members that refer to other objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode</samp>:</p>

<pre><code>typedef struct tnode tnode;
struct tnode {
  int count;
  tnode *left;
  tnode *right;
};</code></pre>
<p class="TX">Type definitions can improve code readability beyond their use with structures. For example, given the following type definition</p>

<pre><code>typedef void fv(int), (*pfv)(int);</code></pre>
<p class="Continued">these declarations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp> function all specify the same type:</p>

<pre><code>void (*signal(int, void (*)(int)))(int);
fv *signal(int, fv *);
pfv signal(int, pfv);</code></pre>
<p class="Continued">The last two declarations are clearly easier to read.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h2 class="H1" id="sec20"><span id="h1-18"/><samp class="SANS_Futura_Std_Bold_B_11">Type Qualifiers</samp></h2>
<p class="TNI">All the types examined so far have been unqualified types. You can qualify types by using one or more of the following qualifiers: <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>. Each of these qualifiers changes behaviors when accessing objects of the qualified type.</p>
<p class="TX">The qualified and unqualified versions of types can be used interchangeably as arguments to functions, return values from functions, and structure and union members.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> <i>type qualifier, available since C11, supports concurrent programs.</i></p>
<section aria-labelledby="sec21" epub:type="division">
<span aria-label="32" epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>
<h3 class="H2" id="sec21"><span id="h2-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">const</samp></h3>
<p class="TNI">Objects declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified types) are not assignable but can have constant initializers. This means the compiler can place objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified types in read-only memory, and any attempt to write to them will result in a runtime error:</p>

<pre><code>const int i = 1; // const-qualified int
i = 2; // error: i is const-qualified</code></pre>
<p class="TX">It’s possible to accidentally convince your compiler to change a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified object for you. In the following example, we take the address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and tell the compiler that it’s actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>const int i = 1;  // object of const-qualified type
int *ip = (int *)&amp;i;
*ip = 2;  // undefined behavior</code></pre>
<p class="TX">C does not allow you to cast away the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> if the original was declared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified object. This code might appear to work, but it’s defective and may fail later. For example, the compiler might place the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified object in read-only memory, causing a memory fault when trying to store a value in the object at runtime.</p>
<p class="TX">C allows you to modify an object that is referenced by a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified pointer by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> away, provided that the original object was not declared <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>:</p>

<pre><code>int i = 12;
const int j = 12;
const int *ip = &amp;i;
const int *jp = &amp;j;
*(int *)ip = 42; // OK
*(int *)jp = 42; // undefined behavior</code></pre>
<p class="TX">Be careful not to pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified pointer to a function that modifies the object.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">

<h3 class="H2" id="sec22"><span id="h2-22"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">volatile</samp></h3>
<p class="TNI">Objects are given a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type to allow for processes that are <i>extrinsic</i> to the compiler. The values stored in these objects may change without the knowledge of the compiler, or a write may synchronize externally. For example, every time the value from a real-time clock is read, it may change, even if the value has not been written to by the C program. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type lets the compiler know that the value may change without its knowledge and ensures that every access to the real-time <span aria-label="33" epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/>clock occurs. Otherwise, an access to the real-time clock may be optimized away or replaced by a previously read and cached value.</p>
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type can be used to access memory-mapped registers, which are accessed through an address just like any other memory. Input/output (I/O) devices often have memory-mapped registers, where you can write to, or read from, a specific address to set or retrieve information or data. Each read and write operation must occur, even if the compiler can see no reason for it. Declaring an object as <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> ensures that each read or write of that object at runtime occurs the same number of times and in the same order as indicated by the source code. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> is defined as a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the compiler must generate instructions to read the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> and then write this value back to <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> in the assignment:</p>

<pre><code>port = port;</code></pre>
<p class="TX">Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> qualification, the compiler would see this as a no-op (a programming statement that does nothing) and might eliminate both the read and the write. Reads and writes of volatile memory are touched exactly once. A volatile operation cannot be eliminated or fused with a subsequent one, even if the compiler believes it’s useless. A volatile operation cannot be speculated, even if the compiler can undo or otherwise make that speculation benign.</p>
<p class="TX">Objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types are used when a compiler is not aware of external interactions. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types can be used for memory shared with untrusted code to avoid time-of-check to time-of-use (ToCToU) vulnerabilities. Such types are used to access objects from a signal handler and with <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp> (refer to the C standard for information on signal handlers and <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp>). Unlike Java and other programming languages, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types should not be used in C for synchronization between threads.</p>
<p class="TX">Memory-mapped I/O ports are modeled by a <samp class="SANS_TheSansMonoCd_W5Regular_11">static volatile</samp>–qualified objects model. Memory-mapped input ports such as a real-time clock are modeled by <samp class="SANS_TheSansMonoCd_W5Regular_11">static const volatile</samp>–qualified objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">const volatile</samp>–qualified object models a variable that can be altered by a separate thread. The meaning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class specifier is explained later in this chapter.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">

<h3 class="H2" id="sec23"><span id="h2-23"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">restrict</samp></h3>
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointer is used to promote optimization. Objects indirectly accessed through a pointer frequently cannot be fully optimized because of potential aliasing, which occurs when more than one pointer refers to the same object. Aliasing can inhibit optimizations because the compiler can’t tell whether an object can change values when another apparently unrelated object is modified, for example.</p>
<p class="TX"><span aria-label="34" epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>The following function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> bytes from the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> to the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>. The function parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointers:</p>

<pre><code>void f(unsigned int n, int * restrict p, int * restrict q) {
  while (n-- &gt; 0) {
    *p++ = *q++;
  }
}</code></pre>
<p class="TX">Because both <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointers, the compiler can assume that an object accessed through one of the pointer parameters is not also accessed through the other. The compiler can make this assessment based solely on the parameter declarations without analyzing the function body.</p>
<p class="TX">Although using <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointers can result in more efficient code, you must ensure that the pointers do not refer to overlapping memory to prevent undefined behavior.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">

<h2 class="H1" id="sec24"><span id="h1-19"/><samp class="SANS_Futura_Std_Bold_B_11">Scope</samp></h2>
<p class="TNI">Objects, functions, macros, and other C language identifiers have <i>scope</i> that delimits the contiguous region where they can be accessed. C has four types of scope: file, block, function prototype, and function.</p>
<p class="TX">The scope of an object or function identifier is determined by where it is declared. If the declaration is outside any block or parameter list, the identifier has <i>file scope</i>, meaning its scope is the entire text file in which it appears as well as any included files.</p>
<p class="TX">If the declaration appears inside a block or within the list of parameters, it has <i>block scope</i>, meaning that the identifier is accessible only from within the block. The identifiers for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from <a href="chapter2.xhtml#Lis2-4">Listing 2-4</a> have block scope and can be referenced only from within the code block in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function in which they’re defined.</p>
<p class="TX">If the declaration appears within the list of parameter declarations in a function prototype (not part of a function definition), the identifier has <i>function prototype scope</i>, which terminates at the end of the function declarator. <i>Function scope</i> is the area between the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>of a function definition and its closing}. A label name is the only kind of identifier that has function scope. <i>Labels</i> are identifiers followed by a colon, and they identify a statement in the same function to which control may be transferred. (<span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> covers labels and control transfer.)</p>
<p class="TX">Scopes also can be <i>nested</i>, with <i>inner</i> and <i>outer</i> scopes. For example, you can define a block scope inside another block scope, and every block scope is defined within a file scope. The inner scope has access to the outer scope, but not vice versa. As the name implies, any inner scope must be completely contained within any outer scope that encompasses it.</p>
<p class="TX">If you declare the same identifier in both an inner scope and an outer scope, the identifier declared in the outer scope is <i>hidden</i> (also known as <i>shadowed</i>) by the identifier declared in the inner scope. Referencing the <span aria-label="35" epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/>identifier from the inner scope will refer to the object in the inner scope; the object in the outer scope is hidden and cannot be referenced by its name. The easiest way to prevent this from becoming a problem is to use different names. <a href="chapter2.xhtml#Lis2-10">Listing 2-10</a> demonstrates different scopes and how identifiers declared in inner scopes can hide identifiers declared in outer scopes.</p>
<span id="Lis2-10"/>
<pre><code>int <b>j</b>;  // file scope of <b>j</b> begins

void f(int <b>i</b>) {         // block scope of <b>i</b> begins
  int <b>j</b> = 1;            // block scope of <b>j</b> begins; hides file-scope <b>j</b>
  i++;                  // <b>i</b> refers to the function parameter
  for (int <b>i</b> = 0; <b>i</b> &lt; 2; i++) {  // block scope of loop-local <b>i</b> begins
    int <b>j</b> = 2;          // block scope of the inner <b>j</b> begins; hides outer <b>j</b>
    printf("%d\n", <b>j</b>);  // inner <b>j</b> is in scope, prints 2
  }                     // block scope of the inner <b>i</b> and <b>j</b> ends
  printf("%d\n", j);    // the outer <b>j</b> is in scope, prints 1
}  // the block scope of <b>i</b> and <b>j</b> ends

void g(int <b>j</b>);          // <b>j</b> has function prototype scope; hides file-scope <b>j</b></code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Identifiers declared in inner scopes hiding identifiers declared in outer scopes</samp></p>
<p class="TX">There is nothing wrong with this code, provided the comments accurately describe your intent. However, it’s better to use different names for different identifiers to avoid confusion, which leads to bugs. Using short names such as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is fine for identifiers with small scopes. Identifiers in large scopes should have longer, descriptive names that are unlikely to be hidden in nested scopes. Some compilers will warn about hidden identifiers.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">

<h2 class="H1" id="sec25"><span id="h1-20"/><samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp></h2>
<p class="TNI">Objects have a storage duration that determines their lifetime. Four storage durations are available: automatic, static, thread, and allocated. You’ve already seen that objects declared within a block or as a function parameter have automatic storage duration. The lifetime of these objects starts when the block in which they’re declared begins execution and ends when execution of this block completes. If the block is entered recursively, a new object is created each time the block is entered, and each object has its own storage.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Scope and lifetime are entirely different concepts. Scope applies to identifiers, whereas lifetime applies to objects. The scope of an identifier is the code region where the object denoted by the identifier can be accessed by its name. The lifetime of an object is the period for which the object exists.</i></p>
<p class="TX">Objects declared in file scope have <i>static</i> storage duration. The lifetime of those objects is the entire execution of the program, and their stored value is initialized prior to program startup.</p>
<p class="TX"><i>Thread</i> storage duration is used in concurrent programming and is not covered in this book. <i>Allocated</i> storage duration involves dynamically allocated <span aria-label="36" epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/>memory and is discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Finally, as described in the next section, a storage-class specifier can determine or influence storage duration.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h2 class="H1" id="sec26"><span id="h1-21"/><samp class="SANS_Futura_Std_Bold_B_11">Storage Class</samp></h2>
<p class="TNI">You can specify the storage class of an object or functions using storage-class specifiers. For C23, these include <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class specifier is new in C23, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage-class specifier is significantly changed.</p>
<p class="TX">Storage-class specifiers specify various properties of identifiers and declared features:</p>
<ul class="ul">
<li class="ListBullet">Storage duration: <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> in block scope, <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp></li>
<li class="ListBullet">Linkage: <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> in file scope, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp></li>
<li class="ListBullet">Value: <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp></li>
<li class="ListBullet">Type: <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp></li>
</ul>
<p class="TX">With a few exceptions, only one storage-class specifier is allowed for each declaration. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> may appear with all the others except <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.</p>
<section aria-labelledby="sec27" epub:type="division">

<h3 class="H2" id="sec27"><span id="h2-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">static</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class specifier is used to specify both storage duration and linkage.</p>
<p class="TX">File scope identifiers specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, or functions specified as static, have <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp> linkage.</p>
<p class="TX">You can also declare a variable with block scope to have static storage duration by using the storage-class specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, as shown in the counting example in <a href="chapter2.xhtml#Lis2-11">Listing 2-11</a>. These objects persist after the function has exited.</p>
<span id="Lis2-11"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void increment(void) {
  static unsigned int counter = 0;
  counter++;
  printf("%d ", counter);
}

int main() {
  for (int i = 0; i &lt; 5; i++) {
    increment();
  }
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: A counting example</samp></p>
<p class="TX"><span aria-label="37" epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>This program outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3 4 5</samp>. The static variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is initialized to 0 once at program startup and incremented each time the <samp class="SANS_TheSansMonoCd_W5Regular_11">increment</samp> function is called. The lifetime of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is the entire execution of the program, and it will retain its last-stored value throughout its lifetime. You could achieve the same behavior by declaring <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> with file scope. However, it’s good software engineering practice to limit the scope of an object whenever possible.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">

<h3 class="H2" id="sec28"><span id="h2-25"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">extern</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier specifies static storage duration and external linkage. It can be used with function and object declarations in both file and block scope (but not function parameter lists). If <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> is specified for the redeclaration of an identifier that has already been declared with internal linkage, the linkage remains internal. Otherwise (if the prior declaration was external, has no linkage, or is not in scope), the linkage is external.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">

<h3 class="H2" id="sec29"><span id="h2-26"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">thread_local</samp></h3>
<p class="TNI">An object whose identifier is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp> storage-class specifier has <i>thread storage duration</i>. Its initializer is evaluated prior to program execution, its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized with the previously determined value when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. (The topic of threading is beyond the scope of this book.)</p>
</section>
<section aria-labelledby="sec30" epub:type="division">

<h3 class="H2" id="sec30"><span id="h2-27"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">constexpr</samp></h3>
<p class="TNI">A scalar object declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class specifier is a constant and has its value permanently fixed at translation time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class specifier may appear with <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>. If not already present, a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualification is implicitly added to the object’s type. The resulting object cannot be modified at runtime in any way. The compiler can then use this value in any other constant expression.</p>
<p class="TX">Additionally, the constant expression used for the initializer of such a constant is checked at compile time. Before the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> in C23, a very large object constant might be declared as follows:</p>

<pre><code>static size_t const BFO = 0x100000000;</code></pre>
<p class="TX">The initializer may or may not fit into <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>; a diagnostic is not required. In C23, this same object can be declared using <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> as follows:</p>

<pre><code>constexpr size_t BFO = 0x100000000;</code></pre>
<p class="TX"><span aria-label="38" epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/>Now, a diagnostic is required on implementations where <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> has a width of 32 or less.</p>
<p class="TX">Static objects must be initialized with a constant value and not a variable:</p>

<pre><code>int *func(int i) {
  const int j = i; // ok
  static int k = j; // error
  return &amp;k;
}</code></pre>
<p class="TX">Arithmetic constant expressions are allowed in initializers. Constant values are literal constants (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>), <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> members, a scalar object declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class specifier, and the result of operators such as <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> (provided the operand does not have a variable-length array type). Unfortunately, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified objects are not constant values. Starting with C23, an implementation may accept other forms of constant expressions; it is implementation defined whether they are integer constant expressions.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">

<h3 class="H2" id="sec31"><span id="h2-28"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">register</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> storage-class specifier suggests that access to an object be as fast as possible. The extent to which such suggestions are effective is implementation defined. Frequently, compilers can make better decisions about register allocation and ignore these programmer suggestions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> storage class can be used only for an object that never has its address taken. A compiler can treat any register declaration simply as an <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> declaration. However, whether addressable storage is used, the address of any part of an object declared with a storage-class specifier register cannot be computed, either explicitly by use of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator or implicitly by converting an array name to a pointer.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">

<h3 class="H2" id="sec32"><span id="h2-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">typedef</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> storage-class specifier defines an identifier to be a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> name that denotes the type specified for the identifier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> storage-class specifier was discussed earlier in the <span class="Xref">“Type Definitions” box</span>.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">

<h3 class="H2" id="sec33"><span id="h2-30"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">auto</samp></h3>
<p class="TNI">Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> specifier was allowed only for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.</p>
<p class="TX">C23 introduced type inference into the C language by expanding the definition of the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage-class specifier. Prior to C23, declaring a variable in C requires the user to name a type. However, when the declaration includes an initializer, the type can be derived directly from the type <span aria-label="39" epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>of the expression used to initialize the variable. This has been a C++ feature since 2011.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration class specifier has similar behavior to C++ in that it allows the type to be inferred from the type of the assignment value. Take the following file scope definitions, for example:</p>

<pre><code>static auto a = 3;
auto p = &amp;a;</code></pre>
<p class="TX">Because the integer literal <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> has an implicit type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, these declarations are interpreted as if they had been written as:</p>

<pre><code>static int a = 3;
int * p = &amp;a;</code></pre>
<p class="TX">Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Type inference is extremely useful when implementing or invoking type-generic macros, as we’ll see in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>
</section>
</section>
<section aria-labelledby="sec34" epub:type="division">

<h2 class="H1" id="sec34"><span id="h1-22"/><samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp></h2>
<p class="TNI">C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators can operate on an expression or a type name and yield the type of their operand. If the type of the operand is a variably modified type, the operand is evaluated; otherwise, the operand is not evaluated.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators and the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration class specifier both perform automatic type inference. They can both be used to determine the type of expression.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration class specifier is commonly used to declare initialized variables where the type can be inferred from the initial value. However, to form a derived type, you must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator:</p>

<pre><code>_Atomic(typeof(x)*) apx = &amp;x;</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration class specifier cannot be used with <samp class="SANS_TheSansMonoCd_W5Regular_11">_Generic</samp> (described in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>) and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> (described later in this chapter).</p>
<p class="TX">The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator is the nonatomic, unqualified version of the type that would result from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator preserves all qualifiers.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator, which executes the expression in an unevaluated context to understand the final type. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator anywhere you can use a type name. The following example illustrates the use of both <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators:</p>

<pre><code>#include &lt;stdlib.h&gt;
const _Atomic int asi = 0;
const int si = 1;
<span aria-label="40" epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>const char* const beatles[] = {
    "John",
    "Paul",
    "George",
    "Ringo"
};

<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> typeof_unqual(si) main() {
  <span aria-label="annotation2" class="code_CodeAnnotation">❷</span> typeof_unqual(asi) plain_si;
  <span aria-label="annotation3" class="code_CodeAnnotation">❸</span> typeof(_Atomic <span aria-label="annotation4" class="CodeAnnotation">❹</span> typeof(si)) atomic_si;
  <span aria-label="annotation5" class="code_CodeAnnotation">❺</span> typeof(beatles) beatles_array;
  <span aria-label="annotation6" class="code_CodeAnnotation">❻</span> typeof_unqual(beatles) beatles2_array;
    return EXIT_SUCCESS;
}</code></pre>
<p class="TX">At the first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator <span aria-label="annotation1" class="CodeAnnotation">❶</span>, the operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>, which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier, resulting in just plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. This use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator is illustrative and not meant for production code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator is used again on operand <samp class="SANS_TheSansMonoCd_W5Regular_11">asi</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic int</samp>. All qualifiers are once again stripped, resulting in a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> specifier at <span aria-label="annotation3" class="CodeAnnotation">❸</span> includes another <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> specifier. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operand is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> specifier, the operand is evaluated before evaluating the current <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator. This evaluation happens recursively until a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> specifier is no longer the operand. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> specifier at <span aria-label="annotation3" class="CodeAnnotation">❸</span> does nothing and can be omitted. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator at <span aria-label="annotation4" class="CodeAnnotation">❹</span> is evaluated before the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator at <span aria-label="annotation3" class="CodeAnnotation">❸</span> and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator at <span aria-label="annotation3" class="CodeAnnotation">❸</span> is now evaluated and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator at <span aria-label="annotation5" class="CodeAnnotation">❺</span> returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp> pointers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator at <span aria-label="annotation6" class="CodeAnnotation">❻</span> strips the qualifier and returns an array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp> pointers. The qualifiers, in this case, are stripped only from the array and not the element types the array contains.</p>
<p class="TX">The following <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function is equivalent but doesn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators:</p>

<pre><code>int main() {
  int plain_si;
  const _Atomic int atomic_si;
  const char* const beatles_array[4];
  const char* beatles2_array[4];
  return EXIT_SUCCESS;
}</code></pre>
<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator to refer to a macro parameter to construct objects with the required types without specifying the type names explicitly as macro arguments.</p>
</section>
<section aria-labelledby="sec35" epub:type="division">
<span aria-label="41" epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>
<h2 class="H1" id="sec35"><span id="h1-23"/><samp class="SANS_Futura_Std_Bold_B_11">Alignment</samp></h2>
<p class="TNI">Object types have alignment requirements that place restrictions on the addresses at which objects of that type may be allocated. An <i>alignment</i> represents the number of bytes between successive addresses at which a given object can be allocated. Central processing units (CPUs) may have different behavior when accessing aligned data (for example, where the data address is a multiple of the data size) versus unaligned data.</p>
<p class="TX">Some machine instructions can perform multibyte accesses on nonword boundaries, but with a performance penalty. A <i>word</i> is a natural, fixed-sized unit of data handled by the instruction set or the hardware of the processor. Some platforms cannot access unaligned memory. Alignment requirements may depend on the CPU word size (typically, 16, 32, or 64 bits).</p>
<p class="TX">Generally, C programmers need not concern themselves with alignment requirements, because the compiler chooses suitable alignments for its various types. However, on rare occasions, you might need to override the compiler’s default choices—for example, to align data on the boundaries of the memory cache lines that must start at power-of-two address boundaries or to meet other system-specific requirements. Traditionally, these requirements were met by linker commands or similar operations involving other nonstandard facilities.</p>
<p class="TX">C11 introduced a simple, forward-compatible mechanism for specifying alignments. Alignments are represented as values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>. Every valid alignment value is a nonnegative integral power of two. An object type imposes a default alignment requirement on every object of that type: a stricter alignment (a larger power of two) can be requested using the alignment specifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>). You can include an alignment specifier in a declaration. <a href="chapter2.xhtml#Lis2-12">Listing 2-12</a> uses the alignment specifier to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> is properly aligned (<samp class="SANS_TheSansMonoCd_W5Regular_11">bad_buff</samp> may have incorrect alignment for member-access expressions).</p>
<span id="Lis2-12"/>
<pre><code>struct S {
  double d; int i; char c;
};

int main() {
  unsigned char bad_buff[sizeof(struct S)];
  alignas(struct S) unsigned char good_buff[sizeof(struct S)];
  struct S *bad_s_ptr = (struct S *)bad_buff;
  struct S *good_s_ptr = (struct S *)good_buff; // correct alignment
  good_s_ptr-&gt;i = 12;
  return good_s_ptr-&gt;i;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Use of the</samp> <samp class="I">alignas</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">keyword</samp></p>
<p class="TX">Although <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> has proper alignment to be accessed through an lvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct S</samp>, this program still has undefined behavior. This undefined behavior stems from the underlying object <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> being <span aria-label="42" epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/>declared as an array of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and being accessed through an lvalue of a different type. The cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">(struct S *)</samp>, like any pointer cast, doesn’t change the effective type of the storage allocated to each array. Because it is an established practice to use areas of character type for low-level storage management, I co-authored a paper to make such code conforming in a future revision of the C standard (Seacord et al. 2024).</p>
<p class="TX">Alignments are ordered from weaker to stronger (also called <i>stricter</i>) alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any valid, weaker alignment requirement.</p>
<p class="TX">Alignment of dynamically allocated memory is covered in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>
</section>
<section aria-labelledby="sec36" epub:type="division">

<h2 class="H1" id="sec36"><span id="h1-24"/><samp class="SANS_Futura_Std_Bold_B_11">Variably Modified Types</samp></h2>
<p class="TNI">Variably modified types (VMTs) define a base type and an extent (number of elements), which is determined at runtime. VMTs are a mandatory feature of C23.</p>
<p class="TX">VMTs can be used as function parameters. Remember from earlier in this chapter that, when used in an expression, an array is converted to a pointer to the first element of the array. This means that we must add an explicit parameter to specify the size of the array—for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> parameter in the signature for <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>:</p>

<pre><code>void *memset(void *s, int c, size_t n);</code></pre>
<p class="TX">When you call such a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> should accurately represent the size of the array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>. Undefined behavior results if this size is larger than the array.</p>
<p class="TX">When declaring a function to take an array as an argument that specifies a size, we must declare the size of the array before referencing the size in the array declaration. We could, for example, modify the signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function as follows to take the number of elements <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> and an array of at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> elements:</p>

<pre><code>void *memset_vmt(size_t n, char s[n], int c);</code></pre>
<p class="TX">For arrays of character type, the number of elements is equal to the size. In this function signature, <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp> is a variably modified type because <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp> depends on the runtime value of <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>.</p>
<p class="TX">We’ve changed the order of the parameters so that the size parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is declared before we use it in the array declaration. The array argument <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is still adjusted to a pointer, and no storage is allocated because of this declaration (except for the pointer itself). When calling this function, you must declare the actual storage for the array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is a valid size for it. Just like a non-VMT parameter, the actual array storage may be a fixed-size array, variable-length array (covered in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>), or dynamically allocated storage.</p>
<p class="TX"><span aria-label="43" epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/>VMTs can generalize your functions, making them more useful. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> function sums all the values in a two-dimensional array. The following version of this function accepts a matrix with a fixed column size:</p>

<pre><code>int matrix_sum(size_t rows, int m[][4]);</code></pre>
<p class="TX">When passing a multidimensional array to a function, the number of elements in the initial dimension of the array (the rows) is lost and needs to be passed in as an argument. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp> parameter provides this information in this example. You can call this function to sum the values of any matrix with exactly four columns, as shown in <a href="chapter2.xhtml#Lis2-13">Listing 2-13</a>.</p>
<span id="Lis2-13"/>
<pre><code>int main(void) {
  int m1[5][4];
  int m2[100][4];
  int m3[2][4];
  printf("%d.\n", matrix_sum(5, m1));
  printf("%d.\n", matrix_sum(100, m2));
  printf("%d.\n", matrix_sum(2, m3));
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Summing matrices with four columns</samp></p>
<p class="TX">This is fine until you need to sum the values of a matrix that does not have four columns. For example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">m3</samp> to have five columns would result in a warning such as this:</p>

<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">warning: incompatible pointer types passing 'int [2][5]' to parameter of type 'int (*)[4]'</samp></code></pre>
<p class="TX">To accept this argument, you would have to write a new function with a signature that matches the new dimensions of the multidimensional array. The problem with this approach, then, is that it fails to generalize sufficiently.</p>
<p class="TX">Instead of doing that, we can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> function to use a VMT, as shown in <a href="chapter2.xhtml#Lis2-14">Listing 2-14</a>. This change allows us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> with matrices of any dimension.</p>
<span id="Lis2-14"/>
<pre><code>int matrix_sum(size_t rows, size_t cols, int m[rows][cols]) {
  int total = 0;

  for (size_t r = 0; r &lt; rows; r++)
    for (size_t c = 0; c &lt; cols; c++)
      total += <span aria-label="annotation1" class="CodeAnnotation">❶</span> m[r][c];
  return total;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Using a VMT as a function parameter</samp></p>
<p class="TX"><span aria-label="44" epub:type="pagebreak" id="pg_44" role="doc-pagebreak"/>The compiler performs the matrix indexing <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Without VMTs, this would require either manual indexing or double indirection, which are both error prone.</p>
<p class="TX">Again, no storage is allocated by either the function declaration or the function definition. As with a non-VMT parameter, you need to allocate the storage for the matrix separately, and its dimensions must match those passed to the function as the <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cols</samp> arguments. Failing to do so can result in undefined behavior.</p>
</section>
<section aria-labelledby="sec37" epub:type="division">

<h2 class="H1" id="sec37"><span id="h1-25"/><samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp></h2>
<p class="TNI">Starting with C23, you can use <i>attributes</i> to associate additional information with a declaration, statement, or type. This information can be used by the implementation to improve diagnostics, improve performance, or modify the behavior of the program in other ways. A comma-delimited list of zero or more attributes is specified within a pair of double square brackets, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo]]</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo, bar]]</samp>.</p>
<p class="TX">Declarations attributes are specified in two ways. If the attribute specifier is at the start of a declaration, the attributes are applied to all declarations in the declaration group. Otherwise, the attributes are applied to the declaration to the immediate left of the attribute specifier. For example, in the following declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> attribute is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>:</p>

<pre><code>[[foo]] int x, y, *z;</code></pre>
<p class="TX">While in the second declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> attributes are applied only to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>:</p>

<pre><code>int a, b [[foo, bar]], *c;</code></pre>
<p class="TX">C23 defines several attributes that apply to declarations, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp> attribute is used with function declarations to denote that the value returned by the function is expected to be used within an expression or initializer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp> attribute is used with the declaration of a function or a type to denote that use of the function or type should be diagnosed as discouraged.</p>
<p class="TX">In addition to standard attributes, the implementation may provide nonportable attributes. Such attributes are also specified within double square brackets, but they include a vendor prefix to distinguish between attributes from different vendors. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[clang::overloadable]]</samp> attribute is used on a function declaration to specify that it can use C++-style function overloading in C, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[gnu::packed]]</samp> attribute is used on a structure declaration to specify that the member declarations of the structure should avoid using padding between member declarations whenever possible for a more space-efficient layout. Vendors typically use their own prefixes, and they may use whatever prefixes they choose. For example, Clang implements many attributes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gnu</samp> prefix for improved <span aria-label="45" epub:type="pagebreak" id="pg_45" role="doc-pagebreak"/>compatibility with GCC. Your compiler should ignore unknown attributes, although they may still be diagnosed so you know that the attribute has no effect. Refer to your compiler’s documentation for the full list of supported attributes.</p>
<aside aria-label="box-4" class="box1">
<p class="BoxTitle" id="box-4"><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISES</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">1.  Add a retrieve function to the counting example from <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a> to retrieve the current value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">2.  Declare an array of three pointers to functions and invoke the appropriate function based on an index value passed in as an argument.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">3.  Repair the following program with the appropriate use of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> <samp class="SANS_Futura_Std_Book_11">type qualifier:</samp></p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;setjmp.h&gt;

static jmp_buf buf;

int main() {
  int foo = 5;
  if (setjmp(buf) != 2) {
    if (foo != 5) {puts("hi"); longjmp(buf, 2);}
    foo = 6;
    longjmp(buf, 1);
  }
  return EXIT_SUCCESS;
}</code></pre>
<p class="BoxList"><samp class="SANS_Futura_Std_Book_11">Hint: The problem may only manifest for optimized builds.</samp></p>
</aside>
</section>
<section aria-labelledby="sec38" epub:type="division">

<h2 class="H1" id="sec38"><span id="h1-26"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about objects and functions and how they differ. You learned how to declare objects and functions, take the addresses of objects, and dereference those object pointers. You also learned about most of the object types available to C programmers as well as derived types.</p>
<p class="TX">We’ll return to these types in later chapters to further explore how they can be best used to implement your designs. In the next chapter, I provide detailed information about the two kinds of arithmetic types: integers and floating-point.</p>
</section>
</section>
</body></html>