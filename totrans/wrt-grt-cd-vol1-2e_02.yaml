- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BINARY ARITHMETIC AND BIT OPERATIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As [Chapter 2](ch02.xhtml#ch02) explained, understanding how computers represent
    data in binary is a prerequisite to writing software that works well on them.
    Of equal importance is understanding how computers operate on binary data. That’s
    the focus of this chapter, which explores arithmetic, logical, and bit operations
    on binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1 Arithmetic Operations on Binary and Hexadecimal Numbers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you need to manually operate on two binary (or hexadecimal) values in
    order to use the result in your source code. Although there are calculators that
    can compute such results, you should be able to perform simple arithmetic operations
    on binary operands by hand. Hexadecimal arithmetic is sufficiently painful that
    a hexadecimal calculator (or a software-based calculator that supports hexadecimal
    operations, such as the Windows calculator, or a smartphone app) belongs on every
    programmer’s desk. Arithmetic operations on binary values, however, are easier
    than decimal arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to manually compute binary arithmetic results is essential because
    several important algorithms use these operations (or variants of them). This
    section describes how to manually add, subtract, multiply, and divide binary values,
    and how to perform various logical operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.1.1 Adding Binary Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding two binary values is easy; there are only eight rules to learn:^([1](footnotes.xhtml#fn3_1a))
  prefs: []
  type: TYPE_NORMAL
- en: 0 + 0 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 + 1 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 + 0 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 + 1 = 0 with carry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carry + 0 + 0 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carry + 0 + 1 = 0 with carry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carry + 1 + 0 = 0 with carry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carry + 1 + 1 = 1 with carry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you know these eight rules, you can add any two binary values together.
    Here’s a step-by-step example of binary addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '***3.1.2 Subtracting Binary Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like addition, binary subtraction has eight rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 – 0 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 – 1 = 1 with a borrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – 0 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – 1 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 – 0 – borrow = 1 with a borrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 – 1 – borrow = 0 with a borrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – 0 – borrow = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – 1 – borrow = 1 with a borrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step example of binary subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '***3.1.3 Multiplying Binary Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Multiplication of binary numbers is simple; it follows the same rules as decimal
    multiplication involving only 0s and 1s:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 × 0 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 × 1 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 × 0 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 × 1 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step example of binary multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '***3.1.4 Dividing Binary Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Binary division uses the same (longhand) division algorithm as decimal division.
    [Figure 3-1](ch03.xhtml#ch03fig01) shows the steps in a decimal division problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Decimal division (3456/12)*'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is easier in binary because at each step you don’t have to guess
    how many times 12 goes into the remainder or multiply 12 by your guess to obtain
    the amount to subtract. At each step in the binary algorithm, the divisor goes
    into the remainder exactly zero or one times. For example, consider the division
    of 27 (11011) by 3 (11) shown in [Figure 3-2](ch03.xhtml#ch03fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Longhand division in binary*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2 Logical Operations on Bits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four main logical operations we’ll need to perform on hexadecimal
    and binary numbers: AND, OR, XOR (exclusive-or), and NOT. In contrast to the arithmetic
    operations, a hexadecimal calculator isn’t necessary to perform these operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical AND, OR, and XOR operations accept two single-bit operands and
    compute the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Tables 3-1](ch03.xhtml#ch03tab01), [3-2](ch03.xhtml#ch03tab02), and [3-3](ch03.xhtml#ch03tab03)
    show the *truth tables* for the AND, OR, and XOR operations, respectively. A truth
    table is just like the multiplication tables you encountered in elementary school.
    The values in the left column correspond to the left operand of the operation.
    The values in the top row correspond to the right operand. The result is at the
    intersection of the row and column (for a particular pair of operands).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** AND Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| AND | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '**Table 3-2:** OR Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| OR | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '**Table 3-3:** XOR Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| XOR | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: In plain English, the logical AND operation translates as, “If the first operand
    is 1 and the second operand is 1, the result is 1; otherwise the result is 0.”
    We could also state this as “If either or both operands are 0, the result is 0.”
    The logical AND operation is useful for forcing a 0 result. If one of the operands
    is 0, the result is 0 regardless of the value of the other operand. If one of
    the operands contains 1, then the result is the value of the other operand.
  prefs: []
  type: TYPE_NORMAL
- en: Colloquially, the logical OR operation is, “If the first operand or the second
    operand (or both) is 1, the result is 1; otherwise the result is 0.” This is also
    known as the *inclusive*-*OR* operation. If one of the operands to the logical-OR
    operation is 1, the result is 1\. If an operand is 0, the result is the value
    of the other operand.
  prefs: []
  type: TYPE_NORMAL
- en: In English, the logical XOR operation is, “If the first or second operand, but
    not both, is 1, the result is 1; otherwise, the result is 0.” If one of the operands
    is a 1, the result is the *[inverse](gloss01.xhtml#gloss01_126)* of the other
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: The logical NOT operation is *unary* (meaning it accepts only one operand).
    [Table 3-4](ch03.xhtml#ch03tab04) is the truth table for the NOT operation. This
    operator inverts the value of its operand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-4:** NOT Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| NOT | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '**3.3 Logical Operations on Binary Numbers and Bit Strings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because most programming languages manipulate groups of 8, 16, 32, or 64 bits,
    we need to extend the definition of these logical operations beyond single-bit
    operands to operate on a bit-by-bit (or *[bitwise](gloss01.xhtml#gloss01_33)*)
    basis. Given two values, a bitwise logical function operates on bit 0 from both
    source operands, producing bit 0 in the result operand; it operates on bit 1 of
    both operands, producing bit 1 of the result; and so on. For example, if you want
    to compute the bitwise logical AND of two 8-bit numbers, you would logically AND
    each pair of bits in the two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This bit-by-bit execution applies to the other logical operations as well. The
    ability to force bits to `0` or `1` using the logical AND and OR operations, and
    to invert bits using the logical XOR operation, is very important when you’re
    working with strings of bits (such as binary numbers). These operations let you
    selectively manipulate certain bits within a value while leaving other bits unaffected.
    For example, if you have an 8-bit binary value *X* and you want to guarantee that
    bits 4 through 7 contain `0`s, AND the value *X* with the binary value `%0000_1111`.
    This bitwise AND operation forces the HO 4 bits of *X* to `0` and leaves the LO
    4 bits of *X* unchanged. Likewise, you could force the LO bit of *X* to `1` and
    invert bit number 2 of *X* by ORing *X* with `%0000_0001` and then exclusive-ORing
    (XORing) *X* with `%0000_0100`.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating bit strings with the logical AND, OR, and XOR operations is known
    as *masking*. This term originates from the fact that we can use certain values
    (`1` for AND, `0` for OR and XOR) to “mask out” or “mask in” certain bits in an
    operand while forcing other bits to `0`, `1`, or their inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several languages provide operators that let you compute the bitwise AND, OR,
    XOR, and NOT of their operands. The C/C++/Java/Swift language family uses the
    ampersand (`&`) for bitwise AND, the pipe (`|`) for bitwise OR, the caret (`^`)
    for bitwise XOR, and the tilde (`~`) for bitwise NOT, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Visual Basic and Free Pascal/Delphi languages let you use the `and`, `or`,
    `xor`, and `not` operators with integer operands. From 80x86 assembly language,
    you can use the `AND`, `OR`, `NOT`, and `XOR` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4 Useful Bit Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although bit operations may seem a bit abstract, they are quite useful for many
    non-obvious purposes. This section describes some of their useful properties in
    various languages.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.4.1 Testing Bits in a Bit String Using AND***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the bitwise AND operator to test individual bits in a bit string
    to see if they are `0` or `1`. If you logically AND a value with a bit string
    that contains a `1` in a certain bit position, the result of the AND will be `0`
    if the corresponding bit contains a `0`, and nonzero if that bit position contains
    `1`. Consider the following C/C++ code, which checks an integer value to see if
    it is odd or even by testing bit 0 of the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In binary form, here’s what this bitwise AND operation is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is `0` if the LO bit of ValueToTest contains a `0` in bit position
    0\. The result is `1` if ValueToTest contains a `1` in bit position 1\. This calculation
    ignores all other bits in ValueToTest.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.4.2 Testing a Set of Bits for Zero/Not Zero Using AND***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also use the bitwise AND operator to see if all bits in a set are `0`.
    For example, one way to check if a number is evenly divisible by 16 is to see
    if the LO 4 bits are all `0`s. The following Free Pascal/Delphi statement uses
    the bitwise AND operator to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In binary form, here’s what this bitwise AND operation is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result is `0` if and only if the LO 4 bits of `ValueToTest` are all `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '***3.4.3 Comparing a Set of Bits Within a Binary String***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The AND and OR operations are particularly useful if you need to compare a subset
    of the bits in a binary value against some other value. For example, you might
    want to compare two 6-bit values found in bits 0, 1, 10, 16, 24, and 31 of a pair
    of 32-bit values. The trick is to set all the uninteresting bits to `0` and then
    compare the two results.^([2](footnotes.xhtml#fn3_2a))
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following three binary values; `x` denotes bits whose values we
    don’t care about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and second binary values (assuming we’re interested only in bits
    31, 24, 16, 10, 1, and 0) are equal. If we compare either of the first two values
    against the third value, we’ll find that they are not equal. The third value is
    also greater than the first two. In C/C++ and assembly, this is how we could compare
    these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***3.4.4 Creating Modulo-*n *Counters Using AND***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A [*modulo-*n *counter*](gloss01.xhtml#gloss01_164) counts from 0^([3](footnotes.xhtml#fn3_3a))
    to some maximum value and then resets to 0\. Modulo-*n* counters are great for
    creating repeating sequences of numbers such as 0, 1, 2, 3, 4, 5, . . . *n* –
    1; 0, 1, 2, 3, 4, 5, . . . *n* – 1; 0, 1, . . . . You can use such sequences to
    create circular queues and other objects that reuse array elements upon encountering
    the end of the data structure. The normal way to create a modulo-*n* counter is
    to add 1 to the counter, divide the result by *n*, and then keep the remainder.
    The following code examples demonstrate the implementation of a modulo-*n* counter
    in C/C++, Pascal, and Visual Basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, division is an expensive operation, requiring far more time to execute
    than addition. In general, you’ll find it more efficient to implement modulo-*n*
    counters using a comparison rather than the remainder operator. Here’s a Pascal
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For certain special cases, when *n* is a power of 2, you can increment a modulo-*n*
    counter more efficiently and conveniently using the AND operation. To do so, increment
    your counter and then logically AND it with the value *x* = 2^(*m*) – 1 (2^(*m*)
    – 1 contains `1`s in bit positions 0..*m* – 1, and `0`s everywhere else). Because
    the AND operation is much faster than division, AND-driven modulo-*n* counters
    are much more efficient than those using the remainder operator. On most CPUs,
    using the AND operator is quite a bit faster than using an `if` statement. The
    following examples show how to implement a modulo-*n* counter for *n* = 32 using
    the AND operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The assembly language code is especially efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5 Shifts and Rotates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another set of logical operations on bit strings are the *shift* and *rotate*
    operations. These functions can be further broken down into *shift lefts*, *rotate
    lefts*, *shift rights*, and *rotate rights*. These operations are very useful
    in many programs.
  prefs: []
  type: TYPE_NORMAL
- en: The shift left operation moves each bit in a bit string one position to the
    left, as shown in [Figure 3-3](ch03.xhtml#ch03fig03). Bit 0 moves into bit position
    1, the previous value in bit position 1 moves into bit position 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Shift left operation (on a byte)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking two questions: “What goes into bit 0?” and “Where does
    the HO bit wind up?” We’ll shift a `0` into bit 0, and the previous value of the
    HO bit will be the *carry* out of this operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several high-level languages (such as C/C++/C#, Swift, Java, and Free Pascal/Delphi)
    provide a shift left operator. In the C language family, this operator is `<<`.
    In Free Pascal/Delphi, you use the `shl` operator. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Shifting the binary representation of a number one position to the left is
    equivalent to multiplying that value by 2\. If you’re using a programming language
    that doesn’t provide an explicit shift left operator, you can simulate this by
    multiplying a binary integer value by 2\. Although the multiplication operation
    is usually slower than the shift left operation, most compilers are smart enough
    to translate a multiplication by a constant power of 2 into a shift left operation.
    Therefore, you could write code like the following in Visual Basic to do a shift
    left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A shift right operation is similar to a shift left, except we move the data
    in the opposite direction. Bit 7 moves into bit 6, bit 6 moves into bit 5, bit
    5 moves into bit 4, and so on. During a shift right, we’ll move a `0` into bit
    7, and bit 0 will be the carry out of the operation (see [Figure 3-4](ch03.xhtml#ch03fig04)).
    C, C++, C#, Swift, and Java use the `>>` operator for a shift right operation.
    Free Pascal/Delphi uses the `shr` operator. Most assembly languages also provide
    a shift right instruction (`shr` on the 80x86).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: The shift right operation (on a byte)*'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting an unsigned binary value one position to the right divides that value
    by 2\. For example, if you shift the unsigned representation of 254 (`$FE`) one
    place to the right, you get 127 (`$7F`), exactly as you’d expect. However, if
    you shift the 8-bit two’s complement binary representation of –2 (`$FE`) one position
    to the right, you get 127 (`$7F`), which is *not* correct. To divide a signed
    number by 2 using a shift, we use a third shift operation, *arithmetic shift right*,
    which doesn’t modify the value of the HO bit. [Figure 3-5](ch03.xhtml#ch03fig05)
    shows the arithmetic shift right operation for an 8-bit operand.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: Arithmetic shift right operation (on a byte)*'
  prefs: []
  type: TYPE_NORMAL
- en: This generally produces the result you expect for two’s complement signed operands.
    For example, if you perform the arithmetic shift right operation on –2 (`$FE`),
    you get –1 (`$FF`). Note, however, that this operation always rounds the numbers
    to the closest integer that is *less than or equal to the actual result*. If you
    arithmetically shift right –1 (`$FF`), the result is –1, not 0\. Because –1 is
    less than 0, the arithmetic shift right operation rounds toward –1\. This is not
    a “bug” in the arithmetic shift right operation; it just uses a different (though
    valid) definition of integer division. The bottom line is that you probably won’t
    be able to use a signed division operator as a substitute for arithmetic shift
    right in languages that don’t support arithmetic shift right, because most integer
    division operators round toward 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s rare for a high-level language to support both the logical shift right
    and the arithmetic shift right. Worse still, the specifications for certain languages
    leave it up to the compiler’s implementer to decide whether to use an arithmetic
    shift right or a logical shift right operation. Therefore, it’s only safe to use
    the shift right operator on values whose HO bit will cause both forms of the shift
    right operation to produce the same result. To guarantee that a shift right is
    a logical shift right or an arithmetic shift right operation, you’ll either have
    to drop down into assembly language or handle the HO bit manually. The high-level
    code gets ugly really fast, so a quick inline assembly statement might be a better
    solution if your program doesn’t need to be portable across different CPUs. The
    following code demonstrates how to simulate a 32-bit logical shift right and arithmetic
    shift right in languages that don’t guarantee the type of shift they use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Many assembly languages also provide various rotate instructions that circulate
    bits through an operand by taking the bits shifted out of one end of the operand
    and shifting them into the other end. Few high-level languages provide this operation;
    fortunately, you won’t need it very often. If you do, you can synthesize this
    operation using the shift operators available in your high-level language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the type of shift and rotate operations that are possible,
    consult *The Art of Assembly Language* (No Starch Press).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.6 Bit Fields and Packed Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CPUs generally operate most efficiently on byte, word, double-word and quad-word
    data types,^([4](footnotes.xhtml#fn3_4a)) but occasionally you’ll need to work
    with a data type whose size is something other than 8, 16, 32, or 64 bits. In
    such cases, you may be able to save some memory by *packing* different strings
    of bits together as compactly as possible, without wasting any bits to align a
    particular data field on a byte or other boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a date of the form 04/02/01\. It takes three numeric values to represent
    this date: month, day, and year. Months use the values 1 through 12, which require
    at least 4 bits to represent. Days use the range 1 through 31, which take 5 bits
    to represent. The year value, assuming that we’re working with values in the range
    0 through 99, requires 7 bits. The total of 4 + 5 + 7 is 16 bits, or 2 bytes.
    We can pack our date data into 2 bytes rather than the 3 that would be required
    if we used a separate byte for each of the values. This saves 1 byte of memory
    for each date stored, which could be a substantial saving if you need to store
    many dates. You might arrange the bits as shown in [Figure 3-6](ch03.xhtml#ch03fig06).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: Short packed date format (16 bits)*'
  prefs: []
  type: TYPE_NORMAL
- en: '`MMMM` represents the 4 bits that hold the month value, `DDDDD` the 5 bits
    that hold the day, and `YYYYYYY` the 7 bits that hold the year. Each collection
    of bits representing a data item is a *bit field*. We could represent April 2,
    2001, with `$4101`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although packed values are space efficient (that is, they use little memory),
    they are computationally inefficient (slow!). The reason? It takes extra instructions
    to unpack the data from the various bit fields. These extra instructions take
    time to execute (and additional bytes to hold the instructions); hence, you must
    carefully consider whether packed data fields will save you anything. The following
    sample HLA/x86 code demonstrates packing and unpacking this 16-bit date format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Keeping in mind the Y2K^([5](footnotes.xhtml#fn3_5a)) problem, adopting a date
    format that supports only a two-digit year is rather foolish. Consider the better
    date format shown in [Figure 3-7](ch03.xhtml#ch03fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: Long packed date format (32 bits)*'
  prefs: []
  type: TYPE_NORMAL
- en: Because there are more bits in a 32-bit variable than are needed to hold the
    date, even accounting for years in the range 0 through 65,535, this format allots
    a full byte for the `month` and `day` fields. An application can manipulate these
    two fields as byte objects, reducing the overhead to pack and unpack these fields
    on processors that support byte access. This leaves fewer bits for the year, but
    65,536 years is probably sufficient (it’s a safe bet that your software won’t
    be in use 63,000 years from now).
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that this is no longer a packed date format. After all, we needed
    three numeric values, two of which fit just nicely into 1 byte each and one that
    should have at least 2 bytes. This “packed” date format consumes the same 4 bytes
    as the unpacked version, not the fewest bits possible. So, in this example, packed
    effectively means *packaged* or *encapsulated*. By packing the data into a double-word
    variable, the program can treat the date value as a single data value rather than
    as three separate variables. This means that you can often get away with a single
    machine instruction to operate on this data rather than three separate instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference between this long packed date format and the short date
    format in [Figure 3-6](ch03.xhtml#ch03fig06) is that this long date format rearranges
    the `Year`, `Month`, and `Day` fields. This allows you to easily compare two dates
    using an unsigned integer comparison. Consider the following HLA/assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Had you kept the different date fields in separate variables or organized the
    fields differently, you wouldn’t have been able to compare `Date1` and `Date2`
    in such a straightforward way. Even if you don’t realize any space savings, packing
    data can make certain computations more convenient or even more efficient (contrary
    to what normally happens when you pack data).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some high-level languages provide built-in support for packed data. For example,
    in C you can define structures like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This structure specifies that each field is an unsigned object that holds 4,
    8, 4, 8, and 8 bits, respectively. The `:`n item after each declaration specifies
    the *minimum* number of bits the compiler will allocate for the given field.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it isn’t possible to show how a C/C++ compiler will allocate
    the values from a 32-bit double word among the fields, because C/C++ compiler
    implementers are free to implement these bit fields any way they see fit. The
    arrangement of the bits within the bit string is arbitrary (for example, the compiler
    could allocate the `bits0_3` field in bits 28 through 31 of the ultimate object).
    The compiler can also inject extra bits between fields, or use a larger number
    of bits for each field (which is actually the same thing as injecting extra padding
    bits between fields). Most C compilers attempt to minimize extraneous padding,
    but compilers (especially on different CPUs) do vary. Therefore, C/C++ struct
    bit field declarations are almost guaranteed to be nonportable, and you can’t
    really count on what the compiler is going to do with those fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the compiler’s built-in data-packing capabilities is
    that the compiler automatically packs and unpacks the data for you. Given the
    following C/C++ code, the compiler would automatically emit the necessary machine
    instructions to store and retrieve the individual bit fields for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**3.7 Packing and Unpacking Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The advantage of packed data types is efficient memory use. Consider the Social
    Security number (SSN) used in the United States, a nine-digit identification code
    in the following form (each `X` represents a single decimal digit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Encoding an SSN using three separate (32-bit) integers takes 12 bytes. That’s
    more than the 11 bytes needed to represent the number using an array of characters.
    A better solution is to encode each field using short (16-bit) integers. Now it
    takes only 6 bytes to represent the SSN. Because the middle field in the SSN is
    always between 0 and 99, we can actually shave one more byte off the size of this
    structure by encoding the middle field with a single byte. Here’s a sample Free
    Pascal/Delphi record structure that defines this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we drop the hyphens in the SSN, the result is a nine-digit number. Because
    we can exactly represent all nine-digit values using 30 bits, we could encode
    any legal SSN using a 32-bit integer. However, some software that manipulates
    SSNs may need to operate on the individual fields. This means using expensive
    division, modulo, and multiplication operators in order to extract fields from
    a SSN you’ve encoded in a 32-bit integer format. Furthermore, converting SSNs
    to and from strings is more complicated when you’re using the 32-bit format.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, it’s easy to insert and extract individual bit fields using fast
    machine instructions, and it’s also less work to create a standard string representation
    (including the hyphens) of one of these fields. [Figure 3-8](ch03.xhtml#ch03fig08)
    shows a straightforward implementation of the SSN packed data type using a separate
    string of bits for each field (note that this format uses 31 bits and ignores
    the HO bit).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8: SSN packed fields encoding*'
  prefs: []
  type: TYPE_NORMAL
- en: Fields that begin at bit position 0 in a packed data object can be accessed
    most efficiently, so you should arrange the fields in your packed data type such
    that the field you access most often^([6](footnotes.xhtml#fn3_6a)) begins at bit
    0\. If you have no idea which field you’ll access most often, assign the fields
    so they begin on a byte boundary. If there are unused bits in your packed type,
    spread them throughout the structure so that individual fields begin on a byte
    boundary and those fields consume multiples of 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got only one unused bit in the SSN example shown in [Figure 3-8](ch03.xhtml#ch03fig08),
    but it turns out that we can use this extra bit to align two fields on a byte
    boundary and ensure that one of those fields occupies a bit string whose length
    is a multiple of 8 bits. Consider [Figure 3-9](ch03.xhtml#ch03fig09), which shows
    a rearranged version of our SSN data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-9: A (possibly) improved encoding of the SSN*'
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the data format in [Figure 3-9](ch03.xhtml#ch03fig09) is that
    we can’t sort SSNs in an intuitive way by comparing 32-bit unsigned integers.^([7](footnotes.xhtml#fn3_7a))
    If you intend to do a lot of sorting based on the entire SSN, the format in [Figure
    3-8](ch03.xhtml#ch03fig08) is probably better.
  prefs: []
  type: TYPE_NORMAL
- en: If this type of sorting isn’t important to you, the format in [Figure 3-9](ch03.xhtml#ch03fig09)
    has some advantages. This packed type actually uses 8 bits (rather than 7) to
    represent `SecondField` (along with moving `SecondField` down to bit position
    0); the extra bit will always contain `0`. This means that `SecondField` consumes
    bits 0 through 7 (a whole byte) and `ThirdField` begins on a byte boundary (bit
    position 8). `ThirdField` doesn’t consume a multiple of 8 bits, and `FirstField`
    doesn’t begin on a byte boundary, but we’ve done fairly well with this encoding,
    considering we only had one extra bit to play around with.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is, “How do we access the fields of this packed type?” There
    are two separate activities here. We need to retrieve, or *extract*, the packed
    fields, and we need to *insert* data into these fields. The AND, OR, and SHIFT
    operations provide the tools for this.
  prefs: []
  type: TYPE_NORMAL
- en: When operating on these fields, it’s convenient to work with three separate
    variables rather than with the packed data directly. For our SSN example, we can
    create the three variables—`FirstField`, `SecondField`, and `ThirdField`—and then
    extract the actual data from the packed value into these three variables, operate
    on the variables, and insert the data from the variables back into their fields
    when we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the `SecondField` data from the packed format shown in [Figure 3-9](ch03.xhtml#ch03fig09)
    (remember, the field aligned to bit 0 is the easiest one to access), copy the
    data from the packed representation to the `SecondField` variable and then mask
    out all but the `SecondField` bits using the AND operation. Because `SecondField`
    is a 7-bit value, the mask is an integer containing `1`s in bit positions 0 through
    6 and `0`s everywhere else. The following C/C++ code demonstrates how to extract
    this field into the `SecondField` variable (assuming packedValue is a variable
    holding the 32-bit packed SSN):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting fields that are not aligned at bit 0 takes a little more work. Consider
    the `ThirdField` entry in [Figure 3-9](ch03.xhtml#ch03fig09). We can mask out
    all the bits associated with the first and second fields by logically ANDing the
    packed value with `%_11_1111_1111_1111_0000_0000` (`$3F_FF00`). However, this
    leaves the `ThirdField` value sitting in bits 8 through 21, which is not convenient
    for various arithmetic operations. The solution is to shift the masked value down
    8 bits so that it’s aligned at bit 0 in our working variable. The following Pascal/Delphi
    code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also shift first and then do the logical AND operation (though this
    requires a different mask, `$11_1111_1111_1111 or $3FFF`). Here’s the C/C++/Swift
    code that extracts `ThirdField` using that technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract a field that is aligned against the HO bit, such as the first field
    in our SSN packed data type, shift the HO field down so that it’s aligned at bit
    0\. The logical shift right operation automatically fills in the HO bits of the
    result with `0`s, so no masking is necessary. The following Pascal/Delphi code
    demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In HLA/x86 assembly language, we can easily access data at any arbitrary byte
    boundary in memory. That allows us to treat both the second and third fields as
    though they are aligned at bit 0 in the data structure. In addition, because the
    `SecondField` value is an 8-bit value (with the HO bit always containing `0`),
    it takes only a single machine instruction to unpack the data, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This instruction fetches the first byte of packedValue (which is the LO 8 bits
    of packedValue on the 80x86) and zero-extends this value to 32 bits in EAX (`movzx`
    stands for “move with zero extension”). The EAX register contains the `SecondField`
    value after this instruction executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThirdField` value from our packed data type isn’t an even multiple of
    8 bits long, so we’ll still need a masking operation to clear the unused bits
    from the 32-bit result we produce. However, because `ThirdField` is aligned on
    a byte (8-bit) boundary in our packed structure, we’ll be able to avoid the shift
    operation that was necessary in the high-level code. Here’s the HLA/x86 assembly
    code that extracts the third field from our packedValue object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting `FirstField` from the packedValue object in HLA/x86 assembly code
    is identical to the high-level code; we’ll simply shift the upper 10 bits (which
    comprise `FirstField`) down to bit 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the data you want to insert appears in some variable and contains `0`s
    in the unused bits, inserting a field into a packed object requires three operations.
    First, if necessary, you shift the field’s data to the left so its alignment matches
    the corresponding field in the packed object. Next, clear the corresponding bits
    in the packed structure, then logically OR the shifted field into the packed object.
    [Figure 3-10](ch03.xhtml#ch03fig10) shows the details of this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-10: Inserting `ThirdField` into the SSN packed type*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the C/C++/Swift code that accomplishes the operation shown in [Figure
    3-10](ch03.xhtml#ch03fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`$FFC000FF` is the hexadecimal value that corresponds to `0`s in bit positions
    8 through 21 and `1`s everywhere else.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.8 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knuth, Donald E. *The Art of Computer Programming, Volume 2: Seminumerical
    Algorithms*. 3rd ed. Boston: Addison-Wesley, 1998.'
  prefs: []
  type: TYPE_NORMAL
