- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: BINARY ARITHMETIC AND BIT OPERATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制算术和位运算**'
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: As [Chapter 2](ch02.xhtml#ch02) explained, understanding how computers represent
    data in binary is a prerequisite to writing software that works well on them.
    Of equal importance is understanding how computers operate on binary data. That’s
    the focus of this chapter, which explores arithmetic, logical, and bit operations
    on binary data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第二章](ch02.xhtml#ch02)所解释的，理解计算机如何以二进制表示数据是编写在计算机上运行良好的软件的前提。与此同样重要的是理解计算机如何处理二进制数据。这是本章的重点，探讨了对二进制数据的算术、逻辑和位运算。
- en: '**3.1 Arithmetic Operations on Binary and Hexadecimal Numbers**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.1 二进制和十六进制数的算术运算**'
- en: Often, you need to manually operate on two binary (or hexadecimal) values in
    order to use the result in your source code. Although there are calculators that
    can compute such results, you should be able to perform simple arithmetic operations
    on binary operands by hand. Hexadecimal arithmetic is sufficiently painful that
    a hexadecimal calculator (or a software-based calculator that supports hexadecimal
    operations, such as the Windows calculator, or a smartphone app) belongs on every
    programmer’s desk. Arithmetic operations on binary values, however, are easier
    than decimal arithmetic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要手动对两个二进制（或十六进制）值进行运算，以便将结果用于你的源代码中。虽然有计算器可以计算这些结果，但你应该能够手动对二进制操作数进行简单的算术运算。十六进制算术相对复杂，因此十六进制计算器（或支持十六进制运算的软件计算器，如
    Windows 计算器或智能手机应用）应该放在每个程序员的桌面上。然而，二进制算术比十进制算术更简单。
- en: Knowing how to manually compute binary arithmetic results is essential because
    several important algorithms use these operations (or variants of them). This
    section describes how to manually add, subtract, multiply, and divide binary values,
    and how to perform various logical operations on them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何手动计算二进制算术结果非常重要，因为许多重要的算法使用这些运算（或其变种）。本节描述了如何手动进行二进制的加法、减法、乘法和除法运算，并执行各种逻辑运算。
- en: '***3.1.1 Adding Binary Values***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.1 二进制值的加法***'
- en: Adding two binary values is easy; there are only eight rules to learn:^([1](footnotes.xhtml#fn3_1a))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个二进制值相加很简单；只需要掌握八条规则：^([1](footnotes.xhtml#fn3_1a))
- en: 0 + 0 = 0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 + 0 = 0
- en: 0 + 1 = 1
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 + 1 = 1
- en: 1 + 0 = 1
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 + 0 = 1
- en: 1 + 1 = 0 with carry
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 + 1 = 0，带进位
- en: Carry + 0 + 0 = 1
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位 + 0 + 0 = 1
- en: Carry + 0 + 1 = 0 with carry
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位 + 0 + 1 = 0，带进位
- en: Carry + 1 + 0 = 0 with carry
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位 + 1 + 0 = 0，带进位
- en: Carry + 1 + 1 = 1 with carry
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进位 + 1 + 1 = 1，带进位
- en: 'Once you know these eight rules, you can add any two binary values together.
    Here’s a step-by-step example of binary addition:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握了这八条规则，你就可以将任意两个二进制值相加。以下是一个逐步的二进制加法示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some more examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些更多的示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***3.1.2 Subtracting Binary Values***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.2 二进制值的减法***'
- en: 'Like addition, binary subtraction has eight rules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法类似，二进制减法有八条规则：
- en: 0 – 0 = 0
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 0 = 0
- en: 0 – 1 = 1 with a borrow
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 1 = 1，借位
- en: 1 – 0 = 1
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – 0 = 1
- en: 1 – 1 = 0
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – 1 = 0
- en: 0 – 0 – borrow = 1 with a borrow
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 0 – 借位 = 1，带借位
- en: 0 – 1 – borrow = 0 with a borrow
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – 1 – 借位 = 0，带借位
- en: 1 – 0 – borrow = 0
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – 0 – 借位 = 0
- en: 1 – 1 – borrow = 1 with a borrow
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – 1 – 借位 = 1，带借位
- en: 'Here’s a step-by-step example of binary subtraction:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逐步的二进制减法示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are some more examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些更多的示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***3.1.3 Multiplying Binary Values***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.3 二进制值的乘法***'
- en: 'Multiplication of binary numbers is simple; it follows the same rules as decimal
    multiplication involving only 0s and 1s:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数的乘法很简单；它遵循与十进制乘法相同的规则，只涉及 0 和 1：
- en: 0 × 0 = 0
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 × 0 = 0
- en: 0 × 1 = 0
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 × 1 = 0
- en: 1 × 0 = 0
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 × 0 = 0
- en: 1 × 1 = 1
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 × 1 = 1
- en: 'Here’s a step-by-step example of binary multiplication:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逐步的二进制乘法示例：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***3.1.4 Dividing Binary Values***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.1.4 二进制值的除法***'
- en: Binary division uses the same (longhand) division algorithm as decimal division.
    [Figure 3-1](ch03.xhtml#ch03fig01) shows the steps in a decimal division problem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制除法使用与十进制除法相同的（长除法）算法。[图 3-1](ch03.xhtml#ch03fig01) 显示了一个十进制除法问题的步骤。
- en: '![image](../images/03fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig01.jpg)'
- en: '*Figure 3-1: Decimal division (3456/12)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：十进制除法（3456/12）*'
- en: This algorithm is easier in binary because at each step you don’t have to guess
    how many times 12 goes into the remainder or multiply 12 by your guess to obtain
    the amount to subtract. At each step in the binary algorithm, the divisor goes
    into the remainder exactly zero or one times. For example, consider the division
    of 27 (11011) by 3 (11) shown in [Figure 3-2](ch03.xhtml#ch03fig02).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在二进制下更简单，因为在每一步中，你不需要猜测12能被余数整除多少次，也不需要将12与你的猜测相乘来获得需要减去的数值。在二进制算法的每一步中，除数只能整除余数零次或一次。例如，考虑将27（11011）除以3（11）的过程，如[图3-2](ch03.xhtml#ch03fig02)所示。
- en: '![image](../images/03fig02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig02.jpg)'
- en: '*Figure 3-2: Longhand division in binary*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：二进制长除法*'
- en: '**3.2 Logical Operations on Bits**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.2 位运算**'
- en: 'There are four main logical operations we’ll need to perform on hexadecimal
    and binary numbers: AND, OR, XOR (exclusive-or), and NOT. In contrast to the arithmetic
    operations, a hexadecimal calculator isn’t necessary to perform these operations.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在十六进制和二进制数上执行四种主要的逻辑运算：与（AND）、或（OR）、异或（XOR，排他或）和非（NOT）。与算术运算不同，执行这些运算不需要十六进制计算器。
- en: 'The logical AND, OR, and XOR operations accept two single-bit operands and
    compute the following results:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与（AND）、或（OR）和异或（XOR）运算接受两个单比特操作数，并计算出以下结果：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Tables 3-1](ch03.xhtml#ch03tab01), [3-2](ch03.xhtml#ch03tab02), and [3-3](ch03.xhtml#ch03tab03)
    show the *truth tables* for the AND, OR, and XOR operations, respectively. A truth
    table is just like the multiplication tables you encountered in elementary school.
    The values in the left column correspond to the left operand of the operation.
    The values in the top row correspond to the right operand. The result is at the
    intersection of the row and column (for a particular pair of operands).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](ch03.xhtml#ch03tab01)，[3-2](ch03.xhtml#ch03tab02) 和 [3-3](ch03.xhtml#ch03tab03)
    显示了与（AND）、或（OR）和异或（XOR）操作的*真值表*。真值表就像你在小学时接触过的乘法表。左列的值对应于操作数的左操作数，顶行的值对应于右操作数。结果位于行和列的交点处（针对特定的一对操作数）。'
- en: '**Table 3-1:** AND Truth Table'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 与（AND）真值表'
- en: '| AND | 0 | 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 与（AND） | 0 | 1 |'
- en: '| 0 | 0 | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '**Table 3-2:** OR Truth Table'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 或（OR）真值表'
- en: '| OR | 0 | 1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 或（OR） | 0 | 1 |'
- en: '| 0 | 0 | 1 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '**Table 3-3:** XOR Truth Table'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-3：** 异或（XOR）真值表'
- en: '| XOR | 0 | 1 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 异或（XOR） | 0 | 1 |'
- en: '| 0 | 0 | 1 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: In plain English, the logical AND operation translates as, “If the first operand
    is 1 and the second operand is 1, the result is 1; otherwise the result is 0.”
    We could also state this as “If either or both operands are 0, the result is 0.”
    The logical AND operation is useful for forcing a 0 result. If one of the operands
    is 0, the result is 0 regardless of the value of the other operand. If one of
    the operands contains 1, then the result is the value of the other operand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗的话来说，逻辑“与”运算的定义是：“如果第一个操作数为1且第二个操作数为1，结果为1；否则，结果为0。”我们也可以这样表达：“如果任何一个或两个操作数为0，结果为0。”逻辑“与”运算对于强制得到0结果很有用。如果其中一个操作数为0，无论另一个操作数的值是什么，结果都是0。如果其中一个操作数为1，则结果是另一个操作数的值。
- en: Colloquially, the logical OR operation is, “If the first operand or the second
    operand (or both) is 1, the result is 1; otherwise the result is 0.” This is also
    known as the *inclusive*-*OR* operation. If one of the operands to the logical-OR
    operation is 1, the result is 1\. If an operand is 0, the result is the value
    of the other operand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，逻辑“或”运算的定义是：“如果第一个操作数或第二个操作数（或两者）为1，结果为1；否则，结果为0。”这也被称为*包含*或*运算*。如果逻辑“或”运算的操作数之一为1，则结果为1。如果某个操作数为0，则结果为另一个操作数的值。
- en: In English, the logical XOR operation is, “If the first or second operand, but
    not both, is 1, the result is 1; otherwise, the result is 0.” If one of the operands
    is a 1, the result is the *[inverse](gloss01.xhtml#gloss01_126)* of the other
    operand.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语来说，逻辑“异或”运算的定义是：“如果第一个或第二个操作数为1，但不是两个都为1，结果为1；否则，结果为0。”如果某个操作数为1，结果为另一个操作数的*逆（inverse）*值。
- en: The logical NOT operation is *unary* (meaning it accepts only one operand).
    [Table 3-4](ch03.xhtml#ch03tab04) is the truth table for the NOT operation. This
    operator inverts the value of its operand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑“非”运算是*一元*运算（意味着它只接受一个操作数）。[表3-4](ch03.xhtml#ch03tab04)是“非”运算的真值表。该运算符将其操作数的值取反。
- en: '**Table 3-4:** NOT Truth Table'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-4：** 非（NOT）真值表'
- en: '| NOT | 0 | 1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 非（NOT） | 0 | 1 |'
- en: '|  | 1 | 0 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 0 |'
- en: '**3.3 Logical Operations on Binary Numbers and Bit Strings**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.3 二进制数和位串的逻辑运算**'
- en: 'Because most programming languages manipulate groups of 8, 16, 32, or 64 bits,
    we need to extend the definition of these logical operations beyond single-bit
    operands to operate on a bit-by-bit (or *[bitwise](gloss01.xhtml#gloss01_33)*)
    basis. Given two values, a bitwise logical function operates on bit 0 from both
    source operands, producing bit 0 in the result operand; it operates on bit 1 of
    both operands, producing bit 1 of the result; and so on. For example, if you want
    to compute the bitwise logical AND of two 8-bit numbers, you would logically AND
    each pair of bits in the two numbers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数编程语言操作的是 8 位、16 位、32 位或 64 位的位组，我们需要将这些逻辑操作的定义扩展到不仅限于单个位操作数，以便按位（或 *[按位](gloss01.xhtml#gloss01_33)）的方式进行操作。给定两个值，按位逻辑函数对两个源操作数的位
    0 进行操作，产生结果操作数的位 0；对两个操作数的位 1 进行操作，产生结果的位 1；以此类推。例如，如果你想计算两个 8 位数的按位逻辑 AND，你会对这两个数中的每一对位进行按位
    AND 运算：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This bit-by-bit execution applies to the other logical operations as well. The
    ability to force bits to `0` or `1` using the logical AND and OR operations, and
    to invert bits using the logical XOR operation, is very important when you’re
    working with strings of bits (such as binary numbers). These operations let you
    selectively manipulate certain bits within a value while leaving other bits unaffected.
    For example, if you have an 8-bit binary value *X* and you want to guarantee that
    bits 4 through 7 contain `0`s, AND the value *X* with the binary value `%0000_1111`.
    This bitwise AND operation forces the HO 4 bits of *X* to `0` and leaves the LO
    4 bits of *X* unchanged. Likewise, you could force the LO bit of *X* to `1` and
    invert bit number 2 of *X* by ORing *X* with `%0000_0001` and then exclusive-ORing
    (XORing) *X* with `%0000_0100`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种按位执行同样适用于其他逻辑操作。当你使用逻辑 AND 和 OR 操作强制位为 `0` 或 `1`，以及使用逻辑 XOR 操作反转位时，它对于处理位串（如二进制数）非常重要。这些操作使你能够有选择性地操作值中的某些位，同时保持其他位不变。例如，如果你有一个
    8 位的二进制值 *X*，并且你想确保第 4 到第 7 位为 `0`，可以将 *X* 与二进制值 `%0000_1111` 进行 AND 运算。此按位 AND
    运算将强制 *X* 的高 4 位为 `0`，并且不改变 *X* 的低 4 位。同样，你可以通过将 *X* 与 `%0000_0001` 进行 OR 运算，再将
    *X* 与 `%0000_0100` 进行异或（XOR）运算，来强制 *X* 的低位为 `1`，并反转 *X* 的第 2 位。
- en: Manipulating bit strings with the logical AND, OR, and XOR operations is known
    as *masking*. This term originates from the fact that we can use certain values
    (`1` for AND, `0` for OR and XOR) to “mask out” or “mask in” certain bits in an
    operand while forcing other bits to `0`, `1`, or their inverse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑 AND、OR 和 XOR 运算操作位串被称为 *掩码操作*。这个术语来源于我们可以使用某些值（`1` 用于 AND，`0` 用于 OR 和 XOR）来“屏蔽”或“激活”操作数中的某些位，同时强制其他位为
    `0`、`1` 或其反值。
- en: 'Several languages provide operators that let you compute the bitwise AND, OR,
    XOR, and NOT of their operands. The C/C++/Java/Swift language family uses the
    ampersand (`&`) for bitwise AND, the pipe (`|`) for bitwise OR, the caret (`^`)
    for bitwise XOR, and the tilde (`~`) for bitwise NOT, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 几种语言提供了运算符，允许你计算其操作数的按位 AND、OR、XOR 和 NOT。C/C++/Java/Swift 语言族使用与号（`&`）表示按位 AND，竖线（`|`）表示按位
    OR，插入符号（`^`）表示按位 XOR，波浪号（`~`）表示按位 NOT，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Visual Basic and Free Pascal/Delphi languages let you use the `and`, `or`,
    `xor`, and `not` operators with integer operands. From 80x86 assembly language,
    you can use the `AND`, `OR`, `NOT`, and `XOR` instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic 和 Free Pascal/Delphi 语言允许你使用 `and`、`or`、`xor` 和 `not` 运算符与整数操作数。对于
    80x86 汇编语言，你可以使用 `AND`、`OR`、`NOT` 和 `XOR` 指令。
- en: '**3.4 Useful Bit Operations**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.4 有用的位操作**'
- en: Although bit operations may seem a bit abstract, they are quite useful for many
    non-obvious purposes. This section describes some of their useful properties in
    various languages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然位操作看起来可能有点抽象，但它们在许多非显而易见的用途上非常有用。本节描述了在各种语言中它们的一些有用特性。
- en: '***3.4.1 Testing Bits in a Bit String Using AND***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.1 使用 AND 测试位串中的位***'
- en: 'You can use the bitwise AND operator to test individual bits in a bit string
    to see if they are `0` or `1`. If you logically AND a value with a bit string
    that contains a `1` in a certain bit position, the result of the AND will be `0`
    if the corresponding bit contains a `0`, and nonzero if that bit position contains
    `1`. Consider the following C/C++ code, which checks an integer value to see if
    it is odd or even by testing bit 0 of the integer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用按位 AND 运算符来测试位串中的单个位，以查看它们是 `0` 还是 `1`。如果你将一个值与包含某个位位置为 `1` 的位串进行按位 AND
    运算，且对应的位是 `0`，则 AND 运算的结果为 `0`；如果该位置的位是 `1`，结果则为非零。考虑以下 C/C++ 代码，它通过测试整数的第 0 位来检查一个整数值是奇数还是偶数：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In binary form, here’s what this bitwise AND operation is doing:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制形式下，以下是此按位与运算操作的实现：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is `0` if the LO bit of ValueToTest contains a `0` in bit position
    0\. The result is `1` if ValueToTest contains a `1` in bit position 1\. This calculation
    ignores all other bits in ValueToTest.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ValueToTest 的最低位（LO bit）在位位置 0 处为 `0`，则结果为 `0`。如果 ValueToTest 在位位置 1 处为 `1`，则结果为
    `1`。此计算忽略了 ValueToTest 中的其他所有位。
- en: '***3.4.2 Testing a Set of Bits for Zero/Not Zero Using AND***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.2 使用 AND 测试一组位是否为零或非零***'
- en: 'You can also use the bitwise AND operator to see if all bits in a set are `0`.
    For example, one way to check if a number is evenly divisible by 16 is to see
    if the LO 4 bits are all `0`s. The following Free Pascal/Delphi statement uses
    the bitwise AND operator to accomplish this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用按位与（bitwise AND）运算符来检查一组位是否全部为 `0`。例如，检查一个数字是否能被 16 整除的其中一种方法是检查最低的 4
    位是否全为 `0`。以下是使用按位与运算符来实现这一点的 Free Pascal/Delphi 语句：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In binary form, here’s what this bitwise AND operation is doing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制形式下，以下是此按位与运算操作的实现：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is `0` if and only if the LO 4 bits of `ValueToTest` are all `0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当且仅当 `ValueToTest` 的最低 4 位全为 `0` 时，结果才为 `0`。
- en: '***3.4.3 Comparing a Set of Bits Within a Binary String***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.3 比较二进制字符串中的一组位***'
- en: The AND and OR operations are particularly useful if you need to compare a subset
    of the bits in a binary value against some other value. For example, you might
    want to compare two 6-bit values found in bits 0, 1, 10, 16, 24, and 31 of a pair
    of 32-bit values. The trick is to set all the uninteresting bits to `0` and then
    compare the two results.^([2](footnotes.xhtml#fn3_2a))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: AND 和 OR 操作特别有用，如果你需要将二进制值中的某一位子集与其他值进行比较。例如，你可能想比较两个 6 位值，这两个值分别位于两个 32 位值的位
    0、1、10、16、24 和 31 中。诀窍是将所有不感兴趣的位设置为 `0`，然后比较两个结果。^([2](footnotes.xhtml#fn3_2a))
- en: 'Consider the following three binary values; `x` denotes bits whose values we
    don’t care about:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下三个二进制值；`x` 表示我们不关心的位：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first and second binary values (assuming we’re interested only in bits
    31, 24, 16, 10, 1, and 0) are equal. If we compare either of the first two values
    against the third value, we’ll find that they are not equal. The third value is
    also greater than the first two. In C/C++ and assembly, this is how we could compare
    these values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个二进制值（假设我们只关注位 31、24、16、10、1 和 0）是相等的。如果我们将这两个值中的任何一个与第三个值进行比较，我们会发现它们不相等。第三个值也大于前两个值。在
    C/C++ 和汇编语言中，我们可以通过以下方式比较这些值：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***3.4.4 Creating Modulo-*n *Counters Using AND***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.4.4 使用 AND 创建模-*n* 计数器***'
- en: 'A [*modulo-*n *counter*](gloss01.xhtml#gloss01_164) counts from 0^([3](footnotes.xhtml#fn3_3a))
    to some maximum value and then resets to 0\. Modulo-*n* counters are great for
    creating repeating sequences of numbers such as 0, 1, 2, 3, 4, 5, . . . *n* –
    1; 0, 1, 2, 3, 4, 5, . . . *n* – 1; 0, 1, . . . . You can use such sequences to
    create circular queues and other objects that reuse array elements upon encountering
    the end of the data structure. The normal way to create a modulo-*n* counter is
    to add 1 to the counter, divide the result by *n*, and then keep the remainder.
    The following code examples demonstrate the implementation of a modulo-*n* counter
    in C/C++, Pascal, and Visual Basic:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 [*模-*n* 计数器*](gloss01.xhtml#gloss01_164) 从 0^([3](footnotes.xhtml#fn3_3a))
    计数到某个最大值，然后重置为 0。模-*n* 计数器非常适合创建重复的数字序列，例如 0, 1, 2, 3, 4, 5, . . . *n* – 1; 0,
    1, 2, 3, 4, 5, . . . *n* – 1; 0, 1, . . .。你可以使用这样的序列来创建循环队列和其他在遇到数据结构末尾时重新利用数组元素的对象。创建模-*n*
    计数器的常规方法是将计数器加 1，然后将结果除以 *n*，最后保留余数。以下是 C/C++、Pascal 和 Visual Basic 中模-*n* 计数器实现的代码示例：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, division is an expensive operation, requiring far more time to execute
    than addition. In general, you’ll find it more efficient to implement modulo-*n*
    counters using a comparison rather than the remainder operator. Here’s a Pascal
    example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除法是一种昂贵的操作，执行的时间远长于加法。通常，你会发现使用比较而不是取余运算符来实现模-*n* 计数器更为高效。以下是一个 Pascal 示例：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For certain special cases, when *n* is a power of 2, you can increment a modulo-*n*
    counter more efficiently and conveniently using the AND operation. To do so, increment
    your counter and then logically AND it with the value *x* = 2^(*m*) – 1 (2^(*m*)
    – 1 contains `1`s in bit positions 0..*m* – 1, and `0`s everywhere else). Because
    the AND operation is much faster than division, AND-driven modulo-*n* counters
    are much more efficient than those using the remainder operator. On most CPUs,
    using the AND operator is quite a bit faster than using an `if` statement. The
    following examples show how to implement a modulo-*n* counter for *n* = 32 using
    the AND operation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些特殊情况，当 *n* 是 2 的幂时，你可以使用 AND 操作更高效、方便地增加模 *n* 计数器。为此，增加你的计数器，然后将其与值 *x*
    = 2^(*m*) – 1 进行逻辑与运算（2^(*m*) – 1 在比特位 0..*m* – 1 中包含 `1`，其他地方是 `0`）。因为 AND 操作比除法快得多，所以使用
    AND 的模 *n* 计数器比使用余数操作符的要高效得多。在大多数 CPU 上，使用 AND 操作要比使用 `if` 语句快得多。以下示例展示了如何使用 AND
    操作实现一个模 *n* 计数器，其中 *n* = 32：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The assembly language code is especially efficient:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言代码特别高效：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**3.5 Shifts and Rotates**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.5 左移与旋转**'
- en: Another set of logical operations on bit strings are the *shift* and *rotate*
    operations. These functions can be further broken down into *shift lefts*, *rotate
    lefts*, *shift rights*, and *rotate rights*. These operations are very useful
    in many programs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组对比特串的逻辑操作是 *左移* 和 *旋转* 操作。这些功能可以进一步细分为 *左移*、*左旋转*、*右移* 和 *右旋转*。这些操作在许多程序中都非常有用。
- en: The shift left operation moves each bit in a bit string one position to the
    left, as shown in [Figure 3-3](ch03.xhtml#ch03fig03). Bit 0 moves into bit position
    1, the previous value in bit position 1 moves into bit position 2, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 左移操作将每个比特在比特串中向左移动一个位置，如 [图 3-3](ch03.xhtml#ch03fig03) 所示。比特 0 移动到比特位置 1，原先在比特位置
    1 的值移到比特位置 2，依此类推。
- en: '![image](../images/03fig03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig03.jpg)'
- en: '*Figure 3-3: Shift left operation (on a byte)*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：左移操作（对一个字节）*'
- en: 'You might be asking two questions: “What goes into bit 0?” and “Where does
    the HO bit wind up?” We’ll shift a `0` into bit 0, and the previous value of the
    HO bit will be the *carry* out of this operation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问两个问题：“什么会进入比特 0？”和“HO 比特会最终去哪？”我们会将 `0` 移入比特 0，HO 比特的前一个值将成为这次操作的*进位*。
- en: 'Several high-level languages (such as C/C++/C#, Swift, Java, and Free Pascal/Delphi)
    provide a shift left operator. In the C language family, this operator is `<<`.
    In Free Pascal/Delphi, you use the `shl` operator. Here are some examples:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级语言（如 C/C++/C#、Swift、Java 和 Free Pascal/Delphi）提供了左移操作符。在 C 语言家族中，该操作符是 `<<`。在
    Free Pascal/Delphi 中，你使用 `shl` 操作符。以下是一些示例：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shifting the binary representation of a number one position to the left is
    equivalent to multiplying that value by 2\. If you’re using a programming language
    that doesn’t provide an explicit shift left operator, you can simulate this by
    multiplying a binary integer value by 2\. Although the multiplication operation
    is usually slower than the shift left operation, most compilers are smart enough
    to translate a multiplication by a constant power of 2 into a shift left operation.
    Therefore, you could write code like the following in Visual Basic to do a shift
    left:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数字的二进制表示向左移动一位，相当于将该值乘以 2。如果你使用的编程语言没有提供显式的左移操作符，你可以通过将二进制整数值乘以 2 来模拟这一操作。虽然乘法操作通常比左移操作慢，但大多数编译器足够智能，能够将乘以
    2 的常数转换为左移操作。因此，你可以像下面这样在 Visual Basic 中编写代码来进行左移：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A shift right operation is similar to a shift left, except we move the data
    in the opposite direction. Bit 7 moves into bit 6, bit 6 moves into bit 5, bit
    5 moves into bit 4, and so on. During a shift right, we’ll move a `0` into bit
    7, and bit 0 will be the carry out of the operation (see [Figure 3-4](ch03.xhtml#ch03fig04)).
    C, C++, C#, Swift, and Java use the `>>` operator for a shift right operation.
    Free Pascal/Delphi uses the `shr` operator. Most assembly languages also provide
    a shift right instruction (`shr` on the 80x86).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 右移操作类似于左移操作，区别在于我们将数据朝相反方向移动。比特 7 移动到比特 6，比特 6 移动到比特 5，比特 5 移动到比特 4，依此类推。在右移操作中，我们会将
    `0` 移入比特 7，比特 0 将成为操作的进位（参见 [图 3-4](ch03.xhtml#ch03fig04)）。C、C++、C#、Swift 和 Java
    使用 `>>` 操作符进行右移操作。Free Pascal/Delphi 使用 `shr` 操作符。大多数汇编语言也提供了右移指令（在 80x86 上是 `shr`）。
- en: '![image](../images/03fig04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig04.jpg)'
- en: '*Figure 3-4: The shift right operation (on a byte)*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：右移操作（对一个字节）*'
- en: Shifting an unsigned binary value one position to the right divides that value
    by 2\. For example, if you shift the unsigned representation of 254 (`$FE`) one
    place to the right, you get 127 (`$7F`), exactly as you’d expect. However, if
    you shift the 8-bit two’s complement binary representation of –2 (`$FE`) one position
    to the right, you get 127 (`$7F`), which is *not* correct. To divide a signed
    number by 2 using a shift, we use a third shift operation, *arithmetic shift right*,
    which doesn’t modify the value of the HO bit. [Figure 3-5](ch03.xhtml#ch03fig05)
    shows the arithmetic shift right operation for an 8-bit operand.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个无符号二进制值右移一个位置相当于将该值除以 2。例如，如果你将无符号表示的 254 (`$FE`) 右移一位，你得到的是 127 (`$7F`)，完全符合预期。然而，如果你将
    8 位二进制补码表示的 –2 (`$FE`) 右移一位，你得到的是 127 (`$7F`)，这显然是*不正确*的。为了通过右移将有符号数除以 2，我们使用第三种右移操作——*算术右移*，它不会改变
    HO 位的值。[图 3-5](ch03.xhtml#ch03fig05)展示了一个 8 位操作数的算术右移操作。
- en: '![image](../images/03fig05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig05.jpg)'
- en: '*Figure 3-5: Arithmetic shift right operation (on a byte)*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：算术右移操作（字节级）*'
- en: This generally produces the result you expect for two’s complement signed operands.
    For example, if you perform the arithmetic shift right operation on –2 (`$FE`),
    you get –1 (`$FF`). Note, however, that this operation always rounds the numbers
    to the closest integer that is *less than or equal to the actual result*. If you
    arithmetically shift right –1 (`$FF`), the result is –1, not 0\. Because –1 is
    less than 0, the arithmetic shift right operation rounds toward –1\. This is not
    a “bug” in the arithmetic shift right operation; it just uses a different (though
    valid) definition of integer division. The bottom line is that you probably won’t
    be able to use a signed division operator as a substitute for arithmetic shift
    right in languages that don’t support arithmetic shift right, because most integer
    division operators round toward 0.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制补码的有符号操作数，这通常会产生你预期的结果。例如，如果你对 –2 (`$FE`) 执行算术右移操作，得到的是 –1 (`$FF`)。然而，值得注意的是，这种操作总是将数字舍入到*小于或等于实际结果*的最接近整数。如果你对
    –1 (`$FF`) 执行算术右移，结果是 –1，而不是 0。因为 –1 小于 0，所以算术右移操作会向 –1 舍入。这不是算术右移操作的“bug”；它只是采用了不同（尽管有效）的整数除法定义。关键是，在不支持算术右移的语言中，你可能无法使用有符号除法运算符来代替算术右移，因为大多数整数除法运算符是向
    0 舍入的。
- en: 'It’s rare for a high-level language to support both the logical shift right
    and the arithmetic shift right. Worse still, the specifications for certain languages
    leave it up to the compiler’s implementer to decide whether to use an arithmetic
    shift right or a logical shift right operation. Therefore, it’s only safe to use
    the shift right operator on values whose HO bit will cause both forms of the shift
    right operation to produce the same result. To guarantee that a shift right is
    a logical shift right or an arithmetic shift right operation, you’ll either have
    to drop down into assembly language or handle the HO bit manually. The high-level
    code gets ugly really fast, so a quick inline assembly statement might be a better
    solution if your program doesn’t need to be portable across different CPUs. The
    following code demonstrates how to simulate a 32-bit logical shift right and arithmetic
    shift right in languages that don’t guarantee the type of shift they use:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言同时支持逻辑右移和算术右移的情况很少见。更糟糕的是，某些语言的规范将是否使用算术右移或逻辑右移操作的决定权留给编译器的实现者。因此，只有在操作数的最高有效位（HO位）会导致两种右移操作产生相同结果时，使用右移运算符才是安全的。为了保证右移是逻辑右移或算术右移操作，你必须降到汇编语言中，或者手动处理
    HO 位。高级代码很快就会变得难以维护，因此如果你的程序不需要跨不同 CPU 可移植，快速的内联汇编语句可能是更好的解决方案。以下代码演示了如何在不保证右移类型的语言中模拟
    32 位逻辑右移和算术右移：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Many assembly languages also provide various rotate instructions that circulate
    bits through an operand by taking the bits shifted out of one end of the operand
    and shifting them into the other end. Few high-level languages provide this operation;
    fortunately, you won’t need it very often. If you do, you can synthesize this
    operation using the shift operators available in your high-level language:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 许多汇编语言还提供各种旋转指令，通过将操作数一端移出的位重新移入另一端，循环移动位。很少有高级语言提供这种操作；幸运的是，你通常不需要使用它。如果你确实需要，你可以使用你所用高级语言中可用的移位运算符来合成这种操作：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For more information on the type of shift and rotate operations that are possible,
    consult *The Art of Assembly Language* (No Starch Press).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可能的移位和旋转操作的更多信息，请参考 *汇编语言的艺术*（No Starch Press）。
- en: '**3.6 Bit Fields and Packed Data**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.6 比特字段和打包数据**'
- en: CPUs generally operate most efficiently on byte, word, double-word and quad-word
    data types,^([4](footnotes.xhtml#fn3_4a)) but occasionally you’ll need to work
    with a data type whose size is something other than 8, 16, 32, or 64 bits. In
    such cases, you may be able to save some memory by *packing* different strings
    of bits together as compactly as possible, without wasting any bits to align a
    particular data field on a byte or other boundary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通常在字节、字、双字和四字数据类型上运行最为高效，^([4](footnotes.xhtml#fn3_4a))但偶尔你需要处理的某些数据类型的大小并非
    8、16、32 或 64 位。在这种情况下，你可能通过将不同的比特串尽可能紧凑地打包在一起而节省一些内存，避免浪费任何比特来对齐特定的数据字段到字节或其他边界。
- en: 'Consider a date of the form 04/02/01\. It takes three numeric values to represent
    this date: month, day, and year. Months use the values 1 through 12, which require
    at least 4 bits to represent. Days use the range 1 through 31, which take 5 bits
    to represent. The year value, assuming that we’re working with values in the range
    0 through 99, requires 7 bits. The total of 4 + 5 + 7 is 16 bits, or 2 bytes.
    We can pack our date data into 2 bytes rather than the 3 that would be required
    if we used a separate byte for each of the values. This saves 1 byte of memory
    for each date stored, which could be a substantial saving if you need to store
    many dates. You might arrange the bits as shown in [Figure 3-6](ch03.xhtml#ch03fig06).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设日期为 04/02/01。表示这个日期需要三个数字值：月份、日期和年份。月份使用 1 到 12 的值，至少需要 4 个比特来表示。日期使用 1 到
    31 的范围，需要 5 个比特来表示。年份值，假设我们处理的是 0 到 99 之间的值，则需要 7 个比特。4 + 5 + 7 总共是 16 个比特，或者
    2 字节。我们可以将日期数据打包成 2 字节，而不是每个值使用一个单独的字节，这样每存储一个日期就能节省 1 字节内存。如果你需要存储许多日期，这可能会带来显著的节省。你可以像
    [图 3-6](ch03.xhtml#ch03fig06) 中所示那样排列这些比特。
- en: '![image](../images/03fig06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig06.jpg)'
- en: '*Figure 3-6: Short packed date format (16 bits)*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：短整型打包日期格式（16 位）*'
- en: '`MMMM` represents the 4 bits that hold the month value, `DDDDD` the 5 bits
    that hold the day, and `YYYYYYY` the 7 bits that hold the year. Each collection
    of bits representing a data item is a *bit field*. We could represent April 2,
    2001, with `$4101`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MMMM` 代表保存月份值的 4 个比特，`DDDDD` 代表保存日期值的 5 个比特，`YYYYYYY` 代表保存年份值的 7 个比特。每一组表示数据项的比特就是一个
    *比特字段*。我们可以用 `$4101` 来表示 2001 年 4 月 2 日：'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although packed values are space efficient (that is, they use little memory),
    they are computationally inefficient (slow!). The reason? It takes extra instructions
    to unpack the data from the various bit fields. These extra instructions take
    time to execute (and additional bytes to hold the instructions); hence, you must
    carefully consider whether packed data fields will save you anything. The following
    sample HLA/x86 code demonstrates packing and unpacking this 16-bit date format.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包值在空间上是高效的（也就是说，它们使用较少的内存），但它们在计算上是低效的（慢！）。原因是什么？因为需要额外的指令从不同的比特字段中解包数据。这些额外的指令需要时间来执行（并且还需要额外的字节来存储指令）；因此，你必须仔细考虑打包数据字段是否真的能为你节省什么。以下是一个示例
    HLA/x86 代码，演示了如何打包和解包这种 16 位日期格式。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Keeping in mind the Y2K^([5](footnotes.xhtml#fn3_5a)) problem, adopting a date
    format that supports only a two-digit year is rather foolish. Consider the better
    date format shown in [Figure 3-7](ch03.xhtml#ch03fig07).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 Y2K^([5](footnotes.xhtml#fn3_5a)) 问题，采用仅支持两位数年份的日期格式是相当愚蠢的。考虑 [图 3-7](ch03.xhtml#ch03fig07)
    中展示的更好的日期格式。
- en: '![image](../images/03fig07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig07.jpg)'
- en: '*Figure 3-7: Long packed date format (32 bits)*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7：长整型打包日期格式（32 位）*'
- en: Because there are more bits in a 32-bit variable than are needed to hold the
    date, even accounting for years in the range 0 through 65,535, this format allots
    a full byte for the `month` and `day` fields. An application can manipulate these
    two fields as byte objects, reducing the overhead to pack and unpack these fields
    on processors that support byte access. This leaves fewer bits for the year, but
    65,536 years is probably sufficient (it’s a safe bet that your software won’t
    be in use 63,000 years from now).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 32 位变量中的比特数超过了存储日期所需的数量，即使考虑到年份范围为 0 到 65,535，这种格式仍为 `month` 和 `day` 字段分配了一个完整的字节。应用程序可以将这两个字段作为字节对象进行操作，从而减少在支持字节访问的处理器上打包和解包这些字段的开销。这为年份留下了更少的比特，但
    65,536 年可能足够了（你可以放心地认为你的软件在 63,000 年后不会再使用）。
- en: You could argue that this is no longer a packed date format. After all, we needed
    three numeric values, two of which fit just nicely into 1 byte each and one that
    should have at least 2 bytes. This “packed” date format consumes the same 4 bytes
    as the unpacked version, not the fewest bits possible. So, in this example, packed
    effectively means *packaged* or *encapsulated*. By packing the data into a double-word
    variable, the program can treat the date value as a single data value rather than
    as three separate variables. This means that you can often get away with a single
    machine instruction to operate on this data rather than three separate instructions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以认为这不再是打包日期格式。毕竟，我们需要三个数值，其中两个可以各自正好适应 1 个字节，而一个至少需要 2 个字节。这种“打包”的日期格式消耗了与解包版本相同的
    4 个字节，而不是最少的位数。所以，在这个例子中，打包实际上意味着*打包*或*封装*。通过将数据打包到一个双字变量中，程序可以将日期值视为一个单一的数据值，而不是三个单独的变量。这意味着你通常可以用一条机器指令操作这组数据，而不是三条单独的指令。
- en: 'Another difference between this long packed date format and the short date
    format in [Figure 3-6](ch03.xhtml#ch03fig06) is that this long date format rearranges
    the `Year`, `Month`, and `Day` fields. This allows you to easily compare two dates
    using an unsigned integer comparison. Consider the following HLA/assembly code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长日期格式与 [图 3-6](ch03.xhtml#ch03fig06) 中的短日期格式之间的另一个区别在于，长日期格式重新排列了 `年份`、`月份`
    和 `日期` 字段。这使你可以轻松地使用无符号整数比较两个日期。考虑以下 HLA/汇编代码：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Had you kept the different date fields in separate variables or organized the
    fields differently, you wouldn’t have been able to compare `Date1` and `Date2`
    in such a straightforward way. Even if you don’t realize any space savings, packing
    data can make certain computations more convenient or even more efficient (contrary
    to what normally happens when you pack data).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将不同的日期字段保存在单独的变量中，或者以不同方式组织字段，你就无法像现在这样简单地比较 `Date1` 和 `Date2`。即使你没有节省任何空间，打包数据也可以使某些计算变得更方便，甚至更高效（这与通常在打包数据时发生的情况相反）。
- en: 'Some high-level languages provide built-in support for packed data. For example,
    in C you can define structures like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级语言提供对打包数据的内置支持。例如，在 C 中，你可以定义如下结构：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This structure specifies that each field is an unsigned object that holds 4,
    8, 4, 8, and 8 bits, respectively. The `:`n item after each declaration specifies
    the *minimum* number of bits the compiler will allocate for the given field.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构指定每个字段是一个无符号对象，分别包含 4 位、8 位、4 位、8 位和 8 位。每个声明后的 `:`n 项指定编译器为给定字段分配的*最小*位数。
- en: Unfortunately, it isn’t possible to show how a C/C++ compiler will allocate
    the values from a 32-bit double word among the fields, because C/C++ compiler
    implementers are free to implement these bit fields any way they see fit. The
    arrangement of the bits within the bit string is arbitrary (for example, the compiler
    could allocate the `bits0_3` field in bits 28 through 31 of the ultimate object).
    The compiler can also inject extra bits between fields, or use a larger number
    of bits for each field (which is actually the same thing as injecting extra padding
    bits between fields). Most C compilers attempt to minimize extraneous padding,
    but compilers (especially on different CPUs) do vary. Therefore, C/C++ struct
    bit field declarations are almost guaranteed to be nonportable, and you can’t
    really count on what the compiler is going to do with those fields.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，无法展示 C/C++ 编译器如何在字段之间分配来自 32 位双字的数据值，因为 C/C++ 编译器的实现者可以自由选择任何方式实现这些位字段。位字符串中位的排列是任意的（例如，编译器可能将
    `bits0_3` 字段分配到最终对象的第 28 到 31 位之间）。编译器还可以在字段之间插入额外的位，或者为每个字段使用更多的位（这实际上和在字段之间插入额外的填充位是同一件事）。大多数
    C 编译器会尽量减少多余的填充，但编译器（尤其是在不同的 CPU 上）确实存在差异。因此，C/C++ 结构体位字段声明几乎肯定是不可移植的，你无法依赖编译器对这些字段的处理方式。
- en: 'The advantage of using the compiler’s built-in data-packing capabilities is
    that the compiler automatically packs and unpacks the data for you. Given the
    following C/C++ code, the compiler would automatically emit the necessary machine
    instructions to store and retrieve the individual bit fields for you:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译器的内置数据打包功能的优点是，编译器会自动为你打包和解包数据。给定以下 C/C++ 代码，编译器会自动生成必要的机器指令，为你存储和检索单个位字段：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**3.7 Packing and Unpacking Data**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.7 数据打包与解包**'
- en: 'The advantage of packed data types is efficient memory use. Consider the Social
    Security number (SSN) used in the United States, a nine-digit identification code
    in the following form (each `X` represents a single decimal digit):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 打包数据类型的优点是高效的内存使用。以美国的社会安全号码（SSN）为例，它是一个九位数的身份识别码，格式如下（每个 `X` 代表一个数字）：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Encoding an SSN using three separate (32-bit) integers takes 12 bytes. That’s
    more than the 11 bytes needed to represent the number using an array of characters.
    A better solution is to encode each field using short (16-bit) integers. Now it
    takes only 6 bytes to represent the SSN. Because the middle field in the SSN is
    always between 0 and 99, we can actually shave one more byte off the size of this
    structure by encoding the middle field with a single byte. Here’s a sample Free
    Pascal/Delphi record structure that defines this data structure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个单独的 32 位整数来编码 SSN 需要 12 字节。这比使用字符数组表示该数字所需的 11 字节还要多。更好的解决方案是使用短整数（16 位）编码每个字段。这样只需要
    6 字节就能表示 SSN。由于 SSN 中间字段的值总是在 0 到 99 之间，我们实际上可以通过用一个字节来编码中间字段，再缩减这个结构的大小。以下是一个示例
    Free Pascal/Delphi 记录结构，定义了这个数据结构：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we drop the hyphens in the SSN, the result is a nine-digit number. Because
    we can exactly represent all nine-digit values using 30 bits, we could encode
    any legal SSN using a 32-bit integer. However, some software that manipulates
    SSNs may need to operate on the individual fields. This means using expensive
    division, modulo, and multiplication operators in order to extract fields from
    a SSN you’ve encoded in a 32-bit integer format. Furthermore, converting SSNs
    to and from strings is more complicated when you’re using the 32-bit format.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去掉 SSN 中的连字符，结果是一个九位数的数字。因为我们可以用 30 位精确表示所有九位数值，因此可以使用 32 位整数来编码任何合法的 SSN。然而，一些处理
    SSN 的软件可能需要操作各个字段。这意味着必须使用昂贵的除法、取余和乘法运算符，以从你已编码为 32 位整数格式的 SSN 中提取字段。此外，使用 32
    位格式时，将 SSN 转换为字符串并进行转换会更复杂。
- en: Conversely, it’s easy to insert and extract individual bit fields using fast
    machine instructions, and it’s also less work to create a standard string representation
    (including the hyphens) of one of these fields. [Figure 3-8](ch03.xhtml#ch03fig08)
    shows a straightforward implementation of the SSN packed data type using a separate
    string of bits for each field (note that this format uses 31 bits and ignores
    the HO bit).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用快速机器指令插入和提取单独的位字段非常容易，而且创建这些字段的标准字符串表示（包括连字符）也更轻松。[图 3-8](ch03.xhtml#ch03fig08)
    展示了使用每个字段的单独位串实现 SSN 打包数据类型的简单实现（请注意，该格式使用 31 位并忽略了 HO 位）。
- en: '![image](../images/03fig08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig08.jpg)'
- en: '*Figure 3-8: SSN packed fields encoding*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-8：SSN 打包字段编码*'
- en: Fields that begin at bit position 0 in a packed data object can be accessed
    most efficiently, so you should arrange the fields in your packed data type such
    that the field you access most often^([6](footnotes.xhtml#fn3_6a)) begins at bit
    0\. If you have no idea which field you’ll access most often, assign the fields
    so they begin on a byte boundary. If there are unused bits in your packed type,
    spread them throughout the structure so that individual fields begin on a byte
    boundary and those fields consume multiples of 8 bits.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包数据对象中，从第 0 位开始的字段可以最有效地访问，因此你应该在打包数据类型中安排字段，使得你最常访问的字段^([6](footnotes.xhtml#fn3_6a))从第
    0 位开始。如果你不知道哪个字段会被访问得最频繁，则应将字段安排在字节边界上。如果你的打包类型中有未使用的位，应将它们均匀分布在整个结构中，以确保各个字段从字节边界开始，并且这些字段占据的是
    8 位的倍数。
- en: We’ve got only one unused bit in the SSN example shown in [Figure 3-8](ch03.xhtml#ch03fig08),
    but it turns out that we can use this extra bit to align two fields on a byte
    boundary and ensure that one of those fields occupies a bit string whose length
    is a multiple of 8 bits. Consider [Figure 3-9](ch03.xhtml#ch03fig09), which shows
    a rearranged version of our SSN data type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-8](ch03.xhtml#ch03fig08)中展示的 SSN 示例中，我们只有一个未使用的位，但实际上我们可以利用这个额外的位将两个字段对齐到字节边界，并确保其中一个字段占据一个长度为
    8 位倍数的位串。请参考[图 3-9](ch03.xhtml#ch03fig09)，它展示了我们 SSN 数据类型的重新排列版本。
- en: '![image](../images/03fig09.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig09.jpg)'
- en: '*Figure 3-9: A (possibly) improved encoding of the SSN*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-9：可能改进的 SSN 编码*'
- en: One problem with the data format in [Figure 3-9](ch03.xhtml#ch03fig09) is that
    we can’t sort SSNs in an intuitive way by comparing 32-bit unsigned integers.^([7](footnotes.xhtml#fn3_7a))
    If you intend to do a lot of sorting based on the entire SSN, the format in [Figure
    3-8](ch03.xhtml#ch03fig08) is probably better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-9](ch03.xhtml#ch03fig09)中的数据格式的一个问题是，我们无法通过比较 32 位无符号整数以直观的方式对 SSN 进行排序。^([7](footnotes.xhtml#fn3_7a))
    如果你打算对整个 SSN 进行大量排序，[图 3-8](ch03.xhtml#ch03fig08)中的格式可能会更好。'
- en: If this type of sorting isn’t important to you, the format in [Figure 3-9](ch03.xhtml#ch03fig09)
    has some advantages. This packed type actually uses 8 bits (rather than 7) to
    represent `SecondField` (along with moving `SecondField` down to bit position
    0); the extra bit will always contain `0`. This means that `SecondField` consumes
    bits 0 through 7 (a whole byte) and `ThirdField` begins on a byte boundary (bit
    position 8). `ThirdField` doesn’t consume a multiple of 8 bits, and `FirstField`
    doesn’t begin on a byte boundary, but we’ve done fairly well with this encoding,
    considering we only had one extra bit to play around with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种排序方式对你不重要，那么[图 3-9](ch03.xhtml#ch03fig09)中的格式有一些优势。这个打包格式实际上使用了 8 位（而不是
    7 位）来表示`SecondField`（同时将`SecondField`移到位位置 0）；额外的一位将始终包含`0`。这意味着`SecondField`占用了位
    0 到 7（一个完整的字节），而`ThirdField`从字节边界开始（位位置 8）。`ThirdField`并不占用 8 位的倍数，且`FirstField`并不从字节边界开始，但考虑到我们只多了一个额外的位来处理，整个编码效果还算不错。
- en: The next question is, “How do we access the fields of this packed type?” There
    are two separate activities here. We need to retrieve, or *extract*, the packed
    fields, and we need to *insert* data into these fields. The AND, OR, and SHIFT
    operations provide the tools for this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是：“我们如何访问这个打包类型的字段？”这里有两个独立的操作。我们需要检索或*提取*打包字段，并且需要*插入*数据到这些字段中。AND、OR
    和 SHIFT 操作提供了完成这些操作的工具。
- en: When operating on these fields, it’s convenient to work with three separate
    variables rather than with the packed data directly. For our SSN example, we can
    create the three variables—`FirstField`, `SecondField`, and `ThirdField`—and then
    extract the actual data from the packed value into these three variables, operate
    on the variables, and insert the data from the variables back into their fields
    when we’re done.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作这些字段时，使用三个独立的变量而不是直接操作打包数据会更方便。以我们的 SSN 示例为例，我们可以创建三个变量——`FirstField`、`SecondField`
    和 `ThirdField`——然后从打包的值中提取实际数据到这三个变量中，操作这些变量，最后在完成操作后将数据插入回各自的字段。
- en: 'To extract the `SecondField` data from the packed format shown in [Figure 3-9](ch03.xhtml#ch03fig09)
    (remember, the field aligned to bit 0 is the easiest one to access), copy the
    data from the packed representation to the `SecondField` variable and then mask
    out all but the `SecondField` bits using the AND operation. Because `SecondField`
    is a 7-bit value, the mask is an integer containing `1`s in bit positions 0 through
    6 and `0`s everywhere else. The following C/C++ code demonstrates how to extract
    this field into the `SecondField` variable (assuming packedValue is a variable
    holding the 32-bit packed SSN):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要从[图 3-9](ch03.xhtml#ch03fig09)所示的打包格式中提取`SecondField`数据（记住，位 0 对齐的字段最容易访问），将打包表示中的数据复制到`SecondField`变量，然后使用
    AND 操作屏蔽除`SecondField`位之外的所有位。因为`SecondField`是一个 7 位的值，所以掩码是一个整数，包含位位置 0 到 6 为`1`，其他位置为`0`。下面的
    C/C++ 代码演示了如何将此字段提取到`SecondField`变量中（假设 packedValue 是一个保存了 32 位打包 SSN 的变量）：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Extracting fields that are not aligned at bit 0 takes a little more work. Consider
    the `ThirdField` entry in [Figure 3-9](ch03.xhtml#ch03fig09). We can mask out
    all the bits associated with the first and second fields by logically ANDing the
    packed value with `%_11_1111_1111_1111_0000_0000` (`$3F_FF00`). However, this
    leaves the `ThirdField` value sitting in bits 8 through 21, which is not convenient
    for various arithmetic operations. The solution is to shift the masked value down
    8 bits so that it’s aligned at bit 0 in our working variable. The following Pascal/Delphi
    code does this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提取那些没有对齐在位 0 上的字段需要稍微多一点工作。考虑[图 3-9](ch03.xhtml#ch03fig09)中的`ThirdField`条目。我们可以通过逻辑
    AND 操作将打包值与`%_11_1111_1111_1111_0000_0000`（`$3F_FF00`）进行与运算，从而屏蔽掉与第一和第二字段相关的所有位。然而，这样会把`ThirdField`值留在位
    8 到 21 中，这对于各种算术操作并不方便。解决方法是将掩码后的值向下移 8 位，使其与我们的工作变量的位 0 对齐。下面的 Pascal/Delphi
    代码实现了这个过程：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also shift first and then do the logical AND operation (though this
    requires a different mask, `$11_1111_1111_1111 or $3FFF`). Here’s the C/C++/Swift
    code that extracts `ThirdField` using that technique:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以先进行移位操作，然后执行逻辑与（AND）操作（不过这需要使用不同的掩码，`$11_1111_1111_1111 或 $3FFF`）。以下是使用该技术提取`ThirdField`的C/C++/Swift代码：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To extract a field that is aligned against the HO bit, such as the first field
    in our SSN packed data type, shift the HO field down so that it’s aligned at bit
    0\. The logical shift right operation automatically fills in the HO bits of the
    result with `0`s, so no masking is necessary. The following Pascal/Delphi code
    demonstrates this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取一个对齐在高位（HO）位的字段，例如我们SSN打包数据类型中的第一个字段，需要将高位字段移到第0位。逻辑右移操作会自动将结果的高位填充为`0`，因此不需要掩码操作。以下Pascal/Delphi代码演示了这一过程：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In HLA/x86 assembly language, we can easily access data at any arbitrary byte
    boundary in memory. That allows us to treat both the second and third fields as
    though they are aligned at bit 0 in the data structure. In addition, because the
    `SecondField` value is an 8-bit value (with the HO bit always containing `0`),
    it takes only a single machine instruction to unpack the data, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA/x86汇编语言中，我们可以轻松地访问内存中任意字节边界的数据。这使得我们能够将第二个和第三个字段看作它们在数据结构中的对齐位置是从第0位开始的。此外，由于`SecondField`值是一个8位值（高位始终为`0`），因此只需要一个机器指令就能解包数据，如下所示：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This instruction fetches the first byte of packedValue (which is the LO 8 bits
    of packedValue on the 80x86) and zero-extends this value to 32 bits in EAX (`movzx`
    stands for “move with zero extension”). The EAX register contains the `SecondField`
    value after this instruction executes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令提取打包值对象的第一个字节（在80x86架构中是打包值的低8位），并将该值零扩展为32位存储在EAX寄存器中（`movzx`表示“带零扩展的移动”）。该指令执行后，EAX寄存器包含`SecondField`值。
- en: 'The `ThirdField` value from our packed data type isn’t an even multiple of
    8 bits long, so we’ll still need a masking operation to clear the unused bits
    from the 32-bit result we produce. However, because `ThirdField` is aligned on
    a byte (8-bit) boundary in our packed structure, we’ll be able to avoid the shift
    operation that was necessary in the high-level code. Here’s the HLA/x86 assembly
    code that extracts the third field from our packedValue object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 来自打包数据类型的`ThirdField`值并不是8位的整数倍长度，因此我们仍然需要进行一个掩码操作，以清除我们产生的32位结果中的未使用位。然而，由于`ThirdField`在打包结构中是对齐在字节（8位）边界上的，我们将能够避免在高级代码中所需的移位操作。以下是提取打包值对象中第三个字段的HLA/x86汇编代码：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Extracting `FirstField` from the packedValue object in HLA/x86 assembly code
    is identical to the high-level code; we’ll simply shift the upper 10 bits (which
    comprise `FirstField`) down to bit 0:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA/x86汇编代码中，从打包值对象中提取`FirstField`与高级代码相同；我们只需将包含`FirstField`的上10位移到第0位：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Assuming the data you want to insert appears in some variable and contains `0`s
    in the unused bits, inserting a field into a packed object requires three operations.
    First, if necessary, you shift the field’s data to the left so its alignment matches
    the corresponding field in the packed object. Next, clear the corresponding bits
    in the packed structure, then logically OR the shifted field into the packed object.
    [Figure 3-10](ch03.xhtml#ch03fig10) shows the details of this operation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要插入的数据存储在某个变量中，并且在未使用的位中包含`0`，那么将一个字段插入到一个打包的对象中需要三步操作。首先，如果有必要，你需要将字段的数据向左移动，使其对齐方式与打包对象中对应字段的对齐方式一致。接下来，清除打包结构中的对应位，然后使用逻辑或（OR）操作将移动后的字段插入到打包对象中。[图
    3-10](ch03.xhtml#ch03fig10)显示了这一操作的细节。
- en: '![image](../images/03fig10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/03fig10.jpg)'
- en: '*Figure 3-10: Inserting `ThirdField` into the SSN packed type*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-10：将`ThirdField`插入到SSN打包类型中*'
- en: 'Here’s the C/C++/Swift code that accomplishes the operation shown in [Figure
    3-10](ch03.xhtml#ch03fig10):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成[图 3-10](ch03.xhtml#ch03fig10)中显示操作的C/C++/Swift代码：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`$FFC000FF` is the hexadecimal value that corresponds to `0`s in bit positions
    8 through 21 and `1`s everywhere else.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`$FFC000FF`是一个十六进制值，它对应于从第8位到第21位的`0`，而其他位置是`1`。'
- en: '**3.8 For More Information**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.8 更多信息**'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*。第二版。旧金山：No Starch Press，2010。
- en: 'Knuth, Donald E. *The Art of Computer Programming, Volume 2: Seminumerical
    Algorithms*. 3rd ed. Boston: Addison-Wesley, 1998.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth, Donald E. *计算机程序设计的艺术，第2卷：半数值算法*。第三版。波士顿：Addison-Wesley，1998。
