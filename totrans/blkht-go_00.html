<html><head></head><body><div id="sbo-rt-content"><h2 class="h2f" id="intro"><span epub:type="pagebreak" id="page_xix"/>INTRODUCTION</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">For about six years, the three of us led one of North America’s largest dedicated penetration-testing consulting practices. As principal consultants, we executed technical project work, including network penetration tests, on behalf of our clients—but we also spearheaded the development of better tools, processes, and methodology. And at some point, we adopted Go as one of our primary development languages.</p>&#13;
<p class="indent">Go provides the best features of other programming languages, striking a balance between performance, safety, and user-friendliness. Soon, we defaulted to it as our language of choice when developing tools. Eventually, we even found ourselves acting as advocates of the language, pushing for our colleagues in the security industry to try it. We felt the benefits of Go were at least worthy of consideration.</p>&#13;
<p class="indent">In this book, we’ll take you on a journey through the Go programming language from the perspective of security practitioners and hackers. Unlike other hacking books, we won’t just show you how to automate third-party or commercial tools (although we’ll touch on that a little). Instead, we’ll delve <span epub:type="pagebreak" id="page_xx"/>into practical and diverse topics that approach a specific problem, protocol, or tactic useful to adversaries. We’ll cover TCP, HTTP, and DNS communications, interact with Metasploit and Shodan, search filesystems and databases, port exploits from other languages to Go, write the core functions of an SMB client, attack Windows, cross-compile binaries, mess with crypto, call C libraries, interact with the Windows API, and much, much more. It’s ambitious! We’d better begin . . .</p>&#13;
<h3 class="h3" id="introlev1">Who This Book Is For</h3>&#13;
<p class="noindent">This book is for anyone who wants to learn how to develop their own hacking tools using Go. Throughout our professional careers, and particularly as consultants, we’ve advocated for programming as a fundamental skill for penetration testers and security professionals. Specifically, the ability to code enhances your understanding of how software works and how it can be broken. Also, if you’ve walked in a developer’s shoes, you’ll gain a more holistic appreciation for the challenges they face in securing software, and you can use your personal experience to better recommend mitigations, eliminate false positives, and locate obscure vulnerabilities. Coding often forces you to interact with third-party libraries and various application stacks and frameworks. For many people (us included), it’s hands-on experience and tinkering that leads to the greatest personal development.</p>&#13;
<p class="indent">To get the most out of this book, we encourage you to clone the book’s official code repository so you have all the working examples we’ll discuss. Find the examples at <a href="https://github.com/blackhat-go/bhg/"><em>https://github.com/blackhat-go/bhg/</em></a>.</p>&#13;
<h3 class="h3" id="introlev2">What This Book Isn’t</h3>&#13;
<p class="noindent">This book is not an introduction to Go programming in general but an introduction to using Go for developing security tools. We are hackers and then coders—in that order. None of us have ever been software engineers. This means that, as hackers, we put a premium on function over elegance. In many instances, we’ve opted to code as hackers do, disregarding some of the idioms or best practices of software design. As consultants, time is always scarce; developing simpler code is often faster and, therefore, preferable over elegance. When you need to quickly create a solution to a problem, style concerns come secondary.</p>&#13;
<p class="indent">This is bound to anger Go purists, who will likely tweet at us that we don’t gracefully handle all error conditions, that our examples could be optimized, or that better constructs or methods are available to produce the desired results. We’re not, in most cases, concerned with teaching you the best, the most elegant, or 100 percent idiomatic solutions, unless doing so will concretely benefit the end result. Although we’ll briefly cover the language syntax, we do so purely to establish a baseline foundation upon which we can build. After all, this isn’t <em>Learning to Program Elegantly with Go</em>—this is <em>Black Hat Go</em>.</p>&#13;
<h3 class="h3" id="introlev3"><span epub:type="pagebreak" id="page_xxi"/>Why Use Go for Hacking?</h3>&#13;
<p class="noindent">Prior to Go, you could prioritize ease of use by using dynamically typed languages—such as Python, Ruby, or PHP—at the expense of performance and safety. Alternatively, you could choose a statically typed language, like C or C++, that offers high performance and safety but isn’t very user-friendly. Go is stripped of much of the ugliness of C, its primary ancestor, making development more user-friendly. At the same time, it’s a statically typed language that produces syntax errors at compile time, increasing your assurance that your code will actually run safely. As it’s compiled, it performs more optimally than interpreted languages and was designed with multicore computing considerations, making concurrent programming a breeze.</p>&#13;
<p class="indentb">These reasons for using Go don’t concern security practitioners specifically. However, many of the language’s features are particularly useful for hackers and adversaries:</p>&#13;
<p class="noindentf"><strong>Clean package management system</strong> Go’s package management solution is elegant and integrated directly with Go’s tooling. Through the use of the <code>go</code> binary, you can easily download, compile, and install packages and dependencies, which makes consuming third-party libraries simple and generally free from conflict.</p>&#13;
<p class="noindentf"><strong>Cross-compilation</strong> One of the best features in Go is its ability to cross-compile executables. So long as your code doesn’t interact with raw C, you can easily write code on your Linux or Mac system but compile the code in a Windows-friendly, Portable Executable format.</p>&#13;
<p class="noindentf"><strong>Rich standard library</strong> Time spent developing in other languages has helped us appreciate the extent of Go’s standard library. Many modern languages lack the standard libraries required to perform many common tasks such as crypto, network communications, database connectivity, and data encoding (JSON, XML, Base64, hex). Go includes many of these critical functions and libraries as part of the language’s standard packaging, reducing the effort necessary to correctly set up your development environment or to call the functions.</p>&#13;
<p class="noindentf"><strong>Concurrency</strong> Unlike languages that have been around longer, Go was released around the same time as the initial mainstream multicore processors became available. For this reason, Go’s concurrency patterns and performance optimizations are tuned specifically to this model.</p>&#13;
<h3 class="h3" id="introlev4">Why You Might Not Love Go</h3>&#13;
<p class="noindentb1">We recognize that Go isn’t a perfect solution to every problem. Here are some of the downsides of the language:</p>&#13;
<p class="noindentf"><strong>Binary size</strong> ’Nuff said. When you compile a binary in Go, the binary is likely to be multiple megabytes in size. Of course, you can strip debugging symbols and use a packer to help reduce the size, but these steps <span epub:type="pagebreak" id="page_xxii"/>require attention. This can be a drawback, particularly for security practitioners who need to attach a binary to an email, host it on a shared filesystem, or transfer it over a network.</p>&#13;
<p class="noindentf"><strong>Verbosity</strong> While Go is less verbose than languages like C#, Java, or even C/C++, you still might find that the simplistic language construct forces you to be overly expressive for things like lists (called <em>slices</em> in Go), processing, looping, or error handling. A Python one-liner might easily become a three-liner in Go.</p>&#13;
<h3 class="h3" id="introlev5">Chapter Overview</h3>&#13;
<p class="noindent">The first chapter of this book covers a basic overview of Go’s syntax and philosophy. Next, we start to explore examples that you can leverage for tool development, including various common network protocols like HTTP, DNS, and SMB. We then dig into various tactics and problems that we’ve encountered as penetration testers, addressing topics including data pilfering, packet sniffing, and exploit development. Finally, we take a brief step back to talk about how you can create dynamic, pluggable tools before diving into crypto, attacking Microsoft Windows, and implementing steganography.</p>&#13;
<p class="indent">In many cases, there will be opportunities to extend the tools we show you to meet your specific objectives. Although we present robust examples throughout, our real intent is to provide you with the knowledge and foundation through which you can extend or rework the examples to meet your goals. We want to teach you to fish.</p>&#13;
<p class="indent">Before you continue with anything in this book, please note that we—the authors and publisher—have created this content for legal usage only. We won’t accept any liability for the nefarious or illegal things you choose to do. All the content here is for educational purposes only; do not perform any penetration-testing activities against systems or applications without authorized consent.</p>&#13;
<p class="indent">The sections that follow provide a brief overview of each chapter.</p>&#13;
<h4 class="h4"><a href="ch01.xhtml">Chapter 1: Go Fundamentals</a></h4>&#13;
<p class="noindent">The goal of this chapter is to introduce the fundamentals of the Go programming language and provide a foundation necessary for understanding the concepts within this book. This includes an abridged review of basic Go syntax and idioms. We discuss the Go ecosystem, including supporting tools, IDEs, dependency management, and more. Readers new to the programming language can expect to learn the bare necessities of Go, which will allow them to, hopefully, comprehend, implement, and extend the examples in later chapters.</p>&#13;
<h4 class="h4"><a href="ch02.xhtml">Chapter 2: TCP, Scanners, and Proxies</a></h4>&#13;
<p class="noindent">This chapter introduces basic Go concepts and concurrency primitives and patterns, input/output (I/O), and the use of interfaces through practical TCP applications. We’ll first walk you through creating a simple TCP port <span epub:type="pagebreak" id="page_xxiii"/>scanner that scans a list of ports using parsed command line options. This will highlight the simplicity of Go code compared to other languages and will develop your understanding of basic types, user input, and error handling. Next, we’ll discuss how to improve the efficiency and speed of this port scanner by introducing concurrent functions. We’ll then introduce I/O by building a TCP proxy—a port forwarder—starting with basic examples and refining our code to create a more reliable solution. Lastly, we’ll re-create Netcat’s “gaping security hole” feature in Go, teaching you how to run operating system commands while manipulating stdin and stdout and redirecting them over TCP.</p>&#13;
<h4 class="h4"><a href="ch03.xhtml">Chapter 3: HTTP Clients and Remote Interaction with Tools</a></h4>&#13;
<p class="noindent">HTTP clients are a critical component to interacting with modern web server architectures. This chapter shows you how to create the HTTP clients necessary to perform a variety of common web interactions. You’ll handle a variety of formats to interact with Shodan and Metasploit. We’ll also demonstrate how to work with search engines, using them to scrape and parse document metadata so as to extract information useful for organizational profiling activities.</p>&#13;
<h4 class="h4"><a href="ch04.xhtml">Chapter 4: HTTP Servers, Routing, and Middleware</a></h4>&#13;
<p class="noindent">This chapter introduces the concepts and conventions necessary for creating an HTTP server. We’ll discuss common routing, middleware, and templating patterns, leveraging this knowledge to create a credential harvester and keylogger. Lastly, we’ll demonstrate how to multiplex command-and-control (C2) connections by building a reverse HTTP proxy.</p>&#13;
<h4 class="h4"><a href="ch05.xhtml">Chapter 5: Exploiting DNS</a></h4>&#13;
<p class="noindent">This chapter introduces you to basic DNS concepts using Go. First, we’ll perform client operations, including how to look for particular domain records. Then we’ll show you how to write a custom DNS server and DNS proxy, both of which are useful for C2 operations.</p>&#13;
<h4 class="h4"><a href="ch06.xhtml">Chapter 6: Interacting with SMB and NTLM</a></h4>&#13;
<p class="noindent">We’ll explore the SMB and NTLM protocols, using them as a basis for a discussion of protocol implementations in Go. Using a partial implementation of the SMB protocol, we’ll discuss the marshaling and unmarshaling of data, the usage of custom field tags, and more. We’ll discuss and demonstrate how to use this implementation to retrieve the SMB-signing policy, as well as perform password-guessing attacks.</p>&#13;
<h4 class="h4"><a href="ch07.xhtml">Chapter 7: Abusing Databases and Filesystems</a></h4>&#13;
<p class="noindent">Pillaging data is a critical aspect of adversarial testing. Data lives in numerous resources, including databases and filesystems. This chapter introduces basic ways to connect to and interact with databases across a <span epub:type="pagebreak" id="page_xxiv"/>variety of common SQL and NoSQL platforms. You’ll learn the basics of connecting to SQL databases and running queries. We’ll show you how to search databases and tables for sensitive information, a common technique used during post-exploitation. We’ll also show how to walk filesystems and inspect files for sensitive information.</p>&#13;
<h4 class="h4"><a href="ch08.xhtml">Chapter 8: Raw Packet Processing</a></h4>&#13;
<p class="noindent">We’ll show you how to sniff and process network packets by using the <code>gopacket</code> library, which uses <code>libpcap</code>. You’ll learn how to identify available network devices, use packet filters, and process those packets. We will then develop a port scanner that can scan reliably through various protection mechanisms, including syn-flood and syn-cookies, which cause normal port scans to show excessive false positives.</p>&#13;
<h4 class="h4"><a href="ch09.xhtml">Chapter 9: Writing and Porting Exploit Code</a></h4>&#13;
<p class="noindent">This chapter focuses almost solely on creating exploits. It begins with creating a fuzzer to discover different types of vulnerabilities. The second half of the chapter discusses how to port existing exploits to Go from other languages. This discussion includes a port of a Java deserialization exploit and the Dirty COW privilege escalation exploit. We conclude the chapter with a discussion on creating and transforming shellcode for use within your Go programs.</p>&#13;
<h4 class="h4"><a href="ch10.xhtml">Chapter 10: Go Plugins and Extendable Tools</a></h4>&#13;
<p class="noindent">We’ll introduce two separate methods for creating extendable tools. The first method, introduced in Go version 1.8, uses Go’s native plug-in mechanism. We’ll discuss the use cases for this approach and discuss a second approach that leverages Lua to create extensible tools. We’ll demonstrate practical examples showing how to adopt either approach to perform a common security task.</p>&#13;
<h4 class="h4"><a href="ch11.xhtml">Chapter 11: Implementing and Attacking Cryptography</a></h4>&#13;
<p class="noindent">This chapter covers the fundamental concepts of symmetric and asymmetric cryptography using Go. This information focuses on using and understanding cryptography through the standard Go package. Go is one of the few languages that, instead of using a third-party library for encryption, uses a native implementation within the language. This makes the code easy to navigate, modify, and understand.</p>&#13;
<p class="indent">We’ll explore the standard library by examining common use cases and creating tools. The chapter will show you how to perform hashing, message authentication, and encryption. Lastly, we’ll demonstrate how to brute-force decrypt an RC2-encrypted ciphertext.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_xxv"/><a href="ch12.xhtml">Chapter 12: Windows System Interaction and Analysis</a></h4>&#13;
<p class="noindent">In our discussion on attacking Windows, we’ll demonstrate methods of interacting with the Windows native API, explore the <code>syscall</code> package in order to perform process injection, and learn how to build a Portable Executable (PE) binary parser. The chapter will conclude with a discussion of calling native C libraries through Go’s C interoperability mechanisms.</p>&#13;
<h4 class="h4"><a href="ch13.xhtml">Chapter 13: Hiding Data with Steganography</a></h4>&#13;
<p class="noindent"><em>Steganography</em> is the concealment of a message or file within another file. This chapter introduces one variation of steganography: hiding arbitrary data within a PNG image file’s contents. These techniques can be useful for exfiltrating information, creating obfuscated C2 messages, and bypassing detective or preventative controls.</p>&#13;
<h4 class="h4"><a href="ch14.xhtml">Chapter 14: Building a Command-and-Control RAT</a></h4>&#13;
<p class="noindent">The final chapter discusses practical implementations of command-and-control (C2) implants and servers in Go. We’ll leverage the wisdom and knowledge gained in previous chapters to build a C2 channel. The C2 client/server implementation will, by nature of being custom-made, avoid signature-based security controls and attempt to circumvent heuristics and network-based egress controls.<span epub:type="pagebreak" id="page_xxvi"/></p>&#13;
</div>



  </body></html>