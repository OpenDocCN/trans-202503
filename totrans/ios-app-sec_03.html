<html><head></head><body>
<h2 class="h2" id="ch02"><a id="page_13"/><strong><span class="big">2</span></strong><br/><strong>OBJECTIVE-C FOR THE LAZY</strong></h2>
<p class="noindent">Objective-C has been met with both derision and adulation during its illustrious career. Brought to popularity by NeXTStep and inspired by the design of Smalltalk, Objective-C is a superset of C. Its most notable characteristics are the use of infix notation and absurdly long class names. People tend to either love it or hate it. People who hate it are wrong.</p>
<p class="indent">In this chapter, I’ll go over the basics of Objective-C, assuming that you’re already familiar with programming in some language or another. Know, however, that Cocoa and Objective-C are constantly changing. I can’t cover all of their finer details adequately in a single chapter, but I do include some hints here to help nondevelopers get their bearings when examining Objective-C code. If you’re starting from very little programming knowledge, you may wish to check out a book like Knaster, Malik, and Dalrymple’s <em>Learn Objective-C on the Mac: For OS X and iOS</em> (Apress, 2012) before you dig in.</p>
<p class="indent">As much as I’d like to stick with the most modern coding patterns of Objective-C, if you’re auditing existing code, you may come across plenty of crusty, reused code from the early days of iOS. So just in case, I’ll go over both historical Objective-C constructs and the newly sanctioned versions.</p>
<h3 class="h3" id="ch02lev1sec01"><a id="page_14"/><strong>Key iOS Programming Terminology</strong></h3>
<p class="noindent">There are a few terms you’ll want to be familiar with to understand where Apple’s various APIs come from. <em>Cocoa</em> is the general term for the frameworks and APIs that are used in Objective-C GUI programming. <em>Cocoa Touch</em> is a superset of Cocoa, with some added mobile-related APIs such as dealing with gestures and mobile GUI elements. <em>Foundation</em> classes are Objective-C classes that make up much of what we call the Cocoa API. <em>Core Foundation</em> is a lower-level C-based library upon which many Foundation classes are based, usually prefixed with <span class="literal">CF</span> instead of <span class="literal">NS</span>.</p>
<h3 class="h3" id="ch02lev1sec02"><strong>Passing Messages</strong></h3>
<p class="noindent">The first key to grokking Objective-C is understanding that the language is designed around the concept of <em>message passing</em>, rather than <em>calling</em>. It’s useful (for me, anyway) to think of Objective-C as a language where objects sit around shouting at each other in a crowded room, rather than a language where hierarchical directors give orders to their subordinates. This analogy especially makes sense in the context of delegates, which I’ll get to shortly.</p>
<p class="indent">At its most basic, sending Objective-C messages looks like this:</p>
<p class="programs">[<span class="codeitalic">Object</span> <span class="violet">doThisThingWithValue</span>:<span class="codeitalic">myValue</span>];</p>
<p class="indent">That’s like saying, “Hey there, <span class="literal"><em>Object</em></span>! Please do this thing using a value of <span class="literal"><em>myValue</em></span>.” When passing in multiple parameters, the nature of the first one is conventionally indicated by the message name. Any subsequent parameters must be both defined as part of the class and specifically named when called, as in this example:</p>
<p class="programs"><span class="rose">if</span> (pantsColor == <span class="red">@"Black</span>") {<br/><br/>    [<span class="violet1">NSHouseCat</span> sleepOnPerson:person<br/>                   withRegion:[person lap]<br/>                  andShedding:YES<br/>                      retries:INT_MAX];<br/>}</p>
<p class="indent">In this simplified simulation of catnapping under certain conditions, <span class="literal">sleepOnPerson</span> specifies a place to sleep (<span class="literal">person</span>), and <span class="literal">withRegion</span> specifies the region of the person to sleep on by sending <span class="literal">person</span> a message returning that person’s <span class="literal">lap</span>. The <span class="literal">andShedding</span> parameter accepts a Boolean, and <span class="literal">retries</span> specifies the number of times this action will be attempted—in this case, up to the maximum value of an integer on a platform, which will vary depending on whether you have a 64-bit cat.</p>
<p class="indent">If you’ve been writing Objective-C for a while, you may notice that the formatting of this code looks different than what you’re used to. That’s because this is an arcane method of formatting Objective-C code, known <a id="page_15"/>as “the correct way,” with vertically aligned colons between argument names and values. This keeps the pairings between parameter names and values visually obvious.</p>
<h3 class="h3" id="ch02lev1sec03"><strong>Dissecting an Objective-C Program</strong></h3>
<p class="noindent">The two main parts of an Objective-C program are the <em>interface</em> and the <em>implementation</em>, stored in <em>.h</em> and <em>.m</em> files, respectively. (These are roughly analogous in purpose to <em>.h</em> and <em>.cpp</em> files in C++.) The former defines all of the classes and methods, while the latter defines the actual meat and logic of your program.</p>
<h4 class="h4" id="ch02lev2sec01"><em><strong>Declaring an Interface</strong></em></h4>
<p class="noindent">Interfaces contain three main components: instance variables (or <em>ivars</em>), class methods, and instance methods. <a href="ch02.html#ch2ex1">Listing 2-1</a> is the classic (that is, deprecated) Objective-C 1.0 way to declare your interfaces.</p>
<p class="programs">   <span class="rose">@interface</span> <span class="green">Classname</span> : <span class="violet1">NSParentClass</span> {<br/><span class="ent">➊</span>     <span class="violet1">NSSomeType</span> aThing;<br/>       <span class="rose">int</span> anotherThing;<br/>   }<br/><span class="ent">➋</span> + (type)<span class="violet">classMethod</span>:(vartype)myVariable;<br/><span class="ent">➌</span> - (type)<span class="violet">instanceMethod</span>:(vartype)myVariable;<br/>   <span class="rose">@end</span></p>
<p class="listcap"><a id="ch2ex1"/><em>Listing 2-1: Declaring an interface, archaic version</em></p>
<p class="indent">Inside the main <span class="literal">@interface</span> block at <span class="ent">➊</span>, instance variables are declared with a class (like <span class="literal">NSSomeType</span>) or a type (like <span class="literal">int</span>), followed by their name. In Objective-C, a <span class="literal">+</span> denotes the declaration of a class method <span class="ent">➋</span>, while a <span class="literal">-</span> indicates an instance method <span class="ent">➌</span>. As with C, the return type of a method is specified in parentheses at the beginning of the definition.</p>
<p class="indent">Of course, the modern way of declaring interfaces in Objective-C is a little different. <a href="ch02.html#ch2ex2">Listing 2-2</a> shows an example.</p>
<p class="programs"><span class="ent">➊</span> <span class="rose">@interface</span> <span class="green">Kitty</span> : <span class="violet1">NSObject</span> {<br/>       <span class="rose">@private</span> <span class="violet1">NSString</span> *name;<br/>       <span class="rose">@private</span> <span class="violet1">NSURL</span> *homepage;<br/>       <span class="rose">@public</span> <span class="violet1">NSString</span> *color;<br/>   }<br/><br/>   <span class="rose">@property</span> <span class="violet1">NSString</span> *name;<br/>   <span class="rose">@property</span> <span class="violet1">NSURL</span> *homepage;<br/><span class="ent">➋</span> <span class="rose">@property</span>(readonly) <span class="violet1">NSString</span> *color;<br/><br/>   + (type)<span class="violet">classMethod</span>:(vartype)myVariable;<br/>   - (type)<span class="violet">instanceMethod</span>:(vartype)myVariable;</p>
<p class="listcap"><a id="page_16"/><a id="ch2ex2"/><em>Listing 2-2: Declaring an interface, modern version</em></p>
<p class="indent">This new class, called <span class="literal">Kitty</span>, inherits from <span class="literal">NSObject</span> <span class="ent">➊</span>. <span class="literal">Kitty</span> has three instance variables of different accessibility types, and three properties are declared to match those instance variables. Notice that <span class="literal">color</span> is declared <span class="literal">readonly</span> <span class="ent">➋</span>; that’s because a <span class="literal">Kitty</span> object’s color should never change. This means when the property is synthesized, only a getter method will be created, instead of both a getter and a setter. <span class="literal">Kitty</span> also has a pair of methods: one class method and one instance method.</p>
<p class="indent">You may have noticed that the example interface declaration used the <span class="literal">@private</span> and <span class="literal">@public</span> keywords when declaring instance variables. Similar to other languages, these keywords define whether ivars will be accessible from within only the class that declared it (<span class="literal">@private</span>), accessible from within the declaring class and any subclasses (<span class="literal">@protected</span>), or accessible by any class (<span class="literal">@public</span>). The default behavior of ivars is <span class="literal">@protected</span>.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Newcomers to the language often want to know whether there is an equivalent to private methods. Strictly speaking, there isn’t a concept of private methods in Objective-C. However, you can have the functional equivalent by declaring your methods only in the</em> <span class="literal"><em>@implementation</em></span> <em>block instead of declaring them in both the</em> <span class="literal"><em>@interface</em></span> <em>and the</em> <span class="literal"><em>@implementation</em></span>.</p>
</div>
<h4 class="h4" id="ch02lev2sec02"><em><strong>Inside an Implementation File</strong></em></h4>
<p class="noindent">Just like <em>.c</em> or <em>.cpp</em> files, Objective-C implementation files contain the meat of an Objective-C application. By convention, Objective-C files use <em>.m</em> files, while Objective-C++ files (which mix C++ and Objective-C code) are stored in <em>.mm</em> files. <a href="ch02.html#ch2ex3">Listing 2-3</a> breaks down the implementation file for the <span class="literal">Kitty</span> interface in <a href="ch02.html#ch2ex2">Listing 2-2</a>.</p>
<p class="programs">   <span class="rose">@implementation</span> <span class="green">Kitty</span><br/><span class="ent">➊</span> <span class="rose">@synthesize</span> name;<br/>   <span class="rose">@synthesize</span> color;<br/>   <span class="rose">@synthesize</span> homepage;<br/><br/>   + (type)<span class="violet">classMethod</span>:(vartype)myVariable {<br/>       <span class="green1"><span class="codeitalic">// method logic</span></span><br/>   }<br/><br/>   - (type)<span class="violet">instanceMethod</span>:(vartype)myVariable {<br/>       <span class="green1"><span class="codeitalic">// method logic</span></span><br/>   }<br/>   <span class="rose">@end</span><br/><br/>   <span class="green">Kitty</span> *myKitty = [[<span class="green">Kitty</span> <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><br/><span class="ent">➋</span> [myKitty <span class="violet">setName</span>:<span class="red">@"Ken"</span>];<br/><span class="ent">➌</span> myKitty.homepage = [[<span class="violet1">NSURL</span> <span class="violet">alloc</span>] <span class="violet">initWithString</span>:<span class="red">@"http://me.ow"</span>];</p>
<p class="listcap"><a id="ch2ex3"/><em>Listing 2-3: A sample implementation</em></p>
<p class="indent"><a id="page_17"/>The <span class="literal">@synthesize</span> statements at <span class="ent">➊</span> create the setter and getter methods for the properties. Later, these getter and setter methods can be used either with Objective-C’s traditional infix notation <span class="ent">➋</span>, where methods of the format <span class="literal"><em>propertyName</em></span> and <span class="literal"><em>setPropertyName</em></span> (like <span class="literal">name</span> and <span class="literal">setName</span>, respectively) get and set values, or with dot notation <span class="ent">➌</span>, where properties like <span class="literal">homepage</span> are set or read using the <span class="literal"><em>.property</em></span> format, as they might be in other languages.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Be careful with dot notation, or just don’t use it. Dot notation makes it hard to know whether you’re dealing with an object or a C struct, and you can actually call</em> any <em>method with it—not only getters and setters. Dot notation is also just visually inconsistent. Long story short, in this book I’ll avoid dot notation in the name of consistency and ideological purity. But despite my best efforts, you’ll likely encounter it in the real world anyway.</em></p>
</div>
<p class="indent">Technically, you don’t need to synthesize properties that are declared in the interface file with <span class="literal">@property</span>, like <span class="literal">name</span>, <span class="literal">color</span>, and <span class="literal">homepage</span> in <a href="ch02.html#ch2ex3">Listing 2-3</a>; the compiler in recent versions of Xcode synthesizes these properties on its own. But you may want to manually declare them anyway for clarity or when you want to change the name of the instance variable to differentiate it from the property name. Here’s how manually synthesizing a property works:</p>
<p class="programs"><span class="rose">@synthesize</span> name = thisCatName;</p>
<p class="indent">Here, the property <span class="literal">name</span> is backed by the instance variable <span class="literal">thisCatName</span> because it was manually synthesized. However, the default behavior with automatic property synthesis is analogous to this:</p>
<p class="programs"><span class="rose">@synthesize</span> name = _name;</p>
<p class="indent">This default behavior prevents developers from accidentally meddling with the instance variables directly, instead of using setters and getters, which can cause confusion. For example, if you set an ivar directly, you’ll be bypassing any logic in your setter/getter methods. Automatic synthesis is probably the best way to do things, but you’ll be seeing manual synthesis in code for a long time to come, so it’s best to be aware of it.</p>
<h3 class="h3" id="ch02lev1sec04"><a id="page_18"/><strong>Specifying Callbacks with Blocks</strong></h3>
<p class="noindent">One thing that’s becoming increasingly popular in Objective-C code is the use of <em>blocks</em>, which are often used in Cocoa as a way to specify a callback. For example, here’s how you’d use the <span class="literal">dataTaskWithRequest</span> method of the <span class="literal">NSURLSessionDataTask</span> class:</p>
<p class="programs">   <span class="violet1">NSURLSession</span> *session = [<span class="violet1">NSURLSession</span> <span class="violet">sessionWithConfiguration</span>:configuration<br/>                                                         delegate:<span class="rose">self</span><br/>                                                    delegateQueue:nil];<br/><br/>   <span class="violet1">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request<br/>                                           <span class="violet">completionHandler</span>:<br/><span class="ent">➊</span>     ^(<span class="violet1">NSData</span> *data, <span class="violet1">NSURLResponse</span> *response, <span class="violet1">NSError</span> *error) {<br/>               <span class="violet1">NSLog(</span><span class="red">@"Error: %@ %@"</span><span class="violet1">,</span> error, [error userInfo]);<br/>        }];</p>
<p class="indent">The <span class="literal">^</span> at <span class="ent">➊</span> is declaring a block that will be executed once the request is complete. Note that no name is specified for this function because it won’t be called from anywhere other than this bit of code. A block declaration just needs to specify the parameters that the closure will take. From there, the rest of the block is just like a normal function. You can use blocks for tons of other things as well, but to start with, it’s probably sufficient to have a basic understanding of what they are: things that begin with <span class="literal">^</span> and do stuff.</p>
<h3 class="h3" id="ch02lev1sec05"><strong>How Objective-C Manages Memory</strong></h3>
<p class="noindent">Unlike some other languages, Objective-C does not have any garbage collection. Historically, Objective-C has used a <em>reference counting model</em>, using the <span class="literal">retain</span> and <span class="literal">release</span> directives to indicate when an object needs to be freed, to avoid memory leaks. When you <span class="literal">retain</span> an object, you increase the <em>reference count</em>—that is, the number of things that want that object to be available to them. When a piece of code no longer needs an object, it sends it a <span class="literal">release</span> method. When the reference count reaches zero, the object is deallocated, as in this example:</p>
<p class="programs"><span class="ent">➊</span> <span class="violet1">NSFish</span> *fish = [[<span class="violet1">NSFish</span> <span class="violet">alloc</span>] <span class="violet">init</span>];<br/>   <span class="violet1">NSString</span> *fishName = [fish name];<br/><span class="ent">➋</span> [fish <span class="violet">release</span>];</p>
<p class="indent">Assume that before this code runs, the reference count is 0. After <span class="ent">➊</span>, the reference count is 1. At <span class="ent">➋</span>, the <span class="literal">release</span> method is called to say that the <span class="literal">fish</span> object is no longer needed (the application just needs the <span class="literal">fish</span> object’s <span class="literal">name</span> property), and when <span class="literal">fish</span> is released, the reference count should be 0 again.</p>
<p class="indent"><a id="page_19"/>The <span class="literal">[[Classname alloc] init]</span> can also be shortened to <span class="literal">[Classname new]</span>, but the <span class="literal">new</span> method isn’t favored by the Objective-C community because it’s less explicit and is inconsistent with methods of object creation other than <span class="literal">init</span>. For example, you can initialize <span class="literal">NSString</span> objects with <span class="literal">[[NSString alloc] initWithString:@"My string"]</span>, but there’s no equivalent <span class="literal">new</span> syntax, so your code would end up having a mix of both methods. Not everyone is averse to <span class="literal">new</span>, and it’s really a matter of taste, so you’re likely to see it both ways. But in this book, I’ll favor the traditional approach.</p>
<p class="indent">Regardless of which allocation syntax you prefer, the problem with a manual retain/release is that it introduced the possibility of errors: programmers could accidentally release objects that had already been deallocated (causing a crash) or forget to release objects (causing a memory leak). Apple attempted to simplify the situation with automatic reference counting.</p>
<h3 class="h3" id="ch02lev1sec06"><strong>Automatic Reference Counting</strong></h3>
<p class="noindentb"><em>Automatic reference counting (ARC)</em> is the modern method of Objective-C memory management. It removes the need for manually tracking reference counts by automatically incrementing and decrementing the retain count where appropriate.<sup><a href="footnote.html#fn14" id="fn_14">1</a></sup> Essentially, it inserts <span class="literal">retain</span> and <span class="literal">release</span> methods for you. ARC introduces a few new concepts, listed here:</p>
<p class="bull">• <em>Weak</em> and <em>strong</em> references assist in preventing cyclical references (referred to as <em>strong reference cycles</em>), where a parent object and child object both have ownership over each other and never get deallocated.</p>
<p class="bull">• Object ownership between Core Foundation objects and Cocoa objects can be bridged. Bridging tells the compiler that Core Foundation objects that are cast to Cocoa objects are to be managed by ARC, by using the <span class="literal">__bridge</span> family of keywords.</p>
<p class="bull">• <span class="literal">@autoreleasepool</span> replaces the previously used <span class="literal">NSAutoReleasePool</span> mechanism.</p>
<p class="indentt">In modern Cocoa applications with ARC, the details of memory management are unlikely to come into play in a security context. Previously exploitable conditions such as double-releases are no longer a problem, and memory-management-related crashes are rare. It’s still worth noting that there are other ways to cause memory management problems because <span class="literal">CFRetain</span> and <span class="literal">CFRelease</span> still exist for Core Foundation objects and C <span class="literal">malloc</span> and <span class="literal">free</span> can still be used. I’ll discuss potential memory management issues using these lower-level APIs in <a href="ch11.html#ch11">Chapter 11</a>.</p>
<h3 class="h3" id="ch02lev1sec07"><a id="page_20"/><strong>Delegates and Protocols</strong></h3>
<p class="noindent">Remember how objects “shout at each other in a crowded room” to pass messages? <em>Delegation</em> is a feature that illustrates Objective-C’s message-passing architecture particularly well. Delegates are objects that can receive messages sent during program execution and respond with instructions that influence the program’s behavior.</p>
<p class="indent">To be a delegate, an object must implement some or all methods defined by a <em>delegate protocol</em>, which is an agreed-upon method of communication between a delegator and a delegate. You can declare your own protocols, but most commonly you’ll be using established protocols in the core APIs.</p>
<p class="indent">The delegates you’ll write will typically respond to one of three fundamental message types: <em>should</em>, <em>will</em>, and <em>did</em>. Invoke these messages whenever an event is about to happen and then let your delegates direct your program to the correct course of action.</p>
<h4 class="h4" id="ch02lev2sec03"><em><strong>Should Messages</strong></em></h4>
<p class="noindent">Objects pass <em>should</em> messages to request input from any available delegates on whether letting an event happen is a good idea. Think of this as the final call for objections. For example, when a <span class="literal">shouldSaveApplicationState</span> message is invoked, if you’ve implemented a delegate to handle this message, your delegate can perform some logic and say something like, “No, actually, we shouldn’t save the application state because the user has checked a checkbox saying not to.” These messages generally expect a Boolean as a response.</p>
<h4 class="h4" id="ch02lev2sec04"><em><strong>Will Messages</strong></em></h4>
<p class="noindent">A <em>will</em> message gives you the chance to perform some action before an event occurs—and, sometimes, to put the brakes on before it does. This message type is more like saying, “Hey guys! Just an FYI, but I’m going to go do this thing, unless you need to do something else first. I’m pretty committed to the idea, but if it’s a total deal-breaker, let me know and I can stop.” An example would be the <span class="literal">applicationWillTerminate</span> message.</p>
<h4 class="h4" id="ch02lev2sec05"><em><strong>Did Messages</strong></em></h4>
<p class="noindent">A <em>did</em> message indicates that something has been decided for sure and an event is going to happen whether you like it or not. It also indicates that if any delegates want to do some stuff as a result, they should go right ahead. An example would be <span class="literal">applicationDidEnterBackground</span>. In this case, did isn’t really an indication that the application <em>has</em> entered the background, but it’s a reflection of the decision being definitively made.</p>
<h4 class="h4" id="ch02lev2sec06"><a id="page_21"/><em><strong>Declaring and Conforming to Protocols</strong></em></h4>
<p class="noindent">To declare that your class conforms to a protocol, specify that protocol in your <span class="literal">@interface</span> declaration within angle brackets. To see this in action, look at <a href="ch02.html#ch2ex4">Listing 2-4</a>, which shows an example <span class="literal">@interface</span> declaration that uses the NSCoding protocol. This protocol simply specifies that a class implements two methods used to encode or decode data: <span class="literal">encodeWithCoder</span> to encode data and <span class="literal">initWithCoder</span> to decode data.</p>
<p class="programs"><span class="ent">➊</span> <span class="rose">@interface</span> <span class="green">Kitty</span> : <span class="violet1">NSObject</span> <span class="violet1">&lt;NSCoding&gt;</span> {<br/>       <span class="rose">@private</span> <span class="violet1">NSString</span> *name;<br/>       <span class="rose">@private</span> <span class="violet1">NSURL</span> *homepage;<br/>       <span class="rose">@public</span> <span class="violet1">NSString</span> *color;<br/>   }<br/><br/>   <span class="rose">@implementation</span> <span class="green">Kitty</span><br/><br/><span class="ent">➋</span> - (<span class="rose">id</span>)<span class="violet">initWithCoder</span>:(<span class="violet1">NSCoder</span> *)decoder {<br/>       <span class="rose">self</span> = [<span class="rose">super</span> <span class="violet">init</span>];<br/>       <span class="rose">if</span> (<span class="rose">!self</span>) {<br/>           <span class="rose">return</span> nil;<br/>       }<br/><br/>       [<span class="rose">self</span> <span class="violet">setName</span>:[decoder <span class="violet">decodeObjectForKey</span>:<span class="red">@"name"</span>]];<br/>       [<span class="rose">self</span> <span class="violet">setHomepage</span>:[decoder <span class="violet">decodeObjectForKey</span>:<span class="red">@"homepage"</span>]];<br/>       [<span class="rose">self</span> <span class="violet">setColor</span>:[decoder <span class="violet">decodeObjectForKey</span>:<span class="red">@"color"</span>]];<br/><br/>       <span class="rose">return self</span>;<br/>   }<br/><br/><span class="ent">➌</span> - (<span class="rose">void</span>)<span class="violet">encodeWithCoder</span>:(<span class="violet1">NSCoder</span> *)encoder {<br/>       [encoder <span class="violet">encodeObject</span>:[<span class="rose">self</span> name] forKey:<span class="red">@"name"</span>];<br/>       [encoder <span class="violet">encodeObject</span>:[<span class="rose">self</span> author] forKey:<span class="red">@"homepage"</span>];<br/>       [encoder <span class="violet">encodeObject</span>:[<span class="rose">self</span> pageCount] forKey:<span class="red">@"color"</span>];<br/>   }</p>
<p class="listcap"><a id="ch2ex4"/><em>Listing 2-4: Declaring and implementing conformance to the NSCoding protocol</em></p>
<p class="indent">The declaration at <span class="ent">➊</span> specifies that the <span class="literal">Kitty</span> class will be conforming to the NSCoding protocol.<sup><a href="footnote.html#fn15" id="fn_15">2</a></sup> When a class declares a protocol, however, it must also conform to it, which is why <span class="literal">Kitty</span> implements the required <span class="literal">initWithCoder</span> <span class="ent">➋</span> and <span class="literal">encodeWithCoder</span> <span class="ent">➌</span> methods. These particular methods are used to serialize and deserialize objects.</p>
<p class="indent"><a id="page_22"/>If none of the built-in message protocols do what you need, then you can also define your own protocols. Check out the declaration of the NSCoding protocol in Apple’s Framework header files (<a href="ch02.html#ch2ex5">Listing 2-5</a>) to see what a protocol definition looks like.</p>
<p class="programs"><span class="rose">@protocol</span> <span class="violet1">NSCoding</span><br/><br/><span class="violet1">-</span> (<span class="rose">void</span>)<span class="violet">encodeWithCoder</span>:(<span class="violet1">NSCoder</span> *)aCoder;<br/>- (<span class="rose">id</span>)<span class="violet">initWithCoder</span>:(<span class="violet1">NSCoder</span> *)aDecoder;<br/><br/><span class="rose">@end</span></p>
<p class="listcap"><a id="ch2ex5"/><em>Listing 2-5: The declaration of the NSCoding protocol, from</em> Frameworks/NSCoding.h</p>
<p class="indent">Notice that the NSCoding definition contains two methods that any class conforming to this protocol must implement: <span class="literal">encodeWithCoder</span> and <span class="literal">initWithCoder</span>. When you define a protocol, you must specify those methods yourself.</p>
<h3 class="h3" id="ch02lev1sec08"><strong>The Dangers of Categories</strong></h3>
<p class="noindent">Objective-C’s <em>category</em> mechanism allows you to implement new methods on existing classes at runtime, without having to recompile those classes. Categories can add or replace methods in the affected class, and they can appear anywhere in the codebase. It’s an easy way to quickly change the behavior of a class without having to reimplement it.</p>
<p class="indent">Unfortunately, using categories is also an easy way to make egregious security mistakes. Because they can affect your classes from anywhere within the codebase—even if they appear only in third-party code—critical functionality, such as TLS endpoint validation, can be completely overridden by a random third-party library or a careless developer. I’ve seen this happen in important iOS products before: after carefully verifying that TLS/SSL works correctly in their application, developers include a third-party library that overrides that behavior, messing up their own properly designed code.</p>
<p class="indent">You can usually spot categories by noting <span class="literal">@implementation</span> directives that purport to implement classes already present in Cocoa Touch. If a developer was actually creating a category there, then the name of the category would follow the <span class="literal">@implementation</span> directive in parentheses (see <a href="ch02.html#ch2ex6">Listing 2-6</a>).</p>
<p class="programs"><span class="rose">@implementation</span> <span class="violet1">NSURL</span> (<span class="codeitalic">CategoryName</span>)<br/><br/>- (<span class="rose">BOOL</span>) <span class="violet">isPurple</span>; {<br/>    <span class="rose">if</span> ([<span class="rose">self</span> <span class="violet">isColor</span>:<span class="red">@"purple"</span>])<br/>        <span class="rose">return</span> YES;<br/>    <span class="rose">else</span><br/>        <span class="rose">return</span> NO;<br/>}<br/><span class="rose">@end</span></p>
<p class="listcap"><a id="ch2ex6"/><em>Listing 2-6: Implementing a category method</em></p>
<p class="indent"><a id="page_23"/>You can also use categories to override <em>existing</em> class methods, which is a potentially useful but particularly dangerous approach. This can cause security mechanisms to be disabled (such as the aforementioned TLS validation) and can also result in unpredictable behavior. Quoth Apple:</p>
<div class="blockquote">
<p class="noindent">If the name of a method declared in a category is the same as a method in the original class, or a method in another category on the same class (or even a superclass), the behavior is undefined as to which method implementation is used at runtime.</p>
</div>
<p class="indent">In other words, multiple categories can define or overwrite the same method, but only one will “win” and be called. Note that some Framework methods may themselves be implemented via a category—if you attempt to override them, your category <em>might</em> be called, but it might not.</p>
<p class="indent">A category may also accidentally override the functionality of subclasses, even when you only meant for it to add a new method. For example, if you were to define an <span class="literal">isPurple</span> method on <span class="literal">NSObject</span>, all subclasses of <span class="literal">NSObject</span> (which is to say, all Cocoa objects) would inherit this method. Any other class that defined a method with the same name might or might not have its method implementation clobbered. So, yes, categories are handy, but use them sparingly; they can cause serious confusion as well as security side effects.</p>
<h3 class="h3" id="ch02lev1sec09"><strong>Method Swizzling</strong></h3>
<p class="noindent"><em>Method swizzling</em> is a mechanism by which you can replace the implementation of a class or instance method that you don’t own (that is, a method provided by the Cocoa API itself). Method swizzling can be functionally similar to categories or subclassing, but it gives you some extra power and flexibility by actually swapping the implementation of a method with a totally new implementation, rather than extending it. Developers typically use this technique to augment functionality of a method that’s used by many different subclasses so they don’t have to duplicate code.</p>
<p class="indent">The code in <a href="ch02.html#ch2ex7">Listing 2-7</a> uses method swizzling to add a logging statement to any call of <span class="literal">setHidden</span>. This will affect any subclass of <span class="literal">UIView</span>, including <span class="literal">UITextView</span>, <span class="literal">UITextField</span>, and so forth.</p>
<p class="programs"><a id="page_24"/>   <span class="brown">#import &lt;objc/runtime.h&gt;</span><br/><br/>   <span class="rose">@implementation</span> <span class="violet1">UIView(Loghiding)</span><br/><br/><span class="ent">➊</span> <span class="violet1">-</span> (<span class="rose">BOOL</span><span class="violet1">)</span><span class="violet">swizzled_setHidden</span> <span class="violet1">{</span><br/>       <span class="violet1">NSLog(</span><span class="red">@"We're calling setHidden now!"</span><span class="violet1">);</span><br/><br/><span class="ent">➋</span>     <span class="rose">BOOL</span> <span class="violet1">result =</span> [<span class="rose">self</span> <span class="violet">swizzled_setHidden</span><span class="violet1">];</span><br/><br/>       <span class="rose">return</span> <span class="violet1">result;<br/>   }</span><br/><br/><span class="ent">➌</span> <span class="violet1">+</span> (<span class="rose">void</span><span class="violet1">)load {</span><br/>       <span class="violet1">Method original_setHidden;</span><br/>       <span class="violet1">Method</span> <span class="violet">swizzled_setHidden</span><span class="violet1">;</span><br/><br/>       <span class="violet1">original_setHidden = class_getInstanceMethod(</span><span class="rose">self</span><span class="violet1">,</span> <span class="rose">@selector</span><span class="violet1">(</span><span class="violet">setHidden</span><span class="violet1">));</span><br/>       <span class="violet">swizzled_setHidden</span> <span class="violet1">= class_getInstanceMethod(</span><span class="rose">self</span><span class="violet1">,</span> <span class="rose">@selector</span><span class="violet1">(swizzled_</span><br/>        <span class="violet">setHidden</span><span class="violet1">));</span><br/><span class="ent">➍</span>     <span class="violet1">method_exchangeImplementations(original_setHidden,</span> <span class="violet">swizzled_setHidde</span><span class="violet1">n);<br/>   }</span><br/><br/>   <span class="rose">@end</span></p>
<p class="listcap"><a id="ch2ex7"/><em>Listing 2-7: Exchanging the implementation of an existing method and a replacement method</em></p>
<p class="indent">At <span class="ent">➊</span>, a wrapper method is defined that simply spits out an <span class="literal">SLog</span> that the <span class="literal">setHidden</span> method is being called. But at <span class="ent">➋</span>, the <span class="literal">swizzle_SetHidden</span> method appears to be calling itself. That’s because it’s considered a best practice to call the original method after performing any added functionality, to prevent unpredictable behavior like failing to return the type of value the caller would expect. When you call <span class="literal">swizzled_setHidden</span> from within itself, it actually calls the <em>original</em> method because the original method and the replacement method have already been swapped.</p>
<p class="indent">The actual swapping is done in the <span class="literal">load</span> class method <span class="ent">➌</span>, which is called by the Objective-C runtime when loading the class for the first time. After the references to the original and swizzled methods are obtained, the <span class="literal">method_exchangeImplementations</span> method is called at <span class="ent">➍</span>, which, as the name implies, swaps the original implementation for the swizzled one.</p>
<p class="indent">There are a few different strategies for implementing method swizzling, but most of them carry some risk since you’re mucking around with core functionality.</p>
<p class="indent"><a id="page_25"/>If you or a loved one want to implement method swizzling, you may want to consider using a fairly well-tested wrapper package, such as JRSwizzle.<sup><a href="footnote.html#fn16" id="fn_16">3</a></sup> Apple may reject applications that appear to use method swizzling in a dangerous way.</p>
<h3 class="h3" id="ch02lev1sec10"><strong>Closing Thoughts</strong></h3>
<p class="noindent">Overall, Objective-C and the Cocoa API are nicely high-level and prevent a number of classic security issues in C. While there are still several ways to mess up memory management and object manipulation, most of these methods result in a denial of service at worst in modern code. If you’re a developer, rely on Cocoa as much as possible, rather than patching in C or C++ code.</p>
<p class="indent">Objective-C does, however, contain some mechanisms, such as categories or swizzling, that can cause unexpected behavior, and these mechanisms can affect your codebase widely. Be sure to investigate these techniques when you see them during an app assessment because they can potentially cause some serious security misbehavior.<a id="page_26"/></p>
</body></html>