- en: Chapter 3. MEMORY ACCESS AND ORGANIZATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![MEMORY ACCESS AND ORGANIZATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") and [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") show you how to declare and access simple variables
    in an assembly language program. This chapter fully explains 80x86 memory access.
    You will learn how to efficiently organize your variable declarations to speed
    up access to their data. This chapter will teach you about the 80x86 stack and
    how to manipulate data on the stack. Finally, this chapter will teach you about
    dynamic memory allocation and the *heap*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses several important concepts, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 80x86 memory addressing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexed and scaled-indexed addressing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation by program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data type coercion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 80x86 stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will teach to you make efficient use of your computer's memory
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 The 80x86 Addressing Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 processors let you access memory in many different ways. Until now,
    you've seen only a single way to access a variable, the so-called *displacement-only*
    addressing mode. In this section you'll see some additional ways your programs
    can access memory using 80x86 *memory addressing modes*. The 80x86 memory addressing
    modes provide flexible access to memory, allowing you to easily access variables,
    arrays, records, pointers, and other complex data types. Mastery of the 80x86
    addressing modes is the first step toward mastering 80x86 assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: When Intel designed the original 8086 processor, it provided the processor with
    a flexible, though limited, set of memory addressing modes. Intel added several
    new addressing modes when it introduced the 80386 microprocessor. However, in
    32-bit environments like Windows, Mac OS X, FreeBSD, and Linux, these earlier
    addressing modes are not very useful; indeed, HLA doesn't even support the use
    of these older, 16-bit-only addressing modes. Fortunately, anything you can do
    with the older addressing modes can be done with the new addressing modes. Therefore,
    you won't need to bother learning the old 16-bit addressing modes when writing
    code for today's high-performance operating systems. Do keep in mind, however,
    that if you intend to work under MS-DOS or some other 16-bit operating system,
    you will need to study up on those old addressing modes (see the 16-bit edition
    of this book at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) for details).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 80x86 Register Addressing Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most 80x86 instructions can operate on the 80x86''s general-purpose register
    set. By specifying the name of the register as an operand to the instruction,
    you can access the contents of that register. Consider the 80x86 `mov` (move)
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction copies the data from the *`source`* operand to the *`destination`*
    operand. The 8-bit, 16-bit, and 32-bit registers are certainly valid operands
    for this instruction. The only restriction is that both operands must be the same
    size. Now let''s look at some actual 80x86 `mov` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The registers are the best place to keep variables. Instructions using the registers
    are shorter and faster than those that access memory. Of course, most computations
    require at least one register operand, so the register addressing mode is very
    popular in 80x86 assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 80x86 32-Bit Memory Addressing Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 80x86 provides hundreds of different ways to access memory. This may seem
    like quite a lot at first, but fortunately most of the addressing modes are simple
    variants of one another, so they're very easy to learn. And learn them you should!
    The key to good assembly language programming is the proper use of memory addressing
    modes.
  prefs: []
  type: TYPE_NORMAL
- en: The addressing modes provided by the 80x86 family include displacement-only,
    base, displacement plus base, base plus indexed, and displacement plus base plus
    indexed. Variations on these five forms provide all the different addressing modes
    on the 80x86\. See, from hundreds down to five. It's not so bad after all!
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.1 The Displacement-Only Addressing Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common addressing mode, and the one that's easiest to understand, is
    the *displacement-only* (or *direct*) addressing mode. The displacement-only addressing
    mode consists of a 32-bit constant that specifies the address of the target location.
    Assuming that variable `j` is an `int8` variable appearing at address $8088, the
    instruction `mov( j, al );` loads the AL register with a copy of the byte at memory
    location $8088\. Likewise, if `int8` variable `k` is at address $1234 in memory,
    then the instruction `mov( dl, k );` stores the value in the DL register to memory
    location $1234 (see [Figure 3-1](ch03.html#displacement-only_open_parenthesis_direc
    "Figure 3-1. Displacement-only (direct) addressing mode")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Displacement-only (direct) addressing mode](tagoreillycom20100401nostarchimages577937.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1. Displacement-only (direct) addressing mode
  prefs: []
  type: TYPE_NORMAL
- en: The displacement-only addressing mode is perfect for accessing simple scalar
    variables. This is named the displacement-only addressing mode because a 32-bit
    constant (displacement) follows the `mov` opcode in memory. On the 80x86 processors,
    this displacement is an offset from the beginning of memory (that is, address
    0). The examples in this chapter often access bytes in memory. Don't forget, however,
    that you can also access words and double words on the 80x86 processors by specifying
    the address of their first byte (see [Figure 3-2](ch03.html#accessing_a_word_or_dword_using_the_disp
    "Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing a word or dword using the displacement-only addressing mode](tagoreillycom20100401nostarchimages577939.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.2 The Register-Indirect Addressing Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 80x86 CPUs let you access memory indirectly through a register using the
    *register-indirect* addressing modes. The term *indirect* means that the operand
    is not the actual address, but rather the operand's value specifies the memory
    address to use. In the case of the register-indirect addressing modes, the value
    held in the register is the address of the memory location to access. For example,
    the instruction `mov( eax, [ebx] );` tells the CPU to store EAX's value at the
    location whose address is in EBX (the square brackets around EBX tell HLA to use
    the register-indirect addressing mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are eight forms of this addressing mode on the 80x86\. The following
    instructions are examples of these eight forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These eight addressing modes reference the memory location at the offset found
    in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP,
    respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the register-indirect addressing modes require a 32-bit register.
    You cannot specify a 16-bit or 8-bit register when using an indirect addressing
    mode.^([[34](#ftn.CHP-3-FN-1)]) Technically, you could load a 32-bit register
    with an arbitrary numeric value and access that location indirectly using the
    register-indirect addressing mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately (or fortunately, depending on how you look at it), this will probably
    cause the operating system to generate a protection fault because it's not always
    legal to access arbitrary memory locations. As it turns out, there are better
    ways to load the address of some object into a register; you'll see how to do
    this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The register-indirect addressing modes have many uses. You can use them to access
    data referenced by a pointer, you can use them to step through array data, and,
    in general, you can use them whenever you need to modify the address of a variable
    while your program is running.
  prefs: []
  type: TYPE_NORMAL
- en: The register-indirect addressing mode provides an example of an *anonymous*
    variable. When using a register-indirect addressing mode, you refer to the value
    of a variable by its numeric memory address (e.g., the value you load into a register)
    rather than by the name of the variable—hence the phrase *anonymous variable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides a simple operator that you can use to take the address of a `static`
    variable and put this address into a 32-bit register. This is the `&` (address-of)
    operator (note that this is the same symbol that C/C++ uses for the address-of
    operator). The following example loads the address of variable `j` into EBX and
    then stores EAX''s current value into `j` using a register-indirect addressing
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it would have been easier to store EAX's value directly into `j`
    rather than using two instructions to do this indirectly. However, you can easily
    imagine a code sequence where the program loads one of several different addresses
    into EBX prior to the execution of the `mov( eax, [ebx]);` statement, thus storing
    EAX into one of several different locations depending on the execution path of
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `&` (address-of ) operator is not a general address-of operator like the
    `&` operator in C/C++. You may apply this operator only to static variables.^([[35](#ftn.CHP-3-FN-2)])
    You cannot apply it to generic address expressions or other types of variables.
    In [3.13 Obtaining the Address of a Memory Object](ch03s13.html "3.13 Obtaining
    the Address of a Memory Object"), you will learn about the *load effective address*
    instruction that provides a general solution for obtaining the address of some
    variable in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.3 Indexed Addressing Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The indexed addressing modes use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*`VarName`* is the name of some variable in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: The indexed addressing modes compute an effective address^([[36](#ftn.CHP-3-FN-3)])
    by adding the address of the variable to the value of the 32-bit register appearing
    inside the square brackets. Their sum is the actual memory address the instruction
    accesses. So if *`VarName`* is at address $1100 in memory and EBX contains 8,
    then `mov(`*`VarName`*`[ ebx ], al);` loads the byte at address $1108 into the
    AL register (see [Figure 3-3](ch03.html#indexed_addressing_mode "Figure 3-3. Indexed
    addressing mode")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexed addressing mode](tagoreillycom20100401nostarchimages577941.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3. Indexed addressing mode
  prefs: []
  type: TYPE_NORMAL
- en: The indexed addressing modes are really handy for accessing elements of arrays.
    You will see how to use these addressing modes for that purpose in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.4 Variations on the Indexed Addressing Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two important syntactical variations of the indexed addressing mode.
    Both forms generate the same basic machine instructions, but their syntax suggests
    other uses for these variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first variant uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These examples use only the EBX register. However, you can use any of the other
    32-bit general-purpose registers in place of EBX. This form computes its effective
    address by adding the value in EBX to the specified constant or subtracting the
    specified constant from EBX (see [Figure 3-4](ch03.html#indexed_addressing_mode_using_a_regi
    "Figure 3-4. Indexed addressing mode using a register plus a constant") and [Figure 3-5](ch03.html#indexed_addressing_mode_using_a_regi-id1
    "Figure 3-5. Indexed addressing mode using a register minus a constant")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexed addressing mode using a register plus a constant](tagoreillycom20100401nostarchimages577943.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4. Indexed addressing mode using a register plus a constant
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexed addressing mode using a register minus a constant](tagoreillycom20100401nostarchimages577945.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5. Indexed addressing mode using a register minus a constant
  prefs: []
  type: TYPE_NORMAL
- en: This particular variant of the addressing mode is useful if a 32-bit register
    contains the base address of a multibyte object and you wish to access a memory
    location some number of bytes before or after that location. One important use
    of this addressing mode is accessing fields of a record (or structure) when you
    have a pointer to the record data. This addressing mode is also invaluable for
    accessing automatic (local) variables in procedures (see [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS") for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second variant of the indexed addressing mode is actually a combination
    of the previous two forms. The syntax for this version is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this example uses only the EBX register. You may substitute any
    of the 32-bit general-purpose registers in lieu of EBX in these two examples.
    This particular form is useful when accessing elements of an array of records
    (structures) in an assembly language program (more on that in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES")).
  prefs: []
  type: TYPE_NORMAL
- en: These instructions compute their effective address by adding or subtracting
    the *`constant`* value from *`VarName`*'s address and then adding the value in
    EBX to this result. Note that HLA, not the CPU, computes the sum or difference
    of *`VarName`*'s address and *`constant`*. The actual machine instructions above
    contain a single constant value that the instructions add to the value in EBX
    at runtime. Because HLA substitutes a constant for *`VarName`*, it can reduce
    an instruction of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: to an instruction of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because of the way these addressing modes work, this is semantically equivalent
    to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA will add the two constants together at compile time, effectively producing
    the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there is nothing special about subtraction. You can easily convert
    the addressing mode involving subtraction to addition by simply taking the two's
    complement of the 32-bit constant and then adding this complemented value (rather
    than subtracting the original value).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.5 Scaled-Indexed Addressing Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scaled-indexed addressing modes are similar to the indexed addressing modes
    with two differences: (1) The scaled-indexed addressing modes allow you to combine
    two registers plus a displacement, and (2) the scaled-indexed addressing modes
    let you multiply the index register by a (scaling) factor of 1, 2, 4, or 8\. The
    syntax for these addressing modes is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, *`BaseReg32`* represents any general-purpose 32-bit register,
    *`IndexReg32`* represents any general-purpose 32-bit register except ESP, and
    *`scale`* must be one of the constants 1, 2, 4, or 8.
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between the scaled-indexed addressing modes and the indexed
    addressing modes is the inclusion of the *`IndexReg32`*`*`*`scale`* component.
    These modes compute the effective address by adding in the value of this new register
    multiplied by the specified scaling factor (see [Figure 3-6](ch03.html#scaled-indexed_addressing_mode
    "Figure 3-6. Scaled-indexed addressing mode") for an example involving EBX as
    the base register and ESI as the index register).
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaled-indexed addressing mode](tagoreillycom20100401nostarchimages577947.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6. Scaled-indexed addressing mode
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-6](ch03.html#scaled-indexed_addressing_mode "Figure 3-6. Scaled-indexed
    addressing mode"), suppose that EBX contains $100, ESI contains $20, and *`VarName`*
    is at base address $2000 in memory; then the following instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: will move the byte at address $2184 ($100 + $20*4 + 4) into the AL register.
  prefs: []
  type: TYPE_NORMAL
- en: The scaled-indexed addressing modes are useful for accessing elements of arrays
    whose elements are 2, 4, or 8 bytes each. These addressing modes are also useful
    for access elements of an array when you have a pointer to the beginning of the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.6 Addressing Mode Wrap-up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, believe it or not, you've just learned several hundred addressing modes!
    That wasn't hard now, was it? If you're wondering where all these modes came from,
    just note that the register-indirect addressing mode isn't a single addressing
    mode but eight different addressing modes (involving the eight different registers).
    Combinations of registers, constant sizes, and other factors multiply the number
    of possible addressing modes on the system. In fact, you need only memorize about
    two dozen forms and you've got it made. In practice, you'll use less than half
    the available addressing modes in any given program (and many addressing modes
    you may never use at all). So learning all these addressing modes is actually
    much easier than it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#CHP-3-FN-1)]) Actually, the 80x86 does support addressing modes involving
    certain 16-bit registers, as mentioned earlier. However, HLA does not support
    these modes and they are not useful under 32-bit operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#CHP-3-FN-2)]) The term *static* here indicates a `static`, `readonly`,
    or `storage` object.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#CHP-3-FN-3)]) The effective address is the ultimate address in memory
    that an instruction will access, once all the address calculations are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Runtime Memory Organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operating system like Mac OS X, FreeBSD, Linux, or Windows tends to put different
    types of data into different sections (or segments) of memory. Although it is
    possible to reconfigure memory to your choice by running the linker and specifying
    various parameters, by default Windows loads an HLA program into memory using
    the organization appearing in [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization") (Linux, Mac OS X, and FreeBSD
    are similar, though they rearrange some of the sections).
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA typical runtime memory organization](tagoreillycom20100401nostarchimages577949.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7. HLA typical runtime memory organization
  prefs: []
  type: TYPE_NORMAL
- en: The operating system reserves the lowest memory addresses. Generally, your application
    cannot access data (or execute instructions) at these low addresses. One reason
    the operating system reserves this space is to help trap NULL pointer references.
    If you attempt to access memory location 0, the operating system will generate
    a general protection fault, meaning you've accessed a memory location that doesn't
    contain valid data. Because programmers often initialize pointers to NULL (0)
    to indicate that the pointer is not pointing anywhere, an access of location 0
    typically means that the programmer has made a mistake and has not properly initialized
    a pointer to a legal (non-NULL) value.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining six areas in the memory map hold different types of data associated
    with your program. These sections of memory include the `stack` section, the `heap`
    section, the `code` section, the `readonly` section, the `static` section, and
    the `storage` section. Each of these memory sections correspond to some type of
    data you can create in your HLA programs. Each section is discussed in detail
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 The code Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `code` section contains the machine instructions that appear in an HLA program.
    HLA translates each machine instruction you write into a sequence of one or more
    byte values. The CPU interprets these byte values as machine instructions during
    program execution.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when HLA links your program it tells the system that your program
    can execute instructions in the code segment and you can read data from the code
    segment. Note, specifically, that you cannot write data to the code segment. The
    operating system will generate a general protection fault if you attempt to store
    any data into the code segment.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, machine instructions are nothing more than data bytes. In theory,
    you could write a program that stores data values into memory and then transfers
    control to the data it just wrote, thereby producing a program that writes itself
    as it executes. This possibility produces romantic visions of *Artificial Intelligence*
    programs that modify themselves to produce some desired result. In real life,
    the effect is somewhat less glamorous. Generally, self-modifying programs are
    very difficult to debug because the instructions are constantly changing behind
    the programmer's back. Because most modern operating systems make it very difficult
    to write self-modifying programs, we will not consider them any further in this
    text.
  prefs: []
  type: TYPE_NORMAL
- en: HLA automatically stores the data associated with your machine code into the
    code section. In addition to machine instructions, you can also store data into
    the code section by using the following pseudo-opcodes:^([[37](#ftn.CHP-3-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: '| `byte` | `int8` |'
  prefs: []
  type: TYPE_TB
- en: '| `word` | `int16` |'
  prefs: []
  type: TYPE_TB
- en: '| `dword` | `in32` |'
  prefs: []
  type: TYPE_TB
- en: '| `uns8` | `boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `uns16` | `char` |'
  prefs: []
  type: TYPE_TB
- en: '| `uns32` |   |'
  prefs: []
  type: TYPE_TB
- en: 'The following `byte` statement exemplifies the syntax for each of these pseudo-opcodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If more than one value appears in the list of values after the pseudo-opcode,
    HLA emits each successive value to the code stream. So the first `byte` statement
    above emits 3 bytes to the code stream, the values 0, 1, and 2\. If a string appears
    within a `byte` statement, HLA emits 1 byte of data for each character in the
    string. Therefore, the second byte statement above emits 6 bytes: the characters
    `H`, `e`, `l`, `l`, and `o`, followed by a `0` byte.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the CPU will attempt to treat data you emit to the code stream
    as machine instructions unless you take special care not to allow the execution
    of the data. For example, if you write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: your program will attempt to execute the `0`, `1`, `2`, and `3` byte values
    as machine instructions after executing the `mov`. Unless you know the machine
    code for a particular instruction sequence, sticking such data values into the
    middle of your code will generally crash your program. Typically when you place
    such data in your programs, you'll execute some code that transfers control around
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 The static Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `static` section is where you will typically declare your variables. Although
    the `static` section syntactically appears as part of a program or procedure,
    keep in mind that HLA moves all static variables to the `static` section in memory.
    Therefore, HLA does not sandwich the variables you declare in the `static` section
    between procedures in the `code` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to declaring static variables, you can also embed lists of data
    into the `static` declaration section. You use the same technique to embed data
    into your `static` section that you use to embed data into the `code` section:
    You use the `byte`, `word`, `dword`, `uns32`, and so on pseudo-opcodes. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Data that HLA writes to the `static` memory segment using these pseudo-opcodes
    is written to the segment after the preceding variables. For example, the byte
    values `1`, `2`, and `3` are emitted to the `static` section after `b`'s `0` byte.
    Because there aren't any labels associated with these values, you do not have
    direct access to these values in your program. You can use the indexed addressing
    modes to access these extra values (examples appear in [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES")).
  prefs: []
  type: TYPE_NORMAL
- en: In the examples above, note that the `c` and `bn` variables do not have an (explicit)
    initial value. However, if you don't provide an initial value, HLA will initialize
    the variables in the `static` section to all 0 bits, so HLA assigns the NUL character
    (ASCII code 0) to `c` as its initial value. Likewise, HLA assigns false as the
    initial value for `bn`. In particular, you should note that your variable declarations
    in the `static` section always consume memory, even if you haven't assigned them
    an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3 The readonly Data Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `readonly` data section holds constants, tables, and other data that your
    program cannot change during execution. You create read-only objects by declaring
    them in the `readonly` declaration section. The `readonly` section is very similar
    to the `static` section with three primary differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The `readonly` section begins with the reserved word `readonly` rather than
    `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All declarations in the `readonly` section generally have an initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system does not allow you to store data into a `readonly` object while the
    program is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All `readonly` object declarations must have an initializer because you cannot
    initialize the value under program control.^([[38](#ftn.CHP-3-FN-5)]) For all
    intents and purposes, you can think of `readonly` objects as constants. However,
    these constants consume memory, and other than the fact that you cannot write
    data to `readonly` objects, they behave like `static` variables. Because they
    behave like `static` objects, you cannot use a `readonly` object everywhere a
    constant is allowed; in particular, `readonly` objects are memory objects, so
    you cannot supply a `readonly` object (which you are treating like a constant)
    and some other memory object as the operands to an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `static` section, you may embed data values in the `readonly` section
    using the `byte`, `word`, `dword`, and so on data declarations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 3.2.4 The storage Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `readonly` section requires that you initialize all objects you declare.
    The `static` section lets you optionally initialize objects (or leave them uninitialized,
    in which case they have the default initial value of 0). The `storage` section
    completes the initialization coverage: you use it to declare variables that are
    always uninitialized when the program begins running. The `storage` section begins
    with the `storage` reserved word and contains variable declarations without initializers.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Linux, FreeBSD, Mac OS X, and Windows will initialize all storage objects to
    0 when they load your program into memory. However, it's probably not a good idea
    to depend on this implicit initialization. If you need an object initialized with
    0, declare it in a `static` section and explicitly set it to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Variables you declare in the `storage` section may consume less disk space in
    the executable file for the program. This is because HLA writes out initial values
    for `readonly` and `static` objects to the executable file, but it may use a compact
    representation for uninitialized variables you declare in the `storage` section;
    note, however, that this behavior is OS- and object-module-format dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `storage` section does not allow initialized values, you *cannot*
    put unlabeled values in the `storage` section using the `byte`, `word`, `dword`,
    and so on pseudo-opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.5 The @nostorage Attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@nostorage` attribute lets you declare variables in the static data declaration
    sections (i.e., `static`, `readonly`, and `storage`) without actually allocating
    memory for the variable. The `@nostorage` option tells HLA to assign the current
    address in a declaration section to a variable but not to allocate any storage
    for the object. That variable will share the same memory address as the next object
    appearing in the variable declaration section. Here is the syntax for the `@nostorage`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you follow the type name with `@nostorage;` rather than some initial
    value or just a semicolon. The following code sequence provides an example of
    using the `@nostorage` option in the `readonly` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `abcd` is a double word whose L.O. byte contains 97 (`'a'`),
    byte 1 contains 98 (`'b'`), byte 2 contains 99 (`'c'`), and the H.O. byte contains
    100 (`'d'`). HLA does not reserve storage for the `abcd` variable, so HLA associates
    the following 4 bytes in memory (allocated by the `byte` directive) with `abcd`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `@nostorage` attribute is legal only in the `static`, `storage`,
    and `readonly` sections (the so-called *static* declarations sections). HLA does
    not allow its use in the `var` section that you'll read about next.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.6 The var Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HLA provides another variable declaration section, the `var` section, that you
    can use to create *automatic* variables. Your program will allocate storage for
    automatic variables whenever a program unit (i.e., main program or procedure)
    begins execution, and it will deallocate storage for automatic variables when
    that program unit returns to its caller. Of course, any automatic variables you
    declare in your main program have the same *lifetime* ^([[39](#ftn.CHP-3-FN-6)])
    as all the `static`, `readonly`, and `storage` objects, so the automatic allocation
    feature of the `var` section is wasted in the main program. In general, you should
    use automatic objects only in procedures (see [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS") for details). HLA allows them in your main program's declaration section
    as a generalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because variables you declare in the `var` section are created at runtime,
    HLA does not allow initializers on variables you declare in this section. So the
    syntax for the `var` section is nearly identical to that for the `storage` section;
    the only real difference in the syntax between the two is the use of the `var`
    reserved word rather than the `storage` reserved word.^([[40](#ftn.CHP-3-FN-7)])
    The following example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: HLA allocates variables you declare within the `var` section within the `stack`
    memory section. HLA does not allocate `var` objects at fixed locations; instead,
    it allocates these variables in an activation record associated with the current
    program unit. [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS") discusses
    activation records in greater detail; for now it is important only to realize
    that HLA programs use the EBP register as a pointer to the current activation
    record. Therefore, whenever you access a `var` object, HLA automatically replaces
    the variable name with `[EBP±`*`displacement`*`]`. Displacement is the offset
    of the object within the activation record. This means that you cannot use the
    full scaled-indexed addressing mode (a base register plus a scaled index register)
    with `var` objects because `var` objects already use the EBP register as their
    base register. Although you will not directly use the two register addressing
    modes often, the fact that the `var` section has this limitation is a good reason
    to avoid using the `var` section in your main program.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.7 Organization of Declaration Sections Within Your Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `static`, `readonly`, `storage`, and `var` sections may appear zero or
    more times between the `program` header and the associated `begin` for the main
    program. Between these two points in your program, the declaration sections may
    appear in any order, as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In addition to demonstrating that the sections may appear in an arbitrary order,
    this section also demonstrates that a given declaration section may appear more
    than once in your program. When multiple declaration sections of the same type
    (for example, the three `storage` sections above) appear in a declaration section
    of your program, HLA combines them into a single group.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#CHP-3-FN-4)]) This isn't a complete list. HLA generally allows you
    to use any scalar data type name as a statement to reserve storage in the code
    section. You'll learn more about the available data types in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#CHP-3-FN-5)]) There is one exception you'll see in [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#CHP-3-FN-6)]) The lifetime of a variable is the point from which memory
    is first allocated to the point the memory is deallocated for that variable.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#CHP-3-FN-7)]) Actually, there are a few other, minor, differences,
    but we won't deal with those differences in this text. See the HLA language reference
    manual for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 How HLA Allocates Memory for Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've seen, the 80x86 CPU doesn't deal with variables that have names like
    `I`, `Profits`, and `LineCnt`. The CPU deals strictly with numeric addresses it
    can place on the address bus like $1234_5678, $0400_1000, and $8000_CC00\. HLA,
    on the other hand, does not force to you refer to variable objects by their addresses
    (which is nice, because names are so much easier to remember). This is good, but
    it does obscure what is really going on. In this section, we'll take a look at
    how HLA associates numeric addresses with your variables so you'll understand
    (and appreciate) the process that is taking place behind your back.
  prefs: []
  type: TYPE_NORMAL
- en: Take another look at [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization"). As you can see, the various
    memory sections tend to be adjacent to one another. Therefore, if the size of
    one memory section changes, then this affects the starting address of all the
    following sections in memory. For example, if you add a few additional machine
    instructions to your program and increase the size of the `code` section, this
    may affect the starting address of the `static` section in memory, thus changing
    the addresses of all your static variables. Keeping track of variables by their
    numeric address (rather than by their names) is difficult enough; imagine how
    much worse it would be if the addresses are constantly shifting around as you
    add and remove machine instructions in your program! Fortunately, you don't have
    to keep track of variable addresses; HLA does that bookkeeping for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA associates a current *location counter* with each of the three static declaration
    sections (`static`, `readonly`, and `storage`). These location counters initially
    contain 0, and whenever you declare a variable in one of the static sections,
    HLA associates the current value of that section''s location counter with the
    variable; HLA also bumps up the value of that location counter by the size of
    the object you''re declaring. As an example, assume that the following is the
    only `static` declaration section in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the runtime address of each of these variables is not the value
    of the location counter. First of all, HLA adds in the base address of the `static`
    memory section to each of these location counter values (which we call *displacements*
    or *offsets*). Second, there may be other static objects in modules that you link
    with your program (e.g., from the HLA Standard Library) or even additional `static`
    sections in the same source file, and the linker has to merge the `static` sections
    together. Hence, these offsets may have very little bearing on the final address
    of these variables in memory. Nevertheless, one important fact remains: HLA allocates
    variables you declare in a single `static` declaration section in contiguous memory
    locations. That is, given the declaration above, `w` will immediately follow `b`
    in memory, `d` will immediately follow `w` in memory, `q` will immediately follow
    `d`, and so on. Generally, it''s not good coding style to assume that the system
    allocates variables this way, but sometimes it''s convenient to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that HLA allocates memory objects you declare in `readonly`, `static`,
    and `storage` sections in completely different regions of memory. Therefore, you
    cannot assume that the following three memory objects appear in adjacent memory
    locations (indeed, they probably will not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, HLA will not even guarantee that variables you declare in separate
    `static` (or whatever) sections are adjacent in memory, even if there is nothing
    between the declarations in your code (for example, you cannot assume that `b`,
    `w`, and `d` are in adjacent memory locations in the following declarations, nor
    can you assume that they *won''t* be adjacent in memory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If your code requires these variables to consume adjacent memory locations,
    you must declare them in the same `static` section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that HLA handles variables you declare in the `var` section a little differently
    than the variables you declare in one of the `static` sections. We'll discuss
    the allocation of offsets to `var` objects in [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS").
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 HLA Support for Data Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write fast programs, you need to ensure that you properly align
    data objects in memory. Proper alignment means that the starting address for an
    object is a multiple of some size, usually the size of an object if the object's
    size is a power of 2 for values up to 16 bytes in length. For objects greater
    than 16 bytes, aligning the object on an 8-byte or 16-byte address boundary is
    probably sufficient. For objects less than 16 bytes, aligning the object at an
    address that is the next power of 2 greater than the object's size is usually
    fine. Accessing data that is not aligned at an appropriate address may require
    extra time; so if you want to ensure that your program runs as rapidly as possible,
    you should try to align data objects according to their size.
  prefs: []
  type: TYPE_NORMAL
- en: Data becomes misaligned whenever you allocate storage for different-sized objects
    in adjacent memory locations. For example, if you declare a byte variable, it
    will consume 1 byte of storage, and the next variable you declare in that declaration
    section will have the address of that byte object plus 1\. If the byte variable's
    address happens to be an even address, then the variable following that byte will
    start at an odd address. If that following variable is a word or double-word object,
    then its starting address will not be optimal. In this section, we'll explore
    ways to ensure that a variable is aligned at an appropriate starting address based
    on that object's size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following HLA variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `static` declaration in a program (running under Windows, Mac OS
    X, FreeBSD, Linux, and most 32-bit operating systems) places its variables at
    an address that is an even multiple of 4,096 bytes. Whatever variable first appears
    in the `static` declaration is guaranteed to be aligned on a reasonable address.
    Each successive variable is allocated at an address that is the sum of the sizes
    of all the preceding variables plus the starting address of that `static` section.
    Therefore, assuming HLA allocates the variables in the previous example at a starting
    address of `4096`, HLA will allocate them at the following addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the exception of the first variable (which is aligned on a 4KB boundary)
    and the byte variables (whose alignment doesn't matter), all of these variables
    are misaligned. The `w`, `w2`, and `dw2` variables start at odd addresses, and
    the `dw3` variable is aligned on an even address that is not a multiple of 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to guarantee that your variables are aligned properly is to put
    all the double-word variables first, the word variables second, and the byte variables
    last in the declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This organization produces the following addresses in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these variables are all aligned at reasonable addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is rarely possible for you to arrange your variables in this
    manner. While there are many technical reasons that make this alignment impossible,
    a good practical reason for not doing this is that it doesn't let you organize
    your variable declarations by logical function (that is, you probably want to
    keep related variables next to one another regardless of their size).
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this problem, HLA provides the `align` directive. The `align` directive
    uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The integer constant must be one of the following small unsigned integer values:
    1, 2, 4, 8, or 16\. If HLA encounters the `align` directive in a `static` section,
    it will align the very next variable on an address that is an even multiple of
    the specified alignment constant. The previous example could be rewritten, using
    the `align` directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you're wondering how the `align` directive works, it's really quite simple.
    If HLA determines that the current address (location counter value) is not an
    even multiple of the specified value, HLA will quietly emit extra bytes of padding
    after the previous variable declaration until the current address in the `static`
    section is an even multiple of the specified value. This has the effect of making
    your program slightly larger (by a few bytes) in exchange for faster access to
    your data. Given that your program will grow by only a few bytes when you use
    this feature, this is probably a good trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, if you want the fastest possible access, you should choose
    an alignment value that is equal to the size of the object you want to align.
    That is, you should align words to even boundaries using an `align(2);` statement,
    double words to 4-byte boundaries using `align(4);`, quad words to 8-byte boundaries
    using `align(8);`, and so on. If the object's size is not a power of 2, align
    it to the next higher power of 2 (up to a maximum of 16 bytes). Note, however,
    that you need only align `real80` (and `tbyte`) objects on an 8-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Note that data alignment isn't always necessary. The cache architecture of modern
    80x86 CPUs actually handles most misaligned data. Therefore, you should use the
    alignment directives only with variables for which speedy access is absolutely
    critical. This is a reasonable space/speed trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Address Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, this chapter points out that addressing modes take a couple generic
    forms, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another legal form, which isn''t actually a new addressing mode but simply
    an extension of the displacement-only addressing mode, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This latter example computes its effective address by adding the constant offset
    within the brackets to the variable's address. For example, the instruction `mov(Address[3],
    al);` loads the AL register with the byte in memory that is 3 bytes beyond the
    `Address` object (see [Figure 3-8](ch03s05.html#using_an_address_expression_to_access_da
    "Figure 3-8. Using an address expression to access data beyond a variable")).
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that the *`offset`* value in these examples must be a constant.
    If `Index` is an `int32` variable, then `Variable[Index]` is not a legal address
    expression. If you wish to specify an index that varies at runtime, then you must
    use one of the indexed or scaled-indexed addressing modes.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to remember is that the offset in `Address[`*`offset`*`]`
    is a byte address. Despite the fact that this syntax is reminiscent of array indexing
    in a high-level language like C/C++ or Pascal, this does not properly index into
    an array of objects unless `Address` is an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an address expression to access data beyond a variable](tagoreillycom20100401nostarchimages577951.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8. Using an address expression to access data beyond a variable
  prefs: []
  type: TYPE_NORMAL
- en: 'This text will consider an *address expression* to be any legal 80x86 addressing
    mode that includes a displacement (i.e., variable name) or an offset. In addition
    to the above forms, the following are also address expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This book will *not* consider the following to be address expressions because
    they do not involve a displacement or offset component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Address expressions are special because those instructions containing an address
    expression always encode a displacement constant as part of the machine instruction.
    That is, the machine instruction contains some number of bits (usually 8 or 32)
    that hold a numeric constant. That constant is the sum of the displacement (i.e.,
    the address or offset of the variable) plus the offset. Note that HLA automatically
    adds these two values together for you (or subtracts the offset if you use the
    `−` rather than `+` operator in the addressing mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Until this point, the offset in all the addressing mode examples has always
    been a single numeric constant. However, HLA also allows a *constant expression*
    anywhere an offset is legal. A constant expression consists of one or more constant
    terms manipulated by operators such as addition, subtraction, multiplication,
    division, modulo, and a wide variety of others. Most address expressions, however,
    will involve only addition, subtraction, multiplication, and sometimes division.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This instruction will move the byte at address `X+9` into the AL register.
  prefs: []
  type: TYPE_NORMAL
- en: The value of an address expression is always computed at compile time, never
    while the program is running. When HLA encounters the instruction above, it calculates
    2 * 4 + 1 on the spot and adds this result to the base address of `X` in memory.
    HLA encodes this single sum (base address of `X` plus 9) as part of the instruction;
    HLA does not emit extra instructions to compute this sum for you at runtime (which
    is good, because doing so would be less efficient). Because HLA computes the value
    of address expressions at compile time, all components of the expression must
    be constants because HLA cannot know the runtime value of a variable while it
    is compiling the program.
  prefs: []
  type: TYPE_NORMAL
- en: Address expressions are useful for accessing the data in memory beyond a variable,
    particularly when you've used the `byte`, `word`, `dword`, and so on statements
    in a `static` or `readonly` section to tack on additional bytes after a data declaration.
    For example, consider the program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions").
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1. Demonstration of address expressions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions") will display the four values
    0, 1, 2, and 3 as though they were array elements. This is because the value at
    the address of `i` is 0 (this program declares `i` using the `@nostorage` option,
    so `i` is the address of the next object in the `static` section, which just happens
    to be the value 0 appearing as part of the `byte` statement). The address expression
    `i[1]` tells HLA to fetch the byte appearing at `i`'s address plus 1\. This is
    the value 1, because the `byte` statement in this program emits the value 1 to
    the `static` segment immediately after the value 0\. Likewise for `i[2]` and `i[3]`,
    this program displays the values 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Type Coercion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although HLA is fairly loose when it comes to type checking, HLA does ensure
    that you specify appropriate operand sizes to an instruction. For example, consider
    the following (incorrect) program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: HLA will generate errors for these three `mov` instructions. This is because
    the operand sizes are incompatible. The first instruction attempts to move a byte
    into EAX, the second instruction attempts to move a word into AL, and the third
    instruction attempts to move a double word into AX. The `mov` instruction, of
    course, requires both operands to be the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a good feature in HLA,^([[41](#ftn.CHP-3-FN-8)]) there are times
    when it gets in the way. Consider the following code fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example let's assume that the programmer really wants to load the word
    starting at the address of `byte_values` into the AX register because she wants
    to load AL with 0 and AH with 1 using a single instruction (note that 0 is held
    in the L.O. memory byte and 1 is held in the H.O. memory byte). HLA will refuse,
    claiming there is a type mismatch error (because `byte_values` is a byte object
    and AX is a word object). The programmer could break this into two instructions,
    one to load AL with the byte at address `byte_values` and the other to load AH
    with the byte at address `byte_values[1]`. Unfortunately, this decomposition makes
    the program slightly less efficient (which was probably the reason for using the
    single `mov` instruction in the first place). Somehow, it would be nice if we
    could tell HLA that we know what we're doing and we want to treat the `byte_values`
    variable as a `word` object. HLA's type coercion facilities provide this capability.
  prefs: []
  type: TYPE_NORMAL
- en: '*Type coercion*^([[42](#ftn.CHP-3-FN-9)]) is the process of telling HLA that
    you want to treat an object as an explicit type, regardless of its actual type.
    To coerce the type of a variable, you use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The *`newTypeName`* item is the new type you wish to associate with the memory
    location specified by *`addressExpression`*. You may use this coercion operator
    anywhere a memory address is legal. To correct the previous example, so HLA doesn''t
    complain about type mismatches, you would use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This instruction tells HLA to load the AX register with the word starting at
    address *`byte_values`* in memory. Assuming *`byte_values`* still contains its
    initial values, this instruction will load 0 into AL and 1 into AH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type coercion is necessary when you specify an anonymous variable as the operand
    to an instruction that directly modifies memory (e.g., `neg`, `shl`, `not`, and
    so on). Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA will generate an error on this instruction because it cannot determine
    the size of the memory operand. The instruction does not supply sufficient information
    to determine whether the program should invert the bits in the byte pointed at
    by EBX, the word pointed at by EBX, or the double word pointed at by EBX. You
    must use type coercion to explicitly specify the size of anonymous references
    with these types of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the type coercion operator unless you know exactly what you are doing
    and fully understand the effect it has on your program. Beginning assembly language
    programmers often use type coercion as a tool to quiet the compiler when it complains
    about type mismatches without solving the underlying problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following statement (where *`byteVar`* is an 8-bit variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the type coercion operator, HLA complains about this instruction because
    it attempts to store a 32-bit register in an 8-bit memory location. A beginning
    programmer, wanting his program to compile, may take a shortcut and use the type
    coercion operator, as shown in this instruction; this certainly quiets the compiler—it
    will no longer complain about a type mismatch—so the beginning programmer is happy.
    However, the program is still incorrect; the only difference is that HLA no longer
    warns you about your error. The type coercion operator does not fix the problem
    of attempting to store a 32-bit value into an 8-bit memory location—it simply
    allows the instruction to store a 32-bit value *starting at the address specified
    by the 8-bit variable*. The program still stores 4 bytes, overwriting the 3 bytes
    following *`byteVar`* in memory. This often produces unexpected results, including
    the phantom modification of variables in your program.^([[43](#ftn.CHP-3-FN-10)])
    Another, rarer possibility is for the program to abort with a general protection
    fault. This can occur if the 3 bytes following *`byteVar`* are not allocated in
    real memory or if those bytes just happen to fall in a read-only segment in memory.
    The important thing to remember about the type coercion operator is this: If you
    cannot exactly state the effect this operator has, don''t use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Also keep in mind that the type coercion operator does not perform any translation
    of the data in memory. It simply tells the compiler to treat the bits in memory
    as a different type. It will not automatically extend an 8-bit value to 32 bits,
    nor will it convert an integer to a floating-point value. It simply tells the
    compiler to treat the bit pattern of the memory operand as a different type.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#CHP-3-FN-8)]) After all, if the two operand sizes are different this
    usually indicates an error in the program.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#CHP-3-FN-9)]) This is also called *type casting* in some languages.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[43](#CHP-3-FN-10)]) If you have a variable immediately following *`byteVar`*
    in this example, the `mov` instruction will surely overwrite the value of that
    variable, whether or not you intend for this to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Register Type Coercion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also cast a register to a specific type using the type coercion operator.
    By default, the 8-bit registers are of type `byte`, the 16-bit registers are of
    type `word`, and the 32-bit registers are of type `dword`. With type coercion,
    you can cast a register as a different type *as long as the size of the new type
    agrees with the size of the register*. This is an important restriction that does
    not exist when applying type coercion to a memory variable.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time you do not need to coerce a register to a different type. As
    `byte`, `word`*,* and `dword` objects, registers are already compatible with all
    1-, 2-, and 4-byte objects. However, there are a few instances where register
    type coercion is handy, if not downright necessary. Two examples include boolean
    expressions in HLA high-level language statements (e.g., `if` and `while`) and
    register I/O in the `stdout.put` and `stdin.get` (and related) statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In boolean expressions, HLA always treats `byte`, `word`, and `dword` objects
    as unsigned values. Therefore, without type coercion, the following `if` statement
    always evaluates false (because there is no unsigned value less than 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can overcome this limitation by casting EAX as an `int32` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar vein, the HLA Standard Library `stdout.put` routine always outputs
    `byte`, `word`, and `dword` values as hexadecimal numbers. Therefore, if you attempt
    to print a register, the `stdout.put` routine will print it as a hex value. If
    you would like to print the value as some other type, you can use register type
    coercion to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The same is true for the `stdin.get` routine. It will always read a hexadecimal
    value for a register unless you coerce its type to something other than `byte`,
    `word`, or `dword`.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 The stack Segment and the push and pop Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter mentions that all variables you declare in the `var` section wind
    up in the `stack` memory segment. However, `var` objects are not the only things
    in the `stack` memory section; your programs manipulate data in the `stack` segment
    in many different ways. This section describes the stack and introduces the `push`
    and `pop` instructions that manipulate data in the `stack` section.
  prefs: []
  type: TYPE_NORMAL
- en: The `stack` segment in memory is where the 80x86 maintains the stack. The *stack*
    is a dynamic data structure that grows and shrinks according to certain needs
    of the program. The stack also stores important information about the program
    including local variables, subroutine information, and temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 controls its stack via the ESP (stack pointer) register. When your
    program begins execution, the operating system initializes ESP with the address
    of the last memory location in the `stack` memory segment. Data is written to
    the `stack` segment by "pushing" data onto the stack and "popping" data off the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.1 The Basic push Instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the syntax for the 80x86 `push` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: These six forms allow you to push `word` or `dword` registers, memory locations,
    and constants. You should specifically note that you cannot push `byte` values
    onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` instruction does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `pushw` and `pushd` operands are always 2- and 4-byte constants, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that ESP contains $00FF_FFE8, then the instruction `push( eax );` will
    set ESP to $00FF_FFE4 and store the current value of EAX into memory location
    $00FF_FFE4, as [Figure 3-9](ch03s08.html#stack_segment_before_the_push_open_paren
    "Figure 3-9. Stack segment before the push( eax ); operation") and [Figure 3-10](ch03s08.html#stack_segment_after_the_push_open_parent
    "Figure 3-10. Stack segment after the push( eax ); operation") show.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack segment before the push( eax ); operation](tagoreillycom20100401nostarchimages577953.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9. Stack segment before the `push( eax );` operation
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack segment after the push( eax ); operation](tagoreillycom20100401nostarchimages577955.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10. Stack segment after the `push( eax );` operation
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `push( eax );` instruction does not affect the value of the EAX
    register.
  prefs: []
  type: TYPE_NORMAL
- en: Although the 80x86 supports 16-bit push operations, their primary use in is
    16-bit environments such as MS-DOS. For maximum performance, the stack pointer's
    value should always be an even multiple of 4; indeed, your program may malfunction
    under a 32-bit OS if ESP contains a value that is not a multiple of 4\. The only
    practical reason for pushing less than 4 bytes at a time on the stack is to build
    up a double word via two successive word pushes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.2 The Basic pop Instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve data you've pushed onto the stack, you use the `pop` instruction.
    The basic `pop` instruction allows the following forms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Like the `push` instruction, the `pop` instruction supports only 16-bit and
    32-bit operands; you cannot pop an 8-bit value from the stack. As with the `push`
    instruction, you should avoid popping 16-bit values (unless you do two 16-bit
    pops in a row) because 16-bit pops may leave the ESP register containing a value
    that is not an even multiple of 4\. One major difference between `push` and `pop`
    is that you cannot pop a constant value (which makes sense, because the operand
    for `push` is a source operand, while the operand for `pop` is a destination operand).
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, here''s what the `pop` instruction does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `pop` operation is the converse of the `push` operation.
    Note that the `pop` instruction copies the data from memory location [ESP] before
    adjusting the value in ESP. See [Figure 3-11](ch03s08.html#memory_before_a_pop_open_parenthesis_eax
    "Figure 3-11. Memory before a pop( eax ); operation") and [Figure 3-12](ch03s08.html#memory_after_the_pop_open_parenthesis_ea
    "Figure 3-12. Memory after the pop( eax ); instruction") for details on this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory before a pop( eax ); operation](tagoreillycom20100401nostarchimages577957.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11. Memory before a `pop( eax );` operation
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory after the pop( eax ); instruction](tagoreillycom20100401nostarchimages577959.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12. Memory after the `pop( eax );` instruction
  prefs: []
  type: TYPE_NORMAL
- en: Note that the value popped from the stack is still present in memory. Popping
    a value does not erase the value in memory; it just adjusts the stack pointer
    so that it points at the next value above the popped value. However, you should
    never attempt to access a value you've popped off the stack. The next time something
    is pushed onto the stack, the popped value will be obliterated. Because your code
    isn't the only thing that uses the stack (for example, the operating system uses
    the stack as do subroutines), you cannot rely on data remaining in stack memory
    once you've popped it off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.3 Preserving Registers with the push and pop Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most common use of the `push` and `pop` instructions is to save
    register values during intermediate calculations. A problem with the 80x86 architecture
    is that it provides very few general-purpose registers. Because registers are
    the best place to hold temporary values, and registers are also needed for the
    various addressing modes, it is very easy to run out of registers when writing
    code that performs complex calculations. The `push` and `pop` instructions can
    come to your rescue when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push` and `pop` instructions are perfect for this situation. By inserting
    a `push` instruction before the middle sequence and a `pop` instruction after
    the middle sequence above, you can preserve the value in EAX across those calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `push` instruction above copies the data computed in the first sequence
    of instructions onto the stack. Now the middle sequence of instructions can use
    EAX for any purpose it chooses. After the middle sequence of instructions finishes,
    the `pop` instruction restores the value in EAX so the last sequence of instructions
    can use the original value in EAX.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 The Stack Is a LIFO Data Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can push more than one value onto the stack without first popping previous
    values off the stack. However, the stack is a *last-in, first-out (LIFO)* data
    structure, so you must be careful how you push and pop multiple values. For example,
    suppose you want to preserve EAX and EBX across some block of instructions; the
    following code demonstrates the obvious way to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this code will not work properly! [Figure 3-13](ch03s09.html#stack_after_pushing_eax
    "Figure 3-13. Stack after pushing EAX") through [Figure 3-16](ch03s09.html#stack_after_popping_ebx
    "Figure 3-16. Stack after popping EBX") show the problem. Because this code pushes
    EAX first and EBX second, the stack pointer is left pointing at EBX's value on
    the stack. When the `pop( eax );` instruction comes along, it removes the value
    that was originally in EBX from the stack and places it in EAX! Likewise, the
    `pop( ebx );` instruction pops the value that was originally in EAX into the EBX
    register. The end result is that this code manages to swap the values in the registers
    by popping them in the same order that it pushes them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after pushing EAX](tagoreillycom20100401nostarchimages577961.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13. Stack after pushing EAX
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after pushing EBX](tagoreillycom20100401nostarchimages577963.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14. Stack after pushing EBX
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after popping EAX](tagoreillycom20100401nostarchimages577965.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15. Stack after popping EAX
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after popping EBX](tagoreillycom20100401nostarchimages577967.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-16. Stack after popping EBX
  prefs: []
  type: TYPE_NORMAL
- en: 'To rectify this problem, you must note that the stack is a last-in, first-out
    data structure, so the first thing you must pop is the last thing you push onto
    the stack. Therefore, you must always observe the following maxim:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always pop values in the reverse order that you push them**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction to the previous code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important maxim to remember is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always pop exactly the same number of bytes that you push**.'
  prefs: []
  type: TYPE_NORMAL
- en: This generally means that the number of pushes and pops must exactly agree.
    If you have too few pops, you will leave data on the stack, which may confuse
    the running program. If you have too many pops, you will accidentally remove previously
    pushed data, often with disastrous results.
  prefs: []
  type: TYPE_NORMAL
- en: '| A corollary to the maxim above is, "Be careful when pushing and popping data
    within a loop." Often it is quite easy to put the pushes in a loop and leave the
    pops outside the loop (or vice versa), creating an inconsistent stack. Remember,
    it is the execution of the `push` and `pop` instructions that matters, not the
    number of `push` and `pop` instructions that appear in your program. At runtime,
    the number (and order) of the `push` instructions the program executes must match
    the number (and reverse order) of the `pop` instructions. |'
  prefs: []
  type: TYPE_TB
- en: 3.9.1 Other push and pop Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 provides several additional `push` and `pop` instructions in addition
    to the basic `push`/`pop` instructions. These instructions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `pusha` | `popa` |'
  prefs: []
  type: TYPE_TB
- en: '| `pushad` | `popad` |'
  prefs: []
  type: TYPE_TB
- en: '| `pushf` | `popf` |'
  prefs: []
  type: TYPE_TB
- en: '| `pushfd` | `popfd` |'
  prefs: []
  type: TYPE_TB
- en: 'The `pusha` instruction pushes all the general-purpose 16-bit registers onto
    the stack. This instruction exists primarily for older 16-bit operating systems
    like MS-DOS. In general, you will have very little need for this instruction.
    The `pusha` instruction pushes the registers onto the stack in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pushad` instruction pushes all the 32-bit (double-word) registers onto
    the stack. It pushes the registers onto the stack in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Because the `pusha` and `pushad` instructions inherently modify the SP/ESP register,
    you may wonder why Intel bothered to push this register at all. It was probably
    easier in the hardware to go ahead and push SP/ESP rather than make a special
    case out of it. In any case, these instructions do push SP or ESP, so don't worry
    about it too much—there is nothing you can do about it.
  prefs: []
  type: TYPE_NORMAL
- en: The `popa` and `popad` instructions provide the corresponding "pop all" operation
    to the `pusha` and `pushad` instructions. This will pop the registers pushed by
    `pusha` or `pushad` in the appropriate order (that is, `popa` and `popad` will
    properly restore the register values by popping them in the reverse order that
    `pusha` or `pushad` pushed them).
  prefs: []
  type: TYPE_NORMAL
- en: Although the `pusha`/`popa` and `pushad`/`popad` sequences are short and convenient,
    they are actually slower than the corresponding sequence of `push`/`pop` instructions,
    this is especially true when you consider that you rarely need to push a majority,
    much less all, of the registers.^([[44](#ftn.CHP-3-FN-11)]) So if you're looking
    for maximum speed, you should carefully consider whether to use the `pusha`(`d`)/`popa`(`d`)
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The `pushf`, `pushfd`, `popf`, and `popfd` instructions push and pop the EFLAGS
    register. These instructions allow you to preserve condition code and other flag
    settings across the execution of some sequence of instructions. Unfortunately,
    unless you go to a lot of trouble, it is difficult to preserve individual flags.
    When using the `pushf`(`d`) and `popf`(`d`) instructions, it's an all-or-nothing
    proposition—you preserve all the flags when you push them; you restore all the
    flags when you pop them.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `pushad` and `popad` instructions, you should really use the `pushfd`
    and `popfd` instructions to push the full 32-bit version of the EFLAGS register.
    Although the extra 16 bits you push and pop are essentially ignored when writing
    applications, you still want to keep the stack aligned by pushing and popping
    only double words.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 Removing Data from the Stack Without Popping It
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once in a while you may discover that you've pushed data onto the stack that
    you no longer need. Although you could pop the data into an unused register or
    memory location, there is an easier way to remove unwanted data from the stack—simply
    adjust the value in the ESP register to skip over the unwanted data on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following dilemma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Within the `then` section of the `if` statement, this code wants to remove the
    old values of EAX and EBX without otherwise affecting any registers or memory
    locations. How can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ESP register contains the memory address of the item on the top
    of the stack, we can remove the item from the top of stack by adding the size
    of that item to the ESP register. In the preceding example, we wanted to remove
    two double-word items from the top of stack. We can easily accomplish this by
    adding 8 to the stack pointer (see [Figure 3-17](ch03s09.html#removing_data_from_the_stack_comma_befor
    "Figure 3-17. Removing data from the stack, before add( 8, esp );") and [Figure 3-18](ch03s09.html#removing_data_from_the_stack_comma_after
    "Figure 3-18. Removing data from the stack, after add( 8, esp );") for the details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![Removing data from the stack, before add( 8, esp );](tagoreillycom20100401nostarchimages577969.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-17. Removing data from the stack, before `add( 8, esp );`
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing data from the stack, after add( 8, esp );](tagoreillycom20100401nostarchimages577971.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-18. Removing data from the stack, after `add( 8, esp );`
  prefs: []
  type: TYPE_NORMAL
- en: Effectively, this code pops the data off the stack without moving it anywhere.
    Also note that this code is faster than two dummy `pop` instructions because it
    can remove any number of bytes from the stack with a single `add` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to keep the stack aligned on a double-word boundary. Therefore, you
    should always add a constant that is a multiple of 4 to ESP when removing data
    from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#CHP-3-FN-11)]) For example, it is extremely rare for you to need to
    push and pop the ESP register with the `pushad`/`popad` instruction sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Accessing Data You've Pushed onto the Stack Without Popping It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while you will push data onto the stack and you will want to get a
    copy of that data's value, or perhaps you will want to change that data's value
    without actually popping the data off the stack (that is, you wish to pop the
    data off the stack at a later time). The 80x86 `[reg32 + offset]` addressing mode
    provides the mechanism for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the stack after the execution of the following two instructions (see
    [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![Stack after pushing EAX and EBX](tagoreillycom20100401nostarchimages577973.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-19. Stack after pushing EAX and EBX
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to access the original EBX value without removing it from the
    stack, you could cheat and pop the value and then immediately push it again. Suppose,
    however, that you wish to access EAX's old value or some other value even farther
    up the stack. Popping all the intermediate values and then pushing them back onto
    the stack is problematic at best, impossible at worst. However, as you will notice
    from [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX"), each of the values pushed on the stack is at some
    offset from the ESP register in memory. Therefore, we can use the `[ESP + offset]`
    addressing mode to gain direct access to the value we are interested in. In the
    example above, you can reload EAX with its original value by using the single
    instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This code copies the 4 bytes starting at memory address ESP+4 into the EAX register.
    This value just happens to be the previous value of EAX that was pushed onto the
    stack. You can use this same technique to access other data values you've pushed
    onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget that the offsets of values from ESP into the stack change every
    time you push or pop data. Abusing this feature can create code that is hard to
    modify; if you use this feature throughout your code, it will make it difficult
    to push and pop other data items between the point where you first push data onto
    the stack and the point where you decide to access that data again using the *`[ESP
    + offset]`* memory addressing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous section pointed out how to remove data from the stack by adding
    a constant to the ESP register. That code example could probably be written more
    safely as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this code sequence, the calculated result was stored over the top of the
    values saved on the stack. Later on, when the program pops the values, it loads
    these calculated values into EAX and EBX.
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 Dynamic Memory Allocation and the Heap Segment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although static and automatic variables are all that simple programs may need,
    more sophisticated programs need the ability to allocate and deallocate storage
    dynamically (at runtime) under program control. In the C language, you would use
    the `malloc` and `free` functions for this purpose. C++ provides the `new` and
    `delete` operators. Pascal uses `new` and `dispose`. Other languages provide comparable
    facilities. These memory-allocation routines have a couple of things in common:
    They let the programmer request how many bytes of storage to allocate, they return
    a *pointer* to the newly allocated storage, and they provide a facility for returning
    the storage to the system so the system can reuse it in a future allocation call.
    As you''ve probably guessed, HLA also provides a set of routines in the HLA Standard
    Library that handle memory allocation and deallocation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA Standard Library `mem.alloc` and `mem.free` routines handle the memory
    allocation and deallocation chores (respectively). The `mem.alloc` routine uses
    the following calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The single parameter is a `dword` value specifying the number of bytes of storage
    you need. This procedure allocates storage in the `heap` segment in memory. The
    HLA `mem.alloc` function locates an unused block of memory of the size you specify
    in the `heap` segment and marks the block as "in use" so that future calls to
    `mem.alloc` will not allocate this same storage. After marking the block as "in
    use," the `mem.alloc` routine returns a pointer to the first byte of this storage
    in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'For many objects, you will know the number of bytes that you need in order
    to represent that object in memory. For example, if you wish to allocate storage
    for an `uns32` variable, you could use the following call to the `mem.alloc` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you can specify a literal constant as this example suggests, it''s
    generally a poor idea to do so when allocating storage for a specific data type.
    Instead, use the HLA built-in *compile-time function*^([[45](#ftn.CHP-3-FN-12)])
    `@size` to compute the size of some data type. The `@size` function uses the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@size` function returns an unsigned integer constant that is the size
    of its parameter in bytes. So you should rewrite the previous call to `mem.alloc`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This call will properly allocate a sufficient amount of storage for the specified
    object, regardless of its type. While it is unlikely that the number of bytes
    required by an `uns32` object will ever change, this is not necessarily true for
    other data types; so you should always use `@size` rather than a literal constant
    in these calls.
  prefs: []
  type: TYPE_NORMAL
- en: Upon return from the `mem.alloc` routine, the EAX register contains the address
    of the storage you have requested (see [Figure 3-20](ch03s11.html#a_call_to_mem.alloc_returns_a_pointer_in
    "Figure 3-20. A call to mem.alloc returns a pointer in the EAX register.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![A call to mem.alloc returns a pointer in the EAX register.](tagoreillycom20100401nostarchimages577975.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-20. A call to `mem.alloc` returns a pointer in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the storage `mem.alloc` allocates, you must use a register-indirect
    addressing mode. The following code sequence demonstrates how to assign the value
    1234 to the `uns32` variable `mem.alloc` creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `type` coercion operator. This is necessary in this example
    because anonymous variables don't have a type associated with them and the constant
    1234 could be a `word` or `dword` value. The `type` coercion operator eliminates
    the ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: The `mem.alloc` routine may not always succeed. If there isn't a single contiguous
    block of free memory in the heap segment that is large enough to satisfy the request,
    then the `mem.alloc` routine will raise an `ex.MemoryAllocationFailure` exception.
    If you do not provide a `try..exception..endtry` handler to deal with this situation,
    a memory allocation failure will cause your program to stop. Because most programs
    do not allocate massive amounts of dynamic storage using `mem.alloc`, this exception
    rarely occurs. However, you should never assume that the memory allocation will
    always occur without error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have finished using a value that `mem.alloc` allocates on the heap,
    you can release the storage (that is, mark it as "no longer in use") by calling
    the `mem.free` procedure. The `mem.free` routine requires a single parameter that
    must be an address returned by a previous call to `mem.alloc` (that you have not
    already freed). The following code fragment demonstrates the nature of the `mem.alloc`/`mem.free`
    pairing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This code demonstrates a very important point: In order to properly free the
    storage that `mem.alloc` allocates, you must preserve the value that `mem.alloc`
    returns. There are several ways to do this if you need to use EAX for some other
    purpose; you could save the pointer value on the stack using `push` and `pop`
    instructions or you could save EAX''s value in a variable until you need to free
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Storage you release is available for reuse by future calls to the `mem.alloc`
    routine. The ability to allocate storage when you need it and then free the storage
    for other use when you have finished with it improves the memory efficiency of
    your program. By deallocating storage once you have finished with it, your program
    can reuse that storage for other purposes, allowing your program to operate with
    less memory than it would if you statically allocated storage for the individual
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several problems can occur when you use pointers. You should be aware of a
    couple of common errors that beginning programmers make when using dynamic storage
    allocation routines like `mem.alloc` and `mem.free`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mistake 1: Continuing to refer to storage after you free it. Once you return
    storage to the system via the call to `mem.free`, you should no longer access
    that storage. Doing so may cause a protection fault or, worse yet, corrupt other
    data in your program without indicating an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mistake 2: Calling `mem.free` twice to release a single block of storage. Doing
    so may accidentally free some other storage that you did not intend to release
    or, worse yet, it may corrupt the system memory management tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    some additional problems you will typically encounter when dealing with dynamically
    allocated storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples thus far in this section have all allocated storage for a single
    unsigned 32-bit object. Obviously you can allocate storage for any data type using
    a call to `mem.alloc` by simply specifying the size of that object as `mem.alloc`''s
    parameter. It is also possible to allocate storage for a sequence of contiguous
    objects in memory when calling `mem.alloc`. For example, the following code will
    allocate storage for a sequence of eight characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the constant expression to compute the number of bytes required
    by an eight-character sequence. Because `@size(char)` always returns a constant
    value (1 in this case), the compiler can compute the value of the expression `@size(char)
    * 8` without generating any extra machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Calls to `mem.alloc` always allocate multiple bytes of storage in contiguous
    memory locations. Hence the former call to `mem.alloc` produces the sequence appearing
    in [Figure 3-21](ch03s11.html#allocating_a_sequence_of_eight_character "Figure 3-21. Allocating
    a sequence of eight character objects using mem.alloc").
  prefs: []
  type: TYPE_NORMAL
- en: '![Allocating a sequence of eight character objects using mem.alloc](tagoreillycom20100401nostarchimages577977.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21. Allocating a sequence of eight character objects using `mem.alloc`
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these extra character values you use an offset from the base address
    (contained in EAX upon return from `mem.alloc`). For example, `mov( ch, [eax +
    2] );` stores the character found in CH into the third byte that `mem.alloc` allocates.
    You can also use an addressing mode like `[eax + ebx]` to step through each of
    the allocated objects under program control. For example, the following code will
    set all the characters in a block of 128 bytes to the NUL character (#0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    composite data structures (including arrays) and describes additional ways to
    deal with blocks of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: You should note that a call to `mem.alloc` actually allocates slightly more
    memory than you request. For one thing, memory allocation requests are generally
    of some minimum size (often a power of 2 between 4 and 16, though this is OS dependent).
    Furthermore, `mem.alloc` requests also require a few bytes of overhead for each
    request (generally around 16 to 32 bytes) to keep track of allocated and free
    blocks. Therefore, it is not efficient to allocate a large number of small objects
    with individual calls to `mem.alloc`. The overhead for each allocation may be
    greater than the storage you actually use. Typically, you'll use `mem.alloc` to
    allocate storage for arrays or large records (structures) rather than small objects.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[45](#CHP-3-FN-12)]) A compile-time function is one that HLA evaluates during
    the compilation of your program rather than at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 The inc and dec Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the example in the previous section indicates—indeed, as several examples
    up to this point have indicated—adding or subtracting 1 from a register or memory
    location is a very common operation. In fact, these operations are so common that
    Intel''s engineers included a pair of instructions to perform these specific operations:
    the `inc` (increment) and `dec` (decrement) instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inc` and `dec` instructions use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The single operand can be any legal 8-bit, 16-bit, or 32-bit register or memory
    operand. The `inc` instruction will add 1 to the specified operand, and the `dec`
    instruction will subtract 1 from the specified operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two instructions are slightly shorter than the corresponding `add` or
    `sub` instructions (that is, their encoding uses fewer bytes). There is also one
    slight difference between these two instructions and the corresponding `add` or
    `sub` instructions: They do not affect the carry flag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the `inc` instruction, consider the example from the previous
    section, recoded to use `inc` rather than `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 3.13 Obtaining the Address of a Memory Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[3.1.2.2 The Register-Indirect Addressing Modes](ch03.html#the_register-indirect_addressing_modes
    "3.1.2.2 The Register-Indirect Addressing Modes") discusses how to use the address-of
    operator, `&`, to take the address of a static variable.^([[46](#ftn.CHP-3-FN-13)])
    Unfortunately, you cannot use the address-of operator to take the address of an
    automatic variable (one you declare in the `var` section), you cannot use it to
    compute the address of an anonymous variable, and you cannot use it to take the
    address of a memory reference that uses an indexed or scaled-indexed addressing
    mode (even if a static variable is part of the address expression). You may use
    the address-of operator only to take the address of a simple static object. Often,
    you will need to take the address of other memory objects as well; fortunately,
    the 80x86 provides the *load effective address* instruction, `lea`, to give you
    this capability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lea` instruction uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first operand must be a 32-bit register; the second operand can be any legal
    memory reference using any valid memory addressing mode. This instruction will
    load the address of the specified memory location into the register. This instruction
    does not access or modify the value of the memory operand in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load the effective address of a memory location into a 32-bit general-purpose
    register, you can use the register-indirect, indexed, or scaled-indexed addressing
    mode to access the data at the specified memory address. Consider the following
    code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This code steps through each of the 8 bytes following the `b` label in the `static`
    section and prints their values. Note the use of the `[ebx+ecx]` addressing mode.
    The EBX register holds the base address of the list (that is, the address of the
    first item in the list), and ECX contains the byte index into the list.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#CHP-3-FN-13)]) A static variable is one that you declare in the `static`,
    `readonly`, or `storage` section of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 3.14 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An older, 16-bit version of *The Art of Assembly Language Programming* can be
    found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/). In that text
    you will find information about the 80x86's 16-bit addressing modes and segmentation.
    More information about the HLA Standard Library `mem.alloc` and `mem.free` functions
    can be found in the HLA Standard Library reference manual, also on Webster at
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or at [http://artofasm.com/](http://artofasm.com/).
    Of course, the Intel x86 documentation (found at [http://www.intel.com/](http://www.intel.com/))
    provides complete information on 80x86 address modes and machine instruction encoding.
  prefs: []
  type: TYPE_NORMAL
