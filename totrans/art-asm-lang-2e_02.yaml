- en: Chapter 3. MEMORY ACCESS AND ORGANIZATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 内存访问与组织
- en: '![MEMORY ACCESS AND ORGANIZATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![内存访问与组织](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: '[Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") and [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") show you how to declare and access simple variables
    in an assembly language program. This chapter fully explains 80x86 memory access.
    You will learn how to efficiently organize your variable declarations to speed
    up access to their data. This chapter will teach you about the 80x86 stack and
    how to manipulate data on the stack. Finally, this chapter will teach you about
    dynamic memory allocation and the *heap*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章：你好，汇编语言世界")和[第2章](ch02.html "第2章：数据表示")展示了如何在汇编语言程序中声明和访问简单变量。本章将全面解释
    80x86 内存访问。你将学习如何高效地组织变量声明，以加速对数据的访问。本章将教授你 80x86 栈及如何在栈上操作数据。最后，本章将讲解动态内存分配和
    *堆*。'
- en: 'This chapter discusses several important concepts, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了几个重要的概念，包括：
- en: 80x86 memory addressing modes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80x86 内存寻址模式
- en: Indexed and scaled-indexed addressing modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引寻址和缩放索引寻址模式
- en: Memory organization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存组织
- en: Memory allocation by program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序分配内存
- en: Data type coercion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型强制转换
- en: The 80x86 stack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80x86 栈
- en: Dynamic memory allocation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: This chapter will teach to you make efficient use of your computer's memory
    resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何高效利用计算机的内存资源。
- en: 3.1 The 80x86 Addressing Modes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 80x86 寻址模式
- en: The 80x86 processors let you access memory in many different ways. Until now,
    you've seen only a single way to access a variable, the so-called *displacement-only*
    addressing mode. In this section you'll see some additional ways your programs
    can access memory using 80x86 *memory addressing modes*. The 80x86 memory addressing
    modes provide flexible access to memory, allowing you to easily access variables,
    arrays, records, pointers, and other complex data types. Mastery of the 80x86
    addressing modes is the first step toward mastering 80x86 assembly language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 处理器允许你以多种不同方式访问内存。到目前为止，你只见过一种访问变量的方式，即所谓的 *仅位移* 寻址模式。在本节中，你将看到一些额外的方式，如何通过
    80x86 *内存寻址模式* 来访问内存。80x86 内存寻址模式提供了灵活的内存访问方式，使你能够轻松访问变量、数组、记录、指针和其他复杂数据类型。掌握
    80x86 寻址模式是掌握 80x86 汇编语言的第一步。
- en: When Intel designed the original 8086 processor, it provided the processor with
    a flexible, though limited, set of memory addressing modes. Intel added several
    new addressing modes when it introduced the 80386 microprocessor. However, in
    32-bit environments like Windows, Mac OS X, FreeBSD, and Linux, these earlier
    addressing modes are not very useful; indeed, HLA doesn't even support the use
    of these older, 16-bit-only addressing modes. Fortunately, anything you can do
    with the older addressing modes can be done with the new addressing modes. Therefore,
    you won't need to bother learning the old 16-bit addressing modes when writing
    code for today's high-performance operating systems. Do keep in mind, however,
    that if you intend to work under MS-DOS or some other 16-bit operating system,
    you will need to study up on those old addressing modes (see the 16-bit edition
    of this book at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) for details).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当英特尔设计最初的 8086 处理器时，它为处理器提供了灵活但有限的内存寻址模式。英特尔在推出 80386 微处理器时添加了几种新的寻址模式。然而，在
    Windows、Mac OS X、FreeBSD 和 Linux 等 32 位环境中，这些早期的寻址模式并不是很有用；实际上，HLA 甚至不支持使用这些旧的、仅限
    16 位的寻址模式。幸运的是，任何可以通过旧的寻址模式完成的事情，都可以通过新的寻址模式来实现。因此，在为当今高性能操作系统编写代码时，你不需要浪费时间学习旧的
    16 位寻址模式。但请记住，如果你打算在 MS-DOS 或其他 16 位操作系统下工作，你仍然需要研究这些旧的寻址模式（有关详细信息，请参阅本书的 16 位版本：[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)）。
- en: 3.1.1 80x86 Register Addressing Modes
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.1 80x86 寄存器寻址模式
- en: 'Most 80x86 instructions can operate on the 80x86''s general-purpose register
    set. By specifying the name of the register as an operand to the instruction,
    you can access the contents of that register. Consider the 80x86 `mov` (move)
    instruction:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 80x86 指令可以在 80x86 的通用寄存器集中操作。通过指定寄存器的名称作为操作数，你可以访问该寄存器的内容。考虑 80x86 的 `mov`（移动）指令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This instruction copies the data from the *`source`* operand to the *`destination`*
    operand. The 8-bit, 16-bit, and 32-bit registers are certainly valid operands
    for this instruction. The only restriction is that both operands must be the same
    size. Now let''s look at some actual 80x86 `mov` instructions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将数据从*`源`*操作数复制到*`目标`*操作数。8位、16位和32位寄存器当然是该指令有效的操作数。唯一的限制是两个操作数必须具有相同的大小。现在让我们来看一些实际的80x86
    `mov`指令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The registers are the best place to keep variables. Instructions using the registers
    are shorter and faster than those that access memory. Of course, most computations
    require at least one register operand, so the register addressing mode is very
    popular in 80x86 assembly code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是存储变量的最佳位置。使用寄存器的指令比访问内存的指令更简短、更快速。当然，大多数计算至少需要一个寄存器操作数，因此寄存器寻址模式在80x86汇编代码中非常流行。
- en: 3.1.2 80x86 32-Bit Memory Addressing Modes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.2 80x86 32位内存寻址模式
- en: The 80x86 provides hundreds of different ways to access memory. This may seem
    like quite a lot at first, but fortunately most of the addressing modes are simple
    variants of one another, so they're very easy to learn. And learn them you should!
    The key to good assembly language programming is the proper use of memory addressing
    modes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86提供了数百种不同的内存访问方式。刚开始看起来可能很多，但幸运的是，大多数寻址模式只是彼此简单的变体，因此它们非常容易学习。而且你确实应该学会它们！良好的汇编语言编程的关键是正确使用内存寻址模式。
- en: The addressing modes provided by the 80x86 family include displacement-only,
    base, displacement plus base, base plus indexed, and displacement plus base plus
    indexed. Variations on these five forms provide all the different addressing modes
    on the 80x86\. See, from hundreds down to five. It's not so bad after all!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86系列提供的寻址模式包括仅位移、基址、位移加基址、基址加索引和位移加基址加索引。这五种形式的变体提供了80x86上的所有不同寻址模式。看，从数百种变成了五种。其实并不那么复杂！
- en: 3.1.2.1 The Displacement-Only Addressing Mode
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.1 仅位移寻址模式
- en: The most common addressing mode, and the one that's easiest to understand, is
    the *displacement-only* (or *direct*) addressing mode. The displacement-only addressing
    mode consists of a 32-bit constant that specifies the address of the target location.
    Assuming that variable `j` is an `int8` variable appearing at address $8088, the
    instruction `mov( j, al );` loads the AL register with a copy of the byte at memory
    location $8088\. Likewise, if `int8` variable `k` is at address $1234 in memory,
    then the instruction `mov( dl, k );` stores the value in the DL register to memory
    location $1234 (see [Figure 3-1](ch03.html#displacement-only_open_parenthesis_direc
    "Figure 3-1. Displacement-only (direct) addressing mode")).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的寻址模式，也是最容易理解的，是*仅位移*（或*直接*）寻址模式。仅位移寻址模式由一个32位常量组成，指定目标位置的地址。假设变量`j`是一个出现在地址$8088的`int8`变量，指令`mov(
    j, al );`将AL寄存器加载为位于内存地址$8088的字节的副本。同样，如果`int8`变量`k`位于内存地址$1234，则指令`mov( dl, k
    );`将DL寄存器中的值存储到内存地址$1234（参见[图3-1](ch03.html#displacement-only_open_parenthesis_direc
    "图3-1. 仅位移（直接）寻址模式")）。
- en: '![Displacement-only (direct) addressing mode](tagoreillycom20100401nostarchimages577937.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![仅位移（直接）寻址模式](tagoreillycom20100401nostarchimages577937.png)'
- en: Figure 3-1. Displacement-only (direct) addressing mode
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1。仅位移（直接）寻址模式
- en: The displacement-only addressing mode is perfect for accessing simple scalar
    variables. This is named the displacement-only addressing mode because a 32-bit
    constant (displacement) follows the `mov` opcode in memory. On the 80x86 processors,
    this displacement is an offset from the beginning of memory (that is, address
    0). The examples in this chapter often access bytes in memory. Don't forget, however,
    that you can also access words and double words on the 80x86 processors by specifying
    the address of their first byte (see [Figure 3-2](ch03.html#accessing_a_word_or_dword_using_the_disp
    "Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode")).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位移寻址模式非常适合访问简单的标量变量。之所以称其为仅位移寻址模式，是因为一个32位常量（位移）跟随在`mov`操作码后面存储在内存中。在80x86处理器中，这个位移是从内存起始地址（即地址0）开始的偏移量。本章中的示例通常访问内存中的字节。然而，别忘了，你也可以通过指定其第一个字节的地址来访问80x86处理器上的字和双字（参见[图3-2](ch03.html#accessing_a_word_or_dword_using_the_disp
    "图3-2. 使用仅位移寻址模式访问字或双字")）。
- en: '![Accessing a word or dword using the displacement-only addressing mode](tagoreillycom20100401nostarchimages577939.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用仅位移寻址模式访问字或双字](tagoreillycom20100401nostarchimages577939.png)'
- en: Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2. 使用仅位移寻址模式访问字或双字
- en: 3.1.2.2 The Register-Indirect Addressing Modes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.2 寄存器间接寻址模式
- en: The 80x86 CPUs let you access memory indirectly through a register using the
    *register-indirect* addressing modes. The term *indirect* means that the operand
    is not the actual address, but rather the operand's value specifies the memory
    address to use. In the case of the register-indirect addressing modes, the value
    held in the register is the address of the memory location to access. For example,
    the instruction `mov( eax, [ebx] );` tells the CPU to store EAX's value at the
    location whose address is in EBX (the square brackets around EBX tell HLA to use
    the register-indirect addressing mode).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 让你通过寄存器间接寻址模式间接访问内存。术语*间接*意味着操作数不是实际的地址，而是操作数的值指定要使用的内存地址。在寄存器间接寻址模式的情况下，寄存器中保存的值是要访问的内存位置的地址。例如，指令`mov(
    eax, [ebx] );`告诉 CPU 将 EAX 的值存储到地址在 EBX 中的位置（EBX 周围的方括号告诉 HLA 使用寄存器间接寻址模式）。
- en: 'There are eight forms of this addressing mode on the 80x86\. The following
    instructions are examples of these eight forms:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 80x86 上有八种这种寻址模式。以下指令是这八种形式的示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These eight addressing modes reference the memory location at the offset found
    in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP,
    respectively).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这八种寻址模式通过方括号中的寄存器（EAX、EBX、ECX、EDX、EDI、ESI、EBP 或 ESP）找到的偏移量引用内存位置。
- en: 'Note that the register-indirect addressing modes require a 32-bit register.
    You cannot specify a 16-bit or 8-bit register when using an indirect addressing
    mode.^([[34](#ftn.CHP-3-FN-1)]) Technically, you could load a 32-bit register
    with an arbitrary numeric value and access that location indirectly using the
    register-indirect addressing mode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，寄存器间接寻址模式要求使用 32 位寄存器。使用间接寻址模式时，不能指定 16 位或 8 位寄存器。^([[34](#ftn.CHP-3-FN-1)])
    从技术上讲，你可以将一个 32 位寄存器加载任意数值，并使用寄存器间接寻址模式间接访问该位置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unfortunately (or fortunately, depending on how you look at it), this will probably
    cause the operating system to generate a protection fault because it's not always
    legal to access arbitrary memory locations. As it turns out, there are better
    ways to load the address of some object into a register; you'll see how to do
    this shortly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（或者幸运的是，这取决于你如何看待它），这可能会导致操作系统生成保护错误，因为并非总是合法访问任意内存位置。事实证明，有更好的方法将某些对象的地址加载到寄存器中；你稍后会看到如何操作。
- en: The register-indirect addressing modes have many uses. You can use them to access
    data referenced by a pointer, you can use them to step through array data, and,
    in general, you can use them whenever you need to modify the address of a variable
    while your program is running.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式有许多用途。你可以用它们来访问由指针引用的数据，也可以用它们来遍历数组数据，通常，你可以在程序运行时需要修改变量地址时使用它们。
- en: The register-indirect addressing mode provides an example of an *anonymous*
    variable. When using a register-indirect addressing mode, you refer to the value
    of a variable by its numeric memory address (e.g., the value you load into a register)
    rather than by the name of the variable—hence the phrase *anonymous variable*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式提供了一个*匿名*变量的例子。当使用寄存器间接寻址模式时，你是通过变量的数值内存地址（例如，加载到寄存器中的值）而不是变量的名称来引用变量的值——因此有了*匿名变量*这一说法。
- en: 'HLA provides a simple operator that you can use to take the address of a `static`
    variable and put this address into a 32-bit register. This is the `&` (address-of)
    operator (note that this is the same symbol that C/C++ uses for the address-of
    operator). The following example loads the address of variable `j` into EBX and
    then stores EAX''s current value into `j` using a register-indirect addressing
    mode:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了一个简单的操作符，你可以用它获取一个`static`变量的地址，并将该地址放入一个 32 位寄存器中。这就是`&`（地址操作符）操作符（注意，这与
    C/C++ 中的地址操作符符号相同）。以下示例将变量 `j` 的地址加载到 EBX 中，然后使用寄存器间接寻址模式将 EAX 的当前值存储到 `j` 中：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Of course, it would have been easier to store EAX's value directly into `j`
    rather than using two instructions to do this indirectly. However, you can easily
    imagine a code sequence where the program loads one of several different addresses
    into EBX prior to the execution of the `mov( eax, [ebx]);` statement, thus storing
    EAX into one of several different locations depending on the execution path of
    the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直接将EAX的值存储到`j`中比使用两条指令间接完成这项操作要简单。然而，你可以很容易地想象出一个代码序列，在该序列中，程序在执行`mov( eax,
    [ebx]);`语句之前，会将多个不同的地址之一加载到EBX中，从而根据程序的执行路径将EAX存储到多个不同的位置。
- en: Warning
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The `&` (address-of ) operator is not a general address-of operator like the
    `&` operator in C/C++. You may apply this operator only to static variables.^([[35](#ftn.CHP-3-FN-2)])
    You cannot apply it to generic address expressions or other types of variables.
    In [3.13 Obtaining the Address of a Memory Object](ch03s13.html "3.13 Obtaining
    the Address of a Memory Object"), you will learn about the *load effective address*
    instruction that provides a general solution for obtaining the address of some
    variable in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`（取地址）操作符不像C/C++中的`&`操作符那样是通用的取地址操作符。你只能将此操作符应用于静态变量。^([[35](#ftn.CHP-3-FN-2)])
    你不能将它应用于通用的地址表达式或其他类型的变量。在[3.13 获取内存对象的地址](ch03s13.html "3.13 获取内存对象的地址")中，你将了解*加载有效地址*指令，它为获取内存中某个变量的地址提供了通用的解决方案。'
- en: 3.1.2.3 Indexed Addressing Modes
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.3 索引寻址模式
- en: 'The indexed addressing modes use the following syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式使用以下语法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*`VarName`* is the name of some variable in your program.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`VarName`* 是你程序中某个变量的名称。'
- en: The indexed addressing modes compute an effective address^([[36](#ftn.CHP-3-FN-3)])
    by adding the address of the variable to the value of the 32-bit register appearing
    inside the square brackets. Their sum is the actual memory address the instruction
    accesses. So if *`VarName`* is at address $1100 in memory and EBX contains 8,
    then `mov(`*`VarName`*`[ ebx ], al);` loads the byte at address $1108 into the
    AL register (see [Figure 3-3](ch03.html#indexed_addressing_mode "Figure 3-3. Indexed
    addressing mode")).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式通过将变量的地址加到出现在方括号内的32位寄存器的值上来计算有效地址^([[36](#ftn.CHP-3-FN-3)])。它们的和即为指令访问的实际内存地址。因此，如果*`VarName`*位于内存地址$1100，而EBX中包含8，那么`mov(`*`VarName`*`[
    ebx ], al);`会将地址$1108处的字节加载到AL寄存器中（见[图3-3](ch03.html#indexed_addressing_mode "图3-3.
    索引寻址模式")）。
- en: '![Indexed addressing mode](tagoreillycom20100401nostarchimages577941.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![索引寻址模式](tagoreillycom20100401nostarchimages577941.png)'
- en: Figure 3-3. Indexed addressing mode
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3. 索引寻址模式
- en: The indexed addressing modes are really handy for accessing elements of arrays.
    You will see how to use these addressing modes for that purpose in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式对于访问数组元素非常方便。你将在[第4章](ch04.html "第4章. 常量、变量和数据类型")中看到如何使用这些寻址模式来完成这一任务。
- en: 3.1.2.4 Variations on the Indexed Addressing Mode
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.4 索引寻址模式的变体
- en: There are two important syntactical variations of the indexed addressing mode.
    Both forms generate the same basic machine instructions, but their syntax suggests
    other uses for these variants.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式有两种重要的语法变体。两种形式生成相同的基本机器指令，但它们的语法暗示了这些变体的其他用途。
- en: 'The first variant uses the following syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种变体使用以下语法：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These examples use only the EBX register. However, you can use any of the other
    32-bit general-purpose registers in place of EBX. This form computes its effective
    address by adding the value in EBX to the specified constant or subtracting the
    specified constant from EBX (see [Figure 3-4](ch03.html#indexed_addressing_mode_using_a_regi
    "Figure 3-4. Indexed addressing mode using a register plus a constant") and [Figure 3-5](ch03.html#indexed_addressing_mode_using_a_regi-id1
    "Figure 3-5. Indexed addressing mode using a register minus a constant")).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例只使用了EBX寄存器。然而，你可以使用任何其他32位通用寄存器来代替EBX。这种形式通过将EBX中的值加到指定常量上，或者将指定常量从EBX中减去来计算其有效地址（见[图3-4](ch03.html#indexed_addressing_mode_using_a_regi
    "图3-4. 使用寄存器加常量的索引寻址模式")和[图3-5](ch03.html#indexed_addressing_mode_using_a_regi-id1
    "图3-5. 使用寄存器减常量的索引寻址模式")）。
- en: '![Indexed addressing mode using a register plus a constant](tagoreillycom20100401nostarchimages577943.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用寄存器加常量的索引寻址模式](tagoreillycom20100401nostarchimages577943.png)'
- en: Figure 3-4. Indexed addressing mode using a register plus a constant
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4. 使用寄存器加常量的索引寻址模式
- en: '![Indexed addressing mode using a register minus a constant](tagoreillycom20100401nostarchimages577945.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用寄存器减去常数的索引寻址模式](tagoreillycom20100401nostarchimages577945.png)'
- en: Figure 3-5. Indexed addressing mode using a register minus a constant
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5. 使用寄存器减去常数的索引寻址模式
- en: This particular variant of the addressing mode is useful if a 32-bit register
    contains the base address of a multibyte object and you wish to access a memory
    location some number of bytes before or after that location. One important use
    of this addressing mode is accessing fields of a record (or structure) when you
    have a pointer to the record data. This addressing mode is also invaluable for
    accessing automatic (local) variables in procedures (see [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS") for more details).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻址模式的特定变体在32位寄存器包含多字节对象的基地址时非常有用，且你希望访问该位置之前或之后某个字节的内存位置。这种寻址模式的一个重要用途是在你拥有记录数据的指针时访问记录（或结构）的字段。对于访问过程中的自动（局部）变量，这种寻址模式也非常有价值（详见[第5章](ch05.html
    "第5章 程序与单元")）。
- en: 'The second variant of the indexed addressing mode is actually a combination
    of the previous two forms. The syntax for this version is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式的第二种变体实际上是前两种形式的结合体。这个版本的语法如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, this example uses only the EBX register. You may substitute any
    of the 32-bit general-purpose registers in lieu of EBX in these two examples.
    This particular form is useful when accessing elements of an array of records
    (structures) in an assembly language program (more on that in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES")).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这个示例仅使用了EBX寄存器。在这两个示例中，你可以用任何32位通用寄存器替代EBX。这个特定的形式在汇编语言程序中访问记录（结构）数组元素时非常有用（更多内容见[第4章](ch04.html
    "第4章 常量、变量和数据类型")）。
- en: These instructions compute their effective address by adding or subtracting
    the *`constant`* value from *`VarName`*'s address and then adding the value in
    EBX to this result. Note that HLA, not the CPU, computes the sum or difference
    of *`VarName`*'s address and *`constant`*. The actual machine instructions above
    contain a single constant value that the instructions add to the value in EBX
    at runtime. Because HLA substitutes a constant for *`VarName`*, it can reduce
    an instruction of the form
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通过将*`constant`*值从*`VarName`*的地址中加或减去，然后将EBX中的值加到这个结果上来计算它们的有效地址。请注意，是HLA，而不是CPU，计算*`VarName`*地址与*`constant`*的和或差。上述实际的机器指令包含一个常数值，在运行时将这个常数值加到EBX中的值上。因为HLA将常数替换为*`VarName`*，它可以将以下形式的指令简化为
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: to an instruction of the form
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变成如下形式的指令
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because of the way these addressing modes work, this is semantically equivalent
    to
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些寻址模式的工作方式，它在语义上等同于
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'HLA will add the two constants together at compile time, effectively producing
    the following instruction:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将在编译时将这两个常数相加，有效地产生以下指令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, there is nothing special about subtraction. You can easily convert
    the addressing mode involving subtraction to addition by simply taking the two's
    complement of the 32-bit constant and then adding this complemented value (rather
    than subtracting the original value).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，减法本身并没有什么特别的。你可以通过简单地取32位常数的二补码，再将该补码值相加（而不是减去原始值）轻松地将涉及减法的寻址模式转换为加法。
- en: 3.1.2.5 Scaled-Indexed Addressing Modes
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.5 缩放索引寻址模式
- en: 'The scaled-indexed addressing modes are similar to the indexed addressing modes
    with two differences: (1) The scaled-indexed addressing modes allow you to combine
    two registers plus a displacement, and (2) the scaled-indexed addressing modes
    let you multiply the index register by a (scaling) factor of 1, 2, 4, or 8\. The
    syntax for these addressing modes is'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式与索引寻址模式类似，但有两个不同之处：(1) 缩放索引寻址模式允许你结合两个寄存器加一个位移量，(2) 缩放索引寻址模式允许你将索引寄存器乘以1、2、4或8的缩放因子。这些寻址模式的语法是
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In these examples, *`BaseReg32`* represents any general-purpose 32-bit register,
    *`IndexReg32`* represents any general-purpose 32-bit register except ESP, and
    *`scale`* must be one of the constants 1, 2, 4, or 8.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，*`BaseReg32`*表示任何通用32位寄存器，*`IndexReg32`*表示除ESP外的任何通用32位寄存器，*`scale`*必须是常数1、2、4或8之一。
- en: The primary difference between the scaled-indexed addressing modes and the indexed
    addressing modes is the inclusion of the *`IndexReg32`*`*`*`scale`* component.
    These modes compute the effective address by adding in the value of this new register
    multiplied by the specified scaling factor (see [Figure 3-6](ch03.html#scaled-indexed_addressing_mode
    "Figure 3-6. Scaled-indexed addressing mode") for an example involving EBX as
    the base register and ESI as the index register).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式和索引寻址模式的主要区别在于包含了*`IndexReg32`*`*`*`scale`*组件。这些模式通过将新寄存器的值乘以指定的缩放因子后加到基地址中，从而计算有效地址（有关以EBX作为基寄存器，ESI作为索引寄存器的示例，请参见[图3-6](ch03.html#scaled-indexed_addressing_mode
    "图3-6. 缩放索引寻址模式")）。
- en: '![Scaled-indexed addressing mode](tagoreillycom20100401nostarchimages577947.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![缩放索引寻址模式](tagoreillycom20100401nostarchimages577947.png)'
- en: Figure 3-6. Scaled-indexed addressing mode
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6. 缩放索引寻址模式
- en: In [Figure 3-6](ch03.html#scaled-indexed_addressing_mode "Figure 3-6. Scaled-indexed
    addressing mode"), suppose that EBX contains $100, ESI contains $20, and *`VarName`*
    is at base address $2000 in memory; then the following instruction
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-6](ch03.html#scaled-indexed_addressing_mode "图3-6. 缩放索引寻址模式")中，假设EBX包含$100，ESI包含$20，*`VarName`*位于内存中的基地址$2000；则以下指令
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: will move the byte at address $2184 ($100 + $20*4 + 4) into the AL register.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将地址$2184（$100 + $20*4 + 4）处的字节移入AL寄存器。
- en: The scaled-indexed addressing modes are useful for accessing elements of arrays
    whose elements are 2, 4, or 8 bytes each. These addressing modes are also useful
    for access elements of an array when you have a pointer to the beginning of the
    array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式适用于访问每个元素为2、4或8字节的数组元素。当你有指向数组开始位置的指针时，这些寻址模式也非常有用。
- en: 3.1.2.6 Addressing Mode Wrap-up
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.6 寻址模式总结
- en: Well, believe it or not, you've just learned several hundred addressing modes!
    That wasn't hard now, was it? If you're wondering where all these modes came from,
    just note that the register-indirect addressing mode isn't a single addressing
    mode but eight different addressing modes (involving the eight different registers).
    Combinations of registers, constant sizes, and other factors multiply the number
    of possible addressing modes on the system. In fact, you need only memorize about
    two dozen forms and you've got it made. In practice, you'll use less than half
    the available addressing modes in any given program (and many addressing modes
    you may never use at all). So learning all these addressing modes is actually
    much easier than it sounds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，你刚刚学会了几百种寻址模式！其实并不难，对吧？如果你在想这些模式是从哪里来的，值得注意的是，寄存器间接寻址模式并不是单一的寻址模式，而是八种不同的寻址模式（涉及到八个不同的寄存器）。寄存器、常数大小和其他因素的组合，会增加系统中可能的寻址模式的数量。实际上，你只需要记住大约二十几种形式，就能应付了。实际上，在任何给定的程序中，你会使用不到一半的可用寻址模式（而且许多寻址模式你可能永远都不会用到）。因此，学习所有这些寻址模式其实比看起来要容易得多。
- en: '* * *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#CHP-3-FN-1)]) Actually, the 80x86 does support addressing modes involving
    certain 16-bit registers, as mentioned earlier. However, HLA does not support
    these modes and they are not useful under 32-bit operating systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-3-FN-1)]) 事实上，80x86确实支持涉及某些16位寄存器的寻址模式，如前所述。然而，HLA不支持这些模式，并且在32位操作系统下它们并不实用。
- en: ^([[35](#CHP-3-FN-2)]) The term *static* here indicates a `static`, `readonly`,
    or `storage` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#CHP-3-FN-2)]) 这里的*static*表示一个`static`、`readonly`或`storage`对象。
- en: ^([[36](#CHP-3-FN-3)]) The effective address is the ultimate address in memory
    that an instruction will access, once all the address calculations are complete.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#CHP-3-FN-3)]) 有效地址是指令在完成所有地址计算后将要访问的内存中的最终地址。
- en: 3.2 Runtime Memory Organization
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 运行时内存组织
- en: An operating system like Mac OS X, FreeBSD, Linux, or Windows tends to put different
    types of data into different sections (or segments) of memory. Although it is
    possible to reconfigure memory to your choice by running the linker and specifying
    various parameters, by default Windows loads an HLA program into memory using
    the organization appearing in [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization") (Linux, Mac OS X, and FreeBSD
    are similar, though they rearrange some of the sections).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类似Mac OS X、FreeBSD、Linux或Windows的操作系统倾向于将不同类型的数据放入内存的不同段（或区域）。尽管通过运行链接器并指定不同的参数，可以重新配置内存的布局，但默认情况下，Windows使用[图3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "图3-7. HLA典型的运行时内存组织")中显示的内存组织加载HLA程序（Linux、Mac OS X和FreeBSD类似，尽管它们对一些段进行了重新安排）。
- en: '![HLA typical runtime memory organization](tagoreillycom20100401nostarchimages577949.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![HLA典型的运行时内存组织](tagoreillycom20100401nostarchimages577949.png)'
- en: Figure 3-7. HLA typical runtime memory organization
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-7. HLA典型的运行时内存组织
- en: The operating system reserves the lowest memory addresses. Generally, your application
    cannot access data (or execute instructions) at these low addresses. One reason
    the operating system reserves this space is to help trap NULL pointer references.
    If you attempt to access memory location 0, the operating system will generate
    a general protection fault, meaning you've accessed a memory location that doesn't
    contain valid data. Because programmers often initialize pointers to NULL (0)
    to indicate that the pointer is not pointing anywhere, an access of location 0
    typically means that the programmer has made a mistake and has not properly initialized
    a pointer to a legal (non-NULL) value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统保留了最低的内存地址。通常，你的应用程序无法访问这些低地址处的数据（或执行指令）。操作系统保留这些空间的一个原因是帮助捕捉NULL指针引用。如果你尝试访问内存位置0，操作系统将生成一个通用保护错误，这意味着你访问了一个没有有效数据的内存位置。因为程序员通常将指针初始化为NULL（0）以表示指针未指向任何位置，因此访问位置0通常意味着程序员犯了错误，没有正确初始化指针为合法的（非NULL）值。
- en: The remaining six areas in the memory map hold different types of data associated
    with your program. These sections of memory include the `stack` section, the `heap`
    section, the `code` section, the `readonly` section, the `static` section, and
    the `storage` section. Each of these memory sections correspond to some type of
    data you can create in your HLA programs. Each section is discussed in detail
    below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射中的其余六个区域保存与你的程序相关的不同类型的数据。这些内存段包括`stack`段、`heap`段、`code`段、`readonly`段、`static`段和`storage`段。每个内存段对应你可以在HLA程序中创建的某种类型的数据。下面将详细讨论每个段。
- en: 3.2.1 The code Section
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.1 代码段
- en: The `code` section contains the machine instructions that appear in an HLA program.
    HLA translates each machine instruction you write into a sequence of one or more
    byte values. The CPU interprets these byte values as machine instructions during
    program execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`code`段包含出现在HLA程序中的机器指令。HLA将你编写的每条机器指令翻译成一个或多个字节值的序列。在程序执行期间，CPU将这些字节值解释为机器指令。'
- en: By default, when HLA links your program it tells the system that your program
    can execute instructions in the code segment and you can read data from the code
    segment. Note, specifically, that you cannot write data to the code segment. The
    operating system will generate a general protection fault if you attempt to store
    any data into the code segment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当HLA链接你的程序时，它会告诉系统你的程序可以在代码段中执行指令，并且你可以从代码段读取数据。特别注意，你不能向代码段写入数据。如果你尝试将数据存储到代码段中，操作系统将生成一个通用保护错误。
- en: Remember, machine instructions are nothing more than data bytes. In theory,
    you could write a program that stores data values into memory and then transfers
    control to the data it just wrote, thereby producing a program that writes itself
    as it executes. This possibility produces romantic visions of *Artificial Intelligence*
    programs that modify themselves to produce some desired result. In real life,
    the effect is somewhat less glamorous. Generally, self-modifying programs are
    very difficult to debug because the instructions are constantly changing behind
    the programmer's back. Because most modern operating systems make it very difficult
    to write self-modifying programs, we will not consider them any further in this
    text.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，机器指令不过是数据字节。从理论上讲，您可以编写一个程序，将数据值存储到内存中，然后将控制权转移到它刚写入的数据上，从而产生一个在执行时自己写自己的程序。这种可能性激发了人们对
    *人工智能* 程序的浪漫幻想，这些程序能够自我修改以产生期望的结果。但在现实生活中，效果要少得多，远没有那么光彩。通常，自我修改的程序非常难以调试，因为指令在程序员的背后不断变化。由于大多数现代操作系统使得编写自我修改的程序变得非常困难，因此我们在本文中不会进一步讨论它们。
- en: HLA automatically stores the data associated with your machine code into the
    code section. In addition to machine instructions, you can also store data into
    the code section by using the following pseudo-opcodes:^([[37](#ftn.CHP-3-FN-4)])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 会自动将与机器代码关联的数据存储到代码区。除了机器指令之外，您还可以通过使用以下伪操作码将数据存储到代码区：^([[37](#ftn.CHP-3-FN-4)])
- en: '| `byte` | `int8` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `int8` |'
- en: '| `word` | `int16` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `word` | `int16` |'
- en: '| `dword` | `in32` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `dword` | `in32` |'
- en: '| `uns8` | `boolean` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `uns8` | `boolean` |'
- en: '| `uns16` | `char` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `uns16` | `char` |'
- en: '| `uns32` |   |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `uns32` |   |'
- en: 'The following `byte` statement exemplifies the syntax for each of these pseudo-opcodes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `byte` 语句展示了每个伪操作码的语法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If more than one value appears in the list of values after the pseudo-opcode,
    HLA emits each successive value to the code stream. So the first `byte` statement
    above emits 3 bytes to the code stream, the values 0, 1, and 2\. If a string appears
    within a `byte` statement, HLA emits 1 byte of data for each character in the
    string. Therefore, the second byte statement above emits 6 bytes: the characters
    `H`, `e`, `l`, `l`, and `o`, followed by a `0` byte.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果伪操作码后面的值列表中出现多个值，HLA 会将每个连续的值发送到代码流中。因此，上面的第一个 `byte` 语句会向代码流发送 3 个字节，值分别为
    0、1 和 2。如果字符串出现在 `byte` 语句中，HLA 会为字符串中的每个字符发送 1 个字节的数据。因此，上面的第二个 `byte` 语句会发送
    6 个字节：字符 `H`、`e`、`l`、`l` 和 `o`，然后是一个 `0` 字节。
- en: 'Keep in mind that the CPU will attempt to treat data you emit to the code stream
    as machine instructions unless you take special care not to allow the execution
    of the data. For example, if you write something like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非特别小心以防止数据执行，否则 CPU 会尝试将您发送到代码流中的数据当作机器指令来处理。例如，如果您写下以下内容：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: your program will attempt to execute the `0`, `1`, `2`, and `3` byte values
    as machine instructions after executing the `mov`. Unless you know the machine
    code for a particular instruction sequence, sticking such data values into the
    middle of your code will generally crash your program. Typically when you place
    such data in your programs, you'll execute some code that transfers control around
    the data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `mov` 指令后，您的程序会尝试将 `0`、`1`、`2` 和 `3` 字节值作为机器指令执行。除非您知道某个指令序列的机器码，否则将这样的数据值直接插入代码中通常会导致程序崩溃。通常，当您在程序中插入这样的数据时，您会执行一些代码，将控制权转移到数据所在位置。
- en: 3.2.2 The static Section
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.2 静态区
- en: The `static` section is where you will typically declare your variables. Although
    the `static` section syntactically appears as part of a program or procedure,
    keep in mind that HLA moves all static variables to the `static` section in memory.
    Therefore, HLA does not sandwich the variables you declare in the `static` section
    between procedures in the `code` section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 区通常是您声明变量的地方。尽管 `static` 区在语法上看起来像是程序或过程的一部分，但请记住，HLA 会将所有静态变量移动到内存中的
    `static` 区。因此，HLA 不会将您在 `static` 区声明的变量夹在 `code` 区的过程之间。'
- en: 'In addition to declaring static variables, you can also embed lists of data
    into the `static` declaration section. You use the same technique to embed data
    into your `static` section that you use to embed data into the `code` section:
    You use the `byte`, `word`, `dword`, `uns32`, and so on pseudo-opcodes. Consider
    the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明静态变量，你还可以将数据列表嵌入到`static`声明区。你可以使用与将数据嵌入到`code`区相同的技巧，将数据嵌入到`static`区：你使用`byte`、`word`、`dword`、`uns32`等伪操作码。考虑以下示例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Data that HLA writes to the `static` memory segment using these pseudo-opcodes
    is written to the segment after the preceding variables. For example, the byte
    values `1`, `2`, and `3` are emitted to the `static` section after `b`'s `0` byte.
    Because there aren't any labels associated with these values, you do not have
    direct access to these values in your program. You can use the indexed addressing
    modes to access these extra values (examples appear in [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用这些伪操作码写入`static`内存段的数据，会在前面变量之后写入该段。例如，字节值`1`、`2`和`3`会在`b`的`0`字节之后被写入`static`区。由于这些值没有与标签关联，你无法在程序中直接访问这些值。你可以使用索引寻址模式来访问这些额外的值（示例见[第4章](ch04.html
    "第4章 常量、变量和数据类型")）。
- en: In the examples above, note that the `c` and `bn` variables do not have an (explicit)
    initial value. However, if you don't provide an initial value, HLA will initialize
    the variables in the `static` section to all 0 bits, so HLA assigns the NUL character
    (ASCII code 0) to `c` as its initial value. Likewise, HLA assigns false as the
    initial value for `bn`. In particular, you should note that your variable declarations
    in the `static` section always consume memory, even if you haven't assigned them
    an initial value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，请注意`c`和`bn`变量没有（显式）初始值。然而，如果你没有提供初始值，HLA会将`static`区中的变量初始化为全0位，因此HLA将NUL字符（ASCII码0）赋给`c`作为其初始值。同样，HLA将`false`作为`bn`的初始值。特别需要注意的是，即使你没有为变量分配初始值，`static`区中的变量声明仍然会占用内存。
- en: 3.2.3 The readonly Data Section
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.3 只读数据区
- en: 'The `readonly` data section holds constants, tables, and other data that your
    program cannot change during execution. You create read-only objects by declaring
    them in the `readonly` declaration section. The `readonly` section is very similar
    to the `static` section with three primary differences:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`数据区包含常量、表格和程序在执行过程中无法修改的其他数据。你通过在`readonly`声明区中声明它们来创建只读对象。`readonly`区与`static`区非常相似，主要有三个区别：'
- en: The `readonly` section begins with the reserved word `readonly` rather than
    `static`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`区以保留字`readonly`开头，而不是`static`。'
- en: All declarations in the `readonly` section generally have an initializer.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`区中的所有声明通常都有初始化值。'
- en: The system does not allow you to store data into a `readonly` object while the
    program is running.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统不允许你在程序运行时将数据存储到`readonly`对象中。
- en: 'Here''s an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All `readonly` object declarations must have an initializer because you cannot
    initialize the value under program control.^([[38](#ftn.CHP-3-FN-5)]) For all
    intents and purposes, you can think of `readonly` objects as constants. However,
    these constants consume memory, and other than the fact that you cannot write
    data to `readonly` objects, they behave like `static` variables. Because they
    behave like `static` objects, you cannot use a `readonly` object everywhere a
    constant is allowed; in particular, `readonly` objects are memory objects, so
    you cannot supply a `readonly` object (which you are treating like a constant)
    and some other memory object as the operands to an instruction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`readonly`对象声明必须有初始化值，因为你无法在程序控制下初始化该值。^([[38](#ftn.CHP-3-FN-5)]) 就所有实际目的而言，你可以将`readonly`对象视为常量。然而，这些常量占用内存，除了不能写入数据到`readonly`对象外，它们的行为类似于`static`变量。因为它们的行为像`static`对象一样，你不能在常量允许的任何地方使用`readonly`对象；特别是，`readonly`对象是内存对象，因此你不能将一个`readonly`对象（你视为常量）和其他内存对象作为操作数传递给指令。
- en: 'As with the `static` section, you may embed data values in the `readonly` section
    using the `byte`, `word`, `dword`, and so on data declarations. For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与`static`区一样，你可以使用`byte`、`word`、`dword`等数据声明将数据值嵌入到`readonly`区。例如：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 3.2.4 The storage Section
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.4 存储区
- en: 'The `readonly` section requires that you initialize all objects you declare.
    The `static` section lets you optionally initialize objects (or leave them uninitialized,
    in which case they have the default initial value of 0). The `storage` section
    completes the initialization coverage: you use it to declare variables that are
    always uninitialized when the program begins running. The `storage` section begins
    with the `storage` reserved word and contains variable declarations without initializers.
    Here is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`部分要求你初始化所有声明的对象。`static`部分让你选择性地初始化对象（或者将它们保持未初始化状态，在这种情况下，它们的默认初始值为0）。`storage`部分完成了初始化的覆盖：你用它来声明在程序开始运行时始终未初始化的变量。`storage`部分以`storage`保留字开始，并包含没有初始化器的变量声明。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Linux, FreeBSD, Mac OS X, and Windows will initialize all storage objects to
    0 when they load your program into memory. However, it's probably not a good idea
    to depend on this implicit initialization. If you need an object initialized with
    0, declare it in a `static` section and explicitly set it to 0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux、FreeBSD、Mac OS X 和 Windows 在将程序加载到内存时会将所有存储对象初始化为 0。然而，依赖这种隐式初始化可能不是一个好主意。如果你需要一个初始化为
    0 的对象，可以在`static`部分声明它，并显式地将其设置为 0。
- en: Variables you declare in the `storage` section may consume less disk space in
    the executable file for the program. This is because HLA writes out initial values
    for `readonly` and `static` objects to the executable file, but it may use a compact
    representation for uninitialized variables you declare in the `storage` section;
    note, however, that this behavior is OS- and object-module-format dependent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`storage`部分声明的变量可能会减少程序可执行文件中的磁盘空间占用。这是因为HLA会将`readonly`和`static`对象的初始值写入可执行文件，但它可能会使用紧凑的表示方式来存储你在`storage`部分声明的未初始化变量；但请注意，这种行为依赖于操作系统和对象模块格式。
- en: Because the `storage` section does not allow initialized values, you *cannot*
    put unlabeled values in the `storage` section using the `byte`, `word`, `dword`,
    and so on pseudo-opcodes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`storage`部分不允许初始化值，所以你*不能*在`storage`部分使用`byte`、`word`、`dword`等伪操作码来放置没有标签的值。
- en: 3.2.5 The @nostorage Attribute
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.5 `@nostorage`属性
- en: 'The `@nostorage` attribute lets you declare variables in the static data declaration
    sections (i.e., `static`, `readonly`, and `storage`) without actually allocating
    memory for the variable. The `@nostorage` option tells HLA to assign the current
    address in a declaration section to a variable but not to allocate any storage
    for the object. That variable will share the same memory address as the next object
    appearing in the variable declaration section. Here is the syntax for the `@nostorage`
    option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nostorage`属性让你在静态数据声明部分（即`static`、`readonly`和`storage`）声明变量，而不实际为变量分配内存。`@nostorage`选项告诉HLA将当前地址分配给声明部分中的变量，但不为对象分配任何存储空间。该变量将与变量声明部分中下一个出现的对象共享相同的内存地址。以下是`@nostorage`选项的语法：'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that you follow the type name with `@nostorage;` rather than some initial
    value or just a semicolon. The following code sequence provides an example of
    using the `@nostorage` option in the `readonly` section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你在类型名称后跟上`@nostorage;`，而不是一些初始值或仅仅是分号。以下代码序列提供了在`readonly`部分中使用`@nostorage`选项的示例：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, `abcd` is a double word whose L.O. byte contains 97 (`'a'`),
    byte 1 contains 98 (`'b'`), byte 2 contains 99 (`'c'`), and the H.O. byte contains
    100 (`'d'`). HLA does not reserve storage for the `abcd` variable, so HLA associates
    the following 4 bytes in memory (allocated by the `byte` directive) with `abcd`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`abcd`是一个双字，其中最低字节包含97（`'a'`），字节1包含98（`'b'`），字节2包含99（`'c'`），最高字节包含100（`'d'`）。HLA不会为`abcd`变量分配存储空间，因此HLA会将内存中以下4个字节（由`byte`指令分配）与`abcd`关联。
- en: Note that the `@nostorage` attribute is legal only in the `static`, `storage`,
    and `readonly` sections (the so-called *static* declarations sections). HLA does
    not allow its use in the `var` section that you'll read about next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@nostorage`属性仅在`static`、`storage`和`readonly`部分（所谓的*静态*声明部分）合法。HLA不允许在接下来会介绍的`var`部分中使用它。
- en: 3.2.6 The var Section
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.6 `var`部分
- en: HLA provides another variable declaration section, the `var` section, that you
    can use to create *automatic* variables. Your program will allocate storage for
    automatic variables whenever a program unit (i.e., main program or procedure)
    begins execution, and it will deallocate storage for automatic variables when
    that program unit returns to its caller. Of course, any automatic variables you
    declare in your main program have the same *lifetime* ^([[39](#ftn.CHP-3-FN-6)])
    as all the `static`, `readonly`, and `storage` objects, so the automatic allocation
    feature of the `var` section is wasted in the main program. In general, you should
    use automatic objects only in procedures (see [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS") for details). HLA allows them in your main program's declaration section
    as a generalization.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Because variables you declare in the `var` section are created at runtime,
    HLA does not allow initializers on variables you declare in this section. So the
    syntax for the `var` section is nearly identical to that for the `storage` section;
    the only real difference in the syntax between the two is the use of the `var`
    reserved word rather than the `storage` reserved word.^([[40](#ftn.CHP-3-FN-7)])
    The following example illustrates this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: HLA allocates variables you declare within the `var` section within the `stack`
    memory section. HLA does not allocate `var` objects at fixed locations; instead,
    it allocates these variables in an activation record associated with the current
    program unit. [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS") discusses
    activation records in greater detail; for now it is important only to realize
    that HLA programs use the EBP register as a pointer to the current activation
    record. Therefore, whenever you access a `var` object, HLA automatically replaces
    the variable name with `[EBP±`*`displacement`*`]`. Displacement is the offset
    of the object within the activation record. This means that you cannot use the
    full scaled-indexed addressing mode (a base register plus a scaled index register)
    with `var` objects because `var` objects already use the EBP register as their
    base register. Although you will not directly use the two register addressing
    modes often, the fact that the `var` section has this limitation is a good reason
    to avoid using the `var` section in your main program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.7 Organization of Declaration Sections Within Your Programs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `static`, `readonly`, `storage`, and `var` sections may appear zero or
    more times between the `program` header and the associated `begin` for the main
    program. Between these two points in your program, the declaration sections may
    appear in any order, as the following example demonstrates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to demonstrating that the sections may appear in an arbitrary order,
    this section also demonstrates that a given declaration section may appear more
    than once in your program. When multiple declaration sections of the same type
    (for example, the three `storage` sections above) appear in a declaration section
    of your program, HLA combines them into a single group.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#CHP-3-FN-4)]) This isn't a complete list. HLA generally allows you
    to use any scalar data type name as a statement to reserve storage in the code
    section. You'll learn more about the available data types in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#CHP-3-FN-5)]) There is one exception you'll see in [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#CHP-3-FN-6)]) The lifetime of a variable is the point from which memory
    is first allocated to the point the memory is deallocated for that variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#CHP-3-FN-7)]) Actually, there are a few other, minor, differences,
    but we won't deal with those differences in this text. See the HLA language reference
    manual for more details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 How HLA Allocates Memory for Variables
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've seen, the 80x86 CPU doesn't deal with variables that have names like
    `I`, `Profits`, and `LineCnt`. The CPU deals strictly with numeric addresses it
    can place on the address bus like $1234_5678, $0400_1000, and $8000_CC00\. HLA,
    on the other hand, does not force to you refer to variable objects by their addresses
    (which is nice, because names are so much easier to remember). This is good, but
    it does obscure what is really going on. In this section, we'll take a look at
    how HLA associates numeric addresses with your variables so you'll understand
    (and appreciate) the process that is taking place behind your back.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Take another look at [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization"). As you can see, the various
    memory sections tend to be adjacent to one another. Therefore, if the size of
    one memory section changes, then this affects the starting address of all the
    following sections in memory. For example, if you add a few additional machine
    instructions to your program and increase the size of the `code` section, this
    may affect the starting address of the `static` section in memory, thus changing
    the addresses of all your static variables. Keeping track of variables by their
    numeric address (rather than by their names) is difficult enough; imagine how
    much worse it would be if the addresses are constantly shifting around as you
    add and remove machine instructions in your program! Fortunately, you don't have
    to keep track of variable addresses; HLA does that bookkeeping for you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA associates a current *location counter* with each of the three static declaration
    sections (`static`, `readonly`, and `storage`). These location counters initially
    contain 0, and whenever you declare a variable in one of the static sections,
    HLA associates the current value of that section''s location counter with the
    variable; HLA also bumps up the value of that location counter by the size of
    the object you''re declaring. As an example, assume that the following is the
    only `static` declaration section in a program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, the runtime address of each of these variables is not the value
    of the location counter. First of all, HLA adds in the base address of the `static`
    memory section to each of these location counter values (which we call *displacements*
    or *offsets*). Second, there may be other static objects in modules that you link
    with your program (e.g., from the HLA Standard Library) or even additional `static`
    sections in the same source file, and the linker has to merge the `static` sections
    together. Hence, these offsets may have very little bearing on the final address
    of these variables in memory. Nevertheless, one important fact remains: HLA allocates
    variables you declare in a single `static` declaration section in contiguous memory
    locations. That is, given the declaration above, `w` will immediately follow `b`
    in memory, `d` will immediately follow `w` in memory, `q` will immediately follow
    `d`, and so on. Generally, it''s not good coding style to assume that the system
    allocates variables this way, but sometimes it''s convenient to do so.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that HLA allocates memory objects you declare in `readonly`, `static`,
    and `storage` sections in completely different regions of memory. Therefore, you
    cannot assume that the following three memory objects appear in adjacent memory
    locations (indeed, they probably will not):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In fact, HLA will not even guarantee that variables you declare in separate
    `static` (or whatever) sections are adjacent in memory, even if there is nothing
    between the declarations in your code (for example, you cannot assume that `b`,
    `w`, and `d` are in adjacent memory locations in the following declarations, nor
    can you assume that they *won''t* be adjacent in memory):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If your code requires these variables to consume adjacent memory locations,
    you must declare them in the same `static` section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Note that HLA handles variables you declare in the `var` section a little differently
    than the variables you declare in one of the `static` sections. We'll discuss
    the allocation of offsets to `var` objects in [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 HLA Support for Data Alignment
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write fast programs, you need to ensure that you properly align
    data objects in memory. Proper alignment means that the starting address for an
    object is a multiple of some size, usually the size of an object if the object's
    size is a power of 2 for values up to 16 bytes in length. For objects greater
    than 16 bytes, aligning the object on an 8-byte or 16-byte address boundary is
    probably sufficient. For objects less than 16 bytes, aligning the object at an
    address that is the next power of 2 greater than the object's size is usually
    fine. Accessing data that is not aligned at an appropriate address may require
    extra time; so if you want to ensure that your program runs as rapidly as possible,
    you should try to align data objects according to their size.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Data becomes misaligned whenever you allocate storage for different-sized objects
    in adjacent memory locations. For example, if you declare a byte variable, it
    will consume 1 byte of storage, and the next variable you declare in that declaration
    section will have the address of that byte object plus 1\. If the byte variable's
    address happens to be an even address, then the variable following that byte will
    start at an odd address. If that following variable is a word or double-word object,
    then its starting address will not be optimal. In this section, we'll explore
    ways to ensure that a variable is aligned at an appropriate starting address based
    on that object's size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following HLA variable declarations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first `static` declaration in a program (running under Windows, Mac OS
    X, FreeBSD, Linux, and most 32-bit operating systems) places its variables at
    an address that is an even multiple of 4,096 bytes. Whatever variable first appears
    in the `static` declaration is guaranteed to be aligned on a reasonable address.
    Each successive variable is allocated at an address that is the sum of the sizes
    of all the preceding variables plus the starting address of that `static` section.
    Therefore, assuming HLA allocates the variables in the previous example at a starting
    address of `4096`, HLA will allocate them at the following addresses:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the exception of the first variable (which is aligned on a 4KB boundary)
    and the byte variables (whose alignment doesn't matter), all of these variables
    are misaligned. The `w`, `w2`, and `dw2` variables start at odd addresses, and
    the `dw3` variable is aligned on an even address that is not a multiple of 4.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to guarantee that your variables are aligned properly is to put
    all the double-word variables first, the word variables second, and the byte variables
    last in the declaration, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This organization produces the following addresses in memory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, these variables are all aligned at reasonable addresses.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is rarely possible for you to arrange your variables in this
    manner. While there are many technical reasons that make this alignment impossible,
    a good practical reason for not doing this is that it doesn't let you organize
    your variable declarations by logical function (that is, you probably want to
    keep related variables next to one another regardless of their size).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this problem, HLA provides the `align` directive. The `align` directive
    uses the following syntax:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The integer constant must be one of the following small unsigned integer values:
    1, 2, 4, 8, or 16\. If HLA encounters the `align` directive in a `static` section,
    it will align the very next variable on an address that is an even multiple of
    the specified alignment constant. The previous example could be rewritten, using
    the `align` directive, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you're wondering how the `align` directive works, it's really quite simple.
    If HLA determines that the current address (location counter value) is not an
    even multiple of the specified value, HLA will quietly emit extra bytes of padding
    after the previous variable declaration until the current address in the `static`
    section is an even multiple of the specified value. This has the effect of making
    your program slightly larger (by a few bytes) in exchange for faster access to
    your data. Given that your program will grow by only a few bytes when you use
    this feature, this is probably a good trade-off.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, if you want the fastest possible access, you should choose
    an alignment value that is equal to the size of the object you want to align.
    That is, you should align words to even boundaries using an `align(2);` statement,
    double words to 4-byte boundaries using `align(4);`, quad words to 8-byte boundaries
    using `align(8);`, and so on. If the object's size is not a power of 2, align
    it to the next higher power of 2 (up to a maximum of 16 bytes). Note, however,
    that you need only align `real80` (and `tbyte`) objects on an 8-byte boundary.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Note that data alignment isn't always necessary. The cache architecture of modern
    80x86 CPUs actually handles most misaligned data. Therefore, you should use the
    alignment directives only with variables for which speedy access is absolutely
    critical. This is a reasonable space/speed trade-off.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Address Expressions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, this chapter points out that addressing modes take a couple generic
    forms, including the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another legal form, which isn''t actually a new addressing mode but simply
    an extension of the displacement-only addressing mode, is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This latter example computes its effective address by adding the constant offset
    within the brackets to the variable's address. For example, the instruction `mov(Address[3],
    al);` loads the AL register with the byte in memory that is 3 bytes beyond the
    `Address` object (see [Figure 3-8](ch03s05.html#using_an_address_expression_to_access_da
    "Figure 3-8. Using an address expression to access data beyond a variable")).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that the *`offset`* value in these examples must be a constant.
    If `Index` is an `int32` variable, then `Variable[Index]` is not a legal address
    expression. If you wish to specify an index that varies at runtime, then you must
    use one of the indexed or scaled-indexed addressing modes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to remember is that the offset in `Address[`*`offset`*`]`
    is a byte address. Despite the fact that this syntax is reminiscent of array indexing
    in a high-level language like C/C++ or Pascal, this does not properly index into
    an array of objects unless `Address` is an array of bytes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an address expression to access data beyond a variable](tagoreillycom20100401nostarchimages577951.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8. Using an address expression to access data beyond a variable
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'This text will consider an *address expression* to be any legal 80x86 addressing
    mode that includes a displacement (i.e., variable name) or an offset. In addition
    to the above forms, the following are also address expressions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This book will *not* consider the following to be address expressions because
    they do not involve a displacement or offset component:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Address expressions are special because those instructions containing an address
    expression always encode a displacement constant as part of the machine instruction.
    That is, the machine instruction contains some number of bits (usually 8 or 32)
    that hold a numeric constant. That constant is the sum of the displacement (i.e.,
    the address or offset of the variable) plus the offset. Note that HLA automatically
    adds these two values together for you (or subtracts the offset if you use the
    `−` rather than `+` operator in the addressing mode).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Until this point, the offset in all the addressing mode examples has always
    been a single numeric constant. However, HLA also allows a *constant expression*
    anywhere an offset is legal. A constant expression consists of one or more constant
    terms manipulated by operators such as addition, subtraction, multiplication,
    division, modulo, and a wide variety of others. Most address expressions, however,
    will involve only addition, subtraction, multiplication, and sometimes division.
    Consider the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This instruction will move the byte at address `X+9` into the AL register.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The value of an address expression is always computed at compile time, never
    while the program is running. When HLA encounters the instruction above, it calculates
    2 * 4 + 1 on the spot and adds this result to the base address of `X` in memory.
    HLA encodes this single sum (base address of `X` plus 9) as part of the instruction;
    HLA does not emit extra instructions to compute this sum for you at runtime (which
    is good, because doing so would be less efficient). Because HLA computes the value
    of address expressions at compile time, all components of the expression must
    be constants because HLA cannot know the runtime value of a variable while it
    is compiling the program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Address expressions are useful for accessing the data in memory beyond a variable,
    particularly when you've used the `byte`, `word`, `dword`, and so on statements
    in a `static` or `readonly` section to tack on additional bytes after a data declaration.
    For example, consider the program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions").
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1. Demonstration of address expressions
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions") will display the four values
    0, 1, 2, and 3 as though they were array elements. This is because the value at
    the address of `i` is 0 (this program declares `i` using the `@nostorage` option,
    so `i` is the address of the next object in the `static` section, which just happens
    to be the value 0 appearing as part of the `byte` statement). The address expression
    `i[1]` tells HLA to fetch the byte appearing at `i`'s address plus 1\. This is
    the value 1, because the `byte` statement in this program emits the value 1 to
    the `static` segment immediately after the value 0\. Likewise for `i[2]` and `i[3]`,
    this program displays the values 2 and 3.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Type Coercion
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although HLA is fairly loose when it comes to type checking, HLA does ensure
    that you specify appropriate operand sizes to an instruction. For example, consider
    the following (incorrect) program:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: HLA will generate errors for these three `mov` instructions. This is because
    the operand sizes are incompatible. The first instruction attempts to move a byte
    into EAX, the second instruction attempts to move a word into AL, and the third
    instruction attempts to move a double word into AX. The `mov` instruction, of
    course, requires both operands to be the same size.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a good feature in HLA,^([[41](#ftn.CHP-3-FN-8)]) there are times
    when it gets in the way. Consider the following code fragments:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example let's assume that the programmer really wants to load the word
    starting at the address of `byte_values` into the AX register because she wants
    to load AL with 0 and AH with 1 using a single instruction (note that 0 is held
    in the L.O. memory byte and 1 is held in the H.O. memory byte). HLA will refuse,
    claiming there is a type mismatch error (because `byte_values` is a byte object
    and AX is a word object). The programmer could break this into two instructions,
    one to load AL with the byte at address `byte_values` and the other to load AH
    with the byte at address `byte_values[1]`. Unfortunately, this decomposition makes
    the program slightly less efficient (which was probably the reason for using the
    single `mov` instruction in the first place). Somehow, it would be nice if we
    could tell HLA that we know what we're doing and we want to treat the `byte_values`
    variable as a `word` object. HLA's type coercion facilities provide this capability.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*Type coercion*^([[42](#ftn.CHP-3-FN-9)]) is the process of telling HLA that
    you want to treat an object as an explicit type, regardless of its actual type.
    To coerce the type of a variable, you use the following syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The *`newTypeName`* item is the new type you wish to associate with the memory
    location specified by *`addressExpression`*. You may use this coercion operator
    anywhere a memory address is legal. To correct the previous example, so HLA doesn''t
    complain about type mismatches, you would use the following statement:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This instruction tells HLA to load the AX register with the word starting at
    address *`byte_values`* in memory. Assuming *`byte_values`* still contains its
    initial values, this instruction will load 0 into AL and 1 into AH.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Type coercion is necessary when you specify an anonymous variable as the operand
    to an instruction that directly modifies memory (e.g., `neg`, `shl`, `not`, and
    so on). Consider the following statement:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'HLA will generate an error on this instruction because it cannot determine
    the size of the memory operand. The instruction does not supply sufficient information
    to determine whether the program should invert the bits in the byte pointed at
    by EBX, the word pointed at by EBX, or the double word pointed at by EBX. You
    must use type coercion to explicitly specify the size of anonymous references
    with these types of instructions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Warning
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the type coercion operator unless you know exactly what you are doing
    and fully understand the effect it has on your program. Beginning assembly language
    programmers often use type coercion as a tool to quiet the compiler when it complains
    about type mismatches without solving the underlying problem.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following statement (where *`byteVar`* is an 8-bit variable):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Without the type coercion operator, HLA complains about this instruction because
    it attempts to store a 32-bit register in an 8-bit memory location. A beginning
    programmer, wanting his program to compile, may take a shortcut and use the type
    coercion operator, as shown in this instruction; this certainly quiets the compiler—it
    will no longer complain about a type mismatch—so the beginning programmer is happy.
    However, the program is still incorrect; the only difference is that HLA no longer
    warns you about your error. The type coercion operator does not fix the problem
    of attempting to store a 32-bit value into an 8-bit memory location—it simply
    allows the instruction to store a 32-bit value *starting at the address specified
    by the 8-bit variable*. The program still stores 4 bytes, overwriting the 3 bytes
    following *`byteVar`* in memory. This often produces unexpected results, including
    the phantom modification of variables in your program.^([[43](#ftn.CHP-3-FN-10)])
    Another, rarer possibility is for the program to abort with a general protection
    fault. This can occur if the 3 bytes following *`byteVar`* are not allocated in
    real memory or if those bytes just happen to fall in a read-only segment in memory.
    The important thing to remember about the type coercion operator is this: If you
    cannot exactly state the effect this operator has, don''t use it.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Also keep in mind that the type coercion operator does not perform any translation
    of the data in memory. It simply tells the compiler to treat the bits in memory
    as a different type. It will not automatically extend an 8-bit value to 32 bits,
    nor will it convert an integer to a floating-point value. It simply tells the
    compiler to treat the bit pattern of the memory operand as a different type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#CHP-3-FN-8)]) After all, if the two operand sizes are different this
    usually indicates an error in the program.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#CHP-3-FN-9)]) This is also called *type casting* in some languages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ^([[43](#CHP-3-FN-10)]) If you have a variable immediately following *`byteVar`*
    in this example, the `mov` instruction will surely overwrite the value of that
    variable, whether or not you intend for this to happen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Register Type Coercion
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also cast a register to a specific type using the type coercion operator.
    By default, the 8-bit registers are of type `byte`, the 16-bit registers are of
    type `word`, and the 32-bit registers are of type `dword`. With type coercion,
    you can cast a register as a different type *as long as the size of the new type
    agrees with the size of the register*. This is an important restriction that does
    not exist when applying type coercion to a memory variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time you do not need to coerce a register to a different type. As
    `byte`, `word`*,* and `dword` objects, registers are already compatible with all
    1-, 2-, and 4-byte objects. However, there are a few instances where register
    type coercion is handy, if not downright necessary. Two examples include boolean
    expressions in HLA high-level language statements (e.g., `if` and `while`) and
    register I/O in the `stdout.put` and `stdin.get` (and related) statements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'In boolean expressions, HLA always treats `byte`, `word`, and `dword` objects
    as unsigned values. Therefore, without type coercion, the following `if` statement
    always evaluates false (because there is no unsigned value less than 0):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can overcome this limitation by casting EAX as an `int32` value:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In a similar vein, the HLA Standard Library `stdout.put` routine always outputs
    `byte`, `word`, and `dword` values as hexadecimal numbers. Therefore, if you attempt
    to print a register, the `stdout.put` routine will print it as a hex value. If
    you would like to print the value as some other type, you can use register type
    coercion to achieve this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The same is true for the `stdin.get` routine. It will always read a hexadecimal
    value for a register unless you coerce its type to something other than `byte`,
    `word`, or `dword`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 The stack Segment and the push and pop Instructions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter mentions that all variables you declare in the `var` section wind
    up in the `stack` memory segment. However, `var` objects are not the only things
    in the `stack` memory section; your programs manipulate data in the `stack` segment
    in many different ways. This section describes the stack and introduces the `push`
    and `pop` instructions that manipulate data in the `stack` section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The `stack` segment in memory is where the 80x86 maintains the stack. The *stack*
    is a dynamic data structure that grows and shrinks according to certain needs
    of the program. The stack also stores important information about the program
    including local variables, subroutine information, and temporary data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The 80x86 controls its stack via the ESP (stack pointer) register. When your
    program begins execution, the operating system initializes ESP with the address
    of the last memory location in the `stack` memory segment. Data is written to
    the `stack` segment by "pushing" data onto the stack and "popping" data off the
    stack.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.1 The Basic push Instruction
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the syntax for the 80x86 `push` instruction:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These six forms allow you to push `word` or `dword` registers, memory locations,
    and constants. You should specifically note that you cannot push `byte` values
    onto the stack.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` instruction does the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `pushw` and `pushd` operands are always 2- and 4-byte constants, respectively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that ESP contains $00FF_FFE8, then the instruction `push( eax );` will
    set ESP to $00FF_FFE4 and store the current value of EAX into memory location
    $00FF_FFE4, as [Figure 3-9](ch03s08.html#stack_segment_before_the_push_open_paren
    "Figure 3-9. Stack segment before the push( eax ); operation") and [Figure 3-10](ch03s08.html#stack_segment_after_the_push_open_parent
    "Figure 3-10. Stack segment after the push( eax ); operation") show.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack segment before the push( eax ); operation](tagoreillycom20100401nostarchimages577953.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9. Stack segment before the `push( eax );` operation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack segment after the push( eax ); operation](tagoreillycom20100401nostarchimages577955.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10. Stack segment after the `push( eax );` operation
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `push( eax );` instruction does not affect the value of the EAX
    register.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Although the 80x86 supports 16-bit push operations, their primary use in is
    16-bit environments such as MS-DOS. For maximum performance, the stack pointer's
    value should always be an even multiple of 4; indeed, your program may malfunction
    under a 32-bit OS if ESP contains a value that is not a multiple of 4\. The only
    practical reason for pushing less than 4 bytes at a time on the stack is to build
    up a double word via two successive word pushes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.2 The Basic pop Instruction
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve data you've pushed onto the stack, you use the `pop` instruction.
    The basic `pop` instruction allows the following forms.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Like the `push` instruction, the `pop` instruction supports only 16-bit and
    32-bit operands; you cannot pop an 8-bit value from the stack. As with the `push`
    instruction, you should avoid popping 16-bit values (unless you do two 16-bit
    pops in a row) because 16-bit pops may leave the ESP register containing a value
    that is not an even multiple of 4\. One major difference between `push` and `pop`
    is that you cannot pop a constant value (which makes sense, because the operand
    for `push` is a source operand, while the operand for `pop` is a destination operand).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, here''s what the `pop` instruction does:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, the `pop` operation is the converse of the `push` operation.
    Note that the `pop` instruction copies the data from memory location [ESP] before
    adjusting the value in ESP. See [Figure 3-11](ch03s08.html#memory_before_a_pop_open_parenthesis_eax
    "Figure 3-11. Memory before a pop( eax ); operation") and [Figure 3-12](ch03s08.html#memory_after_the_pop_open_parenthesis_ea
    "Figure 3-12. Memory after the pop( eax ); instruction") for details on this operation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory before a pop( eax ); operation](tagoreillycom20100401nostarchimages577957.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11. Memory before a `pop( eax );` operation
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory after the pop( eax ); instruction](tagoreillycom20100401nostarchimages577959.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12. Memory after the `pop( eax );` instruction
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Note that the value popped from the stack is still present in memory. Popping
    a value does not erase the value in memory; it just adjusts the stack pointer
    so that it points at the next value above the popped value. However, you should
    never attempt to access a value you've popped off the stack. The next time something
    is pushed onto the stack, the popped value will be obliterated. Because your code
    isn't the only thing that uses the stack (for example, the operating system uses
    the stack as do subroutines), you cannot rely on data remaining in stack memory
    once you've popped it off the stack.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 3.8.3 Preserving Registers with the push and pop Instructions
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most common use of the `push` and `pop` instructions is to save
    register values during intermediate calculations. A problem with the 80x86 architecture
    is that it provides very few general-purpose registers. Because registers are
    the best place to hold temporary values, and registers are also needed for the
    various addressing modes, it is very easy to run out of registers when writing
    code that performs complex calculations. The `push` and `pop` instructions can
    come to your rescue when this happens.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program outline:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `push` and `pop` instructions are perfect for this situation. By inserting
    a `push` instruction before the middle sequence and a `pop` instruction after
    the middle sequence above, you can preserve the value in EAX across those calculations:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `push` instruction above copies the data computed in the first sequence
    of instructions onto the stack. Now the middle sequence of instructions can use
    EAX for any purpose it chooses. After the middle sequence of instructions finishes,
    the `pop` instruction restores the value in EAX so the last sequence of instructions
    can use the original value in EAX.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 The Stack Is a LIFO Data Structure
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can push more than one value onto the stack without first popping previous
    values off the stack. However, the stack is a *last-in, first-out (LIFO)* data
    structure, so you must be careful how you push and pop multiple values. For example,
    suppose you want to preserve EAX and EBX across some block of instructions; the
    following code demonstrates the obvious way to handle this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Unfortunately, this code will not work properly! [Figure 3-13](ch03s09.html#stack_after_pushing_eax
    "Figure 3-13. Stack after pushing EAX") through [Figure 3-16](ch03s09.html#stack_after_popping_ebx
    "Figure 3-16. Stack after popping EBX") show the problem. Because this code pushes
    EAX first and EBX second, the stack pointer is left pointing at EBX's value on
    the stack. When the `pop( eax );` instruction comes along, it removes the value
    that was originally in EBX from the stack and places it in EAX! Likewise, the
    `pop( ebx );` instruction pops the value that was originally in EAX into the EBX
    register. The end result is that this code manages to swap the values in the registers
    by popping them in the same order that it pushes them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after pushing EAX](tagoreillycom20100401nostarchimages577961.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13. Stack after pushing EAX
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after pushing EBX](tagoreillycom20100401nostarchimages577963.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14. Stack after pushing EBX
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after popping EAX](tagoreillycom20100401nostarchimages577965.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15. Stack after popping EAX
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack after popping EBX](tagoreillycom20100401nostarchimages577967.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Figure 3-16. Stack after popping EBX
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'To rectify this problem, you must note that the stack is a last-in, first-out
    data structure, so the first thing you must pop is the last thing you push onto
    the stack. Therefore, you must always observe the following maxim:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Always pop values in the reverse order that you push them**.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction to the previous code is:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another important maxim to remember is:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Always pop exactly the same number of bytes that you push**.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: This generally means that the number of pushes and pops must exactly agree.
    If you have too few pops, you will leave data on the stack, which may confuse
    the running program. If you have too many pops, you will accidentally remove previously
    pushed data, often with disastrous results.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '| A corollary to the maxim above is, "Be careful when pushing and popping data
    within a loop." Often it is quite easy to put the pushes in a loop and leave the
    pops outside the loop (or vice versa), creating an inconsistent stack. Remember,
    it is the execution of the `push` and `pop` instructions that matters, not the
    number of `push` and `pop` instructions that appear in your program. At runtime,
    the number (and order) of the `push` instructions the program executes must match
    the number (and reverse order) of the `pop` instructions. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: 3.9.1 Other push and pop Instructions
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 provides several additional `push` and `pop` instructions in addition
    to the basic `push`/`pop` instructions. These instructions include the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '| `pusha` | `popa` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| `pushad` | `popad` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| `pushf` | `popf` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `pushfd` | `popfd` |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: 'The `pusha` instruction pushes all the general-purpose 16-bit registers onto
    the stack. This instruction exists primarily for older 16-bit operating systems
    like MS-DOS. In general, you will have very little need for this instruction.
    The `pusha` instruction pushes the registers onto the stack in the following order:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `pushad` instruction pushes all the 32-bit (double-word) registers onto
    the stack. It pushes the registers onto the stack in the following order:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because the `pusha` and `pushad` instructions inherently modify the SP/ESP register,
    you may wonder why Intel bothered to push this register at all. It was probably
    easier in the hardware to go ahead and push SP/ESP rather than make a special
    case out of it. In any case, these instructions do push SP or ESP, so don't worry
    about it too much—there is nothing you can do about it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The `popa` and `popad` instructions provide the corresponding "pop all" operation
    to the `pusha` and `pushad` instructions. This will pop the registers pushed by
    `pusha` or `pushad` in the appropriate order (that is, `popa` and `popad` will
    properly restore the register values by popping them in the reverse order that
    `pusha` or `pushad` pushed them).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Although the `pusha`/`popa` and `pushad`/`popad` sequences are short and convenient,
    they are actually slower than the corresponding sequence of `push`/`pop` instructions,
    this is especially true when you consider that you rarely need to push a majority,
    much less all, of the registers.^([[44](#ftn.CHP-3-FN-11)]) So if you're looking
    for maximum speed, you should carefully consider whether to use the `pusha`(`d`)/`popa`(`d`)
    instructions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The `pushf`, `pushfd`, `popf`, and `popfd` instructions push and pop the EFLAGS
    register. These instructions allow you to preserve condition code and other flag
    settings across the execution of some sequence of instructions. Unfortunately,
    unless you go to a lot of trouble, it is difficult to preserve individual flags.
    When using the `pushf`(`d`) and `popf`(`d`) instructions, it's an all-or-nothing
    proposition—you preserve all the flags when you push them; you restore all the
    flags when you pop them.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Like the `pushad` and `popad` instructions, you should really use the `pushfd`
    and `popfd` instructions to push the full 32-bit version of the EFLAGS register.
    Although the extra 16 bits you push and pop are essentially ignored when writing
    applications, you still want to keep the stack aligned by pushing and popping
    only double words.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 Removing Data from the Stack Without Popping It
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once in a while you may discover that you've pushed data onto the stack that
    you no longer need. Although you could pop the data into an unused register or
    memory location, there is an easier way to remove unwanted data from the stack—simply
    adjust the value in the ESP register to skip over the unwanted data on the stack.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following dilemma:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Within the `then` section of the `if` statement, this code wants to remove the
    old values of EAX and EBX without otherwise affecting any registers or memory
    locations. How can we do this?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ESP register contains the memory address of the item on the top
    of the stack, we can remove the item from the top of stack by adding the size
    of that item to the ESP register. In the preceding example, we wanted to remove
    two double-word items from the top of stack. We can easily accomplish this by
    adding 8 to the stack pointer (see [Figure 3-17](ch03s09.html#removing_data_from_the_stack_comma_befor
    "Figure 3-17. Removing data from the stack, before add( 8, esp );") and [Figure 3-18](ch03s09.html#removing_data_from_the_stack_comma_after
    "Figure 3-18. Removing data from the stack, after add( 8, esp );") for the details):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![Removing data from the stack, before add( 8, esp );](tagoreillycom20100401nostarchimages577969.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Figure 3-17. Removing data from the stack, before `add( 8, esp );`
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing data from the stack, after add( 8, esp );](tagoreillycom20100401nostarchimages577971.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 3-18. Removing data from the stack, after `add( 8, esp );`
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Effectively, this code pops the data off the stack without moving it anywhere.
    Also note that this code is faster than two dummy `pop` instructions because it
    can remove any number of bytes from the stack with a single `add` instruction.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to keep the stack aligned on a double-word boundary. Therefore, you
    should always add a constant that is a multiple of 4 to ESP when removing data
    from the stack.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#CHP-3-FN-11)]) For example, it is extremely rare for you to need to
    push and pop the ESP register with the `pushad`/`popad` instruction sequence.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Accessing Data You've Pushed onto the Stack Without Popping It
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while you will push data onto the stack and you will want to get a
    copy of that data's value, or perhaps you will want to change that data's value
    without actually popping the data off the stack (that is, you wish to pop the
    data off the stack at a later time). The 80x86 `[reg32 + offset]` addressing mode
    provides the mechanism for this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the stack after the execution of the following two instructions (see
    [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX")):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![Stack after pushing EAX and EBX](tagoreillycom20100401nostarchimages577973.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Figure 3-19. Stack after pushing EAX and EBX
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to access the original EBX value without removing it from the
    stack, you could cheat and pop the value and then immediately push it again. Suppose,
    however, that you wish to access EAX's old value or some other value even farther
    up the stack. Popping all the intermediate values and then pushing them back onto
    the stack is problematic at best, impossible at worst. However, as you will notice
    from [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX"), each of the values pushed on the stack is at some
    offset from the ESP register in memory. Therefore, we can use the `[ESP + offset]`
    addressing mode to gain direct access to the value we are interested in. In the
    example above, you can reload EAX with its original value by using the single
    instruction
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This code copies the 4 bytes starting at memory address ESP+4 into the EAX register.
    This value just happens to be the previous value of EAX that was pushed onto the
    stack. You can use this same technique to access other data values you've pushed
    onto the stack.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget that the offsets of values from ESP into the stack change every
    time you push or pop data. Abusing this feature can create code that is hard to
    modify; if you use this feature throughout your code, it will make it difficult
    to push and pop other data items between the point where you first push data onto
    the stack and the point where you decide to access that data again using the *`[ESP
    + offset]`* memory addressing mode.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous section pointed out how to remove data from the stack by adding
    a constant to the ESP register. That code example could probably be written more
    safely as this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this code sequence, the calculated result was stored over the top of the
    values saved on the stack. Later on, when the program pops the values, it loads
    these calculated values into EAX and EBX.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 Dynamic Memory Allocation and the Heap Segment
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although static and automatic variables are all that simple programs may need,
    more sophisticated programs need the ability to allocate and deallocate storage
    dynamically (at runtime) under program control. In the C language, you would use
    the `malloc` and `free` functions for this purpose. C++ provides the `new` and
    `delete` operators. Pascal uses `new` and `dispose`. Other languages provide comparable
    facilities. These memory-allocation routines have a couple of things in common:
    They let the programmer request how many bytes of storage to allocate, they return
    a *pointer* to the newly allocated storage, and they provide a facility for returning
    the storage to the system so the system can reuse it in a future allocation call.
    As you''ve probably guessed, HLA also provides a set of routines in the HLA Standard
    Library that handle memory allocation and deallocation.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA Standard Library `mem.alloc` and `mem.free` routines handle the memory
    allocation and deallocation chores (respectively). The `mem.alloc` routine uses
    the following calling sequence:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The single parameter is a `dword` value specifying the number of bytes of storage
    you need. This procedure allocates storage in the `heap` segment in memory. The
    HLA `mem.alloc` function locates an unused block of memory of the size you specify
    in the `heap` segment and marks the block as "in use" so that future calls to
    `mem.alloc` will not allocate this same storage. After marking the block as "in
    use," the `mem.alloc` routine returns a pointer to the first byte of this storage
    in the EAX register.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'For many objects, you will know the number of bytes that you need in order
    to represent that object in memory. For example, if you wish to allocate storage
    for an `uns32` variable, you could use the following call to the `mem.alloc` routine:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although you can specify a literal constant as this example suggests, it''s
    generally a poor idea to do so when allocating storage for a specific data type.
    Instead, use the HLA built-in *compile-time function*^([[45](#ftn.CHP-3-FN-12)])
    `@size` to compute the size of some data type. The `@size` function uses the following
    syntax:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `@size` function returns an unsigned integer constant that is the size
    of its parameter in bytes. So you should rewrite the previous call to `mem.alloc`
    as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This call will properly allocate a sufficient amount of storage for the specified
    object, regardless of its type. While it is unlikely that the number of bytes
    required by an `uns32` object will ever change, this is not necessarily true for
    other data types; so you should always use `@size` rather than a literal constant
    in these calls.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Upon return from the `mem.alloc` routine, the EAX register contains the address
    of the storage you have requested (see [Figure 3-20](ch03s11.html#a_call_to_mem.alloc_returns_a_pointer_in
    "Figure 3-20. A call to mem.alloc returns a pointer in the EAX register.")).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![A call to mem.alloc returns a pointer in the EAX register.](tagoreillycom20100401nostarchimages577975.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: Figure 3-20. A call to `mem.alloc` returns a pointer in the EAX register.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the storage `mem.alloc` allocates, you must use a register-indirect
    addressing mode. The following code sequence demonstrates how to assign the value
    1234 to the `uns32` variable `mem.alloc` creates:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note the use of the `type` coercion operator. This is necessary in this example
    because anonymous variables don't have a type associated with them and the constant
    1234 could be a `word` or `dword` value. The `type` coercion operator eliminates
    the ambiguity.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The `mem.alloc` routine may not always succeed. If there isn't a single contiguous
    block of free memory in the heap segment that is large enough to satisfy the request,
    then the `mem.alloc` routine will raise an `ex.MemoryAllocationFailure` exception.
    If you do not provide a `try..exception..endtry` handler to deal with this situation,
    a memory allocation failure will cause your program to stop. Because most programs
    do not allocate massive amounts of dynamic storage using `mem.alloc`, this exception
    rarely occurs. However, you should never assume that the memory allocation will
    always occur without error.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have finished using a value that `mem.alloc` allocates on the heap,
    you can release the storage (that is, mark it as "no longer in use") by calling
    the `mem.free` procedure. The `mem.free` routine requires a single parameter that
    must be an address returned by a previous call to `mem.alloc` (that you have not
    already freed). The following code fragment demonstrates the nature of the `mem.alloc`/`mem.free`
    pairing:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This code demonstrates a very important point: In order to properly free the
    storage that `mem.alloc` allocates, you must preserve the value that `mem.alloc`
    returns. There are several ways to do this if you need to use EAX for some other
    purpose; you could save the pointer value on the stack using `push` and `pop`
    instructions or you could save EAX''s value in a variable until you need to free
    it.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Storage you release is available for reuse by future calls to the `mem.alloc`
    routine. The ability to allocate storage when you need it and then free the storage
    for other use when you have finished with it improves the memory efficiency of
    your program. By deallocating storage once you have finished with it, your program
    can reuse that storage for other purposes, allowing your program to operate with
    less memory than it would if you statically allocated storage for the individual
    objects.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Several problems can occur when you use pointers. You should be aware of a
    couple of common errors that beginning programmers make when using dynamic storage
    allocation routines like `mem.alloc` and `mem.free`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Mistake 1: Continuing to refer to storage after you free it. Once you return
    storage to the system via the call to `mem.free`, you should no longer access
    that storage. Doing so may cause a protection fault or, worse yet, corrupt other
    data in your program without indicating an error.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mistake 2: Calling `mem.free` twice to release a single block of storage. Doing
    so may accidentally free some other storage that you did not intend to release
    or, worse yet, it may corrupt the system memory management tables.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    some additional problems you will typically encounter when dealing with dynamically
    allocated storage.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples thus far in this section have all allocated storage for a single
    unsigned 32-bit object. Obviously you can allocate storage for any data type using
    a call to `mem.alloc` by simply specifying the size of that object as `mem.alloc`''s
    parameter. It is also possible to allocate storage for a sequence of contiguous
    objects in memory when calling `mem.alloc`. For example, the following code will
    allocate storage for a sequence of eight characters:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note the use of the constant expression to compute the number of bytes required
    by an eight-character sequence. Because `@size(char)` always returns a constant
    value (1 in this case), the compiler can compute the value of the expression `@size(char)
    * 8` without generating any extra machine instructions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Calls to `mem.alloc` always allocate multiple bytes of storage in contiguous
    memory locations. Hence the former call to `mem.alloc` produces the sequence appearing
    in [Figure 3-21](ch03s11.html#allocating_a_sequence_of_eight_character "Figure 3-21. Allocating
    a sequence of eight character objects using mem.alloc").
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Allocating a sequence of eight character objects using mem.alloc](tagoreillycom20100401nostarchimages577977.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21. Allocating a sequence of eight character objects using `mem.alloc`
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these extra character values you use an offset from the base address
    (contained in EAX upon return from `mem.alloc`). For example, `mov( ch, [eax +
    2] );` stores the character found in CH into the third byte that `mem.alloc` allocates.
    You can also use an addressing mode like `[eax + ebx]` to step through each of
    the allocated objects under program control. For example, the following code will
    set all the characters in a block of 128 bytes to the NUL character (#0):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    composite data structures (including arrays) and describes additional ways to
    deal with blocks of memory.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You should note that a call to `mem.alloc` actually allocates slightly more
    memory than you request. For one thing, memory allocation requests are generally
    of some minimum size (often a power of 2 between 4 and 16, though this is OS dependent).
    Furthermore, `mem.alloc` requests also require a few bytes of overhead for each
    request (generally around 16 to 32 bytes) to keep track of allocated and free
    blocks. Therefore, it is not efficient to allocate a large number of small objects
    with individual calls to `mem.alloc`. The overhead for each allocation may be
    greater than the storage you actually use. Typically, you'll use `mem.alloc` to
    allocate storage for arrays or large records (structures) rather than small objects.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: ^([[45](#CHP-3-FN-12)]) A compile-time function is one that HLA evaluates during
    the compilation of your program rather than at runtime.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 The inc and dec Instructions
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the example in the previous section indicates—indeed, as several examples
    up to this point have indicated—adding or subtracting 1 from a register or memory
    location is a very common operation. In fact, these operations are so common that
    Intel''s engineers included a pair of instructions to perform these specific operations:
    the `inc` (increment) and `dec` (decrement) instructions.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inc` and `dec` instructions use the following syntax:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The single operand can be any legal 8-bit, 16-bit, or 32-bit register or memory
    operand. The `inc` instruction will add 1 to the specified operand, and the `dec`
    instruction will subtract 1 from the specified operand.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'These two instructions are slightly shorter than the corresponding `add` or
    `sub` instructions (that is, their encoding uses fewer bytes). There is also one
    slight difference between these two instructions and the corresponding `add` or
    `sub` instructions: They do not affect the carry flag.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the `inc` instruction, consider the example from the previous
    section, recoded to use `inc` rather than `add`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 3.13 Obtaining the Address of a Memory Object
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[3.1.2.2 The Register-Indirect Addressing Modes](ch03.html#the_register-indirect_addressing_modes
    "3.1.2.2 The Register-Indirect Addressing Modes") discusses how to use the address-of
    operator, `&`, to take the address of a static variable.^([[46](#ftn.CHP-3-FN-13)])
    Unfortunately, you cannot use the address-of operator to take the address of an
    automatic variable (one you declare in the `var` section), you cannot use it to
    compute the address of an anonymous variable, and you cannot use it to take the
    address of a memory reference that uses an indexed or scaled-indexed addressing
    mode (even if a static variable is part of the address expression). You may use
    the address-of operator only to take the address of a simple static object. Often,
    you will need to take the address of other memory objects as well; fortunately,
    the 80x86 provides the *load effective address* instruction, `lea`, to give you
    this capability.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lea` instruction uses the following syntax:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first operand must be a 32-bit register; the second operand can be any legal
    memory reference using any valid memory addressing mode. This instruction will
    load the address of the specified memory location into the register. This instruction
    does not access or modify the value of the memory operand in any way.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load the effective address of a memory location into a 32-bit general-purpose
    register, you can use the register-indirect, indexed, or scaled-indexed addressing
    mode to access the data at the specified memory address. Consider the following
    code fragment:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This code steps through each of the 8 bytes following the `b` label in the `static`
    section and prints their values. Note the use of the `[ebx+ecx]` addressing mode.
    The EBX register holds the base address of the list (that is, the address of the
    first item in the list), and ECX contains the byte index into the list.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#CHP-3-FN-13)]) A static variable is one that you declare in the `static`,
    `readonly`, or `storage` section of your program.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 3.14 For More Information
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An older, 16-bit version of *The Art of Assembly Language Programming* can be
    found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/). In that text
    you will find information about the 80x86's 16-bit addressing modes and segmentation.
    More information about the HLA Standard Library `mem.alloc` and `mem.free` functions
    can be found in the HLA Standard Library reference manual, also on Webster at
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or at [http://artofasm.com/](http://artofasm.com/).
    Of course, the Intel x86 documentation (found at [http://www.intel.com/](http://www.intel.com/))
    provides complete information on 80x86 address modes and machine instruction encoding.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
