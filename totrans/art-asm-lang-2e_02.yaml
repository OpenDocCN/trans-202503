- en: Chapter 3. MEMORY ACCESS AND ORGANIZATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 内存访问与组织
- en: '![MEMORY ACCESS AND ORGANIZATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![内存访问与组织](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: '[Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") and [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") show you how to declare and access simple variables
    in an assembly language program. This chapter fully explains 80x86 memory access.
    You will learn how to efficiently organize your variable declarations to speed
    up access to their data. This chapter will teach you about the 80x86 stack and
    how to manipulate data on the stack. Finally, this chapter will teach you about
    dynamic memory allocation and the *heap*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章：你好，汇编语言世界")和[第2章](ch02.html "第2章：数据表示")展示了如何在汇编语言程序中声明和访问简单变量。本章将全面解释
    80x86 内存访问。你将学习如何高效地组织变量声明，以加速对数据的访问。本章将教授你 80x86 栈及如何在栈上操作数据。最后，本章将讲解动态内存分配和
    *堆*。'
- en: 'This chapter discusses several important concepts, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了几个重要的概念，包括：
- en: 80x86 memory addressing modes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80x86 内存寻址模式
- en: Indexed and scaled-indexed addressing modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引寻址和缩放索引寻址模式
- en: Memory organization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存组织
- en: Memory allocation by program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序分配内存
- en: Data type coercion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型强制转换
- en: The 80x86 stack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80x86 栈
- en: Dynamic memory allocation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: This chapter will teach to you make efficient use of your computer's memory
    resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何高效利用计算机的内存资源。
- en: 3.1 The 80x86 Addressing Modes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 80x86 寻址模式
- en: The 80x86 processors let you access memory in many different ways. Until now,
    you've seen only a single way to access a variable, the so-called *displacement-only*
    addressing mode. In this section you'll see some additional ways your programs
    can access memory using 80x86 *memory addressing modes*. The 80x86 memory addressing
    modes provide flexible access to memory, allowing you to easily access variables,
    arrays, records, pointers, and other complex data types. Mastery of the 80x86
    addressing modes is the first step toward mastering 80x86 assembly language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 处理器允许你以多种不同方式访问内存。到目前为止，你只见过一种访问变量的方式，即所谓的 *仅位移* 寻址模式。在本节中，你将看到一些额外的方式，如何通过
    80x86 *内存寻址模式* 来访问内存。80x86 内存寻址模式提供了灵活的内存访问方式，使你能够轻松访问变量、数组、记录、指针和其他复杂数据类型。掌握
    80x86 寻址模式是掌握 80x86 汇编语言的第一步。
- en: When Intel designed the original 8086 processor, it provided the processor with
    a flexible, though limited, set of memory addressing modes. Intel added several
    new addressing modes when it introduced the 80386 microprocessor. However, in
    32-bit environments like Windows, Mac OS X, FreeBSD, and Linux, these earlier
    addressing modes are not very useful; indeed, HLA doesn't even support the use
    of these older, 16-bit-only addressing modes. Fortunately, anything you can do
    with the older addressing modes can be done with the new addressing modes. Therefore,
    you won't need to bother learning the old 16-bit addressing modes when writing
    code for today's high-performance operating systems. Do keep in mind, however,
    that if you intend to work under MS-DOS or some other 16-bit operating system,
    you will need to study up on those old addressing modes (see the 16-bit edition
    of this book at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) for details).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当英特尔设计最初的 8086 处理器时，它为处理器提供了灵活但有限的内存寻址模式。英特尔在推出 80386 微处理器时添加了几种新的寻址模式。然而，在
    Windows、Mac OS X、FreeBSD 和 Linux 等 32 位环境中，这些早期的寻址模式并不是很有用；实际上，HLA 甚至不支持使用这些旧的、仅限
    16 位的寻址模式。幸运的是，任何可以通过旧的寻址模式完成的事情，都可以通过新的寻址模式来实现。因此，在为当今高性能操作系统编写代码时，你不需要浪费时间学习旧的
    16 位寻址模式。但请记住，如果你打算在 MS-DOS 或其他 16 位操作系统下工作，你仍然需要研究这些旧的寻址模式（有关详细信息，请参阅本书的 16 位版本：[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)）。
- en: 3.1.1 80x86 Register Addressing Modes
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.1 80x86 寄存器寻址模式
- en: 'Most 80x86 instructions can operate on the 80x86''s general-purpose register
    set. By specifying the name of the register as an operand to the instruction,
    you can access the contents of that register. Consider the 80x86 `mov` (move)
    instruction:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 80x86 指令可以在 80x86 的通用寄存器集中操作。通过指定寄存器的名称作为操作数，你可以访问该寄存器的内容。考虑 80x86 的 `mov`（移动）指令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This instruction copies the data from the *`source`* operand to the *`destination`*
    operand. The 8-bit, 16-bit, and 32-bit registers are certainly valid operands
    for this instruction. The only restriction is that both operands must be the same
    size. Now let''s look at some actual 80x86 `mov` instructions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将数据从*`源`*操作数复制到*`目标`*操作数。8位、16位和32位寄存器当然是该指令有效的操作数。唯一的限制是两个操作数必须具有相同的大小。现在让我们来看一些实际的80x86
    `mov`指令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The registers are the best place to keep variables. Instructions using the registers
    are shorter and faster than those that access memory. Of course, most computations
    require at least one register operand, so the register addressing mode is very
    popular in 80x86 assembly code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是存储变量的最佳位置。使用寄存器的指令比访问内存的指令更简短、更快速。当然，大多数计算至少需要一个寄存器操作数，因此寄存器寻址模式在80x86汇编代码中非常流行。
- en: 3.1.2 80x86 32-Bit Memory Addressing Modes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.2 80x86 32位内存寻址模式
- en: The 80x86 provides hundreds of different ways to access memory. This may seem
    like quite a lot at first, but fortunately most of the addressing modes are simple
    variants of one another, so they're very easy to learn. And learn them you should!
    The key to good assembly language programming is the proper use of memory addressing
    modes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86提供了数百种不同的内存访问方式。刚开始看起来可能很多，但幸运的是，大多数寻址模式只是彼此简单的变体，因此它们非常容易学习。而且你确实应该学会它们！良好的汇编语言编程的关键是正确使用内存寻址模式。
- en: The addressing modes provided by the 80x86 family include displacement-only,
    base, displacement plus base, base plus indexed, and displacement plus base plus
    indexed. Variations on these five forms provide all the different addressing modes
    on the 80x86\. See, from hundreds down to five. It's not so bad after all!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86系列提供的寻址模式包括仅位移、基址、位移加基址、基址加索引和位移加基址加索引。这五种形式的变体提供了80x86上的所有不同寻址模式。看，从数百种变成了五种。其实并不那么复杂！
- en: 3.1.2.1 The Displacement-Only Addressing Mode
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.1 仅位移寻址模式
- en: The most common addressing mode, and the one that's easiest to understand, is
    the *displacement-only* (or *direct*) addressing mode. The displacement-only addressing
    mode consists of a 32-bit constant that specifies the address of the target location.
    Assuming that variable `j` is an `int8` variable appearing at address $8088, the
    instruction `mov( j, al );` loads the AL register with a copy of the byte at memory
    location $8088\. Likewise, if `int8` variable `k` is at address $1234 in memory,
    then the instruction `mov( dl, k );` stores the value in the DL register to memory
    location $1234 (see [Figure 3-1](ch03.html#displacement-only_open_parenthesis_direc
    "Figure 3-1. Displacement-only (direct) addressing mode")).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的寻址模式，也是最容易理解的，是*仅位移*（或*直接*）寻址模式。仅位移寻址模式由一个32位常量组成，指定目标位置的地址。假设变量`j`是一个出现在地址$8088的`int8`变量，指令`mov(
    j, al );`将AL寄存器加载为位于内存地址$8088的字节的副本。同样，如果`int8`变量`k`位于内存地址$1234，则指令`mov( dl, k
    );`将DL寄存器中的值存储到内存地址$1234（参见[图3-1](ch03.html#displacement-only_open_parenthesis_direc
    "图3-1. 仅位移（直接）寻址模式")）。
- en: '![Displacement-only (direct) addressing mode](tagoreillycom20100401nostarchimages577937.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![仅位移（直接）寻址模式](tagoreillycom20100401nostarchimages577937.png)'
- en: Figure 3-1. Displacement-only (direct) addressing mode
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1。仅位移（直接）寻址模式
- en: The displacement-only addressing mode is perfect for accessing simple scalar
    variables. This is named the displacement-only addressing mode because a 32-bit
    constant (displacement) follows the `mov` opcode in memory. On the 80x86 processors,
    this displacement is an offset from the beginning of memory (that is, address
    0). The examples in this chapter often access bytes in memory. Don't forget, however,
    that you can also access words and double words on the 80x86 processors by specifying
    the address of their first byte (see [Figure 3-2](ch03.html#accessing_a_word_or_dword_using_the_disp
    "Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode")).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位移寻址模式非常适合访问简单的标量变量。之所以称其为仅位移寻址模式，是因为一个32位常量（位移）跟随在`mov`操作码后面存储在内存中。在80x86处理器中，这个位移是从内存起始地址（即地址0）开始的偏移量。本章中的示例通常访问内存中的字节。然而，别忘了，你也可以通过指定其第一个字节的地址来访问80x86处理器上的字和双字（参见[图3-2](ch03.html#accessing_a_word_or_dword_using_the_disp
    "图3-2. 使用仅位移寻址模式访问字或双字")）。
- en: '![Accessing a word or dword using the displacement-only addressing mode](tagoreillycom20100401nostarchimages577939.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用仅位移寻址模式访问字或双字](tagoreillycom20100401nostarchimages577939.png)'
- en: Figure 3-2. Accessing a word or dword using the displacement-only addressing
    mode
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2. 使用仅位移寻址模式访问字或双字
- en: 3.1.2.2 The Register-Indirect Addressing Modes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.2 寄存器间接寻址模式
- en: The 80x86 CPUs let you access memory indirectly through a register using the
    *register-indirect* addressing modes. The term *indirect* means that the operand
    is not the actual address, but rather the operand's value specifies the memory
    address to use. In the case of the register-indirect addressing modes, the value
    held in the register is the address of the memory location to access. For example,
    the instruction `mov( eax, [ebx] );` tells the CPU to store EAX's value at the
    location whose address is in EBX (the square brackets around EBX tell HLA to use
    the register-indirect addressing mode).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 让你通过寄存器间接寻址模式间接访问内存。术语*间接*意味着操作数不是实际的地址，而是操作数的值指定要使用的内存地址。在寄存器间接寻址模式的情况下，寄存器中保存的值是要访问的内存位置的地址。例如，指令`mov(
    eax, [ebx] );`告诉 CPU 将 EAX 的值存储到地址在 EBX 中的位置（EBX 周围的方括号告诉 HLA 使用寄存器间接寻址模式）。
- en: 'There are eight forms of this addressing mode on the 80x86\. The following
    instructions are examples of these eight forms:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 80x86 上有八种这种寻址模式。以下指令是这八种形式的示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These eight addressing modes reference the memory location at the offset found
    in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP,
    respectively).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这八种寻址模式通过方括号中的寄存器（EAX、EBX、ECX、EDX、EDI、ESI、EBP 或 ESP）找到的偏移量引用内存位置。
- en: 'Note that the register-indirect addressing modes require a 32-bit register.
    You cannot specify a 16-bit or 8-bit register when using an indirect addressing
    mode.^([[34](#ftn.CHP-3-FN-1)]) Technically, you could load a 32-bit register
    with an arbitrary numeric value and access that location indirectly using the
    register-indirect addressing mode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，寄存器间接寻址模式要求使用 32 位寄存器。使用间接寻址模式时，不能指定 16 位或 8 位寄存器。^([[34](#ftn.CHP-3-FN-1)])
    从技术上讲，你可以将一个 32 位寄存器加载任意数值，并使用寄存器间接寻址模式间接访问该位置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unfortunately (or fortunately, depending on how you look at it), this will probably
    cause the operating system to generate a protection fault because it's not always
    legal to access arbitrary memory locations. As it turns out, there are better
    ways to load the address of some object into a register; you'll see how to do
    this shortly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（或者幸运的是，这取决于你如何看待它），这可能会导致操作系统生成保护错误，因为并非总是合法访问任意内存位置。事实证明，有更好的方法将某些对象的地址加载到寄存器中；你稍后会看到如何操作。
- en: The register-indirect addressing modes have many uses. You can use them to access
    data referenced by a pointer, you can use them to step through array data, and,
    in general, you can use them whenever you need to modify the address of a variable
    while your program is running.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式有许多用途。你可以用它们来访问由指针引用的数据，也可以用它们来遍历数组数据，通常，你可以在程序运行时需要修改变量地址时使用它们。
- en: The register-indirect addressing mode provides an example of an *anonymous*
    variable. When using a register-indirect addressing mode, you refer to the value
    of a variable by its numeric memory address (e.g., the value you load into a register)
    rather than by the name of the variable—hence the phrase *anonymous variable*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器间接寻址模式提供了一个*匿名*变量的例子。当使用寄存器间接寻址模式时，你是通过变量的数值内存地址（例如，加载到寄存器中的值）而不是变量的名称来引用变量的值——因此有了*匿名变量*这一说法。
- en: 'HLA provides a simple operator that you can use to take the address of a `static`
    variable and put this address into a 32-bit register. This is the `&` (address-of)
    operator (note that this is the same symbol that C/C++ uses for the address-of
    operator). The following example loads the address of variable `j` into EBX and
    then stores EAX''s current value into `j` using a register-indirect addressing
    mode:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了一个简单的操作符，你可以用它获取一个`static`变量的地址，并将该地址放入一个 32 位寄存器中。这就是`&`（地址操作符）操作符（注意，这与
    C/C++ 中的地址操作符符号相同）。以下示例将变量 `j` 的地址加载到 EBX 中，然后使用寄存器间接寻址模式将 EAX 的当前值存储到 `j` 中：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Of course, it would have been easier to store EAX's value directly into `j`
    rather than using two instructions to do this indirectly. However, you can easily
    imagine a code sequence where the program loads one of several different addresses
    into EBX prior to the execution of the `mov( eax, [ebx]);` statement, thus storing
    EAX into one of several different locations depending on the execution path of
    the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直接将EAX的值存储到`j`中比使用两条指令间接完成这项操作要简单。然而，你可以很容易地想象出一个代码序列，在该序列中，程序在执行`mov( eax,
    [ebx]);`语句之前，会将多个不同的地址之一加载到EBX中，从而根据程序的执行路径将EAX存储到多个不同的位置。
- en: Warning
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The `&` (address-of ) operator is not a general address-of operator like the
    `&` operator in C/C++. You may apply this operator only to static variables.^([[35](#ftn.CHP-3-FN-2)])
    You cannot apply it to generic address expressions or other types of variables.
    In [3.13 Obtaining the Address of a Memory Object](ch03s13.html "3.13 Obtaining
    the Address of a Memory Object"), you will learn about the *load effective address*
    instruction that provides a general solution for obtaining the address of some
    variable in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`（取地址）操作符不像C/C++中的`&`操作符那样是通用的取地址操作符。你只能将此操作符应用于静态变量。^([[35](#ftn.CHP-3-FN-2)])
    你不能将它应用于通用的地址表达式或其他类型的变量。在[3.13 获取内存对象的地址](ch03s13.html "3.13 获取内存对象的地址")中，你将了解*加载有效地址*指令，它为获取内存中某个变量的地址提供了通用的解决方案。'
- en: 3.1.2.3 Indexed Addressing Modes
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.3 索引寻址模式
- en: 'The indexed addressing modes use the following syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式使用以下语法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*`VarName`* is the name of some variable in your program.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`VarName`* 是你程序中某个变量的名称。'
- en: The indexed addressing modes compute an effective address^([[36](#ftn.CHP-3-FN-3)])
    by adding the address of the variable to the value of the 32-bit register appearing
    inside the square brackets. Their sum is the actual memory address the instruction
    accesses. So if *`VarName`* is at address $1100 in memory and EBX contains 8,
    then `mov(`*`VarName`*`[ ebx ], al);` loads the byte at address $1108 into the
    AL register (see [Figure 3-3](ch03.html#indexed_addressing_mode "Figure 3-3. Indexed
    addressing mode")).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式通过将变量的地址加到出现在方括号内的32位寄存器的值上来计算有效地址^([[36](#ftn.CHP-3-FN-3)])。它们的和即为指令访问的实际内存地址。因此，如果*`VarName`*位于内存地址$1100，而EBX中包含8，那么`mov(`*`VarName`*`[
    ebx ], al);`会将地址$1108处的字节加载到AL寄存器中（见[图3-3](ch03.html#indexed_addressing_mode "图3-3.
    索引寻址模式")）。
- en: '![Indexed addressing mode](tagoreillycom20100401nostarchimages577941.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![索引寻址模式](tagoreillycom20100401nostarchimages577941.png)'
- en: Figure 3-3. Indexed addressing mode
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3. 索引寻址模式
- en: The indexed addressing modes are really handy for accessing elements of arrays.
    You will see how to use these addressing modes for that purpose in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式对于访问数组元素非常方便。你将在[第4章](ch04.html "第4章. 常量、变量和数据类型")中看到如何使用这些寻址模式来完成这一任务。
- en: 3.1.2.4 Variations on the Indexed Addressing Mode
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.4 索引寻址模式的变体
- en: There are two important syntactical variations of the indexed addressing mode.
    Both forms generate the same basic machine instructions, but their syntax suggests
    other uses for these variants.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式有两种重要的语法变体。两种形式生成相同的基本机器指令，但它们的语法暗示了这些变体的其他用途。
- en: 'The first variant uses the following syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种变体使用以下语法：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These examples use only the EBX register. However, you can use any of the other
    32-bit general-purpose registers in place of EBX. This form computes its effective
    address by adding the value in EBX to the specified constant or subtracting the
    specified constant from EBX (see [Figure 3-4](ch03.html#indexed_addressing_mode_using_a_regi
    "Figure 3-4. Indexed addressing mode using a register plus a constant") and [Figure 3-5](ch03.html#indexed_addressing_mode_using_a_regi-id1
    "Figure 3-5. Indexed addressing mode using a register minus a constant")).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例只使用了EBX寄存器。然而，你可以使用任何其他32位通用寄存器来代替EBX。这种形式通过将EBX中的值加到指定常量上，或者将指定常量从EBX中减去来计算其有效地址（见[图3-4](ch03.html#indexed_addressing_mode_using_a_regi
    "图3-4. 使用寄存器加常量的索引寻址模式")和[图3-5](ch03.html#indexed_addressing_mode_using_a_regi-id1
    "图3-5. 使用寄存器减常量的索引寻址模式")）。
- en: '![Indexed addressing mode using a register plus a constant](tagoreillycom20100401nostarchimages577943.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用寄存器加常量的索引寻址模式](tagoreillycom20100401nostarchimages577943.png)'
- en: Figure 3-4. Indexed addressing mode using a register plus a constant
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4. 使用寄存器加常量的索引寻址模式
- en: '![Indexed addressing mode using a register minus a constant](tagoreillycom20100401nostarchimages577945.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用寄存器减去常数的索引寻址模式](tagoreillycom20100401nostarchimages577945.png)'
- en: Figure 3-5. Indexed addressing mode using a register minus a constant
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5. 使用寄存器减去常数的索引寻址模式
- en: This particular variant of the addressing mode is useful if a 32-bit register
    contains the base address of a multibyte object and you wish to access a memory
    location some number of bytes before or after that location. One important use
    of this addressing mode is accessing fields of a record (or structure) when you
    have a pointer to the record data. This addressing mode is also invaluable for
    accessing automatic (local) variables in procedures (see [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS") for more details).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻址模式的特定变体在32位寄存器包含多字节对象的基地址时非常有用，且你希望访问该位置之前或之后某个字节的内存位置。这种寻址模式的一个重要用途是在你拥有记录数据的指针时访问记录（或结构）的字段。对于访问过程中的自动（局部）变量，这种寻址模式也非常有价值（详见[第5章](ch05.html
    "第5章 程序与单元")）。
- en: 'The second variant of the indexed addressing mode is actually a combination
    of the previous two forms. The syntax for this version is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式的第二种变体实际上是前两种形式的结合体。这个版本的语法如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, this example uses only the EBX register. You may substitute any
    of the 32-bit general-purpose registers in lieu of EBX in these two examples.
    This particular form is useful when accessing elements of an array of records
    (structures) in an assembly language program (more on that in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES")).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这个示例仅使用了EBX寄存器。在这两个示例中，你可以用任何32位通用寄存器替代EBX。这个特定的形式在汇编语言程序中访问记录（结构）数组元素时非常有用（更多内容见[第4章](ch04.html
    "第4章 常量、变量和数据类型")）。
- en: These instructions compute their effective address by adding or subtracting
    the *`constant`* value from *`VarName`*'s address and then adding the value in
    EBX to this result. Note that HLA, not the CPU, computes the sum or difference
    of *`VarName`*'s address and *`constant`*. The actual machine instructions above
    contain a single constant value that the instructions add to the value in EBX
    at runtime. Because HLA substitutes a constant for *`VarName`*, it can reduce
    an instruction of the form
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通过将*`constant`*值从*`VarName`*的地址中加或减去，然后将EBX中的值加到这个结果上来计算它们的有效地址。请注意，是HLA，而不是CPU，计算*`VarName`*地址与*`constant`*的和或差。上述实际的机器指令包含一个常数值，在运行时将这个常数值加到EBX中的值上。因为HLA将常数替换为*`VarName`*，它可以将以下形式的指令简化为
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: to an instruction of the form
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变成如下形式的指令
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because of the way these addressing modes work, this is semantically equivalent
    to
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些寻址模式的工作方式，它在语义上等同于
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'HLA will add the two constants together at compile time, effectively producing
    the following instruction:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将在编译时将这两个常数相加，有效地产生以下指令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, there is nothing special about subtraction. You can easily convert
    the addressing mode involving subtraction to addition by simply taking the two's
    complement of the 32-bit constant and then adding this complemented value (rather
    than subtracting the original value).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，减法本身并没有什么特别的。你可以通过简单地取32位常数的二补码，再将该补码值相加（而不是减去原始值）轻松地将涉及减法的寻址模式转换为加法。
- en: 3.1.2.5 Scaled-Indexed Addressing Modes
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.5 缩放索引寻址模式
- en: 'The scaled-indexed addressing modes are similar to the indexed addressing modes
    with two differences: (1) The scaled-indexed addressing modes allow you to combine
    two registers plus a displacement, and (2) the scaled-indexed addressing modes
    let you multiply the index register by a (scaling) factor of 1, 2, 4, or 8\. The
    syntax for these addressing modes is'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式与索引寻址模式类似，但有两个不同之处：(1) 缩放索引寻址模式允许你结合两个寄存器加一个位移量，(2) 缩放索引寻址模式允许你将索引寄存器乘以1、2、4或8的缩放因子。这些寻址模式的语法是
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In these examples, *`BaseReg32`* represents any general-purpose 32-bit register,
    *`IndexReg32`* represents any general-purpose 32-bit register except ESP, and
    *`scale`* must be one of the constants 1, 2, 4, or 8.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，*`BaseReg32`*表示任何通用32位寄存器，*`IndexReg32`*表示除ESP外的任何通用32位寄存器，*`scale`*必须是常数1、2、4或8之一。
- en: The primary difference between the scaled-indexed addressing modes and the indexed
    addressing modes is the inclusion of the *`IndexReg32`*`*`*`scale`* component.
    These modes compute the effective address by adding in the value of this new register
    multiplied by the specified scaling factor (see [Figure 3-6](ch03.html#scaled-indexed_addressing_mode
    "Figure 3-6. Scaled-indexed addressing mode") for an example involving EBX as
    the base register and ESI as the index register).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式和索引寻址模式的主要区别在于包含了*`IndexReg32`*`*`*`scale`*组件。这些模式通过将新寄存器的值乘以指定的缩放因子后加到基地址中，从而计算有效地址（有关以EBX作为基寄存器，ESI作为索引寄存器的示例，请参见[图3-6](ch03.html#scaled-indexed_addressing_mode
    "图3-6. 缩放索引寻址模式")）。
- en: '![Scaled-indexed addressing mode](tagoreillycom20100401nostarchimages577947.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![缩放索引寻址模式](tagoreillycom20100401nostarchimages577947.png)'
- en: Figure 3-6. Scaled-indexed addressing mode
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6. 缩放索引寻址模式
- en: In [Figure 3-6](ch03.html#scaled-indexed_addressing_mode "Figure 3-6. Scaled-indexed
    addressing mode"), suppose that EBX contains $100, ESI contains $20, and *`VarName`*
    is at base address $2000 in memory; then the following instruction
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-6](ch03.html#scaled-indexed_addressing_mode "图3-6. 缩放索引寻址模式")中，假设EBX包含$100，ESI包含$20，*`VarName`*位于内存中的基地址$2000；则以下指令
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: will move the byte at address $2184 ($100 + $20*4 + 4) into the AL register.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将地址$2184（$100 + $20*4 + 4）处的字节移入AL寄存器。
- en: The scaled-indexed addressing modes are useful for accessing elements of arrays
    whose elements are 2, 4, or 8 bytes each. These addressing modes are also useful
    for access elements of an array when you have a pointer to the beginning of the
    array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式适用于访问每个元素为2、4或8字节的数组元素。当你有指向数组开始位置的指针时，这些寻址模式也非常有用。
- en: 3.1.2.6 Addressing Mode Wrap-up
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2.6 寻址模式总结
- en: Well, believe it or not, you've just learned several hundred addressing modes!
    That wasn't hard now, was it? If you're wondering where all these modes came from,
    just note that the register-indirect addressing mode isn't a single addressing
    mode but eight different addressing modes (involving the eight different registers).
    Combinations of registers, constant sizes, and other factors multiply the number
    of possible addressing modes on the system. In fact, you need only memorize about
    two dozen forms and you've got it made. In practice, you'll use less than half
    the available addressing modes in any given program (and many addressing modes
    you may never use at all). So learning all these addressing modes is actually
    much easier than it sounds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，你刚刚学会了几百种寻址模式！其实并不难，对吧？如果你在想这些模式是从哪里来的，值得注意的是，寄存器间接寻址模式并不是单一的寻址模式，而是八种不同的寻址模式（涉及到八个不同的寄存器）。寄存器、常数大小和其他因素的组合，会增加系统中可能的寻址模式的数量。实际上，你只需要记住大约二十几种形式，就能应付了。实际上，在任何给定的程序中，你会使用不到一半的可用寻址模式（而且许多寻址模式你可能永远都不会用到）。因此，学习所有这些寻址模式其实比看起来要容易得多。
- en: '* * *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#CHP-3-FN-1)]) Actually, the 80x86 does support addressing modes involving
    certain 16-bit registers, as mentioned earlier. However, HLA does not support
    these modes and they are not useful under 32-bit operating systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-3-FN-1)]) 事实上，80x86确实支持涉及某些16位寄存器的寻址模式，如前所述。然而，HLA不支持这些模式，并且在32位操作系统下它们并不实用。
- en: ^([[35](#CHP-3-FN-2)]) The term *static* here indicates a `static`, `readonly`,
    or `storage` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#CHP-3-FN-2)]) 这里的*static*表示一个`static`、`readonly`或`storage`对象。
- en: ^([[36](#CHP-3-FN-3)]) The effective address is the ultimate address in memory
    that an instruction will access, once all the address calculations are complete.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#CHP-3-FN-3)]) 有效地址是指令在完成所有地址计算后将要访问的内存中的最终地址。
- en: 3.2 Runtime Memory Organization
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 运行时内存组织
- en: An operating system like Mac OS X, FreeBSD, Linux, or Windows tends to put different
    types of data into different sections (or segments) of memory. Although it is
    possible to reconfigure memory to your choice by running the linker and specifying
    various parameters, by default Windows loads an HLA program into memory using
    the organization appearing in [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization") (Linux, Mac OS X, and FreeBSD
    are similar, though they rearrange some of the sections).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类似Mac OS X、FreeBSD、Linux或Windows的操作系统倾向于将不同类型的数据放入内存的不同段（或区域）。尽管通过运行链接器并指定不同的参数，可以重新配置内存的布局，但默认情况下，Windows使用[图3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "图3-7. HLA典型的运行时内存组织")中显示的内存组织加载HLA程序（Linux、Mac OS X和FreeBSD类似，尽管它们对一些段进行了重新安排）。
- en: '![HLA typical runtime memory organization](tagoreillycom20100401nostarchimages577949.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![HLA典型的运行时内存组织](tagoreillycom20100401nostarchimages577949.png)'
- en: Figure 3-7. HLA typical runtime memory organization
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-7. HLA典型的运行时内存组织
- en: The operating system reserves the lowest memory addresses. Generally, your application
    cannot access data (or execute instructions) at these low addresses. One reason
    the operating system reserves this space is to help trap NULL pointer references.
    If you attempt to access memory location 0, the operating system will generate
    a general protection fault, meaning you've accessed a memory location that doesn't
    contain valid data. Because programmers often initialize pointers to NULL (0)
    to indicate that the pointer is not pointing anywhere, an access of location 0
    typically means that the programmer has made a mistake and has not properly initialized
    a pointer to a legal (non-NULL) value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统保留了最低的内存地址。通常，你的应用程序无法访问这些低地址处的数据（或执行指令）。操作系统保留这些空间的一个原因是帮助捕捉NULL指针引用。如果你尝试访问内存位置0，操作系统将生成一个通用保护错误，这意味着你访问了一个没有有效数据的内存位置。因为程序员通常将指针初始化为NULL（0）以表示指针未指向任何位置，因此访问位置0通常意味着程序员犯了错误，没有正确初始化指针为合法的（非NULL）值。
- en: The remaining six areas in the memory map hold different types of data associated
    with your program. These sections of memory include the `stack` section, the `heap`
    section, the `code` section, the `readonly` section, the `static` section, and
    the `storage` section. Each of these memory sections correspond to some type of
    data you can create in your HLA programs. Each section is discussed in detail
    below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射中的其余六个区域保存与你的程序相关的不同类型的数据。这些内存段包括`stack`段、`heap`段、`code`段、`readonly`段、`static`段和`storage`段。每个内存段对应你可以在HLA程序中创建的某种类型的数据。下面将详细讨论每个段。
- en: 3.2.1 The code Section
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.1 代码段
- en: The `code` section contains the machine instructions that appear in an HLA program.
    HLA translates each machine instruction you write into a sequence of one or more
    byte values. The CPU interprets these byte values as machine instructions during
    program execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`code`段包含出现在HLA程序中的机器指令。HLA将你编写的每条机器指令翻译成一个或多个字节值的序列。在程序执行期间，CPU将这些字节值解释为机器指令。'
- en: By default, when HLA links your program it tells the system that your program
    can execute instructions in the code segment and you can read data from the code
    segment. Note, specifically, that you cannot write data to the code segment. The
    operating system will generate a general protection fault if you attempt to store
    any data into the code segment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当HLA链接你的程序时，它会告诉系统你的程序可以在代码段中执行指令，并且你可以从代码段读取数据。特别注意，你不能向代码段写入数据。如果你尝试将数据存储到代码段中，操作系统将生成一个通用保护错误。
- en: Remember, machine instructions are nothing more than data bytes. In theory,
    you could write a program that stores data values into memory and then transfers
    control to the data it just wrote, thereby producing a program that writes itself
    as it executes. This possibility produces romantic visions of *Artificial Intelligence*
    programs that modify themselves to produce some desired result. In real life,
    the effect is somewhat less glamorous. Generally, self-modifying programs are
    very difficult to debug because the instructions are constantly changing behind
    the programmer's back. Because most modern operating systems make it very difficult
    to write self-modifying programs, we will not consider them any further in this
    text.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，机器指令不过是数据字节。从理论上讲，您可以编写一个程序，将数据值存储到内存中，然后将控制权转移到它刚写入的数据上，从而产生一个在执行时自己写自己的程序。这种可能性激发了人们对
    *人工智能* 程序的浪漫幻想，这些程序能够自我修改以产生期望的结果。但在现实生活中，效果要少得多，远没有那么光彩。通常，自我修改的程序非常难以调试，因为指令在程序员的背后不断变化。由于大多数现代操作系统使得编写自我修改的程序变得非常困难，因此我们在本文中不会进一步讨论它们。
- en: HLA automatically stores the data associated with your machine code into the
    code section. In addition to machine instructions, you can also store data into
    the code section by using the following pseudo-opcodes:^([[37](#ftn.CHP-3-FN-4)])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 会自动将与机器代码关联的数据存储到代码区。除了机器指令之外，您还可以通过使用以下伪操作码将数据存储到代码区：^([[37](#ftn.CHP-3-FN-4)])
- en: '| `byte` | `int8` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `int8` |'
- en: '| `word` | `int16` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `word` | `int16` |'
- en: '| `dword` | `in32` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `dword` | `in32` |'
- en: '| `uns8` | `boolean` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `uns8` | `boolean` |'
- en: '| `uns16` | `char` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `uns16` | `char` |'
- en: '| `uns32` |   |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `uns32` |   |'
- en: 'The following `byte` statement exemplifies the syntax for each of these pseudo-opcodes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `byte` 语句展示了每个伪操作码的语法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If more than one value appears in the list of values after the pseudo-opcode,
    HLA emits each successive value to the code stream. So the first `byte` statement
    above emits 3 bytes to the code stream, the values 0, 1, and 2\. If a string appears
    within a `byte` statement, HLA emits 1 byte of data for each character in the
    string. Therefore, the second byte statement above emits 6 bytes: the characters
    `H`, `e`, `l`, `l`, and `o`, followed by a `0` byte.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果伪操作码后面的值列表中出现多个值，HLA 会将每个连续的值发送到代码流中。因此，上面的第一个 `byte` 语句会向代码流发送 3 个字节，值分别为
    0、1 和 2。如果字符串出现在 `byte` 语句中，HLA 会为字符串中的每个字符发送 1 个字节的数据。因此，上面的第二个 `byte` 语句会发送
    6 个字节：字符 `H`、`e`、`l`、`l` 和 `o`，然后是一个 `0` 字节。
- en: 'Keep in mind that the CPU will attempt to treat data you emit to the code stream
    as machine instructions unless you take special care not to allow the execution
    of the data. For example, if you write something like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非特别小心以防止数据执行，否则 CPU 会尝试将您发送到代码流中的数据当作机器指令来处理。例如，如果您写下以下内容：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: your program will attempt to execute the `0`, `1`, `2`, and `3` byte values
    as machine instructions after executing the `mov`. Unless you know the machine
    code for a particular instruction sequence, sticking such data values into the
    middle of your code will generally crash your program. Typically when you place
    such data in your programs, you'll execute some code that transfers control around
    the data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `mov` 指令后，您的程序会尝试将 `0`、`1`、`2` 和 `3` 字节值作为机器指令执行。除非您知道某个指令序列的机器码，否则将这样的数据值直接插入代码中通常会导致程序崩溃。通常，当您在程序中插入这样的数据时，您会执行一些代码，将控制权转移到数据所在位置。
- en: 3.2.2 The static Section
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.2 静态区
- en: The `static` section is where you will typically declare your variables. Although
    the `static` section syntactically appears as part of a program or procedure,
    keep in mind that HLA moves all static variables to the `static` section in memory.
    Therefore, HLA does not sandwich the variables you declare in the `static` section
    between procedures in the `code` section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 区通常是您声明变量的地方。尽管 `static` 区在语法上看起来像是程序或过程的一部分，但请记住，HLA 会将所有静态变量移动到内存中的
    `static` 区。因此，HLA 不会将您在 `static` 区声明的变量夹在 `code` 区的过程之间。'
- en: 'In addition to declaring static variables, you can also embed lists of data
    into the `static` declaration section. You use the same technique to embed data
    into your `static` section that you use to embed data into the `code` section:
    You use the `byte`, `word`, `dword`, `uns32`, and so on pseudo-opcodes. Consider
    the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明静态变量，你还可以将数据列表嵌入到`static`声明区。你可以使用与将数据嵌入到`code`区相同的技巧，将数据嵌入到`static`区：你使用`byte`、`word`、`dword`、`uns32`等伪操作码。考虑以下示例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Data that HLA writes to the `static` memory segment using these pseudo-opcodes
    is written to the segment after the preceding variables. For example, the byte
    values `1`, `2`, and `3` are emitted to the `static` section after `b`'s `0` byte.
    Because there aren't any labels associated with these values, you do not have
    direct access to these values in your program. You can use the indexed addressing
    modes to access these extra values (examples appear in [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用这些伪操作码写入`static`内存段的数据，会在前面变量之后写入该段。例如，字节值`1`、`2`和`3`会在`b`的`0`字节之后被写入`static`区。由于这些值没有与标签关联，你无法在程序中直接访问这些值。你可以使用索引寻址模式来访问这些额外的值（示例见[第4章](ch04.html
    "第4章 常量、变量和数据类型")）。
- en: In the examples above, note that the `c` and `bn` variables do not have an (explicit)
    initial value. However, if you don't provide an initial value, HLA will initialize
    the variables in the `static` section to all 0 bits, so HLA assigns the NUL character
    (ASCII code 0) to `c` as its initial value. Likewise, HLA assigns false as the
    initial value for `bn`. In particular, you should note that your variable declarations
    in the `static` section always consume memory, even if you haven't assigned them
    an initial value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，请注意`c`和`bn`变量没有（显式）初始值。然而，如果你没有提供初始值，HLA会将`static`区中的变量初始化为全0位，因此HLA将NUL字符（ASCII码0）赋给`c`作为其初始值。同样，HLA将`false`作为`bn`的初始值。特别需要注意的是，即使你没有为变量分配初始值，`static`区中的变量声明仍然会占用内存。
- en: 3.2.3 The readonly Data Section
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.3 只读数据区
- en: 'The `readonly` data section holds constants, tables, and other data that your
    program cannot change during execution. You create read-only objects by declaring
    them in the `readonly` declaration section. The `readonly` section is very similar
    to the `static` section with three primary differences:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`数据区包含常量、表格和程序在执行过程中无法修改的其他数据。你通过在`readonly`声明区中声明它们来创建只读对象。`readonly`区与`static`区非常相似，主要有三个区别：'
- en: The `readonly` section begins with the reserved word `readonly` rather than
    `static`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`区以保留字`readonly`开头，而不是`static`。'
- en: All declarations in the `readonly` section generally have an initializer.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`区中的所有声明通常都有初始化值。'
- en: The system does not allow you to store data into a `readonly` object while the
    program is running.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统不允许你在程序运行时将数据存储到`readonly`对象中。
- en: 'Here''s an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All `readonly` object declarations must have an initializer because you cannot
    initialize the value under program control.^([[38](#ftn.CHP-3-FN-5)]) For all
    intents and purposes, you can think of `readonly` objects as constants. However,
    these constants consume memory, and other than the fact that you cannot write
    data to `readonly` objects, they behave like `static` variables. Because they
    behave like `static` objects, you cannot use a `readonly` object everywhere a
    constant is allowed; in particular, `readonly` objects are memory objects, so
    you cannot supply a `readonly` object (which you are treating like a constant)
    and some other memory object as the operands to an instruction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`readonly`对象声明必须有初始化值，因为你无法在程序控制下初始化该值。^([[38](#ftn.CHP-3-FN-5)]) 就所有实际目的而言，你可以将`readonly`对象视为常量。然而，这些常量占用内存，除了不能写入数据到`readonly`对象外，它们的行为类似于`static`变量。因为它们的行为像`static`对象一样，你不能在常量允许的任何地方使用`readonly`对象；特别是，`readonly`对象是内存对象，因此你不能将一个`readonly`对象（你视为常量）和其他内存对象作为操作数传递给指令。
- en: 'As with the `static` section, you may embed data values in the `readonly` section
    using the `byte`, `word`, `dword`, and so on data declarations. For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与`static`区一样，你可以使用`byte`、`word`、`dword`等数据声明将数据值嵌入到`readonly`区。例如：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 3.2.4 The storage Section
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.4 存储区
- en: 'The `readonly` section requires that you initialize all objects you declare.
    The `static` section lets you optionally initialize objects (or leave them uninitialized,
    in which case they have the default initial value of 0). The `storage` section
    completes the initialization coverage: you use it to declare variables that are
    always uninitialized when the program begins running. The `storage` section begins
    with the `storage` reserved word and contains variable declarations without initializers.
    Here is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`部分要求你初始化所有声明的对象。`static`部分让你选择性地初始化对象（或者将它们保持未初始化状态，在这种情况下，它们的默认初始值为0）。`storage`部分完成了初始化的覆盖：你用它来声明在程序开始运行时始终未初始化的变量。`storage`部分以`storage`保留字开始，并包含没有初始化器的变量声明。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Linux, FreeBSD, Mac OS X, and Windows will initialize all storage objects to
    0 when they load your program into memory. However, it's probably not a good idea
    to depend on this implicit initialization. If you need an object initialized with
    0, declare it in a `static` section and explicitly set it to 0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux、FreeBSD、Mac OS X 和 Windows 在将程序加载到内存时会将所有存储对象初始化为 0。然而，依赖这种隐式初始化可能不是一个好主意。如果你需要一个初始化为
    0 的对象，可以在`static`部分声明它，并显式地将其设置为 0。
- en: Variables you declare in the `storage` section may consume less disk space in
    the executable file for the program. This is because HLA writes out initial values
    for `readonly` and `static` objects to the executable file, but it may use a compact
    representation for uninitialized variables you declare in the `storage` section;
    note, however, that this behavior is OS- and object-module-format dependent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`storage`部分声明的变量可能会减少程序可执行文件中的磁盘空间占用。这是因为HLA会将`readonly`和`static`对象的初始值写入可执行文件，但它可能会使用紧凑的表示方式来存储你在`storage`部分声明的未初始化变量；但请注意，这种行为依赖于操作系统和对象模块格式。
- en: Because the `storage` section does not allow initialized values, you *cannot*
    put unlabeled values in the `storage` section using the `byte`, `word`, `dword`,
    and so on pseudo-opcodes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`storage`部分不允许初始化值，所以你*不能*在`storage`部分使用`byte`、`word`、`dword`等伪操作码来放置没有标签的值。
- en: 3.2.5 The @nostorage Attribute
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.5 `@nostorage`属性
- en: 'The `@nostorage` attribute lets you declare variables in the static data declaration
    sections (i.e., `static`, `readonly`, and `storage`) without actually allocating
    memory for the variable. The `@nostorage` option tells HLA to assign the current
    address in a declaration section to a variable but not to allocate any storage
    for the object. That variable will share the same memory address as the next object
    appearing in the variable declaration section. Here is the syntax for the `@nostorage`
    option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nostorage`属性让你在静态数据声明部分（即`static`、`readonly`和`storage`）声明变量，而不实际为变量分配内存。`@nostorage`选项告诉HLA将当前地址分配给声明部分中的变量，但不为对象分配任何存储空间。该变量将与变量声明部分中下一个出现的对象共享相同的内存地址。以下是`@nostorage`选项的语法：'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that you follow the type name with `@nostorage;` rather than some initial
    value or just a semicolon. The following code sequence provides an example of
    using the `@nostorage` option in the `readonly` section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你在类型名称后跟上`@nostorage;`，而不是一些初始值或仅仅是分号。以下代码序列提供了在`readonly`部分中使用`@nostorage`选项的示例：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, `abcd` is a double word whose L.O. byte contains 97 (`'a'`),
    byte 1 contains 98 (`'b'`), byte 2 contains 99 (`'c'`), and the H.O. byte contains
    100 (`'d'`). HLA does not reserve storage for the `abcd` variable, so HLA associates
    the following 4 bytes in memory (allocated by the `byte` directive) with `abcd`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`abcd`是一个双字，其中最低字节包含97（`'a'`），字节1包含98（`'b'`），字节2包含99（`'c'`），最高字节包含100（`'d'`）。HLA不会为`abcd`变量分配存储空间，因此HLA会将内存中以下4个字节（由`byte`指令分配）与`abcd`关联。
- en: Note that the `@nostorage` attribute is legal only in the `static`, `storage`,
    and `readonly` sections (the so-called *static* declarations sections). HLA does
    not allow its use in the `var` section that you'll read about next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@nostorage`属性仅在`static`、`storage`和`readonly`部分（所谓的*静态*声明部分）合法。HLA不允许在接下来会介绍的`var`部分中使用它。
- en: 3.2.6 The var Section
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.6 `var`部分
- en: HLA provides another variable declaration section, the `var` section, that you
    can use to create *automatic* variables. Your program will allocate storage for
    automatic variables whenever a program unit (i.e., main program or procedure)
    begins execution, and it will deallocate storage for automatic variables when
    that program unit returns to its caller. Of course, any automatic variables you
    declare in your main program have the same *lifetime* ^([[39](#ftn.CHP-3-FN-6)])
    as all the `static`, `readonly`, and `storage` objects, so the automatic allocation
    feature of the `var` section is wasted in the main program. In general, you should
    use automatic objects only in procedures (see [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS") for details). HLA allows them in your main program's declaration section
    as a generalization.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了另一种变量声明部分，即 `var` 部分，你可以用来创建 *自动* 变量。当程序单元（即主程序或过程）开始执行时，程序将为自动变量分配存储；当该程序单元返回给调用者时，程序会释放自动变量的存储。当然，任何在主程序中声明的自动变量与所有
    `static`、`readonly` 和 `storage` 对象具有相同的 *生命周期* ^([[39](#ftn.CHP-3-FN-6)])，因此 `var`
    部分的自动分配功能在主程序中是无用的。通常，你应该只在过程（见 [第 5 章](ch05.html "第 5 章. 过程与单元")）中使用自动对象。HLA
    允许在主程序的声明部分使用它们作为一种概括。
- en: 'Because variables you declare in the `var` section are created at runtime,
    HLA does not allow initializers on variables you declare in this section. So the
    syntax for the `var` section is nearly identical to that for the `storage` section;
    the only real difference in the syntax between the two is the use of the `var`
    reserved word rather than the `storage` reserved word.^([[40](#ftn.CHP-3-FN-7)])
    The following example illustrates this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在 `var` 部分声明的变量是在运行时创建的，所以 HLA 不允许在此部分声明的变量上使用初始化器。因此，`var` 部分的语法与 `storage`
    部分几乎相同；两者之间唯一的实际区别是使用了 `var` 保留字，而不是 `storage` 保留字。^([[40](#ftn.CHP-3-FN-7)])
    以下示例演示了这一点：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: HLA allocates variables you declare within the `var` section within the `stack`
    memory section. HLA does not allocate `var` objects at fixed locations; instead,
    it allocates these variables in an activation record associated with the current
    program unit. [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS") discusses
    activation records in greater detail; for now it is important only to realize
    that HLA programs use the EBP register as a pointer to the current activation
    record. Therefore, whenever you access a `var` object, HLA automatically replaces
    the variable name with `[EBP±`*`displacement`*`]`. Displacement is the offset
    of the object within the activation record. This means that you cannot use the
    full scaled-indexed addressing mode (a base register plus a scaled index register)
    with `var` objects because `var` objects already use the EBP register as their
    base register. Although you will not directly use the two register addressing
    modes often, the fact that the `var` section has this limitation is a good reason
    to avoid using the `var` section in your main program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 在 `var` 部分声明的变量分配到 `stack` 内存部分。HLA 不会将 `var` 对象分配到固定位置；相反，它会将这些变量分配到与当前程序单元关联的激活记录中。[第
    5 章](ch05.html "第 5 章. 过程与单元")更详细地讨论了激活记录；目前，重要的是要意识到 HLA 程序使用 EBP 寄存器作为指向当前激活记录的指针。因此，每当你访问
    `var` 对象时，HLA 会自动将变量名替换为 `[EBP±`*`位移`*`]`。位移是对象在激活记录中的偏移量。这意味着你不能使用完整的缩放索引寻址模式（基址寄存器加缩放索引寄存器）来访问
    `var` 对象，因为 `var` 对象已经使用 EBP 寄存器作为基址寄存器。虽然你不会经常直接使用这两种寄存器寻址模式，但 `var` 部分的这一限制是避免在主程序中使用
    `var` 部分的一个重要理由。
- en: 3.2.7 Organization of Declaration Sections Within Your Programs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.7 程序中声明部分的组织
- en: 'The `static`, `readonly`, `storage`, and `var` sections may appear zero or
    more times between the `program` header and the associated `begin` for the main
    program. Between these two points in your program, the declaration sections may
    appear in any order, as the following example demonstrates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`、`readonly`、`storage` 和 `var` 部分可以在 `program` 头部和相关 `begin` 之间出现零次或多次。在程序的这两个点之间，声明部分可以按任意顺序出现，以下示例演示了这一点：'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to demonstrating that the sections may appear in an arbitrary order,
    this section also demonstrates that a given declaration section may appear more
    than once in your program. When multiple declaration sections of the same type
    (for example, the three `storage` sections above) appear in a declaration section
    of your program, HLA combines them into a single group.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了演示各个部分可以以任意顺序出现之外，本节还展示了在程序中给定的声明部分可能出现多次。当多个相同类型的声明部分（例如，上述的三个`storage`部分）出现在程序的声明部分时，HLA会将它们合并成一个组。
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[37](#CHP-3-FN-4)]) This isn't a complete list. HLA generally allows you
    to use any scalar data type name as a statement to reserve storage in the code
    section. You'll learn more about the available data types in [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#CHP-3-FN-4)]) 这不是完整的列表。HLA通常允许你使用任何标量数据类型名称作为语句，在代码部分保留存储空间。你将在[第4章](ch04.html
    "第4章。常量、变量与数据类型")中了解更多可用的数据类型。
- en: ^([[38](#CHP-3-FN-5)]) There is one exception you'll see in [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[38](#CHP-3-FN-5)]) 其中有一个例外，你将在[第5章](ch05.html "第5章。过程与单元")中看到。
- en: ^([[39](#CHP-3-FN-6)]) The lifetime of a variable is the point from which memory
    is first allocated to the point the memory is deallocated for that variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[39](#CHP-3-FN-6)]) 变量的生命周期是从首次分配内存到该变量的内存被释放的时间段。
- en: ^([[40](#CHP-3-FN-7)]) Actually, there are a few other, minor, differences,
    but we won't deal with those differences in this text. See the HLA language reference
    manual for more details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[40](#CHP-3-FN-7)]) 事实上，还有一些其他的小差异，但我们在本文中不会涉及这些差异。有关更多细节，请参阅HLA语言参考手册。
- en: 3.3 How HLA Allocates Memory for Variables
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 HLA如何为变量分配内存
- en: As you've seen, the 80x86 CPU doesn't deal with variables that have names like
    `I`, `Profits`, and `LineCnt`. The CPU deals strictly with numeric addresses it
    can place on the address bus like $1234_5678, $0400_1000, and $8000_CC00\. HLA,
    on the other hand, does not force to you refer to variable objects by their addresses
    (which is nice, because names are so much easier to remember). This is good, but
    it does obscure what is really going on. In this section, we'll take a look at
    how HLA associates numeric addresses with your variables so you'll understand
    (and appreciate) the process that is taking place behind your back.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，80x86 CPU不会处理像`I`、`Profits`和`LineCnt`这样的变量名。CPU严格处理可以放置在地址总线上的数字地址，例如$1234_5678、$0400_1000和$8000_CC00。而HLA则不会强制你通过地址来引用变量对象（这很好，因为名称更容易记住）。这很好，但它确实掩盖了真正发生的情况。在本节中，我们将了解HLA如何将数字地址与变量关联起来，这样你就能理解（并欣赏）在你不知情的情况下发生的过程。
- en: Take another look at [Figure 3-7](ch03s02.html#hla_typical_runtime_memory_organization
    "Figure 3-7. HLA typical runtime memory organization"). As you can see, the various
    memory sections tend to be adjacent to one another. Therefore, if the size of
    one memory section changes, then this affects the starting address of all the
    following sections in memory. For example, if you add a few additional machine
    instructions to your program and increase the size of the `code` section, this
    may affect the starting address of the `static` section in memory, thus changing
    the addresses of all your static variables. Keeping track of variables by their
    numeric address (rather than by their names) is difficult enough; imagine how
    much worse it would be if the addresses are constantly shifting around as you
    add and remove machine instructions in your program! Fortunately, you don't have
    to keep track of variable addresses; HLA does that bookkeeping for you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看[图3-7](ch03s02.html#hla_typical_runtime_memory_organization "图3-7. HLA典型的运行时内存组织")。如你所见，各个内存部分通常是彼此相邻的。因此，如果某一内存部分的大小发生变化，所有后续部分的起始地址也会受到影响。例如，如果你向程序中添加了一些机器指令，增大了`code`部分的大小，那么这可能会影响`static`部分在内存中的起始地址，从而改变所有静态变量的地址。通过数字地址来追踪变量（而不是通过它们的名称）已经足够困难；想象一下，如果地址在你添加或删除机器指令时不断变化，会变得多么糟糕！幸运的是，你不需要追踪变量的地址；HLA会为你完成这个记账工作。
- en: 'HLA associates a current *location counter* with each of the three static declaration
    sections (`static`, `readonly`, and `storage`). These location counters initially
    contain 0, and whenever you declare a variable in one of the static sections,
    HLA associates the current value of that section''s location counter with the
    variable; HLA also bumps up the value of that location counter by the size of
    the object you''re declaring. As an example, assume that the following is the
    only `static` declaration section in a program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: HLA为每个静态声明区段（`static`、`readonly`和`storage`）关联了一个当前的*位置计数器*。这些位置计数器最初的值为0，每当你在某个静态区段中声明一个变量时，HLA会将该区段位置计数器的当前值与变量关联；同时，HLA还会将该位置计数器的值增加声明对象的大小。举个例子，假设以下是程序中唯一的`static`声明区段：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, the runtime address of each of these variables is not the value
    of the location counter. First of all, HLA adds in the base address of the `static`
    memory section to each of these location counter values (which we call *displacements*
    or *offsets*). Second, there may be other static objects in modules that you link
    with your program (e.g., from the HLA Standard Library) or even additional `static`
    sections in the same source file, and the linker has to merge the `static` sections
    together. Hence, these offsets may have very little bearing on the final address
    of these variables in memory. Nevertheless, one important fact remains: HLA allocates
    variables you declare in a single `static` declaration section in contiguous memory
    locations. That is, given the declaration above, `w` will immediately follow `b`
    in memory, `d` will immediately follow `w` in memory, `q` will immediately follow
    `d`, and so on. Generally, it''s not good coding style to assume that the system
    allocates variables this way, but sometimes it''s convenient to do so.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些变量的运行时地址并不是位置计数器的值。首先，HLA会将`static`内存区段的基地址加到这些位置计数器的每个值上（我们称之为*位移*或*偏移量*）。其次，可能还有其他静态对象存在于你链接到程序中的模块中（例如来自HLA标准库的对象），或者在同一源文件中可能存在额外的`static`区段，链接器必须将这些`static`区段合并在一起。因此，这些偏移量可能对这些变量在内存中的最终地址几乎没有影响。尽管如此，有一个重要的事实依然成立：HLA会将你在单个`static`声明区段中声明的变量分配到连续的内存位置。也就是说，给定上述声明，`w`将在内存中紧跟`b`之后，`d`将在内存中紧跟`w`之后，`q`将在内存中紧跟`d`之后，以此类推。通常情况下，假设系统以这种方式分配变量并不是良好的编码风格，但有时这么做是方便的。
- en: 'Note that HLA allocates memory objects you declare in `readonly`, `static`,
    and `storage` sections in completely different regions of memory. Therefore, you
    cannot assume that the following three memory objects appear in adjacent memory
    locations (indeed, they probably will not):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA会将你在`readonly`、`static`和`storage`区段中声明的内存对象分配到完全不同的内存区域。因此，你不能假设以下三个内存对象会出现在相邻的内存位置（实际上，它们可能不会相邻）：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In fact, HLA will not even guarantee that variables you declare in separate
    `static` (or whatever) sections are adjacent in memory, even if there is nothing
    between the declarations in your code (for example, you cannot assume that `b`,
    `w`, and `d` are in adjacent memory locations in the following declarations, nor
    can you assume that they *won''t* be adjacent in memory):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，HLA甚至不能保证你在不同的`static`（或其他）区段中声明的变量会在内存中相邻，即使你的代码中这些声明之间没有任何东西（例如，你不能假设`b`、`w`和`d`在以下声明中是相邻的内存位置，也不能假设它们*不会*在内存中相邻）：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If your code requires these variables to consume adjacent memory locations,
    you must declare them in the same `static` section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码要求这些变量占用相邻的内存位置，你必须将它们声明在同一个`static`区段中。
- en: Note that HLA handles variables you declare in the `var` section a little differently
    than the variables you declare in one of the `static` sections. We'll discuss
    the allocation of offsets to `var` objects in [Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA处理你在`var`区段中声明的变量与在`static`区段中声明的变量略有不同。我们将在[第5章](ch05.html "第5章：过程和单元")中讨论如何为`var`对象分配偏移量。
- en: 3.4 HLA Support for Data Alignment
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 HLA对数据对齐的支持
- en: In order to write fast programs, you need to ensure that you properly align
    data objects in memory. Proper alignment means that the starting address for an
    object is a multiple of some size, usually the size of an object if the object's
    size is a power of 2 for values up to 16 bytes in length. For objects greater
    than 16 bytes, aligning the object on an 8-byte or 16-byte address boundary is
    probably sufficient. For objects less than 16 bytes, aligning the object at an
    address that is the next power of 2 greater than the object's size is usually
    fine. Accessing data that is not aligned at an appropriate address may require
    extra time; so if you want to ensure that your program runs as rapidly as possible,
    you should try to align data objects according to their size.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写快速的程序，你需要确保在内存中正确对齐数据对象。正确的对齐意味着对象的起始地址是某个大小的倍数，通常如果对象的大小是2的幂（最大为16字节），那么它的起始地址应该是该对象大小的倍数。对于大于16字节的对象，将其对齐到8字节或16字节的地址边界通常就足够了。对于小于16字节的对象，将其对齐到大于对象大小的下一个2的幂次方地址通常是可以的。访问没有对齐到合适地址的数据可能会需要额外的时间；因此，如果你想确保程序尽可能快速运行，你应该根据数据对象的大小来对齐它们。
- en: Data becomes misaligned whenever you allocate storage for different-sized objects
    in adjacent memory locations. For example, if you declare a byte variable, it
    will consume 1 byte of storage, and the next variable you declare in that declaration
    section will have the address of that byte object plus 1\. If the byte variable's
    address happens to be an even address, then the variable following that byte will
    start at an odd address. If that following variable is a word or double-word object,
    then its starting address will not be optimal. In this section, we'll explore
    ways to ensure that a variable is aligned at an appropriate starting address based
    on that object's size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为不同大小的对象分配存储空间时，如果它们被分配在相邻的内存位置，数据就会变得未对齐。例如，如果你声明了一个字节变量，它将占用1个字节的存储空间，而在该声明部分中你声明的下一个变量将位于该字节对象的地址加1的位置。如果字节变量的地址恰好是偶数地址，那么紧随其后的变量将从一个奇数地址开始。如果这个变量是一个字或双字对象，那么它的起始地址将不是最优的。在本节中，我们将探讨确保变量根据对象的大小在适当起始地址对齐的方法。
- en: 'Consider the following HLA variable declarations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下HLA变量声明：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first `static` declaration in a program (running under Windows, Mac OS
    X, FreeBSD, Linux, and most 32-bit operating systems) places its variables at
    an address that is an even multiple of 4,096 bytes. Whatever variable first appears
    in the `static` declaration is guaranteed to be aligned on a reasonable address.
    Each successive variable is allocated at an address that is the sum of the sizes
    of all the preceding variables plus the starting address of that `static` section.
    Therefore, assuming HLA allocates the variables in the previous example at a starting
    address of `4096`, HLA will allocate them at the following addresses:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的第一个`static`声明（在 Windows、Mac OS X、FreeBSD、Linux 和大多数32位操作系统下运行）将变量放置在一个偶数倍的4,096字节地址上。无论哪个变量最先出现在`static`声明中，都能保证它会对齐到一个合理的地址。每个后续变量都将分配到一个地址，该地址是前面所有变量的大小之和加上该`static`段的起始地址。因此，假设
    HLA 在前面示例中分配变量的起始地址为`4096`，HLA将把它们分配到以下地址：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the exception of the first variable (which is aligned on a 4KB boundary)
    and the byte variables (whose alignment doesn't matter), all of these variables
    are misaligned. The `w`, `w2`, and `dw2` variables start at odd addresses, and
    the `dw3` variable is aligned on an even address that is not a multiple of 4.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个变量（它对齐在4KB边界上）和字节变量（其对齐不重要）外，所有这些变量都没有对齐。`w`、`w2`和`dw2`变量从奇数地址开始，而`dw3`变量则对齐在一个不是4的倍数的偶数地址上。
- en: 'An easy way to guarantee that your variables are aligned properly is to put
    all the double-word variables first, the word variables second, and the byte variables
    last in the declaration, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 保证变量正确对齐的一个简单方法是：在声明中先写双字变量，其次是字变量，最后是字节变量，如下所示：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This organization produces the following addresses in memory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式在内存中生成以下地址：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, these variables are all aligned at reasonable addresses.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些变量都在合理的地址上进行了对齐。
- en: Unfortunately, it is rarely possible for you to arrange your variables in this
    manner. While there are many technical reasons that make this alignment impossible,
    a good practical reason for not doing this is that it doesn't let you organize
    your variable declarations by logical function (that is, you probably want to
    keep related variables next to one another regardless of their size).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通常很难按照这种方式安排你的变量。虽然有许多技术原因使得这种对齐变得不可能，但不这样做的一个好的实际原因是，这样做不能让你按逻辑功能组织变量声明（也就是说，你可能希望将相关的变量放在一起，而不管它们的大小）。
- en: 'To resolve this problem, HLA provides the `align` directive. The `align` directive
    uses the following syntax:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，HLA 提供了 `align` 指令。`align` 指令使用以下语法：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The integer constant must be one of the following small unsigned integer values:
    1, 2, 4, 8, or 16\. If HLA encounters the `align` directive in a `static` section,
    it will align the very next variable on an address that is an even multiple of
    the specified alignment constant. The previous example could be rewritten, using
    the `align` directive, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 整数常量必须是以下小的无符号整数值之一：1、2、4、8 或 16。如果 HLA 在 `static` 部分遇到 `align` 指令，它将把下一个变量对齐到一个指定对齐常量的偶数倍地址。前面的例子可以用
    `align` 指令重写，如下所示：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you're wondering how the `align` directive works, it's really quite simple.
    If HLA determines that the current address (location counter value) is not an
    even multiple of the specified value, HLA will quietly emit extra bytes of padding
    after the previous variable declaration until the current address in the `static`
    section is an even multiple of the specified value. This has the effect of making
    your program slightly larger (by a few bytes) in exchange for faster access to
    your data. Given that your program will grow by only a few bytes when you use
    this feature, this is probably a good trade-off.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想 `align` 指令是如何工作的，其实非常简单。如果 HLA 确定当前地址（位置计数器的值）不是指定值的偶数倍，HLA 会在前一个变量声明后静默地插入额外的填充字节，直到
    `static` 部分的当前地址成为指定值的偶数倍。这会使你的程序稍微变大（增加几字节），以换取更快速的数据访问。鉴于使用此功能时，程序只会增加几字节，这可能是一个值得的权衡。
- en: As a general rule, if you want the fastest possible access, you should choose
    an alignment value that is equal to the size of the object you want to align.
    That is, you should align words to even boundaries using an `align(2);` statement,
    double words to 4-byte boundaries using `align(4);`, quad words to 8-byte boundaries
    using `align(8);`, and so on. If the object's size is not a power of 2, align
    it to the next higher power of 2 (up to a maximum of 16 bytes). Note, however,
    that you need only align `real80` (and `tbyte`) objects on an 8-byte boundary.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你想要尽可能快速的访问，你应该选择一个等于你想对齐的对象大小的对齐值。也就是说，你应该用 `align(2);` 语句将字对齐到偶数边界，用
    `align(4);` 将双字对齐到 4 字节边界，用 `align(8);` 将四字对齐到 8 字节边界，依此类推。如果对象的大小不是 2 的幂，则将其对齐到下一个较大的
    2 的幂（最大为 16 字节）。不过，请注意，只有 `real80`（和 `tbyte`）类型的对象需要对齐到 8 字节边界。
- en: Note that data alignment isn't always necessary. The cache architecture of modern
    80x86 CPUs actually handles most misaligned data. Therefore, you should use the
    alignment directives only with variables for which speedy access is absolutely
    critical. This is a reasonable space/speed trade-off.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数据对齐并非总是必要的。现代 80x86 CPU 的缓存架构实际上可以处理大多数未对齐的数据。因此，你应该仅在需要快速访问的变量上使用对齐指令。这是一个合理的空间/速度权衡。
- en: 3.5 Address Expressions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 地址表达式
- en: 'Earlier, this chapter points out that addressing modes take a couple generic
    forms, including the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候提到，寻址模式有几种通用的形式，包括以下几种：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another legal form, which isn''t actually a new addressing mode but simply
    an extension of the displacement-only addressing mode, is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种合法的形式，实际上并不是一种新的寻址模式，而只是位移寻址模式的扩展，是：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This latter example computes its effective address by adding the constant offset
    within the brackets to the variable's address. For example, the instruction `mov(Address[3],
    al);` loads the AL register with the byte in memory that is 3 bytes beyond the
    `Address` object (see [Figure 3-8](ch03s05.html#using_an_address_expression_to_access_da
    "Figure 3-8. Using an address expression to access data beyond a variable")).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的示例通过将方括号内的常量偏移量与变量的地址相加来计算其有效地址。例如，指令`mov(Address[3], al);`将AL寄存器加载为内存中位于`Address`对象之后3个字节的字节（见[图3-8](ch03s05.html#using_an_address_expression_to_access_da
    "图3-8. 使用地址表达式访问超出变量的数据")）。
- en: Always remember that the *`offset`* value in these examples must be a constant.
    If `Index` is an `int32` variable, then `Variable[Index]` is not a legal address
    expression. If you wish to specify an index that varies at runtime, then you must
    use one of the indexed or scaled-indexed addressing modes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住，这些示例中的*`offset`*值必须是常量。如果`Index`是一个`int32`变量，则`Variable[Index]`不是合法的地址表达式。如果您希望指定一个在运行时变化的索引，则必须使用某种索引寻址或缩放索引寻址模式。
- en: Another important thing to remember is that the offset in `Address[`*`offset`*`]`
    is a byte address. Despite the fact that this syntax is reminiscent of array indexing
    in a high-level language like C/C++ or Pascal, this does not properly index into
    an array of objects unless `Address` is an array of bytes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的重要事项是，`Address[`*`offset`*`]`中的偏移量是字节地址。尽管这种语法类似于C/C++或Pascal等高级语言中的数组索引，但除非`Address`是字节数组，否则这并不会正确地对数组对象进行索引。
- en: '![Using an address expression to access data beyond a variable](tagoreillycom20100401nostarchimages577951.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用地址表达式访问超出变量的数据](tagoreillycom20100401nostarchimages577951.png)'
- en: Figure 3-8. Using an address expression to access data beyond a variable
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-8. 使用地址表达式访问超出变量的数据
- en: 'This text will consider an *address expression* to be any legal 80x86 addressing
    mode that includes a displacement (i.e., variable name) or an offset. In addition
    to the above forms, the following are also address expressions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将*地址表达式*视为任何合法的80x86寻址模式，其中包括位移（即变量名）或偏移量。除了上述形式外，以下也是地址表达式：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This book will *not* consider the following to be address expressions because
    they do not involve a displacement or offset component:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将*不*把以下内容视为地址表达式，因为它们不涉及位移或偏移量成分：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Address expressions are special because those instructions containing an address
    expression always encode a displacement constant as part of the machine instruction.
    That is, the machine instruction contains some number of bits (usually 8 or 32)
    that hold a numeric constant. That constant is the sum of the displacement (i.e.,
    the address or offset of the variable) plus the offset. Note that HLA automatically
    adds these two values together for you (or subtracts the offset if you use the
    `−` rather than `+` operator in the addressing mode).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 地址表达式是特别的，因为包含地址表达式的指令总是将位移常量编码为机器指令的一部分。也就是说，机器指令包含一些位（通常是8位或32位），这些位保存一个数字常量。该常量是位移（即变量的地址或偏移量）加上偏移量的和。请注意，HLA会自动为您将这两个值相加（如果在寻址模式中使用`−`而非`+`操作符，它会自动减去偏移量）。
- en: 'Until this point, the offset in all the addressing mode examples has always
    been a single numeric constant. However, HLA also allows a *constant expression*
    anywhere an offset is legal. A constant expression consists of one or more constant
    terms manipulated by operators such as addition, subtraction, multiplication,
    division, modulo, and a wide variety of others. Most address expressions, however,
    will involve only addition, subtraction, multiplication, and sometimes division.
    Consider the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有寻址模式示例中的偏移量始终是一个数字常量。然而，HLA还允许在任何合法的偏移量位置使用*常量表达式*。常量表达式由一个或多个常量项组成，这些常量项通过加法、减法、乘法、除法、取余以及其他各种运算符进行运算。然而，大多数地址表达式只涉及加法、减法、乘法，有时还会涉及除法。考虑以下示例：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This instruction will move the byte at address `X+9` into the AL register.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将地址`X+9`处的字节移动到AL寄存器中。
- en: The value of an address expression is always computed at compile time, never
    while the program is running. When HLA encounters the instruction above, it calculates
    2 * 4 + 1 on the spot and adds this result to the base address of `X` in memory.
    HLA encodes this single sum (base address of `X` plus 9) as part of the instruction;
    HLA does not emit extra instructions to compute this sum for you at runtime (which
    is good, because doing so would be less efficient). Because HLA computes the value
    of address expressions at compile time, all components of the expression must
    be constants because HLA cannot know the runtime value of a variable while it
    is compiling the program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 地址表达式的值总是在编译时计算，而不是在程序运行时计算。当 HLA 遇到上面的指令时，它会立即计算 2 * 4 + 1，并将此结果加到内存中 `X` 的基地址。HLA
    将这个单一的和（`X` 的基地址加 9）作为指令的一部分进行编码；HLA 不会在运行时为你发出额外的指令来计算这个和（这是好的，因为这样做效率更高）。由于
    HLA 在编译时计算地址表达式的值，因此表达式的所有组件必须是常量，因为 HLA 在编译程序时无法知道变量的运行时值。
- en: Address expressions are useful for accessing the data in memory beyond a variable,
    particularly when you've used the `byte`, `word`, `dword`, and so on statements
    in a `static` or `readonly` section to tack on additional bytes after a data declaration.
    For example, consider the program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions").
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 地址表达式在访问内存中变量之外的数据时非常有用，特别是当你在 `static` 或 `readonly` 段中使用 `byte`、`word`、`dword`
    等语句将附加字节添加到数据声明后时。例如，考虑 [示例 3-1](ch03s05.html#demonstration_of_address_expressions
    "示例 3-1. 地址表达式演示")中的程序。
- en: Example 3-1. Demonstration of address expressions
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1. 地址表达式演示
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The program in [Example 3-1](ch03s05.html#demonstration_of_address_expressions
    "Example 3-1. Demonstration of address expressions") will display the four values
    0, 1, 2, and 3 as though they were array elements. This is because the value at
    the address of `i` is 0 (this program declares `i` using the `@nostorage` option,
    so `i` is the address of the next object in the `static` section, which just happens
    to be the value 0 appearing as part of the `byte` statement). The address expression
    `i[1]` tells HLA to fetch the byte appearing at `i`'s address plus 1\. This is
    the value 1, because the `byte` statement in this program emits the value 1 to
    the `static` segment immediately after the value 0\. Likewise for `i[2]` and `i[3]`,
    this program displays the values 2 and 3.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](ch03s05.html#demonstration_of_address_expressions "示例 3-1. 地址表达式演示")中的程序将显示四个值
    0、1、2 和 3，仿佛它们是数组元素。这是因为 `i` 地址处的值是 0（该程序使用 `@nostorage` 选项声明 `i`，因此 `i` 是 `static`
    段中下一个对象的地址，恰好是作为 `byte` 语句一部分出现的值 0）。地址表达式 `i[1]` 告诉 HLA 获取位于 `i` 地址加 1 的字节。这个值是
    1，因为该程序中的 `byte` 语句在值 0 后立即将值 1 写入 `static` 段。同样，对于 `i[2]` 和 `i[3]`，该程序显示值 2 和
    3。'
- en: 3.6 Type Coercion
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 类型强制转换
- en: 'Although HLA is fairly loose when it comes to type checking, HLA does ensure
    that you specify appropriate operand sizes to an instruction. For example, consider
    the following (incorrect) program:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 HLA 在类型检查方面相当宽松，但 HLA 确保你为指令指定了合适的操作数大小。例如，考虑以下（错误的）程序：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: HLA will generate errors for these three `mov` instructions. This is because
    the operand sizes are incompatible. The first instruction attempts to move a byte
    into EAX, the second instruction attempts to move a word into AL, and the third
    instruction attempts to move a double word into AX. The `mov` instruction, of
    course, requires both operands to be the same size.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 会为这三个 `mov` 指令生成错误。这是因为操作数大小不兼容。第一条指令试图将一个字节移动到 EAX，第二条指令试图将一个字移动到 AL，第三条指令试图将一个双字移动到
    AX。当然，`mov` 指令要求两个操作数的大小相同。
- en: 'While this is a good feature in HLA,^([[41](#ftn.CHP-3-FN-8)]) there are times
    when it gets in the way. Consider the following code fragments:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是 HLA 的一个好特性，^([[41](#ftn.CHP-3-FN-8)])，但有时它会成为障碍。考虑以下代码片段：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example let's assume that the programmer really wants to load the word
    starting at the address of `byte_values` into the AX register because she wants
    to load AL with 0 and AH with 1 using a single instruction (note that 0 is held
    in the L.O. memory byte and 1 is held in the H.O. memory byte). HLA will refuse,
    claiming there is a type mismatch error (because `byte_values` is a byte object
    and AX is a word object). The programmer could break this into two instructions,
    one to load AL with the byte at address `byte_values` and the other to load AH
    with the byte at address `byte_values[1]`. Unfortunately, this decomposition makes
    the program slightly less efficient (which was probably the reason for using the
    single `mov` instruction in the first place). Somehow, it would be nice if we
    could tell HLA that we know what we're doing and we want to treat the `byte_values`
    variable as a `word` object. HLA's type coercion facilities provide this capability.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设程序员确实希望将`byte_values`地址开始的字加载到AX寄存器中，因为她希望通过单条指令将0加载到AL中，将1加载到AH中（注意0存储在低字节，1存储在高字节）。HLA会拒绝，声称发生了类型不匹配错误（因为`byte_values`是一个字节对象，而AX是一个字对象）。程序员可以将其拆分为两条指令，一条将字节值加载到AL，另一条将字节值加载到AH。不幸的是，这样的拆分会使程序效率稍微降低（这可能是最初使用单条`mov`指令的原因）。如果我们能告诉HLA我们知道自己在做什么，并且希望将`byte_values`变量视为`word`对象，那就太好了。HLA的类型强制转换功能提供了这种能力。
- en: '*Type coercion*^([[42](#ftn.CHP-3-FN-9)]) is the process of telling HLA that
    you want to treat an object as an explicit type, regardless of its actual type.
    To coerce the type of a variable, you use the following syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型强制转换*^([[42](#ftn.CHP-3-FN-9)])是告诉HLA你希望将一个对象视为显式类型的过程，而不管它的实际类型是什么。要强制转换变量的类型，使用以下语法：'
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The *`newTypeName`* item is the new type you wish to associate with the memory
    location specified by *`addressExpression`*. You may use this coercion operator
    anywhere a memory address is legal. To correct the previous example, so HLA doesn''t
    complain about type mismatches, you would use the following statement:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*`newTypeName`*项是你希望与*`addressExpression`*指定的内存位置关联的新类型。你可以在任何合法的内存地址上使用这个强制转换操作符。为了修正前面的例子，以便HLA不再抱怨类型不匹配，你可以使用以下语句：'
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This instruction tells HLA to load the AX register with the word starting at
    address *`byte_values`* in memory. Assuming *`byte_values`* still contains its
    initial values, this instruction will load 0 into AL and 1 into AH.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令告诉HLA从内存中*`byte_values`*地址开始加载一个字到AX寄存器中。假设*`byte_values`*仍然包含其初始值，这条指令将把0加载到AL中，将1加载到AH中。
- en: 'Type coercion is necessary when you specify an anonymous variable as the operand
    to an instruction that directly modifies memory (e.g., `neg`, `shl`, `not`, and
    so on). Consider the following statement:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个匿名变量作为直接修改内存的指令的操作数时（例如，`neg`，`shl`，`not`等），需要使用类型强制转换。考虑以下语句：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'HLA will generate an error on this instruction because it cannot determine
    the size of the memory operand. The instruction does not supply sufficient information
    to determine whether the program should invert the bits in the byte pointed at
    by EBX, the word pointed at by EBX, or the double word pointed at by EBX. You
    must use type coercion to explicitly specify the size of anonymous references
    with these types of instructions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: HLA将在此指令上生成错误，因为它无法确定内存操作数的大小。该指令未提供足够的信息来确定程序是否应该反转由EBX指向的字节的位，EBX指向的字的位，或者EBX指向的双字的位。你必须使用类型强制转换来显式指定这些类型的指令中的匿名引用的大小：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Warning
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Do not use the type coercion operator unless you know exactly what you are doing
    and fully understand the effect it has on your program. Beginning assembly language
    programmers often use type coercion as a tool to quiet the compiler when it complains
    about type mismatches without solving the underlying problem.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你完全了解自己在做什么并且充分理解它对程序的影响，否则不要使用类型强制转换操作符。初学汇编语言的程序员经常使用类型强制转换作为工具来安抚编译器，避免因类型不匹配而报错，而不解决根本问题。
- en: 'Consider the following statement (where *`byteVar`* is an 8-bit variable):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语句（其中*`byteVar`*是一个8位变量）：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Without the type coercion operator, HLA complains about this instruction because
    it attempts to store a 32-bit register in an 8-bit memory location. A beginning
    programmer, wanting his program to compile, may take a shortcut and use the type
    coercion operator, as shown in this instruction; this certainly quiets the compiler—it
    will no longer complain about a type mismatch—so the beginning programmer is happy.
    However, the program is still incorrect; the only difference is that HLA no longer
    warns you about your error. The type coercion operator does not fix the problem
    of attempting to store a 32-bit value into an 8-bit memory location—it simply
    allows the instruction to store a 32-bit value *starting at the address specified
    by the 8-bit variable*. The program still stores 4 bytes, overwriting the 3 bytes
    following *`byteVar`* in memory. This often produces unexpected results, including
    the phantom modification of variables in your program.^([[43](#ftn.CHP-3-FN-10)])
    Another, rarer possibility is for the program to abort with a general protection
    fault. This can occur if the 3 bytes following *`byteVar`* are not allocated in
    real memory or if those bytes just happen to fall in a read-only segment in memory.
    The important thing to remember about the type coercion operator is this: If you
    cannot exactly state the effect this operator has, don''t use it.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有类型强制操作符，HLA会抱怨这个指令，因为它试图将一个32位寄存器存储到一个8位的内存位置中。一个初学编程的程序员，想让程序编译通过，可能会采取捷径，使用类型强制操作符，如该指令所示；这肯定会让编译器安静下来——它不再抱怨类型不匹配——因此初学者会感到高兴。然而，程序依然不正确；唯一的区别是HLA不再警告你错误。类型强制操作符并没有解决试图将32位值存储到8位内存位置的问题——它只是允许指令将32位值*从8位变量指定的地址开始存储*。程序仍然存储了4个字节，覆盖了内存中紧跟在*`byteVar`*后面的3个字节。这常常会产生意想不到的结果，包括程序中变量的“幽灵修改”。^([[43](#ftn.CHP-3-FN-10)])
    另一种较少见的情况是程序因一般保护错误而中止。如果*`byteVar`*后面的3个字节没有分配到实际内存中，或者这些字节恰好位于内存中的只读段，则可能会发生这种情况。关于类型强制操作符需要记住的一个重要点是：如果你不能准确描述该操作符的效果，请不要使用它。
- en: Also keep in mind that the type coercion operator does not perform any translation
    of the data in memory. It simply tells the compiler to treat the bits in memory
    as a different type. It will not automatically extend an 8-bit value to 32 bits,
    nor will it convert an integer to a floating-point value. It simply tells the
    compiler to treat the bit pattern of the memory operand as a different type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，类型强制操作符不会对内存中的数据进行任何转换。它只是告诉编译器将内存中的位视为另一种类型。它不会自动将8位值扩展为32位，也不会将整数转换为浮点值。它只是告诉编译器将内存操作数的位模式视为不同的类型。
- en: '* * *'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[41](#CHP-3-FN-8)]) After all, if the two operand sizes are different this
    usually indicates an error in the program.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[41](#CHP-3-FN-8)]) 毕竟，如果两个操作数的大小不同，这通常表示程序中存在错误。
- en: ^([[42](#CHP-3-FN-9)]) This is also called *type casting* in some languages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[42](#CHP-3-FN-9)]) 这在某些语言中也称为*类型转换*。
- en: ^([[43](#CHP-3-FN-10)]) If you have a variable immediately following *`byteVar`*
    in this example, the `mov` instruction will surely overwrite the value of that
    variable, whether or not you intend for this to happen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[43](#CHP-3-FN-10)]) 如果在这个例子中有一个变量紧跟在*`byteVar`*后面，那么`mov`指令肯定会覆盖该变量的值，无论你是否希望发生这种情况。
- en: 3.7 Register Type Coercion
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 寄存器类型强制
- en: You can also cast a register to a specific type using the type coercion operator.
    By default, the 8-bit registers are of type `byte`, the 16-bit registers are of
    type `word`, and the 32-bit registers are of type `dword`. With type coercion,
    you can cast a register as a different type *as long as the size of the new type
    agrees with the size of the register*. This is an important restriction that does
    not exist when applying type coercion to a memory variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用类型强制操作符将寄存器转换为特定类型。默认情况下，8位寄存器是`byte`类型，16位寄存器是`word`类型，32位寄存器是`dword`类型。通过类型强制，你可以将寄存器转换为另一种类型，*只要新类型的大小与寄存器的大小一致*。这是一个重要的限制，使用类型强制应用于内存变量时并不存在这个限制。
- en: Most of the time you do not need to coerce a register to a different type. As
    `byte`, `word`*,* and `dword` objects, registers are already compatible with all
    1-, 2-, and 4-byte objects. However, there are a few instances where register
    type coercion is handy, if not downright necessary. Two examples include boolean
    expressions in HLA high-level language statements (e.g., `if` and `while`) and
    register I/O in the `stdout.put` and `stdin.get` (and related) statements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不需要将寄存器强制转换为不同的类型。作为`byte`、`word`和`dword`对象，寄存器已经与所有1字节、2字节和4字节对象兼容。然而，在一些情况下，寄存器类型强制转换是有用的，甚至是必需的。两个例子包括HLA高级语言语句中的布尔表达式（例如`if`和`while`）以及寄存器I/O操作，在`stdout.put`和`stdin.get`（及相关语句）中。
- en: 'In boolean expressions, HLA always treats `byte`, `word`, and `dword` objects
    as unsigned values. Therefore, without type coercion, the following `if` statement
    always evaluates false (because there is no unsigned value less than 0):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔表达式中，HLA始终将`byte`、`word`和`dword`对象视为无符号值。因此，在没有类型强制转换的情况下，以下`if`语句总是求值为假（因为没有无符号值小于0）：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can overcome this limitation by casting EAX as an `int32` value:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将EAX强制转换为`int32`类型来克服这个限制：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In a similar vein, the HLA Standard Library `stdout.put` routine always outputs
    `byte`, `word`, and `dword` values as hexadecimal numbers. Therefore, if you attempt
    to print a register, the `stdout.put` routine will print it as a hex value. If
    you would like to print the value as some other type, you can use register type
    coercion to achieve this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，HLA标准库的`stdout.put`例程总是将`byte`、`word`和`dword`值作为十六进制数输出。因此，如果你尝试打印一个寄存器，`stdout.put`例程会将其打印为十六进制值。如果你想以其他类型打印该值，可以使用寄存器类型强制转换来实现：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The same is true for the `stdin.get` routine. It will always read a hexadecimal
    value for a register unless you coerce its type to something other than `byte`,
    `word`, or `dword`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`stdin.get`例程也是如此。除非你将其类型强制转换为`byte`、`word`或`dword`以外的类型，否则它总是会读取寄存器的十六进制值。
- en: 3.8 The stack Segment and the push and pop Instructions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 堆栈段和push与pop指令
- en: This chapter mentions that all variables you declare in the `var` section wind
    up in the `stack` memory segment. However, `var` objects are not the only things
    in the `stack` memory section; your programs manipulate data in the `stack` segment
    in many different ways. This section describes the stack and introduces the `push`
    and `pop` instructions that manipulate data in the `stack` section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提到，所有在`var`段中声明的变量最终都会进入`stack`内存段。然而，`var`对象并不是`stack`内存段中唯一的内容；你的程序以多种不同的方式在`stack`段中操作数据。本节描述了堆栈，并介绍了操作`stack`段数据的`push`和`pop`指令。
- en: The `stack` segment in memory is where the 80x86 maintains the stack. The *stack*
    is a dynamic data structure that grows and shrinks according to certain needs
    of the program. The stack also stores important information about the program
    including local variables, subroutine information, and temporary data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的`stack`段是80x86维护堆栈的地方。*堆栈*是一个动态数据结构，依据程序的需求增长和收缩。堆栈还存储关于程序的重要信息，包括局部变量、子例程信息和临时数据。
- en: The 80x86 controls its stack via the ESP (stack pointer) register. When your
    program begins execution, the operating system initializes ESP with the address
    of the last memory location in the `stack` memory segment. Data is written to
    the `stack` segment by "pushing" data onto the stack and "popping" data off the
    stack.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86通过ESP（堆栈指针）寄存器控制其堆栈。当程序开始执行时，操作系统将ESP初始化为`stack`内存段中最后一个内存位置的地址。数据通过“压入”（pushing）数据到堆栈和“弹出”（popping）数据从堆栈中来写入`stack`内存段。
- en: 3.8.1 The Basic push Instruction
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8.1 基本的push指令
- en: 'Consider the syntax for the 80x86 `push` instruction:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑80x86 `push`指令的语法：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These six forms allow you to push `word` or `dword` registers, memory locations,
    and constants. You should specifically note that you cannot push `byte` values
    onto the stack.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这六种形式允许你压入`word`或`dword`寄存器、内存位置和常量。你应该特别注意，不能将`byte`值压入堆栈。
- en: 'The `push` instruction does the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`指令执行以下操作：'
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `pushw` and `pushd` operands are always 2- and 4-byte constants, respectively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushw`和`pushd`操作数分别始终是2字节和4字节常量。'
- en: Assuming that ESP contains $00FF_FFE8, then the instruction `push( eax );` will
    set ESP to $00FF_FFE4 and store the current value of EAX into memory location
    $00FF_FFE4, as [Figure 3-9](ch03s08.html#stack_segment_before_the_push_open_paren
    "Figure 3-9. Stack segment before the push( eax ); operation") and [Figure 3-10](ch03s08.html#stack_segment_after_the_push_open_parent
    "Figure 3-10. Stack segment after the push( eax ); operation") show.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 ESP 的值为 $00FF_FFE8，那么指令 `push( eax );` 会将 ESP 设置为 $00FF_FFE4，并将 EAX 的当前值存储到内存位置
    $00FF_FFE4，如 [图 3-9](ch03s08.html#stack_segment_before_the_push_open_paren "图
    3-9. push( eax ); 操作前的栈段") 和 [图 3-10](ch03s08.html#stack_segment_after_the_push_open_parent
    "图 3-10. push( eax ); 操作后的栈段") 所示。
- en: '![Stack segment before the push( eax ); operation](tagoreillycom20100401nostarchimages577953.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![push( eax ); 操作前的栈段](tagoreillycom20100401nostarchimages577953.png)'
- en: Figure 3-9. Stack segment before the `push( eax );` operation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9. `push( eax );` 操作前的栈段
- en: '![Stack segment after the push( eax ); operation](tagoreillycom20100401nostarchimages577955.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![push( eax ); 操作后的栈段](tagoreillycom20100401nostarchimages577955.png)'
- en: Figure 3-10. Stack segment after the `push( eax );` operation
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10. `push( eax );` 操作后的栈段
- en: Note that the `push( eax );` instruction does not affect the value of the EAX
    register.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`push( eax );` 指令不会影响 EAX 寄存器的值。
- en: Although the 80x86 supports 16-bit push operations, their primary use in is
    16-bit environments such as MS-DOS. For maximum performance, the stack pointer's
    value should always be an even multiple of 4; indeed, your program may malfunction
    under a 32-bit OS if ESP contains a value that is not a multiple of 4\. The only
    practical reason for pushing less than 4 bytes at a time on the stack is to build
    up a double word via two successive word pushes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 80x86 支持 16 位的 push 操作，但它们主要用于如 MS-DOS 这样的 16 位环境。为了获得最佳性能，栈指针的值应始终是 4 的偶数倍；实际上，如果
    ESP 的值不是 4 的倍数，您的程序可能在 32 位操作系统下出现故障。将小于 4 字节的数据推入栈的唯一实际原因是通过两个连续的 16 位 push 操作来构建一个双字。
- en: 3.8.2 The Basic pop Instruction
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8.2 基本 pop 指令
- en: To retrieve data you've pushed onto the stack, you use the `pop` instruction.
    The basic `pop` instruction allows the following forms.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索您推入栈的数据，可以使用 `pop` 指令。基本的 `pop` 指令允许以下几种形式。
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Like the `push` instruction, the `pop` instruction supports only 16-bit and
    32-bit operands; you cannot pop an 8-bit value from the stack. As with the `push`
    instruction, you should avoid popping 16-bit values (unless you do two 16-bit
    pops in a row) because 16-bit pops may leave the ESP register containing a value
    that is not an even multiple of 4\. One major difference between `push` and `pop`
    is that you cannot pop a constant value (which makes sense, because the operand
    for `push` is a source operand, while the operand for `pop` is a destination operand).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `push` 指令一样，`pop` 指令仅支持 16 位和 32 位操作数；您不能从栈中弹出一个 8 位的值。与 `push` 指令相同，您应该避免弹出
    16 位值（除非连续做两个 16 位弹出），因为 16 位弹出可能会导致 ESP 寄存器中包含一个不是 4 的偶数倍的值。`push` 和 `pop` 之间的一个主要区别是，您不能弹出常量值（这很有意义，因为
    `push` 的操作数是源操作数，而 `pop` 的操作数是目的操作数）。
- en: 'Formally, here''s what the `pop` instruction does:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，`pop` 指令的作用如下：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, the `pop` operation is the converse of the `push` operation.
    Note that the `pop` instruction copies the data from memory location [ESP] before
    adjusting the value in ESP. See [Figure 3-11](ch03s08.html#memory_before_a_pop_open_parenthesis_eax
    "Figure 3-11. Memory before a pop( eax ); operation") and [Figure 3-12](ch03s08.html#memory_after_the_pop_open_parenthesis_ea
    "Figure 3-12. Memory after the pop( eax ); instruction") for details on this operation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`pop` 操作是 `push` 操作的逆操作。请注意，`pop` 指令在调整 ESP 中的值之前，会从内存位置 [ESP] 复制数据。有关此操作的详细信息，请参见
    [图 3-11](ch03s08.html#memory_before_a_pop_open_parenthesis_eax "图 3-11. pop( eax
    ); 操作之前的内存") 和 [图 3-12](ch03s08.html#memory_after_the_pop_open_parenthesis_ea
    "图 3-12. pop( eax ); 指令执行后的内存")。
- en: '![Memory before a pop( eax ); operation](tagoreillycom20100401nostarchimages577957.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![pop( eax ); 操作前的内存](tagoreillycom20100401nostarchimages577957.png)'
- en: Figure 3-11. Memory before a `pop( eax );` operation
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11. `pop( eax );` 操作之前的内存
- en: '![Memory after the pop( eax ); instruction](tagoreillycom20100401nostarchimages577959.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![pop( eax ); 指令执行后的内存](tagoreillycom20100401nostarchimages577959.png)'
- en: Figure 3-12. Memory after the `pop( eax );` instruction
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12. `pop( eax );` 指令执行后的内存
- en: Note that the value popped from the stack is still present in memory. Popping
    a value does not erase the value in memory; it just adjusts the stack pointer
    so that it points at the next value above the popped value. However, you should
    never attempt to access a value you've popped off the stack. The next time something
    is pushed onto the stack, the popped value will be obliterated. Because your code
    isn't the only thing that uses the stack (for example, the operating system uses
    the stack as do subroutines), you cannot rely on data remaining in stack memory
    once you've popped it off the stack.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从栈中弹出的值仍然存在于内存中。弹出一个值并不会擦除内存中的该值，它只是调整栈指针，使其指向被弹出值上方的下一个值。然而，您绝不能尝试访问已从栈中弹出的值。下次将数据推送到栈中时，弹出的值将被覆盖。因为不仅仅是您的代码在使用栈（例如，操作系统和子程序也使用栈），所以在您将数据从栈中弹出后，不能依赖数据仍然保存在栈内存中。
- en: 3.8.3 Preserving Registers with the push and pop Instructions
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8.3 使用 `push` 和 `pop` 指令保护寄存器
- en: Perhaps the most common use of the `push` and `pop` instructions is to save
    register values during intermediate calculations. A problem with the 80x86 architecture
    is that it provides very few general-purpose registers. Because registers are
    the best place to hold temporary values, and registers are also needed for the
    various addressing modes, it is very easy to run out of registers when writing
    code that performs complex calculations. The `push` and `pop` instructions can
    come to your rescue when this happens.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 和 `pop` 指令最常见的用途可能是保存寄存器值以便进行中间计算。80x86架构的一个问题是，它提供的通用寄存器非常少。由于寄存器是保存临时值的最佳位置，并且寄存器还需要用于各种寻址模式，因此在编写执行复杂计算的代码时，寄存器很容易用完。当发生这种情况时，`push`
    和 `pop` 指令可以为您提供帮助。'
- en: 'Consider the following program outline:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下程序框架：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `push` and `pop` instructions are perfect for this situation. By inserting
    a `push` instruction before the middle sequence and a `pop` instruction after
    the middle sequence above, you can preserve the value in EAX across those calculations:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 和 `pop` 指令非常适合这种情况。通过在中间指令序列之前插入一个 `push` 指令，并在中间指令序列之后插入一个 `pop` 指令，您可以在这些计算中保护EAX中的值：'
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `push` instruction above copies the data computed in the first sequence
    of instructions onto the stack. Now the middle sequence of instructions can use
    EAX for any purpose it chooses. After the middle sequence of instructions finishes,
    the `pop` instruction restores the value in EAX so the last sequence of instructions
    can use the original value in EAX.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`push`指令将第一组指令计算出的数据复制到栈中。现在，中间的指令序列可以根据需要使用EAX寄存器。中间指令序列完成后，`pop`指令会恢复EAX中的值，以便最后一组指令可以使用EAX中的原始值。
- en: 3.9 The Stack Is a LIFO Data Structure
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 栈是一个 LIFO 数据结构
- en: 'You can push more than one value onto the stack without first popping previous
    values off the stack. However, the stack is a *last-in, first-out (LIFO)* data
    structure, so you must be careful how you push and pop multiple values. For example,
    suppose you want to preserve EAX and EBX across some block of instructions; the
    following code demonstrates the obvious way to handle this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将多个值推送到栈中，而无需先将先前的值弹出栈。然而，栈是一个*后进先出（LIFO）*数据结构，因此在推送和弹出多个值时必须小心。例如，假设您想在一些指令块之间保护EAX和EBX寄存器的值；以下代码演示了处理这种情况的明显方法：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Unfortunately, this code will not work properly! [Figure 3-13](ch03s09.html#stack_after_pushing_eax
    "Figure 3-13. Stack after pushing EAX") through [Figure 3-16](ch03s09.html#stack_after_popping_ebx
    "Figure 3-16. Stack after popping EBX") show the problem. Because this code pushes
    EAX first and EBX second, the stack pointer is left pointing at EBX's value on
    the stack. When the `pop( eax );` instruction comes along, it removes the value
    that was originally in EBX from the stack and places it in EAX! Likewise, the
    `pop( ebx );` instruction pops the value that was originally in EAX into the EBX
    register. The end result is that this code manages to swap the values in the registers
    by popping them in the same order that it pushes them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码无法正常工作！[图3-13](ch03s09.html#stack_after_pushing_eax "图3-13. 推送EAX后的栈")到[图3-16](ch03s09.html#stack_after_popping_ebx
    "图3-16. 弹出EBX后的栈")展示了问题所在。因为这段代码首先推送EAX，然后推送EBX，所以栈指针指向栈中EBX的值。当执行 `pop( eax );`
    指令时，它将原本在EBX中的值从栈中移除并放入EAX中！同样，`pop( ebx );` 指令将原本在EAX中的值弹出并放入EBX寄存器。最终结果是，这段代码通过以与推送顺序相同的顺序弹出寄存器的值，从而交换了寄存器中的值。
- en: '![Stack after pushing EAX](tagoreillycom20100401nostarchimages577961.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![推入EAX后的堆栈](tagoreillycom20100401nostarchimages577961.png)'
- en: Figure 3-13. Stack after pushing EAX
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-13. 推入 EAX 后的堆栈
- en: '![Stack after pushing EBX](tagoreillycom20100401nostarchimages577963.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![推入EBX后的堆栈](tagoreillycom20100401nostarchimages577963.png)'
- en: Figure 3-14. Stack after pushing EBX
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14. 推入 EBX 后的堆栈
- en: '![Stack after popping EAX](tagoreillycom20100401nostarchimages577965.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![弹出EAX后的堆栈](tagoreillycom20100401nostarchimages577965.png)'
- en: Figure 3-15. Stack after popping EAX
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-15. 弹出 EAX 后的堆栈
- en: '![Stack after popping EBX](tagoreillycom20100401nostarchimages577967.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![弹出EBX后的堆栈](tagoreillycom20100401nostarchimages577967.png)'
- en: Figure 3-16. Stack after popping EBX
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-16. 弹出 EBX 后的堆栈
- en: 'To rectify this problem, you must note that the stack is a last-in, first-out
    data structure, so the first thing you must pop is the last thing you push onto
    the stack. Therefore, you must always observe the following maxim:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，你必须注意到堆栈是一个后进先出（LIFO）数据结构，所以你必须先弹出最后推入堆栈的东西。因此，你必须始终遵循以下格言：
- en: '**Always pop values in the reverse order that you push them**.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终以相反的顺序弹出你推入的值**。'
- en: 'The correction to the previous code is:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的修正是：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another important maxim to remember is:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的格言是：
- en: '**Always pop exactly the same number of bytes that you push**.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终弹出与推入相同数量的字节**。'
- en: This generally means that the number of pushes and pops must exactly agree.
    If you have too few pops, you will leave data on the stack, which may confuse
    the running program. If you have too many pops, you will accidentally remove previously
    pushed data, often with disastrous results.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着推入和弹出的次数必须完全一致。如果你弹出次数太少，会导致数据留在堆栈上，可能会干扰正在运行的程序。如果你弹出次数太多，会不小心移除之前推入的数据，常常会导致灾难性的后果。
- en: '| A corollary to the maxim above is, "Be careful when pushing and popping data
    within a loop." Often it is quite easy to put the pushes in a loop and leave the
    pops outside the loop (or vice versa), creating an inconsistent stack. Remember,
    it is the execution of the `push` and `pop` instructions that matters, not the
    number of `push` and `pop` instructions that appear in your program. At runtime,
    the number (and order) of the `push` instructions the program executes must match
    the number (and reverse order) of the `pop` instructions. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 上述格言的推论是：“在循环中推入和弹出数据时要小心。”通常很容易将推入操作放在循环中，而将弹出操作放在循环外（或反之），这样会导致堆栈不一致。记住，重要的是
    `push` 和 `pop` 指令的执行，而不是程序中出现的 `push` 和 `pop` 指令的数量。在运行时，程序执行的 `push` 指令的数量（和顺序）必须与
    `pop` 指令的数量（和反顺序）相匹配。|'
- en: 3.9.1 Other push and pop Instructions
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9.1 其他推入和弹出指令
- en: 'The 80x86 provides several additional `push` and `pop` instructions in addition
    to the basic `push`/`pop` instructions. These instructions include the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 除了基本的 `push`/`pop` 指令外，还提供了几条额外的 `push` 和 `pop` 指令。这些指令包括以下几条：
- en: '| `pusha` | `popa` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `pusha` | `popa` |'
- en: '| `pushad` | `popad` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `pushad` | `popad` |'
- en: '| `pushf` | `popf` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `pushf` | `popf` |'
- en: '| `pushfd` | `popfd` |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `pushfd` | `popfd` |'
- en: 'The `pusha` instruction pushes all the general-purpose 16-bit registers onto
    the stack. This instruction exists primarily for older 16-bit operating systems
    like MS-DOS. In general, you will have very little need for this instruction.
    The `pusha` instruction pushes the registers onto the stack in the following order:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`pusha` 指令将所有通用 16 位寄存器推入堆栈。此指令主要用于旧的 16 位操作系统，如 MS-DOS。一般来说，你很少需要使用此指令。`pusha`
    指令按以下顺序将寄存器推入堆栈：'
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `pushad` instruction pushes all the 32-bit (double-word) registers onto
    the stack. It pushes the registers onto the stack in the following order:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushad` 指令将所有 32 位（双字）寄存器推入堆栈。它按以下顺序将寄存器推入堆栈：'
- en: '[PRE59]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because the `pusha` and `pushad` instructions inherently modify the SP/ESP register,
    you may wonder why Intel bothered to push this register at all. It was probably
    easier in the hardware to go ahead and push SP/ESP rather than make a special
    case out of it. In any case, these instructions do push SP or ESP, so don't worry
    about it too much—there is nothing you can do about it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `pusha` 和 `pushad` 指令本身会修改 SP/ESP 寄存器，你可能会想，为什么 Intel 会把这个寄存器也推入堆栈。可能在硬件层面，直接推入
    SP/ESP 比特殊处理它更容易。无论如何，这些指令确实会推入 SP 或 ESP，所以不用太担心——这没什么你能做的。
- en: The `popa` and `popad` instructions provide the corresponding "pop all" operation
    to the `pusha` and `pushad` instructions. This will pop the registers pushed by
    `pusha` or `pushad` in the appropriate order (that is, `popa` and `popad` will
    properly restore the register values by popping them in the reverse order that
    `pusha` or `pushad` pushed them).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`popa` 和 `popad` 指令提供了与`pusha`和`pushad`指令对应的“弹出所有”操作。这将以适当的顺序弹出`pusha`或`pushad`推送的寄存器（也就是说，`popa`和`popad`将通过以与`pusha`或`pushad`推送它们时相反的顺序弹出它们，正确恢复寄存器的值）。'
- en: Although the `pusha`/`popa` and `pushad`/`popad` sequences are short and convenient,
    they are actually slower than the corresponding sequence of `push`/`pop` instructions,
    this is especially true when you consider that you rarely need to push a majority,
    much less all, of the registers.^([[44](#ftn.CHP-3-FN-11)]) So if you're looking
    for maximum speed, you should carefully consider whether to use the `pusha`(`d`)/`popa`(`d`)
    instructions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`pusha`/`popa`和`pushad`/`popad`序列简短且方便，但它们实际上比相应的`push`/`pop`指令序列更慢，特别是当你考虑到你很少需要推送大部分寄存器，更不用说所有寄存器了时，情况就更加明显了。^([[44](#ftn.CHP-3-FN-11)])
    所以，如果你追求最大速度，应该仔细考虑是否使用`pusha`(`d`)/`popa`(`d`)指令。
- en: The `pushf`, `pushfd`, `popf`, and `popfd` instructions push and pop the EFLAGS
    register. These instructions allow you to preserve condition code and other flag
    settings across the execution of some sequence of instructions. Unfortunately,
    unless you go to a lot of trouble, it is difficult to preserve individual flags.
    When using the `pushf`(`d`) and `popf`(`d`) instructions, it's an all-or-nothing
    proposition—you preserve all the flags when you push them; you restore all the
    flags when you pop them.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushf`、`pushfd`、`popf` 和 `popfd` 指令用于推送和弹出EFLAGS寄存器。这些指令允许你在执行一系列指令时保留条件码和其他标志设置。不幸的是，除非你费很大劲，否则很难保留单独的标志。在使用`pushf`(`d`)和`popf`(`d`)指令时，这是一个“全有或全无”的问题——当你推送它们时，你会保留所有标志；当你弹出它们时，你会恢复所有标志。'
- en: Like the `pushad` and `popad` instructions, you should really use the `pushfd`
    and `popfd` instructions to push the full 32-bit version of the EFLAGS register.
    Although the extra 16 bits you push and pop are essentially ignored when writing
    applications, you still want to keep the stack aligned by pushing and popping
    only double words.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 像`pushad`和`popad`指令一样，你应该使用`pushfd`和`popfd`指令来推送完整的32位EFLAGS寄存器版本。尽管你推送和弹出的额外16位在编写应用程序时基本被忽略，但你仍然希望通过仅推送和弹出双字来保持栈的对齐。
- en: 3.9.2 Removing Data from the Stack Without Popping It
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9.2 在不弹出数据的情况下从栈中移除数据
- en: Once in a while you may discover that you've pushed data onto the stack that
    you no longer need. Although you could pop the data into an unused register or
    memory location, there is an easier way to remove unwanted data from the stack—simply
    adjust the value in the ESP register to skip over the unwanted data on the stack.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔你可能会发现自己将一些不再需要的数据推入栈中。尽管你可以将这些数据弹出到未使用的寄存器或内存位置，但有一个更简单的方法可以从栈中移除不需要的数据——只需调整ESP寄存器中的值，跳过栈中的不需要数据。
- en: 'Consider the following dilemma:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下困境：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Within the `then` section of the `if` statement, this code wants to remove the
    old values of EAX and EBX without otherwise affecting any registers or memory
    locations. How can we do this?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句的`then`部分，这段代码希望移除EAX和EBX的旧值，同时不影响任何其他寄存器或内存位置。我们如何做到这一点？
- en: 'Because the ESP register contains the memory address of the item on the top
    of the stack, we can remove the item from the top of stack by adding the size
    of that item to the ESP register. In the preceding example, we wanted to remove
    two double-word items from the top of stack. We can easily accomplish this by
    adding 8 to the stack pointer (see [Figure 3-17](ch03s09.html#removing_data_from_the_stack_comma_befor
    "Figure 3-17. Removing data from the stack, before add( 8, esp );") and [Figure 3-18](ch03s09.html#removing_data_from_the_stack_comma_after
    "Figure 3-18. Removing data from the stack, after add( 8, esp );") for the details):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ESP寄存器包含栈顶项目的内存地址，我们可以通过将该项目的大小加到ESP寄存器中来移除栈顶的项目。在上面的例子中，我们想从栈顶移除两个双字项目。我们可以通过将8加到栈指针来轻松完成这一操作（有关详细信息，请参见[图3-17](ch03s09.html#removing_data_from_the_stack_comma_befor
    "图3-17. 从栈中移除数据，在add(8, esp)之前")和[图3-18](ch03s09.html#removing_data_from_the_stack_comma_after
    "图3-18. 从栈中移除数据，在add(8, esp)之后")）。
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![Removing data from the stack, before add( 8, esp );](tagoreillycom20100401nostarchimages577969.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![从栈中移除数据，在add(8, esp)之前](tagoreillycom20100401nostarchimages577969.png)'
- en: Figure 3-17. Removing data from the stack, before `add( 8, esp );`
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17. 从栈中移除数据，`add( 8, esp );`之前
- en: '![Removing data from the stack, after add( 8, esp );](tagoreillycom20100401nostarchimages577971.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![从栈中移除数据，`add( 8, esp );`之后](tagoreillycom20100401nostarchimages577971.png)'
- en: Figure 3-18. Removing data from the stack, after `add( 8, esp );`
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-18. 从栈中移除数据，`add( 8, esp );`之后
- en: Effectively, this code pops the data off the stack without moving it anywhere.
    Also note that this code is faster than two dummy `pop` instructions because it
    can remove any number of bytes from the stack with a single `add` instruction.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这段代码是在不移动数据的情况下将数据从栈中弹出。还要注意，这段代码比两条虚拟`pop`指令更快，因为它可以通过单个`add`指令从栈中移除任意数量的字节。
- en: Warning
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Remember to keep the stack aligned on a double-word boundary. Therefore, you
    should always add a constant that is a multiple of 4 to ESP when removing data
    from the stack.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 记得保持栈在双字边界上对齐。因此，在从栈中移除数据时，应该始终向ESP添加一个4的倍数常量。
- en: '* * *'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[44](#CHP-3-FN-11)]) For example, it is extremely rare for you to need to
    push and pop the ESP register with the `pushad`/`popad` instruction sequence.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[44](#CHP-3-FN-11)]) 例如，你很少需要使用`pushad`/`popad`指令序列来推送和弹出ESP寄存器。
- en: 3.10 Accessing Data You've Pushed onto the Stack Without Popping It
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.10 访问已推入栈但尚未弹出的数据
- en: Once in a while you will push data onto the stack and you will want to get a
    copy of that data's value, or perhaps you will want to change that data's value
    without actually popping the data off the stack (that is, you wish to pop the
    data off the stack at a later time). The 80x86 `[reg32 + offset]` addressing mode
    provides the mechanism for this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你会将数据推入栈中，之后你可能需要获取该数据的副本，或者你希望在不弹出数据的情况下修改数据的值（也就是说，你希望稍后再从栈中弹出该数据）。80x86的`[reg32
    + offset]`寻址模式为此提供了机制。
- en: 'Consider the stack after the execution of the following two instructions (see
    [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX")):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个指令执行后的栈情况（见[图 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "图 3-19.
    将 EAX 和 EBX 推入栈后的栈情况")）：
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![Stack after pushing EAX and EBX](tagoreillycom20100401nostarchimages577973.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![将 EAX 和 EBX 推入栈后的栈情况](tagoreillycom20100401nostarchimages577973.png)'
- en: Figure 3-19. Stack after pushing EAX and EBX
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-19. 将 EAX 和 EBX 推入栈后的栈情况
- en: If you wanted to access the original EBX value without removing it from the
    stack, you could cheat and pop the value and then immediately push it again. Suppose,
    however, that you wish to access EAX's old value or some other value even farther
    up the stack. Popping all the intermediate values and then pushing them back onto
    the stack is problematic at best, impossible at worst. However, as you will notice
    from [Figure 3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "Figure 3-19. Stack
    after pushing EAX and EBX"), each of the values pushed on the stack is at some
    offset from the ESP register in memory. Therefore, we can use the `[ESP + offset]`
    addressing mode to gain direct access to the value we are interested in. In the
    example above, you can reload EAX with its original value by using the single
    instruction
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问原始的EBX值而不从栈中移除它，你可以通过作弊，将值弹出后再立即将其推回栈中。然而，假设你希望访问EAX的旧值或者栈上更远的其他值。弹出所有中间值并再推回栈是最好的情况，而最坏的情况是完全不可能做到的。然而，正如你从[图
    3-19](ch03s10.html#stack_after_pushing_eax_and_ebx "图 3-19. 将 EAX 和 EBX 推入栈后的栈情况")中看到的那样，栈中每个推入的值都在内存中与ESP寄存器有一定的偏移。因此，我们可以使用`[ESP
    + offset]`寻址模式来直接访问我们感兴趣的值。在上面的例子中，你可以使用单条指令通过其原始值重新加载EAX。
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This code copies the 4 bytes starting at memory address ESP+4 into the EAX register.
    This value just happens to be the previous value of EAX that was pushed onto the
    stack. You can use this same technique to access other data values you've pushed
    onto the stack.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将从内存地址ESP+4开始的4个字节复制到EAX寄存器。这个值恰好是之前推入栈中的EAX的值。你可以使用相同的技术来访问你推入栈的其他数据值。
- en: Warning
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Don't forget that the offsets of values from ESP into the stack change every
    time you push or pop data. Abusing this feature can create code that is hard to
    modify; if you use this feature throughout your code, it will make it difficult
    to push and pop other data items between the point where you first push data onto
    the stack and the point where you decide to access that data again using the *`[ESP
    + offset]`* memory addressing mode.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，ESP 中的值偏移量在每次压入或弹出数据时都会发生变化。滥用此特性可能会导致代码难以修改；如果你在代码中广泛使用此特性，将使得在第一次将数据压入堆栈和决定再次访问该数据时，难以在两者之间压入和弹出其他数据项，使用
    *`[ESP + offset]`* 内存寻址模式。
- en: 'The previous section pointed out how to remove data from the stack by adding
    a constant to the ESP register. That code example could probably be written more
    safely as this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节提到了如何通过向 ESP 寄存器添加常数来从堆栈中移除数据。那段代码示例可能会更安全地改写成这样：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this code sequence, the calculated result was stored over the top of the
    values saved on the stack. Later on, when the program pops the values, it loads
    these calculated values into EAX and EBX.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码序列中，计算结果被存储在堆栈上已保存的值之上。稍后，当程序弹出这些值时，它将这些计算结果加载到 EAX 和 EBX 寄存器中。
- en: 3.11 Dynamic Memory Allocation and the Heap Segment
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.11 动态内存分配与堆段
- en: 'Although static and automatic variables are all that simple programs may need,
    more sophisticated programs need the ability to allocate and deallocate storage
    dynamically (at runtime) under program control. In the C language, you would use
    the `malloc` and `free` functions for this purpose. C++ provides the `new` and
    `delete` operators. Pascal uses `new` and `dispose`. Other languages provide comparable
    facilities. These memory-allocation routines have a couple of things in common:
    They let the programmer request how many bytes of storage to allocate, they return
    a *pointer* to the newly allocated storage, and they provide a facility for returning
    the storage to the system so the system can reuse it in a future allocation call.
    As you''ve probably guessed, HLA also provides a set of routines in the HLA Standard
    Library that handle memory allocation and deallocation.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管静态变量和自动变量可能是简单程序所需的全部内容，但更复杂的程序需要能够在程序控制下动态地分配和释放存储空间（在运行时）。在 C 语言中，你会使用 `malloc`
    和 `free` 函数来实现这一点。C++ 提供了 `new` 和 `delete` 运算符。Pascal 使用 `new` 和 `dispose`。其他语言也提供了类似的功能。这些内存分配例程有几个共同点：它们允许程序员指定要分配的字节数，它们返回指向新分配存储空间的*指针*，并且它们提供了一种机制，可以将存储空间返回给系统，以便系统在未来的分配调用中重新利用这些空间。正如你可能猜到的，HLA
    也在 HLA 标准库中提供了一组处理内存分配和释放的例程。
- en: 'The HLA Standard Library `mem.alloc` and `mem.free` routines handle the memory
    allocation and deallocation chores (respectively). The `mem.alloc` routine uses
    the following calling sequence:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库中的 `mem.alloc` 和 `mem.free` 例程分别处理内存分配和释放操作。`mem.alloc` 例程使用以下调用顺序：
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The single parameter is a `dword` value specifying the number of bytes of storage
    you need. This procedure allocates storage in the `heap` segment in memory. The
    HLA `mem.alloc` function locates an unused block of memory of the size you specify
    in the `heap` segment and marks the block as "in use" so that future calls to
    `mem.alloc` will not allocate this same storage. After marking the block as "in
    use," the `mem.alloc` routine returns a pointer to the first byte of this storage
    in the EAX register.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的参数是一个 `dword` 值，指定你需要的存储字节数。此过程在内存的 `heap` 段中分配存储空间。HLA 的 `mem.alloc` 函数会在
    `heap` 段中找到一个未使用的内存块，并将该块标记为“正在使用中”，这样未来对 `mem.alloc` 的调用就不会再次分配相同的存储空间。在将该块标记为“正在使用中”后，`mem.alloc`
    例程将返回指向该存储空间第一个字节的指针，该指针存储在 EAX 寄存器中。
- en: 'For many objects, you will know the number of bytes that you need in order
    to represent that object in memory. For example, if you wish to allocate storage
    for an `uns32` variable, you could use the following call to the `mem.alloc` routine:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多对象，你将知道表示该对象所需的字节数。例如，如果你希望为一个 `uns32` 变量分配存储空间，可以使用以下调用来调用 `mem.alloc`
    例程：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although you can specify a literal constant as this example suggests, it''s
    generally a poor idea to do so when allocating storage for a specific data type.
    Instead, use the HLA built-in *compile-time function*^([[45](#ftn.CHP-3-FN-12)])
    `@size` to compute the size of some data type. The `@size` function uses the following
    syntax:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以像本示例所示指定一个字面常量，但在为特定数据类型分配存储时，通常不建议这么做。相反，应该使用 HLA 内置的*编译时函数*^([[45](#ftn.CHP-3-FN-12)])
    `@size` 来计算某个数据类型的大小。`@size` 函数使用以下语法：
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `@size` function returns an unsigned integer constant that is the size
    of its parameter in bytes. So you should rewrite the previous call to `mem.alloc`
    as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`@size` 函数返回一个无符号整数常量，表示其参数的字节大小。因此，你应该将之前对 `mem.alloc` 的调用重写为如下形式：'
- en: '[PRE68]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This call will properly allocate a sufficient amount of storage for the specified
    object, regardless of its type. While it is unlikely that the number of bytes
    required by an `uns32` object will ever change, this is not necessarily true for
    other data types; so you should always use `@size` rather than a literal constant
    in these calls.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用将正确分配足够的存储空间来存储指定的对象，无论其类型如何。虽然一个 `uns32` 对象所需的字节数不太可能改变，但对于其他数据类型来说，这不一定成立；因此，在这些调用中，你应该始终使用
    `@size` 而不是字面常量。
- en: Upon return from the `mem.alloc` routine, the EAX register contains the address
    of the storage you have requested (see [Figure 3-20](ch03s11.html#a_call_to_mem.alloc_returns_a_pointer_in
    "Figure 3-20. A call to mem.alloc returns a pointer in the EAX register.")).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `mem.alloc` 例程返回后，EAX 寄存器包含你请求的存储地址（参见 [图 3-20](ch03s11.html#a_call_to_mem.alloc_returns_a_pointer_in
    "图 3-20. 调用 mem.alloc 返回一个指针到 EAX 寄存器。")）。
- en: '![A call to mem.alloc returns a pointer in the EAX register.](tagoreillycom20100401nostarchimages577975.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![调用 mem.alloc 返回一个指针到 EAX 寄存器。](tagoreillycom20100401nostarchimages577975.png)'
- en: Figure 3-20. A call to `mem.alloc` returns a pointer in the EAX register.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-20. 调用 `mem.alloc` 返回一个指针到 EAX 寄存器。
- en: 'To access the storage `mem.alloc` allocates, you must use a register-indirect
    addressing mode. The following code sequence demonstrates how to assign the value
    1234 to the `uns32` variable `mem.alloc` creates:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `mem.alloc` 分配的存储，你必须使用寄存器间接寻址模式。以下代码序列演示了如何将值 1234 赋给 `mem.alloc` 创建的 `uns32`
    变量：
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note the use of the `type` coercion operator. This is necessary in this example
    because anonymous variables don't have a type associated with them and the constant
    1234 could be a `word` or `dword` value. The `type` coercion operator eliminates
    the ambiguity.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了 `type` 强制转换运算符。在本示例中，这是必要的，因为匿名变量没有与之关联的类型，并且常量 1234 可能是 `word` 或 `dword`
    类型。`type` 强制转换运算符消除了歧义。
- en: The `mem.alloc` routine may not always succeed. If there isn't a single contiguous
    block of free memory in the heap segment that is large enough to satisfy the request,
    then the `mem.alloc` routine will raise an `ex.MemoryAllocationFailure` exception.
    If you do not provide a `try..exception..endtry` handler to deal with this situation,
    a memory allocation failure will cause your program to stop. Because most programs
    do not allocate massive amounts of dynamic storage using `mem.alloc`, this exception
    rarely occurs. However, you should never assume that the memory allocation will
    always occur without error.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`mem.alloc` 例程可能并不总是成功。如果堆段中没有一个足够大的连续空闲内存块来满足请求，那么 `mem.alloc` 例程将引发一个 `ex.MemoryAllocationFailure`
    异常。如果你没有提供一个 `try..exception..endtry` 处理程序来处理这种情况，内存分配失败将导致程序停止。由于大多数程序不会使用 `mem.alloc`
    分配大量动态存储，因此这种异常很少发生。然而，你绝不能假设内存分配总是能无错误地完成。'
- en: 'When you have finished using a value that `mem.alloc` allocates on the heap,
    you can release the storage (that is, mark it as "no longer in use") by calling
    the `mem.free` procedure. The `mem.free` routine requires a single parameter that
    must be an address returned by a previous call to `mem.alloc` (that you have not
    already freed). The following code fragment demonstrates the nature of the `mem.alloc`/`mem.free`
    pairing:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成使用 `mem.alloc` 在堆上分配的值后，可以通过调用 `mem.free` 过程来释放存储（即标记为“不再使用”）。`mem.free`
    例程需要一个参数，这个参数必须是之前调用 `mem.alloc` 返回的地址（且你尚未释放过）。以下代码片段演示了 `mem.alloc`/`mem.free`
    配对的性质：
- en: '[PRE70]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This code demonstrates a very important point: In order to properly free the
    storage that `mem.alloc` allocates, you must preserve the value that `mem.alloc`
    returns. There are several ways to do this if you need to use EAX for some other
    purpose; you could save the pointer value on the stack using `push` and `pop`
    instructions or you could save EAX''s value in a variable until you need to free
    it.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Storage you release is available for reuse by future calls to the `mem.alloc`
    routine. The ability to allocate storage when you need it and then free the storage
    for other use when you have finished with it improves the memory efficiency of
    your program. By deallocating storage once you have finished with it, your program
    can reuse that storage for other purposes, allowing your program to operate with
    less memory than it would if you statically allocated storage for the individual
    objects.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Several problems can occur when you use pointers. You should be aware of a
    couple of common errors that beginning programmers make when using dynamic storage
    allocation routines like `mem.alloc` and `mem.free`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Mistake 1: Continuing to refer to storage after you free it. Once you return
    storage to the system via the call to `mem.free`, you should no longer access
    that storage. Doing so may cause a protection fault or, worse yet, corrupt other
    data in your program without indicating an error.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mistake 2: Calling `mem.free` twice to release a single block of storage. Doing
    so may accidentally free some other storage that you did not intend to release
    or, worse yet, it may corrupt the system memory management tables.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    some additional problems you will typically encounter when dealing with dynamically
    allocated storage.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples thus far in this section have all allocated storage for a single
    unsigned 32-bit object. Obviously you can allocate storage for any data type using
    a call to `mem.alloc` by simply specifying the size of that object as `mem.alloc`''s
    parameter. It is also possible to allocate storage for a sequence of contiguous
    objects in memory when calling `mem.alloc`. For example, the following code will
    allocate storage for a sequence of eight characters:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note the use of the constant expression to compute the number of bytes required
    by an eight-character sequence. Because `@size(char)` always returns a constant
    value (1 in this case), the compiler can compute the value of the expression `@size(char)
    * 8` without generating any extra machine instructions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Calls to `mem.alloc` always allocate multiple bytes of storage in contiguous
    memory locations. Hence the former call to `mem.alloc` produces the sequence appearing
    in [Figure 3-21](ch03s11.html#allocating_a_sequence_of_eight_character "Figure 3-21. Allocating
    a sequence of eight character objects using mem.alloc").
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Allocating a sequence of eight character objects using mem.alloc](tagoreillycom20100401nostarchimages577977.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21. Allocating a sequence of eight character objects using `mem.alloc`
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these extra character values you use an offset from the base address
    (contained in EAX upon return from `mem.alloc`). For example, `mov( ch, [eax +
    2] );` stores the character found in CH into the third byte that `mem.alloc` allocates.
    You can also use an addressing mode like `[eax + ebx]` to step through each of
    the allocated objects under program control. For example, the following code will
    set all the characters in a block of 128 bytes to the NUL character (#0):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES") discusses
    composite data structures (including arrays) and describes additional ways to
    deal with blocks of memory.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You should note that a call to `mem.alloc` actually allocates slightly more
    memory than you request. For one thing, memory allocation requests are generally
    of some minimum size (often a power of 2 between 4 and 16, though this is OS dependent).
    Furthermore, `mem.alloc` requests also require a few bytes of overhead for each
    request (generally around 16 to 32 bytes) to keep track of allocated and free
    blocks. Therefore, it is not efficient to allocate a large number of small objects
    with individual calls to `mem.alloc`. The overhead for each allocation may be
    greater than the storage you actually use. Typically, you'll use `mem.alloc` to
    allocate storage for arrays or large records (structures) rather than small objects.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: ^([[45](#CHP-3-FN-12)]) A compile-time function is one that HLA evaluates during
    the compilation of your program rather than at runtime.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 The inc and dec Instructions
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the example in the previous section indicates—indeed, as several examples
    up to this point have indicated—adding or subtracting 1 from a register or memory
    location is a very common operation. In fact, these operations are so common that
    Intel''s engineers included a pair of instructions to perform these specific operations:
    the `inc` (increment) and `dec` (decrement) instructions.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inc` and `dec` instructions use the following syntax:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The single operand can be any legal 8-bit, 16-bit, or 32-bit register or memory
    operand. The `inc` instruction will add 1 to the specified operand, and the `dec`
    instruction will subtract 1 from the specified operand.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'These two instructions are slightly shorter than the corresponding `add` or
    `sub` instructions (that is, their encoding uses fewer bytes). There is also one
    slight difference between these two instructions and the corresponding `add` or
    `sub` instructions: They do not affect the carry flag.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the `inc` instruction, consider the example from the previous
    section, recoded to use `inc` rather than `add`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 3.13 Obtaining the Address of a Memory Object
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[3.1.2.2 The Register-Indirect Addressing Modes](ch03.html#the_register-indirect_addressing_modes
    "3.1.2.2 The Register-Indirect Addressing Modes") discusses how to use the address-of
    operator, `&`, to take the address of a static variable.^([[46](#ftn.CHP-3-FN-13)])
    Unfortunately, you cannot use the address-of operator to take the address of an
    automatic variable (one you declare in the `var` section), you cannot use it to
    compute the address of an anonymous variable, and you cannot use it to take the
    address of a memory reference that uses an indexed or scaled-indexed addressing
    mode (even if a static variable is part of the address expression). You may use
    the address-of operator only to take the address of a simple static object. Often,
    you will need to take the address of other memory objects as well; fortunately,
    the 80x86 provides the *load effective address* instruction, `lea`, to give you
    this capability.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lea` instruction uses the following syntax:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first operand must be a 32-bit register; the second operand can be any legal
    memory reference using any valid memory addressing mode. This instruction will
    load the address of the specified memory location into the register. This instruction
    does not access or modify the value of the memory operand in any way.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load the effective address of a memory location into a 32-bit general-purpose
    register, you can use the register-indirect, indexed, or scaled-indexed addressing
    mode to access the data at the specified memory address. Consider the following
    code fragment:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This code steps through each of the 8 bytes following the `b` label in the `static`
    section and prints their values. Note the use of the `[ebx+ecx]` addressing mode.
    The EBX register holds the base address of the list (that is, the address of the
    first item in the list), and ECX contains the byte index into the list.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#CHP-3-FN-13)]) A static variable is one that you declare in the `static`,
    `readonly`, or `storage` section of your program.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 3.14 For More Information
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An older, 16-bit version of *The Art of Assembly Language Programming* can be
    found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/). In that text
    you will find information about the 80x86's 16-bit addressing modes and segmentation.
    More information about the HLA Standard Library `mem.alloc` and `mem.free` functions
    can be found in the HLA Standard Library reference manual, also on Webster at
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or at [http://artofasm.com/](http://artofasm.com/).
    Of course, the Intel x86 documentation (found at [http://www.intel.com/](http://www.intel.com/))
    provides complete information on 80x86 address modes and machine instruction encoding.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
