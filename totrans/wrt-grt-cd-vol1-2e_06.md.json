["```\nM: array [0..1023] of integer;\n```", "```\ni := 0; (* assume i is an integer variable *)\n\nM [i] := 100;\n```", "```\ni := 5;      (* assume all variables are integers*)\n\nj := 10;\n\nk := 50;\n\nm [i * j - k] := 100;\n```", "```\nM [1] := 0;\n\nM [ M [1] ] := 100;\n```", "```\nmov( PointerVariable, ebx );   // Load the pointer variable into a register.\n\nmov( [ebx], eax );             // Use register indirect mode to access data.\n```", "```\ni = **cDblPtr;            // C/C++\n\ni := ^^pDblPtr;           (* Pascal *)\n```", "```\nmov( hDblPtr, ebx );  // Get the pointer to a pointer.\n\nmov( [ebx], ebx );    // Get the pointer to the value.\n\nmov( [ebx], eax );    // Get the value.\n```", "```\nptrVar = malloc( bytes_to_allocate );\n```", "```\nptrVar = malloc( sizeof( int ) * 8 );\n```", "```\nmalloc( @size( int32 ) * 8 );  // Returns storage for eight int32 objects.\n\n                               // EAX points at this storage.\n\nmov( 0, ecx );\n\nmov( ecx, [eax] );             // Zero out the 32 bytes (4 bytes\n\nmov( ecx, [eax+4] );           // at a time).\n\nmov( ecx, [eax+8] );\n\nmov( ecx, [eax+12] );\n\nmov( ecx, [eax+16] );\n\nmov( ecx, [eax+20] );\n\nmov( ecx, [eax+24] );\n\nmov( ecx, [eax+28] );\n```", "```\nmov( [ebx-4], eax );\n```", "```\nint distance;\n\nchar *aPtr;\n\nchar *ePtr;\n\n    . . .\n\naPtr = someString;    // Get ptr to start of string in aPtr.\n\n// While we're not at the end of the string and the current\n\n// char isn't 'a':\n\nwhile( *aPtr != '\\0' && *aPtr != 'a' )\n\n{\n\n    aPtr = aPtr + 1;  // Move on to the next character pointed\n\n                      // at by aPtr.\n\n}\n\n// While we're not at the end of the string and the current \n\n// character isn't 'e':\n\nePtr = aPtr;          // Start at the 'a' char (or end of string \n\n                      // if no 'a').\n\nwhile( *ePtr != '\\0' && *ePtr != 'a' )\n\n{\n\n    ePtr = ePtr + 1;  // Move on to the next character pointed at by aPtr.\n\n}\n\n// Now compute the number of characters between the 'a' and the 'e' \n\n// (counting the 'a' but not counting the 'e'):\n\ndistance = (ePtr - aPtr);\n```", "```\ndata_type  array_name [ number_of_elements ];\n```", "```\nchar CharArray[ 128 ];\n\nint intArray[ 8 ];\n\nunsigned char ByteArray[ 10 ];\n\nint *PtrArray[ 4 ];\n```", "```\ndata_type array_name[ number_of_elements ] = {element_list};\n```", "```\nint intArray[8] = {0,1,2,3,4,5,6,7};\n```", "```\nvar array_name = Array<element_type>()\n\nvar array_name = [element_type]()\n```", "```\nvar array_name = Array<element_type>( repeating: initial_value, count: elements)\n```", "```\nvar intArray = Array<Int>( repeating: 0, count: 100)\n\nvar intArray2 = [Int]( repeating: 0, count: 100)\n```", "```\nvar intArray = [1, 2, 3]\n\nvar strArray = [\"str1\", \"str2\", \"str3\"]\n```", "```\ntype[ ] array_name = new type[elements];\n```", "```\nint[ ] intArray = {1, 2, 3};\n\nstring[ ] strArray = {\"str1\", \"str2\", \"str3\"};\n```", "```\narray_name : data_type [ number_of_elements ];\n```", "```\nstatic\n\n    CharArray: char[128];         // Character array with elements\n\n                                  //  0..127.\n\n    IntArray: integer[8];         // Integer array with elements 0..7.\n\n    ByteArray: byte[10];          // Byte array with elements 0..9.\n\n    PtrArray: dword[4];           // Double-word array with elements 0..3.\n```", "```\nRealArray: real32[8] := [ 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 ];\n\nIntegerAry: integer[8] := [ 8, 9, 10, 11, 12, 13, 14, 15 ];\n```", "```\narray_name : array[ lower_bound..upper_bound ] of data_type;\n```", "```\ntype\n\n    ptrToChar = ^char;\n\nvar\n\n    CharArray: array[0..127] of char;          // 128 elements\n\n    IntArray: array[ 0..7 ] of integer;        // 8 elements\n\n    ByteArray: array[0..9] of char;            // 10 elements\n\n    PtrArray: array[0..3] of ptrToChar;        // 4 elements\n```", "```\nvar\n\n     ProfitsByYear : array[ 1998..2039 ] of real;  // 42 elements\n```", "```\nalphaCnt : array[ 'A'..'Z' ] of integer;\n```", "```\nfor ch := 'A' to 'Z' do\n\n    alphaCnt[ ch ] := 0;\n```", "```\nElement_Address = Base_Address + index * Element_Size\n```", "```\nvar  SixteenInts : array[ 0..15 ] of integer;\n```", "```\nElement_Address = AddressOf( SixteenInts ) + index * 4\n```", "```\nmov( index, ebx );\n\nmov( SixteenInts[ ebx*4 ], eax );\n```", "```\nA:array[0..3,0..3] of char;\n```", "```\nA[ colindex ][ rowindex ]\n```", "```\nElement_Address = Base_Address + (colindex * row_size + rowindex) * Element_Size\n```", "```\nfor( int col=0; col < 4; ++col )\n\n{\n\n    for( int row=0; row < 4; ++row )\n\n    {\n\n        A[ col ][ row ] = 0;\n\n    }\n\n}\n```", "```\nsomeType A[depth_size][col_size][row_size];\n```", "```\nAddress = \n\nBase + ((depth_index * col_size + col_index) * row_size + row_index) * Element_Size\n```", "```\ndataType A[bn-1][bn-2]...[b0];\n```", "```\nA[an-1][an-2]...[a1][a0]\n```", "```\nAddress := an-1\n\nfor i := n-2 downto 0 do\n\n    Address := Address * bi + ai\n\nAddress := Base_Address + Address * Element_Size\n```", "```\nElement_Address = \n\n   Base_Address + (rowindex * col_size + colindex) * Element_Size\n```", "```\nElement_Address = \n\n   Base_Address + \n\n       ((rowindex * col_size + colindex) * depth_size + depthindex) * Element_Size\n```", "```\ndata_type array_name [dim1][dim2] . . . [dimn];\n```", "```\nint threeDInts[ 4 ][ 2 ][ 8 ];\n```", "```\nvar\n\n        threeDInts  : array[0..3] of array[0..1] of array[0..7] of integer;\n\n        threeDInts2 : array[0..3, 0..1, 0..7] of integer;\n```", "```\ntype [,]array_name = new type [dim1,dim2] ;\n\ntype [,,]array_name = new type [dim1,dim2,dim3] ;\n\ntype [,,,]array_name = new type [dim1,dim2,dim3,dim4] ;\n\netc.\n```", "```\nint ThreeDInts[ 4 ][ 2 ][ 8 ];\n```", "```\nThreeDInts[i][j][k] = n;\n```", "```\nElement_Address = \n\n   Base_Address + \n\n      ((rowindex * col_size + colindex) * depth_size + depthindex) * \n\n          Element_Size\n```", "```\nintmul( 2, i, ebx );            // EBX = 2 * i\n\nadd( j, ebx );                  // EBX = 2 * i + j\n\nintmul( 8, ebx );               // EBX = (2 * i + j) * 8\n\nadd( k, ebx );                  // EBX = (2 * i + j) * 8 + k\n\nmov( n, eax );\n\nmov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n\n```", "```\nmov( i, ebx );\n\nshl( 1, ebx );                  // EBX = 2 * i\n\nadd( j, ebx );                  // EBX = 2 * i + j\n\nshl( 3, ebx );                  // EBX = (2 * i + j) * 8\n\nadd( k, ebx );                  // EBX = (2 * i + j) * 8 + k\n\nmov( n, eax );\n\nmov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n\n```", "```\nvar array_name = ContiguousArray<element_type>()\n```", "```\nimport Foundation\n\nvar a1 = [[Int]]()\n\nvar a2 = ContiguousArray<Array<Int>>()\n\na1.append( [1,2,3] )\n\na1.append( [4,5,6] )\n\na2.append( [1,2,3] )\n\na2.append( [4,5,6] )\n\nprint( a1 )\n\nprint( a2 )\n\nprint( a1[0] )\n\nprint( a1[0][1] )\n```", "```\n[[1, 2, 3], [4, 5, 6]]\n\n[[1, 2, 3], [4, 5, 6]]\n\n[1, 2, 3]\n\n2\n```", "```\nimport Foundation\n\nvar a2 = ContiguousArray<Array<Int>>()\n\na2.append( [1,2,3] )\n\na2.append( [4,5] )\n\nprint( a2 )\n\nprint( a2[0] )\n\nprint( a2[0][1] )\n```", "```\n[[[1, 2, 3], [4, 5]]\n\n[1, 2, 3]\n\n2\n```", "```\ntype\n\n    Student = \n\n        record\n\n            Name:     string (64);\n\n            Major:    smallint;    // 2-byte integer in Delphi\n\n            SSN:      string (11);\n\n            Mid1:     smallint;\n\n            Midt:     smallint;\n\n            Final:    smallint;\n\n            Homework: smallint;\n\n            Projects: smallint;\n\n        end;\n```", "```\ntypedef\n\n    struct \n\n    {\n\n        char Name[65]; // Room for a 64-character zero-terminated string.\n\n        short Major;   // Typically a 2-byte integer in C/C++\n\n        char SSN[12];  // Room for an 11-character zero-terminated string.\n\n        short Mid1;\n\n        short Mid2;\n\n        short Final;\n\n        short Homework;\n\n        short Projects\n\n    } Student;\n```", "```\nextern \"C\"\n\n{\n\n    struct \n\n    {\n\n        char Name[65]; // Room for a 64-character zero-terminated string.\n\n        short Major;   // Typically a 2-byte integer in C/C++\n\n        char SSN[12];  // Room for an 11-character zero-terminated string.\n\n        short Mid1;\n\n        short Mid2;\n\n        short Final;\n\n        short Homework;\n\n        short Projects;\n\n    } Student;\n\n}\n```", "```\ntype\n\n    Student:\n\n        record\n\n            Name:     char[65];    // Room for a 64-character\n\n                                   // zero-terminated string.\n\n            Major:    int16;\n\n            SSN:      char[12];    // Room for an 11-character\n\n                                   // zero-terminated string.\n\n            Mid1:     int16;\n\n            Mid2:     int16;\n\n            Final:    int16;\n\n            Homework: int16;\n\n            Projects: int16;\n\n        endrecord;\n```", "```\n( value1, value2, ..., valuen )\n```", "```\nfunc returns3Ints()->(Int, Int, Int )\n\n{\n\n    return(1, 2, 3)\n\n}\n\nvar (r1, r2, r3) = returns3Ints();\n\nprint( r1, r2, r3 )\n```", "```\nvar (r1, r2, r3) = returns3Ints();\n```", "```\nlet rTuple = ( \"a\", \"b\", \"c\" )\n\nprint( rTuple.0, rTuple.1, rTuple.2 ) // Prints \"a b c\"\n```", "```\ntypealias record = ( field1:Int, field2:Int, field3:Float64 )\n\nvar r = record(1, 2, 3.0 )\n\nprint( r.field1, r.field2, r.field3 )  // prints \"1 2 3.0\"\n```", "```\nvar\n\n     John: Student;\n```", "```\nJohn.Mid1 = 80;              // C/C++ example\n\nJohn.Final := 93;            (* Pascal example *)\n\nmov( 75, John.Projects );    // HLA example\n```", "```\ntype\n\n    aRecord: record\n\n        bField : byte;  (* assume Pascal compiler supports a byte type *)\n\n        wField : word;  (* assume Pascal compiler supports a word type *)\n\n        dField : dword; (* assume Pascal compiler supports a double-word type *)\n\n    end; (* record *)\n```", "```\ntype\n\n    aRecord: packed record\n\n        bField   :byte;\n\n        padding0 :array[0..2] of byte; (* add padding to dword align wField *)\n\n        wField   :word;\n\n        padding1 :word;                (* add padding to dword align dField *)\n\n        dField   :dword; \n\n    end; (* record *)\n```", "```\ntypedef union\n\n{\n\n      unsigned int  i;\n\n      float         r;\n\n      unsigned char c[4];\n\n} unionType;\n```", "```\ntype\n\n    typeName = \n\n       record\n\n            <<nonvariant/union record fields go here>>\n\n            case tag of\n\n                const1:( field_declaration );\n\n                const2:( field_declaration );\n\n                    .\n\n                    .\n\n                    .\n\n                constn:( field_declaration )  (* no semicolon follows\n\n                                            the last field *)\n\n        end;\n```", "```\ntype\n\n    noTagRecord=\n\n        record\n\n            someField: integer;\n\n            case boolean of\n\n                true:( i:integer );\n\n                false:( b:array[0..3] of char)\n\n        end; (* record *)\n\n    hasTagRecord=\n\n        record\n\n            case which:0..2 of\n\n                0:( i:integer );\n\n                1:( r:real );\n\n                2:( c:array[0..3] of char )\n\n        end; (* record *)\n```", "```\nenum EnumType\n\n{\n\n    case a\n\n    case b\n\n    case c\n\n}\n\nlet et = EnumType.b\n\nprint( et )  // prints \"b\" on standard output\n```", "```\nimport Foundation\n\nenum EnumType\n\n{\n\n    case isInt( Int )\n\n    case isReal( Double )\n\n    case isString( String )\n\n}\n\nfunc printEnumType( _ et:EnumType )\n\n{\n\n    switch( et )\n\n    {\n\n        case .isInt( let i ):\n\n            print( i )\n\n        case .isReal( let r ):\n\n            print( r )\n\n        case .isString( let s ):\n\n            print( s )\n\n    }\n\n}\n\nlet etI = EnumType.isInt( 5 )\n\nlet etF = EnumType.isReal( 5.0 )\n\nlet etS = EnumType.isString( \"Five\" )\n\nprint( etI, etF, etS )\n\nprintEnumType( etI )\n\nprintEnumType( etF )\n\nprintEnumType( etS )\n```", "```\nisInt(5) isReal(5.0) isString(\"Five\")\n\n5\n\n5.0\n\nFive\n```", "```\ntype\n\n    unionType:\n\n        union\n\n            i: int32;\n\n            r: real32;\n\n            c: char[4];\n\n        endunion;\n```", "```\ntype\n\n    numericRec:\n\n        record\n\n            i: int32;\n\n            u: uns32;\n\n            r: real64;\n\n        endrecord;\n\n    numericUnion:\n\n        union\n\n            i: int32;\n\n            u: uns32;\n\n            r: real64;\n\n        endunion;\n```", "```\ntype\n\n    CharOrUns:\n\n        union\n\n            c:char;\n\n            u:uns32;\n\n            endunion;\n\nstatic\n\n    v:CharOrUns;\n```", "```\nmov( eax, v.u );\n\nstdout.put( \"v, as a character, is '\", v.c, \"'\" nl );\n```", "```\ntypedef union\n\n{\n\n    unsigned int u;\n\n    unsigned char bytes[4];\n\n} asBytes;\n\nasBytes composite;\n\n        .\n\n        .\n\n        .\n\n    composite.u = 1234567890;\n\n    printf\n\n    ( \n\n        \"HO byte of composite.u is %u, LO byte is %u\\n\",\n\n        composite.u[3],\n\n        composite.u[0]\n\n    );\n```", "```\ntype\n\n     student: record \n\n          sName:    char[65]; \n\n          Major:    int16; \n\n          SSN:      char[12]; \n\n          Midterm1: int16; \n\n          Midterm2: int16; \n\n          Final:    int16; \n\n          Homework: int16; \n\n          Projects: int16;  \n\n     endrecord; \n\n     student2: class \n\n          var \n\n               sName:    char[65]; \n\n               Major:    int16; \n\n               SSN:      char[12]; \n\n               Midterm1: int16; \n\n               Midterm2: int16; \n\n               Final:    int16; \n\n               Homework: int16; \n\n               Projects: int16;\n\n          method setName( source:string );\n\n          method getName( dest:string );\n\n          procedure create;  // Constructor for class\n\n     endclass;\n```", "```\ntype\n\n        student3: class  inherits( student2 )\n\n            var\n\n                extraTime: int16; // Extra time allotted for exams\n\n            override method setName;\n\n            override procedure create;\n\n     endclass;\n```", "```\ntype  \n\n     tBaseClass: class\n\n          var\n\n               i:uns32;\n\n               j:uns32;\n\n               r:real32;\n\n          method mBase;\n\n     endclass;\n\n     tChildClassA: class inherits( tBaseClass )\n\n          var\n\n               c:char;\n\n               b:boolean;\n\n               w:word;\n\n          method mA;\n\n     endclass;\n\n     tChildClassB: class inherits( tBaseClass )\n\n          var\n\n               d:dword;\n\n               c:char;\n\n               a:byte[3];\n\n     endclass;\n```", "```\nreadonly\n\n      VMT( student2 );\n\n      VMT( student3 );\n```", "```\nprocedure student2.create; @noframe;\n\nbegin create;\n\n    push( eax );\n\n    // ESI will contain NULL if this is called as \"student2.create();\"\n\n    // ESI will not be NULL if you call create from an object reference,\n\n    // such as \"John.create();\" (in which case ESI will point at the object,\n\n    // John in this case).\n\n    if( esi == NULL ) then\n\n        // If a class call, allocate storage for the object\n\n        // on the heap.\n\n        mov( malloc( @size( student2 )), esi );\n\n    endif;\n\n    mov( &student2._VMT_, this._pVMT_ );\n\n    // If you're going to initialize other fields of the class, do that here.\n\n    pop( eax );\n\n    ret();\n\nend create;\n\nprocedure student3.create; @noframe;\n\nbegin create;\n\n    push( eax );\n\n    if( esi == NULL ) then\n\n        mov( malloc( @size( student3 )), esi );\n\n    endif;\n\n    // Must call the base constructor to do any class initialization\n\n    // it requires.\n\n    (type student2 [esi]).create();  // Must call the base class constructor.\n\n    // Might want to initialize any student3-specific fields (such \n\n    // as extra time) here:\n\n    // student2.create filled in the VMT pointer with the address of the\n\n    // student2 VMT. It really needs to point at the student3 VMT.\n\n    // Fix that here.\n\n    mov( &student3._VMT_, this._pVMT_ );\n\n    pop( eax );\n\n    ret();\n\nend create;\n```", "```\nmov( &student2._VMT_, this._pVMT_ );\n\nmov( &student3._VMT_, this._pVMT_ );\n```", "```\n(type student2 [esi]).create();  // Must call the base class constructor.\n```", "```\nvar\n\n    John        :pointer to student2;\n\n    Joan        :pointer to student2;\n\n    Jenny       :pointer to student3;\n\n        .\n\n        .\n\n        .\n\n    student2.create(); // Equivalent to calling \"new student2\"\n\n                       // in other languages.\n\n    mov( esi, John );  // Save pointer to new student2\n\n                       // object in John\n\n    student2.create();\n\n    mov( esi, Joan );\n\n    student3.create();\n\n    mov( esi, Jenny );\n```", "```\nJohn.setName(\"John\");\n\nJoan.setName(\"Joan\");\n```", "```\nmov( John, esi );\n\nmov( (type student2 [esi])._pVMT_, edi );\n\ncall( [edi+0] );        // Note: the offset of the setName method in the VMT is 0.\n```", "```\nvar student:pointer to student2;\n```", "```\ntype  \n\n     uint: class \n\n          var \n\n               TheValue: dword;\n\n          method put; \n\n          << Other methods for this class >>  \n\n     endclass;\n\n     sint: class\n\n          var\n\n               TheValue: dword;\n\n          method put; \n\n          << Other methods for this class >>  \n\n     endclass;\n\n     r64: class\n\n          var\n\n               TheValue: real64;\n\n          method put; \n\n          << Other methods for this class >>  \n\n     endclass;\n```", "```\ntype\n\n     numeric: class\n\n          method put;\n\n          << Other common methods shared by all the classes >>\n\n     endclass;\n\n     uint: class inherits( numeric )\n\n          var\n\n               TheValue: dword;\n\n          override method put;\n\n          << Other methods for this class >>\n\n     endclass;\n\n     sint: class inherits( numeric )\n\n          var\n\n               TheValue: dword;\n\n          override method put;\n\n          << Other methods for this class >>\n\n     endclass;\n\n     r64: class inherits( numeric )\n\n          var\n\n               TheValue: real64;\n\n          override method put;\n\n          << Other methods for this class >>  \n\nendclass;\n```", "```\ntype\n\n     numeric: class\n\n          method put; abstract;\n\n          << Other common methods shared by all the classes >>\n\n     endclass;\n```", "```\nclass student2\n\n{\n\n    private:\n\n        char    Name[65];\n\n        short   Major;\n\n        char    SSN[12];\n\n        short   Midterm1;\n\n        short   Midterm2;\n\n        short   Final;\n\n        short   Homework;\n\n        short   Projects;\n\n    protected:\n\n        virtual void clearGrades();\n\n    public:\n\n        student2();\n\n        ~student2();\n\n        virtual void getName(char *name_p, int maxLen);\n\n        virtual void setName(const char *name_p);\n\n};\n```", "```\nclass student3 : public student2\n\n{\n\n    public:\n\n        short extraTime;\n\n        virtual void setName(char *name_p, int maxLen);\n\n        student3();\n\n        ~student3();\n\n};\n```", "```\nstruct student3 : public student2\n\n{\n\n        short extraTime;\n\n        virtual void setName(char *name_p, int maxLen);\n\n        student3();\n\n        ~student3();\n\n};\n```", "```\nstruct absClass\n\n{\n\n        int someDataField;\n\n        virtual void absFunc( void ) = 0;\n\n };\n```", "```\nclass a\n\n{\n\n    public:\n\n        int i;\n\n        virtual void setI(int i) { this->i = i; }\n\n};\n\nclass b\n\n{\n\n    public:\n\n        int j;\n\n        virtual void setJ(int j) { this->j = j; }\n\n};\n\nclass c : public a, public b\n\n{\n\n    public:\n\n        int k;\n\n        virtual void setK(int k) { this->k = k; }\n\n};\n```", "```\npublic abstract class a\n\n{\n\n        int i;\n\n        abstract void setI(int i);\n\n};\n\npublic class b extends a\n\n{\n\n    int j;\n\n    void setI( int i )\n\n    {\n\n        this.i = i;\n\n    }\n\n    void setJ(int j)\n\n    {\n\n        this.j = j; \n\n    }\n\n};\n```", "```\nclass a\n\n{\n\n    var i: Int;\n\n    init( i:Int )\n\n    {\n\n        self.i = i;\n\n    }\n\n    func setI( i :Int )\n\n    {\n\n        self.i = i;\n\n    }\n\n};\n\nclass b : a\n\n{\n\n    var j: Int = 0;\n\n    override func setI( i :Int )\n\n    {\n\n    self.i = I;\n\n    }\n\n    func setJ( j:Int)\n\n    {\n\n        self.j = j;\n\n    }\n\n};\n```", "```\nprotocol someProtocol\n\n{\n\n    func doSomething()->Void;\n\n    func doSomethingElse() ->Void;\n\n}\n\nprotocol anotherProtocol\n\n{\n\n    func doThis()->Void;\n\n    func doThat()->Void;\n\n}\n\nclass supportsProtocols: someProtocol, anotherProtocol\n\n{\n\n    var i:Int = 0;\n\n    func doSomething()->Void\n\n    {\n\n        // appropriate function body\n\n    }\n\n    func doSomethingElse()->Void\n\n    {\n\n        // appropriate function body\n\n    }\n\n    func doThis()->Void\n\n    {\n\n        // appropriate function body\n\n    }\n\n    func doThat()->Void\n\n    {\n\n        // appropriate function body\n\n    }}\n\n}\n```", "```\nclass InterfaceDemo {\n\n    interface someInterface\n\n    {\n\n        public void doSomething();\n\n        public void doSomethingElse();\n\n    }\n\n    interface anotherInterface\n\n    {\n\n        public void doThis();\n\n        public void doThat();\n\n    }\n\n    class supportsInterfaces implements someInterface, anotherInterface\n\n    {\n\n        int i;\n\n        public void doSomething()\n\n        {\n\n                // appropriate function body\n\n        }\n\n        public void doSomethingElse()\n\n        {\n\n                // appropriate function body\n\n        }\n\n        public void doThis()\n\n        {\n\n                // appropriate function body\n\n        }\n\n        public void doThat()\n\n        {\n\n                // appropriate function body\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n    System.out.println(\"InterfaceDemo\");\n\n    }\n\n}\n```", "```\nsomeInterface some = new supportsInterfaces();\n\n// We can call the member functions defined for someInterface:\n\nsome.doSomething();\n\nsome.doSomethingElse();\n\n// Note that it is illegal to try and call doThis \n\n// or doThat (or access the i data field) using\n\n// the \"some\" variable.\n```", "```\nimport Foundation\n\nprotocol a\n\n{\n\n    func b()->Void;\n\n    func c()->Void;\n\n}\n\nprotocol d\n\n{\n\n    func e()->Void;\n\n    func f()->Void;\n\n}\n\nclass g : a, d\n\n{\n\n    var i:Int = 0;\n\n    func b()->Void {print(\"b\")}\n\n    func c()->Void {print(\"c\")}\n\n    func e()->Void {print(\"e\")}\n\n    func f()->Void {print(\"f\")}\n\n    func local()->Void {print( \"local to g\" )}\n\n}\n\nvar x:a = g()\n\nx.b()\n\nx.c()\n```", "```\ntemplate< class T >\n\nclass node {\n\n  public:\n\n    T data;\n\n  private:\n\n    node< T > *next;\n\n};\n\ntemplate< class T >\n\nclass list {\n\n  public:\n\n    int  isEmpty();\n\n    void append( T data );\n\n    T    remove();\n\n    list() { \n\n      listEnd = new node< T >(); \n\n      listEnd->next = listEnd; \n\n    }\n\n  private:\n\n    node< T >* listEnd;\n\n};\n```", "```\n#include <iostream>\n\n#include <list>\n\nusing namespace std;\n\nint main(void) {\n\n    list< int > integerList;\n\n    list< double > doubleList;\n\n    integerList.push_back( 25 );\n\n    integerList.push_back( 0 );\n\n    doubleList.push_back( 1.2 );\n\n    doubleList.push_back( 3.14 );\n\n    cout << \"integerList.size() \" << integerList.size() << endl;\n\n    cout << \"doubleList.size()  \" << doubleList.size()  << endl;\n\n    return 0;\n\n}\n\n    doubleList.add( 3.14 );\n```", "```\nlist <int> iList1;\n\nlist <int> iList2;\n```"]