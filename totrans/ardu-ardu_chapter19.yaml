- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    ESP32 MICROCONTROLLER PLATFORM AND IOT</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: The phrase *Internet of things (IoT)* describes a wide variety of devices that
    communicate or are controlled over the internet. In the past, building IoT Arduino
    projects that communicate using Wi-Fi was complex and expensive, as Wi-Fi shields
    for Arduino were cumbersome and had limited features when combined with the Arduino’s
    microcontroller. However, this is no longer the case, thanks to the Espressif
    ESP32 microcontroller platform, which has built-in Wi-Fi and Arduino compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use ESP32-based boards in the final six chapters of this book. For the
    best learning experience, you may want to read these chapters in order; however,
    you can still skip around between them if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll introduce you to the ESP32-based Arduino-compatible development
    board. You’ll learn to install new board profiles in the Arduino IDE, test ESP32
    Wi-Fi connectivity, and use PWM with the ESP32 board. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple web page with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a remote control for four outputs with state display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a remote-control-adjustable PWM output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll use the skills you develop in this chapter to work with other internet-connected
    devices in the later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The ESP32</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ESP32 is a microcontroller with built-in Wi-Fi and Bluetooth, as well as
    a higher operating speed than a typical Arduino or compatible board. It’s not
    a simple one-chip configuration; instead, it requires an external flash memory
    IC and an antenna for the wireless operations. The IC and antenna are usually
    grouped closely together, as shown in [Figure 19-1](chapter19.xhtml#fig19-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE ESP32 MICROCONTROLLER UNIT PCB](../images/fig19-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: Example ESP32
    chipset in a module with the top can removed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid signal interference, the required circuitry is supplied in a module,
    which has a metal can on top. This module is then fitted to boards with the circuitry
    used to interface with other devices or is added to boards to become Arduino-compatible,
    as shown in [Figure 19-2](chapter19.xhtml#fig19-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE ESP32-BASED ARDUINO-COMPATIBLE BOARD](../images/fig19-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: An ESP32 development
    board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Boards like PMD Way part 51045204, shown in [Figure 19-2](chapter19.xhtml#fig19-2),
    are known as *ESP32 development boards* (or *dev boards*). You’ll use this board
    for projects from this chapter through [Chapter 24](chapter24.xhtml). Make sure
    to order the required USB cable if it isn’t included with the board you purchase.
  prefs: []
  type: TYPE_NORMAL
- en: There are four major differences between the Arduino Uno and the ESP32 dev board.
    The first is the large external flash memory IC; the ESP32 offers much more space
    for Arduino code than offered by an 8-bit Arduino. The second difference is the
    faster CPU speed of up to 240 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: The third difference is that the ESP32 is a 3.3 V device, so all connections
    to external devices via input or output pins must either operate at 3.3 V or be
    3.3 V tolerant. If the connection isn’t at this voltage by default, you’ll need
    to use a level converter such as PMD Way part 441079, shown in [Figure 19-3](chapter19.xhtml#fig19-3).
    Connect the converter between the wires from the 5 V device to the HV pads and
    the matching lower voltage wires on the LV pads to the ESP32, and connect GND
    of both sides to the ESP32 and the 5 V device.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE FOUR-CHANNEL LEVEL CONVERTER PCB](../images/fig19-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A four-channel
    level converter board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When shopping for a level converter, get a four-channel unit like the unit in
    [Figure 19-3](chapter19.xhtml#fig19-3). That way, you can use both SPI and I²C
    data buses without running out of converter pins.
  prefs: []
  type: TYPE_NORMAL
- en: The final difference between the Arduino Uno and the ESP32 is that, while the
    ESP32 shares the same physical form factor as an Uno, the pinouts are different,
    as shown in [Table 19-1](chapter19.xhtml#tab19-1). This also means that some Arduino
    shields may not work with the ESP32 board, so investigate the required connections
    of a shield before purchasing to use with your ESP32.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp> <samp class="SANS_Futura_Std_Book_11">ESP32
    and Arduino Pinout Comparison</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Arduino label</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno
    R3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    label</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno R3</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">ESP32</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C clock</samp> | <samp class="SANS_Futura_Std_Book_11">SCL</samp>
    | <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D3</samp> | <samp class="SANS_Futura_Std_Book_11">IO25</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C data</samp> | <samp class="SANS_Futura_Std_Book_11">SDA</samp>
    | <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D2</samp> | <samp class="SANS_Futura_Std_Book_11">IO26</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Analog reference</samp> | <samp class="SANS_Futura_Std_Book_11">AREF</samp>
    | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D1</samp> | <samp class="SANS_Futura_Std_Book_11">TX
    only</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D0</samp> | <samp class="SANS_Futura_Std_Book_11">RX
    only</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D13</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO18</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A5</samp> | <samp class="SANS_Futura_Std_Book_11">IO39</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D12</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO19</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A4</samp> | <samp class="SANS_Futura_Std_Book_11">IO36</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D11</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO23</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A3</samp> | <samp class="SANS_Futura_Std_Book_11">IO34</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D10</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO5</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A2</samp> | <samp class="SANS_Futura_Std_Book_11">IO35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D9</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO13</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A1</samp> | <samp class="SANS_Futura_Std_Book_11">IO4</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D8</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO12</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A0</samp> | <samp class="SANS_Futura_Std_Book_11">IO2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D7</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO14</samp> | <samp class="SANS_Futura_Std_Book_11">Board
    voltage</samp> | <samp class="SANS_Futura_Std_Book_11">IOREF</samp> | <samp class="SANS_Futura_Std_Book_11">IO0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D6</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO27</samp> | <samp class="SANS_Futura_Std_Book_11">Reset
    MCU</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D5</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO16</samp> | <samp class="SANS_Futura_Std_Book_11">3.3
    V output</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D4</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO17</samp> | <samp class="SANS_Futura_Std_Book_11">5
    V output</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">Raw voltage in</samp> | <samp
    class="SANS_Futura_Std_Book_11">Vin</samp> | <samp class="SANS_Futura_Std_Book_11">Vin</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: ESP32 pins labeled IO*xx* are (3.3 V) digital input and output pins. When addressing
    these pins in your Arduino sketches, don’t include the IO, just use the number.
    I’ll demonstrate that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Port manipulation doesn’t work with the ESP32 board. Pins may also have other
    functions beyond those shown in the table, but for the purposes of the projects
    in this chapter, you’ll use only the functions shown in the table.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE for the
    ESP32</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arduino IDE doesn’t come with the ESP32 boards preinstalled, so you’ll need
    to install the required files. With your ESP32 on hand, open the Arduino IDE and
    select **File** ![](../images/arr.png) **Preferences**. When the Preferences dialog
    appears, click the small button next to the Additional Boards Manager URLs field,
    and the Additional Boards Manager URLs dialog should appear, as shown in [Figure
    19-4](chapter19.xhtml#fig19-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF ADDING THE BOARD PROFILES IN ARDUINO IDE](../images/fig19-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: The Arduino IDE
    Additional Boards Manager URLs dialog</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following URL into the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you already have other URLs in the dialog, place a comma at the end of the
    last URL and paste the new one after the comma.
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** to close the Preferences dialog. Now close and reopen the IDE.
    If your computer is not connected to the internet, connect it now. Select **Tools**
    ![](../images/arr.png) **Boards Manager**. When the Boards Manager opens, enter
    **ESP32** in the search dialog. The ESP32 package should appear. Always use the
    latest version available.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Install** and wait a few moments for the process to complete, as shown
    in the progress bar at the bottom of the Boards Manager dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Since the ESP32 uses the CH340 USB-to-serial interface, which differs from that
    used on an Arduino Uno or compatible board, you’ll need to install drivers for
    the interface for your computer. To do this, follow the guide provided by SparkFun
    at [*https://<wbr>learn<wbr>.sparkfun<wbr>.com<wbr>/tutorials<wbr>/how<wbr>-to<wbr>-install<wbr>-ch340<wbr>-drivers<wbr>/all*](https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all).
    Once you’ve installed the driver, connect your ESP32 dev board to the PC via a
    USB cable.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have the latest version of Python on your PC, you’ll also
    need to download and install it, since the Arduino IDE requires it as part of
    the toolchain to upload code to an ESP32 board. If necessary, visit [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)
    and follow the links for your operating system and install.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Python, macOS users may need to open the terminal and run
    the following command before re-opening the Arduino IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now open the Arduino IDE, select **Tools**, and change all the settings from
    Board onward to match those shown in [Figure 19-5](chapter19.xhtml#fig19-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE ESP32 SETTINGS MENU IN IDE](../images/fig19-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Board settings
    in Arduino IDE for the ESP32</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The only parameter that may vary on your computer is the USB port; select the
    appropriate port shown in that option.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the ESP32</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to the first project of the chapter, test the dev board to
    check you can upload a sketch, operate GPIO pins, and operate your Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The GPIO Pins</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, try controlling some GPIO pins by building the classic test circuit
    that blinks some LEDs. You will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 560 Ω, 0.25 W, 1 percent resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 19-6](chapter19.xhtml#fig19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR TESTING LISTING 19-1](../images/fig19-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A basic four-LED
    circuit for testing purposes.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now enter and upload [Listing 19-1](#LiT-19-1) to your ESP32 dev board. A moment
    after uploading the sketch, each LED should turn on and off in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: Testing outputs
    from the ESP32 dev board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although the hardware descriptions for the GPIO pins are IO*xx*, as shown in
    [Table 19-1](chapter19.xhtml#tab19-1), the sketch references the pins by just
    their numerical part identifiers when setting up the GPIO pin status ❶ and addressing
    them to turn on and off ❷ ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If your sketch didn’t upload, check the settings for the board type and parameters
    as described in the previous section. Once you’ve finished this test, keep the
    circuit assembled, as you’ll use it for the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Wi-Fi Connectivity</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll now test the ESP32’s Wi-Fi connectivity, using the WiFiScan sketch included
    with the ESP32 board profile that scans for the existence of Wi-Fi networks in
    your immediate vicinity.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t need any extra hardware beyond the board, the USB cable, and a Wi-Fi
    network. Upload the sketch from the IDE’s examples via **File** ![](../images/arr.png)
    **Examples** ![](../images/arr.png) **WiFi** ![](../images/arr.png) **WiFiScan**,
    then open the Serial Monitor in the Arduino IDE. After a few moments, the board
    should search for the existence of Wi-Fi access points and list them, along with
    their signal strength, as shown in [Figure 19-7](chapter19.xhtml#fig19-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE OUTPUT PRODUCED WHEN SCANNING FOR NEW WI-FI NETWORKS](../images/fig19-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: Example results
    of scanning for Wi-Fi access points</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Serial Monitor simply shows the access point names, not whether the connection
    is open. If you’d like more information on the meaning of the signal strength,
    visit [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Received<wbr>_signal<wbr>_strength<wbr>_indication*](https://en.wikipedia.org/wiki/Received_signal_strength_indication).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Port Forwarding</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To control your project from a device that isn’t connected to your local network,
    such as a tablet or phone using a cellular connection that doesn’t have a static
    IP address, you’ll need to use a technique called *port forwarding* in your network
    router or modem. Port forwarding gives you a static IP address from an external
    provider that then diverts data directly to your device.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding services are provided by organizations such as No-IP ([*https://<wbr>www<wbr>.noip<wbr>.com*](https://www.noip.com))
    and Dyn ([*https://<wbr>account<wbr>.dyn<wbr>.com*](https://account.dyn.com)).
    Setup is often unique to the make and model of your router, so do an internet
    search for *router port forwarding* for your model of router. Alternatively, you
    could ask your ISP, if it provided the router, or visit a tutorial site such as
    [*http://<wbr>www<wbr>.wikihow<wbr>.com<wbr>/Port<wbr>-Forward*](http://www.wikihow.com/Port-Forward)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve set up port forwarding or otherwise confirmed your static IP address,
    you’re ready to start building a framework for remote-control applications. However,
    if you can’t organize port forwarding, you can still control your projects from
    your local-area Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #55: Remote-Controlling a
    Single GPIO Pin</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll remotely control a GPIO pin on your ESP32 dev board
    via any device with a web browser. This includes building a simple web page hosted
    by the ESP32 using HTML and CSS. You can then use this page to control anything
    you normally would control with an Arduino 3.3 V (or 5 V with a level converter)
    digital output, such as a relay, MOSFET, LED, or so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the hardware, use the circuit for testing the GPIO pins described in the
    previous section. Enter and upload the Project #55 sketch to your ESP32 dev board.
    Don’t forget to update your Wi-Fi network credentials in the sketch before uploading.
    A moment after that, open the Serial Monitor in the Arduino IDE to watch the ESP32’s
    progress as it connects to the Wi-Fi network. The sketch should then display your
    project’s IP address, as shown in [Figure 19-8](chapter19.xhtml#fig19-8).'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE OUTPUT FROM THE ESP32 ONCE CONNECTED TO A WI-FI NETWORK](../images/fig19-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The Serial Monitor
    showing that the ESP32 has connected to the Wi-Fi network</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, using the web browser on a web-enabled device, visit the IP address shown
    in the Serial Monitor. You should see the simple web page hosted by the ESP32
    dev board, as shown in [Figure 19-9](chapter19.xhtml#fig19-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![<<AN IMAGE OF THE WEB PAGE INTERFACE FOR PROJECT #55](../images/fig19-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: A remote-control
    web page</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the On or Off buttons, the LED connected to GPIO 16 should turn
    on and off. For this project, the ESP32 dev board has two jobs: to act as a web
    server that hosts the simple web page for the user interface (including the On/Off
    buttons) and to respond to HTML requests from the web browser (to turn the GPIO
    pin on and off).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, the sketch includes the Arduino Wi-Fi library ❶ and creates an instance
    of a server with a port of 80\. Following this, it stores the SSID (Wi-Fi access
    point name) and password in the respective fields. It declares a string variable
    to contain the text of the HTTP request from the client (the web browser displaying
    the project’s web page) and then sets the GPIO pin it will control.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then declares variables to take care of the connection time allowed
    for each client to the server (the ESP32 dev board) ❷. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, it configures the Serial Monitor and then sets GPIO16 as an output
    and to LOW. The ESP32 attempts to connect to the Wi-Fi network using the credentials
    entered earlier, with the code looping and displaying a tilde (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    every half second until the network connection is successful. Once the ESP32 has
    made a Wi-Fi connection, the sketch displays the IP address in the Serial Monitor
    and the project begins to operate as a web server, thanks to <samp class="SANS_TheSansMonoCd_W5Regular_11">server.begin()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The ESP32 now runs the code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> until a reset or removal of power. Each loop begins by checking
    to see if a client (a person using a web browser) is trying to connect to the
    project ❸. If so, the code takes note of the point in time at which the connection
    starts using the <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    function to allow each individual client to connect to the ESP32 for only up to
    two seconds (as set with <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp>).
    This is because other users may want access as well—you don’t want one person
    hogging access to the project. The code also empties the string variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">currentLine</samp>, awaiting text from
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: If the client has been connected for less than 2,000 milliseconds and has made
    a request, the ESP32 receives it. The code feeds the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentTime</samp>
    variable with the latest value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>.
    The string request receives the client request ❹, one character at a time. This
    request is displayed on the Serial Monitor so that, if you’re curious, you can
    see the information the client sends out (browser type, device operating system,
    and so on). Once the client has finished sending the request, as denoted by a
    newline character (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), the
    ESP32 sends a response in HTML back to the client browser. To do so, it uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions, which
    send the text out via the Wi-Fi connection in the same way you may use <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>
    in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: The ESP32 can finally act on the client request and take an action. Client requests
    are received in the form <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>, so the string
    request is searched in turn for an on command ❺ and acted upon by sending this
    to the Serial Monitor and then turning GPIO16 on; if an off command is received,
    the opposite occurs ❻. This is the point where you can modify the actions to suit
    your own purposes. This project simply calls a <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    function, and you can replace this with your own function to have the ESP32 take
    an action of your own choosing.
  prefs: []
  type: TYPE_NORMAL
- en: The final section of the code enables ESP32 to host the simple web page that
    is the user interface shown in [Figure 19-10](chapter19.xhtml#fig19-10). Using
    many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions,
    the code creates HTML that creates the framework for a web page, defines using
    CSS the buttons to be displayed, positions the buttons, and sends HTML to define
    the end of the web page. Once the client request is complete, the sketch flushes
    the request from the variable ❼ and closes the connection, ready for the next
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the HTML contained in the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses CSS to select the color, size, font size, and rounded edges
    of the web interface’s buttons ❶, with the heading displayed in a larger type
    ❷. It then adds the two buttons to the web page. Each button has a hyperlink to
    its respective operation attached: the first link is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    ❸, and the second is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>
    ❹. When the user clicks either of the buttons, the client request will consist
    of the IP address of the ESP32, followed by */16/on*—for example, *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you hover your mouse over the button on the web page, the link should appear
    at the bottom of the screen. For example, [Figure 19-10](chapter19.xhtml#fig19-10)
    shows what happens when the mouse hovers over the On button. (The URL in the browser
    tab at the top is for the last page I visited, the result of clicking the Off
    button.)
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE HYPERLINK DISPLAYED IN THE WEB BROWSER](../images/fig19-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: Example hyperlink
    displayed in the browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When installing a project on a more permanent basis, the end user can also bookmark
    the full URL for each function. For example, if the IP address returned by the
    project is 192.168.20.28, the bookmark to turn on would be *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*.
  prefs: []
  type: TYPE_NORMAL
- en: Be warned that anyone who has the URL address for this type of project can operate
    the controls. For increased security, you might create a secure website or portal
    that password-protects access to the control buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #56: Remote-Controlling Four
    GPIO Pins</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project builds on the previous project by allowing you to remotely control
    four GPIO pins, displaying their status on the web page hosted by the ESP32\.
    Users can then quickly review the status of the devices under control, which is
    ideal for truly remote-controlled projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the same demonstration circuit described in “The GPIO Pins” on page
    326 (this is why it includes four LEDs). Once you’ve set up that circuit, enter
    and upload the Project #56 sketch to your ESP32 dev board. A moment after that,
    open the Serial Monitor in the Arduino IDE to watch as the ESP32 connects to the
    Wi-Fi network.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the ESP32 connects, the IP address of the project should appear in the
    Serial Monitor. Enter that IP address into a web browser and the interface for
    this project should appear, as shown in [Figure 19-11](chapter19.xhtml#fig19-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56>, SHOWING ALL FOUR
    OUTPUTS ARE OFF](../images/fig19-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: The user interface
    for Project #56</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to control all four LEDs by clicking their respective buttons.
    After each button click, the web page should also indicate the state of the linked
    LED. For example, [Figure 19-12](chapter19.xhtml#fig19-12) shows that outputs
    2 and 4 are on.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56, SHOWING OUTPUTS 1
    AND 3 ARE OFF AND 2 AND 4 ARE ON](../images/fig19-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-12: Outputs 2 and
    4 are on, while 1 and 3 are off.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine how much more useful this is to have four sets of buttons, enabling
    control of more relays, outputs, devices controlled by MOSFETs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The framework for this project is the same as that of the previous project,
    except that it controls four GPIOs and eight buttons while keeping track of the
    GPIO status. The sketch uses four string variables to store the status of the
    four GPIO pins in text form, On or Off, declaring them with a default value of
    Off ❶. To save confusion, the sketch also declares variables to give each GPIO
    pin a name instead of a number in the code ❷. It then sets the pins as outputs
    and to LOW ❸.
  prefs: []
  type: TYPE_NORMAL
- en: As there are now eight buttons and eight matching actions (on and off for each
    of the four GPIOs), there are eight client requests to look out for ❹. After each
    action has taken place, the status of the matching GPIO is updated in its matching
    state variable ❺. This occurs for all eight client request types.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the code uses many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>
    functions to create the HTML for the user interface. Functions like the one at
    ❻ in the project code generate the HTML required to display the status of each
    GPIO pin. The sketch also attaches a hyperlink to each button (using <samp class="SANS_TheSansMonoCd_W5Regular_11"><a
    href=</samp>) such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    to turn GPIO 16 on, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full HTML code contained in the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to experiment with the buttons—changing their size, shape, the
    URLs attached to them, and so on—to help you master the process of building an
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this project’s circuit assembled. You’ll use it in the next section to
    learn about using pulse-width modulation on the ESP32 dev board.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pulse-Width Modulation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with the usual Arduino and compatible boards, the ESP32 dev board
    offers pulse-width modulation (PWM) with all the GPIO pins on the ESP32 dev board.
    PWM allows you to control the perceived brightness of an LED, instead of simply
    switching it on and off. The LED’s brightness is determined by the duty cycle,
    or the length of time the GPIO pin is on (so the LED is lit) versus the length
    of time it is off (the LED is unlit).
  prefs: []
  type: TYPE_NORMAL
- en: Duty cycle is expressed as the percentage of time the pin is on in each *cycle*,
    the fixed period of time in which the pin can be on or off. The greater the duty
    cycle, the greater the perceived brightness of the LED connected to the pin. Furthermore,
    the higher the frequency of the PWM signal—that is, the faster the signal is turned
    on and off—the smoother the visual effect. If you’re controlling a motor, a higher
    PWM frequency makes the rotational speed a closer approximation of the actual
    speed required.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-13](chapter19.xhtml#fig19-13) shows four possible PWM duty cycles.
    The filled-in gray areas represent the amount of time that the LED is on; as you
    can see, this increases with the duty cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A DIAGRAM EXPLAINING THE PWM DUTY CYCLE WIDTHS](../images/fig19-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-13: Various PWM duty
    cycles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The ESP32 module has 16 PWM channels (numbered 0 to 15). You can direct each
    channel to a GPIO pin. To do so, you must add two lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> for each pin you want to use. The first line is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to use (0 through 15), <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>
    is the PWM frequency, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>
    is the detail for the duty cycle. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>,
    I suggest 5,000 for 5 kHz. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>,
    use 8 for 8-bit resolution, giving you a value of between 0 and 255 for the duty
    cycle (the same way you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">analogWrite()</samp>
    when using an Arduino or compatible board).
  prefs: []
  type: TYPE_NORMAL
- en: The second line required is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is
    the number of the GPIO pin to use, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to use, as defined in the previous line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to activate PWM on the GPIO, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to control, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dutyCycle</samp>
    is, of course, the duty cycle.
  prefs: []
  type: TYPE_NORMAL
- en: To stop using PWM on a particular GPIO pin and instead use it as a digital input
    or output, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is
    the number of the GPIO pin (not the PWM channel).
  prefs: []
  type: TYPE_NORMAL
- en: You can test PWM and experiment with these parameters with the following sketch,
    which uses the same four-LED circuit you’ve used throughout this chapter. A moment
    after you enter and upload [Listing 19-2](#LiT-19-2), all four LEDs should use
    PWM to exhibit a “breathing” effect by using increasing and then decreasing values
    for the duty cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: Testing PWM outputs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch demonstrates the three relevant lines for using PWM, setting up
    the required PWM channels ❶, and then attaching those channels to GPIO pins ❷.
    This allows the duty cycles to be set for each of the pins at an increasing ❸
    and decreasing ❹ level.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put this technique to use in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #57: Building a Hosted Web
    Page for a User Interface</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project synthesizes everything you’ve learned in this chapter: using an
    ESP32 dev board to control a GPIO via Wi-Fi, using PWM for various output levels,
    and building a hosted web page for a user interface. You can use this as a framework
    to build projects that require PWM control, such as LED lighting effects, controlling
    DC motors via MOSFETs, or experimenting with sound effects from a distance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project uses the same circuit as in previous projects, with only one LED
    connected to GPIO16 being controlled. Once the circuit is ready and the ESP32
    dev board has been connected to the PC, upload the Project #57 sketch. A moment
    after that, determine the project’s IP address as usual with the Serial Monitor
    and then enter that address into your web browser. The browser should display
    the project interface, as shown in [Figure 19-14](chapter19.xhtml#fig19-14).'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #57](../images/fig19-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-14: The user interface
    for Project #57</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to turn the LED on and off with the appropriate buttons as
    usual. This time, though, you can also decrease or increase the duty cycle one
    step at a time with the DC− and DC+ buttons. You can click the second row of four
    additional buttons to give the duty cycle a preset value, and the line of text
    beneath them shows the current duty cycle value. For example, [Figure 19-14](chapter19.xhtml#fig19-14)
    shows the LED as off (as the duty cycle is 0), while in [Figure 19-15](chapter19.xhtml#fig19-15),
    the LED is on with a duty cycle of 72/255.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE WITH THE DUTY CYCLE SET TO 72/255](../images/fig19-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-15: The user interface
    with the duty cycle set to 72/255</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The operation of this project is similar to that of the previous projects, but
    with more buttons and a different type of status display.
  prefs: []
  type: TYPE_NORMAL
- en: When the user changes the duty cycle of the PWM output, that value is stored
    in an integer variable ❶. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>
    function is called when the user clicks the Off button. Since you can’t set PWM
    to 0 duty cycle to turn off the GPIO output, this function detaches the PWM channel
    from the GPIO pin and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    to turn off the GPIO pin. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>
    function does the opposite; since you can’t set the PWM to full-on, this function
    detaches the PWM channel and then turns the GPIO pin on using <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch uses the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PWM(int
    dc)</samp> function to activate PWM, attach a PWM channel to the GPIO pin, and
    set the required duty cycle, passed in via the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">dc</samp>.
    When you first start the project or reset it, the sketch turns the GPIO pin off
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sketch reviews client requests. If the user presses the Off button
    to turn off the GPIO pin off, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>
    function ❸ and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>
    variable to 0 for display purposes on the interface. If the user presses the DC
    button ❹, the duty cycle decreases by 1\. If this would cause the duty cycle to
    fall below 1, the GPIO is switched off instead using <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>.
    Likewise, if the user presses the DC+ button ❺, the duty cycle increases by 1\.
    If this would push the cycle beyond 254, the sketch instead turns on GPIO using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>. Pressing the On
    button ❻ calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>
    function and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>
    variable to 255 for display purposes on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The four final buttons ❼ set the duty cycle to preset levels. They’re just examples
    to give you an idea of what is possible. Each request simply sets the PWM value
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">pinPWM()</samp> and then updates
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp> variable accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter demonstrated how to remotely control your ESP32 dev board over
    the internet via web pages designed to your specifications. Rather than controlling
    operations, you can also simply display data generated via the ESP32 on a web
    page for remote viewing, such as data from a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll continue to use your ESP32 in the following chapters. In the next, you’ll
    learn to control it by interacting with social media.
  prefs: []
  type: TYPE_NORMAL
