<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 3: Securing Networks with Graph Theory</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_27" title="27"/>3</span><br/>
<span class="ChapterTitle">Securing Networks with Graph Theory</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Graph theory is a powerful but often overlooked tool in a security analyst’s arsenal. A <em>graph</em> is a mathematical structure that shows relationships (called <em>edges</em> or <em>connections</em>) between things (called <em>nodes</em> or <em>vertices</em>), and graph theory provides a suite of algorithms for analyzing the structure and importance of these different, often interlinked, relationships. As technical a topic as security is, at its core it’s about relationships: between computers and networks, users and systems, pieces of information, and so on. By modeling a computer network or social network as a graph, you can examine the composition of the relationships to determine, for example, which computers are integral to a business’s communications, or which employees are most likely to forward a spam message, and to whom. Knowing which nodes (machines or employees) pose the greatest risk allows you to intelligently distribute your security resources.</p>
<p><span epub:type="pagebreak" id="Page_28" title="28"/>This chapter starts by discussing the diverse applications of graph theory to information security, then goes over the theory itself. We’ll cover types of graphs, how to create them efficiently in Python, and some interesting measurements you can perform on them. Chapters <span class="xref" itemid="xref_target_4"><a href="c04.xhtml">4</a></span> through <span class="xref" itemid="xref_target_6"><a href="c06.xhtml">6</a></span> then walk you through applying what you’ve learned here to analyze computer and social networks, the two types of network you’ll face most often as a security engineer. We’ll answer questions like which computers in a network received the most data, which members in a group are most influential, and how quickly information is likely to spread through a social network.</p>
<h2 id="h1-502567c03-0001">Graph Theory for Security Applications</h2>
<p class="BodyFirst">Before we discuss how we can apply graph theory in practice, let’s take a look at a simple travel graph example in <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03001.png"/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: A travel graph</p></figcaption>
</figure>
<p>As mentioned previously, a graph is defined by nodes and edges. In this example, the nodes (the circles) represent airports in major cities, and the edges (the arrows) represent the cost of a plane ticket between two cities. A graph like this could save you money as you plan a trip. For example, if you wanted to travel from Seattle to New York, you could fly from SEA to LAX, then to MIA, and finally to JFK for a total cost of $396.00. You could also fly from SEA to ORD and then to JFK for $198.00, or directly from SEA to JFK for $250.00. </p>
<p><span epub:type="pagebreak" id="Page_29" title="29"/>I don’t know about you, but when I fly I don’t think just about the cost; I also consider the travel time. In addition to the cost of each potential trip, you can also use this graph to determine the smallest number of stops between any two cities. Fewer stops means shorter trips. As you can see, even a simple graph can contain a lot of information. </p>
<p>When analyzing a computer network, the first step for both attackers and defenders is to get “the lay of the land.” That means they can’t start to attack or defend anything until they’ve built a graph of what’s available around them. One way to create such a graph is to define computers as nodes and the network connections as edges; this is typical of most network maps. In one of the upcoming projects, we’ll model a computer network from a raw packet capture. In this definition, the nodes will be the individual computers, and the edges will indicate when one machine sends packets to another. </p>
<p>Similarly, analyzing a social network can reveal key people and relationships, like the employees who will forward spam messages, or important members of a criminal organization. You can use that information to target or protect members of the network (depending on your job). For example, the FBI uses undercover agents to get information on organized crime families, then builds a social network graph, determines the key figures, and attempts to arrest them. Now, with the prevalence of social media, any amateur sleuth with a laptop can build an alarmingly accurate graph of an organization’s (or individual’s) social network and use that information to target key members for their own means.</p>
<p>Researchers also apply graph theory, using it to map technologies like cellular networks and cloud computing. For example, scholars have presented ways to apply shortest-path algorithms (similar to limiting the number of airport stops in <a href="#figure3-1">Figure 3-1</a>) to pick secure routes through graphs representing 5G cellular networks. The research analyzes how messages travel from point to point in the physical layer (OSI model) of the network.<sup class="endnote"><a href="b01.xhtml#c03-endnote-001" id="c03-noteref-001">1</a></sup> We’ll use a similar analytical model in <span class="xref" itemid="xref_target_Chapter 4"><a href="c04.xhtml">Chapter 4</a></span> when we graph a computer network from packet data. Other modern research has focused on graphing the logical relationship of components hosted in the cloud. By mapping code usage and typical hypervisor loading activities, scientists have presented a formal way to describe cloud security concerns for virtualization platforms.<sup class="endnote"><a href="b01.xhtml#c03-endnote-002" id="c03-noteref-002">2</a></sup></p>
<p>Graph theory is also applied to <em>open source intelligence (OSINT)</em>, which, in short, collates publicly available information to gain intelligence about a target. An application named Maltego crawls the public web for related terms, email addresses, places, machines, and other details, and creates a graph of where they appear online, like in <a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a>. In 2017 at DEF CON, the annual information security convention, Andrew Hay gave an excellent introductory presentation on applied graph theory for OSINT.</p>
<span epub:type="pagebreak" id="Page_30" title="30"/><figure>
<img alt="" class="keyline" src="image_fi/502567c03/f03002.png"/>
<figcaption><p><a id="figure3-2">Figure 3-2</a>: An intelligence-gathering application of graph theory</p></figcaption>
</figure>
<p>Applications like Maltego blend these logically different types of networks together in one graph, leading to very interesting insights. In one example, my team was able to locate a covert communication channel between two users of different forums. Although the forums were run by different companies, they resided on a shared hosting server. User A joined site X while user B joined site Y. Then, by manipulating the forum software, the two users were able to use local file reads and writes to pass messages on the underlying server. Had my team examined only the social network connections, we would have been stumped, but when we combined information about the social networks and the underlying machine networks, we realized that both accounts could access the same hardware. Of course, you don’t need to rely on other people’s tools; once you know the inner workings, you can produce your own OSINT-gathering tools, complete with pretty, yet functional, graph displays.</p>
<p>Graphs can also be used to describe how you can go from one condition to another by taking some action. For example, you can go from somewhat secure to completely unsecured by removing the locks from your doors. In this definition, secured and unsecured are called <em>states</em>, and removing the locks is the <em>action</em> that changes you from one state to another, known as a <em>transition</em>. <a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a> shows such a graph, known as a <em>state machine graph</em>, that describes the potential for an attacker to move through an environment. <span class="xref" itemid="xref_target_Chapter 6"><a href="c06.xhtml">Chapter 6</a></span> will cover state machines in detail.</p>
<p>You interpret the graph like so: if you’re on the internet, and you want to take over an employee’s system at your target organization, you can try phishing their customer service team. When you get a willing employee, you send them a remote-controlled malicious payload. You would then be on the employee system, but you might still need to perform some form of privilege escalation to completely take over the system. You can also see that this is just one path you could follow to achieve your objective. </p>
<span epub:type="pagebreak" id="Page_31" title="31"/><figure>
<img alt="" class="" src="image_fi/502567c03/f03003.png"/>
<figcaption><p><a id="figure3-3">Figure 3-3</a>: A state machine graph</p></figcaption>
</figure>
<p>Now that you have an idea of what to do with graph theory, let’s discuss the math behind it.</p>
<h2 id="h1-502567c03-0002">Introduction to Graph Theory</h2>
<p class="BodyFirst">A graph<em> G </em>comprises the set of nodes <em>V</em> and the set of edges <em>E</em>. Information travels between nodes along a set of nonrepeating edges that connect them, called a <em>path</em>. A node may forward information to any node it’s directly connected to by an edge; the receiving node is the <em>neighbor </em>of the sending node. By convention I’ll denote an edge as a tuple (<em>u</em>, <em>v</em>) containing an origin node <em>u</em> and a terminal node <em>v</em>, where both <em>u</em> and <em>v</em> are in <em>V</em> and are unique (not equivalent). We can write this in set notation as follows:</p>
<p class="MathEquation"><span class="math" title="E ⊆ left (u , v right ) ∈ {V} ^ {2} ∧ u ≠ v"><span class="mi">E</span> ⊆ <span class="mo">(</span> <span class="mi">u, v</span> <span class="mo">)</span> <span class="mi">∈</span> <span class="mi">V</span><span class="msup"> <span class="mn">2</span></span><span class="mi"> ∧ u ≠ v</span></span></p>
<p>Sometimes an edge in a graph points back to the same node (breaking my <em>u</em> ≠ <em>v</em> assumption); this is known as <em>self-looping</em>. For example, if you create a graph of function calls in a program that contains a recursive function, there will be an edge that leaves the recursive function and points directly back to it. Self-loops don’t show up too often, but when they do they complicate the analysis and require specialized algorithms, so I recommend leaving them alone until you’re very comfortable with the basics of graph theory.</p>
<p>Depending on the type of graph, edges may be bidirectional (<em>undirected graphs</em>) or directional (<em>directed graphs</em>). If the direction of communication is important to the question at hand, use a directed graph. Otherwise, use <span epub:type="pagebreak" id="Page_32" title="32"/>an undirected graph. In practical implementation, undirected graphs are usually faster to work with since you assume (<em>u</em>, <em>v</em>) = (<em>v</em>, <em>u</em>). A lot of problem descriptions require directed edges, though. In the travel graph from <a href="#figure3-1">Figure 3-1</a>, flying from LAX to MIA has a different cost than flying from MIA to LAX, so we need to use directed edges between those two nodes to capture the directional information.</p>
<p>An edge may contain <em>edge attributes</em>, additional pieces of information beyond the two nodes it connects. Nodes may also contain additional information called <em>node attributes</em>. When one of these attributes is used in ranking a node or edge, it’s referred to as the node’s or edge’s <em>weight</em>, and a graph with weights is called a <em>weighted graph</em>. In some cases you may even need to add more than one edge connecting two nodes (called <em>edge multiplicity</em>) to account for different edge attributes or weights. I’ll cover edge multiplicity in its own section later in the chapter, but for now we can extend the travel graph from <a href="#figure3-1">Figure 3-1</a> for a simple example. Suppose we find out there are multiple flights leaving SEA for LAX. We may choose to add an edge for each additional flight, along with its cost as the weight. Adding these edges for all city pairs would give us a sense of which airports had the most travel options for our trip. We’ll use multiple edges, edge attributes, and weighted graphs to inform our investigations in meaningful ways in the following chapters.</p>
<p><em>Simple graphs</em> are unweighted, undirected graphs containing no self-looping or edge multiplicity. <em>Nonsimple</em> graphs (or, less commonly, <em>pseudographs</em>), those that do contain self-loops or multiple edges, comprise the vast majority of interesting graphs you’ll encounter in practice.</p>
<p>A <em>cycle</em> of a graph <em>G</em> is a nonempty subset of <em>E</em> that forms a path such that the first node of the path corresponds to the last, and no other node is repeated along the path. This is a fancy way of saying a path that forms a closed loop. A self-loop is a special case of a graph cycle with a strict path length of 1. A <em>cyclic graph</em> is one that contains at least one graph cycle. A graph that is not cyclic (has no loops) is <em>acyclic</em>.</p>
<p>Before we go any further into the theory, let’s walk through how to build one of these graph objects programmatically. In the next section we’ll go over the current de facto standard library for Python graphs, NetworkX. Having access to the tools in this library will help you construct the examples in this book and play around with the theory at your own pace. The documentation for NetworkX also serves as a great reference to the theory that underlies each function.</p>
<h2 id="h1-502567c03-0003">Creating Graphs in NetworkX</h2>
<p class="BodyFirst">You can use NetworkX (which contains implementations of most graph algorithms) and Pyplot (a part of the Matplotlib library) to generate and display an undirected graph. <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a> creates a graph with seven nodes and six weighted edges, then displays it.</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> <span epub:type="pagebreak" id="Page_33" title="33"/>import networkx as nx
from matplotlib import pyplot as plt

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> G = nx.Graph()  # Create the default Graph object
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> G.add_node('f') # Adds a node manually
G.add_node('g') # Adds another node manually
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> G.add_edge('a', 'b', weight=0.6) # Will add missing nodes
G.add_edge('a', 'c', weight=0.2) # and connecting edges
G.add_edge('c', 'd', weight=0.1) # Weight is one type of edge attribute
G.add_edge('c', 'e', weight=0.7)
G.add_edge('g', 'c', weight=0.8) 
G.add_edge('f', 'a', weight=0.5) 
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> pos = nx.layout.spring_layout(G, seed=42) # Try to optimize layout 
nx.draw(G, pos, with_labels=True, font_color='w')
plt.show()</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: Creating a basic weighted undirected graph</p>
<p>First, we import the two libraries required to build and display the graph <span aria-label="annotation1" class="CodeAnnotation">❶</span>. (Aliasing NetworkX as <code>nx</code> and Pyplot as <code>plt</code> is a common convention in examples online.) Then, we create a basic undirected graph with the NetworkX <code>Graph</code> constructor <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Defining a graph in this way returns an empty graph (with no nodes or edges). </p>
<p>To manually define the graph’s structure, or <em>topography</em>, we can add either nodes or edges. To add a node to the graph, we use the <code>graph.add_node</code> function <span aria-label="annotation3" class="CodeAnnotation">❸</span> with an argument to use as an identifier (ID) for the node (during lookups, for example). In this case, the ID is the string literal <code>f</code>, but an ID can be any object that could act as a key to a Python dictionary (tuples, for instance). The <code>graph.add_edge</code> function, which takes two nodes and optional edge attributes as arguments, adds edges directly to the graph <span aria-label="annotation4" class="CodeAnnotation">❹</span>. If either <code>a</code> or <code>b</code> (or both, as in this case) doesn’t exist in the graph, NetworkX will helpfully add the missing node(s) before adding the edge. With directed graphs, the order in which you pass the nodes to <code>graph.add_edge</code> specifies the edge’s direction: the edge starts at the first node and concludes at the second.</p>
<p>The real strength of graphs lies in their visual interpretations, as humans very often can detect patterns in information visually that they wouldn’t have found otherwise. NetworkX supports several options for displaying graph information, including Matplotlib and Graphviz. For this example, we lay out the graph with one of NetworkX’s built-in layout functions, <code>nx.layout.spring_layout</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>, which uses a physics model of spring motion to position the nodes. The nodes’ initial positions are randomly generated, but you can pass in the <code>seed</code> argument to make the image reproducible, which can be important if you want to share the conclusions from your research with others. The resulting node positions are stored in the dictionary <code>pos</code>, with structure <code>{node ID: (</code><var>x-coordinate</var><code>, </code><var>y-coordinate</var><code>)}</code>. The function <code>nx.draw</code> creates a plot object using these node positions, and Matplotlib displays the resulting figure. The additional parameters <span epub:type="pagebreak" id="Page_34" title="34"/>to <code>nx.draw</code>, <code>labels</code> and <code>font_color</code>, control the look of the graph, shown in <a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03004.png"/>
<figcaption><p><a id="figure3-4">Figure 3-4</a>: An undirected graph</p></figcaption>
</figure>
<p>If you remove the <code>seed</code> parameter and rerun the code your graph may look different, but it’s guaranteed to be mathematically equivalent to the one in <a href="#figure3-4">Figure 3-4</a>. </p>
<p>Now that we have a way to codify and visualize graphs, let’s look at some interesting measurements you can use in your analysis.</p>
<h2 id="h1-502567c03-0004">Discovering Relationships in Data</h2>
<p class="BodyFirst">In this section, we’ll examine a few of the most-used graph properties that can give us insight into the underlying relationships in our data. These properties are expressed as statistical relationships, such as the ratio of the number of possible paths between two nodes to the total number of paths in the graph. Typically we’re interested in learning things like which nodes are isolated from other nodes, what are the shortest or longest possible paths between nodes, and how many different nodes can be reached from a particular starting node. There are dozens of possible graph properties to explore, but some are suitable only for certain types of graphs, while others are specialized use cases of these more general properties. The ones described here will give you everything you need to understand the projects in the next three chapters, but it’s by no means a complete list.</p>
<h3 id="h2-502567c03-0001"><span epub:type="pagebreak" id="Page_35" title="35"/>Measuring Node Importance</h3>
<p class="BodyFirst">A key concept in security is measuring the importance of different assets, be they human or machine, and the impact that compromising them may have on the operation of the organization as a whole. To do so, we need a way to measure which nodes are in critical positions. <em>Closeness</em> measures the connectivity of two nodes relative to the other connections in the graph. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Closeness can have many interpretations. In <span class="xref" itemid="xref_target_Chapter 11"><a href="c11.xhtml">Chapter 11</a></span> we’ll look at how to use physical closeness (the distance between two objects in a physical space) to plan incident response. By selecting security personnel who are already in the vicinity of an incident, you can drastically reduce the reaction time in a lot of cases.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>When you apply closeness across all nodes in the graph, you’re measuring some type of <em>centrality</em> (roughly, “importance”) for each node. There are several types of centrality defined for graphs. The proper one to use depends on the behavior and structure of the network you’re trying to analyze.<sup class="endnote"><a href="b01.xhtml#c03-endnote-003" id="c03-noteref-003">3</a></sup> Sometimes you won’t know in advance which measure of centrality makes the most sense for your problem. In these cases, start with simpler metrics (like closeness centrality) and move on to testing with other, more complex ones. We’ll cover two types of centrality: betweenness centrality and degree centrality.</p>
<h4 id="h3-502567c03-0001">Finding Nodes That Facilitate Connections</h4>
<p class="BodyFirst"><em>Betweenness centrality</em> considers nodes that connect other nodes together as more central to the graph. Consider a computer network like the one in <a href="#figure3-5" id="figureanchor3-5">Figure 3-5</a>, where some systems act as proxies to connect users to databases.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03005.png"/>
<figcaption><p><a id="figure3-5">Figure 3-5</a>: A simple proxy network</p></figcaption>
</figure>
<p>Betweenness centrality rates the gray proxy nodes much higher than any of the other nodes (the users and databases), since five of the seven users must connect to one of the two proxies to reach either database. The light gray circle at the top is between six paths (3 users × 2 databases = 6 paths) <span epub:type="pagebreak" id="Page_36" title="36"/>and the dark gray circle at the bottom is between four paths (2 users × 2 databases = 4 paths). The centrality is further strengthened by the fact that these five users must pass through their respective proxy to reach the databases.</p>
<p>Formally speaking, betweenness centrality of a node <em>u</em> is the sum of ratios of all shortest paths from node <em>s</em> to node <em>t</em>, which pass through node <em>u</em> (noted as σ<sub>(</sub><sub><em>s</em></sub><sub>, </sub><sub><em>t</em></sub><sub>)</sub>(<em>u</em>)), compared to the total number of shortest paths between node <em>s</em> and node <em>t</em> (noted as σ<sub>(</sub><sub><em>s</em></sub><sub>, </sub><sub><em>t</em></sub><sub>)</sub>) for all paths where <em>s</em> ≠ <em>u</em> ≠ <em>t</em>. Putting it all together looks like this:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c03/m03001.png"/></figure>

<p>The betweenness scores can be normalized to the number of nodes in <em>G</em>. The normalization function is 2 / ((<em>n</em> – 1)(<em>n</em> – 2)) for undirected graphs, and 1 / ((<em>n</em> – 1)(<em>n</em> – 2)) for directed graphs (where <em>n</em> is the number of nodes in the graph). The difference is due to the impact of directionality on the normalization. For undirected graphs, adding an edge between two nodes affects the betweenness score of both nodes and therefore carries twice as much influence as the same edge in a directed graph that impacts only one node (the source node). The normalization scores for both a directed and an undirected graph with five nodes each are calculated as follows:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c03/m03002.png"/></figure>

<p>Unlike some other measures of centrality (such as closeness centrality), normalizing betweenness centrality is optional in NetworkX, and is specified by the Boolean keyword argument <code>normalized=True</code>. <a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a> shows how we can retrieve the betweenness centrality scores for the map generated in <a href="#listing3-1">Listing 3-1</a>.</p>
<pre><code>b_scores = nx.betweenness_centrality(G, normalized=True)
nx.set_node_attributes(G, name='between', values=b_scores)
print(G.nodes["c"]["between"])</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: Betweenness centrality for the graph created in <a href="#listing3-1">Listing 3-1</a></p>
<p>The normalized result for the example graph should be approximately 0.8. There are a total of 15 shortest paths between all node pairs in <a href="#figure3-4">Figure 3-4</a> (excluding pairs with <em>c</em> as the start or end node). Of those 15, 12 paths pass through <em>c</em> at some point (12 / 15 = 0.8). The Jupyter notebook for this example shows how you can manually calculate the betweenness score by looping over the node pairs and counting the number of shortest paths that contain the target node.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The mathematical definition of betweenness centrality just shown and the algorithm used by NetworkX to compute the betweenness centrality score are both from a paper by mathematician Ulrik Brandes, which has a lot of useful information on the theory of closeness and betweenness.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_37" title="37"/>Betweenness centrality has many applications within information security and network analysis because it represents the degree to which a node facilitates communication between other nodes. For example, a node in a computer network with high betweenness centrality would have more control over the network traffic, because more packets will eventually pass through it. For this reason, betweenness centrality can also be used to identify good places to perform inspections on network traffic. Another application is understanding critical points of failure in social networks, which we’ll discuss more in <span class="xref" itemid="xref_target_Chapter 6"><a href="c06.xhtml">Chapter 6</a></span>.</p>
<h4 id="h3-502567c03-0002">Measuring the Number of Node Connections</h4>
<p class="BodyFirst">Centrality can also be measured by how many neighbors a node has; this is known as <em>degree centrality</em>. Intuitively, degree centrality favors nodes that have a larger number of connections to other nodes in the graph. (Betweenness centrality can be seen as a specific measure of degree centrality.) </p>
<p>For undirected graphs, degree centrality is calculated as the fraction of all nodes that are connected directly to a node <em>u</em>. You’ll commonly see the neighbors of a node <em>u</em> annotated as <em>Γ</em><sub>(</sub><sub><em>u</em></sub><sub>)</sub>.</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c03/m03003.png"/></figure>

<p>Remember from the math primer at the start of the book that the absolute value of a set of nodes (|<em>V</em>|, for example) is the same as the number of nodes in the set. We subtract 1 from the length of <em>V</em> to account for the fact that node <em>c</em> cannot be a neighbor of itself. Undirected degree centrality is calculated using <code>nx.degree_centrality</code>, as shown in <a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a>. The bold areas show the few changes required from <a href="#listing3-2">Listing 3-2</a>.</p>
<pre><code><b>d_scores = nx.degree_centrality(G)</b>
nx.set_node_attributes(G, name=<b>'degree'</b>, values=<b>d_scores</b>)
<b>print(G.nodes["c"]["degree"])</b></code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: Degree centrality with changes from <a href="#listing3-2">Listing 3-2</a> in bold</p>
<p>The output of this code should be approximately 0.66, meaning node <em>c</em> is neighbors with two-thirds of the total number of nodes in the graph. In <a href="#figure3-4">Figure 3-4</a> you can see that node <em>c</em> has four neighbors and, excluding <em>c</em>, there are a total of six nodes that could be neighbors of <em>c</em>. That gives us 4 / 6 = 2 / 3 = 0.66, which matches the <code>nx.degree_centrality</code> result.</p>
<p>For directed graphs, the degree centrality measure gets split in two pieces. The first deals with edges leading into a node, aptly named <em>in-degree centrality</em>. The second measure deals with edges leading out of a node, called <em>out-degree centrality</em>. The calculation for each is the same as for degree centrality, except that it considers only the subset of edges matching the specified direction. We denote these sets of edges as</p>
<p class="MathEquation"><span class="math" title="(u rightarrow ) = E sub (u ,)"><span class="mo">(</span> <span class="mi">u</span> <span class="mo">→</span> <span class="mo">)</span> <span class="mo"> = </span> <span class="msub"><span class="mi">E</span><span class="mo">(</span> <span class="MathSubscript">u,</span> <span class="mo">)</span></span></span></p>
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_38" title="38"/>for out-degree and</p>
<p class="MathEquation"><span class="math" title="(u leftarrow) = E sub ( , u)"><span class="mo">(</span> <span class="mi">u</span> <span class="mo">←</span> <span class="mo">)</span> <span class="mo"> = </span> <span class="msub"><span class="mi">E</span><span class="mo">(</span> <span class="MathSubscript">,u</span> <span class="mo">)</span></span></span></p>
<p class="BodyContinued">for in-degree. <a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a> creates a directed version of the graph from <a href="#listing3-1">Listing 3-1</a>, then calculates in-degree and out-degree centrality for each node in the graph. </p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span><b> G = nx.DiGraph() # Create the default Graph object</b>
G.add_edge('a', 'b', weight=0.6)
G.add_edge('a', 'c', weight=0.2)
G.add_edge('c', 'd', weight=0.1)
G.add_edge('c', 'e', weight=0.7)
G.add_edge('g', 'c', weight=0.8) 
G.add_edge('f', 'a', weight=0.5) 
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> i_scores = nx.in_degree_centrality(G)
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> o_scores = nx.out_degree_centrality(G)
nx.set_node_attributes(G, name='in-degree', values=i_scores)
nx.set_node_attributes(G, name='out-degree', values=o_scores)
print(G.nodes["c"]["in-degree"], G.nodes["c"]["out-degree"])</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: Creating a directed graph to measure in-degree and out-degree centrality</p>
<p>To make the graph directed, we replace the generator <code>nx.Graph</code> with <code>nx.DiGraph</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then, we use <code>nx.in_degree_centrality</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> and <code>nx.out_degree_centrality</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span> to get their respective measures. The result of the code should be 0.33 for both values. If you examine the data, you’ll see that node <em>c</em> has two incoming edges and two outgoing edges of the six total edges we defined. For each measure, then, the math works out to be 2 / 6 = 1 / 3 = 0.33. If you try running <a href="#listing3-4">Listing 3-4</a> against an undirected graph, you’ll get an error of the type <code>NetworkXError</code>, because in-degree and out-degree are specific to the <code>nx.DiGraph</code> and <code>nx.MultiDiGraph</code> objects.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Several algorithms are implemented only for directed or undirected graphs in NetworkX, so if you use a statistical measurement that isn’t supported for the type of edges in your graph, you’ll need to implement the statistic for the other graph type yourself. We’ll see an example of this in <span class="xref" itemid="xref_target_Chapter 6"><a href="c06.xhtml">Chapter 6</a></span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The family of degree metrics allows us to specify the direction of information flow while calculating the scores, whereas both the closeness and betweenness measures make assumptions about the directionality. To understand why this matters, consider analyzing network traffic related to a <em>distributed denial-of-service (DDoS)</em> attack. A DDoS attack floods a network or specific target machine with more traffic than it is capable of processing, thereby blocking legitimate users’ access. As packets travel from one system to the next, they create directed edges on the graph. A sudden increase of in-degree centrality would be seen at the target nodes, which could allow a script to automatically detect and respond to this threat. By including the direction of information flow, you can often provide more meaningful context to your graphs.</p>
<h3 id="h2-502567c03-0002"><span epub:type="pagebreak" id="Page_39" title="39"/>Analyzing Cliques to Track Associations</h3>
<p class="BodyFirst">Investigators use <em>clique analysis</em> to track the associations of different groups who aren’t kind enough to hand out membership lists. By collecting a list of who is talking to whom (and sometimes when), you can find interconnected clusters, or cliques. In theory, a clique <em>β</em> in graph <em>G</em> is any subset of <em>V</em> in which each node is adjacent to each other node in the set. Think of this as a group of friends who have all met each other, or a cluster of computers that are all connected. Some material may refer to these constructs as <em>complete subgraphs</em>. <a href="#figure3-6" id="figureanchor3-6">Figure 3-6</a> shows an undirected graph containing different cliques.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03006.png"/>
<figcaption><p><a id="figure3-6">Figure 3-6</a>: A cartoon character graph</p></figcaption>
</figure>
<p>A node may be in zero or more cliques. In the graph in <a href="#figure3-6">Figure 3-6</a>, for example, Tom is in three cliques: Tom, Spike, and Jerry; Tom, Butch, and Jerry; and Tom, Squeek, and Butch. <a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a> creates the graph from <a href="#figure3-6">Figure 3-6</a> and calculates a clique membership score for each node.</p>
<pre><code>clique_graph = nx.Graph()
clique_graph.add_edges_from(
    [
        ("Tom", "Jerry"),("Butch", "Jerry"),("Spike", "Jerry"),
        ("Spike", "Tom"),("Tom", "Squeek"),("Tom", "Butch"),
        ("Squeek", "Butch")
    ]
)
clq = nx.algorithms.number_of_cliques(clique_graph)
tot = nx.algorithms.graph_number_of_cliques(clique_graph)
for m in clq:
    print(m, (clq[m]/tot))</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Creating the cartoon clique graph in <a href="#figure3-6">Figure 3-6</a></p>
<p><span epub:type="pagebreak" id="Page_40" title="40"/>The call to <code>nx.algorithms.number_of_cliques</code> tallies the number of cliques each node belongs to, which you can use to easily find the node in the most cliques. To find the total number of cliques in the graph, we use <code>nx.graph_number_of_cliques</code>. We can then combine the number of cliques for each node and the total number of cliques to create a normalized score to determine which members of a network are key facilitators. The output from running this example code should be:</p>
<pre><code>{'Tom': 1.0, 'Jerry': 0.66, 'Butch': 0.66, 'Spike': 0.33, 'Squeek': 0.33}</code></pre>
<p>Tom is in every clique, Jerry and Butch are each in two-thirds of the possible cliques, and Spike and Squeek are only in one-third of the possible cliques. Clearly, Tom is the best-known member of this network. In social networks, like a company or an organized crime syndicate, the members in the most cliques are key to facilitating the operations. If we wanted to disrupt the activities of this organization, removing Tom would go a long way toward achieving that. You can also measure clique membership in your network to identify nodes that act as gateways between otherwise separate parts of the network. </p>
<p>The function <code>nx.algorithms.number_of_cliques</code> finds the number of <em>maximal</em> cliques to which each node belongs—that is, the largest group of nodes that are all connected to one another. In undirected graphs, any two adjacent nodes could be considered a clique, and, in any graph, cliques of four or more nodes contain cliques of three and two nodes, so working with maximal cliques takes those subcliques into account.</p>
<p>You can enumerate all the maximal cliques in a graph with the <code>nx.find_cliques</code> function, as shown in <a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a>.</p>
<pre><code>cliques = list(nx.find_cliques(clique_graph))
print(cliques)</code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: Creating a list of cliques from a directed graph</p>
<p>The result is a <code>Generator</code> object, which is a built-in object type in Python 3. You can either use it directly or cast it to a <code>list</code>. We’ll see a practical application of finding cliques using <code>nx.find_cliques</code> in <span class="xref" itemid="xref_target_Chapter 5"><a href="c05.xhtml">Chapter 5</a></span> when we build a social network graph from posts. </p>
<h3 id="h2-502567c03-0003">Determining the Connectedness of the Network</h3>
<p class="BodyFirst">Graphs can be connected or disconnected. A <em>connected</em> graph is one where every node pair (<em>u</em>, <em>v</em>) has some connecting path (<em>ρ</em>). Therefore, a graph <em>G</em> is <em>disconnected</em> if any pair of nodes (<em>u</em>, <em>v</em>) doesn’t have a connecting path (<em>ρ</em>) using any subset of edges in <em>E</em>. The only way to know whether or not a graph is connected is to check every pair of nodes to see if they’re disconnected. We can write this out neatly using set notation and Boolean algebra:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c03/m03004.png"/></figure>

<p><span epub:type="pagebreak" id="Page_41" title="41"/>A Boolean statement such as <em>ρ</em>(<em>u</em>, <em>v</em>) ⊄ <em>E </em>returns <code>1</code> if it is true and <code>0</code> otherwise, so this equation technically counts all pairs of disconnected nodes. In practical implementations, we don’t need to continue searching all remaining pairs of <em>G</em> because once we discover a missing edge, we know it’s a disconnected graph. We can only say a graph is connected, however, once we’ve checked every pair of nodes and found no disconnected pairs. You can go through this exercise yourself with the graph from <a href="#figure3-1">Figure 3-1</a> to determine if it’s a connected or disconnected map. </p>
<p><a href="#figure3-7" id="figureanchor3-7">Figure 3-7</a> shows the graph from <a href="#figure3-6">Figure 3-6</a> extended to be a disconnected graph.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03007.png"/>
<figcaption><p><a id="figure3-7">Figure 3-7</a>: A disconnected graph</p></figcaption>
</figure>
<p>A disconnected graph is made up of two or more disparate sections called <em>connected components </em>(or just <em>components</em>). Formally speaking, a connected component of an undirected graph <em>G</em> (ϕ<sub><em>i</em></sub>(<em>G</em>)) is a subgraph in which every pair of nodes (<em>u</em>, <em>v</em>) is connected by a path <em>ρ</em>(<em>u</em>, <em>v</em>) ∈ <em>E </em>(annotated <em>ρ</em>(ϕ<sub><em>i</em></sub>, <em>u</em>, <em>v</em>) for a path in the <em>i</em>th component subgraph). Additionally, none of the nodes in ϕ may be connected to any additional nodes in the superset <em>V</em>. For example, the graph shown in <a href="#figure3-7">Figure 3-7</a> has two connected components: one comprising cartoon characters, and the other comprising former bandmates. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	A clique can never extend beyond a single component, so you’ll often care which component a clique is formed in, especially when performing social network analysis.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502567c03-0004"><span epub:type="pagebreak" id="Page_42" title="42"/>Using Graph Edges to Capture Important Details</h3>
<p class="BodyFirst">The final graph property we’ll examine is one I mentioned earlier, edge multiplicity. This property is powerful once you know how to leverage the flexibility it brings to your analysis. In many practical instances, like the packet analysis project in the next chapter, there may be multiple edges between nodes that contain valuable information we want to keep for analysis. </p>
<p>For example, graphing the TCP handshake requires multiple directed edges between two nodes. The connecting machine (also called the <em>client</em>) sends a synchronization request to the target machine (a SYN packet), which creates one directed edge from <em>u</em> to <em>v </em>in the graph. The target machine then responds with an acknowledgment as well as a request of its own to synchronize (a SYN-ACK packet), which creates a directed edge from <em>v</em> back to <em>u</em>. (In an undirected graph, this response would count as a duplicate of the first edge.) Finally, the connecting machine sends the target machine its own acknowledgment packet (an ACK packet), which creates a second directed edge from <em>u</em> to <em>v </em>in the graph. <a href="#figure3-8" id="figureanchor3-8">Figure 3-8</a> shows two versions of the same graph data containing TCP handshakes between two different groups of systems.</p>
<figure>
<img alt="" class="" src="image_fi/502567c03/f03008.png"/>
<figcaption><p><a id="figure3-8">Figure 3-8</a>: Comparing single- and multi-edge graphs</p></figcaption>
</figure>
<p>On the left is a standard <code>DiGraph</code> representation, which treats repeated communications between two nodes as a single directed edge. Examining this graph alone, you couldn’t determine which nodes participated in a TCP handshake. On the right is a <code>MultiDiGraph</code> representation of the same data, which retains an edge for each occurrence of communication. Examining this graph, you can easily see that node <em>c</em> initiated a handshake-like exchange with node <em>d</em>. Node <em>a</em> also initiated a handshake with node <em>b</em>.</p>
<p>There are two schools of thought for dealing with edge multiplicity. The first school says you should summarize multiple edges based on their weight ω (and potentially other attributes) into a singular edge, like so:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c03/m03005.png"/></figure>

<p class="BodyContinued"><span epub:type="pagebreak" id="Page_43" title="43"/>If the constituent edges are unweighted, the weight is the number of edges making up the composite:</p>
<p class="MathEquation"><span class="math" title="overline ( u rightarrow v ) sub %omega = abs ( u rightarrow v ) in E"><span class="MathOverline"><span class="msub"><span class="mo">(</span> <span class="mi">u</span> <span class="mo">→</span> <span class="mi">v</span> <span class="mo">)</span> <span class="mi">ω</span></span><span class="mo"/></span> <span class="mo"> = </span> <span class="mo">|</span> <span class="mo">(</span> <span class="mi">u</span> <span class="mo">→</span> <span class="mi">v</span> <span class="mo">)</span> <span class="mo">|</span> <span class="mo">∈</span> <span class="mi">E</span></span></p>
<p class="BodyContinued">This summation must take into account the directionality of edges when dealing with directed graphs. (If you’re using complex values for edge attributes—such as ranges, which require specialized processing to summarize—you’ll be better off implementing your own definition of edge summation in a function within your code.)</p>
<p>The second school of thought is to graph each edge individually and summarize edges only when it comes time to analyze them. Doing so allows you to retain more of the underlying structure. As an example, consider timestamp information on network packets. If you sum the edges into a single edge like the preceding example, you can’t see the order in which the edges are created. Retaining each edge allows you to order their creation by timestamp and look for interesting patterns, like call and response pairs in edges. </p>
<p>There’s no generally right or wrong way to handle edge multiplicity in a graph. The correct approach is often a little of both schools of thought, as we’ll see in the next chapter.</p>
<h2 id="h1-502567c03-0005">Summary</h2>
<p class="BodyFirst">The power of graph theory lies in the flexible interpretation of nodes and edges. Do nodes represent people, computers, cities, or something else entirely? Do edges measure physical distances or intangible relationships? The answer to all these questions is yes. Be warned, though: this freedom of perception is a double-edged sword. Because there are no strict definitions of what a node or edge represents, you can create a graph whose edges and analysis have no meaningful relationship to reality. An example would be using nodes that represent computers and edges that represent the physical distance between two cities where the computers are located. We typically don’t think about how far a message travels on the internet in terms of physical distance, but rather in terms of the number of network “hops” it has to make before reaching its destination. Over the next three chapters, I’ll explain the justification for different interpretations of information in more depth, because the meaning of a result, such as closeness centrality, relies on the meaning of an edge’s weight and needs a bit of context to make sense. </p>
<p>There’s a lot more useful theory than what I’ve covered here. The book <em>Introduction to Graph Theory</em> by Richard Trudeau (Dover, 2001) is an excellent resource.<sup class="endnote"><a href="b01.xhtml#c03-endnote-004" id="c03-noteref-004">4</a></sup> If you’re looking for a more advanced discussion, check out <em>Graph Theory and Complex Networks: An Introduction</em> by Maarten van Steen (author, 2010).<sup class="endnote"><a href="b01.xhtml#c03-endnote-005" id="c03-noteref-005">5</a></sup> Both books make the topics easy to understand and the math easy to follow. For something more security focused, check out <span epub:type="pagebreak" id="Page_44" title="44"/>the paper “Applied Graph Theory to Security: A Qualitative Placement of Security Solutions within IoT networks,” published in the <em>Journal of Information Security and Applications</em> in December 2020, which uses graph theory to analyze the security of IoT network devices and determine suitable locations for monitoring device traffic.<sup class="endnote"><a href="b01.xhtml#c03-endnote-006" id="c03-noteref-006">6</a></sup></p>
<p>In the next two chapters, we’ll put these theoretical concepts to work by examining both a computer network and a human social network to learn which nodes are important to the network, what information is being exchanged, and other important insights about the underlying graph structure. The final graph theory project, in <span class="xref" itemid="xref_target_Chapter 6"><a href="c06.xhtml">Chapter 6</a></span>, will give you the tools you need to simulate changes to a network over time. Once you understand the concepts and interpretations, the insights you can gain will make graph theory one of the most powerful and versatile weapons in your analytical arsenal.</p>
</section>
</body>
</html>