["```\nclass Tree {\n  constructor(rootKey) {\n  ❶ this._key = rootKey;\n  ❷ this._children = [];\n  }\n\n  isEmpty() {\n  ❸ return this._key === undefined;\n  }\n\n❹ _throwIfEmpty() {\n    if (this.isEmpty()) {\n      throw new Error(\"Empty tree\");\n    }\n  }\n\n❺ get key() {\n    this._throwIfEmpty();\n    return this._key;\n  }\n\n❻ set key(v) {\n    this._key = v;\n  }\n\n❼ get isLeaf() {\n    this._throwIfEmpty();\n    return this.childNodes.length === 0;\n  }\n\n❽ get childNodes() {\n    this._throwIfEmpty();\n    return this._children;\n  }\n\n❾ get firstChild() {\n    return this.isLeaf ? null : this.childNodes[0];\n  }\n\n❿ get lastChild() {\n    return this.isLeaf ? null : this.childNodes[this.childNodes.length - 1];\n  }\n\n  // ...more methods...\n}\n```", "```\n❶ addChild(keyToAdd, i = this.childNodes.length) {\n❷ this._throwIfEmpty();\n❸ if (i < 0 || i > this.childNodes.length) {\n    throw new Error(\"Wrong index at add\");\n  } else {\n  ❹ const newTree = new this.constructor();\n    newTree.key = keyToAdd;\n  ❺ this._children.splice(i, 0, newTree);\n  ❻ return this;\n  }\n}\n```", "```\nappendChild(keyToAppend) {\n  return this.addChild(keyToAppend);\n}\n```", "```\nremoveChild(i) {\n❶ this._throwIfEmpty();\n❷ if (i < 0 || i >= this.childNodes.length) {\n    throw new Error(\"Wrong index at remove\");\n  } else {\n  ❸ this._children.splice(i, 1);\n  ❹ return this;\n  }\n}\n```", "```\n❶ const depthFirst = (tree, visit = (x) => console.log(x)) => {\n❷ if (!isEmpty(tree)) {\n  ❸ visit(tree.key);\n  ❹ tree.children.forEach((v) => depthFirst(v));\n  }\n};\n```", "```\n❶ breadthFirst(visit = (x) => console.log(x)) {\n❷ if (!this.isEmpty()) {\n  ❸ const q = new Queue();\n  ❹ q.push(this);\n  ❺ while (!q.isEmpty()) {\n    ❻ const t = q.pop();\n    ❼ visit(t.key);\n    ❽ t.childNodes.forEach((v) => q.push(v));\n    }\n  }\n}\n```", "```\n❶ let ORDER = undefined;\n\nconst newBTree = (order = 3) => {\n❷ if (ORDER === undefined) {\n    ORDER = order;\n  }\n  return null;\n};\n\n❸ const newNode = (\n  newKeys = [null],\n❹ newPtrs = new Array(newKeys.length + 1).fill(null)\n) => ({\n  keys: newKeys,\n  ptrs: newPtrs\n});\n\nconst isEmpty = (tree) => tree === null;\n\n❺ const _tooBig = (tree, d = 0) => tree.keys.length + d > ORDER – 1;\n\n❻ const _tooSmall = (tree, d = 0) =>\n  tree.keys.length - d < Math.ceil(ORDER / 2) – 1;\n```", "```\nconst _findIndex = (tree, key) => {\n❶ const p = tree.keys.findIndex((k) => k >= key);\n  return p === -1 ? tree.keys.length : p;\n};\n```", "```\nconst find = (tree, keyToFind) => {\n❶ if (isEmpty(tree)) {\n    return false;\n  } else {\n  ❷ const p = _findIndex(tree, keyToFind);\n  ❸ return tree.keys[p] === keyToFind || find(tree.ptrs[p], keyToFind);\n  }\n};\n```", "```\nconst inOrder = (tree, visit = (x) => console.log(x)) => {\n❶ if (!isEmpty(tree)) {\n  ❷ tree.ptrs.forEach((p, i) => {\n    ❸ inOrder(p, visit);\n    ❹ i in tree.keys && visit(tree.keys[i]);\n    });\n  }\n};\n```", "```\nconst add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n  ❶ return newNode([keyToAdd]);\n  } else {\n  ❷ _add(tree, keyToAdd);\n  ❸ if (_tooBig(tree)) {\n      const m = Math.ceil(ORDER / 2);\n    ❹ const left = newNode(tree.keys.slice(0, m - 1), tree.ptrs.slice(0, m));\n    ❺ const right = newNode(tree.keys.slice(m), tree.ptrs.slice(m));\n    ❻ tree.keys = [tree.keys[m – 1]];\n    ❼ tree.ptrs = [left, right];\n    }\n    return tree;\n  }\n};\n```", "```\nconst _add = (tree, keyToAdd) => {\n❶ const p = _findIndex(tree, keyToAdd);\n❷ if (isEmpty(tree.ptrs[p])) {\n    tree.keys.splice(p, 0, keyToAdd);\n    tree.ptrs.splice(p, 0, null);\n  } else {\n  ❸ const child = tree.ptrs[p];\n  ❹ _add(child, keyToAdd);\n\n  ❺ if (_tooBig(child)) {\n      // Child too big? Split it\n      const m = Math.ceil(ORDER / 2);\n    ❻ const newChild = newNode(child.keys.slice(m), child.ptrs.slice(m));\n\n    ❼ tree.keys.splice(p, 0, child.keys[m – 1]);\n      tree.ptrs.splice(p + 1, 0, newChild);\n\n    ❽ child.keys.length = m – 1;\n      child.ptrs.length = m;\n    }\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n❶ tree = _remove(tree, keyToRemove);\n❷ return (isEmpty(tree) || tree.keys.length === 0) && !isEmpty(tree.ptrs[0])\n    ? tree.ptrs[0]\n    : tree;\n};\n```", "```\nconst _remove = (tree, keyToRemove) => {\n❶ if (!isEmpty(tree)) {\n ❷ const p = _findIndex(tree, keyToRemove);\n    if (tree.keys[p] === keyToRemove) {\n    ❸ if (isEmpty(tree.ptrs[p])) {\n      ❹ tree.keys.splice(p, 1);\n        tree.ptrs.splice(p, 1);\n      } else {\n      ❺ const nextKey = _findMin(tree.ptrs[p + 1]);\n      ❻ tree.keys[p] = nextKey;\n      ❼ _remove(tree.ptrs[p + 1], nextKey);\n      ❽ _fixChildIfSmall(tree, p + 1);\n      }\n    } else {\n    ❾ _remove(tree.ptrs[p], keyToRemove);\n    ❿ _fixChildIfSmall(tree, p);\n    }\n  }\n  return tree;\n};\n```", "```\nconst _findMin = (tree) =>\n  isEmpty(tree.ptrs[0]) ? tree.keys[0] : _findMin(tree.ptrs[0]);\n```", "```\nconst _fixChildIfSmall = (tree, p) => {\n  const child = tree.ptrs[p];\n\n❶ if (_tooSmall(child)) {\n  ❷ if (p > 0 && !_tooSmall(tree.ptrs[p - 1], 1)) {\n    ❸ const leftChild = tree.ptrs[p – 1];\n      child.keys.unshift(tree.keys[p - 1]);\n      child.ptrs.unshift(leftChild.ptrs.pop());\n      tree.keys[p - 1] = leftChild.keys.pop();\n  ❹} else if (p < tree.keys.length && !_tooSmall(tree.ptrs[p + 1], 1)) {\n    ❺ const rightChild = tree.ptrs[p + 1];\n      child.keys.push(tree.keys[p]);\n child.ptrs.push(rightChild.ptrs.shift());\n      tree.keys[p] = rightChild.keys.shift();\n  ❻} else if (p > 0) {\n    ❼ const leftChild = tree.ptrs[p – 1];\n      leftChild.keys.push(tree.keys[p - 1], . . .child.keys);\n      leftChild.ptrs.push(...child.ptrs);\n      tree.keys.splice(p - 1, 1);\n      tree.ptrs.splice(p, 1);\n  ❽} else {\n    ❾ const rightChild = tree.ptrs[p + 1];\n      rightChild.keys.unshift(...child.keys, tree.keys[p]);\n      rightChild.ptrs.unshift(...child.ptrs);\n      tree.keys.splice(p, 1);\n      tree.ptrs.splice(p, 1);\n    }\n  }\n};\n```", "```\nconst RED = \"RED\";\nconst BLACK = \"BLACK\";\nconst flip = (color) => (color === RED ? BLACK : RED);\n```", "```\nconst newRedBlackTree = () => null;\n\nconst newNode = (key) => ({\n  key,\n  left: null,\n  right: null,\n❶ color: RED\n});\n\n❷ const _isBlack = (node) => isEmpty(node) || node.color === BLACK;\n❸ const _isRed = (node) => !_isBlack(node);\n```", "```\n❶ const _add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n    return newNode(keyToAdd);\n  } else {\n    const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n    tree[side] = _add(tree[side], keyToAdd);\n❷ **return _fixUp(tree);**\n  }\n};\n\n❸ const add = (tree, keyToAdd) => {\n❹ const newRoot = _add(tree, keyToAdd);\n❺ newRoot.color = BLACK;\n  return newRoot;\n};\n```", "```\nconst _rotate = (tree, side) => {\n  const otherSide = side === \"left\" ? \"right\" : \"left\";\n\n  const auxTree = tree[side];\n  tree[side] = auxTree[otherSide];\n  auxTree[otherSide] = tree;\n\n **auxTree.color = auxTree[otherSide].color;**\n **auxTree[otherSide].color = RED;**\n\n  return auxTree;\n};\n```", "```\nconst _fixUp = (tree) => {\n❶ if (_isRed(tree.right)) {\n    tree = _rotate(tree, \"right\");\n  }\n\n❷ if (_isRed(tree.left) && _isRed(tree.left.left)) {\n    tree = _rotate(tree, \"left\");\n  }\n\n❸ if (_isRed(tree.left) && _isRed(tree.right)) {\n    _flipColors(tree);\n  }\n\n  return tree;\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n❶ const newRoot = _remove(tree, keyToRemove);\n  if (!isEmpty(newRoot)) {\n  ❷ newRoot.color = BLACK;\n  }\n  return newRoot;\n};\n```", "```\nconst _remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    return null;\n❶} else if (keyToRemove < tree.key) {\n  ❷ if (_isBlack(tree.left) && _isBlack(tree.left.left)) {\n      _flipColors(tree);\n      if (_isRed(tree.right.left)) {\n        tree.right = _rotate(tree.right, \"left\");\n        tree = _rotate(tree, \"right\");\n        _flipColors(tree);\n      }\n    }\n ❸ tree.left = _remove(tree.left, keyToRemove);\n❹} else {\n    if (_isRed(tree.left)) {\n      tree = _rotate(tree, \"left\");\n    }\n  ❺ if (keyToRemove === tree.key && isEmpty(tree.right)) {\n      return null;\n    } else {\n    ❻ if (_isBlack(tree.right) && _isBlack(tree.right.left)) {\n        _flipColors(tree);\n        if (_isRed(tree.left.left)) {\n          tree = _rotate(tree, \"left\");\n          _flipColors(tree);\n        }\n      }\n      if (keyToRemove === tree.key) {\n      ❼ tree.key = minKey(tree.right);\n        tree.right = _remove(tree.right, tree.key);\n      } else {\n      ❽ tree.right = _remove(tree.right, keyToRemove);\n      }\n    }\n  }\n❾ return _fixUp(tree);\n};\n```"]