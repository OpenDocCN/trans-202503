<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_217"/><span class="big">12</span><br/>ELLIPTIC CURVES</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">The introduction of <em>elliptic curve cryptography (ECC)</em> in 1985 revolutionized the way we do public-key cryptography. ECC is more powerful and efficient than alternatives like RSA and classical Diffie–Hellman (ECC with a 256-bit key is stronger than RSA with a 4096-bit key), but it’s also more complex.</p>
<p class="indent">Like RSA, ECC multiplies large numbers, but unlike RSA it does so in order to combine points on a mathematical curve, called an <em>elliptic curve</em> (which has nothing to do with an ellipse, by the way). To complicate matters, there are many different types of elliptic curves—simple and sophisticated ones, efficient and inefficient ones, and secure and insecure ones.</p>
<p class="indent">Although first introduced in 1985, ECC wasn’t adopted by standardization bodies until the early 2000s, and it wasn’t seen in major toolkits until much later: OpenSSL added ECC in 2005, and the OpenSSH secure connectivity tool waited until 2011. But modern systems have few reasons not to use ECC, and you’ll find it used in Bitcoin and many security components <span epub:type="pagebreak" id="page_218"/>in Apple devices. Indeed, elliptic curves allow you to perform common public-key cryptography operations such as encryption, signature, and key agreement faster than their classical counterparts. Most cryptographic applications that rely on the discrete logarithm problem (DLP) will also work when based on its elliptic curve counterpart, ECDLP, with one notable exception: the Secure Remote Password (SRP) protocol.</p>
<p class="indent">This chapter focuses on applications of ECC and discusses why you would use ECC rather than RSA or classical Diffie–Hellman, as well as how to choose the right elliptic curve for your application.</p>
<h3 class="h3" id="lev1sec80">What Is an Elliptic Curve?</h3>
<p class="noindent">An elliptic curve is a <em>curve</em> on a plane—a group of points with <em>x</em> and <em>y</em> coordinates. A curve’s equation defines all the points that belong to that curve. For example, the curve <em>y</em> = 3 is a horizontal line with the vertical coordinate 3, curves of the form <em>y</em> = <em>ax</em> + <em>b</em> with fixed numbers <em>a</em> and <em>b</em> are straight lines, <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> = 1 is a circle of radius 1 centered on the origin, and so on. Whatever the type of curve, the points on a curve are all (<em>x</em>, <em>y</em>) pairs that satisfy the curve’s equation.</p>
<p class="indent">An elliptic curve as used in cryptography is typically a curve whose equation is of the form <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em> (known as the <em>Weierstrass form</em>), where the constants <em>a</em> and <em>b</em> define the shape of the curve. For example, <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows the elliptic curve that satisfies the equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em>.</p>
<div class="image"><img src="../images/f12-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig1"/><em>Figure 12-1: An elliptic curve with the equation y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x, shown over the real numbers</em></p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_219"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In this chapter, I focus on the simplest, most common type of elliptic curves—namely, those with an equation that looks like</em> y<sup>2</sup> = x<sup>3</sup> + ax + b—<em>but there are types of elliptic curves with equations in other forms. For example,</em> Edwards curves <em>are elliptic curves whose equation is of the form</em> x<sup>2</sup> + y<sup>2</sup> = 1 + dx<sup>2</sup>y<sup>2</sup>. <em>Edwards curves are sometimes used in cryptography (for example, in the Ed25519 scheme)</em>.</p>
</div>
<p class="indent"><a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows all the points that make up the curve for <em>x</em> between –3 and 4, be they points on the left side of the curve, which looks like a circle, or on the right side, which looks like a parabola. All these points have (<em>x</em>, <em>y</em>) coordinates that satisfy the curve’s equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em>. For example, when <em>x</em> = 0, then <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em> = 0<sup>3</sup> – 4 × 0 = 0; hence, <em>y</em> = 0 is a solution, and the point (0, 0) belongs to the curve. Likewise, if <em>x</em> = 2, the solution to the equation is <em>y</em> = 0, meaning that the point (2, 0) belongs to the curve.</p>
<p class="indent">It is crucial to distinguish points that belong to the curve from other points, because when using elliptic curves for cryptography, we’ll be working with points from the curve, and points off the curve often present a security risk. However, note that the curve’s equation doesn’t always admit solutions, at least not in the natural number plane. For example, to find points with the horizontal coordinate <em>x</em> = 1, we solve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em> for <em>y</em><sup>2</sup> with <em>x</em><sup>3</sup> – 4<em>x</em> = 1<sup>3</sup> – 4 × 1, giving a result of –3. But <em>y</em><sup>2</sup> = –3 doesn’t have a solution because there is no number for which <em>y</em><sup>2</sup> = –3. (There is a solution in the complex numbers, but elliptic curve cryptography will only deal with natural numbers—more precisely, integers modulo a prime.) Because there is no solution to the curve’s equation for <em>x</em> = 1, the curve has no point at that position on the x-axis, as you can see in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>
<p class="indent">What if we try to solve for <em>x</em> = –1? In this case, we get the equation <em>y</em><sup>2</sup> = –1 + 4 = 3, which has two solutions (<em>y</em> = √3 and <em>y</em> = –√3), the square root of three and its negative value. Squaring a number always gives a positive number, so <em>y</em><sup>2</sup> = (–<em>y</em>)<sup>2</sup> for any real number <em>y</em>, and as you can see, the curve in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> is symmetric with respect to the x-axis for all points that solve its equation (as are all elliptic curves of the form <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>).</p>
<h4 class="h4" id="lev2sec147"><em>Elliptic Curves over Integers</em></h4>
<p class="noindent">Now here’s a bit of a twist: the curves used in elliptic curve cryptography actually don’t look like the curve shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>. They look instead like <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>, which is a cloud of points rather than a curve. What’s going on here?</p>
<p class="indent"><a href="ch12.xhtml#ch12fig1">Figures 12-1</a> and <a href="ch12.xhtml#ch12fig2">12-2</a> are actually based on the same curve equation, <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em>, but they show the curve’s points with respect to different sets of numbers: <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows the curve’s points over the set of <em>real numbers</em>, which includes negative numbers, decimals, and so on. For example, as a continuous curve, it shows the points at <em>x</em> = 2.0, <em>x</em> = 2.1, <em>x</em> = 2.00002, and so on. <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>, on the other hand, shows only <em>integers</em> that satisfy this equation, which excludes decimal numbers. Specifically, <a href="ch12.xhtml#ch12fig2">Figure 12-2</a> shows the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em> with respect to the integers <em>modulo 191</em>: 0, 1, 2, 3, up to 190. This set of numbers is denoted <strong>Z</strong><sub>191</sub>. (There’s nothing special with 191 here, except that it’s a prime number. I picked a small number to avoid having too many <span epub:type="pagebreak" id="page_220"/>points on the graph.) The points shown on <a href="ch12.xhtml#ch12fig2">Figure 12-2</a> therefore all have <em>x</em> and <em>y</em> coordinates that are integers modulo 191 and that satisfy the equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em>. For example, for <em>x</em> = 2, we have <em>y</em><sup>2</sup> = 0, for which <em>y</em> = 0 is a valid solution. This tells us that the point (2, 0) belongs to the curve.</p>
<div class="image"><img src="../images/f12-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig2"/><em>Figure 12-2: The elliptic curve with the equation</em> y<sup>2</sup> = x<sup>3</sup> – 4<em>x over <strong>Z</strong><sub>191</sub>, the set of integers modulo 191</em></p>
<p class="indentt">What if <em>x</em> = 3? We get the equation <em>y</em><sup>2</sup> = 27 – 12 = 15, which admits two solutions to <em>y</em><sup>2</sup> = 15 (namely, 46 and 145), because 46<sup>2</sup> mod 191 = 15 and 145<sup>2</sup> mod 191 = 15 both equal 15 in <strong>Z</strong><sub>191</sub>. Thus, the points (3, 46) and (3, 145) belong to the curve and appear as shown in <a href="ch12.xhtml#ch12fig2">Figure 12-2</a> (the two points highlighted at the left).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em><a href="ch12.xhtml#ch12fig2">Figure 12-2</a> considers points from the set denoted <strong>Z</strong></em><sub>191</sub> = <em>{0, 1, 2, … , 190}, which includes zero. This differs from the groups denoted <strong>Z</strong></em><sub>p</sub><sup>*</sup> <em>(with a star superscript) that we discussed in the context of RSA and Diffie–Hellman. The reason for this difference is that we’ll both multiply and add numbers, and we therefore need to ensure that the set of numbers includes addition’s identity element (namely 0, such that</em> x + 0 = x <em>for every</em> x <em>in <strong>Z</strong></em><sub>191</sub>). <em>Also, every number x has an inverse with respect to addition, denoted</em> –x, <em>such that</em> x + (–x) = 0. <em>For example, the inverse of 100 in <strong>Z</strong></em><sub>191</sub> <em>is 91, because 100 + 91 mod 191 = 0. Such a set of numbers, where addition and multiplication are possible and where each element</em> x <em>admits an inverse with respect to addition (denoted</em> –x) <em>as well as an inverse with respect to multiplication (denoted 1</em> / x), <em>is called a</em> field. <em>When a field has a finite number of elements, as in <strong>Z</strong></em><sub>191</sub> <em>and as with all fields used for elliptic curve cryptography, it is called a</em> finite field.</p>
</div>
<h4 class="h4" id="lev2sec148"><span epub:type="pagebreak" id="page_221"/><em>Adding and Multiplying Points</em></h4>
<p class="noindent">We’ve seen that the points on an elliptic curve are all coordinates (<em>x</em>, <em>y</em>) that satisfy the curve’s equation, <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>. In this section, we look at how to add elliptic curve points, a rule called the <em>addition law</em>.</p>
<h5 class="h5">Adding Two Points</h5>
<p class="noindent">Say that we want to add two points on the elliptic curve, <em>P</em> and <em>Q</em>, to give a new point, <em>R</em>, that is the sum of these two points. The simplest way to understand point addition is to determine the position of <em>R</em> = <em>P</em> + <em>Q</em> on the curve relative to <em>P</em> and <em>Q</em> based on a geometric rule: draw the line that connects <em>P</em> and <em>Q</em>, find the other point of the curve that intersects with this line, and <em>Q</em> is the reflection of this point with respect to the x-axis. For example, in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>, the line connecting <em>P</em> and <em>Q</em> intersects the curve at a third point between <em>P</em> and <em>Q</em>, and the point <em>P</em> + <em>Q</em> is the point at the same <em>x</em> coordinate but the inverse <em>y</em> coordinate.</p>
<div class="image"><img src="../images/f12-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig3"/><em>Figure 12-3: A general case of the geometric rule for adding points over an elliptic curve</em></p>
<p class="indentt">This geometric rule is simple, but it won’t directly give you the coordinates of the point <em>R</em>. We compute the coordinates (<em>x</em><sub><em>R</em></sub>, <em>y</em><sub><em>R</em></sub>) of <em>R</em> using the coordinates (<em>x</em><sub><em>P</em></sub> , <em>y</em><sub><em>P</em></sub>) of <em>P</em> and the coordinates (<em>x</em><sub><em>Q</em></sub>, <em>y</em><sub><em>Q</em></sub>) of <em>Q</em> using the formulas <em>x</em><sub><em>R</em></sub> = <em>m</em><sup>2</sup> – <em>x</em><sub><em>P</em></sub> – <em>x</em><sub><em>Q</em></sub> and <em>y</em><sub><em>R</em></sub> <em>= m(x</em><sub><em>P</em></sub> – <em>x</em><sub><em>R</em></sub>) – <em>y</em><sub><em>P</em></sub> , where the value <em>m</em> = (<em>y</em><sub><em>Q</em></sub> – <em>y</em><sub><em>P</em></sub>) / (<em>x</em><sub><em>Q</em></sub> – <em>x</em><sub><em>P</em></sub>) is the slope of the line connecting <em>P</em> and <em>Q</em>.</p>
<p class="indent">Unfortunately, these formulas and the line-drawing trick shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a> don’t always work. If, for example, <em>P</em> = <em>Q</em>, you can’t draw a line <span epub:type="pagebreak" id="page_222"/>between two points (there’s only one), and if <em>P</em> = –<em>P</em>, the line doesn’t cross the curve again, so there is no point on the curve to mirror. We’ll explore these in the next section.</p>
<h5 class="h5">Adding a Point and Its Negative</h5>
<p class="noindent">The negative of a point <em>P</em> = (<em>x</em><sub><em>P</em></sub> , <em>y</em><sub><em>P</em></sub>) is the point –<em>P</em> = (<em>x</em><sub><em>P</em></sub> , –<em>y</em><sub><em>P</em></sub>), which is the point mirrored around the x-axis. For any <em>P</em>, we say that <em>P</em> + (–<em>P</em>) = <em>O</em>, where <em>O</em> is called the <em>point at infinity</em>. And as you can see in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>, the line between <em>P</em> and –<em>P</em> runs to infinity and never intersects the curve. (The point at infinity is a virtual point that belongs to any elliptic curve; it is to elliptic curves what zero is to integers.)</p>
<div class="image"><img src="../images/f12-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig4"/><em>Figure 12-4: The geometric rule for adding points on an elliptic curve with the operation</em> P + (–P) = O <em>when the line between the points never intersects the curve</em></p>
<h5 class="h5">Doubling a Point</h5>
<p class="noindent">When <em>P</em> = <em>Q</em> (that is, <em>P</em> and <em>Q</em> are at the same position), adding <em>P</em> and <em>Q</em> is equivalent to computing <em>P</em> + <em>P</em>, also denoted 2<em>P</em>. This addition operation is therefore called a <em>doubling</em>.</p>
<p class="indent">However, to find the coordinates of the result <em>R</em> = 2<em>P</em>, we can’t use the geometric rule from the previous section, because we can’t draw a line between <em>P</em> and itself. Instead, we draw the line <em>tangent</em> to the curve at <em>P</em>, and <em>2P</em> is the negation of the point where this line intersects the curve, as shown on <a href="ch12.xhtml#ch12fig5">Figure 12-5</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_223"/><img src="../images/f12-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig5"/><em>Figure 12-5: The geometric rule for adding points over an elliptic curve using the doubling operation</em> P + P</p>
<p class="indent">The formula for determining the coordinates (<em>x</em><sub><em>R</em></sub>, <em>y</em><sub><em>R</em></sub>) of <em>R</em> = <em>P</em> + <em>P</em> is slightly different from the formula we would use for a distinct <em>P</em> and <em>Q</em>. Again, the basic formula is <em>x</em><sub><em>R</em></sub> = <em>m</em><sup>2</sup> – <em>x</em><sub><em>P</em></sub> – <em>x</em><sub><em>Q</em></sub> and <em>y</em><sub><em>R</em></sub> = <em>m</em>(<em>x</em><sub><em>P</em></sub> – <em>x</em><sub><em>R</em></sub>) – <em>y</em><sub><em>P</em></sub>, but the value of <em>m</em> is different; it becomes (3<em>x</em><sub><em>P</em></sub><sup>2</sup> + <em>a</em>) / 2<em>y</em><sub><em>P</em></sub>, where <em>a</em> is the curve’s parameter, as in <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>.</p>
<h5 class="h5">Multiplication</h5>
<p class="noindent">In order to multiply points on elliptic curves by a given number <em>k</em>, where <em>k</em> is an integer, we determine the point <em>kP</em> by adding <em>P</em> to itself <em>k</em> – 1 times. In other words, 2<em>P</em> = <em>P</em> + <em>P</em>, 3<em>P</em> = <em>P</em> + <em>P</em> + <em>P</em>, and so on. To obtain the <em>x</em> and <em>y</em> coordinates of <em>kP</em>, repeatedly add <em>P</em> to itself and apply the preceding addition law.</p>
<p class="indent">To compute <em>kP</em> efficiently, however, the naive technique of adding <em>P</em> by applying the addition law <em>k</em> – 1 times is far from optimal. For example, if <em>k</em> is large (of the order of, say, 2<sup>256</sup>) as it occurs in elliptic curve–based crypto schemes, then computing <em>k</em> – 1 additions is downright infeasible.</p>
<p class="indent">But there’s a trick: you can gain an exponential speed-up by adapting the technique discussed in <a href="ch10.xhtml#lev2sec130">“Fast Exponentiation Algorithm: Square-and-Multiply”</a> on page 192 to compute <em>x</em><sup><em>e</em></sup> mod <em>n</em>. For example, to compute 8<em>P</em> in three additions instead of seven using the naive method, you would first compute <em>P</em><sub>2</sub> = <em>P</em> + <em>P</em>, then <em>P</em><sub>4</sub> = <em>P</em><sub>2</sub> + <em>P</em><sub>2</sub>, and finally <em>P</em><sub>4</sub> + <em>P</em><sub>4</sub> = 8<em>P</em>.</p>
<h4 class="h4" id="lev2sec149"><span epub:type="pagebreak" id="page_224"/><em>Elliptic Curve Groups</em></h4>
<p class="noindent">Because points can be added together, the set of points on an elliptic curve forms a group. According to the definition of a group (see <a href="ch09.xhtml#lev2sec121">“What Is a Group?”</a> on page 174), if the points <em>P</em> and <em>Q</em> belong to a given curve, then <em>P</em> + <em>Q</em> also belongs to the curve.</p>
<p class="indent">Furthermore, because addition is <em>associative</em>, we have (<em>P</em> + <em>Q</em>) + <em>R</em> = <em>P</em> + (<em>Q</em> + <em>R</em>) for any points <em>P</em>, <em>Q</em>, and <em>R</em>. In a group of elliptic curve points, the identity element is called the point at infinity, and denoted <em>O</em>, such that <em>P</em> + <em>O</em> = <em>P</em> for any <em>P</em>. Every point <em>P</em> = (<em>x</em><sub><em>P</em></sub> , <em>y</em><sub><em>P</em></sub>) has an inverse, –<em>P</em> = (<em>x</em><sub><em>P</em></sub> , –<em>y</em><sub><em>P</em></sub>), such that <em>P</em> + (–<em>P</em>) = <em>O</em>.</p>
<p class="indent">In practice, most elliptic curve–based cryptosystems work with <em>x</em> and <em>y</em> coordinates that are numbers modulo a prime number, <em>p</em> (in other words, numbers in the finite field <strong>Z</strong><sub><em>p</em></sub>). Just as the security of RSA depends on the size of the numbers used, the security of an elliptic curve–based cryptosystem depends on the number of points on the curve. But how do we know the number of points on an elliptic curve, or its <em>cardinality</em>? Well, it depends on the curve and the value of <em>p</em>.</p>
<p class="indent">One rule of thumb is that there are approximately <em>p</em> points on the curve, but you can compute the exact number of points with Schoof’s algorithm, which counts points on elliptic curves over finite fields. You’ll find this algorithm built in to SageMath. For example, <a href="ch12.xhtml#ch12list1">Listing 12-1</a> shows how to use this algorithm to count the number of points on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 4<em>x</em> over <strong>Z</strong><sub>191</sub> shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>
<p class="programs">sage: <span class="codestrong">Z = Zmod(191)</span><br/>sage: <span class="codestrong">E = EllipticCurve(Z, (-4,0))</span><br/>sage: <span class="codestrong">E.cardinality()</span><br/>192</p>
<p class="figcap"><a id="ch12list1"/><em>Listing 12-1: Computing the cardinality, or number of points on a curve</em></p>
<p class="indentt">In <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, we’ve first defined the variable <span class="literal">Z</span> as the set over integers modulo 191; then we defined the variable <span class="literal">E</span> as the elliptic curve over <span class="literal">Z</span> with the coefficients –4 and 0. Finally, we computed the number of points on the curve, also known as its <em>cardinality</em>, <em>group</em> <em>order</em>, or just <em>order</em>. Note that this count includes the point at infinity <em>O</em>.</p>
<h3 class="h3" id="lev1sec81">The ECDLP Problem</h3>
<p class="noindent"><a href="ch09.xhtml#ch9">Chapter 9</a> introduced the DLP: that of finding the number <em>y</em> given some base number <em>g</em>, where <em>x</em> = <em>g</em><sup><em>y</em></sup> mod <em>p</em> for some large prime number <em>p</em>. Cryptography with elliptic curves has a similar problem: the problem of finding the number <em>k</em> given a base point <em>P</em> where the point <em>Q</em> = <em>kP</em>. This is called the <em>elliptic curve discrete logarithm problem</em>, or <em>ECDLP</em>. (Instead of numbers, the elliptic curve’s problems operate on points, and multiplication is used instead of exponentiation.)</p>
<p class="indent">All elliptic curve cryptography is built on the ECDLP problem, which, like DLP, is believed to be hard and has withstood cryptanalysis since its <span epub:type="pagebreak" id="page_225"/>introduction into cryptography in 1985. One important difference between ECDLP and the classical DLP is that ECDLP allows you to work with smaller numbers and still enjoy a similar level of security.</p>
<p class="indent">Generally, when <em>p</em> is <em>n</em> bits, you’ll get a security level of about <em>n</em>/2 bits. For example, an elliptic curve taken over numbers modulo <em>p</em>, with a 256-bit <em>p</em>, will give a security level of about 128 bits. For the sake of comparison, to achieve a similar security level with DLP or RSA, you would need to use numbers of several thousands of bits. The smaller numbers used for ECC arithmetic are one reason why it’s often faster than RSA or classical Diffie–Hellman.</p>
<p class="indent">One way of solving ECDLP is to find a collision between two outputs, <em>c</em><sub>1</sub><em>P</em> + <em>d</em><sub>1</sub><em>Q</em> and <em>c</em><sub>2</sub><em>P</em> + <em>d</em><sub>2</sub><em>Q</em>. The points <em>P</em> and <em>Q</em> in these equations are such that <em>Q</em> = <em>kP</em> for some unknown <em>k</em>, and <em>c</em><sub>1</sub>, <em>d</em><sub>1</sub>, <em>c</em><sub>2</sub>, and <em>d</em><sub>2</sub> are the numbers you will need in order to find <em>k</em>.</p>
<p class="indent">As with the hash function discussed in <a href="ch06.xhtml#ch6">Chapter 6</a>, a collision occurs when two different inputs produce the same output. Therefore, in order to solve ECDLP, we need to find points where the following is true:</p>
<p class="center"><em>c</em><sub>1</sub><em>P</em> + <em>d</em><sub>1</sub><em>Q</em> = <em>c</em><sub>2</sub><em>P</em> + <em>d</em><sub>2</sub><em>Q</em></p>
<p class="indentb">In order to find these points, we replace <em>Q</em> with the value <em>kP</em>, and we have the following:</p>
<p class="center"><em>c</em><sub>1</sub><em>P</em> + <em>d</em><sub>1</sub><em>kP</em> = (<em>c</em><sub>1</sub> + <em>d</em><sub>1</sub><em>k</em>)<em>P</em> = <em>c</em><sub>2</sub><em>P</em> + <em>d</em><sub>2</sub><em>kP</em> = (<em>c</em><sub>2</sub> + <em>d</em><sub>2</sub><em>k</em>)<em>P</em></p>
<p class="indentt">This tells us that (<em>c</em><sub>1</sub> + <em>d</em><sub>1</sub><em>k</em>) equals (<em>c</em><sub>2</sub> + <em>d</em><sub>2</sub><em>k</em>) when taken modulo the number of points on the curve, which is not a secret.</p>
<p class="indentb">From this, we can deduce the following:</p>
<div class="image1"><img src="../images/f0225-01.jpg" alt="image"/></div>
<p class="indentt">And we’ve found <em>k</em>, the solution to ECDLP.</p>
<p class="indent">Of course, that’s only the big picture—the details are more complex and interesting. In practice, elliptic curves extend over numbers of at least 256 bits, which makes attacking elliptic curve cryptography by finding a collision impractical because doing so takes up to 2<sup>128</sup> operations (the cost of finding a collision over 256-bit numbers, as you learned in <a href="ch06.xhtml#ch6">Chapter 6</a>).</p>
<h3 class="h3" id="lev1sec82">Diffie–Hellman Key Agreement over Elliptic Curves</h3>
<p class="noindent">Recall from <a href="ch11.xhtml#ch11">Chapter 11</a> that in the classical Diffie–Hellman (DH) key agreement protocol, two parties establish a shared secret by exchanging non-secret values. Given some fixed number <em>g</em>, Alice picks a secret random <span epub:type="pagebreak" id="page_226"/>number <em>a</em>, computes <em>A</em> = <em>g</em><sup><em>a</em></sup>, sends <em>A</em> to Bob, and Bob picks a secret random <em>b</em> and sends <em>B</em> = <em>g</em><sup><em>b</em></sup> to Alice. Both then combine their secret key with the other’s public key to produce the same <em>A</em><sup><em>b</em></sup> = <em>B</em><sup><em>a</em></sup> = <em>g</em><sup><em>ab</em></sup>.</p>
<p class="indent">The elliptic curve version of DH is identical to that of classical DH but with different notations. In the case of ECC, for some fixed point <em>G</em>, Alice picks a secret random number <em>d</em><sub><em>A</em></sub>, computes <em>P</em><sub><em>A</em></sub> = <em>d</em><sub><em>A</em></sub><em>G</em> (the point <em>G</em> multiplied by <em>d</em><sub>A</sub>), and sends <em>P</em><sub>A</sub> to Bob. Bob picks a secret random <em>d</em><sub>B</sub>, computes the point <em>P</em><sub>B</sub> = <em>d</em><sub>B</sub><em>G</em>, and sends it to Alice. Then both compute the same shared secret, <em>d</em><sub><em>A</em></sub><em>P</em><sub><em>B</em></sub> = <em>d</em><sub><em>B</em></sub><em>P</em><sub><em>A</em></sub> = <em>d</em><sub><em>A</em></sub><em>d</em><sub><em>B</em></sub><em>G</em>. This method is called <em>elliptic curve Diffie–Hellman</em>, or <em>ECDH</em>.</p>
<p class="indent">ECDH is to the ECDLP problem what DH is to DLP: it’s secure as long as ECDLP is hard. DH protocols that rely on DLP can therefore be adapted to work with elliptic curves and rely on ECDLP as a hardness assumption. For example, authenticated DH and Menezes–Qu–Vanstone (MQV) will also be secure when used with elliptic curves. (In fact, MQV was first defined as working over elliptic curves.)</p>
<h4 class="h4" id="lev2sec150"><em>Signing with Elliptic Curves</em></h4>
<p class="noindent">The standard algorithm used for signing with ECC is <em>ECDSA</em>, which stands for <em>elliptic curve digital signature algorithm</em>. This algorithm has replaced RSA signatures and classical DSA signatures in many applications. It is, for example, the only signature algorithm used in Bitcoin and is supported by many TLS and SSH implementations.</p>
<p class="indent">As with all signature schemes, ECDSA consists of a <em>signature generation</em> algorithm that the signer uses to create a signature using their private key and a <em>verification</em> algorithm that a verifier uses to check a signature’s correctness given the signer’s public key. The signer holds a number, <em>d</em>, as a private key, and verifiers hold the public key, <em>P</em> = <em>dG</em>. Both know in advance what elliptic curve to use, its order (<em>n</em>, the number of points in the curve), as well as the coordinates of a base point, <em>G</em>.</p>
<h5 class="h5">ECDSA Signature Generation</h5>
<p class="noindent">In order to sign a message, the signer first hashes the message with a cryptographic hash function such as SHA-256 or BLAKE2 to generate a hash value, <em>h</em>, that is interpreted as a number between 0 and <em>n</em> – 1. Next, the signer picks a random number, <em>k</em>, between 1 and <em>n</em> – 1 and computes <em>kG</em>, a point with the coordinates (<em>x</em>, <em>y</em>). The signer now sets <em>r</em> = <em>x</em> mod <em>n</em> and computes <em>s</em> = (<em>h</em> + <em>rd</em>) / <em>k</em> mod <em>n</em>, and then uses these values as the signature (<em>r</em>, <em>s</em>).</p>
<p class="indent">The length of the signature will depend on the coordinate lengths being used. For example, when you’re working with a curve where coordinates are 256-bit numbers, <em>r</em> and <em>s</em> would both be 256 bits long, yielding a 512-bit-long signature.</p>
<h5 class="h5">ECDSA Signature Verification</h5>
<p class="noindent">The ECDSA verification algorithm uses a signer’s public key to verify the validity of a signature.</p>
<p class="indent"><span epub:type="pagebreak" id="page_227"/>In order to verify an ECDSA signature (<em>r</em>, <em>s</em>) and a message’s hash, <em>h</em>, the verifier first computes <em>w</em> = 1 / <em>s</em>, the inverse of <em>s</em> in the signature, which is equal to <em>k</em> / (<em>h</em> + <em>rd</em>) mod <em>n</em>, since <em>s</em> is defined as <em>s</em> = (<em>h</em> + <em>rd</em>) / <em>k</em>. Next, the verifier multiplies <em>w</em> with <em>h</em> to find <em>u</em> according to the following formula:</p>
<p class="center"><em>wh</em> = <em>hk</em> (<em>h</em> + <em>rd</em>) = <em>u</em></p>
<p class="indent1">The verifier then multiplies <em>w</em> with <em>r</em> to find <em>v</em>:</p>
<p class="center"><em>wr</em> = <em>rk</em>(<em>h</em> + <em>rd</em>) = <em>v</em></p>
<p class="indent1">Given <em>u</em> and <em>v</em>, the verifier computes the point <em>Q</em> according to the following formula:</p>
<p class="center"><em>Q</em> = <em>uG</em> + <em>vP</em></p>
<p class="indentt">Here, <em>P</em> is the signer’s public key, which is equal to <em>dG</em>, and the verifier only accepts the signature if the <em>x</em> coordinate of <em>Q</em> is equal to the value <em>r</em> from the signature.</p>
<p class="indentb">This process works because, as a last step, we compute the point <em>Q</em> by substituting the public key <em>P</em> with its actual value <em>dG</em>:</p>
<p class="center"><em>uG</em> + <em>vdG</em> = (<em>u</em> + <em>vd</em>)<em>G</em></p>
<p class="indent1">When we replace <em>u</em> and <em>v</em> with their actual values, we obtain the following:</p>
<p class="center"><em>u</em> + <em>vd</em> = <em>hk</em> (<em>h</em> + <em>rd</em>) + <em>drk</em> / (<em>h</em> + <em>rd</em>) = (<em>hk</em> + <em>drk</em>) / (<em>h</em> + <em>rd</em>) = <em>k</em> (<em>h</em> + <em>dr</em>) / (<em>h</em> + <em>rd</em>) = <em>k</em></p>
<p class="indentt">This tells us that (<em>u</em> + <em>vd</em>) is equal to the value <em>k</em>, chosen during signature generation, and that <em>uG</em> + <em>vdG</em> is equal to the point <em>kG</em>. In other words, the verification algorithm succeeds in computing point <em>kG</em>, the same point computed during signature generation. Validation is complete once a verifier confirms that <em>kG</em>’s <em>x</em> coordinate is equal to the <em>r</em> received; otherwise, the signature is rejected as invalid.</p>
<h5 class="h5">ECDSA vs. RSA Signatures</h5>
<p class="noindent">Elliptic curve cryptography is often viewed as an alternative to RSA for public-key cryptography, but ECC and RSA don’t have much in common. RSA is only used for encryption and signatures, whereas ECC is a family of algorithms that can be used to perform encryption, generate signatures, perform key agreement, and offer advanced cryptographic functionalities such as identity-based encryption (a kind of encryption that uses encryption keys derived from a personal identifier, such as an email address).</p>
<p class="indent">When comparing RSA and ECC’s signature algorithms, recall that in RSA signatures, the signer uses their private key <em>d</em> to compute a signature <span epub:type="pagebreak" id="page_228"/>as <em>y</em> = <em>x</em><sup><em>d</em></sup> mod <em>n</em>, where <em>x</em> is the data to be signed and <em>y</em> is the signature. Verification uses the public key <em>e</em> to confirm that <em>y</em><sup><em>e</em></sup> mod <em>n</em> equals <em>x</em>—a process that’s clearly simpler than that of ECDSA.</p>
<p class="indent">RSA’s verification process is often faster than ECC’s signature generation because it uses a small public key <em>e</em>. But ECC has two major advantages over RSA: shorter signatures and signing speed. Because ECC works with shorter numbers, it produces shorter signatures than RSA (hundreds of bits long, not thousands of bits), which is an obvious benefit if you have to store or transmit numerous signatures. Signing with ECDSA is also much faster than signing with RSA (though signature verification is about as fast) because ECDSA works with much smaller numbers than RSA does for a similar security level. For example, <a href="ch12.xhtml#ch12list2">Listing 12-2</a> shows that ECDSA is about 150 times faster at signing and a little faster at verifying. Note that ECDSA signatures are also shorter than RSA signatures because they’re 512 bits (two elements of 256 bits each) rather than 4096 bits.</p>
<p class="programs">$ <span class="codestrong">openssl speed ecdsap256 rsa4096</span><br/>                              sign     verify     sign/s     verify/s<br/>rsa 4096 bits            0.007267s  0.000116s      137.6       8648.0<br/>                              sign     verify     sign/s     verify/s<br/>256 bit ecdsa (nistp256)   0.0000s    0.0001s    21074.6       9675.7</p>
<p class="figcap"><a id="ch12list2"/><em>Listing 12-2: Comparing the speed of 4096-bit RSA signatures with 256-bit ECDSA signatures</em></p>
<p class="indent">It’s fair to compare the performance of these differently sized signatures because they provide a similar security level. However, in practice, many systems use RSA signatures with 2048 bits, which is orders of magnitude less secure than 256-bit ECDSA. Thanks to its smaller modulus size, 2048-bit RSA is faster than 256-bit ECDSA at verifying, yet still slower at signing, as shown in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>.</p>
<p class="programs">$ <span class="codestrong">openssl speed rsa2048</span><br/>                          sign         verify     sign/s     verify/s<br/>rsa 2048 bits            0.000696s  0.000032s     1436.1      30967.1</p>
<p class="figcap"><a id="ch12list3"/><em>Listing 12-3: The speed of 2048-bit RSA signatures</em></p>
<p class="indent">The upshot is that you should prefer ECDSA to RSA except when signature verification is critical <em>and</em> you don’t care about signing speed, as in a sign-once, verify-many situation (for example, when a Windows executable application is signed once and then verified by all the systems executing it).</p>
<h4 class="h4" id="lev2sec151"><em>Encrypting with Elliptic Curves</em></h4>
<p class="noindent">Although elliptic curves are more commonly used for signing, you can still encrypt with them. But you’ll rarely see people do so in practice due to restrictions in the size of the plaintext that can be encrypted: you can fit only about 100 bits of plaintext, as compared to almost 4000 in RSA with the same security level.</p>
<p class="indent"><span epub:type="pagebreak" id="page_229"/>One simple way to encrypt with elliptic curves is to use the <em>i</em><em>ntegrated encryption scheme (IES)</em>, a hybrid asymmetric–symmetric key encryption algorithm based on the Diffie–Hellman key exchange. Essentially, IES encrypts a message by generating a Diffie–Hellman key pair, combining the private key with the recipient’s own public key, deriving a symmetric key from the shared secret obtained, and then using an authenticated cipher to encrypt the message.</p>
<p class="indent">When used with elliptic curves, IES relies on ECDLP’s hardness and is called <em>elliptic-curve integrated encryption scheme (ECIES)</em>. Given a recipient’s public key, <em>P</em>, ECIES encrypts a message, <em>M</em>, as follows:</p>
<ol>
<li class="noindent"><p class="list">Pick a random number, <em>d</em>, and compute the point <em>Q</em> = <em>dG</em>, where the base point <em>G</em> is a fixed parameter. Here, (<em>d</em>, <em>Q</em>) acts as an ephemeral key pair, used only for encrypting <em>M</em>.</p></li>
<li class="noindent"><p class="list">Compute an ECDH shared secret by computing <em>S</em> = <em>dP</em>.</p></li>
<li class="noindent"><p class="list">Use a key derivation scheme (KDF) to derive a symmetric key, <em>K</em>, from <em>S</em>.</p></li>
<li class="noindent"><p class="list">Encrypt <em>M</em> using <em>K</em> and a symmetric authenticated cipher, obtaining a ciphertext, <em>C</em>, and an authentication tag, <em>T</em>.</p></li>
</ol>
<p class="indent">The ECIES ciphertext then consists of the ephemeral public key <em>Q</em> followed by <em>C</em> and <em>T</em>. Decryption is straightforward: the recipient computes <em>S</em> by multiplying <em>R</em> with their private exponent to obtain <em>S</em>, and then derives the key <em>K</em> and decrypts <em>C</em> and verifies <em>T</em>.</p>
<h3 class="h3" id="lev1sec83">Choosing a Curve</h3>
<p class="noindent">Criteria used to assess the safety of an elliptic curve include the order of the group used (that is, its number of points), its addition formulas, and its origins.</p>
<p class="indentb">There are several types of elliptic curves, but not all are equally good for cryptographic purposes. When making your selection, be sure to choose coefficients <em>a</em> and <em>b</em> in the curve’s equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em> carefully; otherwise, you may end up with an insecure curve. In practice, you’ll use some de facto standard curve for encryption, but knowing what makes a safe curve will help you choose among the several available ones and better understand any associated risks. Here are some points to keep in mind:</p>
<ul>
<li class="noindent">The order of the group should not be a product of small numbers; otherwise solving ECDLP becomes much easier.</li>
<li class="noindent">In <a href="ch12.xhtml#lev2sec148">“Adding and Multiplying Points”</a> on page 221, you learned that adding points <em>P</em> + <em>Q</em> required a specific addition formula when <em>Q</em> = <em>P</em>. Unfortunately, treating this case differently from the general one may leak critical information if an attacker is able to distinguish doublings from additions between distinct points. Some curves are secure <em>because</em> they use a single formula for all point addition. (When a curve does not require a specific formula for doublings, we say that it admits a <em>unified</em> addition law.)</li>
<li class="noindent"><span epub:type="pagebreak" id="page_230"/>If the creators of a curve don’t explain the origin of <em>a</em> and <em>b</em>, they may be suspected of foul play because you can’t know whether they may have chosen weaker values that enable some yet-unknown attack on the cryptosystem.</li>
</ul>
<p class="indent">Let’s review some of the most commonly used curves, especially ones used for signatures or Diffie–Hellman key agreement.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You’ll find more criteria and more details about curves on the dedicated website</em> <a href="https://safecurves.cr.yp.to/">https://safecurves.cr.yp.to/</a>.</p>
</div>
<h4 class="h4" id="lev2sec152"><em>NIST Curves</em></h4>
<p class="noindent">In 2000, the NIST curves were standardized by the US NIST in the FIPS 186 document under “Recommended Elliptic Curves for Federal Government Use.” Five NIST curves work modulo a prime number (as discussed in <a href="ch12.xhtml#lev2sec147">“Elliptic Curves over Integers”</a> on page 219), called <em>prime curves</em>. Ten other NIST curves work with binary polynomials, which are mathematical objects that make implementation in hardware more efficient. (We won’t cover binary polynomials in further detail because they’re seldom used with elliptic curves.)</p>
<p class="indent">The most common NIST curves are the prime curves. Of these, one of the most common is P-256, a curve that works over numbers modulo the 256-bit number <em>p</em> = 2<sup>256</sup> – 2<sup>224</sup> + 2<sup>192</sup> + 2<sup>96</sup> – 1. The equation for P-256 is <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> – 3<em>x</em> + <em>b</em>, where <em>b</em> is a 256-bit number. NIST also provides prime curves of 192 bits, 224 bits, 384 bits, and 521 bits.</p>
<p class="indent">NIST curves are sometimes criticized because only the NSA, creator of the curves, knows the origin of the <em>b</em> coefficient in their equations. The only explanation we’ve been given is that <em>b</em> results from hashing a random-looking constant with SHA-1. For example, P-256’s <em>b</em> parameter comes from the following constant: <span class="literal">c49d3608 86e70493 6a6678e1 139d26b7 819f7e90</span>.</p>
<p class="indent">No one knows why the NSA picked this particular constant, but most experts don’t believe the curve’s origin hides any weakness.</p>
<h4 class="h4" id="lev2sec153"><em>Curve25519</em></h4>
<p class="noindent">Daniel J. Bernstein brought Curve25519 (pronounced <em>curve-twenty-five-five-</em><em>nineteen</em>) to the world in 2006. Motivated by performance, he designed Curve25519 to be faster and use shorter keys than the standard curves. But Curve25519 also brings security benefits, because unlike the NIST curves it has no suspicious constants and can use the same unified formula for adding distinct points or for doubling a point.</p>
<p class="indent">The form of Curve25519’s equation, <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 486662<em>x</em><sup>2</sup> + <em>x</em>, is slightly different from that of the other equations you’ve seen in this chapter, but it still belongs to the elliptic curve family. The unusual form of this equation allows for specific implementation techniques that make Curve25519 fast in software.</p>
<p class="indent"><span epub:type="pagebreak" id="page_231"/>Curve25519 works with numbers modulo the prime number 2<sup>255</sup> – 19, a 256-bit prime number that is as close as possible to 2<sup>255</sup>. The <em>b</em> coefficient 486662 is the smallest integer that satisfies the security criteria set by Bernstein. Taken together, these features make Curve25519 more trust­worthy than NIST curves and their fishy coefficients.</p>
<p class="indent">Curve25519 is used everywhere: in Google Chrome, Apple systems, OpenSSH, and many other systems. However, because Curve25519 isn’t a NIST standard, some applications stick to NIST curves.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>To learn all the details and rationale behind Curve25519, view the 2016 presentation “The first 10 years of Curve25519” by Daniel J. Bernstein, available at</em> <a href="http://cr.yp.to/talks.html#2016.03.09/">http://cr.yp.to/talks.html#2016.03.09/</a>.</p>
</div>
<h4 class="h4" id="lev2sec154"><em>Other Curves</em></h4>
<p class="noindent">As I write this, most cryptographic applications use NIST curves or Curve25519, but there are other legacy standards in use, and newer curves are being promoted and pushed within standardization committees. Some of the old national standards include France’s ANSSI curves and Germany’s Brainpool curves: two families that don’t support complete addition formulas and that use constants of unknown origins.</p>
<p class="indent">Some newer curves are more efficient than the older ones and are clear of any suspicion; they offer different security levels and various efficiency optimizations. Examples include Curve41417, a variant of Curve25519, which works with larger numbers and offers a higher level of security (approximately 200 bits); Ed448-Goldilocks, a 448-bit curve first proposed in 2014 and considered to be an internet standard; as well as six curves proposed by Aranha et al. in “A note on high-security general-purpose elliptic curves” (see <em><a href="http://eprint.iacr.org/2013/647/">http://eprint.iacr.org/2013/647/</a></em>), though these curves are rarely used. The details specific to all these curves are beyond the scope of this book.</p>
<h3 class="h3" id="lev1sec84">How Things Can Go Wrong</h3>
<p class="noindent">Elliptic curves have their downsides due to their complexity and large attack surface. Their use of more parameters than classical Diffie–Hellman brings with it a greater attack surface with more opportunities for mistakes and abuse—and possible software bugs that might affect their implementation. Elliptic curve software may also be vulnerable to side-channel attacks due to the large numbers used in their arithmetic. If the speed of calculations depends on inputs, attackers may be able to obtain information about the formulas being used to encrypt.</p>
<p class="indent">In the following sections, I discuss two examples of vulnerabilities that can occur with elliptic curves, even when the implementation is safe. These are protocol vulnerabilities rather than implementation vulnerabilities.</p>
<h4 class="h4" id="lev2sec155"><span epub:type="pagebreak" id="page_232"/><em>ECDSA with Bad Randomness</em></h4>
<p class="noindentb">ECDSA signing is randomized, as it involves a secret random number <em>k</em> when setting <em>s</em> = (<em>h</em> + <em>rd</em>) / <em>k</em> mod <em>n</em>. However, if the same <em>k</em> is reused to sign a second message, an attacker could combine the resulting two values, <em>s</em><sub>1</sub> = (<em>h</em><sub>1</sub> + <em>rd</em>) / <em>k</em> and <em>s</em><sub>2</sub> = (<em>h</em><sub>2</sub> + <em>rd</em>) / <em>k,</em> to get <em>s</em><sub>1</sub> – <em>s</em><sub>2</sub> = (<em>h</em><sub>1</sub> – <em>h</em><sub>2</sub>) / <em>k</em> and then <em>k</em> = (<em>h</em><sub>1</sub> – <em>h</em><sub>2</sub>) / (<em>s</em><sub>1</sub> – <em>s</em><sub>2</sub>). When <em>k</em> is known, the private key <em>d</em> is easily recovered by computing the following:</p>
<p class="center">(<em>ks</em><sub>1</sub> − <em>h</em><sub>1</sub>) / <em>r</em> = ((<em>h</em><sub>1</sub> + <em>rd</em>) − <em>h</em><sub>1</sub>) / <em>r</em> = <em>rd</em> / <em>r</em> = <em>d</em></p>
<p class="indentt">Unlike RSA signatures, which won’t allow the key to be recovered if a weak pseudorandom number generator (PRNG) is used, the use of non-random numbers can lead to ECDSA’s <em>k</em> being recoverable, as happened with the attack on the PlayStation 3 game console in 2010, presented by the fail0verflow team at the 27th Chaos Communication Congress in Berlin, Germany.</p>
<h4 class="h4" id="lev2sec156"><em>Breaking ECDH Using Another Curve</em></h4>
<p class="noindent">ECDH can be elegantly broken if you fail to validate input points. The primary reason is that the formulas that give the coordinates for the sum of points <em>P</em> + <em>Q</em> never involve the <em>b</em> coefficient of the curve; instead, they rely only on the coordinates of <em>P</em> and <em>Q</em> and the <em>a</em> coefficient (when doubling a point). The unfortunate consequence of this is that when adding two points, you can never be sure that you’re working on the right curve because you may actually be adding points on a different curve with a different <em>b</em> coefficient. That means you can break ECDH as described in the following scenario, called the <em>invalid curve attack</em>.</p>
<p class="indent">Say that Alice and Bob are running ECDH and have agreed on a curve and a base point, <em>G</em>. Bob sends his public key <em>d</em><sub>B</sub><em>G</em> to Alice. Alice, instead of sending a public key <em>d</em><sub>A</sub><em>G</em> on the agreed upon curve, sends a point on a different curve, either intentionally or accidentally. Unfortunately, this new curve is weak and allows Alice to choose a point <em>P</em> for which solving ECDLP is easy. She chooses a point of low order, for which there is a relatively small <em>k</em> such that <em>kP</em> = <em>O</em>.</p>
<p class="indent">Now Bob, believing that he has a legitimate public key, computes what he thinks is the shared secret <em>d</em><sub>B</sub><em>P</em>, hashes it, and uses the resulting key to encrypt data sent to Alice. The problem is that when Bob computes <em>d</em><sub>B</sub><em>P</em>, he is unknowingly computing on the weaker curve. As a result, because <em>P</em> was chosen to belong to a small subgroup within the larger group of points, the result <em>d</em><sub>B</sub><em>P</em> will also belong to that small subgroup, allowing an attacker to determine the shared secret <em>d</em><sub>B</sub><em>P</em> efficiently if they know the order of <em>P</em>.</p>
<p class="indent">One way to prevent this is to make sure that points <em>P</em> and <em>Q</em> belong to the right curve by ensuring that their coordinates satisfy the curve’s equation. Doing so would prevent this attack by making sure that you’re only able to work on the secure curve.</p>
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Such an invalid curve attack was found in 2015 on certain implementations of the TLS protocol, which uses ECDH to negotiate session keys. (For details, see the paper “Practical Invalid Curve Attacks on TLS-ECDH” by Jager, Schwenk, and Somorovsky.)</p>
<h3 class="h3" id="lev1sec85">Further Reading</h3>
<p class="noindent">Elliptic curve cryptography is a fascinating and complex topic that involves lots of mathematics. I’ve not discussed important notions such as a point’s order, a curve’s cofactor, projective coordinates, torsion points, and methods for solving the ECDLP problem. If you are mathematically inclined, you’ll find information on these and other related topics in the <em>Handbook of Elliptic and Hyperelliptic Curve Cryptography</em> by Cohen and Frey (Chapman and Hall/CRC, 2005). The 2013 survey “Elliptic Curve Cryptography in Practice” by Bos, Halderman, Heninger, Moore, Naehrig, and Wustrow also gives a good illustrated introduction with practical examples (<em><a href="https://eprint.iacr.org/2013/734/">https://eprint.iacr.org/2013/734/</a></em>).<span epub:type="pagebreak" id="page_234"/></p>
</body></html>