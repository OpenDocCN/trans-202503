<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_217" title="217"/>10</span><br/>&#13;
<span class="ChapterTitle">Caddy: A Contemporary Web Server </span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> focused on the web service building blocks available to you in Go’s standard library. You learned how to create a simple web server with relatively little code by using handlers, middleware, and multiplexers. Although you can build a capable web server with those tools alone, writing your own server from scratch may not always be the quickest approach. Adding support for logging, metrics, authentication, access control, and encryption, to name a few features, can be daunting and hard to get right. Instead, you may find it more convenient to use an existing, comprehensive web server to host your web services.</p>&#13;
<p><span epub:type="pagebreak" id="Page_218" title="218"/>This chapter will introduce you to the Caddy web server and show you how to focus your time on writing web services while relying on Caddy to serve your application. You’ll get Caddy up and running and then take a dive into its real-time configuration API. Next, you’ll learn how to extend Caddy’s functionality by using custom modules and configuration adapters. You’ll then use Caddy to serve your application’s static files and proxy requests to your web services. Finally, you’ll learn about Caddy’s automatic TLS support by using free certificates from Let’s Encrypt and automated key management. </p>&#13;
<p>After reading this chapter, you should feel comfortable choosing the best solution for your web applications: either a simple <code>net/http</code>-based web server or a comprehensive solution like Caddy.</p>&#13;
<h2 id="h1-500884c10-0001">What Is Caddy?</h2>&#13;
<p class="BodyFirst"><em>Caddy</em> is a contemporary web server that focuses on security, performance, and ease of use. Among its hallmark features, it offers automatic TLS certificate management, allowing you to easily implement HTTPS. Caddy also takes advantage of Go’s concurrency primitives to serve a considerable amount of all web traffic. It’s one of the few open source projects with enterprise-grade support.</p>&#13;
<h3 id="h2-500884c10-0001">Let’s Encrypt Integration</h3>&#13;
<p class="BodyFirst"><em>Let’s Encrypt</em> is a nonprofit certificate authority that supplies digital certificates free of charge for the public to facilitate HTTPS communication. Let’s Encrypt certificates run on more than half of all websites on the internet, and they’re trusted by all popular web browsers. You can retrieve certificates for your website by using Let’s Encrypt’s automated issuance and renewal protocol, known as <em>Automated Certificate Management Environment (ACME)</em>.</p>&#13;
<p>Typically, getting a certificate requires three steps: a certificate request, domain validation, and certificate issuance. First, you request a certificate for your domain from Let’s Encrypt. Let’s Encrypt then confirms your domain to make sure you administer it. Once Let’s Encrypt has ensured that you’re the domain’s rightful owner, it issues you a certificate, which your web server can use for HTTPS support. Each certificate is good for 90 days, though you should renew it every 60 days to prevent service interruption. </p>&#13;
<p>Caddy has inherent support for the ACME protocol and will automatically request, validate, and install Let’s Encrypt certificates if Caddy can properly derive the domain names it hosts. We’ll discuss how best to do this in <span class="xref" itemid="xref_target_“Adding Automatic HTTPS” on page 237">“Adding Automatic HTTPS” on page 237</span>. Caddy also handles automatic renewals, eliminating the need for you to keep track of certificate expiration dates.</p>&#13;
<h3 id="h2-500884c10-0002"><span epub:type="pagebreak" id="Page_219" title="219"/>How Does Caddy Fit into the Equation?</h3>&#13;
<p class="BodyFirst">Caddy works just like other popular web servers, such as NGINX and Apache. It’s best positioned on the edge of your network, between web clients and your web services, as shown in <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>.</p>&#13;
<figure>&#13;
<img alt="f10001" src="image_fi/500884c10/f10001.png"/>&#13;
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Caddy reverse-proxying client requests to web services</p></figcaption>&#13;
</figure>&#13;
<p>Caddy can serve static files and forward requests between clients and backend services, a process known as <em>reverse proxying</em>. In this example, you can see Caddy serving a WordPress blog through PHP’s FastCGI Process Manager (PHP-FPM), static files, and a Go-based web service. We’ll replicate a similar setup later in the chapter, sans WordPress blog.</p>&#13;
<p>Caddy helps abstract web services from clients in much the same way we use abstraction in our code. If you use Caddy’s automatic TLS, static file server, data compression, access control, and logging features, you won’t have to add that functionality to each web service. In addition, using Caddy has the benefit of allowing you to abstract your network topography from clients. As the services increase in popularity and the capacity on web services starts to negatively affect clients, you can add web services to Caddy and instruct Caddy to balance the load among them all, without interruption to your clients. </p>&#13;
<h2 id="h1-500884c10-0002">Retrieving Caddy</h2>&#13;
<p class="BodyFirst">In this chapter, we’ll use version 2 of Caddy. You have a few options for installation, described in this section.</p>&#13;
<h3 id="h2-500884c10-0003">Downloading Caddy</h3>&#13;
<p class="BodyFirst">You can install Caddy by using a static binary, built by the Caddy team. This binary is available through the download link at <a class="LinkURL" href="https://caddyserver.com/">https://caddyserver.com/</a><em>.</em></p>&#13;
<p>Caddy is also available as a Docker image; a DigitalOcean droplet; an Advanced Package Tool (APT) source for Debian derivatives; and in the Fedora Copr build system for use in Fedora, CentOS, or Red Hat Enterprise Linux. You can find details in the Install documentation at <a class="LinkURL" href="https://caddyserver.com/docs/download">https://caddyserver.com/docs/download</a>.</p>&#13;
<h3 id="h2-500884c10-0004"><span epub:type="pagebreak" id="Page_220" title="220"/>Building Caddy from Source Code</h3>&#13;
<p class="BodyFirst">If you do not find a suitable static binary for your operating system and architecture, or if you wish to customize Caddy, you can also compile Caddy from source code. </p>&#13;
<p>Caddy relies heavily on Go’s support for modules. Therefore, you need to use at least Go 1.14 before running the following commands:</p>&#13;
<pre><code>$ <b>git clone "https://github.com/caddyserver/caddy.git"</b>&#13;
Cloning into 'caddy'...&#13;
$ <b>cd caddy/cmd/caddy</b>&#13;
$ <b>go build</b></code></pre>&#13;
<p>Clone the Caddy Git repository and change to the <em>caddy/cmd/caddy</em> subdirectory, where you’ll find the <code>main</code> package. Run <code>go build</code> to create a binary named <em>caddy</em> in the current directory for your operating system and architecture. To simplify commands, the rest of this chapter assumes that the <em>caddy</em> binary is in your <code>PATH</code>.</p>&#13;
<p>While you’re in this subdirectory, make note of the <em>main.go</em> file. You’ll revisit it later in this chapter when you learn how to customize Caddy by adding modules.</p>&#13;
<h2 id="h1-500884c10-0003">Running and Configuring Caddy</h2>&#13;
<p class="BodyFirst">For configuration purposes, Caddy exposes an administration endpoint on TCP port 2019, over which you can interact with Caddy’s configuration in real time. You can configure Caddy by posting JSON to this endpoint, and you can read the configuration with a <code>GET</code> request. Caddy’s full JSON API documentation is available at <a class="LinkURL" href="https://caddyserver.com/docs/json/">https://caddyserver.com/docs/json/</a>.</p>&#13;
<p>Before you can configure Caddy, you need to start it. Running this command starts Caddy as a background process:</p>&#13;
<pre><code>$ <b>caddy start</b>&#13;
2006/01/02 15:04:05.000 INFO    admin   endpoint started&#13;
{"address": "tcp/localhost:2019", "enforce_origin": false,&#13;
"origins": ["localhost:2019", "[::1]:2019", "127.0.0.1:2019"]}&#13;
2006/01/02 15:04:05.000 INFO    serving initial configuration&#13;
Successfully started Caddy (pid=24587) - Caddy is running in the background</code></pre>&#13;
<p>You’ll see log entries showing that the admin endpoint started and Caddy is using the initial configuration. You’ll also see log entries printed to standard output as you interact with the admin endpoint.</p>&#13;
<p>Caddy’s configuration is empty by default. Let’s send meaningful configuration data to Caddy. <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> uses the <code>curl</code> command to post JSON to the <code>load</code> resource on Caddy’s admin endpoint.</p>&#13;
<pre><code>$ <b>curl localhost:2019/load \</b>&#13;
<span class="CodeAnnotationHang">1</span><b> -X POST -H "Content-Type: application/json" \ </b>&#13;
<b>-d '</b>&#13;
<span epub:type="pagebreak" id="Page_221" title="221"/><b>{</b>&#13;
<b>  "apps": {</b>&#13;
<b>    "http": {</b>&#13;
<b>      "servers": {</b>&#13;
<b>        "hello": {</b>&#13;
<b>          "listen": ["localhost:2020"],</b>&#13;
       <span class="CodeAnnotation">2</span><b> "routes": [{</b>&#13;
<b>              "handle": [{</b>&#13;
           <span class="CodeAnnotation">3</span><b> "handler": "static_response",</b>&#13;
<b>                  "body": "Hello, world!"</b>&#13;
<b>              }]</b>&#13;
<b>          }]</b>&#13;
<b>        }</b>&#13;
<b>      }</b>&#13;
<b>    }</b>&#13;
<b>  }</b>&#13;
<b>}'</b></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Posting configuration to Caddy’s admin endpoint</p>&#13;
<p>You send a <code>POST</code> request containing JSON in the request body <span class="CodeAnnotation">1</span> to the <code>load</code> resource of the Caddy instance listening on port 2019. The top-level <code>apps</code> namespace lists the applications Caddy will load at runtime. In this case, you’re telling Caddy to load the <code>http</code> application. The <code>http</code> application configuration consists of one or more servers. This example sets up a single server named <code>hello</code> listening on localhost port 2020. Feel free to name your server whatever you’d like.</p>&#13;
<p>Since the <code>listen</code> value is an array of addresses, you can configure this server to listen to more than one socket address. Caddy passes these address values to <code>net.Listen</code>, just as you did in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. You also have the option of specifying a port range, such as <em>localhost:2020-2025</em>. Caddy will recognize that you used a range and properly extrapolate the range into separate socket addresses. Caddy allows you to restrict listeners to specific network types by prefixing the socket address. For example, <em>udp/localhost:2020</em> tells the server to bind to UDP port 2020 on localhost. The forward slash is not part of the address but rather a separator. If you want the server to bind to a Unix socket <em>/tmp/caddy.sock</em>, specify the address <em>unix//tmp/caddy.sock</em>.</p>&#13;
<p>The <code>hello</code> server’s <code>routes</code> value <span class="CodeAnnotation">2</span> is an array of routes, like the multiplexer from the preceding chapter, which dictates how the server will handle incoming requests. If a route matches the request, Caddy passes the request onto each handler in the <code>handle</code> array. Since <code>handle</code> is an array, you can specify more than one handler per route. Caddy will pass the request to each successive handler in the same way you chained middleware together in the preceding chapter. In this example, you specify a single route to match all requests and add a single handler to this route. You’re using the built-in <code>static_response</code> handler <span class="CodeAnnotation">3</span>, which will write the value of the <code>body</code> (<code>Hello, world!</code> in this example) in the response body.</p>&#13;
<p><span epub:type="pagebreak" id="Page_222" title="222"/>Provided there are no errors in the configuration, Caddy will at once start using the new configuration. Let’s confirm Caddy is now listening on both the administrative port 2019 and your <code>hello</code> server port 2020:</p>&#13;
<pre><code>$ <b>lsof -Pi :2019-2025</b>&#13;
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME&#13;
caddy   24587 user    3u  IPv4 811511      0t0  TCP localhost:2019 (LISTEN)&#13;
caddy   24587 user    9u  IPv4 915742      0t0  TCP localhost:2020 (LISTEN)</code></pre>&#13;
<p>Looks good. This command won’t work on Windows. Instead, you can see similar output by running the <code>netstat -b</code> command in an Administrator command prompt. Now, you can ask Caddy for its configuration by sending a <code>GET</code> request:</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/</b>&#13;
{"apps":{"http":{"servers":{"hello":{"listen":["localhost:2020"],&#13;
"routes":[{"handle":[{"body":"Hello, world!","handler":"static_response"}]}]}}}}}</code></pre>&#13;
<p>Caddy returns its JSON-formatted configuration in the response body. Note that you need to write the trailing slash on the <code>/config/</code> resource, because <code>/config/</code> is the resource prefix under which Caddy exposes its configuration. You are asking Caddy for all resources found under the /<code>config/</code> prefix. If you accidentally omit the trailing slash, Caddy thinks you’re asking for an absolute resource named <code>/config</code>, which doesn’t exist in Caddy’s admin API on port 2019.</p>&#13;
<p>Caddy supports <em>configuration traversal</em>. Configuration traversal lets you request a subset of the configuration by treating each JSON key in the configuration data as a resource address. For example, you can request the <code>listen</code> value for the <code>hello</code> server from our example configuration by issuing a <code>GET</code> request, like this:</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/apps/http/servers/hello/listen</b>&#13;
["localhost:2020"]</code></pre>&#13;
<p>Caddy returns a JSON array containing <em>localhost:2020</em>, just as you’d expect. Let’s send a <code>GET</code> request to this socket address:</p>&#13;
<pre><code>$ <b>curl localhost:2020</b>&#13;
Hello, world!</code></pre>&#13;
<p>You see the <code>Hello, world!</code> string returned from the <code>static_response</code> handler.</p>&#13;
<h3 id="h2-500884c10-0005">Modifying Caddy’s Configuration in Real Time</h3>&#13;
<p class="BodyFirst">You can use the other HTTP verbs you learned in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> to modify your server’s configuration. Any changes you make will take immediate effect, so long as Caddy can parse the JSON you send. If Caddy fails to parse the JSON, or if a fundamental error exists in the new configuration, Caddy will log an error with an explanation of what went wrong and continue to use its existing configuration.</p>&#13;
<p><span epub:type="pagebreak" id="Page_223" title="223"/>Let’s say you want to make your <code>hello</code> server listen on port 2021 as well. You can append another <code>listen</code> value by using a <code>POST</code> request and immediately check that the change took effect:</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/apps/http/servers/hello/listen \</b>&#13;
<b>-X POST -H "Content-Type: application/json" -d '"localhost:2021"'</b>&#13;
$ <b>lsof -Pi :2019-2025</b>&#13;
COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME&#13;
caddy   24587 user    3u  IPv4  811511      0t0  TCP localhost:2019 (LISTEN)&#13;
caddy   24587 user    9u  IPv4  915742      0t0  TCP localhost:2020 (LISTEN)&#13;
<span class="CodeAnnotationHang">1</span> caddy   24587 user   11u  IPv4 1148212      0t0  TCP localhost:2021 (LISTEN)</code></pre>&#13;
<p>You can see that Caddy is now listening on port 2021 <span class="CodeAnnotation">1</span> in addition to ports 2019 and 2020. </p>&#13;
<p>Suppose you want to replace the listening addresses and use a range instead. For that, you can send a <code>PATCH</code> request with the new <code>listen</code> array value you want Caddy to use:</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/apps/http/servers/hello/listen \</b>&#13;
<b>-X PATCH -H "Content-Type: application/json" -d '["localhost:2020-2025"]'</b>&#13;
$ <b>lsof -Pi :2019-2025</b>&#13;
COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME&#13;
caddy   24587 user    3u  IPv4  811511      0t0  TCP localhost:2019 (LISTEN)&#13;
<span class="CodeAnnotationHang">1</span> caddy   24587 user    9u  IPv4  915742      0t0  TCP localhost:2020 (LISTEN)&#13;
caddy   24587 user   10u  IPv4 1149557      0t0  TCP localhost:2021 (LISTEN)&#13;
caddy   24587 user   11u  IPv4 1166333      0t0  TCP localhost:2022 (LISTEN)&#13;
caddy   24587 user   12u  IPv4 1169409      0t0  TCP localhost:2023 (LISTEN)&#13;
caddy   24587 user   13u  IPv4 1169413      0t0  TCP localhost:2024 (LISTEN)&#13;
<span class="CodeAnnotationHang">2</span> caddy   24587 user   14u  IPv4 1169417      0t0  TCP localhost:2025 (LISTEN)</code></pre>&#13;
<p>In addition to the admin port 2019, Caddy is now listening on ports 2020 <span class="CodeAnnotation">1</span> through 2025 <span class="CodeAnnotation">2</span>. </p>&#13;
<p>Although you may not find yourself changing Caddy’s configuration on the fly very often, it’s a handy feature for development, because it lets you quickly spin up a new server to add functionality. Let’s add a new server to Caddy while it’s running. You’ll name this new server <code>test</code> and configure it to listen on port 2030. <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a> adds the new <code>test</code> server to Caddy in real time.</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/apps/http/servers/test \</b>&#13;
<b>-X POST -H "Content-Type: application/json" \</b>&#13;
<b>-d '{</b>&#13;
<b>  "listen": ["localhost:2030"],</b>&#13;
<b>  "routes": [{</b>&#13;
<b>    "handle": [{</b>&#13;
<b>      "handler": "static_response",</b>&#13;
<b>      "body": "Welcome to my temporary test server."</b>&#13;
<b>    }]</b>&#13;
<b>  }]</b>&#13;
<b>}'</b></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: Adding a new server to Caddy in real time</p>&#13;
<p><span epub:type="pagebreak" id="Page_224" title="224"/>The name of the new server, <code>test</code>, is part of the resource you <code>POST</code> to. You can think of <code>test</code> as the key and the JSON in the request body as the value, if you defined this server in the original configuration from <a href="#listing10-1">Listing 10-1</a>. At this point, Caddy has two servers: <code>hello</code> listening on ports 2020 to 2025 and <code>test</code> listening on port 2030. To confirm Caddy is serving <code>test</code>, you can check the new endpoint on port 2030:</p>&#13;
<pre><code>$ <b>curl localhost:2030</b>&#13;
Welcome to my temporary test server.</code></pre>&#13;
<p>The <code>static_response</code> handler properly responds with the expected message. If you want to remove the <code>test</code> server, it’s as simple as issuing a <code>DELETE</code> request:</p>&#13;
<pre><code>$ <b>curl localhost:2019/config/apps/http/servers/test -X DELETE</b></code></pre>&#13;
<p>Here again, you specify the <code>test</code> server in the resource. Caddy is no longer listening on localhost port 2030, and the test server no longer exists. You were able to stand up a new server to handle entirely different requests without interrupting the functionality of your <code>hello</code> server. Changing the configuration in real time opens possibilities. Do you want a server or route to be accessible only certain times of the day? No problem. Do you want to temporarily redirect traffic without having to bounce your entire web server, interrupting existing web traffic? Sure, go ahead.</p>&#13;
<h3 id="h2-500884c10-0006">Storing the Configuration in a File</h3>&#13;
<p class="BodyFirst">We typically provide Caddy with its configuration as part of the startup process. Write the JSON configuration from <a href="#listing10-1">Listing 10-1</a> to a file named <em>caddy.json</em>. Then start Caddy by using the following command:</p>&#13;
<pre><code>$ <b>caddy start --config caddy.json</b>&#13;
Successfully started Caddy (pid=46112) - Caddy is running in the background&#13;
$ <b>curl localhost:2019/config/</b>&#13;
{"apps":{"http":{"servers":{"hello":{"listen":["localhost:2020"],&#13;
"routes":[{"handle":[{"body":"Hello, world!","handler":"static_response"}]}]}}}}}</code></pre>&#13;
<p>Caddy starts in the background, as in <a href="#listing10-1">Listing 10-1</a>—but this time, it populates its configuration from the <em>caddy.json</em> file during initialization.</p>&#13;
<h2 id="h1-500884c10-0004">Extending Caddy with Modules and Adapters</h2>&#13;
<p class="BodyFirst">Caddy uses a modular architecture to organize its functionality. This modular approach allows you to extend Caddy’s capabilities by writing your own modules and configuration adapters. In this section, we’ll walk through the process of writing a configuration adapter that will allow you to store your Caddy configuration in a Tom’s Obvious, Minimal Language (TOML) file. We’ll also replicate the <code>restrict_prefix</code> middleware from the preceding chapter in a proper Caddy module.</p>&#13;
<h3 id="h2-500884c10-0007"><span epub:type="pagebreak" id="Page_225" title="225"/>Writing a Configuration Adapter</h3>&#13;
<p class="BodyFirst">Although JSON is a perfectly good format for configuration files, it isn’t as well suited for human consumption as other formats. JSON lacks support for comments and multiline strings, two characteristics that make configuration files easier for people to read. Caddy supports the use of <em>configuration adapters</em> that adapt one format, such as TOML, to Caddy’s native JSON format. TOML is a configuration file format that is easy for humans to read. It supports both comments and multiline strings. You can find more details at <a class="LinkURL" href="https://github.com/toml-lang/toml/tree/v0.5.0/">https://github.com/toml-lang/toml/tree/v0.5.0/</a>.</p>&#13;
<p>Caddy version 1 supported a custom configuration file format named <em>Caddyfile</em>, which was also the name of the configuration file by convention. If you want to use Caddyfile with Caddy v2, you must rely on a configuration adapter so Caddy can ingest it. Caddy is smart enough to know it needs to use the <code>caddyfile</code> adapter when you specify a filename that starts with <em>Caddyfile</em>. But to specify an adapter from the command line, you explicitly tell Caddy which adapter to use:</p>&#13;
<pre><code>$ <b>caddy start --config Caddyfile --adapter caddyfile</b></code></pre>&#13;
<p>The <code>adapter</code> flag tells Caddy which adapter it should use. Caddy will invoke the adapter to adapt the configuration file to JSON and then parse the JSON returned by the adapter as if you had presented the configuration in JSON format in the first place.</p>&#13;
<p>But Caddy doesn’t ship with an official configuration adapter for TOML, so let’s take a crack at writing one. You need to first create a Go module for your TOML configuration adapter:</p>&#13;
<pre><code>$ <b>mkdir caddy-toml-adapter</b>&#13;
$ <b>cd caddy-toml-adapter</b>&#13;
<span class="CodeAnnotationHang">1</span> $ <b>go mod init github.com/awoodbeck/caddy-toml-adapter</b>&#13;
go: creating new go.mod: module github.com/awoodbeck/caddy-toml-adapter</code></pre>&#13;
<p>You should use a fully qualified module name <span class="CodeAnnotation">1</span> different from the one used here. I created this module on GitHub under my <em>awoodbeck</em> account. The fully qualified name for your module will differ depending on where, and under what account, it’s hosted.</p>&#13;
<p>Now that you’ve created a module, you can write the code. Create a file in the current directory named <em>toml.go</em> and add the code in <a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a>.</p>&#13;
<pre><code>package tomladapter&#13;
&#13;
import (&#13;
    "encoding/json"&#13;
&#13;
    "github.com/caddyserver/caddy/v2/caddyconfig"&#13;
    "github.com/pelletier/go-toml"&#13;
)&#13;
&#13;
func init() {&#13;
    caddyconfig.RegisterAdapter(<span class="CodeAnnotation">1</span>"toml", <span class="CodeAnnotation">2</span>Adapter{})&#13;
<span epub:type="pagebreak" id="Page_226" title="226"/>}&#13;
&#13;
// Adapter converts a TOML Caddy configuration to JSON.&#13;
type Adapter struct{}&#13;
&#13;
// Adapt the TOML body to JSON.&#13;
func (a Adapter) Adapt(body []byte, _ map[string]interface{}) (&#13;
    []byte, []caddyconfig.Warning, error) {&#13;
    tree, err := <span class="CodeAnnotation">3</span>toml.LoadBytes(body)&#13;
    if err != nil {&#13;
        return nil, nil, err&#13;
    }&#13;
&#13;
    b, err := json.Marshal(<span class="CodeAnnotation">4</span>tree.ToMap())&#13;
&#13;
    return b, nil, err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: Creating a TOML configuration adapter and registering it with Caddy</p>&#13;
<p>You use Thomas Pelletier’s <em>go-toml</em> library to parse the configuration file contents <span class="CodeAnnotation">3</span>. This saves a considerable amount of code. You then convert the parsed TOML into a map <span class="CodeAnnotation">4</span> and marshal the map to JSON.</p>&#13;
<p>The last bit of accounting is to register your configuration adapter with Caddy. For this, you include a call to <code>caddyconfig.RegisterAdapter</code> in the <code>init</code> function and pass it the adapter’s type <span class="CodeAnnotation">1</span> and an <code>Adapter</code> object <span class="CodeAnnotation">2</span> implementing the <code>caddyconfig.Adapter</code> interface. When you import this module from Caddy’s <em>main.go</em> file, the configuration adapter registers itself with Caddy, adding support for parsing the TOML configuration file. You’ll look at a concrete example of importing this module from Caddy in <span class="xref" itemid="xref_target_“Injecting Your Module into Caddy” on page 231">“Injecting Your Module into Caddy” on page 231</span>.</p>&#13;
<p>Now that you’ve created the <em>toml.go</em> file, tidy up the module:</p>&#13;
<pre><code>$ <b>go mod tidy</b>&#13;
go: finding module for package github.com/caddyserver/caddy/v2/caddyconfig&#13;
go: found github.com/caddyserver/caddy/v2/caddyconfig in&#13;
github.com/caddyserver/caddy/v2 v2.0.0</code></pre>&#13;
<p>This command adds the Caddy dependency to the <em>go.mod</em> file. All that’s left to do is to publish your module to GitHub, as in this example, or another suitable version-control system supported by <code>go get</code>.</p>&#13;
<h3 id="h2-500884c10-0008">Writing a Restrict Prefix Middleware Module</h3>&#13;
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> introduced the concept of middleware, a design pattern that allows your code to manipulate a request and a response and to perform ancillary tasks when the server receives a request, such as logging request details. Let’s explore how to use middleware with Caddy.</p>&#13;
<p>In Go, middleware is a function that accepts an <code>http.Handler</code> and returns an <code>http.Handler</code>:</p>&#13;
<pre><code>func(http.Handler) http.Handler</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_227" title="227"/>An <code>http.Handler</code> describes an object with a <code>ServeHTTP</code> method that accepts an <code>http.RequestWriter</code> and an <code>http.Request</code>:</p>&#13;
<pre><code>type Handler interface {&#13;
    ServeHTTP(http.ResponseWriter, *http.Request)&#13;
}</code></pre>&#13;
<p>The handler reads from the request and writes to the response. Assuming <code>myHandler</code> is an object that implements the <code>http.Handler</code> interface, and <code>middleware1</code>, <code>middleware2</code>, and <code>middleware3</code> all accept an <code>http.Handler</code> and return an <code>http.Handler</code>, you can apply the middleware functions to <code>myHandler</code> in <a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>.</p>&#13;
<pre><code>h := middleware1(middleware2(middleware3(myHandler)))</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: Multiple middleware functions wrapping a handler</p>&#13;
<p>You can replace any of the middleware functions with the <code>RestrictPrefix</code> middleware you wrote in the preceding chapter, since it’s a function that accepts an <code>http.Handler</code> and returns an <code>http.Handler</code>. </p>&#13;
<p>Unfortunately for us, Caddy’s middleware does not use this design pattern, so it cannot use <code>RestrictPrefix</code>. Caddy includes interfaces for both handlers and middleware, unlike <code>net/http</code>, which describes only handlers. Caddy’s equivalent of the <code>http.Handler</code> interface is <code>caddyhttp.Handler</code>:</p>&#13;
<pre><code>type Handler interface {&#13;
    ServeHTTP(http.ResponseWriter, *http.Request) error&#13;
}</code></pre>&#13;
<p>The only difference between <code>caddyhttp.Handler</code> and <code>http.Handler</code> is that the former’s <code>ServeHTTP</code> method returns an <code>error</code> interface.</p>&#13;
<p>Caddy middleware is a special type of handler that implements the <code>caddyhttp.MiddlewareHandler</code> interface:</p>&#13;
<pre><code>type MiddlewareHandler interface {&#13;
    ServeHTTP(http.ResponseWriter, *http.Request, Handler) error&#13;
}</code></pre>&#13;
<p>Like <code>caddyhttp.Handler</code>, Caddy’s middleware accepts both an <code>http.ResponseWriter</code> and an <code>http.Request</code>, and it returns an <code>error</code> interface. But it accepts an additional argument: the <code>caddyhttp.Handler</code>, downstream from the middleware in the same way that <code>myHandler</code> is downstream from <code>middleware3</code> in <a href="#listing10-4">Listing 10-4</a>. Instead of accepting an <code>http.Handler</code> and returning an <code>http.Handler</code>, Caddy expects its middleware to act as handlers, with access to the <code>caddyhttp.Handler</code> that should receive the request and response after the middleware is done with them.</p>&#13;
<p>Let’s create a new Caddy module that replicates the functionality of your <code>RestrictPrefix</code> middleware:</p>&#13;
<pre><code>$ <b>mkdir caddy-restrict-prefix</b>&#13;
$ <b>cd caddy-restrict-prefix</b>&#13;
<span epub:type="pagebreak" id="Page_228" title="228"/>$ <b>go mod init github.com/awoodbeck/caddy-restrict-prefix</b>&#13;
go: creating new go.mod: module github.com/awoodbeck/caddy-restrict-prefix</code></pre>&#13;
<p>As before, your fully qualified module name will differ from mine. Create a new file named <em>restrict_prefix.go</em> and add the code from <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a> to the file.</p>&#13;
<pre><code>package restrictprefix&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "net/http"&#13;
    "strings"&#13;
&#13;
    "github.com/caddyserver/caddy/v2"&#13;
    "github.com/caddyserver/caddy/v2/modules/caddyhttp"&#13;
    "go.uber.org/zap"&#13;
)&#13;
&#13;
func init() {&#13;
  <span class="CodeAnnotation">1</span>caddy.RegisterModule(RestrictPrefix{})&#13;
}&#13;
&#13;
// RestrictPrefix is middleware that restricts requests where any portion&#13;
// of the URI matches a given prefix.&#13;
type RestrictPrefix struct {&#13;
  <span class="CodeAnnotation">2</span>Prefix string `json:"prefix,omitempty"`&#13;
  <span class="CodeAnnotation">3</span>logger *zap.Logger&#13;
}&#13;
&#13;
// CaddyModule returns the Caddy module information.&#13;
func (RestrictPrefix) <span class="CodeAnnotation">4</span>CaddyModule() caddy.ModuleInfo {&#13;
    return caddy.ModuleInfo{&#13;
      <span class="CodeAnnotation">5</span>ID:  "http.handlers.restrict_prefix",&#13;
      <span class="CodeAnnotation">6</span>New: func() caddy.Module { return new(RestrictPrefix) },&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: Defining and registering a new Caddy module</p>&#13;
<p>The<code> RestrictPrefix</code> middleware implementation from the preceding chapter expected the prefix of a URL path as a string. Here, you’re storing the prefix in the <code>RestrictPrefix</code> struct <span class="CodeAnnotation">2</span> and assigning it a struct tag to use the <code>json.Unmarshal</code> behavior of matching incoming keys to struct tags. The struct tag tells <code>json.Unmarshal</code> which JSON key corresponds to this field. In this example, you’re telling <code>json.Unmarshal</code> that it should take the value associated with the <code>prefix</code> key in the JSON configuration and assign it to the struct’s <code>Prefix</code> field. The <code>RestrictPrefix</code> struct also has a <code>logger</code> field <span class="CodeAnnotation">3</span> so you can log events, as necessary.</p>&#13;
<p>Your module needs to register itself with Caddy upon initialization <span class="CodeAnnotation">1</span>. The <code>caddy.RegisterModule</code> function accepts any object that implements the <code>caddy.Module</code> interface. For that, you add the <code>CaddyModule</code> method <span class="CodeAnnotation">4</span> to return <span epub:type="pagebreak" id="Page_229" title="229"/>information to Caddy about your module. Caddy requires an ID <span class="CodeAnnotation">5</span> for each module. Since you’re creating an HTTP middleware handler, you’ll use the ID <code>http.handler.restrict_prefix</code>, where <code>restrict_prefix</code> is the unique name of your module. Caddy also expects a function <span class="CodeAnnotation">6</span> that can create a new instance of your module.</p>&#13;
<p>Now that you can register your module with Caddy, let’s add more functionality so you can retrieve the logger from Caddy and validate your module’s settings. <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a> picks up where we left off.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
// Provision a Zap logger to RestrictPrefix.&#13;
func (p *RestrictPrefix) <span class="CodeAnnotation">1</span>Provision(ctx caddy.Context) error {&#13;
    p.logger = <span class="CodeAnnotation">2</span>ctx.Logger(p)&#13;
    return nil&#13;
}&#13;
&#13;
// Validate the prefix from the module's configuration, setting the&#13;
// default prefix "." if necessary.&#13;
func (p *RestrictPrefix) <span class="CodeAnnotation">3</span>Validate() error {&#13;
    if p.Prefix == "" {&#13;
        p.Prefix = "."&#13;
    }&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Implementing various Caddy interfaces</p>&#13;
<p>You add the <code>Provision</code> method <span class="CodeAnnotation">1</span> to your struct. Caddy will recognize that your module implements the <code>caddy.Provisioner</code> interface and call this method. You can then retrieve the logger from the given <code>caddy.Context</code><span class="CodeAnnotation">2</span>. Likewise, Caddy will call your module’s <code>Validate</code> method <span class="CodeAnnotation">3</span> since it implements the <code>caddy.Validator</code> interface. You can use this method to make sure all required settings have been unmarshaled from the configuration into your module. If anything goes wrong, you can return an error and Caddy will complain on your behalf. In this example, you’re using this method to set the default prefix if one was not provided in the configuration.</p>&#13;
<p>You’re almost done. The last piece of the puzzle is the middleware implementation itself. <a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a> rounds out your module’s implementation by adding support for the <code>caddyhttp.MiddlewareHandler</code> interface.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
// ServeHTTP implements the caddyhttp.MiddlewareHandler interface.&#13;
func (p RestrictPrefix) ServeHTTP(w http.ResponseWriter, r *http.Request,&#13;
    next caddyhttp.Handler) error {&#13;
 <span class="CodeAnnotation">1</span> for _, part := range strings.Split(r.URL.Path, "/") {&#13;
        if strings.HasPrefix(part, p.Prefix) {&#13;
          <span class="CodeAnnotation">2</span>http.Error(w, "Not Found", http.StatusNotFound)&#13;
            if p.logger != nil {&#13;
              <span class="CodeAnnotation">3</span>p.logger.Debug(fmt.Sprintf(&#13;
                    "restricted prefix: %q in %s", part, r.URL.Path))&#13;
<span epub:type="pagebreak" id="Page_230" title="230"/>            }&#13;
            return nil&#13;
        }&#13;
    }&#13;
    return <span class="CodeAnnotation">4</span>next.ServeHTTP(w, r)&#13;
}&#13;
&#13;
var (&#13;
 <span class="CodeAnnotation">5</span> _ caddy.Provisioner           = (*RestrictPrefix)(nil)&#13;
    _ caddy.Validator             = (*RestrictPrefix)(nil)&#13;
    _ caddyhttp.MiddlewareHandler = (*RestrictPrefix)(nil)&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: Implementing the <var>MiddlewareHandler</var> interface</p>&#13;
<p>The logic is almost identical to the middleware from the preceding chapter. You loop through the URL path components, checking each one for the prefix <span class="CodeAnnotation">1</span>. If you find a match, you respond with a 404 Not Found status <span class="CodeAnnotation">2</span> and log the occurrence for debugging purposes <span class="CodeAnnotation">3</span>. If everything checks out, you pass control onto the next handler in the chain <span class="CodeAnnotation">4</span>.</p>&#13;
<p>It’s a good practice to guard against interface changes by explicitly making sure your module implements the expected interfaces <span class="CodeAnnotation">5</span>. If one of these interfaces happens to change in the future (for example, if you add a new method), these interface guards will cause compilation to fail, giving you an early warning that you need to adapt your code.</p>&#13;
<p>The final steps are to tidy up your module’s dependencies and publish it:</p>&#13;
<pre><code>$ <b>go mod tidy</b>&#13;
go: finding module for package github.com/caddyserver/caddy/v2&#13;
go: finding module for package github.com/caddyserver/caddy/v2/modules/caddyhttp&#13;
go: finding module for package go.uber.org/zap&#13;
go: found github.com/caddyserver/caddy/v2 in github.com/caddyserver/caddy/v2 v2.0.0&#13;
go: found go.uber.org/zap in go.uber.org/zap v1.15.0&#13;
go: downloading github.com/golang/mock v1.4.1&#13;
go: downloading github.com/onsi/gomega v1.8.1&#13;
go: downloading github.com/smallstep/assert v0.0.0-20200103212524-b99dc1097b15&#13;
go: downloading github.com/onsi/ginkgo v1.11.0&#13;
go: downloading github.com/imdario/mergo v0.3.7&#13;
go: downloading github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1&#13;
go: downloading github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b&#13;
go: downloading github.com/alangpierce/go-forceexport v0.0.0-20160317203124-&#13;
8f1d6941cd75&#13;
go: downloading github.com/chzyer/logex v1.1.10&#13;
go: downloading github.com/hpcloud/tail v1.0.0&#13;
go: downloading gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7&#13;
go: downloading gopkg.in/fsnotify.v1 v1.4.7</code></pre>&#13;
<p>Publish your module to GitHub or a similar version-control system supported by <code>go get</code>.</p>&#13;
<h3 id="h2-500884c10-0009"><span epub:type="pagebreak" id="Page_231" title="231"/>Injecting Your Module into Caddy</h3>&#13;
<p class="BodyFirst">The module and adapter you wrote are both self-registering. All you need to do to include their functionality in Caddy is to import them at build time. To do that, you need to compile Caddy from source. Start by making a directory for your build:</p>&#13;
<pre><code>$ <b>mkdir caddy</b>&#13;
$ <b>cd caddy</b></code></pre>&#13;
<p>Building Caddy from source code requires a small amount of boilerplate code, to which you’ll include your modules. Your modules register themselves with Caddy as a side effect of the import. Create a new file named <em>main.go</em> and add the code from <a href="#listing10-8" id="listinganchor10-8">Listing 10-8</a> into it.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
 <span class="CodeAnnotation">1</span> cmd "github.com/caddyserver/caddy/v2/cmd"&#13;
 <span class="CodeAnnotation">2</span> _ "github.com/caddyserver/caddy/v2/modules/standard"&#13;
&#13;
    // Injecting custom modules into Caddy&#13;
 <span class="CodeAnnotation">3</span> _ "github.com/awoodbeck/caddy-restrict-prefix"&#13;
 <span class="CodeAnnotation">4</span> _ "github.com/awoodbeck/caddy-toml-adapter"&#13;
)&#13;
&#13;
func main() {&#13;
    cmd.Main()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: Injecting custom modules into Caddy</p>&#13;
<p>First, you import the Caddy command module <span class="CodeAnnotation">1</span> into your build. This has the <code>Main</code> function that starts the caddy server. Then, you import the standard modules <span class="CodeAnnotation">2</span> that you’ll find in Caddy’s binary distribution. Finally, you include your restrict prefix module <span class="CodeAnnotation">3</span> and your TOML configuration adapter <span class="CodeAnnotation">4</span>.</p>&#13;
<p>All that’s left to do now is initialize the <code>caddy</code> module and build it:</p>&#13;
<pre><code>$ <b>go mod init caddy</b>&#13;
$ <b>go build</b></code></pre>&#13;
<p>At this point, you should have a binary named <code>caddy</code> in the current directory. You can verify that it has your custom imports by looking for them in the <code>caddy</code> binary’s list of modules. The following command is specific to Linux and macOS:</p>&#13;
<pre><code>$ <b>./caddy list-modules | grep "toml\|restrict_prefix"</b>&#13;
caddy.adapters.toml&#13;
http.handlers.restrict_prefix</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_232" title="232"/>For my Windows friends, run this command instead:</p>&#13;
<pre><code>&gt; <b>caddy list-modules | findstr "toml restrict_prefix"</b>&#13;
caddy.adapters.toml&#13;
http.handlers.restrict_prefix</code></pre>&#13;
<p>The <code>caddy</code> binary you built can read its configuration from TOML files and deny clients access to resources whose path includes a given prefix.</p>&#13;
<h2 id="h1-500884c10-0005">Reverse-Proxying Requests to a Backend Web Service</h2>&#13;
<p class="BodyFirst">You now have all the building blocks to create something meaningful in Caddy. Let’s put everything you’ve learned together by configuring Caddy to reverse-proxy requests to a backend web service and serve up static files on behalf of the backend web service. You’ll create two endpoints in Caddy. The first endpoint will serve up only static content from Caddy’s file server, showing Caddy’s static file-serving abilities. The second endpoint will reverse-proxy requests to a backend web service. This backend service will send the client HTML that will prompt the client to retrieve static files from Caddy, which will show how your web services can lean on Caddy to serve static content on their behalf.</p>&#13;
<p>Before you start building, you need to set up the proper directory structure. If you’re following along, you’re currently in the <em>caddy</em> directory, which has a <code>caddy</code> binary built from the code in <a href="#listing10-8">Listing 10-8</a>. Create two subdirectories, <em>files</em> and <em>backend</em>:</p>&#13;
<pre><code>$ <b>mkdir files backend</b></code></pre>&#13;
<p>You can retrieve the contents of the <em>files</em> subdirectory from <a class="LinkURL" href="https://github.com/awoodbeck/gnp/tree/master/ch10/files/">https://github.com/awoodbeck/gnp/tree/master/ch10/files/</a>. The <em>backend</em> subdirectory will store a simple backend service created in the next section.</p>&#13;
<h3 id="h2-500884c10-0010">Creating a Simple Backend Web Service</h3>&#13;
<p class="BodyFirst">You need a backend web service for Caddy to reverse-proxy requests to, as illustrated in <a href="#figure10-1">Figure 10-1</a>. This service will respond to all requests with an HTML document that includes the static files Caddy serves on the service’s behalf.</p>&#13;
<p><a href="#listing10-9" id="listinganchor10-9">Listing 10-9</a> is the initial code for the backend web service.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
    "fmt"&#13;
    "log"&#13;
    "net/http"&#13;
    "os"&#13;
    "os/signal"&#13;
    "time"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_233" title="233"/>var addr = flag.String("listen", <span class="CodeAnnotation">1</span>"localhost:8080", "listen address")&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    c := make(chan os.Signal, 1)&#13;
    signal.Notify(c, os.Interrupt)&#13;
&#13;
    err := <span class="CodeAnnotation">2</span>run(*addr, c)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    log.Println("Server stopped")&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-9">Listing 10-9</a>: Creating a backend service (<em>backend/main.go</em>)</p>&#13;
<p>This bit of code should be familiar since it’s a simplified version of what you wrote in the preceding chapter. You’re setting up a web service that listens on port 8080 of localhost <span class="CodeAnnotation">1</span>. Caddy will direct requests to this socket address. <a href="#listing10-10" id="listinganchor10-10">Listing 10-10</a> implements the <code>run</code> function <span class="CodeAnnotation">2</span>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func run(addr string, c chan os.Signal) error {&#13;
    mux := http.NewServeMux()&#13;
    mux.Handle("/",&#13;
        http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#13;
            clientAddr := r.Header.Get(<span class="CodeAnnotation">1</span>"X-Forwarded-For")&#13;
            log.Printf("%s -&gt; %s -&gt; %s", clientAddr, r.RemoteAddr, r.URL)&#13;
            _, _ = w.Write(<span class="CodeAnnotation">2</span>index)&#13;
        }),&#13;
    )&#13;
&#13;
    srv := &amp;http.Server{&#13;
        Addr:              addr,&#13;
        Handler:           mux,&#13;
        IdleTimeout:       time.Minute,&#13;
        ReadHeaderTimeout: 30 * time.Second,&#13;
    }&#13;
&#13;
    go func() {&#13;
        for {&#13;
            if &lt;-c == os.Interrupt {&#13;
                _ = srv.Close()&#13;
                return&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
    fmt.Printf("Listening on %s ...\n", srv.Addr)&#13;
    err := srv.ListenAndServe()&#13;
&#13;
<span epub:type="pagebreak" id="Page_234" title="234"/>    if err == http.ErrServerClosed {&#13;
        err = nil&#13;
    }&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-10">Listing 10-10</a>: The main logic of the backend service (<em>backend/main.go</em>)</p>&#13;
<p>The web service receives all requests from Caddy, no matter which client originated the request. Likewise, it sends all responses back to Caddy, which then routes the response to the right client. Conveniently, Caddy adds an <code>X-Forwarded-For</code> header <span class="CodeAnnotation">1</span> to each request with the originating client’s IP address. Although you don’t do anything other than log this information, your backend service could use this IP address to differentiate between client requests. The service could deny requests based on client IP address, for example.</p>&#13;
<p>The handler writes a slice of bytes <span class="CodeAnnotation">2</span> to the response that has HTML defined in <a href="#listing10-11" id="listinganchor10-11">Listing 10-11</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
var index = []byte(`&lt;!DOCTYPE html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
    &lt;meta charset="UTF-8"&gt;&#13;
    &lt;title&gt;Caddy Backend Test&lt;/title&gt;&#13;
    &lt;link href=<span class="CodeAnnotation">1</span>"/style.css" rel="stylesheet"&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
    &lt;p&gt;&lt;img src=<span class="CodeAnnotation">2</span>"/hiking.svg" alt="hiking gopher"&gt;&lt;/p&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;`)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-11">Listing 10-11</a>: The index HTML served by the backend service (<em>backend/main.go</em>)</p>&#13;
<p>The <code>/style.css</code><span class="CodeAnnotation">1</span> and <code>/hiking.svg</code><span class="CodeAnnotation">2</span> resources do not include a full URL (such as <a class="LinkURL" href="http://localhost:2020/style.css">http://localhost:2020/style.css</a>) because the backend web service does not know anything about Caddy or how clients access Caddy. When you exclude the scheme, hostname, and port number in the resource address, the client’s web browser should encounter <code>/style.css</code> in the HTML and prepend the scheme, hostname, and port number it used for the initial request before sending the request to Caddy. For that all to work, you need to configure Caddy in the next section to send some requests to the backend web service and serve static files for the rest of the requests. </p>&#13;
<h3 id="h2-500884c10-0011">Setting Up Caddy’s Configuration</h3>&#13;
<p class="BodyFirst">As mentioned earlier in the chapter, Caddy uses JSON as its native configuration format. You could certainly write your configuration in JSON, but you’ve already written a perfectly good configuration adapter that allows you to use TOML, so you’ll implement that instead. </p>&#13;
<p><span epub:type="pagebreak" id="Page_235" title="235"/>You want to configure Caddy to reverse-proxy requests to your backend web service and serve static files from the <em>files</em> subdirectory. You’ll need two routes: one to the backend web service and one for static files. Let’s start by defining your server configuration in a file named <em>caddy.toml</em> (<a href="#listing10-12" id="listinganchor10-12">Listing 10-12</a>).</p>&#13;
<pre><code><span class="CodeAnnotationHang">1</span> [apps.http.servers.test_server]&#13;
listen = [&#13;
    'localhost:2020',&#13;
]</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-12">Listing 10-12</a>: Caddy test server configuration (<em>caddy.toml</em>)</p>&#13;
<p>Your TOML adapter directly converts TOML to JSON. Therefore, you need to make sure you’re using the same namespaces Caddy expects. The namespace for your server is <code>apps.http.servers.test_server</code><span class="CodeAnnotation">1</span>. (For simplicity, you’ll refer to this namespace simply as <code>test_server</code> from here on out.) It listens for incoming connections on port 2020 of localhost.</p>&#13;
<h3 id="h2-500884c10-0012">Adding a Reverse-Proxy to Your Service</h3>&#13;
<p class="BodyFirst">Caddy includes a powerful reverse-proxy handler that makes quick work of sending incoming requests to your backend web service. Just as in the server implementation in the preceding chapter, Caddy matches an incoming request to a route and then passes the request onto the associated handler.</p>&#13;
<p><a href="#listing10-13" id="listinganchor10-13">Listing 10-13</a> adds a route and a reverse-proxy handler to the <em>caddy.toml</em> file.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> [[apps.http.servers.test_server.routes]]&#13;
<span class="CodeAnnotationHang">2</span> [[apps.http.servers.test_server.routes.match]]&#13;
path = [&#13;
    '/backend',&#13;
 <span class="CodeAnnotation">3</span> '/backend/*',&#13;
]&#13;
<span class="CodeAnnotationHang">4</span> [[apps.http.servers.test_server.routes.handle]]&#13;
handler = 'reverse_proxy'&#13;
<span class="CodeAnnotationHang">5</span> [[apps.http.servers.test_server.routes.handle.upstreams]]&#13;
dial = <span class="CodeAnnotation">6</span>'localhost:8080'</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-13">Listing 10-13</a>: Adding a reverse proxy to the backend service (<em>caddy.toml</em>)</p>&#13;
<p>The <code>test_server</code> configuration includes a <code>routes</code> array <span class="CodeAnnotation">1</span>, and each route in the array has zero or more matchers <span class="CodeAnnotation">2</span>. A <em>matcher</em> is a special module that allows you to specify matching criteria for incoming requests, like the <code>http.ServeMux.Handle</code> method’s pattern matching discussed in the preceding chapter. Caddy includes matcher modules that allow you to consider each part of a request.</p>&#13;
<p>For this route, you add a single matcher that matches any request for the absolute path <em>/backend</em> or any path starting with <em>/backend/</em><span class="CodeAnnotation">3</span>. The <em>*</em> character is a wildcard that tells Caddy you want to match on the <em>/backend/</em> prefix. For example, a request for the resource <em>/backend/this/is/a/test</em> will also match.</p>&#13;
<p><span epub:type="pagebreak" id="Page_236" title="236"/>The route may have one or more handlers <span class="CodeAnnotation">4</span>. Here, you tell Caddy you want to send all matching requests to the reverse-proxy handler. The reverse-proxy handler needs to know where to send the requests. You specify an upstream entry <span class="CodeAnnotation">5</span> with its dial property set to the backend server’s socket address <span class="CodeAnnotation">6</span>.</p>&#13;
<h3 id="h2-500884c10-0013">Serving Static Files</h3>&#13;
<p class="BodyFirst">You relied on the <code>http.FileServer</code> to serve static files for you in the preceding chapter. Caddy exposes similar functionality with its <code>file_server</code> handler. <a href="#listing10-14" id="listinganchor10-14">Listing 10-14</a> adds a second route to your <em>caddy.toml</em> file for serving static files.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
<span class="CodeAnnotationHang">1</span> [[apps.http.servers.test_server.routes]]&#13;
<span class="CodeAnnotationHang">2</span> [[apps.http.servers.test_server.routes.handle]]&#13;
handler = 'restrict_prefix'&#13;
prefix = '.'&#13;
<span class="CodeAnnotationHang">3</span> [[apps.http.servers.test_server.routes.handle]]&#13;
handler = 'file_server'&#13;
root = <span class="CodeAnnotation">4</span>'./files'&#13;
index_names = [&#13;
  <span class="CodeAnnotation">5</span>'index.html',&#13;
]</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing10-14">Listing 10-14</a>: Adding a default route to serve static files (<em>caddy.toml</em>)</p>&#13;
<p>Unlike the route you added in <a href="#listing10-13">Listing 10-13</a>, this route <span class="CodeAnnotation">1</span> does not include any matchers. As such, Caddy would send every request to this route’s handler if the request didn’t match previous routes. In other words, this route is your default route, and so its position in the file matters. If you moved this route before the reverse-proxy route, all requests would match it, and no requests would ever make their way to the reverse proxy. Whenever you specify a route with no matches, make sure you put it at the end of your routes array, as you do here.</p>&#13;
<p>As with the file server in the preceding chapter, you want to protect against accidentally serving sensitive files prefixed with a period. Therefore, you include your <code>restrict_prefix</code> middleware <span class="CodeAnnotation">2</span> in the array of handlers before the <code>file_server</code> handler <span class="CodeAnnotation">3</span>. You add more configuration options to serve files found in the <em>files</em> subdirectory <span class="CodeAnnotation">4</span> and return the <em>index.html</em> file <span class="CodeAnnotation">5</span> if the request didn’t specify a file.</p>&#13;
<h3 id="h2-500884c10-0014">Checking Your Work</h3>&#13;
<p class="BodyFirst">Everything is in place. Start Caddy and verify that your configuration works as expected. Since some of the static files are images, I recommend you use a web browser to interact with Caddy while it runs on your computer.</p>&#13;
<p>Start Caddy by using the <em>caddy.toml</em> file and the <em>toml</em> adapter:</p>&#13;
<pre><code>$ <b>./caddy start --config caddy.toml --adapter toml</b></code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_237" title="237"/>On Windows, the command looks like this:</p>&#13;
<pre><code>&gt; <b>caddy start --config caddy.toml --adapter toml</b></code></pre>&#13;
<p>Now, run the backend web service:</p>&#13;
<pre><code>$ <b>cd backend</b>&#13;
$ <b>go run backend.go</b>&#13;
Listening on localhost:8080 ...</code></pre>&#13;
<p>Open your web browser and visit <a class="LinkURL" href="http://localhost:2020/">http://localhost:2020/</a>. Caddy will send your request to the file server handler, which in turn will respond with the <em>index.html</em> file, since you didn’t indicate a specific file in the request. Your browser then asks Caddy for the <em>style.css</em> and <em>sage.svg</em> files to finish rendering the page. If everything succeeds, you should now be looking at a sage gopher.</p>&#13;
<p>Now, let’s test the reverse proxy to the backend web service. Visit <a class="LinkURL" href="http://localhost:2020/backend">http://localhost:2020/backend</a>. This request matches the reverse-proxy route’s matcher, so the reverse-proxy handler should handle it, sending the request onto the backend service. The backend web service responds with HTML that instructs your browser to retrieve the <em>style.css</em> and <em>hiking.svg</em> files from Caddy, where the file server handler happily serves them up. You should now be looking at a hiking gopher rendered using HTML from the backend web service and static files from Caddy.</p>&#13;
<p>If you copied the <em>files</em> subdirectory from this book’s source code repository, it should contain <em>./files/.secret</em> and <em>./files/.dir/secret</em> files. Your middleware should block access to both files. In other words, both <a class="LinkURL" href="http://localhost:2020/files/.secret">http://localhost:2020/files/.secret</a> and <a class="LinkURL" href="http://localhost:2020/files/.dir/secret">http://localhost:2020/files/.dir/secret</a> will return a 404 Not Found status if you try to request them.</p>&#13;
<h3 id="h2-500884c10-0015">Adding Automatic HTTPS</h3>&#13;
<p class="BodyFirst">Now let’s add Caddy’s key feature to your web server: automatic HTTPS. </p>&#13;
<p>I once used Caddy to stand up a website with full HTTPS support, using certificates trusted by all contemporary web browsers, in a matter of minutes. The server has been rock-solid ever since, happily rotating Let’s Encrypt keys every few months with no intervention on my part. This isn’t to say I couldn’t replicate this functionality in my own Go-based web server; my time was simply best spent building services and leaving the web serving to Caddy. If Caddy lacked any functionality, I could add it as a module.</p>&#13;
<p>Caddy automatically enables TLS when it can determine what domain names you’ve configured it to serve. The <em>caddy.toml</em> configuration created in this chapter didn’t give Caddy enough information to determine which domain it was serving. Therefore, Caddy didn’t enable HTTPS for you. You told Caddy to bind to localhost, but that tells Caddy only what it’s listening to, not what domains it’s serving.</p>&#13;
<p><span epub:type="pagebreak" id="Page_238" title="238"/>The most common way to enable automatic HTTPS is by adding a host matcher to one of Caddy’s routes. Here’s an example matcher:</p>&#13;
<pre><code>[[apps.http.servers.server.routes.match]]&#13;
host = [&#13;
    'example.com',&#13;
]</code></pre>&#13;
<p>This host matcher supplies enough information for Caddy to determine that it is serving the <em>example.com</em> domain. If Caddy doesn’t already have a valid certificate for <em>example.com</em> to enable HTTPS, it will go through the process of validating the domain with Let’s Encrypt and retrieving a certificate. Caddy will manage your certificate, automatically renewing it, as necessary.</p>&#13;
<p>Caddy’s <code>file-server</code> subcommand tells Caddy you want it to exclusively serve files over HTTP. The <code>file-server</code>’s <code>--domain</code> flag is enough information for Caddy to invoke its automatic HTTPS and allow you to serve files over HTTPS as well.</p>&#13;
<p>Caddy’s <code>reverse-proxy</code> subcommand allows you to put Caddy into a reverse-proxy-only mode, where it will send all incoming requests onto the socket address specified by the <code>--to</code> flag. Caddy will retrieve a TLS certificate and enable automatic HTTPS if you specify a hostname with the <code>--from</code> flag. </p>&#13;
<p>I encourage you to read more about Caddy’s automatic HTTPS in production environments at <a class="LinkURL" href="https://caddyserver.com/docs/automatic-https">https://caddyserver.com/docs/automatic-https</a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Caddy defaults to using Let’s Encrypt as its certificate authority for non-localhost names and IP addresses. But Caddy supports its own internal certificate authority for enabling HTTPS over localhost, which you may want to do for testing purposes. If you specify <em>localhost</em> as your hostname in the earlier settings to enable automatic HTTPS, Caddy will use its internal certificate authority for its TLS certificate. It will also try to install its root certificate in your operating system’s root certificate trust store, which is where your operating system keeps track of all root certificates it inherently trusts.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-500884c10-0006">What You’ve Learned</h2>&#13;
<p class="BodyFirst">Caddy is a contemporary web server written in Go that offers security, performance, and extensibility through modules and configuration adapters. Caddy can automatically use HTTPS through its integration with Let’s Encrypt, a nonprofit certificate authority that supplies free digital certificates. Together, Caddy and Let’s Encrypt allow you to stand up a web server with seamless HTTPS support.</p>&#13;
<p>Caddy uses JSON as its native configuration format, and it exposes an API on localhost port 2019 that allows you to post JSON to change its configuration. The configuration changes take immediate effect. But since JSON isn’t an ideal configuration format, Caddy makes use of configuration adapters. Configuration adapters translate configuration files from more configuration-friendly formats, like TOML, to JSON. If you don’t want to <span epub:type="pagebreak" id="Page_239" title="239"/>use JSON for your Caddy configuration or if you don’t find a configuration adapter that meets your needs, you can also write your own, as you did in this chapter.</p>&#13;
<p>You can also extend Caddy’s functionality with the use of modules. This chapter shows how to write a middleware module, compile it into Caddy, configure the module, and put it to effective use.</p>&#13;
<p>Finally, this chapter showed you how to integrate Caddy into your network architecture. You’ll often make Caddy the first server in your network, using it to receive client requests before sending the requests onto their final destinations. In this chapter, you configured an instance of Caddy to reverse-proxy client requests to your backend web service and serve static files on behalf of the backend web service. As a result, you kept your backend web service as simple as possible and saved it from having to manage its static content. Your backend web service can use Caddy for HTTPS support, caching, and file serving. </p>&#13;
<p>Now that you have some experience with Caddy, you should be able to determine whether your web services would do better when served by a comprehensive web server solution or a comparatively minimal <code>net/http</code> web server implementation. If you expect to make your web service available to the public, using a proven web server like Caddy at the edge of your application will free up time you can better spend on your backend web service.</p>&#13;
</section>&#13;
</body></html>