<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ENUMERATING OPERATING SYSTEM ARTIFACTS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">A normal, “real” user environment looks much different from a malware sandbox or lab environment. A typical user will likely have installed common applications, such as Microsoft Office, email clients, multiple web browsers, and so on. They probably wouldn’t be using a VM, Wireshark, or Procmon, nor are they likely to have installed malware analysis tools such as IDA Pro or sandboxing tools like Cuckoo. A sandbox or lab environment, on the other hand, typically has analysis software installed in a VM.</p>&#13;
<p class="TNI1">This is indicated by references to the hypervisor in the names and properties of various <i>operating system artifacts</i>, such as the currently running processes, configured registry keys, and installed devices and drivers. Malware can extract this information to understand its environment, choose its <span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/>target, and decide whether or not to execute its payload on the host. This is known as <i>enumeration</i>.</p>&#13;
<p class="TX">In this chapter, I’ll walk you through enumeration techniques for several OS artifacts and explain how malware might use the information it gathers to identify an analysis environment or inappropriate target. Many of the techniques we’ll explore in this and the next few chapters can be circumvented by a specially tuned malware analysis environment, which we’ll discuss in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-53"/><samp class="SANS_Futura_Std_Bold_B_11">Processes</samp></h3>&#13;
<p class="TNI1">Malware can use process enumeration techniques to detect VMs and sandboxes and better understand its operating environment. The primary Windows API functions that malware may use to enumerate processes are <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>. The following malware sample excerpt enumerates running processes on a host to look for the target process <i>VboxTray.exe</i>, which is common in some VirtualBox VMs:</p>&#13;
<pre class="pre-13"><code><span class="CodeAnnotationHang">1</span> call  CreateToolhelp32Snapshot&#13;
<var>--snip--</var>&#13;
loc_2:&#13;
lea   ecx, [esp+peInfo]&#13;
<span class="CodeAnnotationHang">2</span> push  ecx // Pointer to buffer (peInfo)&#13;
push  eax // Handle to snapshot&#13;
call  Process32First&#13;
<span class="CodeAnnotationHang">3</span> test  [esp+peInfo.szExeFile], vboxtray_process_name&#13;
jz    loc_3&#13;
<var>--snip--</var>&#13;
loc_3:&#13;
lea   ecx, [esp+peInfo]&#13;
<span class="CodeAnnotationHang">4</span> push  ecx // Pointer to buffer (peInfo)&#13;
push  eax // Handle to snapshot&#13;
call  Process32Next&#13;
test  [esp+peInfo.szExeFile], vboxtray_process_name&#13;
<span class="CodeAnnotationHang">5</span> jz    loc_3 // Loop</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp> function creates a snapshot of the processes running on the victim’s host and returns a handle to it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This handle is pushed to the stack, along with a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo</samp> buffer, which will store the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> outputs information about the first process running on the host, <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo.szExeFile</samp>. After calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, the malware compares <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo.szExeFile</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">vboxtray_process_name</samp> variable, which was previously defined as <samp class="SANS_TheSansMonoCd_W5Regular_11">"VboxTray.exe"</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (This variable assignment isn’t shown in the code snippet.) If the process names don’t match, the program jumps to the next area of code.</p>&#13;
<p class="TX">Both the pointer to the buffer and the process snapshot handle are again pushed to the stack to prepare for the next function: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which does exactly the same thing as <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> but will iterate over the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/>remaining processes running on the system. After the next process is enumerated and stored in the buffer, the malware does another comparison to the <samp class="SANS_TheSansMonoCd_W5Regular_11">vboxtray_process_name</samp> variable. This time, if the names don’t match, the code will loop to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> again, repeating until it enumerates all processes or finds the target process <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If you’re analyzing malware and you spot it enumerating the process list and checking for a specific process name such as <i>VboxTray.exe</i> or <i>Vmtoolsd.exe</i>, it should raise a red flag. Here are some of the common VM-related process names malware might be targeting:</p>&#13;
<p class="ListHead"><b>VMware</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>TPAutoConnSvc.exe</i></li>&#13;
<li class="BL"><i>VGAuthService.exe</i></li>&#13;
<li class="BL"><i>VMwareService.exe</i></li>&#13;
<li class="BL"><i>Vm3dservice.exe</i></li>&#13;
<li class="BL"><i>Vmtoolsd.exe</i></li>&#13;
<li class="BL"><i>Vmwaretray.exe</i></li>&#13;
<li class="BL"><i>Vmwareuser.exe</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>VboxControl.exe</i></li>&#13;
<li class="BL"><i>VBoxService.exe</i></li>&#13;
<li class="BL"><i>VboxTray.exe</i></li>&#13;
</ul>&#13;
<p class="TX">Some malware variants also search for typical malware analysis tools (such as Procmon, Wireshark, Process Explorer, and Fiddler), which may be running on the analyst’s workstation at the time of detonation. If the malware finds any of the following example processes running on the system, it may decide to terminate itself or take other evasive actions:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>autoruns.exe</i></li>&#13;
<li class="BL"><i>fiddler.exe</i></li>&#13;
<li class="BL"><i>ollydbg.exe</i></li>&#13;
<li class="BL"><i>procexp.exe</i></li>&#13;
<li class="BL"><i>procmon.exe</i></li>&#13;
<li class="BL"><i>tcpview.exe</i></li>&#13;
<li class="BL"><i>wireshark.exe</i></li>&#13;
<li class="BL"><i>x64dbg.exe</i></li>&#13;
</ul>&#13;
<p class="TX">Oftentimes, you can simply rename the executable file for these tools before running the process. For example, renaming <i>procmon.exe</i> to <i>nomcorp.exe</i> may evade basic malware checks. This trick won’t work for malware that looks at the window title bar, however.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/>When enumerating and searching for specific process names, some malware will use hashed names instead of cleartext strings so that its target won’t be readily apparent to the malware analyst. For example, the MD5 hash sum of the process name <i>fiddler.exe</i> is 447c259d51c2d1cd320e71e6390b8495, so if you were debugging a particular malware sample or inspecting it in a disassembler, you might notice the string <samp class="SANS_TheSansMonoCd_W5Regular_11">447c259d51c2d1cd320e71e6390b8495</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">fiddler.exe</samp>. You can see how this would slow down analysis and possibly stump an inexperienced analyst.</p>&#13;
<p class="TX">Hashing in this way will be covered in more depth in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a>.</span> For now, just keep in mind that you might not see nice, cleartext process names when analyzing a malware sample; always be aware of possible hashing. This is true not only for processes but also for filenames, services, and other strings that the malware may be searching for.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-54"/><samp class="SANS_Futura_Std_Bold_B_11">Directories and Files</samp></h3>&#13;
<p class="TNI1">Enumerating directories and files is another technique malware can use to detect sandboxes and VMs. Malware may search for specific files and directories associated with hypervisor software (such as VMware Workstation and VirtualBox) or with automated malware sandboxes (such as Cuckoo).</p>&#13;
<p class="TX">The following snippet shows a malware sample calling <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> with <i>C:\Windows\System32\drivers\vm*</i> as a target. The sample is searching the Windows <i>drivers</i> directory for any driver files with a prefix of <i>vm</i>, which is a common pattern for VMware Workstation driver files:</p>&#13;
<pre class="pre-14"><code>call  FindFirstFileW&#13;
test  [ebp+FindFileData.cFileName], fileName ; "C:\Windows\System32\drivers\vm*"&#13;
jz    loc_2&#13;
<var>--snip--</var>&#13;
loc_2:&#13;
<var>--snip--</var>&#13;
call  FindNextFileW&#13;
test  [ebp+FindFileData.cFileName], fileName&#13;
jz    loc_2</code></pre>&#13;
<p class="TX">After the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction compares the value of the returned filename to <i>C:\Windows\System32\drivers\vm*</i>. If the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (meaning there’s no match), the code jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>, which contains the next function call, <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> executes, and the same <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction compares the filenames. If the test instruction returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the program jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp> again. <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> will continue to execute until there’s a match or there are no more files.</p>&#13;
<p class="TX">While file enumeration in malware is very common for many reasons, the presence of <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> could mean the malware sample may be attempting to detect an analysis environment. VMware <span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/>Workstation and VirtualBox file and directory paths that malware might target include the following:</p>&#13;
<p class="ListHead"><b>VMware files</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Windows\System32\drivers\vm*</i></li>&#13;
<li class="BL"><i>C:\Windows\System32\vm*</i></li>&#13;
<li class="BL"><i>C:\Windows\SysWOW64\vm*</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VMware directories</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Program Files\VMware\</i></li>&#13;
<li class="BL"><i>C:\Program Files\Common Files\VMware\</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox files</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Windows\System32\VBox*</i></li>&#13;
<li class="BL"><i>C:\Windows\System32\drivers\VBox*</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox directories</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Program Files\Oracle\VirtualBox Guest Additions\</i></li>&#13;
</ul>&#13;
<p class="TX">Similar to VMs, automated sandbox environments often contain specific folders and files that malware may find suspicious. Many Cuckoo installations, for example, contain several scripts and files like <i>Analyzer.py</i> and <i>analysis.conf</i>. Some Cuckoo versions may even have a directory called <i>cuckoo</i> or <i>agent</i> under the <i>C:\</i> directory path. Keep this in mind when analyzing evasive malware in an automated malware analysis sandbox.</p>&#13;
<p class="TX">Finally, malware can use directories and file enumeration to identify its operating environment and profile its target. For example, if a malware sample is targeting a certain organization or type of system, it might enumerate the filesystem to look for specific directories and files containing the target company name. This check would allow the malware to infect only systems in the scope of its attack. A good example of such a system is Stuxnet, mentioned in the <span class="Xref">introduction</span>. As part of its exploitation tactics, Stuxnet searches for several files related to the Siemens Step7 software on the victim host. If these files don’t exist, the system will not be infected.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Some of these files and directories can be renamed or even removed without affecting the VM environment. I’ll discuss this in more detail in <a href="appendix-A.xhtml">Appendix A</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_B_11">Shared Folders</samp></h3>&#13;
<p class="TNI1">To share files between VMs and the host OS, an analyst can configure <i>shared folders</i>. But while shared folders allow easy transfer of files from the host to the guest and vice versa, they also give malware another clue that it’s being analyzed.</p>&#13;
<p class="TX">Malware can enumerate shared folders by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNetGetProviderName</samp> Windows API function, which retrieves network resource information. As VM shared folders are effectively network resources, calling this function on a VirtualBox VM configured with shared folders may return a result of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/><samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualBox Shared Folders</samp>, for example, which is a dead giveaway that this machine is hosted on a VirtualBox hypervisor.</p>&#13;
<p class="TX">Additionally, because VM shared folders function like network drives, they can be identified via normal file and folder enumeration functions, such as the previously discussed <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>. The target path for these functions would be the name of the VM network drive. Some common network drive names are <i>\\VboxSrv</i> (for VirtualBox) and <i>\\vmware-host</i> (for VMware Workstation).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp></h3>&#13;
<p class="TNI1">The Windows registry contains information about installed software, hardware configurations, the network, language and location settings, and many other data points that Windows uses to function. As a result, malware attempting to understand the target environment or detect a VM or sandbox will often query the registry. It might enumerate entire hives of the registry and search for suspect VM-related strings, or it might simply inspect a few keys of specific interest. The following excerpt shows how this might look in an actual malware sample:</p>&#13;
<pre class="pre-15"><code>xor   r8d, r8d    ; ulOptions&#13;
mov   r9d, ebx    ; samDesired&#13;
<span class="CodeAnnotationHang">1</span> mov   rdx, r15    ; lpSubKey ("HKLM:\HARDWARE\Description\System")&#13;
mov   rcx, r13    ; hKey&#13;
mov   [rsp+70h+phkResult], rax ; lpReserved&#13;
<span class="CodeAnnotationHang">2</span> call  RegOpenKeyExA&#13;
test  eax, eax&#13;
jz    short loc_180018C24&#13;
<var>--snip--</var>&#13;
<span class="CodeAnnotationHang">3</span> mov   [rsp+70h+lpData], r14 ; lpData&#13;
mov   [rsp+70h+lpType], rax ; lpType&#13;
and   [rsp+70h+phkResult], 0&#13;
lea   r9, [rbp+cchValueName] ; lpcchValueName&#13;
<span class="CodeAnnotationHang">4</span> mov   r8, rsi     ; lpValueName&#13;
mov   edx, r15d   ; dwIndex&#13;
<span class="CodeAnnotationHang">5</span> call  RegEnumValueA&#13;
cmp   eax, 0EAh ; 'ê'&#13;
jz    short loc_180018D03&#13;
<var>--snip--</var>&#13;
<span class="CodeAnnotationHang">6</span> cmp   [rsp+70h+lpData], suspect_value ; "VBOX -1"&#13;
je    terminate_process</code></pre>&#13;
<p class="TX">The malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey</samp> to open a specific key of interest, followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumValue</samp> function to enumerate all values and data under this registry key. Let’s break this code down a bit more.</p>&#13;
<p class="TX">First, the malware moves the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpSubKey</samp> value, which represents the registry key it’s interested in, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp> register <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In this case, this registry key is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp>. The value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp> register is used as a parameter for the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, the code loads pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpData</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValueName</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> structures. Then, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/>it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumValueA</samp> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, which stores the returned values and data for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp> registry key in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValueName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpData</samp>, respectively.</p>&#13;
<p class="TX">Typically, malware will call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp> multiple times in a loop, as each iteration of <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp> stores only one value and data item. For simplicity’s sake, I included only one call to this function in the code.</p>&#13;
<p class="TX">Finally, the malware compares the suspect value, <samp class="SANS_TheSansMonoCd_W5Regular_11">VBOX -1</samp>, to the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpdata</samp> buffer <span class="CodeAnnotation" aria-label="annotation6">❻</span>. If they match, the malware assumes it’s running in a VirtualBox VM and terminates itself.</p>&#13;
<p class="TX">Malware may also query certain areas of the registry for environment profiling. For example, it might attempt to detect whether it’s running on a computer system of a certain company in order to avoid inadvertently infecting the wrong target. In the following pseudocode, this malware sample is querying the registry for software related to its target, a company called NewCorp:</p>&#13;
<pre class="pre-16"><code>reg_key = RegOpenKey(HKEY_CURRENT_USER, "Software\\NewCorp", result)&#13;
&#13;
if (reg_key != ERROR_SUCCESS) {&#13;
  TerminateProcess)}</code></pre>&#13;
<p class="TX">This example is using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey</samp> Windows API function to search for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU\Software\NewCorp</samp> registry key of the host’s system. If the malware finds the key, it assumes it’s running on a system within the NewCorp organization; otherwise, it terminates itself.</p>&#13;
<p class="TX">Malware can also query the registry using Windows command line tools, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">reg query</samp>:</p>&#13;
<pre class="pre-17"><code>C:\&gt; reg query HKLM\Software\NewCorp</code></pre>&#13;
<p class="TX">This command would succeed if the key exists on the victim’s system and fail otherwise.</p>&#13;
<p class="TX">One final way in which malware can query the registry is by using Windows Management Instrumentation (WMI), PowerShell, and other native Windows tools, as we’ll discuss in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>. For now, the point is that there are many methods of querying the registry, but it’s also important to note that malware and benign software alike both query the registry for many reasons; a query doesn’t always indicate that malware is using a profiling or evasion technique. Registry keys that malware may search for in an attempt to identify a VM analysis environment include the following:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU:\SOFTWARE\VMware, Inc.</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\Applications\VMwareHostOpen.exe</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\VMwareHostOpen.AssocFile</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\VMwareHostOpen.AssocURL</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware User Process</samp></li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware VM3DService Process</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\RegisteredApplications\VMware Host Open</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\WOW6432Node\RegisteredApplications\VMware Host Open</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\CurrentControlSet\Enum\IDE\DiskVMware_Virtual_IDE_Hard_Drive<span aria-hidden="true">___________</span>00000001\</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\DSDT\VBOX__</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\FADT\VBOX__</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\RSDT\VBOX__</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VBoxTray</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Oracle VM VirtualBox Guest Additions</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Oracle\VirtualBox Guest Additions</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxMouse</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxSF</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxService</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxVideo</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxGuest</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>General</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\BIOS\SystemManufacturer</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\BIOS\SystemProductName</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\SystemBiosVersion</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Store\Configuration\OEMID</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\CurrentControlSet\Control\Class\</samp></li>&#13;
</ul>&#13;
<p class="TX">You can use the Windows tool <i>regedit.exe</i> on your own analysis VM to investigate these keys and get an idea of what malware may be looking for. For example, when I inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp> registry key in my own analysis machine, I can spot certain values and data that may be interesting to malware (see <a href="chapter4.xhtml#fig4-1">Figure 4-1</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig4-1" src="../images/fig4-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The hardware description in</samp> <samp class="SANS_Futura_Std_Book_11">regedit.exe</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>The obvious data points of interest here are the <samp class="SANS_TheSansMonoCd_W5Regular_11">VBOX -1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Oracle VM VirtualBox</samp> strings. Another big hint is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemBiosDate</samp> of <samp class="SANS_TheSansMonoCd_W5Regular_11">06/23/99</samp>, which indicates the VirtualBox hypervisor. Once again, these registry keys are only examples. They may or may not exist on your VMs, depending on your hypervisor version, installed software, and other factors.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>These registry keys can typically be renamed or removed completely in order to trick malware and bypass its evasion techniques. I’ll discuss this in more detail in <a href="appendix-A.xhtml">Appendix A</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-57"/><samp class="SANS_Futura_Std_Bold_B_11">Services</samp></h3>&#13;
<p class="TNI1"><i>Services</i> are applications that typically start at system boot-up and run in the background of a user’s session, and they’re yet another way in which malware may attempt to identify a VM or sandbox environment. Some services are unique to a certain brand of hypervisor, giving away its presence, and some services can also identify installed malware analysis tools. For example, malware may be looking for the <i>VirtualBox Guest Additions Service</i>, which indicates the presence of VirtualBox.</p>&#13;
<p class="TX">Malware may query services in multiple ways. One of the most common techniques is using the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumServiceStatus</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumServiceStatusEx</samp>, which will return a list of services on the host and their associated statuses, which are usually either <samp class="SANS_TheSansMonoCd_W5Regular_11">running</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stopped</samp>. Malware can also use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenService</samp> to open a handle to a specific service. If it successfully obtains a handle (meaning the service exists), the return code will be <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>&#13;
<p class="TX">In addition to Windows API functions, there are other methods of enumerating services that malware can employ. For example, malware can use the Windows <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp> command line tool to query a list of services or a specific service, like so:</p>&#13;
<pre class="pre-18"><code>C:\&gt; sc query <var>ServiceName</var></code></pre>&#13;
<p class="TX">Similarly, malware can use the WMI command line tool <samp class="SANS_TheSansMonoCd_W5Regular_11">wmic</samp> to query all services on the host:</p>&#13;
<pre class="pre-19"><code>C:\&gt; wmic service get <var>name</var></code></pre>&#13;
<p class="TX">Finally, since some service information is stored in the registry, malware can query the registry for service information. If you see malware using service-related API functions, using tools such as <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp>, or querying the registry to find specific hypervisor services, the sample may be attempting to detect an analysis environment.</p>&#13;
<p class="TX">To better understand and explore the services running on your VMs and sandboxes, you can use the Windows native application <i>services.exe</i> to get a list of services configured on the system. In <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>, you can see the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/>VirtualBox Guest Additions Service running, which can signal to malware that it is running in a VM environment.</p>&#13;
<figure class="IMG"><img class="img100" id="fig4-2" src="../images/fig4-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The output of</samp> <samp class="SANS_Futura_Std_Book_11">services.exe</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter4.xhtml#tab4-1">Table 4-1</a> lists some of the common services created by VMware and VirtualBox.</p>&#13;
<p class="TT" id="tab4-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Hypervisor Services</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">VGAuthService</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">VMware Guest Authentication Service</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMTools</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">VMware Tools Service</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxService</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">VirtualBox Guest Additions Service</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-58"/><samp class="SANS_Futura_Std_Bold_B_11">Installed Software</samp></h3>&#13;
<p class="TNI1">Malware may enumerate the installed software on your analysis machine and look for keywords that represent common analysis tools or sandbox-related artifacts. This technique can also be used for target profiling; malware may simply query the host, looking for installed software indicating that this system is a valid target.</p>&#13;
<p class="TX">To search for installed software, the malware might use a Windows API function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MsiEnumProducts</samp> or inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM\Software\Microsoft\Windows\Current Version\Uninstall</samp> registry key, whose contents from my malware analysis machine are shown in <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/>&#13;
<figure class="IMG"><img class="img60" id="fig4-3" src="../images/fig4-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: Enumerating the HKLM\Software\Microsoft\ Windows\Current Version\Uninstall registry key</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span class="Index-Link">Here you can see several analysis tools, as well as VirtualBox Guest Additions.</span></p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Software installers create many artifacts on the host, such as new folders, files, and registry entries, all of which can be enumerated by malware. Sometimes it’s a better approach to use the</i> <span class="note_Italic">portable</span> <i>versions of analysis tools, which don’t need to be installed and are run directly from a self-contained executable file.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_B_11">Mutexes</samp></h3>&#13;
<p class="TNI1">As <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> explained, a <i>mutex</i> is an object that helps control access to resources, acting as a sort of gatekeeper. Certain sandboxes and hypervisors have unique mutexes that may be interesting to malware. For example, VMware typically uses mutexes that begin with <i>VMware</i>, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>.</p>&#13;
<p class="TX">Malware can use the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutex</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenMutex</samp> to search for specific mutex values, as shown in this sample:</p>&#13;
<pre class="pre-20"><code>push mutex_name ; "VMwareGuestCopyPasteMutex"&#13;
push 0&#13;
push 20000L&#13;
call OpenMutexA&#13;
test eax, eax</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label="86"/>The malware pushes the <samp class="SANS_TheSansMonoCd_W5Regular_11">mutex_name</samp> variable, which contains the mutex that the malware wants to find (<samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>), to the stack. It also pushes two other values that are required for the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenMutex</samp> function but aren’t important here. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenMutexA</samp> and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction to check whether that function succeeded or failed. If the function call succeeded, <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp> exists on the system, meaning that the system is likely running inside a VMware hypervisor.</p>&#13;
<p class="TX"><span class="Source-Text">K</span>eep in mind that not all mutex-related activity is malicious. Mutexes are standard Windows objects and are not inherently malicious <i>or</i> benign. If you spot malware enumerating mutexes and attempting to find very specific strings such as the examples just given, it could be using this detection technique. Some mutexes that may reveal a VM environment include the following:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMToolsHookQueueLock</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestDnDDataMutex</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxService</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTray</samp></li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-60"/><samp class="SANS_Futura_Std_Bold_B_11">Pipes</samp></h3>&#13;
<p class="TNI1">A <i>pipe</i> is a Windows object that allows for interprocess communication. Some hypervisors create unique pipes on the guest OS that may give away their presence to malware. Malware can call several different functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CallNamedPipe</samp>, to search for specific named pipes.</p>&#13;
<p class="TX">A great way to check your own VMs for these pipes is to use the tool Pipelist, which is part of the Windows Sysinternals suite from Mark Russinovich. <a href="chapter4.xhtml#fig4-4">Figure 4-4</a> shows the output from running the <samp class="SANS_TheSansMonoCd_W5Regular_11">pipelist</samp> command on a VMware Workstation VM. If you look closely, you may spot the <samp class="SANS_TheSansMonoCd_W5Regular_11">vgauth-service</samp> pipe, which is unique to VMware.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/>&#13;
<figure class="IMG"><img class="img100" id="fig4-4" src="../images/fig4-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: Output from running the pipelist command on a VMware Workstation VM</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here are some of the common pipes that may reside on your VMs:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">Vmmemctl</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vgauth-service</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTray</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTrayIPC</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVideo</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMouse</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMiniRdr</samp></li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/>&#13;
<h3 class="H1" id="sec9"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_B_11">Devices and Drivers</samp></h3>&#13;
<p class="TNI1">Hypervisors often install specific devices and drivers on guest operating systems. <i>Devices</i> are objects that often represent physical hardware on the system, such as USB controllers or hard disk volumes. <i>Drivers</i> are software objects that control hardware, allowing the OS and devices to communicate. Device and driver objects are typically managed by the Windows object manager.</p>&#13;
<p class="TX">Malware can enumerate devices and driver objects using two Windows functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenDirectoryObject</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp>. The following code shows these functions in action:</p>&#13;
<pre class="pre-21"><code>mov   [rbp+57h+ObjectAttributes.ObjectName], rax&#13;
mov   edx, 1     ; DesiredAccess&#13;
<span class="CodeAnnotationHang">1</span> lea   rcx, [rbp+57h+DirectoryHandle] ; "\\Driver"&#13;
<span class="CodeAnnotationHang">2</span> call  NtOpenDirectoryObject&#13;
mov   ebx, eax&#13;
test  eax, eax&#13;
<var>--snip--</var>&#13;
mov   rcx, [rbp+57h+DirectoryHandle] ; "\\Driver"&#13;
xor   r9d, r9d    ; ReturnSingleEntry&#13;
mov   [rsp+110h+ReturnLength], rax ; ReturnLength&#13;
mov   r8d, r14d    ; BufferLength&#13;
mov   [rbp+57h+var_BC], eax&#13;
<span class="CodeAnnotationHang">3</span> mov   rdx, rsi    ; Buffer&#13;
lea   rax, [rbp+57h+var_BC]&#13;
mov   [rsp+110h+Context], rax  ; Context&#13;
mov   [rsp+110h+RestartScan], 1 ; RestartScan&#13;
<span class="CodeAnnotationHang">4</span> call  NtQueryDirectoryObject</code></pre>&#13;
<p class="TX">You can see a handle to the <i>\\Driver</i> directory being loaded into register <samp class="SANS_TheSansMonoCd_W5Regular_11">rcx</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, using the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>, or <i>load effective address</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction calculates the address of an operand and loads it into a target register. This is followed by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenDirectoryObject</samp>, which opens <i>\\Driver</i> in preparation for the subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp> function call <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> queries the <i>\\Driver</i> directory objects and stores the list of objects in a buffer specified previously <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The malware then searches through this buffer, looking for specific drivers often used in VMs. Devices can be queried in the same way.</p>&#13;
<p class="TX">To better understand the contents of the Windows object manager, you can view it directly on your Windows VMs using the WinObj tool from Sysinternals. <a href="chapter4.xhtml#fig4-5">Figure 4-5</a> shows some of the VirtualBox-related drivers installed on my analysis VM using WinObj. Feel free to explore them on your own analysis system.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/>&#13;
<figure class="IMG"><img class="img100" id="fig4-5" src="../images/fig4-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: Exploring drivers with WinObj</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Some common hypervisor drivers for VMware Workstation and VirtualBox include the following:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-debug</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-stats</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-sloader</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmci</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmhgfs</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMMemCtl</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmmouse</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmrawdsk</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmusbmouse</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vsock</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMouse</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxSF</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVideo</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxWddm</samp></li>&#13;
</ul>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>And here are some common devices:</p>&#13;
<p class="ListHead"><b>VMware Workstation</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMCIGuestDev</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VMCIHostDev</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmpDevice</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmci</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">vmmemctl</samp></li>&#13;
</ul>&#13;
<p class="ListHead"><b>VirtualBox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp></li>&#13;
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMiniRdr</samp></li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_B_11">Usernames and Hostnames</samp></h3>&#13;
<p class="TNI1">Many automated malware analysis sandboxes have a default list of possible usernames assigned to user accounts on the system. These usernames may be randomized, but they’re often hardcoded. System hostnames may similarly be hardcoded and randomized at boot-up time. This isn’t simply a characteristic of automated sandboxes, however. Malware analysts may also configure their analysis VMs with usernames or hostnames that may be generic, well known, or otherwise not how a “real” user would configure their system.</p>&#13;
<p class="TX">Some malware can take advantage by enumerating the user accounts and hostname of the system, specifically searching for generic usernames such as <i>Administrator</i>, <i>User</i>, or <i>John</i>, or hostnames such as <i>Cuckoo</i>, <i>Test</i>, <i>Desktop</i>, <i>Workstation</i>, or <i>Lab</i>. <i>TequilaBoomBoom</i>, at one point the hostname for VirusTotal’s sandboxing service, is also a common check.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Configure your VMs and sandbox environments with nongeneric usernames and hostnames. Try to use values that an actual end user or enterprise environment would use, or randomize the names.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-63"/><samp class="SANS_Futura_Std_Bold_B_11">Locale and Language Settings</samp></h3>&#13;
<p class="TNI1">Keyboard and language settings can be used to determine a potential victim’s location. Malware might use this technique to include or exclude a host as a valid target for geographic or geopolitical reasons, or to evade analysis. For example, say a malware sample wants to determine whether a potential victim is located in Russia or speaks Russian. Depending on this information, it may then choose to deploy its payload on the host or quietly terminate itself. Here are three different approaches it can use to extract this information:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Getting the keyboard layout language</li>&#13;
<li class="BL">Enumerating the language settings of the system itself, such as the display language</li>&#13;
<li class="BL">Obtaining the host’s locale</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/>The first method is perhaps the most common. The Windows function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp> returns the active keyboard language of the host, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayoutList</samp> returns a complete list of all keyboard languages that are installed on the host.</p>&#13;
<p class="TX">There are several possible Windows functions to get the host’s language settings. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetUserDefaultUILanguage</samp>, for example, returns the currently logged-in user’s user interface language. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemDefaultUILanguage</samp> returns the system language, or more specifically, the language in which the OS was installed. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcessPreferredUILanguages</samp> will list languages that the user’s running processes may be utilizing. Talk about options!</p>&#13;
<p class="TX">The <i>locale</i> of the host is different from the host’s keyboard and UI language settings in that it’s a list of language-related settings for a particular language-and-country combination. Some items that may be included as part of a locale are currency and date/time display formats, as well as a language identifier. The Windows API functions <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemDefaultLCID</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetUserDefaultLCID</samp> return locale information that can be used to profile a host or user. Processes and threads may also have their own custom locales, which malware can query using the function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadLocale</samp>.</p>&#13;
<p class="TX">In a malware sample, you’d likely see a call to one of the previously mentioned functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp>, followed by a comparison to several values that represent Windows language identifiers. The following pseudocode shows this technique in action:</p>&#13;
<pre class="pre-22"><code>keyboard_layout = GetKeyboardLayout(0)&#13;
if keyboard_layout == "0x419" {&#13;
  TerminateProcess()&#13;
}</code></pre>&#13;
<p class="TX">This malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp> function and compares the result to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x419</samp>, which is the Russian language identifier in hexadecimal (also known as <i>in hex</i>). If this Russian language identifier is in use, the malware executes <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#tab4-2">Table 4-2</a> lists some of the language identifiers for Windows.</p>&#13;
<p class="TT" id="tab4-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Common Language Identifiers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Identifier (in hex)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Language (and associated country)</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x402</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bulgarian (Bulgaria)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x4</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Chinese (Simplified) (China)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x809</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">English (United Kingdom)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x409</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">English (United States)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x407</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">German (Germany)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x418</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Romanian (Romania)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x419</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Russian (Russia)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">There are several other, more covert methods for enumerating or inferring a potential victim’s language and locale settings, such as enumerating <span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>the date/time formats, currency formats, or even calendar information. The potential list is so extensive that a portion of this book could be dedicated to this technique alone. What’s most important is that you now have the necessary knowledge to identify many of the common methods that malware may use to profile a victim’s language and locale.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-64"/><samp class="SANS_Futura_Std_Bold_B_11">Operating System Version Information</samp></h3>&#13;
<p class="TNI1">Before infecting a victim machine, malware often needs to determine whether that machine is running a certain OS. Stuxnet, for example, infected only Windows XP computers because its authors knew that the target facilities used Windows XP to control the Siemens programmable logic controllers. A malware sample that can run on only a certain version of Windows may attempt to identify the OS before infecting the host to avoid inadvertently crashing it. For example, if the malware contains exploit code that works for only a specific sub-version of Windows, such as Windows 7 Service Pack 1, but causes system instability for Windows 7 Service Pack 2, it might want to determine a victim’s OS sub-version first to prevent an unintended crash that would potentially alert the victim to its presence.</p>&#13;
<p class="TX">This technique isn’t usually implemented as a detection or evasion technique, but it’s worth discussing in this context because it can still interfere with the analysis process. For example, if you were researching Stuxnet and decided to run the sample in a VM or sandbox with a modern Windows OS, it likely wouldn’t run correctly, thereby unintentionally evading automated and dynamic analysis methods. This is an important point to keep in mind: a malware sample that doesn’t execute correctly in your analysis environment isn’t necessarily intentionally trying to be evasive.</p>&#13;
<p class="TX">There are multiple ways of enumerating the target’s OS and version via the Windows API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionEx</samp> function, along with its close cousin <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersion</samp>, accomplishes this, as shown here:</p>&#13;
<pre class="pre-23"><code>lea   eax, [ebp-0A0h]&#13;
push  eax&#13;
mov   [ebp+VersionInformation.dwOSVersionInfoSize], 9Ch&#13;
call  GetVersionExA&#13;
test  eax, eax&#13;
jnz   short loc_2&#13;
<var>--snip--</var>&#13;
cmp   [ebp+VersionInformation.dwMajorVersion], 4&#13;
jnz   loc_1000FA0F</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> function takes a buffer as an argument. This buffer will be the area of memory where the returned OS information will be stored after <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> is called. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction loads the buffer address, <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp-0A0h]</samp>, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, and then the buffer address is pushed to the stack with <samp class="SANS_TheSansMonoCd_W5Regular_11">push eax</samp>.</p>&#13;
<p class="TX">Next, the sample must define the size of the data that will be returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> function call. This data will be stored in a structure <span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>called <samp class="SANS_TheSansMonoCd_W5Regular_11">VersionInformation</samp>. This sample specifies the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">VersionInformation</samp> structure as <samp class="SANS_TheSansMonoCd_W5Regular_11">9C</samp>, which in hex is equal to 156 bytes.</p>&#13;
<p class="TX">Finally, the malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">call GetVersionExA</samp>) to get the OS version, then later checks that information by comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajorVersion</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which represents a very old version of Windows. (For some perspective, <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> is the version number for Windows XP!) Essentially, this malware sample is testing to see how old this host’s Windows version is.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#tab4-3">Table 4-3</a> contains a subset of the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMinor</samp> OS versions.</p>&#13;
<p class="TT" id="tab4-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp></span> <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajor</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dbMinor</samp> <samp class="SANS_Futura_Std_Book_11">OS Versions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operating system</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajorVersion</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dwMinorVersion</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows 10</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows Server 2016</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows 8.1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows Server 2012</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows 7</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows Server 2008</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows Vista</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Windows XP</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h-65"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, we covered many common (and some not-so-common) ways in which malware can detect an analysis environment by inspecting operating system objects and artifacts. In the next chapter, we’ll explore some techniques malware can use to look for evidence of legitimate user activity (or lack thereof!) to reveal the underlying VM or sandbox environment.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>