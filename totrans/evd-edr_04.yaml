- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OBJECT
    NOTIFICATIONS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">对象通知</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Process and thread events are only the tip of the iceberg when it comes to monitoring
    system activity with callback routines. On Windows, developers can also capture
    requests for handles to objects, which provide valuable telemetry related to adversary
    activity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程事件只是使用回调例程监控系统活动的冰山一角。在 Windows 上，开发人员还可以捕获请求对象句柄的操作，这些操作提供了与攻击者活动相关的有价值遥测信息。
- en: '*Objects* are a way to abstract resources such as files, processes, tokens,
    and registry keys. A centralized broker, aptly named the *object manager*, handles
    tasks like overseeing the creation and destruction of objects, keeping track of
    resource assignments, and managing an object’s lifetime. In addition, the object
    manager notifies registered callbacks when code requests handles to processes,
    threads, and desktop objects. EDRs find these notifications useful because many
    attacker techniques, from credential dumping to remote process injection, involve
    opening such handles.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象* 是一种抽象资源的方式，如文件、进程、令牌和注册表键。一个名为 *对象管理器* 的集中式代理处理诸如监督对象的创建与销毁、跟踪资源分配和管理对象生命周期等任务。此外，当代码请求对进程、线程和桌面对象的句柄时，对象管理器会通知已注册的回调。EDR
    认为这些通知很有用，因为许多攻击技术，从凭据转储到远程进程注入，都涉及打开这些句柄。'
- en: 'In this chapter, we explore one function of the object manager: its ability
    to notify drivers when certain types of object-related actions occur on the system.
    Then, of course, we discuss how attackers can evade these detection activities.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了对象管理器的一个功能：它能够在系统上发生某些类型的与对象相关的操作时通知驱动程序。当然，我们还将讨论攻击者如何避开这些检测活动。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Object Notifications Work</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象通知的工作原理</samp>
- en: As for all the other notification types, EDRs can register an object-callback
    routine using a single function, in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ObRegisterCallbacks()</samp>.
    Let’s take a look at this function to see how it works and then practice implementing
    an object-callback routine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他通知类型，EDR 可以使用一个单独的函数注册对象回调例程，在这种情况下是 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ObRegisterCallbacks()</samp>。让我们来看一下这个函数，看看它是如何工作的，然后练习实现一个对象回调例程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a New
    Callback</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册新的回调</samp>
- en: 'At first glance, the registration function seems simple, requiring only two
    pointers as parameters: the <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp>
    parameter, which specifies the callback routine itself and other registration
    information, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationHandle</samp>,
    which receives a value passed when the driver wishes to unregister the callback
    routine.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，注册功能似乎很简单，只需要两个指针作为参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp>
    参数，指定回调例程本身以及其他注册信息，和 <samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationHandle</samp>，当驱动程序希望取消注册回调例程时，接收传递的值。
- en: Despite the function’s simple definition, the structure passed in via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp> parameter
    is anything but. [Listing 4-1](#list4-1) shows its definition.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个函数的定义看起来简单，但通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp>
    参数传递的结构体却复杂得多。[列表 4-1](#list4-1) 显示了它的定义。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_CALLBACK_REGISTRATION</samp>
    structure definition'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_CALLBACK_REGISTRATION</samp>
    结构定义
- en: You’ll find some of these values to be fairly straightforward. The version of
    the object-callback registration will always be <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_FLT_REGISTRATION_VERSION</samp>
    (0x0100). The <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp>
    member is the number of callback registration structures passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    member, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationContext</samp>
    is some value passed as is to the callback routines whenever they are invoked
    and is set to null more often than not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现其中一些值相当简单明了。对象回调注册的版本始终为 <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_FLT_REGISTRATION_VERSION</samp>
    (0x0100)。<samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp>
    成员是传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    成员的回调注册结构的数量，<samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationContext</samp>
    是传递给回调例程的某个值，每当它们被调用时都会传递该值，并且通常会被设置为 null。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp> member is
    a string indicating the order in which the callback routines should be invoked.
    A pre-operation routine with a higher altitude will run earlier, and a post-operation
    routine with a higher altitude will execute later. You can set this value to anything
    so long as the value isn’t in use by another driver’s routines. Thankfully, Microsoft
    allows the use of decimal numbers, rather than merely whole numbers, reducing
    the overall chances of altitude collisions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp> 成员是一个字符串，表示回调例程应调用的顺序。具有较高高度的前操作例程会更早运行，而具有较高高度的后操作例程则会稍晚执行。你可以将此值设置为任何值，只要该值没有被其他驱动程序的例程占用。幸运的是，微软允许使用小数，而不仅仅是整数，这降低了高度冲突的总体可能性。
- en: This registration function centers on its <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    parameter and the array of registration structures it points to. This structure’s
    definition is shown in [Listing 4-2](#list4-2). Each structure in this array specifies
    whether the function is registering a pre-operation or post-operation callback
    routine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此注册功能的核心是其 <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    参数及其指向的注册结构数组。该结构的定义如 [清单 4-2](#list4-2) 所示。此数组中的每个结构都指定函数是注册前操作回调例程还是后操作回调例程。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_OPERATION_REGISTRATION</samp>
    structure definition'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_OPERATION_REGISTRATION</samp>
    结构定义
- en: '[Table 4-1](#tab4-1) describes each member and its purpose. If you’re curious
    about what exactly a driver is monitoring, these structures hold the bulk of the
    information in which you’ll be interested.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#tab4-1) 描述了每个成员及其目的。如果你对驱动程序监控的内容感到好奇，这些结构包含了你所关注的大部分信息。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Members
    of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_REGISTRATION</samp>
    <samp class="SANS_Futura_Std_Book_11">Structure</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-1：</samp> <samp class="SANS_Futura_Std_Book_11">成员</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_REGISTRATION</samp>
    <samp class="SANS_Futura_Std_Book_11">结构</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Member</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">成员</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">目的</samp>
    |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> | <samp class="SANS_Futura_Std_Book_11">A
    pointer to the type of object the driver developer wishes to monitor.</samp> <samp
    class="SANS_Futura_Std_Book_11">At the time of this writing, there are three supported
    values:</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> | <samp class="SANS_Futura_Std_Book_11">指向驱动程序开发人员希望监控的对象类型的指针。</samp>
    <samp class="SANS_Futura_Std_Book_11">截至本文写作时，支持三种值：</samp>'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> <samp class="SANS_Futura_Std_Book_11">(processes)</samp>
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> <samp class="SANS_Futura_Std_Book_11">(进程)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">PsThreadType</samp> <samp class="SANS_Futura_Std_Book_11">(threads)</samp>
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PsThreadType</samp> <samp class="SANS_Futura_Std_Book_11">(线程)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExDesktopObjectType</samp> <samp
    class="SANS_Futura_Std_Book_11">(desktops)</samp>
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExDesktopObjectType</samp> <samp
    class="SANS_Futura_Std_Book_11">(桌面)</samp>
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp> | <samp class="SANS_Futura_Std_Book_11">A
    flag indicating the type of handle operation to be monitored. This can be either</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_CREATE</samp><samp
    class="SANS_Futura_Std_Book_11">, to monitor requests for new handles, or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp><samp
    class="SANS_Futura_Std_Book_11">, to monitor handle-duplication requests.</samp>
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp> | <samp class="SANS_Futura_Std_Book_11">一个指示要监控的句柄操作类型的标志。可以是</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_CREATE</samp><samp
    class="SANS_Futura_Std_Book_11">，用于监控新句柄请求，或者</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp><samp
    class="SANS_Futura_Std_Book_11">，用于监控句柄重复请求。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> | <samp
    class="SANS_Futura_Std_Book_11">A pointer to a pre-operation callback routine.
    This routine will be invoked before the handle operation completes.</samp> |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> | <samp
    class="SANS_Futura_Std_Book_11">一个指向前操作回调例程的指针。此例程将在句柄操作完成之前调用。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">PostOperation</samp> | <samp
    class="SANS_Futura_Std_Book_11">A pointer to a post-operation callback routine.
    This routine will be invoked after the handle operation completes.</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">PostOperation</samp> | <samp
    class="SANS_Futura_Std_Book_11">一个指向后操作回调例程的指针。此例程将在句柄操作完成后调用。</samp> |'
- en: We’ll discuss these members further in “Detecting a Driver’s Actions Once Triggered”
    on [page 66](#sec5).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“驱动程序触发后的操作检测”一节中进一步讨论这些成员，参见 [第66页](#sec5)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Monitoring New and
    Duplicate Process-Handle Requests</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">监控新进程句柄和重复进程句柄请求</samp>
- en: EDRs commonly implement pre-operation callbacks to monitor new and duplicate
    process-handle requests. While monitoring thread- and desktop-handle requests
    can also be useful, attackers request process handles more frequently, so they
    generally provide more relevant information. [Listing 4-3](#list4-3) shows how
    an EDR might implement such a callback in a driver.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: EDR（端点检测与响应）通常实现前操作回调来监控新进程句柄和重复进程句柄请求。虽然监控线程和桌面句柄请求也有帮助，但攻击者更频繁地请求进程句柄，因此它们通常提供更相关的信息。[清单
    4-3](#list4-3) 显示了EDR可能如何在驱动程序中实现这种回调。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-3: Registering a pre-operation callback notification routine'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：注册前操作回调通知例程
- en: In this example driver, we begin by populating the callback registration structure.
    The two most important members are <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp>,
    which we set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, indicating
    that we are registering only one callback routine ❶, and the altitude, which we
    set to an arbitrary value ❷ to avoid collisions with other drivers’ routines.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例驱动程序中，我们首先填充回调注册结构。最重要的两个成员是 <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp>，我们将其设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，表示我们只注册一个回调例程 ❶，以及高度值，我们将其设置为一个任意值
    ❷，以避免与其他驱动程序的例程冲突。
- en: Next, we set up the operation-registration structure. We set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> ❸ and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp> to values that indicate
    we’re interested in monitoring new or duplicate process-handle operations ❹. Lastly,
    we set our <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> member
    to point to our internal callback function ❺.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置操作注册结构。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> ❸，并将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp> 设置为指示我们关注监控新或重复进程句柄操作的值
    ❹。最后，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> 成员指向我们的内部回调函数
    ❺。
- en: Finally, we tie our operation-registration structure into the callback registration
    structure by passing a pointer to it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    member ❻. At this point, we’re ready to call the registration function ❼. When
    this function completes, our callback routine will start receiving events, and
    we’ll receive a value that we can pass to the registration function to unregister
    the routine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将指针传递到 <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    成员 ❻，将我们的操作注册结构与回调注册结构连接起来。此时，我们准备调用注册函数 ❼。当该函数执行完成后，我们的回调例程将开始接收事件，同时我们会收到一个可以传递给注册函数来注销该例程的值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Objects an EDR Is Monitoring</samp>
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">检测 EDR 正在监控的对象</samp>
- en: How can we detect which objects an EDR is monitoring? As with the other types
    of notifications, when a registration function is called, the system will add
    the callback routine to an array of routines. In the case of object callbacks,
    however, the array isn’t quite as straightforward as others.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何检测 EDR 正在监控哪些对象？与其他类型的通知一样，当注册函数被调用时，系统会将回调例程添加到例程数组中。然而，对于对象回调，数组的结构不像其他类型那么直接。
- en: Remember those pointers we passed into the operation-registration structure
    to say what type of object we were interested in monitoring? So far in this book,
    we’ve mostly encountered pointers to structures, but these pointers instead reference
    values in an enumeration. Let’s take a look at <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp>
    to see what’s going on. Object types like <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp>
    are really <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_TYPE</samp> structures.
    [Listing 4-4](#list4-4) shows what these look like on a live system using the
    WinDbg debugger.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们传递到操作注册结构中的指针，用来指定我们感兴趣监控的对象类型吗？到目前为止，在本书中我们大多遇到的是指向结构体的指针，但这些指针实际上引用的是枚举中的值。让我们来看一下
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp>，了解一下发生了什么。像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp> 这样的对象类型其实是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_TYPE</samp> 结构体。[列表 4-4](#list4-4)
    展示了在运行中的系统中，这些结构体的样子，使用了 WinDbg 调试器。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!_OBJECT_TYPE</samp>
    pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!PsProcessType</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-4: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!_OBJECT_TYPE</samp>
    被 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!PsProcessType</samp>
    指向'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp> entry
    at offset 0x0c8 is particularly interesting to us, as it points to a <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp>
    structure, which is the entry point, or header, of a doubly linked list of callback
    routines associated with the process object type. Each entry in the list points
    to an undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">CALLBACK_ENTRY_ITEM</samp>
    structure. This structure’s definition is included in [Listing 4-5](#list4-5).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量 0x0c8 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp>
    条目对我们特别有意义，因为它指向一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp>
    结构，这是与进程对象类型相关的回调例程双向链表的入口点或头部。链表中的每个条目都指向一个未记录的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CALLBACK_ENTRY_ITEM</samp>
    结构。这个结构的定义包含在 [列表 4-5](#list4-5) 中。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CALLBACK_ENTRY_ITEM</samp>
    structure definition'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-5: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CALLBACK_ENTRY_ITEM</samp>
    结构定义'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> member
    of this structure resides at offset 0x028\. If we can traverse the linked list
    of callbacks and get the symbol at the address pointed to by this member in each
    structure, we can enumerate the drivers that are monitoring process-handle operations.
    WinDbg comes to the rescue once again, as it supports scripting to do exactly
    what we want, as demonstrated in [Listing 4-6](#list4-6).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> 成员位于偏移量
    0x028。如果我们能遍历回调函数的链表，并在每个结构体中获取该成员指向地址的符号，我们就能列举出监控进程句柄操作的驱动程序。WinDbg 再次派上用场，它支持脚本化功能，正如
    [列表 4-6](#list4-6) 中所示，能够完成我们所需要的操作。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-6: Enumerating pre-operation callbacks for process-handle operations'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-6: 枚举进程句柄操作的预操作回调'
- en: This debugger command essentially says, “Traverse the linked list starting at
    the address pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!_OBJECT_TYPE</samp>
    structure for <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp>,
    printing out the module information if the address pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp>
    member is not null.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调试器命令基本上是说：“遍历从 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!_OBJECT_TYPE</samp>
    结构中 <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp> 成员指向的地址开始的链表，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> 成员指向的地址不为 null，则打印出模块信息。”
- en: On my test system, Defender’s *WdFilter.sys* ❶ is the only driver with a registered
    callback. On a real system with an EDR deployed, you will almost certainly see
    the EDR’s driver registered alongside Defender. You can use the same process to
    enumerate callbacks that monitor thread- or desktop-handle operations, but those
    are usually far less common. Additionally, if Microsoft were to add the ability
    to register callbacks for other types of object-handle operations, such as for
    tokens, this process could enumerate them as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试系统上，Defender的 *WdFilter.sys* ❶ 是唯一一个注册了回调的驱动程序。在部署了EDR的真实系统中，你几乎肯定会看到EDR的驱动程序与Defender一起注册。你可以使用相同的过程列举监控线程或桌面句柄操作的回调，但这些通常不那么常见。此外，如果微软添加了注册其他类型对象句柄操作回调的能力，比如针对令牌的回调，那么这个过程也可以列举它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting a Driver’s Actions Once Triggered</samp>
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">触发后检测驱动程序的行为</samp>
- en: While you’ll find it useful to know what types of objects an EDR is interested
    in monitoring, the most valuable piece of information is what the driver actually
    does when triggered. An EDR can do a bunch of things, from silently observing
    the code’s activities to actively interfering with requests. To understand what
    the driver might do, we first need to look at the data with which it works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解EDR关注的对象类型对于监控很有用，但最有价值的信息是驱动程序在被触发时实际执行的操作。EDR可以做很多事情，从默默观察代码的活动到积极干扰请求。为了理解驱动程序可能做什么，我们首先需要查看它操作的数据。
- en: When some handle operation invokes a registered callback, the callback will
    receive a pointer to either an <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp>
    structure, if it is a pre-operation callback, or an <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_POST_OPERATION_INFORMATION</samp>
    structure, if it is a post-operation routine. These structures are very similar,
    but the post-operation version contains only the return code of the handle operation,
    and its data can’t be changed. Pre-operation callbacks are far more prevalent
    because they offer the driver the ability to intercept and modify the handle operation.
    Therefore, we’ll focus our attention on the pre-operation structure, shown in
    [Listing 4-7](#list4-7).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些句柄操作调用已注册的回调时，回调将接收一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp>
    结构的指针（如果是预操作回调），或者一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_POST_OPERATION_INFORMATION</samp>
    结构的指针（如果是后操作例程）。这些结构非常相似，但后操作版本仅包含句柄操作的返回码，且其数据不能更改。预操作回调更为普遍，因为它们为驱动程序提供了拦截和修改句柄操作的能力。因此，我们将重点关注预操作结构，如[列表
    4-7](#list4-7)所示。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_OPERATION_INFORMATION</samp>
    structure definition'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_OPERATION_INFORMATION</samp>
    结构定义
- en: Just like the process of registering the callback, parsing the notification
    data is a little more complex than it looks. Let’s step through the important
    pieces together. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp>
    handle identifies whether the operation being performed is the creation of a new
    handle or the duplication of an existing one. An EDR’s developer can use this
    handle to take different actions based on the type of operation it is processing.
    Also, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp>
    value isn’t zero, the handle is a kernel handle, and a callback function will
    rarely process it. This allows the EDR to further reduce the scope of events that
    it needs to monitor to provide effective coverage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就像注册回调的过程一样，解析通知数据比看起来要复杂一些。让我们一起逐步分析其中的重要部分。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp>句柄用来识别当前执行的操作是创建一个新的句柄，还是复制一个已有的句柄。EDR的开发者可以根据正在处理的操作类型使用这个句柄执行不同的操作。此外，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp>值不为零，则说明该句柄是内核句柄，回调函数通常不会处理它。这允许EDR进一步减少需要监控的事件范围，从而提供有效的覆盖。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> pointer references
    the handle operation’s target. The driver can use it to further investigate this
    target, such as to get information about its process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    pointer indicates whether the operation is targeting a process or a thread, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp> pointer references
    a structure that indicates the type of operation being processed (either handle
    creation or duplication).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>指针引用了句柄操作的目标。驱动程序可以使用它进一步调查该目标，例如获取有关其进程的信息。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>指针指示操作是否针对进程或线程，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp>指针引用一个结构，该结构指示正在处理的操作类型（无论是句柄创建还是复制）。
- en: The driver uses pretty much everything in this structure leading up to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp> member to filter the
    operation. Once it knows what type of object it is working with and what types
    of operations it will be processing, it will rarely perform additional checks
    beyond figuring out whether the handle is a kernel handle. The real magic begins
    once we start processing the structure pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp>
    member. If the operation is for the creation of a new handle, we’ll receive a
    pointer to the structure defined in [Listing 4-8](#list4-8).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序几乎会使用结构中的所有内容，直到<samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp>成员来筛选操作。一旦知道它正在处理的对象类型以及将要处理的操作类型，它通常不会再执行额外的检查，除非是确认该句柄是否为内核句柄。一旦开始处理由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp>成员指向的结构，真正的魔力就开始了。如果操作是创建一个新的句柄，我们将接收到指向[清单4-8](#list4-8)中定义的结构的指针。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_CREATE_HANDLE_INFORMATION</samp>
    structure definition'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-8：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_CREATE_HANDLE_INFORMATION</samp>结构定义
- en: The two <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS_MASK</samp> values
    both specify the access rights to grant to the handle. These might be set to values
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_OPERATION</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">THREAD_SET_THREAD_TOKEN</samp>,
    which might be passed to functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    parameter when opening a process or thread.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: "这两个<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">ACCESS_MASK</samp>值都指定了要授予句柄的访问权限。这些值可能会设置为像<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">PROCESS_VM_OPERATION</samp>或<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">THREAD_SET_THREAD_TOKEN</samp>这样的值，这些值可能会在打开进程或线程时，作为<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">dwDesiredAccess</samp>参数传递给函数。"
- en: You may be wondering why this structure contains two copies of the same value.
    Well, the reason is that pre-operation notifications give the driver the ability
    to modify requests. Let’s say the driver wants to prevent processes from reading
    the memory of the *lsass.exe* process. To read that process’s memory, the attacker
    would first need to open a handle with the appropriate rights, so they might request
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>. The driver
    would receive this new process-handle notification and see the requested access
    mask in the structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">OriginalDesiredAccess</samp>
    member. To prevent the access, the driver could remove <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>
    by flipping the bit associated with this access right in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    member using the bitwise complement operator (*~*). Flipping this bit stops the
    handle from gaining that particular right but allows it to retain all the other
    requested rights.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么这个结构包含两份相同的值。其实原因是预操作通知赋予了驱动程序修改请求的能力。假设驱动程序想要阻止进程读取*lsass.exe*进程的内存。为了读取该进程的内存，攻击者首先需要打开一个具有适当权限的句柄，因此他们可能会请求<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>。驱动程序将收到这个新的进程句柄通知，并在结构的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OriginalDesiredAccess</samp>成员中看到请求的访问掩码。为了阻止访问，驱动程序可以通过使用按位补码运算符（*~*）翻转与该访问权限相关的位，从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>成员中移除<samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>。翻转这个位会阻止该句柄获得该特定权限，但允许它保留所有其他请求的权限。
- en: If the operation is for the duplication of an existing handle, we’ll receive
    a pointer to the structure defined in [Listing 4-9](#list4-9), which includes
    two additional pointers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是用于复制现有句柄，我们将收到指向[清单 4-9](#list4-9)中定义的结构的指针，该结构包含两个附加指针。
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-9: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_DUPLICATE_HANDLE_INFORMATION</samp>
    structure definition'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-9：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_DUPLICATE_HANDLE_INFORMATION</samp>
    结构定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcess</samp> member
    is a pointer to the process object from which the handle originated, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetProcess</samp> is a pointer to the
    process receiving the handle. These match the <samp class="SANS_TheSansMonoCd_W5Regular_11">hSourceProcessHandle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">hTargetProcessHandle</samp>
    parameters passed to the handle-duplication kernel function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcess</samp>成员是指向发起句柄请求的进程对象的指针，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetProcess</samp>是指向接收该句柄的进程的指针。这与传递给句柄复制内核函数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hSourceProcessHandle</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">hTargetProcessHandle</samp>参数相匹配。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Object Callbacks During an Authentication
    Attack</samp>
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">在认证攻击中规避对象回调</samp>
- en: Undeniably one of the processes that attackers target most often is *lsass.exe*,
    which is responsible for handling authentication in user mode. Its address space
    may contain cleartext authentication credentials that attackers can extract with
    tools such as Mimikatz, ProcDump, and even the Task Manager.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，攻击者最常针对的进程之一是*lsass.exe*，它负责处理用户模式下的认证。其地址空间可能包含明文认证凭据，攻击者可以使用如 Mimikatz、ProcDump，甚至任务管理器等工具提取这些凭据。
- en: 'Because attackers have targeted *lsass.exe* so extensively, security vendors
    have invested considerable time and effort into detecting its abuse. Object-callback
    notifications are one of their strongest data sources for this purpose. To determine
    whether activity is malicious, many EDRs rely on three pieces of information passed
    to their callback routine on each new process-handle request: the process from
    which the request was made, the process for which the handle is being requested,
    and the *access mask*, or the rights requested by the calling process.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击者已经广泛地攻击*lsass.exe*，安全厂商已经投入了大量时间和精力来检测其滥用。对象回调通知是他们用于此目的的最强大数据源之一。为了判断活动是否恶意，许多EDR依赖于每次新的进程句柄请求时传递给回调例程的三条信息：发起请求的进程、请求句柄的目标进程以及*访问掩码*，即调用进程请求的权限。
- en: For example, when an operator requests a new process handle to *lsass.exe*,
    the EDR’s driver will determine the identity of the calling process and check
    whether the target is *lsass.exe*. If so, it might evaluate the requested access
    rights to see whether the requestor asked for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>,
    which it would need to read process memory. Next, if the requestor doesn’t belong
    to a list of processes that should be able to access *lsass.exe*, the driver might
    opt to return an invalid handle or one with a modified access mask and notify
    the agent of the potentially malicious behavior.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当操作员请求一个新的指向 *lsass.exe* 的进程句柄时，EDR 的驱动程序将确定调用进程的身份，并检查目标是否为 *lsass.exe*。如果是，它可能会评估请求的访问权限，查看请求者是否请求了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>，因为它需要读取进程内存。接下来，如果请求者不属于应有权访问
    *lsass.exe* 的进程列表，驱动程序可能选择返回无效句柄或一个修改过的访问掩码，并通知代理可能的恶意行为。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Defenders can sometimes identify specific attacker tools based on the access
    masks requested. Many offensive tools request excessive access masks, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_ALL_ACCESS</samp>,
    or atypical ones, such as Mimikatz’s request for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_VM_READ
    | PROCESS_QUERY_LIMITED_INFORMATION</samp>, when opening process handles.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*防御者有时可以根据请求的访问掩码识别特定的攻击者工具。许多攻击工具请求过度的访问掩码，如 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_ALL_ACCESS</samp>，或非典型的掩码，如
    Mimikatz 请求的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_VM_READ
    | PROCESS_QUERY_LIMITED_INFORMATION</samp>，当打开进程句柄时。*'
- en: 'In summary, an EDR makes three assumptions in its detection strategy: that
    the calling process will open a new handle to *lsass.exe*, that the process will
    be atypical, and that the requested access mask will allow the requestor to read
    *lsass.exe*’s memory. Attackers might be able to use these assumptions to bypass
    the detection logic of the agent.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，EDR 在其检测策略中做出了三个假设：调用进程将打开一个新的句柄指向 *lsass.exe*，该进程将是非典型的，并且请求的访问掩码将允许请求者读取
    *lsass.exe* 的内存。攻击者可能会利用这些假设绕过代理的检测逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing Handle
    Theft</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">执行句柄窃取</samp>
- en: 'One way attackers can evade detection is to duplicate a handle to *lsass.exe*
    owned by another process. They can discover these handles through the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">()</samp> API, which provides an incredibly
    useful feature: the ability to view the system’s handle table as an unprivileged
    user. This table contains a list of all the handles open on the systems, including
    objects such as mutexes, files, and, most importantly, processes. [Listing 4-10](#list4-10)
    shows how malware might query this API.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者规避检测的一种方式是复制另一个进程拥有的指向 *lsass.exe* 的句柄。它们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">()</samp> API 发现这些句柄，该 API 提供了一个极其有用的功能：作为普通用户查看系统句柄表的能力。该表包含系统上所有打开的句柄的列表，包括互斥体、文件，最重要的是进程等对象。[列表
    4-10](#list4-10) 展示了恶意软件如何查询此 API。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-10: Retrieving the table of handles'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-10：检索句柄表
- en: By passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemHandleInformation</samp>
    information class to this function ❶, the user can retrieve an array containing
    all the active handles on the system. After this function completes, it will store
    the array in a member variable of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_HANDLE_INFORMATION</samp>
    structure ❷.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemHandleInformation</samp>
    信息类传递给该函数 ❶，用户可以检索一个包含系统上所有活动句柄的数组。该函数完成后，将把数组存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_HANDLE_INFORMATION</samp>
    结构的成员变量中 ❷。
- en: Next, the malware could iterate over the array of handles, as shown in [Listing
    4-11](#list4-11), and filter out those it can’t use.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件可以遍历句柄数组，如 [列表 4-11](#list4-11) 所示，并筛选出它无法使用的句柄。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-11: Filtering only for process handles'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-11：仅筛选进程句柄
- en: We first make sure that neither *lsass.exe* nor the system process owns the
    handle ❶, as this could trigger some alerting logic. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryObject()</samp>,
    passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypeInformation</samp>
    ❷ to get the type of the object to which the handle belongs. Following this, we
    determine whether the handle is for a process object ❸ so that we can filter out
    all the other types, such as files and mutexes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保*lsass.exe*或系统进程不拥有该句柄 ❶，因为这可能触发某些警报逻辑。然后，我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryObject()</samp>，传入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypeInformation</samp> ❷ 以获取句柄所属对象的类型。接下来，我们确定该句柄是否属于进程对象
    ❸，以便过滤掉其他类型，如文件和互斥体。
- en: After completing this basic filtering, we need to investigate the handles a
    little more to make sure they have the access rights that we need to dump process
    memory. [Listing 4-12](#list4-12) builds upon the previous code listing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成基本过滤后，我们需要进一步调查这些句柄，确保它们具有我们所需的访问权限以转储进程内存。[列表 4-12](#list4-12)在前一个代码清单的基础上进行了扩展。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-12: Evaluating duplicated handles and dumping memory'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-12：评估复制的句柄并转储内存
- en: We first get the image name for the process ❶ and pass it to an internal function,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IsLsassHandle()</samp>, which makes
    sure that the process handle is for *lsass.exe*. Next, we check the handle’s access
    rights, looking for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM _READ</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_INFORMATION</samp>,
    because the API we’ll use to read *lsass.exe*’s process memory requires these.
    If we find an existing handle to *lsass.exe* with the required access rights,
    we pass the duplicated handle to the API and extract its information ❷.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取进程 ❶ 的映像名称，并将其传递给一个内部函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">IsLsassHandle()</samp>，该函数确保进程句柄是针对*lsass.exe*的。接下来，我们检查句柄的访问权限，寻找
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM _READ</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_INFORMATION</samp>，因为我们将用来读取*lsass.exe*进程内存的API需要这些权限。如果我们找到具有所需访问权限的*lsass.exe*句柄，我们将复制该句柄并传递给API，提取其信息
    ❷。
- en: Using this new handle, we could create and process an *lsass.exe* memory dump
    with a tool such as Mimikatz. [Listing 4-13](#list4-13) shows this workflow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新句柄，我们可以利用像 Mimikatz 这样的工具创建并处理*lsass.exe*的内存转储。[列表 4-13](#list4-13)展示了这个工作流程。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-13: Dumping lsass.exe’s memory and processing the minidump with Mimikatz'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-13：转储 lsass.exe 的内存并使用 Mimikatz 处理小型转储文件
- en: As you can see, our tool determines that PID 17600, which corresponds to Process
    Explorer on my test host, had a handle to *lsass.exe* with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>
    access mask (0x1FFFFF). We use this handle to dump the memory to a file, *C:\lsa.dmp*.
    Next, we run Mimikatz and use it to process the file, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sekurlsa::logonpasswords</samp>
    command to extract credential material. Note that we could perform these Mimikatz
    steps off-target to reduce our risk of detection, as we’re working with a file
    and not live memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的工具确定了PID 17600，它对应于我测试主机上的进程资源管理器，并且该PID具有*lsass.exe*的句柄，访问掩码为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp> (0x1FFFFF)。我们使用这个句柄将内存转储到文件中，*C:\lsa.dmp*。接下来，我们运行
    Mimikatz 并使用它来处理该文件，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sekurlsa::logonpasswords</samp>
    命令提取凭证信息。请注意，我们可以在目标外执行这些 Mimikatz 步骤，以减少被检测的风险，因为我们处理的是文件而不是实时内存。
- en: While this technique would evade certain sensors, an EDR could still detect
    our behavior in plenty of ways. Remember that object callbacks might receive notifications
    about duplication requests. [Listing 4-14](#list4-14) shows what this detection
    logic could look like in an EDR’s driver.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一技术可以避开某些传感器，但EDR仍然可以通过多种方式检测我们的行为。请记住，对象回调可能会收到关于复制请求的通知。[列表 4-14](#list4-14)展示了EDR驱动程序中可能出现的这种检测逻辑。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-14: Filtering handle-duplication events on the target process name'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-14：基于目标进程名称过滤句柄复制事件
- en: To detect duplication requests, the EDR could determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp>
    structure, which gets passed to the callback routine, is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp>
    and, if so, whether its <samp class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp>
    member is <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp>
    ❶. Using additional filtering, we could determine whether we’re potentially looking
    at the technique described earlier. We might then compare the name of the target
    process with the name of a sensitive process, or a list of them ❷.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测重复请求，EDR 可以确定是否传递给回调例程的 <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp>
    结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> 成员是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp>，如果是，进一步检查其 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp> 成员是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp>
    ❶。通过附加过滤，我们可以判断是否有可能遇到前面提到的技术。然后，我们可能会将目标进程的名称与敏感进程的名称进行比较，或者与敏感进程的列表进行比对 ❷。
- en: A driver that implements this check will detect process-handle duplication performed
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>.
    [Figure 4-1](#fig4-1) shows a mock EDR reporting the event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此检查的驱动程序将检测到使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>
    进行的进程句柄重复操作。[图 4-1](#fig4-1) 展示了一个模拟的 EDR 报告该事件。
- en: '![](../images/Figure4-1.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: Detecting process-handle
    duplication</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-1：检测进程句柄重复</samp>
- en: Unfortunately, at the time of this writing, many sensors perform checks only
    on new handle requests and not on duplicate requests. This may change in the future,
    however, so always evaluate whether the EDR’s driver performs this check.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，许多传感器仅对新句柄请求进行检查，而不检查重复请求。然而，这种情况可能会在未来发生变化，因此始终评估 EDR 驱动程序是否执行此检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Racing the Callback
    Routine</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与回调例程竞速</samp>
- en: 'In their 2020 paper “Fast and Furious: Outrunning Windows Kernel Notification
    Routines from User-Mode,” Pierre Ciholas, Jose Miguel Such, Angelos K. Marnerides,
    Benjamin Green, Jiajie Zhang, and Utz Roedig demonstrated a novel approach to
    evading detection by object callbacks. Their technique involves requesting a handle
    to a process before execution has been passed to the driver’s callback routine.
    The authors described two separate ways of racing callback routines, covered in
    the sections that follow.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们2020年的论文《快速与狂怒：从用户模式绕过 Windows 内核通知例程》中，Pierre Ciholas、Jose Miguel Such、Angelos
    K. Marnerides、Benjamin Green、Jiajie Zhang 和 Utz Roedig 展示了一种新颖的绕过对象回调检测的方法。他们的方法是在执行传递到驱动程序的回调例程之前，先请求一个进程句柄。作者描述了两种不同的竞速回调例程的方法，以下章节对此进行了详细讲解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Job Object on the
    Parent Process</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在父进程上创建作业对象</samp>
- en: The first technique works in situations when an attacker wants to gain access
    to a process whose parent is known. For example, when a user double-clicks an
    application in the Windows GUI, its parent process should be *explorer.exe*. In
    those cases, the attacker definitively knows the parent of their target process,
    allowing them to use some Windows magic, which we’ll discuss shortly, to open
    a handle to the target child process before the driver has time to act. [Listing
    4-15](#list4-15) shows this technique in action.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术适用于攻击者希望访问一个已知父进程的进程的情况。例如，当用户在 Windows 图形界面中双击一个应用程序时，其父进程应该是 *explorer.exe*。在这些情况下，攻击者明确知道目标进程的父进程，从而可以利用一些
    Windows 技巧——稍后我们将讨论这些技巧——在驱动程序来不及处理之前，打开目标子进程的句柄。[列表 4-15](#list4-15) 展示了该技术的实际应用。
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-15: Setting up a job object and I/O completion port to be queried'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-15：设置作业对象和待查询的 I/O 完成端口
- en: To gain a handle to a protected process, the operator creates a job object on
    the known parent ❶. As a result, the process that placed the job object will be
    notified of any new child processes created through an I/O completion port ❷.
    The malware process must then query this I/O completion port as quickly as possible.
    In our example, the internal <samp class="SANS_TheSansMonoCd_W5Regular_11">GetChildHandles()</samp>
    function ❸, expanded in [Listing 4-16](#list4-16), does just that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取受保护进程的控制，操作员首先在已知的父进程上创建一个作业对象❶。结果，创建该作业对象的进程将会收到通过 I/O 完成端口❷创建的任何新子进程的通知。恶意软件进程随后必须尽快查询该
    I/O 完成端口。在我们的示例中，内部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">GetChildHandles()</samp>❸，在[列表
    4-16](#list4-16)中进行了扩展，正是执行了这一操作。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-16: Opening new process handles'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-16：打开新进程句柄
- en: In this function, we first check the I/O completion port in a <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>
    loop ❸. If we see that bytes have been transferred as part of a completed operation,
    we open a new handle to the returned PID ❶, requesting full rights (in other words,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>). If we
    receive a handle, we check its image name ❷. Real malware would do something with
    this handle, such as read its memory or terminate it, but here we just print some
    information about it instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们首先在一个<samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp>循环❸中检查
    I/O 完成端口。如果我们看到作为已完成操作一部分的字节已经传输，我们就会打开返回的 PID ❶的新句柄，请求完全权限（换句话说，<samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>）。如果我们收到了句柄，我们会检查其映像名称❷。真正的恶意软件会对这个句柄执行某些操作，比如读取内存或终止进程，但在这里我们只是打印一些关于它的信息。
- en: This technique works because the notification to the job object occurs before
    the object-callback notification in the kernel. In their paper, the researchers
    measured the time between process-creation and object-callback notification to
    be 8.75–14.5 ms. This means that if a handle is requested before the notification
    is passed to the driver, the attacker can obtain a fully privileged handle as
    opposed to one whose access mask has been changed by the driver.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术之所以有效，是因为作业对象的通知发生在内核中的对象回调通知之前。在他们的论文中，研究人员测量了进程创建与对象回调通知之间的时间，约为 8.75–14.5
    毫秒。这意味着，如果在通知传递给驱动程序之前请求句柄，攻击者可以获得一个完全特权的句柄，而不是一个被驱动程序更改了访问掩码的句柄。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Guessing the PID of the Target
    Process</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">猜测目标进程的 PID</samp>
- en: The second technique described in the paper attempts to predict the PID of the
    target process. By removing all known PIDs and thread IDs (TIDs) from the list
    of potential PIDs, the authors showed that it is possible to more efficiently
    guess the PID of the target process. To demonstrate this, they created a proof-of-concept
    program called *hThemAll.cpp*. At the core of their tool is the internal function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessThemAll()</samp>, shown
    in [Listing 4-17](#list4-17), which the program executes across four concurrent
    threads to open process handles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 论文中描述的第二种技术尝试预测目标进程的 PID。通过从潜在 PID 列表中移除所有已知的 PID 和线程 ID（TID），作者们展示了更高效地猜测目标进程
    PID 的可能性。为了演示这一点，他们创建了一个名为*hThemAll.cpp*的概念验证程序。该工具的核心是内部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessThemAll()</samp>，如[列表
    4-17](#list4-17)所示，程序通过四个并发线程执行该函数来打开进程句柄。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-17: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OpenProcessThemAll()</samp>
    function used to request handles to processes and check their PIDs'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-17：用于请求进程句柄并检查其 PID 的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OpenProcessThemAll()</samp>函数
- en: This function indiscriminately requests handles ❶ to all processes via their
    PIDs in a filtered list. If the handle returned is valid, it is added to an array
    ❷. After this function completes, we can check whether any of the handles returned
    match the target process. If the handle does not match the target, it is closed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过一个过滤后的 PID 列表，不加区别地请求所有进程的句柄❶。如果返回的句柄有效，它将被添加到数组中❷。该函数完成后，我们可以检查是否有返回的句柄匹配目标进程。如果句柄不匹配目标，它将被关闭。
- en: While the proof of concept is functional, it misses some edge cases, such as
    the reuse of process and thread identifiers by another process or thread after
    one terminates. It is absolutely possible to cover these, but no public examples
    of doing so exist at the time of this writing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管概念验证是可行的，但它缺少一些边缘案例，例如在一个进程或线程终止后，另一个进程或线程重新使用该进程和线程标识符。完全可以覆盖这些情况，但在本文写作时并没有公开的示例。
- en: Both of these techniques’ operational use cases may also be limited. For instance,
    if we wanted to use the first technique to open a handle to the agent process,
    we’d need to run our code before that process starts. This would be very challenging
    to pull off on a real system because most EDRs start their agent process via a
    service that runs early in the boot order. We’d need administrative rights to
    create our own service, and that still doesn’t guarantee that we’d be able to
    get our malware running before the agent service starts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术的操作使用案例也可能受到限制。例如，如果我们想使用第一种技术来打开代理进程的句柄，我们需要在该进程启动之前运行我们的代码。这在真实系统中非常具有挑战性，因为大多数EDR通过在启动顺序中较早运行的服务启动代理进程。我们需要管理员权限来创建我们自己的服务，而这仍然无法保证我们能够在代理服务启动之前让恶意软件运行。
- en: Additionally, both techniques focus on defeating the EDR’s preventive controls
    and do not take into consideration its detective controls. Even if the driver
    is unable to modify the privileges of the requested handle, it might still report
    suspicious process-access events. Microsoft has stated that it won’t fix this
    issue, as doing so could cause application-compatibility problems; instead, third-party
    developers are responsible for mitigation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这两种技术都侧重于破解EDR的预防控制措施，并没有考虑其侦测控制措施。即使驱动程序无法修改请求句柄的权限，它仍然可能报告可疑的进程访问事件。微软表示，它不会修复这个问题，因为这样做可能会导致应用兼容性问题；相反，第三方开发者负责缓解。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Monitoring handle operations, especially handles being opened to sensitive processes,
    provides a robust way to detect adversary tradecraft. A driver with a registered
    object-notification callback stands directly inline of an adversary whose tactics
    rely on opening or duplicating handles to things such as *lsass.exe*. When this
    callback routine is implemented well, the opportunities for evading this sensor
    are limited, and many attackers have adapted their tradecraft to limit the need
    to open new handles to processes altogether.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 监控句柄操作，尤其是打开指向敏感进程的句柄，提供了一种强有力的方式来检测对手的战术。一个注册了对象通知回调的驱动程序，直接处于一个依赖于打开或复制诸如*lsass.exe*等进程句柄的对手的操作路径中。当这个回调例程实现得当时，规避这一传感器的机会是有限的，许多攻击者已经调整了他们的战术，以减少完全不需要打开新进程句柄的情况。
