- en: '![](../images/pg160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-17.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Functions*—chunks of code that can be defined in one place and invoked somewhere
    else—are a fundamental concept in every mainstream programming language. They’re
    so fundamental, in fact, that there are dedicated processor instructions just
    for making function calls. In this chapter, you’ll implement function calls and
    definitions according to the standard *calling convention* for Unix-like systems,
    which defines exactly how function calls should work at the assembly level. Calling
    conventions make it possible for binaries that were compiled separately (and might
    even have been written in different source languages) to interoperate. By following
    your system’s calling convention, you’ll be able to compile programs that call
    functions in external libraries, including the standard library. The programs
    you compile will finally be able to perform I/O operations! Programs built by
    other compilers will also be able to use libraries built by your compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll spend most of this chapter on semantic analysis and assembly code generation.
    In the semantic analysis stage, we’ll add a new *type checking* pass, which is
    bolded in the diagram at the start of this chapter. This pass is pretty bare-bones
    for now, but we’ll build on it as we add new types throughout [Part II](part2.xhtml).
    In the assembly generation stage, we’ll dig into our system’s calling convention,
    which tells us how to set up stack frames, pass arguments and return values, and
    transfer control from one function to another.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let’s define exactly what features we’re about to implement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring, Defining, and Calling Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ll implement function calls, function declarations, and
    function definitions. A function *declaration* tells you a function’s name and
    type. The declaration brings the function name into scope so it can be called
    later. A function *definition* is a declaration that includes a function body.
    (All function definitions are declarations, but not all declarations are definitions.)
    Your compiler already has some support for function definitions, since it can
    compile <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Now you’ll
    generalize it to compile other functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations and
    Definitions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A function declaration, like the one in [Listing 9-1](chapter9.xhtml#list9-1),
    must include the function’s return type, its name, and a type and name for each
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: A function declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, a function’s return type and parameter types all have to be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. As we’ve already seen, if
    a function has no parameters, its parameter list is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A function definition looks just like the function declaration from [Listing
    9-1](chapter9.xhtml#list9-1), plus a body. [Listing 9-2](chapter9.xhtml#list9-2)
    shows an example of a function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: A function definition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare the same function as many times as you like, but all the declarations
    must be compatible: the return type, parameter types, and number of parameters
    must be the same. The parameter names can vary between declarations, because only
    the parameter names in the function definition are used. [Listing 9-3](chapter9.xhtml#list9-3),
    for example, is perfectly valid.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Declaring a function
    multiple times with different parameter names</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While it’s legal to declare a function multiple times, you cannot define a function
    more than once; if you did, when the function was called, there would be no way
    to tell which definition to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare functions in two places: at the top level and inside the body
    of other functions. [Listing 9-4](chapter9.xhtml#list9-4) includes both kinds
    of declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Nested and top-level
    function declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t define a function in the body of another function, however. The C
    standard supports function definitions only at the top level, so it doesn’t allow
    programs like [Listing 9-5](chapter9.xhtml#list9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: A nested function
    definition (not supported)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers support nested function definitions as a language extension and
    will compile [Listing 9-5](chapter9.xhtml#list9-5) just fine. We won’t implement
    this language extension; we’re sticking with features that are in the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function call consists of a function name followed by a sequence of comma-separated
    arguments, wrapped in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the identifiers in a function declaration are called function *parameters*,
    the expressions passed into a function call are called function *arguments*. For
    example, in [Listing 9-6](chapter9.xhtml#list9-6), <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    are parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, while
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * c</samp> are arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Function parameters
    and arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As [Listing 9-7](chapter9.xhtml#list9-7) illustrates, a function must be declared,
    but not necessarily defined, before it can be called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Declaring and
    then calling a function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> may
    appear later in the same file, or it may appear in a separate library. It’s up
    to the linker, not your compiler, to find the definition of every function your
    program calls. If it can’t find the definition, linking will fail.
  prefs: []
  type: TYPE_NORMAL
- en: It’s illegal to call a function before it’s declared, so [Listing 9-8](chapter9.xhtml#list9-8)
    is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Calling a function
    before it’s declared</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many compilers warn about programs that call undeclared functions,
    but don’t reject them. Our implementation is stricter and rejects programs like
    [Listing 9-8](chapter9.xhtml#list9-8) during semantic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also illegal to call a function with the wrong number of arguments, or
    to call a variable as a function. (Function pointers would be an exception to
    this second point if we were implementing them.)  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifier
    Linkage</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Function and variable names are both identifiers. They exist in the same namespace
    and follow the same scoping rules. Function names, like variable names, can be
    shadowed by other declarations in inner scopes. Consider [Listing 9-9](chapter9.xhtml#list9-9),
    where the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    shadows the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: A variable name
    shadowing a function name</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program compiles without error and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    Function names can also shadow variable names, as [Listing 9-10](chapter9.xhtml#list9-10)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: A function name
    shadowing a variable name</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    shadows the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    this program compiles without error too, as long as the function <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is defined somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: In other ways, however, function declarations are resolved very differently
    from the local variable declarations we’ve seen so far. Every local variable declaration
    refers to a different variable, even if some of those variables have the same
    name (we make this explicit when we give a unique name to each variable in the
    variable resolution pass). But multiple function declarations with the same name
    all refer to the same function. Consider [Listing 9-11](chapter9.xhtml#list9-11),
    which includes three function declarations that use the name <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-11: Multiple function
    declarations that refer to a single definition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these declarations ultimately refers to the same function definition.
    This listing doesn’t contain declarations of three different functions called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>; it contains three declarations
    of the same function.
  prefs: []
  type: TYPE_NORMAL
- en: In the C standard, a declaration’s *linkage* determines how it relates to other
    declarations of the same identifier. There are a few different kinds of linkage.
    According to section 6.2.2, paragraph 2, of the C standard, “each declaration
    of a particular identifier with *external linkage* denotes the same object or
    function.” In [Listing 9-11](chapter9.xhtml#list9-11), every declaration of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">incr</samp> has external linkage, so these
    declarations all refer to the same function definition. Declarations with external
    linkage can refer to the same object or function even if they appear in different
    translation units. (A *translation unit* is just a preprocessed source file.)
  prefs: []
  type: TYPE_NORMAL
- en: Consider a program made up of two different files. In one file, shown in [Listing
    9-12](chapter9.xhtml#list9-12), we define a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-12: Defining a library
    function in one file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the other file, which is shown in [Listing 9-13](chapter9.xhtml#list9-13),
    we declare and use that function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-13: Declaring and
    calling the library function in a different file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>
    is declared in two different files, the linker will recognize that both of these
    declarations refer to the same thing: the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>
    in [Listing 9-12](chapter9.xhtml#list9-12). It will then update every use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp> in the binary code
    for [Listing 9-13](chapter9.xhtml#list9-13) to point to the definition in [Listing
    9-12](chapter9.xhtml#list9-12).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, all function identifiers have external linkage. Local variables,
    on the other hand, have no linkage*.* Section 6.2.2, paragraph 2, of the C standard
    says that “each declaration of an identifier with *no linkage* denotes a unique
    entity.” A local variable can’t refer to the same object as another local variable,
    and it can’t refer to the same thing as an identifier with external linkage, like
    a function name.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It may look like an identifier’s linkage depends only on whether it’s a function
    or a variable, but in the next chapter you’ll see that this isn’t the case. We’ll
    implement global variable declarations with external linkage, and we’ll implement
    function and variable declarations with a third kind of linkage,* internal linkage*.
    Declarations with internal linkage can be linked to other declarations in the
    same translation unit, but not in other translation units.*'
  prefs: []
  type: TYPE_NORMAL
- en: Since all declarations of a given function name must refer to the same function
    definition, they must be compatible even if they appear in different scopes. [Listing
    9-14](chapter9.xhtml#list9-14) contains two incompatible function declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-14: Conflicting function
    declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    should refer to the same function, since they both have external linkage. But
    no function definition could satisfy both declarations, since the numbers of parameters
    differ. Because the two declarations conflict, this code won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered some background information on functions, we can get
    to work on the compiler. But we won’t start with the lexer right away. First,
    we need to update the compiler driver.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiling Libraries</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In previous chapters, we could compile only stand-alone executables. Every
    source file we compiled defined a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function, which was the program’s entry point. Now that we can handle other functions,
    we should also be able to compile libraries, which don’t have an entry point.
    When your compiler translates source code into assembly, it doesn’t care whether
    it’s processing a library or an executable. Your compiler driver, however, does
    care, because the linker expects a complete program to include <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    If you try to compile a source file with no <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function using your current compiler driver, you’ll get a linker error, which
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This error means the linker is trying and failing to link your code against
    <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>, the wrapper code that
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command accepts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> command line flag that
    tells it not to invoke the linker; when this flag is present, it generates an
    object file instead of an executable. To work with the test suite, your compiler
    driver should recognize the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag as well. When it’s passed this flag, the compiler driver should first convert
    the source program to assembly as usual, then run the following command to convert
    the assembly program into an object file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output filename should be the original filename with a *.o* suffix. In other
    words, <samp class="SANS_TheSansMonoCd_W5Regular_11">./YOUR_COMPILER -c /path/to/program.c</samp>
    should produce an object file at */path/to/program.o*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you wanted to compile and distribute a real library, you wouldn’t just
    produce an object file; you’d create a shared library (a* .so *file on Linux or
    a* .dylib *file on macOS). If you like, you can add another option to your compiler
    driver to produce shared libraries; your driver can convert an assembly program
    into a shared library instead of an object file by invoking GCC or Clang with
    the appropriate flags. But there’s a major limitation on your compiler’s ability
    to produce shared libraries, particularly on Linux; we’ll talk more about this
    in [Chapter 10](chapter10.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might also want to extend your compiler driver to accept
    multiple input source files. The test suite doesn’t require this feature, but
    you’ll need it if you want to compile multifile programs. To handle multiple source
    files, your compiler driver should convert each one to assembly separately, then
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to assemble
    them and link them together.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add one token in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> A comma
  prefs: []
  type: TYPE_NORMAL
- en: Lists of function parameters or arguments are comma-separated.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to extend the AST in a couple of spots to support function calls, declarations,
    and definitions. Let’s start with function calls, which are a kind of expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The AST node for a function call includes the function name and a list of arguments.
    Each argument is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    node so that it can represent either function or variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve renamed the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    node to <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    (We’ll walk through the other changes to this node in a moment.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    node includes the same information that <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    did in earlier chapters: a variable name and an optional initializer. But it looks
    a little different from the other AST nodes we’ve seen so far; it doesn’t include
    a named constructor like <samp class="SANS_TheSansMonoCd_W5Regular_11">FunDecl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">VarDecl</samp>. When a node in
    ASDL has multiple constructors—like the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    node and most of the other AST nodes do—each constructor needs a distinct name
    so we can tell them apart. But since the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    node has only one constructor, we aren’t required to name that constructor. In
    ASDL jargon, a node definition with exactly one unnamed constructor is a *product
    type*. The other nodes we’ve used up until now are *sum types*, because they all
    have named constructors. Product types are just a syntactic convenience so that
    we aren’t forced to use clunky, redundant constructor names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    Here’s the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp>
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make a few changes here. First, as I already noted, we’ll rename
    it to the more accurate <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    We’ll also add function parameters, and we’ll make the function body optional
    so this node can represent both function declarations and function definitions.
    Lastly, for consistency with <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>,
    we’ll remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>
    constructor name to turn this into a product type. Our revised AST node for representing
    function declarations and definitions is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the top-level definition of a program. Now, instead
    of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function,
    a program is a list of function definitions and declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 9-15](chapter9.xhtml#list9-15) shows the complete updated AST.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-15: The abstract
    syntax tree with function calls, declarations, and definitions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> can appear
    as a block item, but only a <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    can appear in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    header. Note that this AST can represent nested function definitions, like the
    one in [Listing 9-5](chapter9.xhtml#list9-5), even though we don’t support them.
    We’ll check for nested function definitions during the semantic analysis stage
    and throw an error if we encounter any.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-16](chapter9.xhtml#list9-16) shows the updated grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-16: The grammar with
    function calls, declarations, and definitions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp> symbols in [Listing
    9-16](chapter9.xhtml#list9-16) don’t have equivalent nodes in the AST. I’ve factored
    them out of the production rules for function declarations and function calls,
    respectively, to make those rules a bit more readable. A <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>
    consists of just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword if a function has no parameters; otherwise, it consists of a comma-separated
    list of parameters, each with a type and name. An <samp class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>
    consists of a comma-separated list of expressions. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>
    is required in a function declaration, but <samp class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>
    is optional in a function call. Parsing a comma-separated list of arguments or
    parameters is similar to parsing a list of block items; just consume the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> tokens between list elements,
    and stop when you see a) token.
  prefs: []
  type: TYPE_NORMAL
- en: Function calls have higher precedence than any binary or ternary operator, so
    you should handle them when parsing the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    symbol. If a <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> starts
    with an identifier, look ahead one token to figure out whether the expression
    is a variable or a function call. If the next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>,
    you can assume it’s a function call. Similarly, you’ll need to check for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(</samp>token to distinguish between function
    and variable declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: During the variable resolution pass, we give every local variable a new, unique
    name. However, we shouldn’t rename entities with external linkage. Two declarations
    of local variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    refer to distinct memory addresses, so we assign them distinct names. But two
    declarations of a function named <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    refer to the same code, so those declarations should keep the same name throughout
    compilation. Furthermore, an object with external linkage must retain the name
    from the original source code because the linker will rely on that name during
    symbol resolution. The linker won’t be able to link an object file that calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> to the object file that
    defines <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> unless the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> was preserved when each
    of those object files was compiled.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll therefore need to update the variable resolution pass to rename identifiers
    with no linkage but leave identifiers with external linkage unchanged. (Since
    this pass will handle functions as well as variables, I’ll call it *identifier
    resolution* instead of variable resolution from now on.) We’ll check for all the
    usual error conditions, like duplicate declarations and undeclared identifiers;
    we’ll also validate that there are no nested function definitions. The logic to
    catch duplicate declarations will change slightly, since it’s legal to declare
    a name with external linkage more than once in the same scope. For instance, [Listing
    9-17](chapter9.xhtml#list9-17) is perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-17: Multiple function
    declarations in the same scope</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because both declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    have external linkage, they refer to the same function, so they don’t conflict.
    Duplicate declarations of an identifier conflict only when they refer to different
    entities; when you use that identifier later in the same scope, there’s no way
    to tell which entity it should refer to.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a few other error cases to check for. We must validate that every
    declaration of a function has the same number of parameters and that no function
    is defined more than once. Also, we must validate that variables aren’t used as
    functions and that functions are called with the right number of arguments. These
    errors aren’t that similar to the error cases we already check for, because they’re
    not really about what identifiers are in scope. They’re *type errors*, which occur
    when different declarations of an object have conflicting types or when an object
    is used in a way its type doesn’t support.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll define a separate type checking pass to catch these errors. This pass
    will also build up a symbol table to store the type of every identifier in the
    program, along with a few other properties of identifiers that we need to track.
    We’ll refer back to the symbol table in later compiler stages. (This is different
    from the symbol table in an object file, which the linker uses during symbol resolution.
    The symbol table we build in the type checker is internal to the compiler.)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this chapter, the semantic analysis stage will consist of three
    passes: identifier resolution, type checking, and loop labeling. The loop labeling
    pass can happen at any point relative to the other two passes.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Identifier
    Resolution</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s update the identifier resolution pass to handle function calls, function
    declarations, and function definitions. We’ll need to track one new piece of information
    for each entry in the identifier map: whether it has external linkage. As you
    build up your identifier map, don’t assume that functions always have external
    linkage and variables never do. That assumption holds right now, but it won’t
    in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also update a couple of names in our pseudocode: we’ll change <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_map</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>, and we’ll
    rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp>
    field in the identifier map to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>,
    since function declarations can appear outside of blocks, at the top level.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Calls</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A function name, like a variable name, needs to be present in the identifier
    map before you can use it. [Listing 9-18](chapter9.xhtml#list9-18) demonstrates
    how <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> should handle
    function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-18: Resolving function
    calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we look up the function name in the identifier map to confirm that it’s
    in scope at this point in the program. Then, we replace this name with the new
    name from the identifier map. In a valid program, this new name will be the same
    as the original name, since we don’t rename identifiers with external linkage.
    But we also need to consider invalid programs. Maybe <samp class="SANS_TheSansMonoCd_W5Regular_11">fun_name</samp>
    is actually the name of a local variable instead of a function; in that case,
    trying to call it like a function is a type error. Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">fun
    _name</samp> here will allow us to catch this type error during type checking.
    We’ll also wait until the type checking pass to make sure this function call has
    the right number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: After we replace the function’s name, we recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    on each function argument, just like we recursively resolve each subexpression
    in unary, binary, and ternary expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Declarations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s consider function declarations. We can handle a function declaration
    in almost exactly the same way whether it appears in a block or at the top level.
    First, we add the function name to the current scope. Then, we process its parameters,
    adding them to a new inner scope. Finally, if there’s a function body, we process
    that too. [Listing 9-19](chapter9.xhtml#list9-19) illustrates how to resolve function
    declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-19: Resolving function
    declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Before we update the identifier map, we need to make sure that we’re not illegally
    redeclaring an identifier ❶. If the identifier isn’t already in scope, there’s
    no conflict. If the identifier was declared in an outer scope, that’s also fine;
    the new declaration shadows the existing one. So far, this is exactly the same
    as how we handle variable declarations. However, we also need to consider linkage.
    Multiple declarations of an identifier with external linkage can appear in the
    same scope. We already know the new declaration has external linkage because it’s
    a function declaration, so it’s legal as long as the old declaration has external
    linkage too. But if the old declaration has no linkage (because it declares a
    local variable), we’ll throw an error. The <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>
    attribute in the identifier map tells us whether an identifier has external linkage.
    (In the next chapter, it will track whether the identifier has any linkage at
    all, either internal or external.)
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no conflicting declaration, we add this name to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>
    ❷. We don’t generate new names for functions; the <samp class="SANS_TheSansMonoCd_W5Regular_11">new_name</samp>
    attribute for this map entry should just be the original name. Because this declaration
    has external linkage, the <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>
    attribute should be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we resolve the parameter names. The list of function parameters in a
    declaration starts a new scope, so we make a copy of the identifier map to keep
    track of them ❸. Parameter names can shadow names from the outer scope, but two
    parameters in the same function declaration can’t share a name. So, this is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve left out the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_param</samp>,
    but it should be the same as your existing code to resolve variable declarations:
    it should make sure the parameter name isn’t already declared in the current scope,
    generate a unique name for it, add it to the identifier map, and return the new
    name. You may want to write one helper function to resolve both parameters and
    local variable declarations, since the logic is the same in both cases.'
  prefs: []
  type: TYPE_NORMAL
- en: We resolve the function’s parameters for two reasons. First, we need to validate
    that there are no duplicate parameter names. Second, we need to make sure the
    parameters are in scope when we process the function body. When we process a function
    declaration with no body, the second point doesn’t matter; we could get away with
    checking for duplicate parameters without renaming them or updating the inner
    scope. However, I think it’s easiest to process function declarations in a uniform
    way whether they have a body or not.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in [Listing 9-19](chapter9.xhtml#list9-19) is processing the function
    body, if there is one. We handle this with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp>,
    as usual; we just need to make sure to pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>
    so the function parameters will be in scope. The function name itself is also
    in scope because we added it to the outer map before making a copy; we’ll therefore
    be able to handle functions that call themselves recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function parameters and function body are in the same scope, so you should
    pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>, and not
    a copy of it, when you process the function body. This, for example, is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The variable declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3;</samp>
    is an illegal duplicate declaration because it’s in the same scope as parameter
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can return the updated <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>
    node. While the function name itself hasn’t changed, the list of parameters and
    any variables declared in the function body have been renamed in this new node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Local Declarations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can process local variable declarations exactly the same way as in previous
    chapters; just be sure to record in the identifier map that these declarations
    do not have linkage. To process a local function declaration, first check if it
    has a body. If it does, throw an error; otherwise, call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve
    _function_declaration</samp>, which we defined in [Listing 9-19](chapter9.xhtml#list9-19).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Top-Level Processing</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we need to put all this together to process a list of function declarations.
    Just process them in order, building up the identifier map as you go. Each function
    name you add will remain in scope as you process later function declarations.
    The parameter names and local variables in a function won’t be visible in later
    functions, because they were added to an inner scope.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Type
    Checker</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our remaining validation is all type checking. Every identifier, whether it’s
    a function or a variable, has a type. Variables can have types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    but at this point in our project the type of every variable is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    A function’s type depends on its return type and the types of its parameters.
    For example, a function can have a type like “function that takes three <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters and returns an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Right now, we support only
    functions that take <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters
    and return <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> results, so
    only the number of parameters varies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type checking pass validates that all declarations and uses of an identifier
    have compatible types. For example, if you declare that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a variable, you can’t call it like a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t declare a function in multiple places with different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t call a function with the wrong number of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can’t define the same function more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This last error isn’t a type error per se, but it’s easiest to check here.
  prefs: []
  type: TYPE_NORMAL
- en: To type check the program, we’ll record the type of every identifier in the
    symbol table. We’ll also record whether each function we encounter is defined
    or just declared; that is, whether it has a body. The symbol table will be our
    central source of information about every identifier in the program. In this chapter,
    we’ll primarily use the symbol table to catch type errors. We’ll add more information
    to this table, and find more uses for it, in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a symbol table, we need a way to represent types in the compiler,
    just like we need a way to represent ASTs. Right now, your type definition should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Every variable has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and the only information we need about a function’s type is how many parameters
    it has. We’ll add more types in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build the symbol table by traversing the program in the usual fashion.
    When we encounter a function or variable declaration, we’ll record its type in
    the symbol table. The type checker doesn’t transform the AST like the identifier
    resolution pass does, so the individual type checking methods won’t return transformed
    AST nodes; they’ll just add symbol table entries and report errors. (The type
    checker *will* transform the AST in [Part II](part2.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-20](chapter9.xhtml#list9-20) shows how to type check a variable
    declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-20: Type checking
    variable declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Every variable has a unique name by this point, so we know that this declaration
    won’t conflict with any existing entry in the symbol table. We just add it to
    the symbol table and then type check its initializer, if it has one. Functions
    are a little trickier. Because you can declare a function more than once, it might
    already have an entry in the symbol table. So, before adding a function to the
    symbol table, you need to validate it against what’s already there. [Listing 9-21](chapter9.xhtml#list9-21)
    gives the pseudocode to type check a function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-21: Type checking
    function declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We first check that the function hasn’t already been declared with a different
    type ❶. Then, we make sure we’re not redefining a function that was already defined
    ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute
    in a function’s symbol table entry tracks whether we’ve already type checked a
    definition of that function. (The symbol table entries for variables don’t need
    this attribute.)
  prefs: []
  type: TYPE_NORMAL
- en: After validation, we add the function to the symbol table ❸. This will overwrite
    the existing symbol table entry, if there is one. That’s okay, because the type
    won’t change. We just need to take the old entry into account when setting the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute. If the
    function was already defined, or if the current declaration has a body, we’ll
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Finally, if the current declaration has a body ❹, we’ll add each of the function’s
    parameters to the symbol table, then type check the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the symbol table includes every declaration we’ve type checked
    so far, even if it’s not in scope. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The nested function declaration ❶ is not in scope when the function is declared
    again ❷. Nonetheless, declaration ❶ will be in the symbol table when we type check
    declaration ❷. So, we’ll detect that these two declarations conflict and throw
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll validate uses of identifiers as well as declarations. An identifier can
    be used as a variable in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    AST node or as a function name in a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunctionCall</samp>
    AST node. In both cases, you should validate that the identifier has the expected
    type. [Listing 9-22](chapter9.xhtml#list9-22) demonstrates how to type check both
    kinds of expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-22: Type checking
    expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When an identifier is called as a function, you need to validate that it was
    declared as a function, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    ❶. You also need to validate that it’s called with the correct number of arguments
    ❷, then recursively type check each of its arguments ❸. When an identifier is
    used as a variable, you need to validate that it was declared as a variable and
    not a function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that your symbol table will need to be accessible in later compiler
    passes. I recommend making the symbol table a global variable (or a singleton,
    depending on your implementation language) so that it’s easy to access from anywhere
    in the compiler. In our type checking pseudocode, the symbol table is an explicit
    argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_*</samp>
    functions instead of a global variable, for the sake of clarity. But in a real
    implementation, I’ve found that using a global variable is less cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’re sure the input program is valid, let’s convert it to TACKY. We’ll
    need to make a few changes to the TACKY IR. First, we need a new TACKY instruction
    to represent function calls. Second, we need to include parameters in TACKY function
    definitions. Finally, we’ll define a whole TACKY program as a list of functions
    instead of a single function. [Listing 9-23](chapter9.xhtml#list9-23) shows the
    updated definition of the TACKY IR.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-23: Adding function
    calls to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: These changes correspond closely to the changes to the AST in [Listing 9-15](chapter9.xhtml#list9-15).
    The TACKY IR requires fewer changes than the AST, however, because we don’t represent
    function declarations in TACKY. Like variable declarations without initializers,
    function declarations without bodies are discarded during IR generation. Only
    function definitions are converted to TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction
    requires a function name, a list of arguments, and a destination for the return
    value. Just like the operands of other TACKY instructions, function arguments
    must be constants or variables, not expressions.
  prefs: []
  type: TYPE_NORMAL
- en: To convert an entire program to TACKY, process the top-level function declarations
    one at a time, converting each function definition to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    and discarding any declaration without a body. To convert a function call to TACKY,
    generate the instructions to evaluate each argument and construct a list of the
    resulting TACKY values. The TACKY for the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun(e1,
    e2, …)</samp> will look like [Listing 9-24](chapter9.xhtml#list9-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-24: Converting a
    function call to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same approach we use to handle other expressions with nested subexpressions,
    like unary and binary operations. Now we’re just generalizing it to an arbitrary
    number of nested expressions, since a function can have an arbitrary number of
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>
    instruction to the end of every function body, to make sure it returns to the
    caller even if some execution paths are missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Next, we’ll tackle the trickiest part of this chapter: implementing
    function calls in assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re going to make two big changes to the TACKY-to-assembly conversion pass
    in this chapter: putting function parameters on the stack so they can be accessed
    in the function body and converting the new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction to assembly. We’ll also make a couple of smaller changes to the pseudoregister
    replacement and instruction fix-up passes. But before we make these changes, we
    need to understand the calling convention we’re going to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding
    Calling Conventions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *calling convention* is a contract between the caller and callee about how
    a function will be called. It answers questions like:'
  prefs: []
  type: TYPE_NORMAL
- en: How are arguments passed to the callee? Are they passed in registers or on the
    stack?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is a function’s return value passed back to the caller?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the callee or caller responsible for removing arguments from the stack at
    the end of a function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which registers is the callee allowed to overwrite, and which does it need to
    preserve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared calling convention allows the caller and callee to work together. The
    caller knows where to put arguments, and the callee knows where to look for them.
    The callee knows where to store a return value, and the caller knows where to
    find it after the callee returns. The callee and caller both know which registers
    they need to save to ensure that the callee won’t clobber any values the caller
    will use after the function call. This ensures that both functions can access
    the information they need.
  prefs: []
  type: TYPE_NORMAL
- en: A calling convention is part of a larger specification, called the *application
    binary interface (ABI)*, that makes it possible to link object files that were
    built by different compilers. As long as the object files all share the same ABI,
    they’ll be able to interoperate. In addition to calling conventions, the ABI specifies
    how different C types are represented in memory, which will be important in [Part
    II](part2.xhtml). Most of the other details that make up the ABI—like executable
    file formats—are handled by the assembler, linker, and operating system, so we
    don’t need to worry about them.
  prefs: []
  type: TYPE_NORMAL
- en: If your compiler adheres to the calling conventions on your platform, you can
    compile programs that depend on the standard library and any other libraries you
    might want to use. You’ll be able to compile programs that make system calls and
    perform I/O operations. You still can’t compile the standard library itself—it
    relies on all sorts of language features that we haven’t implemented—but since
    it’s already compiled and lives on your system, you can link to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Unix-like system uses the standard calling convention defined in the
    *System V ABI*. (This ABI takes its name from Unix System V, an early commercial
    version of Unix.) Since we’re targeting macOS and Linux, we’ll use the System
    V calling convention. There are different versions of the System V ABI for different
    processor architectures; we’ll use the version for x64 processors. Windows has
    its own ABI, which we won’t worry about. If you’re doing this project on Windows
    Subsystem for Linux, you’ll still be able to use the System V calling convention.
    Next, we’ll look at how this calling convention works.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calling
    Functions with the System V ABI</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, I listed a few questions that a calling convention
    must answer. Let’s see how the System V calling convention answers these questions,
    and the other requirements it imposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument passing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first six integer arguments to a function are passed in the EDI, ESI, EDX,
    ECX, R8D, and R9D registers, in that order (64-bit integers are passed using these
    registers’ 64-bit names instead: RDI, RSI, RDX, RCX, R8, and R9). Any remaining
    arguments are pushed onto the stack *in reverse order.* For example, to implement
    the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(a, b, c, d,
    e, f, g, h)</samp>, you first copy variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into EDI, then copy <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into
    ESI, and so on, up to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    Then, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, the last
    argument, onto the stack. Finally, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    onto the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Return values**'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, a function’s return value is passed in EAX (or RAX if you’re returning
    a 64-bit integer). The return value must be in EAX when the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument cleanup**'
  prefs: []
  type: TYPE_NORMAL
- en: After the callee returns, the caller removes any arguments from the stack. The
    callee does not clean up arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Caller-saved and callee-saved registers**'
  prefs: []
  type: TYPE_NORMAL
- en: If a register is *caller-saved*, the callee is allowed to overwrite it. The
    caller must therefore save the register’s value to the stack before issuing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction if it will
    need it later. It can then pop that value off the stack after the function returns.
    (If the value in a register won’t be used after the function call, the caller
    doesn’t need to save it.) If a register is *callee-saved*, it must have the same
    contents when a function returns as it did at the start of the function. If the
    callee needs to use the register, it typically pushes the register’s value onto
    the stack during the function prologue, then pops it back off the stack during
    the function epilogue. Registers RAX, R10, R11, and all the parameter passing
    registers are caller-saved; the remaining registers are callee-saved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack alignment**'
  prefs: []
  type: TYPE_NORMAL
- en: The System V ABI requires the stack to be 16-byte aligned. In other words, the
    address stored in RSP, the stack pointer, must be divisible by 16 when we issue
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The ABI
    imposes this requirement because some instructions require 16-byte-aligned operands.
    It’s easier to maintain the correct alignment of these operands if the stack is
    16-byte aligned to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full System V x64 ABI at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
    However, looking at an example might be more useful than reading the spec. Consider
    [Listing 9-25](chapter9.xhtml#list9-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-25: A C program that
    includes a function call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-26](chapter9.xhtml#list9-26) gives the assembly code for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.
    It’s more optimized than what your compiler will produce, in order to illustrate
    the System V calling convention more clearly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-26: The assembly
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">in [Listing 9-25](chapter9.xhtml#list9-25)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-27](chapter9.xhtml#list9-27) gives the assembly code to call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-27: The assembly
    code to call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in [Listing 9-25](chapter9.xhtml#list9-25)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through this function call and see how the program state changes
    at each step. In the following diagrams, the left column shows the contents of
    the stack and general-purpose registers, and the right column shows the contents
    of RIP, which always holds the address of the next instruction to execute. (Note
    that the instruction addresses in these diagrams aren’t realistic. These addresses
    suggest that every instruction is 1 byte long, but instruction length varies,
    and it’s usually more than a single byte!)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](#fig9-1) shows the initial state of the program before the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The initial state
    of the program in [Listing 9-25](chapter9.xhtml#list9-25) [Description](description-18.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 9-1](#fig9-1), RSP and RBP point to the same address. There are no
    local variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>,
    so we don’t need to allocate any stack space. The registers in this diagram all
    hold 64-bit values, but we’ll usually use 32-bit register names, like EDI, ESI,
    and EDX, because all our function arguments and return values are 32-bit integers.
    However, we’ll use 64-bit register names when saving to and restoring from the
    stack, because <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> require 64-bit operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, is passed in RDI. Let’s
    say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">15</samp>. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>,
    we need to pass all eight arguments according to the System V calling convention.
    The first six arguments will be passed in registers, and the last two will be
    passed on the stack. But copying the first argument into RDI will clobber <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, which we’ll need again after
    the function call. So, the very first step, before passing any arguments, is to
    save <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> onto the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, we adjust RSP so it will be 16-byte aligned when we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction. We need to work backward from the number of arguments and saved registers
    we put on the stack. Before the start of the function call, we can assume that
    the stack pointer is a multiple of 16\. (To guarantee this, we’ll allocate stack
    space in multiples of 16 bytes in the function prologue.) We’ll then push some
    registers and function arguments onto the stack; each of these will be 8 bytes.
    If the total number of registers and arguments pushed onto the stack is even,
    the stack will be 16-byte aligned after we’ve added all of them. If the number
    of registers and arguments on the stack is odd, we need to subtract 8 bytes from
    the stack pointer to get the right alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we push one register, RDI. We’ll also need to push two arguments
    onto the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. In total, we’ll push three values,
    totaling 24 bytes, onto the stack before issuing the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction. Therefore, we need to adjust the stack by another 8 bytes after saving
    RDI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to set up the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.
    We start with the first six arguments, which will be passed in registers. Because
    the arguments are all 32-bit integers, we’ll use 32-bit register names here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we push the remaining two arguments onto the stack, in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each of these instructions will push a 64-bit constant onto the stack, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction can
    push only 64-bit values. [Figure 9-2](#fig9-2) shows the state of the program
    after we save RDI, adjust the stack, and set up the function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: The state of the
    program just before the call instruction [Description](description-19.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tell that the stack is indeed 16-byte aligned because the stack pointer
    is divisible by 16 (or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    in hexadecimal). Once our arguments are set up, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> assembly instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction does
    two things. First, it pushes the address of the instruction that immediately follows
    it, the return address, onto the stack. Then, it transfers control to the instruction
    labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> by copying that
    instruction’s address into RIP. [Figure 9-3](#fig9-3) shows the state of the program
    just after the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The state of the
    program just after the call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction
    [Description](description-20.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The function prologue, which we’re already familiar with, sets up the stack
    frame for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, which puts
    the program in the state shown in [Figure 9-4](#fig9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: The state of the
    program after the function prologue for fun [Description](description-21.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, the portion of the stack with a white background is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>’s stack frame. The portion
    with a light gray background is <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>’s
    stack frame. In <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we need
    to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. This requires us to access
    one parameter that was passed in a register (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>)
    and one that was passed on the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>).
    The next instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into
    EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to add <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>,
    which was passed on the stack, to the value in EAX. Stack arguments, just like
    local variables, can be addressed relative to RBP. We know that RBP points to
    the stack slot that contains the base address of the caller’s stack frame. The
    stack slot just below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>,
    contains the return address in the caller. The value below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>,
    will be the first stack argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>.
    (Remember that we pushed stack arguments in reverse order. That means <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>,
    the first stack argument, was pushed onto the stack last and is now closest to
    the current stack frame.) The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>,
    will be 8 bytes below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>,
    and we can access it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We pushed a 64-bit constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>,
    onto the stack, but <samp class="SANS_TheSansMonoCd_W5Regular_11">addl</samp>
    needs a 32-bit operand. It will therefore interpret the 4 bytes starting at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp> as a 32-bit integer, effectively
    dropping the upper 32 bits. Since those bits are just leading zeros, the resulting
    value will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. That
    is, even though each argument pushed onto the stack must be 64 bits, we can still
    interpret them as 32-bit integers in the callee.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have the correct return value in EAX. We’re ready for the
    function epilogue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction
    is unnecessary in this particular program. Usually, this instruction deallocates
    the current stack frame, putting the old value of RBP back at the top of the stack.
    But we didn’t allocate any stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>,
    so RSP and RBP already have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: The epilogue puts the stack back the way it was before the prologue. [Figure
    9-5](#fig9-5) shows how things will look at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: The state of the
    program just before returning to the caller [Description](description-22.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We return to the caller with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction, which pops the return address off the stack and transfers control
    to that address. [Figure 9-6](#fig9-6) shows the state of the program after we
    return to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The state of the
    program just after returning to the caller [Description](description-23.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the stack is in exactly the same state as it was just before
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The
    last step is to clean up the padding and stack arguments and restore <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    to RDI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now the stack is back the way it was before the function call, and RDI has been
    restored to its original state. The RAX register contains the return value, which
    we can use later in the function body. Because the other registers were uninitialized
    before the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we
    don’t need to clean them up now. [Figure 9-7](#fig9-7) shows the state of the
    program once we’ve finished cleaning up after the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig9-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: The state of the
    program after the function call has been completed [Description](description-24.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a clear understanding of how to call functions
    and access function parameters in assembly. We’re ready to update the assembly
    generation stage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Function
    Calls and Definitions to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to extend our assembly AST now, for the first time since [Chapter
    4](chapter4.xhtml). [Listing 9-28](chapter9.xhtml#list9-28) defines the new AST,
    with changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-28: The assembly
    AST with support for function calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we change the top-level definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    to support multiple function definitions. We also introduce three new instructions.
    To adjust the stack alignment before a function call, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction we already have, which will eventually be emitted as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction. To remove arguments and padding after a function call, we add a corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> instruction,
    which will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>.
    We also need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction
    to push arguments onto the stack. We’ve already used <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    in the function prologue, but in such a limited way that we could add it mechanically
    during code emission. Now that we’re going to be using it more extensively, we
    need to add it to the assembly AST. And, of course, we need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp>
    instruction to actually call functions. Lastly, we need a few new registers for
    argument passing: <samp class="SANS_TheSansMonoCd_W5Regular_11">CX</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SI</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">R8</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">R9</samp>.
    Arguments are also passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DX</samp>
    register, which is already in our AST. Like in previous chapters, the AST doesn’t
    distinguish between the different aliases for each register: <samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>,
    for example, will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">%rdi</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%dil</samp>,
    depending on whether we want to use the whole register, its lower 4 bytes, or
    its lowest byte.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these additions to the assembly AST in place, we can update the TACKY-to-assembly
    conversion. Remember that we made three changes to the TACKY IR: we defined a
    program as a list of functions instead of a single function, added parameters
    to each function definition, and added a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Accounting for the first change is straightforward: we convert a
    list of functions in TACKY to a list of functions in assembly. Next, we’ll make
    function parameters accessible in assembly. Then, we’ll see how to convert the
    new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction to
    assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Function Parameters
    in Assembly</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the start of a function, each parameter is stored in the register or stack
    location dictated by our calling convention. We could access function parameters
    in assembly code by referring directly to those locations. The assembly code for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> in [Listing 9-26](chapter9.xhtml#list9-26)
    took this approach; when we needed to add parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, we referred to their
    calling convention–defined locations, <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>. This works,
    but it has a few disadvantages. It requires us to push parameter passing registers
    onto the stack just before function calls and pop them off again afterward, like
    we had to push and pop RDI before and after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    in [Listing 9-27](chapter9.xhtml#list9-27). It also leads to conflicts with other
    instructions that use parameter passing registers. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    writes to the EDX register, potentially clobbering the function parameter stored
    there. Finally, it makes the pseudoregister allocation phase more complex, because
    parameters must be handled differently from local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll take a different approach that bypasses these problems: at the start
    of each function body, we’ll copy each parameter from its calling convention–defined
    register or memory address into a slot in the current function’s stack frame.
    Let’s look at a simple example. [Listing 9-29](chapter9.xhtml#list9-29) defines
    a function with one parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-29: A function with
    a single parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we generate the assembly for this function, we’ll include an extra <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction at the start of
    the function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This instruction copies the function’s first parameter into the <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>
    pseudoregister. Keep in mind that any uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Var("param")</samp>
    in TACKY will be translated to uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("param")</samp>
    in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated assembly for the whole function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: (Really, <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> would be
    renamed during identifier resolution, and we would emit an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>
    instruction during TACKY generation, but neither of these details matter for this
    example.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll replace pseudoregisters with stack locations in the usual fashion. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> is our only pseudoregister,
    we’ll assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>.
    We’ll ultimately emit the assembly program shown in [Listing 9-30](chapter9.xhtml#list9-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-30: The assembly
    program for [Listing 9-29](chapter9.xhtml#list9-29)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Copying parameters onto the stack keeps code generation simple. We won’t need
    to save caller-saved registers before function calls or restore them afterward,
    because we use these registers only in very transient ways. When we pass function
    parameters in registers, we save them to the stack immediately, instead of leaving
    them in those registers long term. Aside from function parameters, the only values
    we store in caller-saved registers are return values, the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instructions, and values that are temporarily copied into R10D or R11D during
    the instruction rewriting stage. Just like parameters, these values are either
    used or copied to the stack right away. The upshot is that the values in caller-saved
    registers will never need to persist across function calls; that’s why we don’t
    need to save or restore them. (Meanwhile, the callee doesn’t need to save or restore
    most callee-saved registers because we don’t use them at all. The sole exceptions
    are the RBP and RSP registers, which we save and restore in the function prologue
    and epilogue.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the same lines, we don’t have to worry about the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction clobbering the parameter in EDX. We don’t need any extra logic to
    handle function parameters during pseudoregister allocation, either: we can assign
    them to stack locations just like local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, copying parameters to the stack is inefficient. First of
    all, we’re generating extra <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions. Second, we’re forcing the program to access memory, which is usually
    slower than registers, every time it reads or writes a parameter. Luckily, we’ll
    be able to get rid of most of these extra instructions and memory accesses when
    we implement register allocation in [Part III](part3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: When you generate these parameter-copying instructions, start by moving the
    first parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DI)</samp>
    into a pseudoregister, the second from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(SI)</samp>,
    and so on, up to the sixth parameter (or until you run out of parameters, if the
    function has fewer than six). Then, copy the seventh parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp>,
    the eighth from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(24)</samp>,
    and so on until you’ve handled every parameter. As we saw earlier, the top of
    the caller’s stack frame, <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>,
    is the return address, and the seventh parameter—the first parameter passed on
    the stack—is always just below it, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>.
    From there, the offset increases by 8 bytes for each additional parameter, because
    the caller pushes them onto the stack as 8-byte values (even though the callee
    interprets them as 4-byte values).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier, we stepped through the assembly code for a function call. Now let’s
    look at how to generate this assembly code. [Listing 9-31](chapter9.xhtml#list9-31)
    gives the pseudocode to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY instruction to assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-31: Emitting assembly
    for a function call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to make sure the stack is properly aligned. We must do this
    before passing arguments on the stack; if we add extra padding between the arguments
    and the callee’s stack frame, the callee won’t be able to find them. When we walked
    through the function call in [Listing 9-27](chapter9.xhtml#list9-27), we saw that
    if we pushed an even number of arguments and caller-saved registers to the stack,
    it would still be 16-byte aligned afterward—no padding required. If we pushed
    an odd number, we’d need to subtract another 8 bytes from the stack pointer to
    maintain the correct alignment. Now, thanks to the parameter-copying trick from
    the previous section, we need to consider only arguments that are pushed onto
    the stack, not caller-saved registers. So, we just check how many arguments we’ll
    push onto the stack, then emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction if that number is odd.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass the function arguments. As we process each argument, we convert
    it from a TACKY value to an assembly operand with the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>
    helper function. (I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>,
    since you already know how to perform this conversion.) The first six arguments
    are copied into the appropriate registers. A function may, of course, have fewer
    than six arguments; in that case, we copy every argument into a register.
  prefs: []
  type: TYPE_NORMAL
- en: If the function has more than six arguments, the remainder must be passed on
    the stack. We push the last argument, then the second-to-last, and so on, up through
    the seventh argument. Keep in mind that our arguments are 4-byte integers, but
    we need to push 8 bytes onto the stack for each of them (because the ABI requires
    it, and because <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> takes
    only 8-byte operands). However, the callee will use only the lower 4 bytes of
    each argument. If an argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operand, we pass it
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction
    ❶. If it’s in memory, we first copy the argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>,
    then push that ❷. Using an immediate value in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq
    $7</samp> pushes the 8-byte representation of that value. Pushing a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    operand pushes the entire 8-byte register, whose lower 4 bytes we can access with
    the corresponding 4-byte alias. (The code emission pass will use 4-byte register
    aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> in most
    instructions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>,
    and 8-byte aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%rax</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions.)
  prefs: []
  type: TYPE_NORMAL
- en: If we used a 4-byte memory operand directly in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq
    -4(%rbp)</samp>, we’d push the 4 bytes of our operand followed by 4 bytes of whatever
    happened to follow it in memory. This would usually be fine, if a bit kludgy.
    But if the 4 bytes that followed our operand weren’t readable memory, trying to
    access those bytes would trigger a segmentation fault and crash the program. This
    issue won’t come up when we push an operand from the stack; the bytes right after
    it will hold either some other temporary value from the current function or the
    saved base address of the caller’s stack frame. But it could come up when we push
    static variables, which we’ll implement in [Chapter 10](chapter10.xhtml). A static
    variable might appear at the very end of a valid memory region; in this case,
    the memory addresses just past that variable could be invalid. (You can read more
    about this edge case in Randall Hyde’s *The Art of 64-Bit Assembly, Volume 1*
    [No Starch Press, 2021]; see section 5.5.3.3, “Passing Parameters on the Stack.”)
    Copying the operand from memory into a register before we push it avoids this
    problem. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp> is
    the only register we can use to help push memory operands onto the stack, because
    we have to preserve the callee-saved registers, we’ve already put arguments in
    the parameter passing registers, and we’ve reserved R10 and R11 for the instruction
    fix-up phase.
  prefs: []
  type: TYPE_NORMAL
- en: Once every argument is in place, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction to transfer control to the callee. After the call returns, we no longer
    need the arguments that were passed on the stack, and we certainly don’t need
    the padding. We add the total size of those arguments and the padding to the stack
    pointer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp>
    instruction. After deallocating this space, the stack pointer will be back where
    it was before we started preparing for the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we retrieve the function’s return value. This value will be in EAX,
    and we copy it to its destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 9-1](chapter9.xhtml#tab9-1) and [9-2](chapter9.xhtml#tab9-2) summarize
    this chapter’s changes to the conversion from TACKY to assembly. New constructs
    and changes to existing constructs are bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">params</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    instructions)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FunCall(fun_name, args, dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly for a function call is too complex to fully specify in a table,
    so the conversion for <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    in [Table 9-2](chapter9.xhtml#tab9-2) is more of a rough outline.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we’ll update the pseudoregister replacement pass. Most of the logic here
    won’t change: we’ll replace pseudoregisters in each function definition exactly
    the same way as in past chapters. As we saw earlier, pseudoregisters that represent
    function parameters don’t require any special handling. They’ll get assigned locations
    on the stack, just like local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we do need to make a couple of updates. First, we’ll extend this pass
    to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    instruction. (We don’t directly push pseudoregisters now, but we will in [Part
    II](part2.xhtml).) Second, we’ll change how we track the stack space needed by
    each function. Previously, this whole pass returned a single number because the
    program contained a single function. Now we need to return a stack size for each
    function we process. You could record each function’s stack size in the symbol
    table, or annotate each function with its stack size in the assembly AST.
  prefs: []
  type: TYPE_NORMAL
- en: Note that parameters count toward a function’s stack size, whether they were
    passed on the stack or in registers, since we copy them into the function’s stack
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Allocating Stack
    Space During Instruction Fix-Up</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to make one small adjustment to the instruction fix-up pass: we’ll
    change how we add <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    to each function definition. First, we’ll look up the stack space needed by each
    function wherever we recorded it during pseudoregister replacement. Next, we’ll
    round that stack size up to the next multiple of 16\. Rounding up the size of
    the stack frame makes it easier to maintain the correct stack alignment during
    function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to make sure the code emission stage can handle all our new instructions
    and operands. Most of this is pretty straightforward, but there are a few platform-specific
    details to consider. As we’ve already seen, function names are prefixed with an
    underscore on macOS, but not on Linux. This applies in <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions too, so on macOS you’ll emit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'and on Linux you’ll emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux, you’ll also call functions in external libraries differently from
    functions defined in the same file. If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    isn’t defined in the current translation unit, you’ll emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: PLT stands for *procedure linkage table*, a section in ELF executables. (*ELF*,
    short *for Executable and Linkable Format*, is the standard file format for object
    files and executables on Linux and most other Unix-like systems; macOS uses a
    different file format called *Mach-O*.) Programs use the PLT to call functions
    in shared libraries. We’ve already learned that the linker combines object files
    and resolves symbols to concrete locations in memory in order to produce an executable.
    On modern systems, these locations are typically encoded as offsets from the current
    instruction rather than absolute memory addresses. When we define and use a symbol
    in the same executable, the linker can figure out the symbol’s relative offset
    from the instruction that uses it and resolve the reference.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries are a different story. When a program uses a shared library,
    the linker doesn’t copy the whole library into the executable. Instead, the library
    is loaded into memory separately at runtime. The linker doesn’t know exactly where
    this library will live in memory, so it can’t resolve the names of shared library
    functions. Another piece of software, called the *dynamic linker*, must resolve
    these names at runtime. The dynamic linker can resolve symbols in a few different
    ways, but the most common approach is *lazy binding*. Using lazy binding, we don’t
    figure out a function’s address until the program tries to call that function.
    That’s where the PLT comes in. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">foo@PLT</samp>
    doesn’t refer to the function <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    It refers to a tiny bit of code in the PLT that determines the address of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> if we don’t already know it,
    and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. The linker
    is responsible for generating this code, which is called a *PLT entry*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> isn’t defined in
    the current translation unit, it might be defined in a shared library or in another
    object file that the linker will include in the final executable. In the latter
    case, we don’t need the PLT: the linker will be able to figure out the address
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> (or, more precisely,
    its offset from the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction that refers to it). The code emission pass can’t tell these two cases
    apart, so it should include the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    suffix either way; there’s no harm in including this suffix when we don’t need
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For a more in-depth explanation of how the PLT works and why we need it, see
    the two blog posts on position-independent code listed in [Chapter 1](chapter1.xhtml)’s
    “Additional Resources” on [page 21](chapter1.xhtml#pg_21).*'
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, to check whether a function was defined in the current translation
    unit—and therefore whether it requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    modifier—you’ll need to look it up in the symbol table. On macOS, which handles
    lazy binding slightly differently, you don’t need the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    modifier at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 9-3](chapter9.xhtml#tab9-3) through [9-5](chapter9.xhtml#tab9-5) show
    the changes to the code emission pass for this chapter, with new constructs and
    updates to existing constructs bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeallocateStack(int)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Push(operand)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Call(label)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rax</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdx</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%dl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(CX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rcx</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%ecx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%cl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdi</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edi</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dil</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(SI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsi</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%esi</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%sil</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R8)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R9)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We now have 8-byte, 4-byte, and 1-byte names for every register. We’ll use 8-byte
    register names in <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions,
    1-byte names in conditional set instructions, and 4-byte names everywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Calling Library Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve updated the backend of your compiler, you’ll be able to compile
    programs that call standard library functions. You won’t be able to use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives, because any
    standard library header file will use language features your compiler doesn’t
    support. Instead, you’ll need to explicitly declare any library functions you
    want to use.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t many library functions we can call at this point. Because the only
    type we’ve implemented is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we can’t call functions that use any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type as either a return type or a parameter type. But we can call <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>,
    which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument
    and prints the corresponding ASCII character to stdout. This is enough for us
    to compile [Listing 9-32](chapter9.xhtml#list9-32), which is a slightly unorthodox
    implementation of “Hello, World!”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-32: Hello, World!</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try compiling [Listing 9-32](chapter9.xhtml#list9-32) with your compiler and
    running it. If you’ve implemented everything correctly, it will write to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is a big milestone! Take a moment to bask in your sense of accomplishment
    before running the remaining test cases.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function calls are the most powerful, and most complicated, feature we’ve seen
    so far. To implement them, you expanded the semantic analysis stage to understand
    different kinds of identifiers and learned the ins and outs of the System V calling
    convention. All that work paid off: you can finally compile programs that interact
    with the outside world!'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also laid the groundwork for other language features. You’ll expand on
    the idea of identifier linkage and build on the latest changes to the identifier
    resolution pass when you implement file scope variables and storage-class specifiers
    in the next chapter (the last chapter of [Part I](part1.xhtml)!). And you’ll continue
    to extend the type checker as you add more types throughout [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
