- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 3 CODE SIGNING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll write code that can extract code signing information
    from distribution file formats that malware often abuses, such as disk images
    and packages. Then we’ll turn our attention to the code signing information of
    on-disk Mach-O binaries and running processes. For each, I’ll show you how to
    programmatically validate the code signing information and detect any revocations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior-based heuristics covered throughout this book are a powerful approach
    to detecting malware. But the approach comes with a downside: *false positives*,
    which occur when code incorrectly flags something as suspicious.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: One way to reduce false positives is by examining an item’s code signing information.
    Apple’s support of cryptographic code signing is unparalleled, and as malware
    detectors, we can leverage it in a variety of ways, most notably to confirm that
    items come from known, trusted sources and that these items haven’t been tampered
    with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, we should closely scrutinize any unsigned or non-notarized
    item. For example, malware is often either wholly unsigned or signed in an ad
    hoc manner, meaning with a self-signed or untrusted certificate. While threat
    actors may occasionally sign their malware with fraudulently obtained or stolen
    developer certificates, it’s rare for Apple to have notarized the malware as well.
    Moreover, Apple is often quick to revoke the signing certificate or notarization
    ticket when it makes a mistake.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: You can find the majority of code snippets presented in this chapter in the
    *checkSignature* project, available in the book’s GitHub repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Code Signing in Malware Detection
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example of why code signing is useful for malware detection, imagine that
    you develop a heuristic to monitor the filesystem for persistent items (a reasonable
    approach to detecting malware, as the vast majority of Mac malware will persist
    on an infected host). Say your heuristic triggers when the *com.microsoft.update.agent.plist*
    property list is persisted as a launch agent. This property list references an
    application named *MicrosoftAutoUpdate.app*, which the operating system will now
    start automatically each time the user logs in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'If your detection capabilities don’t take into account the code signing information
    of the persisted item, you might generate an alert for what is actually a totally
    benign persistence event. The question, therefore, becomes: Is this really a Microsoft
    updater, or is it malware masquerading as such? By checking the application’s
    code signing signature, you should be able to answer this question conclusively;
    if Microsoft has indeed signed the item, you can ignore the persistence event,
    but if not, the item warrants a much closer look.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, existing malware detection products may fail to adequately take
    code signing information into account. For example, consider Apple’s Malware Removal
    Tool (MRT), a built-in malware detection tool found in certain versions of macOS.
    This platform binary is, of course, signed by Apple proper. Yet many antivirus
    engines have, at one point or another, flagged an MRT binary, *com.apple.XProtectFramework.plugins.MRTv3*,
    as malicious because their antivirus signatures naively matched MRT’s own embedded
    viral signatures ([Figure 3-1](chapter3.xhtml#fig3-1)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，现有的恶意软件检测产品可能未能充分考虑代码签名信息。例如，考虑一下苹果的恶意软件移除工具（MRT），这是某些版本macOS中内建的恶意软件检测工具。这个平台二进制文件自然是由苹果签名的。然而，许多杀毒引擎曾在某些时刻将MRT二进制文件*com.apple.XProtectFramework.plugins.MRTv3*标记为恶意软件，因为它们的杀毒签名天真地匹配了MRT自身嵌入的病毒签名（[图3-1](chapter3.xhtml#fig3-1)）。
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.jpg)'
- en: 'Figure 3-1: Apple’s Malicious Removal Tool flagged as malicious'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：苹果的恶意软件移除工具被标记为恶意软件
- en: A rather hilarious false positive indeed. Joking aside, products that incorrectly
    classify legitimate items as malware may alert the user, causing consternation,
    or worse, may break legitimate functionality by quarantining the item. While third-party
    security products luckily can’t delete system components such as MRT, Apple has
    been known to inadvertently block its own components, disrupting system operations.^([1](#chapter3-1))
    In both cases, the detection logic could have simply checked the item’s code signing
    information to see that it belonged to a trusted source.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个相当好笑的误报。开个玩笑，错误地将合法项目归类为恶意软件的产品可能会触发用户警报，引发恐慌，或者更糟糕的是，可能通过将项目隔离而破坏其正常功能。幸运的是，第三方安全产品无法删除像MRT这样的系统组件，但苹果曾因操作失误，阻止了自己的一些组件，从而中断了系统的操作。^([1](#chapter3-1))
    在这两种情况下，检测逻辑本来可以简单地检查项目的代码签名信息，确认它是否来自可信来源。
- en: 'Code signing information can do more than just reduce false positives. For
    example, security tools should allow trusted or user-approved items to perform
    actions that might otherwise trigger an alert. Consider the case of a simple firewall
    that generates a notification whenever an untrusted item attempts to access the
    network. To distinguish between trusted and untrusted items, the firewall can
    check the items’ code signing signatures. Creating firewall rules based on code
    signing information has a few benefits:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码签名信息不仅仅能减少误报。例如，安全工具应该允许受信任或用户批准的项目执行那些可能会触发警报的操作。考虑一个简单的防火墙，每当一个不受信任的项目尝试访问网络时，它会生成一个通知。为了区分受信任和不受信任的项目，防火墙可以检查项目的代码签名信息。基于代码签名信息创建防火墙规则有以下几个好处：
- en: If malware attempts to bypass the firewall by modifying a legitimate item, code
    signing checks will detect this tampering.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果恶意软件试图通过修改一个合法项目来绕过防火墙，代码签名检查将能检测到这种篡改行为。
- en: If an approved item moves to another location on the filesystem, the rule will
    still match, as it isn’t tied to the item’s path or specific location.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个已批准的项目移动到文件系统的其他位置，规则依然适用，因为它并未绑定到项目的路径或特定位置。
- en: 'Hopefully, these brief examples have already shown you the value of inspecting
    the code signing information. For good measure, let’s list a few other ways that
    code signing information can help us programmatically detect malicious code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些简短的示例已经向你展示了检查代码签名信息的价值。为了更全面一些，下面列举一些代码签名信息如何帮助我们以编程方式检测恶意代码的其他方式：
- en: '**Detecting notarization** Recent versions of macOS require all downloaded
    software to be signed in order to run. As such, most malware is now signed, often
    with an ad hoc certificate or fraudulent developer ID. However, malware is rarely
    notarized, because notarization requires submitting an item to Apple, which scans
    it, then issues a notarization ticket if the item doesn’t appear to be malicious.^([2](#chapter3-2))
    On the few occasions that Apple has inadvertently notarized malware, it has quickly
    detected the misstep and revoked the notarization.^([3](#chapter3-3)) These blunders
    are exceedingly rare, and notarized items are most likely benign. Using code signing,
    you can quickly determine whether an item is notarized, providing a reliable indication
    that Apple doesn’t consider it to be malware.'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**检测公证** 近期版本的 macOS 要求所有下载的软件必须签名才能运行。因此，现在大多数恶意软件都有签名，通常使用临时证书或伪造的开发者 ID。然而，恶意软件很少会被公证，因为公证需要将项目提交给
    Apple，Apple 会对其进行扫描，并在确认项目不含恶意后发放公证票证。^([2](#chapter3-2)) 如果 Apple 不小心公证了恶意软件，它通常会迅速发现这一失误并撤销公证。^([3](#chapter3-3))
    这些失误非常罕见，因此被公证的项目大多数是无害的。通过代码签名，您可以快速判断项目是否已公证，这为您提供了 Apple 不认为其为恶意软件的可靠指示。'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Detecting revocations** If Apple has revoked an item’s code signing certificate
    or notarization ticket, it means they have determined that the item should no
    longer be distributed and run. Although revocation sometimes happens for benign
    reasons, it’s often because Apple deemed the item malicious. This chapter explains
    how to programmatically detect revocations.^([4](#chapter3-4))'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**检测撤销** 如果 Apple 撤销了项目的代码签名证书或公证票证，意味着他们已确定该项目不应再被分发和运行。虽然撤销有时是由于无害原因，但通常是因为
    Apple 认为该项目是恶意的。本章将解释如何以编程方式检测撤销情况。^([4](#chapter3-4))'
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Linking items to known adversaries** Code signing information that researchers
    have attributed to malicious adversaries, such as team identifiers, can later
    identify other malware specimens created by the same authors.'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**将项目与已知对手关联** 研究人员将恶意对手所拥有的代码签名信息（如团队标识符）与其他由同一作者创建的恶意软件样本进行关联。'
- en: 'When detecting malware, you’re generally interested in the following code signing
    information for an item:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测恶意软件时，通常需要关注以下项目的代码签名信息：
- en: The general status of the information, signing certificate, and notarization
    ticket. Is the item fully signed and notarized, and are the signing certificate
    and notarization ticket still in good standing?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息、签名证书和公证票证的总体状态。该项目是否完全签名并已公证，签名证书和公证票证是否仍然有效？
- en: The code signing authorities describing the chain of signers, as they can provide
    insight into the origin and trustworthiness of the signed item.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述签名链的代码签名授权机构，因为它们可以提供有关签名项目来源和可信度的洞见。
- en: The item’s optional team identifier, which specifies the team or company that
    created the signed item. If the team identifier belongs to a reputable company,
    you can generally trust the signed item.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的可选团队标识符，指定了创建已签名项目的团队或公司。如果该团队标识符属于一家信誉良好的公司，通常可以信任该签名项目。
- en: This chapter won’t cover code signing internals. Rather, it focuses on higher-level
    concepts, as well as the APIs used to extract code signing information.^([5](#chapter3-5))
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会讨论代码签名的内部细节，而是专注于更高层次的概念，以及用于提取代码签名信息的 API。^([5](#chapter3-5))
- en: Keep in mind, however, that not everything on macOS is signed, nor is it signed
    in the same way. Most notably, developers can’t sign stand-alone scripts (one
    of the reasons Apple is desperately trying to deprecate them). Nor is the macOS
    kernel signed per se. Instead, the boot process uses a cryptographic hash to verify
    that it remains pristine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，并非 macOS 上的所有内容都已签名，也不是所有的签名方式都相同。最显著的是，开发者无法签名独立脚本（这是 Apple 急于弃用它们的原因之一）。此外，macOS
    内核本身并没有签名。相反，启动过程使用加密哈希来验证内核保持完整。
- en: While developers can and should sign distribution media such as disk images,
    packages, and zip archives, as well as applications and stand-alone binaries,
    the tools and APIs that extract the code signing information are often specific
    to the file type. For example, Apple’s codesign utility and code signing services
    APIs work on disk images, applications, and binaries, but not on packages, whose
    information you can examine with the pkgutil utility or the private PackageKit
    APIs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者可以并且应该对分发介质（如磁盘映像、软件包、zip 压缩文件）以及应用程序和独立二进制文件进行签名，但提取代码签名信息的工具和 API 通常特定于文件类型。例如，苹果的
    codesign 工具和代码签名服务 API 适用于磁盘映像、应用程序和二进制文件，但不适用于软件包，您可以使用 pkgutil 工具或私有的 PackageKit
    API 来检查软件包信息。
- en: Let’s consider how to manually and programmatically extract and validate code
    signing information, starting with distribution media.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何手动和程序化地提取和验证代码签名信息，从分发介质开始。
- en: Disk Images
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘映像
- en: Both legitimate developers and malware authors often distribute their code as
    disk images, which have the *.dmg* extension. Most disk images containing malware
    are unsigned, and if you encounter an unsigned *.dmg*, you should at the very
    least check whether the items it contains are signed and notarized. The presence
    of code signing information doesn’t mean a disk image is benign, however; nothing
    stops malware authors from leveraging cryptographic signatures. When you encounter
    a signed disk image, use its code signing information to identify the creator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 合法的开发者和恶意软件作者经常以磁盘映像的形式分发他们的代码，这些磁盘映像通常具有 *.dmg* 扩展名。大多数包含恶意软件的磁盘映像没有签名，如果您遇到未签名的
    *.dmg* 文件，至少应该检查其包含的项目是否已签名并经过公证。然而，代码签名信息的存在并不意味着磁盘映像是良性的；没有任何东西能阻止恶意软件作者利用加密签名。当您遇到已签名的磁盘映像时，请使用其代码签名信息来识别创建者。
- en: Manually Verifying Signatures
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动验证签名
- en: You can manually verify the signature of a disk image with macOS’s built-in
    codesign utility. Execute it with the --verify command line option (or -v for
    short) and the path of a *.dmg* file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 macOS 内置的 codesign 工具手动验证磁盘映像的签名。使用 --verify 命令行选项（或简写为 -v）和 *.dmg* 文件的路径来执行它。
- en: 'In the following example, codesign identifies a validly signed disk image containing
    LuLu, legitimate software from Objective-See. When it encounters validly signed
    images, the tool won’t output anything by default; hence, we use the -dvv option
    to display verbose output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，codesign 识别出包含 LuLu 的有效签名磁盘映像，LuLu 是来自 Objective-See 的合法软件。当它遇到有效签名的映像时，工具默认不会输出任何内容；因此，我们使用
    -dvv 选项来显示详细输出：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The verbose output shows information about the disk image, such as its path,
    identifier, and format, as well as its code signing status, including the certificate
    authority chain. From the certificate authority chain, you can see the package
    has been signed with an Apple Developer ID belonging to Objective-See.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 详细输出显示磁盘映像的信息，如其路径、标识符、格式以及代码签名状态，包括证书颁发机构链。从证书颁发机构链中，您可以看到该软件包已经使用属于 Objective-See
    的 Apple Developer ID 进行了签名。
- en: 'If a disk image isn’t signed, the utility will display a code object is not
    signed at all message. Many software items, including most of the malware specimens
    distributed via disk images, fall into this category; the authors may have signed
    the software or malware but not its distribution media. For example, take a look
    at the EvilQuest malware. Distributed via disk images, it contains packages of
    trojanized applications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果磁盘映像未签名，工具将显示“代码对象未签名”消息。许多软件项目，包括大多数通过磁盘映像分发的恶意软件，都属于这一类别；作者可能已签名了软件或恶意软件，但未签名其分发介质。例如，看看
    EvilQuest 恶意软件。它通过磁盘映像分发，包含了带有木马的应用程序包：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Lastly, if Apple has revoked a disk image’s signature, codesign will display
    CSSMERR_TP_CERT_REVOKED. You can see an example of this in the disk image used
    to distribute the CreativeUpdate malware:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果苹果撤销了磁盘映像的签名，codesign 将显示 CSSMERR_TP_CERT_REVOKED。您可以在分发 CreativeUpdate
    恶意软件的磁盘映像中看到这个例子：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The malware’s signature is no longer valid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的签名不再有效。
- en: Extracting Code Signing Information
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取代码签名信息
- en: Let’s programmatically extract and verify the code signing information of a
    disk image using Apple’s code signing services (Sec*) APIs.^([6](#chapter3-6))
    In the chapter’s *checkSignature* project, you’ll find a function named checkItem
    that takes the path to an item to verify, such as a disk image, and returns a
    dictionary containing the results of the verification. For validly signed items,
    it also returns information such as the code signing authorities, if any.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编程方式使用苹果的代码签名服务 (Sec*) API 提取并验证磁盘映像的代码签名信息。^([6](#chapter3-6)) 在本章的 *checkSignature*
    项目中，你会找到一个名为 checkItem 的函数，它接受要验证的项目路径（例如磁盘映像），并返回一个包含验证结果的字典。对于有效签名的项目，它还会返回签名机构等信息（如果有的话）。
- en: For the sake of brevity, I’ve omitted basic sanity and error checks from most
    of the code snippets in this book. However, when it comes to code signing, which
    provides the means to make crucial decisions about the trustworthiness of items,
    it’s imperative that the code handle errors appropriately. Without resilient error-handling
    mechanisms, the code might inadvertently trust a malicious item masquerading as
    something benign! Thus, in this chapter, the code snippets don’t omit such important
    error checks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我在本书中的大部分代码片段中省略了基本的健全性和错误检查。然而，涉及到代码签名时，它提供了一种方式来做出关于项目可信度的关键决策，这时必须确保代码能够适当处理错误。如果没有强健的错误处理机制，代码可能会不小心信任一个伪装成无害项的恶意项目！因此，在本章中，代码片段没有省略这些重要的错误检查。
- en: The first step to extracting the code signing information of any item is to
    obtain what is referred to as a *code object* reference that you can then pass
    to all subsequent code signing API calls. For on-disk items such as disk images,
    you’ll obtain a static code object of type SecStaticCodeRef.^([7](#chapter3-7))
    For running processes, you’ll instead obtain a dynamic code object of type SecCodeRef.^([8](#chapter3-8))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 提取任何项目的代码签名信息的第一步是获取所谓的 *代码对象* 引用，随后你可以将其传递给所有后续的代码签名 API 调用。对于磁盘上的项目，比如磁盘映像，你将获得一个类型为
    SecStaticCodeRef 的静态代码对象。^([7](#chapter3-7)) 对于正在运行的进程，你将获得一个类型为 SecCodeRef 的动态代码对象。^([8](#chapter3-8))
- en: To obtain a static code reference from a disk image, invoke the SecStaticCodeCreateWithPath
    API with a path to the specified disk image, optional flags, and an out pointer.
    Once the function returns, this out pointer will contain a SecStaticCode object
    for use in subsequent API calls ([Listing 3-1](chapter3.xhtml#Lis3-1)).^([9](#chapter3-9))
    Note that you should free this pointer using CFRelease once you’re done with it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要从磁盘映像中获取静态代码引用，请调用 SecStaticCodeCreateWithPath API，传入指定磁盘映像的路径、可选的标志和一个输出指针。函数返回后，输出指针将包含一个
    SecStaticCode 对象，用于后续的 API 调用 ([Listing 3-1](chapter3.xhtml#Lis3-1))。^([9](#chapter3-9))
    请注意，使用完毕后，应该使用 CFRelease 来释放这个指针。
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-1: Obtaining a static code object for a disk image'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-1：获取磁盘映像的静态代码对象
- en: After initializing a URL object containing the path of the disk image we’re
    to check ❶, we invoke the SecStaticCodeCreateWithPath API ❷. If this function
    fails, it will return a nonzero value ❸. If Sec* APIs succeed, they return zero,
    which maps to the preferred errSecSuccess constant. I discuss the error codes
    that the Sec* APIs may return in “Code Signing Error Codes” on [page 97](chapter3.xhtml#pg_97).
    They’re also detailed in Apple’s “Code Signing Services Result Codes” documentation.^([10](#chapter3-10))
    Also note that when we are done with the code reference, we must release it via
    CFRelease.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化包含我们要检查的磁盘映像路径的 URL 对象 ❶ 后，我们调用 SecStaticCodeCreateWithPath API ❷。如果此函数失败，它将返回非零值
    ❸。如果 Sec* API 成功，它们返回零，映射到首选的 errSecSuccess 常量。我在《代码签名错误代码》一节中讨论了 Sec* API 可能返回的错误代码，详见
    [第97页](chapter3.xhtml#pg_97)。这些代码也在苹果的《代码签名服务结果代码》文档中有详细说明。^([10](#chapter3-10))
    另外，注意，当我们完成代码引用后，必须通过 CFRelease 来释放它。
- en: In this and subsequent code snippets, you’ll see the use of *bridging*, a mechanism
    to cast Objective-C objects in a toll-free manner into (and out of) the Core Foundation
    objects used by Apple’s code signing APIs. For example, in [Listing 3-1](chapter3.xhtml#Lis3-1),
    the SecStaticCodeCreateWithPath API expects a CFURLRef as its first argument.
    After converting the path of the disk image to an NSURL object, we bridge it to
    a CFURLRef using (__bridge CFURLRef). You can read more about bridging in Apple’s
    “Core Foundation Design Concepts.”^([11](#chapter3-11))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码和随后的代码片段中，你会看到使用了*桥接*，这是一种将Objective-C对象无缝转换为（或从）Apple代码签名API使用的Core Foundation对象的机制。例如，在[Listing
    3-1](chapter3.xhtml#Lis3-1)中，SecStaticCodeCreateWithPath API期望其第一个参数是CFURLRef类型。在将磁盘映像的路径转换为NSURL对象之后，我们使用(__bridge
    CFURLRef)将其桥接为CFURLRef。你可以在Apple的“Core Foundation设计概念”中了解更多关于桥接的内容。^([11](#chapter3-11))
- en: Once we’ve created a static code object for the disk image, we can invoke the
    SecStaticCodeCheckValidity API with the just-created SecStaticCode object to check
    its validity, saving the result of the call so we can return it to the caller
    ([Listing 3-2](chapter3.xhtml#Lis3-2)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为磁盘映像创建了一个静态代码对象，就可以调用SecStaticCodeCheckValidity API，使用刚创建的SecStaticCode对象来检查其有效性，并保存调用结果以便返回给调用者（[Listing
    3-2](chapter3.xhtml#Lis3-2)）。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-2: Checking a disk image’s code signing validity'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-2: 检查磁盘映像的代码签名有效性'
- en: You’ll normally see this API invoked with the kSecCSDefaultFlags constant, which
    contains a default set of flags, but to perform certificate revocation checks
    as part of the validation, you need to pass in kSecCSEnforceRevocationChecks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会看到这个API调用时使用kSecCSDefaultFlags常量，该常量包含默认的标志集，但为了在验证过程中执行证书撤销检查，你需要传递kSecCSEnforceRevocationChecks。
- en: Next, we check that the invocation succeeded. If we fail to perform this validation,
    malicious code may be able to subvert code signing checks.^([12](#chapter3-12))
    If the API fails, for example, with errSecCSUnsigned, you’ll likely want to abort
    the extraction of any further code signing information, which either won’t be
    present (in the case of unsigned items) or won’t be trustworthy.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查调用是否成功。如果我们未能执行此验证，恶意代码可能会绕过代码签名检查。^([12](#chapter3-12)) 如果API失败，例如，返回errSecCSUnsigned错误，你可能希望中止提取任何进一步的代码签名信息，因为它要么不存在（在未签名的情况下），要么不可信。
- en: Once we’ve determined the validity of the disk image’s code signing status,
    we can extract its code signing information via the SecCodeCopySigningInformation
    API. We pass this API the SecStaticCode object, the kSecCSSigningInformation flag,
    and an out pointer to a dictionary to populate with the disk image’s code signing
    details ([Listing 3-3](chapter3.xhtml#Lis3-3)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了磁盘映像的代码签名状态的有效性，就可以通过SecCodeCopySigningInformation API提取其代码签名信息。我们将SecStaticCode对象、kSecCSSigningInformation标志以及一个输出指针传递给此API，用于填充磁盘映像的代码签名详细信息（[Listing
    3-3](chapter3.xhtml#Lis3-3)）。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-3: Extracting code signing information'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-3: 提取代码签名信息'
- en: Now we can extract stored details from the dictionary, such as the certificate
    authority chain, using the key kSecCodeInfoCertificates ([Listing 3-4](chapter3.xhtml#Lis3-4)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从字典中提取存储的详细信息，例如证书授权链，使用键kSecCodeInfoCertificates（[Listing 3-4](chapter3.xhtml#Lis3-4)）。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-4: Extracting the certificate authority chain'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-4: 提取证书授权链'
- en: If the item has an ad hoc signature, it won’t have an entry under the kSecCodeInfoCertificates
    key in its code signing dictionary. Another way to identify ad hoc signatures
    is to check the kSecCodeInfoFlags key, which contains the item’s code signing
    flags. For ad hoc signatures, we’ll find the second least significant bit (2)
    set in the flag, which, after consulting Apple’s *cs_blobs.h* header file, we
    see maps to the constant CS_ADHOC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该项具有临时签名，它的代码签名字典中就不会在kSecCodeInfoCertificates键下有条目。识别临时签名的另一种方法是检查kSecCodeInfoFlags键，该键包含该项的代码签名标志。对于临时签名，我们会在标志中发现第二个最低有效位（2）被设置，经过查阅Apple的*cs_blobs.h*头文件后，我们看到它对应于常量CS_ADHOC。
- en: It’s rare to see disk images signed in an ad hoc manner, as they don’t require
    a signature to begin with, but because apps and binaries must be signed to run,
    you’ll commonly see malware signed in this way. We can extract the code signing
    flags in the manner shown in [Listing 3-5](chapter3.xhtml#Lis3-5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很少看到以临时方式签名的磁盘映像，因为它们本身不需要签名，但由于应用程序和二进制文件必须签名才能运行，因此你常常会看到恶意软件以这种方式签名。我们可以按照[Listing
    3-5](chapter3.xhtml#Lis3-5)中显示的方式提取代码签名标志。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-5: Extracting an item’s code signing flags'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-5: 提取项目的代码签名标志'
- en: We could then check these extracted flags for the value indicating an ad hoc
    signature ([Listing 3-6](chapter3.xhtml#Lis3-6)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以检查这些提取的标志，查看是否有指示临时签名的值（[列表 3-6](chapter3.xhtml#Lis3-6)）。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-6: Verifying code signing flags'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：验证代码签名标志
- en: The dictionary stores these flags in a number object, so we must first convert
    them to an integer and then perform a bitwise AND operation (&) to check for the
    bits specified by CS_ADHOC.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将这些标志存储在一个数字对象中，因此我们必须首先将其转换为整数，然后执行按位与操作（&）来检查由 CS_ADHOC 指定的位。
- en: When we’re finished with the CFDictionaryRef dictionary, we must free it via
    CFRelease.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成 CFDictionaryRef 字典的使用后，必须通过 CFRelease 释放它。
- en: Extracting Notarization Information
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取公证信息
- en: To extract the notarization status of the disk images, we can use the SecRequirementCreateWithString
    API, which lets us create a requirement to which an item must conform. In [Listing
    3-7](chapter3.xhtml#Lis3-7), we create a requirement with the string "notarized".
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取磁盘映像的公证状态，我们可以使用 SecRequirementCreateWithString API，该 API 允许我们创建一个要求，项目必须符合该要求。在[列表
    3-7](chapter3.xhtml#Lis3-7)中，我们使用字符串“notarized”创建了一个要求。
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-7: Initializing a requirement reference string'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：初始化要求引用字符串
- en: The API generates an object by compiling the code requirement string we pass
    to it, allowing us to use the requirement multiple times.^([13](#chapter3-13))
    If you’re performing a one-time requirement check, you can skip the compilation
    step and instead use the SecTaskValidateForRequirement API, which takes a string-based
    requirement to validate as a second argument.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: API 通过编译我们传递给它的代码要求字符串生成一个对象，使我们能够多次使用该要求。^([13](#chapter3-13)) 如果你只进行一次要求检查，可以跳过编译步骤，改用
    SecTaskValidateForRequirement API，该 API 将字符串形式的要求作为第二个参数进行验证。
- en: Now we can call the SecStaticCodeCheckValidity API, passing it the SecStaticCode
    object, as well as the requirement reference ([Listing 3-8](chapter3.xhtml#Lis3-8)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用 SecStaticCodeCheckValidity API，传递给它 SecStaticCode 对象，以及要求引用（[列表 3-8](chapter3.xhtml#Lis3-8)）。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-8: Checking a notarization requirement'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：检查公证要求
- en: If the API returns errSecSuccess, we know that the item conforms to the requirement
    we passed in. In our case, this means the disk image is indeed notarized. You
    can read more about requirements, including useful requirement strings, in Apple’s
    informative “Code Signing Requirement Language” document.^([14](#chapter3-14))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 返回 errSecSuccess，我们就知道该项目符合我们传入的要求。在我们的例子中，这意味着磁盘映像确实已进行公证。你可以在苹果的《代码签名要求语言》文档中阅读更多关于要求的内容，包括有用的要求字符串。^([14](#chapter3-14))
- en: If the notarization validation fails, we should check whether Apple has revoked
    the item’s notarization ticket, even if the item is validly signed. This nuanced
    case presents a huge red flag; for an example, see the discussion of the 3CX supply
    chain attack in “On-Disk Applications and Executables” on [page 93](chapter3.xhtml#pg_93).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公证验证失败，我们应该检查苹果是否已撤销该项目的公证票据，即使该项目已有效签名。这个细致的情况提出了一个巨大的警示；例如，请参见“磁盘应用程序和可执行文件”中关于3CX供应链攻击的讨论，详见[第93页](chapter3.xhtml#pg_93)。
- en: Although I’ve asked for one,^([15](#chapter3-15)) Apple has not approved any
    method of determining whether an item’s notarization ticket has been revoked.
    However, two undocumented APIs, SecAssessmentCreate and SecAssessmentTicketLookup,
    can provide this information. In [Listing 3-9](chapter3.xhtml#Lis3-9), we invoke
    SecAssessmentCreate to check whether an item that has passed other code signing
    checks has had its notarization ticket revoked.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已经要求过了，^([15](#chapter3-15)) 苹果并未批准任何确定项目的公证票据是否已被撤销的方法。然而，有两个未公开的 API，SecAssessmentCreate
    和 SecAssessmentTicketLookup，可以提供这些信息。在[列表 3-9](chapter3.xhtml#Lis3-9)中，我们调用 SecAssessmentCreate
    来检查一个已通过其他代码签名检查的项目是否已被撤销其公证票据。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-9: Checking whether a notarization ticket has been revoked'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：检查公证票据是否已被撤销
- en: We pass the function the path to the item, such as a disk image; the default
    assessment flags; an empty but non-NULL dictionary; and an out pointer to an error
    variable ❶.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路径传递给该函数，路径指向项目（如磁盘映像）；默认评估标志；一个空的但非 NULL 的字典；以及指向错误变量的输出指针 ❶。
- en: If Apple has revoked either the notarization ticket or the certificate, the
    function will set an error to CSSMERR_TP_CERT_REVOKED or errSecCSRevokedNotarization.
    The name of the first error is a bit nuanced, as it can return items with valid
    certificates but revoked notarization tickets, which is what we’re interested
    in here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Apple撤销了公证票证或证书，函数将设置错误为CSSMERR_TP_CERT_REVOKED或errSecCSRevokedNotarization。第一个错误的名称有些微妙，因为它可以返回有效证书但已撤销公证票证的项目，而这正是我们在此关心的内容。
- en: 'If we receive a NULL assessment and either of these error codes ❷, we know
    something has been revoked. Moreover, because we’ve already validated the code
    signing certificates, we know that the revocation refers to the notarization ticket.
    Once we’re done with the assessment, we make sure to free it if it’s not NULL
    ❸.  #### Running the Tool'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到NULL评估结果并且出现以下错误代码❷，我们知道某些内容已被撤销。此外，由于我们已经验证了代码签名证书，我们知道撤销指的是公证票证。一旦评估完成，如果评估结果不是NULL
    ❸，我们会确保释放它。#### 运行工具
- en: 'Let’s compile the *checkSignature* project and run it against the disk images
    mentioned earlier in this section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译*checkSignature*项目，并针对本节前面提到的磁盘映像运行它：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As expected, the code reports that LuLu’s disk image is signed, though it isn’t
    notarized. The code also extracts the chain of its code signing authorities, which
    include its developer ID application and its developer ID certification authority.
    (When detecting malware, you may want to ignore disk images signed via trusted
    developer IDs unless you’re interested in detecting supply chain attacks.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，代码报告LuLu的磁盘映像已签名，但未经过公证。代码还提取了其代码签名的证书链，包括其开发者ID应用程序和开发者ID证书颁发机构。（在检测恶意软件时，除非你对检测供应链攻击感兴趣，否则可能希望忽略通过受信任开发者ID签名的磁盘映像。）
- en: 'Now let’s run the code against the EvilQuest malware. As you’ll see, the code
    matches the results from Apple’s codesign utility, indicating that the disk image
    is unsigned:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对EvilQuest恶意软件运行代码。正如你所见，代码与Apple的codesign工具的结果一致，表明磁盘映像未签名：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we run the code against the CreativeUpdate malware, whose code signing
    certificate has been revoked:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对CreativeUpdate恶意软件运行代码，其代码签名证书已被撤销：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we can programmatically extract and validate code signing information
    from disk images, let’s do the same for packages, which unfortunately require
    a completely different approach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过编程方式从磁盘映像中提取和验证代码签名信息，接下来让我们对包进行相同的操作，尽管这需要完全不同的方法。
- en: Packages
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包
- en: 'You can manually verify the signature of a package (*.pkg*) with the built-in
    pkgutil utility. Execute it with the --check-signature command line option, followed
    by the path of the *.pkg* file you’d like to verify. The utility should display
    the result of the check in a line prefixed with Status:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的pkgutil工具手动验证包（*.pkg*）的签名。使用--check-signature命令行选项执行该工具，然后指定你想验证的*.pkg*文件路径。该工具应在以“Status:”为前缀的行中显示检查结果：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The results show that pkgutil has verified that the package, a Google Chrome
    installer, is signed and notarized. The tool also displayed the certificate authority
    chain, which indicates that the package was signed via an Apple Developer ID belonging
    to Google.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，pkgutil已经验证该包（一个Google Chrome安装程序）已签名并经过公证。该工具还显示了证书颁发机构链，表明该包是通过属于Google的Apple
    Developer ID进行签名的。
- en: 'Note that you can’t use the codesign utility to check the code signature of
    packages, as *.pkg* files use a different mechanism for storing code signing information
    that codesign doesn’t understand. For example, when run against the same package,
    it detects no signature:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能使用codesign工具来检查包的代码签名，因为*.pkg*文件使用与codesign无法理解的不同机制存储代码签名信息。例如，当针对同一包运行时，它检测不到签名：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If a package isn’t signed, pkgutil will display a Status: no signature message.
    Most malware distributed via packages, including EvilQuest, falls into this category.
    These disk images contain a malicious package, and once the disk image is mounted,
    we can use pkgutil to show that this package is unsigned:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个包没有签名，pkgutil将显示“Status: no signature”消息。大多数通过包分发的恶意软件，包括EvilQuest，都属于这一类。这些磁盘映像包含一个恶意包，一旦磁盘映像被挂载，我们可以使用pkgutil显示该包未签名：'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, if a package was signed but Apple has revoked its code signing certificate,
    pkgutil will display Status: revoked signature but will still show the certificate
    chain. We find an example of this behavior in a package used to distribute the
    KeySteal malware:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一个包已签名，但苹果撤销了它的代码签名证书，pkgutil 将显示状态：撤销的签名，但仍然会显示证书链。我们在一个用于分发 KeySteal
    恶意软件的包中发现了这种行为的例子：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Apple has revoked the signature. In addition, the revoked code signing identifier,
    fenghua he (32W7BZNTSV), may help you find other malware signed by the same malware
    author.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果已撤销签名。此外，被撤销的代码签名标识符 fenghua he (32W7BZNTSV) 可能帮助你找到其他由同一恶意软件作者签署的恶意软件。
- en: Reverse Engineering pkgutil
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反向工程 pkgutil
- en: Now, you may be wondering how to programmatically check the signatures of packages.
    This is a good question, as there are currently no public APIs for verifying a
    package! Thanks, Cupertino.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想知道如何以编程方式检查包的签名。这是一个很好的问题，因为目前没有公开的 API 用于验证包！谢谢你，库比提诺。
- en: 'Luckily, a quick reverse engineering session of the pkgutil binary reveals
    exactly how it checks the signature of packages. To begin, we can see that pkgutil
    is linked against the private *PackageKit* framework:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对 pkgutil 二进制文件进行快速的反向工程分析，可以揭示它如何检查包的签名。首先，我们可以看到 pkgutil 链接了私有的 *PackageKit*
    框架：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The name of this framework suggests that it likely contains relevant APIs. Traditionally
    found in the */System/Library/PrivateFrameworks/* directory, the framework lives
    in the shared *dyld cache*, a prelinked shared file containing commonly used libraries,
    on recent versions of macOS.^([16](#chapter3-16)) Its name and location depend
    on the version of macOS and the architecture of the system but might look something
    like *dyld_shared_cache_arm64e* and */System/Volumes/Preboot/Cryptexes/OS/System/Library/dyld/*,
    respectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架的名字表明它可能包含相关的 API。通常，它位于 */System/Library/PrivateFrameworks/* 目录中，且在最近版本的
    macOS 中存在于共享的 *dyld 缓存* 中，dyld 缓存是一个预先链接的共享文件，包含常用的库。^([16](#chapter3-16)) 它的名字和位置取决于
    macOS 的版本和系统架构，但可能类似于 *dyld_shared_cache_arm64e* 和 */System/Volumes/Preboot/Cryptexes/OS/System/Library/dyld/*。
- en: We must extract the *PackageKit* framework from the *dyld* cache before we can
    reverse engineer it. A tool such as Hopper, shown in [Figure 3-2](chapter3.xhtml#fig3-2),
    can extract frameworks from the cache.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须先从 *dyld* 缓存中提取 *PackageKit* 框架，然后才能对其进行反向工程。像 Hopper 这样的工具，如 [图 3-2](chapter3.xhtml#fig3-2)
    所示，可以从缓存中提取框架。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: 'Figure 3-2: Extracting the PackageKit framework from the dyld cache'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：从 dyld 缓存中提取 PackageKit 框架
- en: 'If you prefer to use a command line tool to extract libraries, one good option
    is the *dyld-shared-cache-extractor*.^([17](#chapter3-17)) After installing this
    tool, you can execute it with the path of the *dyld* cache and an output directory,
    which we specify here as */tmp/libraries*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于使用命令行工具来提取库，一个不错的选择是 *dyld-shared-cache-extractor*。^([17](#chapter3-17))
    安装此工具后，你可以通过指定 *dyld* 缓存路径和输出目录来执行它，这里我们指定输出目录为 */tmp/libraries*：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the tool has extracted all of the libraries from the cache, you’ll find
    the *PackageKit* framework at */tmp/libraries/System/Library/Private Frameworks/PackageKit.framework*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工具从缓存中提取了所有库，你会在 */tmp/libraries/System/Library/Private Frameworks/PackageKit.framework*
    找到 *PackageKit* 框架。
- en: 'Now we can load the framework into a disassembler to gain insight into its
    APIs and internals. For example, we find a class named PKArchive that contains
    useful methods, such as archiveWithPath: and verifyReturningError:, among others:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以将框架加载到反汇编器中，以深入了解其 API 和内部结构。例如，我们发现了一个名为 PKArchive 的类，它包含了一些有用的方法，如
    archiveWithPath: 和 verifyReturningError: 等：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I won’t cover the full details of reverse engineering the *PackageKit* framework
    here, but you can learn more about the process online.^([18](#chapter3-18)) You
    can also find the entirety of my package verification source code in my What’s
    Your Sign utility’s *Package.h/Package.m* file.^([19](#chapter3-19))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细介绍反向工程 *PackageKit* 框架的全过程，但你可以在线了解更多相关过程。^([18](#chapter3-18)) 你也可以在我的
    What’s Your Sign 工具的 *Package.h/Package.m* 文件中找到完整的包验证源代码。^([19](#chapter3-19))
- en: Accessing Framework Functions
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问框架函数
- en: To use the methods we’ve discovered in our *checkSignature* project, we’ll need
    a header file containing the private class definitions from the *PackageKit* framework.
    This will allow us to invoke them directly from our code. In the past, tools such
    as class-dump could easily create such header files,^([20](#chapter3-20)) but
    this approach isn’t fully compatible with newer Apple Silicon binaries. Instead,
    you can manually extract these class definitions from a disassembler or by using
    otool. [Listing 3-10](chapter3.xhtml#Lis3-10) shows the extracted definitions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-10: The PackageKit framework’s extracted class and method definitions'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write code to use these classes, invoking their methods to programmatically
    verify packages of our choosing. We’ll do this in a function we name checkPackage.
    As its only argument, it takes a path to the package to verify and returns a dictionary
    containing the results of verification, plus other code signing information, such
    as the package’s code signing authorities. The function starts by loading the
    required *PackageKit* framework ([Listing 3-11](chapter3.xhtml#Lis3-11)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-11: Loading the PackageKit framework'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the path to the *PackageKit* framework ❶. We then load the
    framework with the NSBundle class’s bundleWithPath: and load methods so that we
    can dynamically resolve and invoke the framework’s methods ❷.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Due to its introspective nature, the Objective-C programming language makes
    it easy to use private classes and invoke private methods. To access a private
    class, use the NSClassFromString function. For example, [Listing 3-12](chapter3.xhtml#Lis3-12)
    shows how to dynamically obtain the class object for the PKArchive class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 3-12: Obtaining the PKArchive class object'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse engineering pkgutil revealed that it instantiates an archive object
    (PKXARArchive) using the PKArchive class’s archiveWithPath: method, along with
    the path of the package to validate. In [Listing 3-13](chapter3.xhtml#Lis3-13),
    our code does the same.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-13: Instantiating an archive object'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with private classes such as the PKArchive class, note that it’s
    wise to invoke the respondsToSelector: method before invoking its methods. The
    respondsToSelector: method will return a Boolean value that tells you whether
    you can safely invoke the method on the class or class instance.^([21](#chapter3-21))
    If you skip this step and an object doesn’t respond to a method, it will crash
    your program with an unrecognized selector sent to class exception.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code checks to make sure the PKArchive class implements the archiveWithPath:
    method ([Listing 3-14](chapter3.xhtml#Lis3-14)).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-14: Checking for a method'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to perform some basic package validation.  #### Validating
    the Package'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we mimic pkgutil by using the PKXARArchive class’s verifyReturningError:
    method ([Listing 3-15](chapter3.xhtml#Lis3-15)).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-15: Performing basic package validation'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Once the package has passed basic verification checks, we can check its signature,
    which we find in the archive’s archiveSignatures instance variable. This variable
    is an array holding pointers to PKArchiveSignature objects. A signed package will
    have at least one signature ([Listing 3-16](chapter3.xhtml#Lis3-16)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 3-16: Verifying a package’s leaf signature'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'After ensuring that the package has at least one signature ❶, we verify the
    first, or *leaf*, signature, using the PKArchiveSignature class’s verifySignedDataReturningError:
    method ❷. Additionally, we evaluate the trust of this signature ([Listing 3-17](chapter3.xhtml#Lis3-17)).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-17: Evaluating the trust of a signature'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate a PKTrust object with the signature ❶ and then invoke the PKTrust
    class’s evaluateTrustReturningError: method ❷. If verificationTrustRef returns
    nil, we can validate the package via certificates by using the PKTrust class’s
    initWithCertificates:usingAppleRoot:signatureDate: method. See this chapter’s
    *checkSignature* project code for more details. If the signature and signature
    trust verifications pass, we have a validly signed package.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: You could also extract the signature’s certificates, which would allow you to
    perform actions like checking the name of each signing authority. You can access
    these certificates through the PKArchiveSignature object’s certificateRefs instance
    variable, which is an array of SecCertificateRef objects, and extract their information
    with the SecCertificate* APIs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Checking Package Notarization
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll wrap up this section by showing how to determine whether Apple has notarized
    a package. Recall that pkgutil leverages the private *PackageKit* framework to
    validate packages. However, reverse engineering revealed that the package notarization
    checks aren’t implemented in that framework with the rest of the checks, but rather
    directly in the pkgutil binary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To check the notarization status of a package, pkgutil invokes the SecAssessmentTicketLookup
    API. Though this API is undocumented, we find its declaration in Apple’s *SecAssessment.h*
    header file. [Listing 3-18](chapter3.xhtml#Lis3-18) mimics pkgutil’s approach.
    Given a validated PKArchiveSignature object from a package, it determines whether
    the package has been notarized.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 3-18: A package notarization check'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare various variables, most of which we’ll need for the SecAssessmentTicketLookup
    API call. We then invoke the signature’s signedDataReturningAlgorithm: method,
    which returns a data object containing a hash ❶.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Next, we make the first call to SecAssessmentTicketLookup ❷, passing it the
    hash and hash type, which will be either SHA-1 or SHA-256, represented by the
    kSecCodeSignatureHashSHA1 and kSecCodeSignatureHashSHA256 constants, respectively.
    We also pass in the assessment flags and an out pointer that will receive the
    date of the notarization if the package is notarized. The last argument is an
    optional out pointer to an error variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Mimicking the pkgutil binary, we first invoke the API with the assessment flags
    set to kSecAssessmentTicketFlagDefault. If this call fails to determine whether
    the package is notarized, we invoke the API again, this time with the flag set
    to kSecAssessmentTicketFlagForceOnlineCheck ❸. You can find these and other flag
    values in the *SecAssessment.h* header file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟 pkgutil 二进制文件，我们首先使用设置为 kSecAssessmentTicketFlagDefault 的评估标志调用 API。如果此调用未能确定包是否已公证，我们将再次调用该
    API，这次设置标志为 kSecAssessmentTicketFlagForceOnlineCheck ❸。你可以在 *SecAssessment.h*
    头文件中找到这些及其他标志值。
- en: If either API invocation returns a nonzero value, the package is notarized,
    and the Apple notary service trusts it. Because we mimicked pkgutil, however,
    our code doesn’t specify whether a non-notarized package has had its notarization
    ticket revoked. Given an item’s code signing hash and hash type, we could implement
    such a check in the manner shown in [Listing 3-19](chapter3.xhtml#Lis3-19).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一 API 调用返回非零值，则包已公证，且 Apple 公证服务信任它。然而，由于我们模拟了 pkgutil，我们的代码并未指定非公证包是否已撤销其公证票证。通过项目的代码签名哈希和哈希类型，我们可以按照
    [清单 3-19](chapter3.xhtml#Lis3-19) 所示的方式实现此检查。
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 3-19: Checking for revoked notarization tickets'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-19：检查撤销的公证票证
- en: The SecAssessmentTicketLookup API will set its error variable to the value EACCES
    if the item’s notarization ticket has been revoked.^([22](#chapter3-22))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目的公证票证已被撤销，SecAssessmentTicketLookup API 将把其错误变量设置为 EACCES 的值。^([22](#chapter3-22))
- en: Running the Tool
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行工具
- en: 'Let’s run the *checkSignature* tool against the packages mentioned earlier
    in this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 *checkSignature* 工具，检查本章前面提到的包：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The output matches the results of Apple’s pkgutil. Our code accurately identifies
    the first package as validly signed and notarized; the second, containing the
    EvilQuest malware, as unsigned; and the last, containing the KeySteal malware,
    as revoked.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果与 Apple 的 pkgutil 工具的结果匹配。我们的代码准确地识别出第一个包已正确签名并经过公证；第二个包，包含 EvilQuest 恶意软件，则未签名；最后一个包，包含
    KeySteal 恶意软件，则已被撤销。
- en: On-Disk Applications and Executables
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘上的应用程序和可执行文件
- en: 'The majority of macOS malware is distributed as applications or stand-alone
    Mach-O binaries. We can extract code signing information from an on-disk application
    bundle or executable binary in the same manner as for disk images: manually, via
    the codesign utility, or programmatically, via Apple’s Code Signing Services APIs.
    However, this case presents a few important differences.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 macOS 恶意软件以应用程序或独立的 Mach-O 二进制文件形式分发。我们可以以与磁盘映像相同的方式，从磁盘上的应用程序包或可执行二进制文件中提取代码签名信息：手动通过
    codesign 工具，或通过 Apple 的代码签名服务 API 编程实现。然而，这种情况存在一些重要的不同点。
- en: The first involves the SecStaticCodeCheckValidity API, which validates the item’s
    signature. When the item isn’t a disk image, we must invoke this function with
    the kSecCSCheckAllArchitectures flag ([Listing 3-20](chapter3.xhtml#Lis3-20)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个涉及 SecStaticCodeCheckValidity API，该 API 用于验证项目的签名。当项目不是磁盘映像时，我们必须使用 kSecCSCheckAllArchitectures
    标志调用此函数（[清单 3-20](chapter3.xhtml#Lis3-20)）。
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 3-20: Checking an item’s signature'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-20：检查项目的签名
- en: This flag handles multiarchitecture items like universal binaries, which can
    include several embedded Mach-O binaries, potentially with different code signers.
    For a real-world example in which attackers abused a universal binary to bypass
    insufficient code signing checks, see CVE-2021-30773.^([23](#chapter3-23)) This
    flag value also enforces revocation checks, as it contains the value kSecCSEnforceRevocationChecks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志处理多架构项目，如通用二进制文件，这些文件可能包含多个嵌入的 Mach-O 二进制文件，可能具有不同的代码签名者。有关攻击者利用通用二进制文件绕过不充分的代码签名检查的实际示例，请参见
    CVE-2021-30773。^([23](#chapter3-23)) 此标志值还强制执行撤销检查，因为它包含了 kSecCSEnforceRevocationChecks
    的值。
- en: Earlier in this chapter, I showed you how to check whether a specified item
    conforms to some requirement, such as notarization. You might want to check additional
    requirements, such as whether Apple proper signed the item (the *anchor apple*
    requirement) or whether both Apple and a third-party developer ID have signed
    it (the *anchor apple generic* requirement). In each of these cases, your code
    can invoke the SecRequirementCreateWithString function with the requirement you
    wish to check and then pass this requirement to the SecStaticCodeCheckValidity
    API. To take into account universal binaries, invoke this function with a flag
    value that contains kSecCSCheckAllArchitectures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: You should also invoke the SecAssessmentCreate API to account for items with
    valid signatures but revoked notarization tickets. For a real-world example of
    this situation pertaining to applications, consider the 3CX supply chain attack
    mentioned previously. In this attack, North Korean attackers compromised the 3CX
    company network and build server, subverted the 3CX application with malware,
    signed it with the 3CX code signing certificate, and then tricked Apple into notarizing
    it. Not wanting to revoke 3CX’s code signing certificate, which would have blocked
    many other legitimate 3CX apps, Apple merely revoked the subverted application’s
    notarized ticket.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the *checkSignature* project on legitimate applications as well as
    malware, including the 3CX sample:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We first check Objective-See’s signed and notarized LuLu application, followed
    by a WindTail malware specimen with a revoked certificate. Next, we test an instance
    of the trojanized 3CX application; our code correctly detects its revoked notarization
    status. Finally, we demonstrate that the MacMa malware is unsigned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Running Processes
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve examined on-disk items by obtaining static code object references.
    In this section, we’ll check the code signing information of running processes
    by using dynamic code object references (SecCodeRef).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: When applicable, you should make use of dynamic code object references for two
    reasons. The first is efficiency; the operating system will have already validated
    much of the code signing information for a dynamic instance of an item of interest
    to ensure conformance with runtime requirements. For us, this means we can avoid
    the costly file I/O operations associated with static code checks and skip certain
    computations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The other reason that dynamic code references are preferable to static code
    references relates to possible discrepancies between an item’s on-disk image and
    its in-memory one. For example, there is little stopping malware from changing
    the code signing information of its on-disk item to a benign value. (Of course,
    this highly anomalous behavior should itself raise a huge red flag.) On the other
    hand, a running item can’t change its dynamic code signing information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: To check whether a running process is signed and then extract its code signing
    information, we first must obtain a code reference via the SecCodeCopyGuestWithAttributes
    API. Invoke it with the process’s ID, or preferably, with a more secure process
    audit token ([Listing 3-21](chapter3.xhtml#Lis3-21)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个正在运行的进程是否已签名并提取其代码签名信息，首先我们必须通过 SecCodeCopyGuestWithAttributes API 获取一个代码引用。通过进程的
    ID 调用它，或者更安全的做法是通过进程的审计令牌（[Listing 3-21](chapter3.xhtml#Lis3-21)）。
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 3-21: Obtaining a code object reference via a process’s audit token'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-21: 通过进程的审计令牌获取代码对象引用'
- en: We first convert the audit token into a data object ❶. We need this conversion
    so we can place the audit token in a dictionary, keyed by the string kSecGuestAttributeAudit
    ❷. We then pass this dictionary to the SecCodeCopyGuestWithAttributes API, along
    with an out pointer to populate with a code object reference ❸.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将审计令牌转换为数据对象 ❶。我们需要进行此转换，以便可以将审计令牌放入字典中，字典的键是字符串 kSecGuestAttributeAudit
    ❷。然后，我们将此字典传递给 SecCodeCopyGuestWithAttributes API，并附上一个输出指针，用于填充代码对象引用 ❸。
- en: With a code object reference in hand, you can validate the process’s code signing
    information with SecCodeCheckValidity or SecCodeCheckValidityWithErrors. Recall
    that for on-disk items such as universal binaries, we make use of the kSecCSCheckAllArchitectures
    flag value to validate all embedded Mach-Os; for running processes, the dynamic
    loader will load and execute only one embedded Mach-O, so that flag value is irrelevant
    and not needed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到代码对象引用后，您可以使用 SecCodeCheckValidity 或 SecCodeCheckValidityWithErrors 验证进程的代码签名信息。请记住，对于磁盘上的项目，比如通用二进制文件，我们使用
    kSecCSCheckAllArchitectures 标志值来验证所有嵌入的 Mach-O 文件；而对于正在运行的进程，动态加载器只会加载并执行一个嵌入的
    Mach-O 文件，因此该标志值不相关，也不需要使用。
- en: It’s essential that you validate a process’s code signing information before
    extracting or acting upon any of it. If you don’t, or if the validation fails,
    you won’t be able to trust it. If the code signing information is valid, you can
    extract it via the SecCodeCopySigningInformation function that was already discussed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取或操作任何代码签名信息之前，验证进程的代码签名信息至关重要。如果没有进行验证，或者验证失败，您将无法信任这些信息。如果代码签名信息有效，您可以通过之前讨论的
    SecCodeCopySigningInformation 函数提取它。
- en: With a code reference for a process, you can also perform other mundane but
    important tasks in a simple and secure manner. For example, using the SecCodeCopyPath
    API, you can retrieve the process’s path ([Listing 3-22](chapter3.xhtml#Lis3-22)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个进程的代码引用后，您还可以以简单而安全的方式执行其他日常但重要的任务。例如，使用 SecCodeCopyPath API，您可以检索进程的路径（[Listing
    3-22](chapter3.xhtml#Lis3-22)）。
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 3-22: Obtaining a process’s path from a dynamic code object reference'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-22: 从动态代码对象引用中获取进程路径'
- en: You can also perform specific validations using requirements, as was discussed
    for static code object references. Using dynamic code object references, the approach
    is largely the same, except you’ll make use of the SecCodeCheckValidity API to
    perform the validation. It is important to note that when you are done with a
    dynamic code reference, you should release it via CFRelease.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用要求执行特定验证，就像我们在静态代码对象引用中讨论的那样。使用动态代码对象引用时，方法基本相同，唯一不同的是您需要使用 SecCodeCheckValidity
    API 来执行验证。需要注意的是，当您完成动态代码引用的使用后，应通过 CFRelease 释放它。
- en: Because macOS won’t allow a process to execute if either its certificate or
    its notarization ticket has been revoked, you don’t need to perform this check
    yourself for running processes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 macOS 不允许执行任何证书或公证票已被撤销的进程，因此您无需对正在运行的进程进行此检查。
- en: Detecting False Positives
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测误报
- en: At the beginning of the chapter, I noted that various antivirus engines had
    incorrectly flagged components of Apple’s MRT as malware. If these engines had
    taken the item’s code signing information into account, they would have identified
    MRT and its components as a built-in part of macOS signed solely by Apple proper
    and safely ignored it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我提到过一些杀毒引擎错误地将苹果的 MRT 组件标记为恶意软件。如果这些引擎考虑到该项的代码签名信息，它们会将 MRT 及其组件识别为仅由苹果签名的
    macOS 内置部分，并安全地忽略它。
- en: I’ll show you how to perform such a check using the APIs introduced in this
    chapter. Specifically, you’ll make use of the *anchor apple* requirement string,
    which holds cryptographically true if and only if nobody but Apple has signed
    an item.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示如何使用本章介绍的 API 执行此类检查。具体来说，您将使用 *anchor apple* 要求字符串，只有在没有其他人签名该项时，它才会在加密学上为真。
- en: Let’s assume we’ve obtained a static code reference to the binary that was incorrectly
    flagged as malware. In [Listing 3-23](chapter3.xhtml#Lis3-23), we first compile
    the requirement string and then pass it and the code reference to the SecStaticCodeCheckValidity
    API.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 3-23: Checking the validity of an item against the anchor apple requirement'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If SecStaticCodeCheckValidity returns errSecSuccess, we know that only Apple
    proper has signed the item, meaning it belongs to macOS and therefore certainly
    isn’t malware.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Code Signing Error Codes
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned throughout this chapter, it’s important to appropriately handle
    any errors you encounter when validating an item’s cryptographic signature. You
    can find the error codes for the code signing services APIs in Apple’s “Code Signing
    Services Result Codes” developer documentation^([24](#chapter3-24)) or in the
    *CSCommon.h* file, found at *Security.framework/Versions/A/Headers/*. These resources
    indicate, for example, that the error code -66992 maps to errSecCSRevokedNotarization,
    signifying that the code has been revoked.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If perusing header files isn’t your thing, consult the OSStatus website. This
    website provides a simple way to map any Apple API error code to its human-readable
    name.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code signing allows us to determine where an item is from and whether the item
    has been modified. In this chapter, you delved into code signing APIs that can
    verify, extract, and validate code signing information for items such as disk
    images, packages, on-disk binaries, and running processes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these APIs is imperative in the context of detecting malware,
    especially as heuristic-based approaches can be fraught with false positives.
    The information provided by code signing can drastically reduce your detection
    errors. When building antimalware tools, you can use code signing in a myriad
    of ways, including identifying core operating system components you can trust,
    detecting items whose certificates or notarization tickets have been revoked,
    and authenticating clients, such as tool modules attempting to connect to XPC
    interfaces (a topic covered in [Chapter 11](chapter11.xhtml)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '### Notes'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[  1](#chapter3_1).  Rich Trouton, “Apple Security Update Blocks Apple Ethernet
    Drivers on OS X El Capitan,” *Der Flounder*, February 28, 2016, [*https://<wbr>derflounder<wbr>.wordpress<wbr>.com<wbr>/2016<wbr>/02<wbr>/28<wbr>/apple<wbr>-security<wbr>-update<wbr>-blocks<wbr>-apple<wbr>-ethernet<wbr>-drivers<wbr>-on<wbr>-el<wbr>-capitan<wbr>/*](https://derflounder.wordpress.com/2016/02/28/apple-security-update-blocks-apple-ethernet-drivers-on-el-capitan/).'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter3_2).  “Notarizing macOS Software Before Distribution,” Apple
    Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/notarizing<wbr>_macos<wbr>_software<wbr>_before<wbr>_distribution*](https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution).'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter3_3).  Patrick Wardle, “Apple Approved Malware,” Objective-See,
    August 30, 2020, [*https://<wbr>objective<wbr>-see<wbr>.com<wbr>/blog<wbr>/blog<wbr>_0x4E<wbr>.html*](https://objective-see.com/blog/blog_0x4E.html).'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter3_4).  You can read more about the revocation of developer certificates
    in Jeff Johnson, “Developer ID Certificate Revocation,” *Lapcat Software*, October
    29, 2020, [*https://<wbr>lapcatsoftware<wbr>.com<wbr>/articles<wbr>/revocation<wbr>.html*](https://lapcatsoftware.com/articles/revocation.html).'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter3_5).  If you’re interested in the technical details of code
    signing, see Jonathan Levin, “Code Signing—Hashed Out,” *NewOSXBook*, April 20,
    2015, [*http://<wbr>www<wbr>.newosxbook<wbr>.com<wbr>/articles<wbr>/CodeSigning<wbr>.pdf*](http://www.newosxbook.com/articles/CodeSigning.pdf),
    or “macOS Code Signing in Depth,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/technotes<wbr>/tn2206<wbr>/<wbr>_index<wbr>.html*](https://developer.apple.com/library/archive/technotes/tn2206/_index.html).'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter3_6).  “Code Signing Services,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/code<wbr>_signing<wbr>_services*](https://developer.apple.com/documentation/security/code_signing_services).'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter3_7).  “SecStaticCodeRef,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/secstaticcoderef<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/security/secstaticcoderef?language=objc).'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter3_8).  “SecCodeRef,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/seccoderef<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/security/seccoderef?language=objc).'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter3_9).  “SecStaticCodeCreateWithPath,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/1396899<wbr>-secstaticcodecreatewithpath*](https://developer.apple.com/documentation/security/1396899-secstaticcodecreatewithpath).'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter3_10).  “Code Signing Services Result Codes,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/1574088<wbr>-code<wbr>_signing<wbr>_services<wbr>_result<wbr>_cod*](https://developer.apple.com/documentation/security/1574088-code_signing_services_result_cod).'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter3_11).  “Core Foundation Design Concepts,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/CoreFoundation<wbr>/Conceptual<wbr>/CFDesignConcepts<wbr>/Articles<wbr>/tollFreeBridgedTypes<wbr>.html*](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html).'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#chapter3_12).  For a real-world example, see Ilias Morad, “CVE-2020–9854:
    ‘Unauthd,’ ” Objective-See, August 1, 2020, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x4D<wbr>.html*](https://objective-see.org/blog/blog_0x4D.html),
    which highlighted this issue in macOS’s authd.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#chapter3_13).  “SecRequirementCreateWithString,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/1394522<wbr>-secrequirementcreatewithstring*](https://developer.apple.com/documentation/security/1394522-secrequirementcreatewithstring).'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#chapter3_14).  “Code Signing Requirement Language,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/library<wbr>/archive<wbr>/documentation<wbr>/Security<wbr>/Conceptual<wbr>/CodeSigningGuide<wbr>/RequirementLang<wbr>/RequirementLang<wbr>.html*](https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html).'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[15](#chapter3_15).  Asfdadsfasdfasdfsasdafads, “Programmatically Detected
    If a Notarization Ticket Has Been Revoked,” Apple Developer Forums, June 2023,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/forums<wbr>/thread<wbr>/731675<wbr>.*](https://developer.apple.com/forums/thread/731675)'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[16](#chapter3_16).  “dyld Shared Cache Info,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/forums<wbr>/thread<wbr>/692383*](https://developer.apple.com/forums/thread/692383).'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17](#chapter3_17).  See [*https://<wbr>github<wbr>.com<wbr>/keith<wbr>/dyld<wbr>-shared<wbr>-cache<wbr>-extractor*](https://github.com/keith/dyld-shared-cache-extractor).'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[18](#chapter3_18).  See, for example, Patrick Wardle, “Reversing ‘pkgutil’
    to Verify PKGs,” *Jamf*, January 22, 2019, [*https://<wbr>www<wbr>.jamf<wbr>.com<wbr>/blog<wbr>/reversing<wbr>-pkgutil<wbr>-to<wbr>-verify<wbr>-pkgs<wbr>/*](https://www.jamf.com/blog/reversing-pkgutil-to-verify-pkgs/).'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[19](#chapter3_19).  See [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/WhatsYourSign<wbr>/blob<wbr>/master<wbr>/WhatsYourSignExt<wbr>/FinderSync<wbr>/Packages<wbr>.m*](https://github.com/objective-see/WhatsYourSign/blob/master/WhatsYourSignExt/FinderSync/Packages.m).'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[20](#chapter3_20).  Steve Nygard, “Class-dump,” [*http://<wbr>stevenygard<wbr>.com<wbr>/projects<wbr>/class<wbr>-dump<wbr>/*](http://stevenygard.com/projects/class-dump/).'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[21](#chapter3_21).  “respondsToSelector:,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/objectivec<wbr>/1418956<wbr>-nsobject<wbr>/1418583<wbr>-respondstoselector*](https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418583-respondstoselector).'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[22](#chapter3_22).  “Notarization,” Apple Developer Documentation, [*https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/Security<wbr>/Security<wbr>-59306<wbr>.120<wbr>.7<wbr>/OSX<wbr>/libsecurity<wbr>_codesigning<wbr>/lib<wbr>/notarization<wbr>.cpp*](https://opensource.apple.com/source/Security/Security-59306.120.7/OSX/libsecurity_codesigning/lib/notarization.cpp).'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[23](#chapter3_23).  Linus Henze, “Fugu15: The Journey to Jailbreaking iOS
    15.4.1,” paper presented at Objective by the Sea v5, Spain, October 6, 2022, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_lHenze<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_lHenze.pdf).'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[24](#chapter3_24).  “Code Signing Services Result Codes,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/security<wbr>/1574088<wbr>-code<wbr>_signing<wbr>_services<wbr>_result<wbr>_cod*](https://developer.apple.com/documentation/security/1574088-code_signing_services_result_cod).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
