- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 CONDITIONAL EXECUTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The if command, which is quite likely common to all programming languages, causes
    one or more lines of code to be executed only when a condition is true, and a
    different section of code can be executed only when that condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: The basics are straightforward, but in Batch the *conditional clause*, or the
    entity that evaluates to true or false, is quite different from similar clauses
    in other languages. Most of the compare operators are unique to Batch, and in
    this chapter you’ll learn the syntax to determine whether a path or file exists
    and whether a variable is populated. It’s also important to understand the different
    techniques for evaluating the return code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you’ll learn how to efficiently manage instances where multiple
    conditions need to be evaluated as well as some common stumbling blocks to avoid.
    It’s disturbingly easy to write an if command that works most of the time but
    either aborts or fails to execute as intended under certain data conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The Basic if Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In its most basic incarnation, the if command executes one or more lines of
    code if a condition is true. I’ll show how you can expand this command to execute
    a different bit of code if that same condition is false, but let’s start with
    its basic structure.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly every Batch command implementation starts with the command name itself
    and is often followed by arguments and/or options. For instance, the set command
    always starts with those three letters. Usually, it’s followed by an argument
    consisting of a variable name, an equal sign, and a value, but in [Chapter 2](chapter2.xhtml)
    you learned that it works with no arguments or options at all. (Such a command
    writes out a list of active variables.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The if command is unique. It also starts with its command name, but the similarities
    end there; it can span multiple lines and has two major components. Here’s the
    general form where you’d replace the italicized text with code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *conditional clause* is an expression that evaluates to true or false. If
    it’s true, the interpreter executes the command or commands inside the *true code
    block*, and if it’s false, this code doesn’t execute. In [Chapter 16](chapter16.xhtml),
    I’ll discuss code blocks in more depth, but for now, a code block is simply one
    or more lines of code set between parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this syntax, the open parenthesis must not only follow the conditional
    clause; it also must be on the same line. Other languages allow (or even encourage)
    you to put the open parenthesis on the next line and line it up with the close
    parenthesis, but this is verboten in Batch. However, good form dictates that the
    close parenthesis should line up with the beginning of the if command with the
    intervening commands indented. My convention calls for three spaces of indentation,
    but any amount will do. Here’s a functioning example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The conditional clause, "%today%" equ "07/04/2026", is looking for equality
    between a resolved variable and some hardcoded text. This conditional clause is
    fairly straightforward, but I’ll soon demonstrate far more impressive ones using
    different compare operators, keywords, and even an option. Many coding languages
    put the conditional clause inside parentheses; for better or worse, the clause
    stands on its own in Batch, and the parentheses are used to enclose the upcoming
    code block.
  prefs: []
  type: TYPE_NORMAL
- en: If the conditional clause is true, the command in the code block (in this example,
    the set command) is executed, resulting in event being set to the term for a quarter-millennium
    celebration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following more compact format fitting on a single line is functionally
    equivalent to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You no longer need the parentheses when using a single line. The following
    is functionally equivalent to both prior examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Technically, because of the lack of parentheses, the set command is no longer
    in a code block. In lieu of a concise term, it’s now just the command that executes
    when the conditional clause is true.
  prefs: []
  type: TYPE_NORMAL
- en: In both of the prior examples, I’ve left two spaces after the conditional clause,
    and I often leave more than two. Syntactically this isn’t needed, but since nothing
    clearly delineates the conditional clause from what comes after it, readability
    is enhanced with a little separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even execute multiple commands on a single line with the & command
    separator, as discussed in [Chapter 2](chapter2.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the conditional clause is true, an additional set command, which happens
    to be self-critiquing of the code, is executed. I’ve seen this technique used
    on occasion, usually when setting an error code and error message, but in instances
    such as this, using a single line just makes the code inscrutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there’s anything remotely interesting in the logic being performed, use
    multiple lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Elegant is undoubtedly a gross overstatement here, but I hope you agree that
    this technique makes the code far more readable. With just a glance, the reader
    knows that if the condition is true, two variables are set.
  prefs: []
  type: TYPE_NORMAL
- en: The Conditional Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples in the previous section all use a straightforward conditional clause,
    but the clause can be far more dynamic, taking on many other forms and using different
    operators and keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Compare Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *compare operator*, unsurprising enough, compares two operands for equality
    or for one being greater than the other. You may have guessed that the equ operator
    in the previous examples represents equality, and you’d be right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete list of Batch compare operators:'
  prefs: []
  type: TYPE_NORMAL
- en: equ **or** ==    Equal
  prefs: []
  type: TYPE_NORMAL
- en: neq    Not equal
  prefs: []
  type: TYPE_NORMAL
- en: lss    Less than
  prefs: []
  type: TYPE_NORMAL
- en: leq    Less than or equal
  prefs: []
  type: TYPE_NORMAL
- en: gtr    Greater than
  prefs: []
  type: TYPE_NORMAL
- en: geq    Greater than or equal
  prefs: []
  type: TYPE_NORMAL
- en: You can choose between two functionally equivalent alternatives for the equality
    operator. To differentiate from the single equal sign used for assignment, such
    as in a set command, Batch uses double equal signs for the compare operator. My
    preferred syntax is the equ operator because it looks similar to the others, but
    some coders prefer the == operator for the opposite reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The neq operator evaluates the conditional clause to true if the two operands
    being compared are *not* equal. The last four operators determine which operand
    is greater or less than the other. For example, assuming that age is set to a
    numeric value, the following one-line code block executes only if the variable
    is set to a value greater than 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You might be tempted to try %age% > 12 as the conditional clause, but the greater-than
    sign already has a defined purpose in Batch; in fact, it’s being used in this
    code block to write a short message to the console. For this reason, you must
    use the three-character alpha code of gtr as the operator. Similarly, the operators
    listed in this section are needed for greater-than or equal, less-than, and less-than
    or equal compares.
  prefs: []
  type: TYPE_NORMAL
- en: Less intuitively, these operators also work on alphanumeric values. All numbers
    are less than all letters; a is less than A; A is less than b; b is less than
    B; and so on. This’ll do nothing to end the larger debate, but at least in the
    Batch universe, Picard is greater than Kirk.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Clause Keywords
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll find the following indispensable keywords in the help for the if command,
    but make no mistake; these keywords are specific to the conditional clause:'
  prefs: []
  type: TYPE_NORMAL
- en: 'exist    The exist keyword checks for the existence of either a path or a file
    and returns true if found. You can hardcode the path or file, or for flexibility,
    you can use a variable containing the potential path or file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also string multiple variables together to build the path or filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'defined    The following conditional clause using the defined keyword checks
    whether a variable is defined—that is, does it resolve to anything, even a space?
    A common mistake is to use percent signs around the variable, but here’s the correct
    syntax using this keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is functionally equivalent to the following with percent signs resolving
    the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This keyword is often used to validate expected input variables. If one or more
    is not defined, you can take appropriate action, possibly initiating an abort.
  prefs: []
  type: TYPE_NORMAL
- en: 'not    The not keyword negates any conditional clause when used at the very
    beginning of the clause. This is extremely useful in setting defaults for variables
    in the event that they’ve not yet been set by someone or something else. For instance,
    the following ensures that skyColor is set to its usual color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can couple the not keyword with the exist keyword to determine whether a
    specific file doesn’t exist. Armed with that knowledge, you can then create a
    file, initiate an abort, or do whatever makes sense for your application. Some
    coders use the not keyword with the equ operator, but I find this iffy at best
    and much prefer the neq operator alone. Logically there’s no difference, but whatever
    your preference, be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*After two decades of Batch coding I still try to add s to the end of the exist
    keyword more often than I care to admit. Notepad++ faithfully alerts me every
    time because it emboldens keywords; that spurious character drops the bold font
    for the entire word, making it stand out. Code without an editor like this at
    your own peril.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Case-Insensitive Option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The if command has exactly one option, and much like the keywords we’ve looked
    at so far, it applies to the conditional clause. The /i option makes the equality
    (and inequality) operator in the conditional clause case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, the conditional clause without the option in the following
    if command evaluates to true only if myMood resolves exactly to happy—the hardcoded
    value on the right side of the inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the same code with the addition of the /i option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The conditional clause now evaluates to true if the variable resolves to HAPPY,
    Happy, happy, or any of the other 29 possible permutations on the capitalization
    of the word.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The /i option probably looks a bit different from others that I’ve mentioned
    already and ones yet to come. As mentioned previously, I use lowercase for Batch
    commands even though the case doesn’t matter to the interpreter. Options also
    work regardless of the case. Even so, since options are usually just a forward
    slash followed by a single character, I typically capitalize them for emphasis.
    But depending on the font, the capital I often looks like a lowercase L, so I
    depart from my personal convention for the /i option, used most often with the
    if command. And yes, the irony that this is the option concerned with case-insensitivity
    has not been lost on me.*'
  prefs: []
  type: TYPE_NORMAL
- en: The errorlevel Variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After calling an executable or performing many Batch commands, a return code
    is stored in the errorlevel pseudo-environment variable. (The command in [Chapter
    1](chapter1.xhtml) that copied a file is one example of many to come that will
    set this variable.) You’ll learn more about pseudo-environment variables in [Chapter
    21](chapter21.xhtml), but for now, consider errorlevel to be a variable containing
    a return code that you shouldn’t set with the set command. (If you do, you’ll
    just break the errorlevel variable.) The errorlevel variable can be evaluated
    like any other in Batch as part of an if command. For example, the following recognizes
    a return code of 1 or greater as a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Batch also supports an archaic syntax that works only for this unique variable,
    where the percent signs and the equality operator are removed. The following is
    functionally equivalent to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At first this may seem simplified and appealing because content has been dropped
    with nothing added, but the syntax disguises a surprising batveat. Many Batch
    coders mistakenly interpret this conditional clause as looking for equality between
    the return code and 1. After all, testing it with a return code of 0 correctly
    returns false, and testing it with a return code of 1 correctly returns true.
    But the conditional clause errorlevel 1 is equivalent to both %errorlevel% geq
    1 and %errorlevel% gtr 0. It evaluates to true for all positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Couple this syntax with the not keyword for something truly opaque:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Doesn’t this look like a conditional clause that would evaluate to true when
    the return code isn’t equal to 0? It’s really the negation of the return code
    being greater than or equal to 0. The %errorlevel% lss 0 conditional clause is
    functionally equivalent and far more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the syntax lacking a compare operator is that more often
    than not, 0 represents a good return code, and all others, including negative
    values, indicate a problem of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The neq operator results in this conditional clause being true for all nonzero
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may run across the arcane syntax, so it’s important to understand how it
    works, but it’s more important to not propagate it. Always use percent signs (or
    exclamation marks) and a compare operator to evaluate the errorlevel pseudo-environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The if...else Construct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the unwritten rules of coding languages is that an if command must come
    with the possibility of an else keyword. The keywords I mentioned earlier are
    associated with the conditional clause, but this one is tied to the if command
    itself. Here’s the general form of the if...else construct, where once again the
    italicized text must be replaced with code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines and the close parenthesis starting the third are identical
    to the general form I showed at the beginning of this chapter. The else keyword
    follows, and it in turn is followed by the false code block, set between a second
    set of parentheses. This represents the code that executes when the conditional
    clause evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of an if...else construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the fahrenheit variable is greater than 70, the pants variable is set to
    shorts. Otherwise, the pants variable is set to jeans. One or the other code block
    will always execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can condense this construct into a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses surrounding the code in the false code block are technically
    optional, but they should be included for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have contempt for those that’ll be reading your code, the one-line
    if...else construct is usually bad practice, although you might make exceptions
    for the simplest of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in other languages, in Batch the else keyword can’t be coded on a line
    of its own; it can’t even start or end a line. To clearly demarcate the two code
    blocks, it’s best to code the keyword sandwiched between the close and open parentheses
    on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: The else if Construct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The if...else construct is great when there are exactly two branches in the
    logical flow, one for true and one for false. When there are more than two branches,
    the else if construct allows for multiple conditional clauses. [Listing 4-1](#Lis4-1)
    has three clauses and four branches, one branch for each conditional clause and
    a default branch that executes when none of the clauses evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: An else if construct with four logical branches'
  prefs: []
  type: TYPE_NORMAL
- en: This logic assumes that fahrenheit is set to an integer describing the temperature.
    If it’s greater than 80 degrees, the first set command executes. If it’s greater
    than 60, which is to say between 61 and 80, inclusive, the second set command
    executes. If the first two conditional clauses are false and the mercury registers
    as above freezing, the third set command executes. If all three clauses are false,
    the temperature is 32 degrees or below, so the fourth and final set command assigns
    a very warm pair of pants.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no open parenthesis immediately after the first else keyword. Instead,
    it’s followed by another if command with a conditional clause of its own and only
    then by the open parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-1](#Lis4-1) contains two else if clauses, but you can code any number
    depending on the need. The interpreter executes the code block corresponding to
    the first conditional clause that evaluates to true; afterward, control jumps
    to the end of the entire construct without evaluating the other clauses.'
  prefs: []
  type: TYPE_NORMAL
- en: Many times, you’ll want a final code block executed if none of the conditional
    clauses is true—that is, a default code block. For instance, if [Listing 4-1](#Lis4-1)
    fails to set a certain variable, someone is in danger of leaving the house without
    the proper attire. The final else keyword is not followed by an if command, so
    its code block, the default code block, executes if none of the three conditional
    clauses prior to it evaluated to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 4-1](#Lis4-1), fahrenheit is being interrogated to determine in
    which of four ranges it falls. This is a popular use of else if conditional clauses,
    but they don’t have to be so closely linked. Each conditional clause can interrogate
    completely different variables or make use of the three keywords covered earlier.
    For example, here’s a reimagining of [Listing 4-1](#Lis4-1) with only the three
    conditional clauses changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first conditional clause performs a case-insensitive compare for equality
    of a resolved variable and hardcoded text. The second clause is looking for the
    existence of a file, and the third is looking to see whether the value of the
    celsius variable is above the freezing point. Once again, due to the default code
    block, this code is guaranteed to set the variable to one of the four values.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Equality Determination Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I would be remiss if I didn’t mention an important batveat associated with
    these conditional clauses. In some of the examples in this chapter I’ve surrounded
    each side of the equality with double quotes in a conditional clause, but without
    them the commands would still work—most of the time. The following two if commands
    are very similar but *not* functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If myMood is set to happy, the clause evaluates to true, and if it’s set to
    sad, the result is false. Either way, it works for both commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s great, but now imagine that the variable hasn’t been set or that it’s
    been set to null or some number of spaces. The command without the double quotes
    will crash, but it hints at the issue with the following cryptic message (assuming
    you haven’t used the echo off command mentioned in [Chapter 2](chapter2.xhtml)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line here is the error message, and it’s followed by what has confused
    the interpreter. To understand the error, we must think like the interpreter.
    Once it sees the if command start the line, it expects one out of a finite list
    of items to come next (maybe not, exist, defined, or /i), with anything unrecognizable
    assumed to be the left side of a conditional clause. Obviously, it finds /i. Assuming
    that one of the three keywords doesn’t come next, the interpreter is now expecting
    exactly three items in a specific order: some text; an operator such as equ, neq,
    or ==; and some more text. If the value of myMood is pretty much anything, it
    will resolve to be the first text field. The interpreter will then be pleased
    to find the equ operator, and knowing that it’s dealing with an equality, it’ll
    interpret the hardcoded happy as being the right side of that equality. *Success*.'
  prefs: []
  type: TYPE_NORMAL
- en: This all blows up when the variable resolves to nothing or any number of spaces.
    The interpreter sees if /i to start the statement, so it doesn’t expect to see
    equ next. The not keyword would’ve made sense, but not equ. As a result, it incorrectly
    considers equ to be the left side of what might be an equality and what comes
    next to be the operator. But what comes next is the happy text, and the list of
    operators clearly doesn’t contain this word. As the message states, the interpreter
    doesn’t expect to see happy at this time. *Failure*.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are two methods of evaluating variables that might resolve
    to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The Preceding Dot Technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One common technique to get around this issue is to prefix each side of the
    equality with a dot, or almost any character as long as it’s applied consistently,
    so that the interpreter will definitely find something on both sides of the equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding dot technique works nicely when the variable is set to null, as
    the command resolves to if /i . equ .happy. The dot isn’t equal to the dot followed
    by the word, so it evaluates to false, and we move on. If the variable had been
    set to happy, the command would’ve been resolved to if /i .happy equ .happy, and
    equality would’ve been found. *Success.*
  prefs: []
  type: TYPE_NORMAL
- en: 'But I’m not a fan of this technique because it’s susceptible to yet another
    batveat. Now imagine that the variable is set to a two-word mood, such as irritably
    depressed—not good on many levels having nothing to do with the Batch code. Again,
    it blows up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Don’t get down. The interpreter is fooled by the embedded space. Don’t tell
    anyone, but it really isn’t that bright. It thinks that .irritably is the left
    side of the clause and finds depressed to be a completely unexpected operator.
    *Failure*. But there’s another technique.
  prefs: []
  type: TYPE_NORMAL
- en: The Double Quotes Technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Coming full circle, this brings us back to the example with the double quotes
    around each side of the equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The double quotes here provide something on either side of the equality just
    as the dot did, but that’s not all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpreter considers everything inside the double quotes to be one entity.
    When the variable with the embedded space is resolved, the interpreter sees this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Despite the embedded space, the interpreter treats "irritably depressed" as
    one entity, or in this case the left side of the equality, with the right side
    being "happy". The upshot is that Batch correctly recognizes these two entities
    as not being equal. *Success*.
  prefs: []
  type: TYPE_NORMAL
- en: If there’s a chance that the alphanumeric variable being interrogated might
    not be set or that it might contain embedded spaces, I almost always encase each
    side of the clause with double quotes. However, you may have noticed that I don’t
    have double quotes encasing %errorlevel% when used in a conditional clause. That
    variable will always be set to a number, so there’s no need for the quotes. Even
    more important, when the interpreter sees numbers being compared without quotes,
    it does a numeric compare, meaning that 000 is equivalent to 0. Adding the quotes
    results in a text compare, and "000" isn’t equal to "0".
  prefs: []
  type: TYPE_NORMAL
- en: Preceding Dot vs. Double Quotes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When comparing alphanumeric values, I *usually* encase each side of the equality
    with double quotes. It works when a value is null; it works when a value is one
    or more spaces; it works when a value has embedded spaces; and it works for more
    typical non-null spaceless values. However, I’m using the nondefinitive qualifier
    *usually* because of an extremely fine point.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the case of a variable containing a value with a trailing space. Perhaps
    the value sad is padded with a trailing space to make a four-character value.
    Is that equal to the three-character value sad? In the purest and most accurate
    sense, no, they aren’t equal—and using the double quote method correctly finds
    them to be different. But in a less strict scenario you might consider these values
    to be equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dot method will find equality between the two values because the trailing
    space becomes just another space between the left side of the equality and the
    operator. In this narrow instance of trailing spaces, the dot method is better,
    but it’ll work only if the variables don’t have any embedded spaces.
  prefs: []
  type: TYPE_NORMAL
- en: In the final analysis, the double quote technique is far superior to the dot
    method, with one very distinctive case when it isn’t. Get into the habit of using
    double quotes for almost all non-numeric compares.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Batch provides an interesting and compact alternative to the if command, although
    it does behave differently. It’s not a command, it doesn’t have any keywords,
    and it doesn’t even support a conditional clause. In [Chapter 28](chapter28.xhtml),
    I’ll return to the topic of conditional execution and provide more details about
    what it is than what it isn’t.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The if command is instrumental in virtually all, if not all, coding languages,
    and Batch is no different. In this chapter you learned about the conditional clause,
    including its valid operators for comparing two operands and its keywords for
    proving out the existence of a variable, path, or file, and what happens when
    the clause evaluates to true and false. You also learned how to evaluate multiple
    clauses so as to execute multiple branches of logic conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case, Batch gives you a little more to consider, so I detailed
    useful techniques to enhance your conditional clauses comparing both alphanumeric
    and numeric values. But what makes a value alphanumeric or numeric? I’ll answer
    that question in the next two chapters concerning data types.
  prefs: []
  type: TYPE_NORMAL
