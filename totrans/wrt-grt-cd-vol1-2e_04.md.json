["```\nimport Foundation\n\nlet charToPrintName  :String = \"A\"      // Print name of this character\n\nlet unicodeName =\n\n    String(charToPrintName).applyingTransform(\n\n        StringTransform(rawValue: \"Any-Name\"),\n\n        reverse: false\n\n    )! // Forced unwrapping is legit here because it always succeeds.\n\nprint( unicodeName )\n\nOutput from program:\n\n\\N{LATIN CAPITAL LETTER A}\n```", "```\nimport Foundation\n\nlet eAccent  :String = \"e\\u{301}\"\n\nprint( eAccent )\n\nprint( \"eAccent.count=\\(eAccent.count)\" )\n\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nprint( eAccent )\n```", "```\nprint( \"eAccent.count=\\(eAccent.count)\" )\n```", "```\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nimport Foundation\n\nlet eAccent  :String = \"e\\u{301}\\u{301}\"\n\nprint( eAccent )\n\nprint( \"eAccent.count=\\(eAccent.count)\" )\n\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nprint( eAccent )\n```", "```\nprint( \"eAccent.count=\\(eAccent.count)\" )\n```", "```\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\nimport Foundation\n\nlet eAccent  :String = \"\\u{E9}\"\n\nprint( eAccent )\n\nprint( \"eAccent.count=\\(eAccent.count)\" )\n\nprint( \"eAccent.utf16.count=\\(eAccent.utf16.count)\" )\n```", "```\n©\n\n1\n\n1\n```", "```\nlet eAccent1 :String = \"\\u{E9}\"\n\nlet eAccent2 :String = \"e\\u{301}\"\n\nlet eAccent3 :String = \"e\\u{301}\\u{301}\"\n```", "```\nlet chars: [Character] = [\n\n    \"\\u{1ECD}\\u{300}\", \n\n    \"\\u{F2}\\u{323}\",\n\n    \"\\u{6F}\\u{323}\\u{300}\",\n\n    \"\\u{6F}\\u{300}\\u{323}\"\n\n]\n```", "```\nprint( \"\\u{1ECD} + \\u{300} = \\u{1ECD}\\u{300}\" )\n\nprint( \"\\u{F2} + \\u{323} = \\u{F2}\\u{323}\" )\n\nprint( \"\\u{6F} + \\u{323} + \\u{300} = \\u{6F}\\u{323}\\u{300}\" )\n\nprint( \"\\u{6F} + \\u{300} + \\u{323} = \\u{6F}\\u{300}\\u{323}\" )\n\nprint( chars[0] == chars[1] ) // Outputs true\n\nprint( chars[0] == chars[2] ) // Outputs true\n\nprint( chars[0] == chars[3] ) // Outputs true\n\nprint( chars[1] == chars[2] ) // Outputs true\n\nprint( chars[1] == chars[3] ) // Outputs true\n\nprint( chars[2] == chars[3] ) // Outputs true\n```", "```\n#macro sbs( s );\n\n    // Grab all but the last character of the string:\n\n    (@substr( s, 0, @length(s) – 1) +\n\n        // Concatenate the last character with its HO bit set:\n\n        char( uns8( char( @substr( s, @length(s) – 1, 1))) | $80 ) )\n\n#endmacro\n\n    . . .\n\nbyte sbs( \"Hello World\" );\n```", "```\nstatic\n\n        s :string := \"Hello World\";\n\n                . . .\n\n        mov( s, esi );        // Move the address of 'H' in \"Hello World\"\n\n                              // into esi.\n\n        mov( [esi-4], ecx );  // Puts length of string (11 for \"Hello World\")\n\n                              // into ECX.\n\n                . . .\n\n        mov( s, esi );\n\n        cmp( eax, [esi-8] );  // See if value in EAX exceeds the maximum\n\n                              // string length.\n\n        ja StringOverflow;\n```", "```\nsomeCFunc( hlaStringVar );\n```", "```\ntype\n\n    dString :record\n\n              curLength  :integer;\n\n              strData    :^char;\n\n   end;\n```", "```\n(* Pascal static string example *)\n\nvar  pascalString :string(255);  // Max length will always be 255 characters.\n```", "```\n// C/C++ static string example:\n\nchar cString[256];  // Max length will always be 255 characters\n\n                    // (plus 0 byte).\n```", "```\nif( c >= 76) . . .\n```", "```\nif( c >= 'a') . . .\n```", "```\n         cmp( al, 76 );\n\n         jnae NotAlphabetic;\n\n             // Execute these statements if it's alphabetic\n\nNotAlphabetic:\n```", "```\na:76, A:77, b:78, B:79, c:80, C:81, . . . y:124, Y:125, z:126, Z:127\n```", "```\nif( (c >= 76) && (c & 1) )\n\n{\n\n    // execute this code if it's an uppercase character\n\n}\n\nif( (c >= 76) && !(c & 1) )\n\n{\n\n    // execute this code if it's a lowercase character\n\n}\n```", "```\n// Note: ROR(1, AL) maps lowercase to the range $26..$3F (38..63)\n\n//       and uppercase to $A6..$BF (166..191). Note that all other characters\n\n//       get mapped to smaller values within these ranges.\n\n         ror( 1, al );\n\n         cmp( al, $26 );\n\n         jnae NotLower;    // Note: must be an unsigned branch!\n\n             // Code that deals with a lowercase character.\n\nNotLower:\n\n// For uppercase, note that the ROR creates codes in the range $A8..$BF which \n\n// are negative (8-bit) values. They also happen to be the *most* negative \n\n// numbers that ROR will produce from the HyCode character set.\n\n         ror( 1, al );\n\n         cmp( al, $a6 );\n\n         jge NotUpper;    // Note: must be a signed branch!\n\n             // Code that deals with an uppercase character.\n\nNotUpper:\n```", "```\na < A < b < B < c < C < d < D < . . . < w < W < x < X < y < Y < z < Z\n```", "```\nif( toupper( c ) == toupper( d ))\n\n{\n\n    // do code that handles c==d using a case-insensitive comparison.\n\n}\n```", "```\n#define toupper(ch) ( (ch >= 'a' && ch <= 'z') ? ch & 0x5f : ch )\n```", "```\nif\n\n(\n\n        ( (c >= 'a' && c <= 'z') ? c & 0x5f : c )\n\n     == ( (d >= 'a' && d <= 'z') ? d & 0x5f : d )\n\n)\n\n{\n\n        // do code that handles c==d using a case-insensitive comparison.\n\n}\n```", "```\n        // assume c is in cl and d is in dl.\n\n        cmp( cl, 'a' );     // See if c is in the range 'a'..'z'\n\n        jb NotLower;\n\n        cmp( cl, 'z' );\n\n        ja NotLower;\n\n        and( $5f, cl );     // Convert lowercase char in cl to uppercase.\n\nNotLower:\n\n        cmp( dl, 'a' );     // See if d is in the range 'a'..'z'\n\n        jb NotLower2;\n\n        cmp( dl, 'z' );\n\n        ja NotLower2;\n\n        and( $5f, dl );     // Convert lowercase char in dl to uppercase.\n\nNotLower2:\n\n        cmp( cl, dl );      // Compare the (now uppercase if alphabetic)\n\n                            // chars.\n\n        jne NotEqual;       // Skip the code that handles c==d if they're \n\n                            // not equal.\n\n            // do code that handles c==d using a case-insensitive comparison.\n\nNotEqual:\n```", "```\n// Check to see if CL is alphabetic. No need to check DL as the comparison\n\n// will always fail if DL is nonalphabetic.\n\n        cmp( cl, 76 );      // If CL < 76 ('a') then it's not alphabetic\n\n        jb TestEqual;       // and there is no way the two chars are equal\n\n                            // (even ignoring case).\n\n        or( 1, cl );        // CL is alpha, force it to uppercase.\n\n        or( 1, dl );        // DL may or may not be alpha. Force to \n\n                            // uppercase if it is.\n\nTestEqual:\n\n        cmp( cl, dl );      // Compare the uppercase versions of the chars.\n\n        jne NotEqual;       // Bail out if they're not equal.\n\nTheyreEqual:\n\n            // do code that handles c==d using a case-insensitive comparison.\n\nNotEqual:\n```", "```\nif( ch < chr(10) or ch >= chr(76) ) then . . .\n```"]