["```\n$ go get -u golang.org/x/crypto/bcrypt\n```", "```\n❶ var md5hash = \"77f62e3524cd583d698d51fa24fdff4f\"\n   var sha256hash =\n   \"95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced\"\n\n   func main() {\n       f, err := os.Open(\"wordlist.txt\")❷\n       if err != nil {\n           log.Fatalln(err)\n       }  \n       defer f.Close()\n\n    ❸ scanner := bufio.NewScanner(f)\n       for scanner.Scan() {\n           password := scanner.Text()\n           hash := fmt.Sprintf(\"%x\", md5.Sum([]byte(password))❹)\n        ❺ if hash == md5hash {\n               fmt.Printf(\"[+] Password found (MD5): %s\\n\", password)\n           }  \n\n           hash = fmt.Sprintf(\"%x\", sha256.Sum256([]byte(password))❻)\n        ❼ if hash == sha256hash {\n               fmt.Printf(\"[+] Password found (SHA-256): %s\\n\", password)\n           }  \n       }  \n\n       if err := scanner.Err(); err != nil {\n           log.Fatalln(err)\n       }  \n   }\n```", "```\n   import (\n       \"log\"\n       \"os\"\n    ❶ \"golang.org/x/crypto/bcrypt\"\n   )\n\n❷ var storedHash = \"$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu\"\n\n   func main() {\n       var password string\n       if len(os.Args) != 2 {\n           log.Fatalln(\"Usage: bcrypt password\")\n       }  \n       password = os.Args[1]\n\n    ❸ hash, err := bcrypt.GenerateFromPassword(\n           []byte(password),\n           bcrypt.DefaultCost,\n       )\n       if err != nil {\n           log.Fatalln(err)\n       }  \n       log.Printf(\"hash = %s\\n\", hash)\n\n    ❹ err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))\n       if err != nil {\n           log.Println(\"[!] Authentication failed\")\n           return\n       }  \n       log.Println(\"[+] Authentication successful\")\n   }\n```", "```\n$ go run main.go someWrongPassword\n2020/08/25 08:44:01 hash = $2a$10$YSSanGl8ye/NC7GDyLBLUO5gE/ng51l9TnaB1zTChWq5g9i09v0AC\n2020/08/25 08:44:01 [!] Authentication failed\n```", "```\n$ go run main.go someC0mpl3xP@ssw0rd\n2020/08/25 08:39:29 hash = $2a$10$XfeUk.wKeEePNAfjQ1juXe8RaM/9EC1XZmqaJ8MoJB29hZRyuNxz.\n2020/08/25 08:39:29 [+] Authentication successful\n```", "```\nvar key = []byte(\"some random key\") ❶\n\nfunc checkMAC(message, recvMAC []byte) bool { ❷\n    mac := hmac.New(sha256.New, key) ❸\n    mac.Write(message)\n    calcMAC := mac.Sum(nil)\n\n    return hmac.Equal(calcMAC, recvMAC)❹\n}\n\nfunc main() {\n    // In real implementations, we'd read the message and HMAC value from network source\n    message := []byte(\"The red eagle flies at 10:00\") ❺\n    mac, _ := hex.DecodeString(\"69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d\") ❻\n    if checkMAC(message, mac) { ❼\n        fmt.Println(\"EQUAL\")\n    } else {\n        fmt.Println(\"NOT EQUAL\")\n    }  \n}\n```", "```\nfunc unpad(buf []byte) []byte { ❶\n    // Assume valid length and padding. Should add checks\n    padding := int(buf[len(buf)-1])\n    return buf[:len(buf)-padding]\n}\n\nfunc decrypt(ciphertext, key []byte) ([]byte, error) { ❷\n    var (\n        plaintext []byte\n        iv        []byte\n        block     cipher.Block\n        mode      cipher.BlockMode\n err       error\n    )\n\n    if len(ciphertext) < aes.BlockSize { ❸\n        return nil, errors.New(\"Invalid ciphertext length: too short\")\n    }\n\n    if len(ciphertext)%aes.BlockSize != 0 { ❹\n        return nil, errors.New(\"Invalid ciphertext length: not a multiple of blocksize\")\n    }\n\n    iv = ciphertext[:aes.BlockSize] ❺\n    ciphertext = ciphertext[aes.BlockSize:]\n\n    if block, err = aes.NewCipher(key); err != nil { ❻\n        return nil, err\n    }\n\n    mode = cipher.NewCBCDecrypter(block, iv) ❼\n    plaintext = make([]byte, len(ciphertext))\n    mode.CryptBlocks(plaintext, ciphertext) ❽\n    plaintext = unpad(plaintext) ❾\n\n    return plaintext, nil\n}\n```", "```\n$ go run main.go\nkey        = aca2d6b47cb5c04beafc3e483b296b20d07c32db16029a52808fde98786646c8\nciphertext = 7ff4a8272d6b60f1e7cfc5d8f5bcd047395e31e5fc83d062716082010f637c8f21150eabace62\n--snip--\nplaintext  = 4321123456789090\n```", "```\nfunc main() {\n    var (\n        err                                              error\n        privateKey                                       *rsa.PrivateKey\n        publicKey                                        *rsa.PublicKey\n        message, plaintext, ciphertext, signature, label []byte\n    )  \n\n    if privateKey, err = rsa.GenerateKey(rand.Reader, 2048)❶; err != nil {\n        log.Fatalln(err)\n    }  \n    publicKey = &privateKey.PublicKey ❷\n\n    label = []byte(\"\")\n    message = []byte(\"Some super secret message, maybe a session key even\")\n    ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label) ❸\n    if err != nil {\n        log.Fatalln(err)\n    }\n    fmt.Printf(\"Ciphertext: %x\\n\", ciphertext)\n\n    plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label) ❹\n    if err != nil {\n        log.Fatalln(err)\n    }  \n    fmt.Printf(\"Plaintext: %s\\n\", plaintext)\n\n    h := sha256.New()\n    h.Write(message)\n    signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil) ❺\n    if err != nil {\n        log.Fatalln(err)\n    }  \n    fmt.Printf(\"Signature: %x\\n\", signature)\n\n    err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)❻\n    if err != nil {\n        log.Fatalln(err)\n    }  \n    fmt.Println(\"Signature verified\")\n}\n```", "```\n$ go run main.go\nCiphertext: a9da77a0610bc2e5329bc324361b480ba042e09ef58e4d8eb106c8fc0b5\n--snip--\nPlaintext: Some super secret message, maybe a session key even\nSignature: 68941bf95bbc12edc12be369f3fd0463497a1220d9a6ab741cf9223c6793\n--snip--\nSignature verified\n```", "```\n$ openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365\n```", "```\n$ openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365\n```", "```\nfunc helloHandler(w http.ResponseWriter, r *http.Request) { ❶\n    fmt.Printf(\"Hello: %s\\n\", r.TLS.PeerCertificates[0].Subject.CommonName) ❷\n    fmt.Fprint(w, \"Authentication successful\")\n}\n\nfunc main() {\n    var (\n        err        error\n        clientCert []byte\n        pool       *x509.CertPool\n        tlsConf    *tls.Config\n        server     *http.Server\n    )  \n\n    http.HandleFunc(\"/hello\", helloHandler)\n\n    if clientCert, err = ioutil.ReadFile(\"../client/clientCrt.pem\")❸; err != nil {\n        log.Fatalln(err)\n    }  \n    pool = x509.NewCertPool()\n    pool.AppendCertsFromPEM(clientCert) ❹\n\n    tlsConf = &tls.Config{ ❺\n        ClientCAs:  pool,\n        ClientAuth: tls.RequireAndVerifyClientCert,\n    }  \n    tlsConf.BuildNameToCertificate() ❻\n\n    server = &http.Server{\n        Addr:      \":9443\",\n        TLSConfig: tlsConf, ❼\n    }  \n    log.Fatalln(server.ListenAndServeTLS(\"serverCrt.pem\", \"serverKey.pem\")❽)\n}\n```", "```\n$ curl -ik -X GET --cert badCrt.pem --key badKey.pem \\\n  https://server.blackhat-go.local:9443/hello\ncurl: (35) gnutls_handshake() failed: Certificate is bad\n```", "```\nhttp: TLS handshake error from 127.0.0.1:61682: remote error: tls: unknown certificate authority\n```", "```\n$ curl -ik -X GET --cert clientCrt.pem --key clientKey.pem \\\n  https://server.blackhat-go.local:9443/hello\nHTTP/1.1 200 OK\nDate: Fri, 09 Oct 2020 16:55:52 GMT\nContent-Length: 25\nContent-Type: text/plain; charset=utf-8\n\nAuthentication successful\n```", "```\nfunc main() {\n    var (\n        err              error\n        cert             tls.Certificate\n        serverCert, body []byte\n        pool             *x509.CertPool\n        tlsConf          *tls.Config\n transport        *http.Transport\n        client           *http.Client\n        resp             *http.Response\n    )  \n\n    if cert, err = tls.LoadX509KeyPair(\"clientCrt.pem\", \"clientKey.pem\"); err != nil { ❶\n        log.Fatalln(err)\n    }  \n\n    if serverCert, err = ioutil.ReadFile(\"../server/serverCrt.pem\"); err != nil { ❷\n        log.Fatalln(err)\n    }  \n\n    pool = x509.NewCertPool()\n    pool.AppendCertsFromPEM(serverCert) ❸\n\n    tlsConf = &tls.Config{ ❹\n        Certificates: []tls.Certificate{cert},\n        RootCAs:      pool,\n    }  \n    tlsConf.BuildNameToCertificate()❺\n\n    transport = &http.Transport{ ❻\n        TLSClientConfig: tlsConf,\n    }  \n    client = &http.Client{ ❼\n        Transport: transport,\n    }  \n\n    if resp, err = client.Get(\"https://server.blackhat-go.local:9443/hello\"); err != nil { ❽\n        log.Fatalln(err)\n    }  \n    if body, err = ioutil.ReadAll(resp.Body); err != nil { ❾\n        log.Fatalln(err)\n    }  \n    defer resp.Body.Close()\n\n    fmt.Printf(\"Success: %s\\n\", body)\n}\n```", "```\n$ go run main.go\nSuccess: Authentication successful\n```", "```\n$ go run main.go\nHello: client.blackhat-go.local\n```", "```\n$ go get github.com/joeljunstrom/go-luhn\n```", "```\n   import (\n       \"crypto/cipher\"\n       \"encoding/binary\"\n       \"encoding/hex\"\n       \"fmt\"\n       \"log\"\n       \"regexp\"\n       \"sync\"\n\n     ❶ luhn \"github.com/joeljunstrom/go-luhn\"\n\n     ❷ \"github.com/bhg/ch-11/rc2-brute/rc2\"\n   )\n\n❸ var numeric = regexp.MustCompile(`^\\d{8}$`)\n\n❹ type CryptoData struct {\n       block cipher.Block\n       key   []byte\n   }\n```", "```\n❶ func generate(start, stop uint64, out chan <- *CryptoData,\\\n   done <- chan struct{}, wg *sync.WaitGroup) {\n    ❷ wg.Add(1)\n    ❸ go func() {\n        ❹ defer wg.Done()\n           var (\n               block cipher.Block\n               err   error\n               key   []byte\n               data  *CryptoData\n           )\n        ❺ for i := start; i <= stop; i++ {\n               key = make([]byte, 8)\n            ❻ select {\n            ❼ case <- done:\n                   return\n            ❽ default:\n                ❾ binary.BigEndian.PutUint64(key, i)\n                   if block, err = rc2.New(key[3:], 40); err != nil {\n                       log.Fatalln(err)\n                   }\n                   data = &CryptoData{\n                       block: block,\n                       key:   key[3:],\n                   }\n                ❿ out <- data\n               }\n           }\n       }()\n\n       return\n   }\n```", "```\n❶ func decrypt(ciphertext []byte, in <- chan *CryptoData, \\\n   done chan struct{}, wg *sync.WaitGroup) {\n       size := rc2.BlockSize\n       plaintext := make([]byte, len(ciphertext))\n    ❷ wg.Add(1)\n       go func() {  \n        ❸ defer wg.Done()\n        ❹ for data := range in {\n               select {\n            ❺ case <- done:\n                   return\n            ❻ default:\n                ❼ data.block.Decrypt(plaintext[:size], ciphertext[:size])\n                ❽ if numeric.Match(plaintext[:size]) {\n                    ❾ data.block.Decrypt(plaintext[size:], ciphertext[size:])\n                    ❿ if luhn.Valid(string(plaintext)) && \\\n                       numeric.Match(plaintext[size:]) {\n                           fmt.Printf(\"Card [%s] found using key [%x]\\n\", /\n                           plaintext, data.key)\n                           close(done)\n                           return\n                       }\n                   }\n               }\n           }\n       }()\n   }\n```", "```\nfunc main() {\n    var (\n        err        error\n        ciphertext []byte\n    )\n\n    if ciphertext, err = hex.DecodeString(\"0986f2cc1ebdc5c2e25d04a136fa1a6b\"); err != nil { ❶\n        log.Fatalln(err)\n    }\n\n    var prodWg, consWg sync.WaitGroup ❷\n    var min, max, prods = uint64(0x0000000000), uint64(0xffffffffff), uint64(75)\n    var step = (max - min) / prods\n\n    done := make(chan struct{})\n    work := make(chan *CryptoData, 100)\n    if (step * prods) < max { ❸\n        step += prods\n    }\n var start, end = min, min + step\n    log.Println(\"Starting producers...\")\n    for i := uint64(0); i < prods; i++ { ❹\n        if end > max {\n            end = max\n        }\n        generate(start, end, work, done, &prodWg) ❺\n        end += step\n        start += step\n    }\n    log.Println(\"Producers started!\")\n    log.Println(\"Starting consumers...\")\n    for i := 0; i < 30; i++ { ❻\n        decrypt(ciphertext, work, done, &consWg) ❼\n    }\n    log.Println(\"Consumers started!\")\n    log.Println(\"Now we wait...\")\n    prodWg.Wait()❽\n    close(work)\n    consWg.Wait()❾\n    log.Println(\"Brute-force complete\")\n}\n```", "```\n$ go run main.go\n2020/07/12 14:27:47 Starting producers...\n2020/07/12 14:27:47 Producers started!\n2020/07/12 14:27:47 Starting consumers...\n2020/07/12 14:27:47 Consumers started!\n2020/07/12 14:27:47 Now we wait...\n2020/07/12 14:27:48 Card [4532651325506680] found using key [e612d0bbb6]\n2020/07/12 14:27:48 Brute-force complete\n```"]