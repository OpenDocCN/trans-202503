- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SOFTWARE DEVELOPMENT METAPHORS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How do we define the software development process? This might seem like a silly
    question. Why not just say “software development is software development” and
    leave it at that? Well, if we can draw analogies between software development
    tasks and other professional endeavors, we can gain insight into the software
    development process. Then we can refine the process by studying process improvements
    in related fields. To that end, this chapter explores some of the common ways
    of understanding software development.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1 What Is Software?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To better understand how programmers create software, we can compare software
    to other things people create. Doing so will provide important insight into why
    certain creative metaphors apply, or don’t apply, to software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his book, *Software Engineering: A Beginner’s Approach*, Robert Pressman
    identifies several characteristics of software. This section explores those characteristics
    to illuminate the nature of software and how it defines a computer programmer’s
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1.1 Software Is Not Manufactured***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Software is developed or engineered; it is not manufactured in the classical
    sense.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Robert Pressman
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to hardware products, the manufacturing cost of a software product
    is very low: stamping out a CD or DVD costs only a few pennies, plus a small amount
    for shipping and handling (and electronic distribution is even less expensive).
    Also, the software design has very little impact on the quality or final cost
    of the manufactured CD/DVD. Assuming reasonable quality controls at the manufacturing
    plant, a computer programmer rarely has to consider manufacturing issues when
    designing a software application.^([1](ch19_footnote.xhtml#ch01fn1)) Contrast
    this with other engineering professions where the engineer has to design in *manufacturability*
    of the product.'
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1.2 Software Doesn’t Wear Out***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both software and hardware suffer from failures due to poor design early in
    the products’ lives. However, if we could eliminate design flaws in the products
    (that is, deliver a defect-free piece of software or hardware), the differences
    between the two become obvious. Once a piece of software is correct, it doesn’t
    ever fail or “wear out.” As long as the underlying computer system is functioning
    properly, the software will continue to work.^([2](ch19_footnote.xhtml#ch01fn2))
    The software engineer, unlike the hardware engineer, doesn’t have to worry about
    designing in the ability to easily replace components that fail over time.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1.3 Most Software Is Custom***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Most software is custom built rather than being assembled from existing [standard]
    components.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Robert Pressman
  prefs: []
  type: TYPE_NORMAL
- en: Although many attempts have been made to create similarly standardized software
    components that software engineers can assemble into large applications, the concept
    of a *software IC* (that is, the equivalent of an electronic integrated circuit)
    has never been realized. Software libraries and object-oriented programming techniques
    encourage reusing prewritten code, but the premise of constructing large software
    systems from smaller preassembled components has failed to produce anything close
    to what’s possible in hardware design.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1.4 Software Can Be Easily Upgraded***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many cases, it’s possible to completely replace an existing software application
    in the field with a new version (or even a completely different application) without
    incurring a huge cost.^([3](ch19_footnote.xhtml#ch01fn3)) The application’s end
    user can simply replace the old software with the new and enjoy the benefits of
    the upgraded version. In fact, most modern software systems and applications auto-update
    via the internet during normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1.5 Software Is Not an Independent Entity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Software is not a stand-alone product. An electrical engineer can design a hardware
    device that can operate completely on its own. However, software depends upon
    something else (typically a computer system) for proper operation. Therefore,
    a software developer must live with the constraints imposed by external systems
    (computer systems, operating systems, programming languages, and so on) when designing
    and implementing a software application.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.2 Parallels to Other Fields**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computer programmers are often compared to artists, craftsmen, engineers, architects,
    and technicians. Although computer programming doesn’t match any of these professions
    exactly, we can draw useful parallels to these fields and gain insight from the
    techniques they employ.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2.1 Programmer as Artist***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the early days of computer programming, software development was considered
    an art. The ability to write software—to make sense of so much nonsense to create
    a working program—seemed to be a God-given talent exercised by a select few, akin
    to master painters or musical virtuosos. (In fact, considerable anecdotal evidence
    suggests that musicians and computer programmers use the same areas of their brains
    for their creative activities, and a decent percentage of programmers were, or
    are, musicians.^([4](ch19_footnote.xhtml#ch01fn4)))
  prefs: []
  type: TYPE_NORMAL
- en: But is software development an actual art form? An *artist* is typically defined
    as someone blessed with certain talents and the skill to use them in a creative
    way. The key word here is *talent*, which is a natural ability. Because not everyone
    is born with the same talents, not everyone can be an artist. To apply the analogy,
    it would seem that if you want to be a programmer, you have to be born that way;
    indeed, some people seem to be born with a natural talent or aptitude for programming.
  prefs: []
  type: TYPE_NORMAL
- en: The “programmer as artist” comparison seems to apply to the very best programmers.
    Although artists follow their own set of rules to produce quality art, they often
    produce their most exceptional art when they bend the rules and explore new creative
    ground. Similarly, the very best programmers are familiar with good software development
    rules but are also willing to experiment with new techniques to try to improve
    the development process. Just as true artists are not content with duplicating
    existing work or styles, the “programmer as artist” is happier creating new applications
    than grinding out yet another version of an old one.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*One of the most well-respected textbook series on computer science is Donald
    Knuth’s *The Art of Computer Programming*. Clearly, the notion of programming
    as an art form is well entrenched in the computer science field.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2.2 Programmer as Architect***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The artist metaphor works great for small projects where the artist creates
    the idea and implements a work of art, much like a programmer designs and implements
    a small software system. However, for larger software systems, the “programmer
    as architect” analogy is probably a better fit. An architect designs the structure
    but leaves the implementation to others (because often it’s logistically impossible
    for one person to build it). In computer science, those who design a system for
    others to implement are often called *programmer/analysts*.
  prefs: []
  type: TYPE_NORMAL
- en: An architect exercises large-scale creative control over a project. For example,
    an architect designing a fancy building defines how it will look, what materials
    to use, and the guidelines for the construction workers to follow, but doesn’t
    handle the construction itself. An architect might supervise the build (much like
    a programmer/analyst would review modules others add to their software system);
    however, the architect doesn’t wield a hammer or operate a crane.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem that this analogy doesn’t apply to small projects, but it can
    if you allow an individual to “change hats.” That is, during the first phase of
    the project, the programmer puts on their architect/programmer/analyst hat and
    creates the design for the system. Then the programmer switches hats and puts
    on their programmer/coder hat to implement the system.
  prefs: []
  type: TYPE_NORMAL
- en: What the “programmer as architect” paradigm adds over and above the “programmer
    as artist” model is verification and safety measures. When an artist paints an
    image, composes a piece of music, or sculpts an object, they generally don’t worry
    about whether that work meets any requirements other than their own. Also, they
    don’t have to worry about how that art might physically hurt life or property.^([5](ch19_footnote.xhtml#ch01fn5))
    An architect, on the other hand, must consider physical realities and the fact
    that a bad design can lead to injury or harm. The “programmer as architect” paradigm
    introduces personal responsibility, review (testing), and safety to the programmer’s
    task.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2.3 Programmer as Engineer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A NATO conference in 1968 challenged the notion that good programmers are born,
    not made. As mentioned in this book’s introduction, the world was facing a software
    crisis—new software applications were needed faster than programmers could be
    trained to create them. So NATO sponsored the 1968 conference, coining the term
    *software engineering* to describe how to tackle the problem by applying engineering
    principles to the wild world of computer programming.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers are interested in solving practical problems cost-effectively, in
    terms of both the design effort and the cost of production. For this reason, coupled
    with the fact that the engineering profession has been around for a very long
    time (particularly mechanical and chemical engineering), a large number of procedures
    and policies have been created for engineers over the years to streamline their
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In many engineering fields today, an engineer’s task is to construct a large
    system from smaller, predesigned building blocks. An electrical engineer who wants
    to design a computer system doesn’t start by designing custom transistors or other
    small components; instead, they use predesigned CPUs, memory elements, and I/O
    devices, assembling them into a complete system. Similarly, a mechanical engineer
    can use predesigned trusses and pedestals to design a new bridge. Design reuse
    is the hallmark of the engineering profession. It’s one of the key elements to
    producing safe, reliable, functional, and cost-effective designs as rapidly as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software engineers also follow a set of well-defined procedures and policies
    to construct large systems from smaller predefined systems. Indeed, the Institute
    of Electrical and Electronics Engineers (IEEE) defines *software engineering*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application of a systematic, disciplined, quantifiable approach to development,
    operation, and maintenance of software; that is, the application of engineering
    to software.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2.4 Programmer as Craftsman***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The craftsman model lies somewhere between the artist and the engineer. Central
    to this paradigm is the idea of programmers as individuals; that is, the software
    craftsman metaphor recognizes that people matter. Throwing more people and restrictive
    rules at a problem doesn’t produce higher-quality software, but training individuals
    better and allowing them to apply their natural talents and skills does.
  prefs: []
  type: TYPE_NORMAL
- en: There are parallels between the traditional craftsman’s development process
    and that of the software craftsman. Like all craftsmen, a software craftsman starts
    as an *apprentice* or an *intern*. An apprentice works under the close guidance
    of another craftsman. After learning the ropes, the apprentice programmer becomes
    a *journeyman*, usually working with teams of other programmers under the supervision
    of a software craftsman. Ultimately, the programmer’s skills increase to the point
    that they become a *master craftsman*.
  prefs: []
  type: TYPE_NORMAL
- en: The craftsman model provides the best metaphor for programmers intent upon becoming
    great programmers. I’ll return to the discussion of this metaphor later in this
    chapter, in the section “[Software Craftsmanship](ch01.xhtml#lev-1.4)” on [page
    13](ch01.xhtml#page_13).
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2.5 Artist, Architect, Engineer, or Craftsman?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write great code, you must understand what makes code great. You need to
    use the best tools, coding techniques, procedures, processes, and policies when
    writing code. In addition, you must constantly increase your knowledge and improve
    the development processes you use to enhance the quality of the software you develop.
    That’s why it’s important to consider different approaches to software development,
    understand the software product, and choose the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to work hard to learn how to write great code and then work hard at
    actually writing it. A great software developer adopts ideas that work from each
    of the fields just discussed and dispenses with those that don’t work. To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Great artists* practice their skills to develop their talents. They engage
    in divergent thinking to explore new ways of presenting their message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Great architects* know how to build upon existing designs using standard components
    to create custom objects. They understand cost constraints, safety issues, requirements,
    and the need for overdesign to ensure reliable operation. Great architects understand
    the relationship between form and function, as well as the need to fulfill customer
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Great engineers* recognize the benefit of consistency. They document and automate
    development steps to avoid missing steps in the process. Like architects, engineers
    encourage the reuse of existing designs to deliver more robust and cost-effective
    solutions. Engineering provides procedures and policies to help overcome personal
    limitations in a project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Great craftsmen* train and practice skills under the tutelage of a master
    with the ultimate goal of becoming a master craftsman. This metaphor emphasizes
    the qualities of the individual such as their problem-solving and organizational
    abilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1.3 Software Engineering**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since its emergence in the late 1960s, software engineering has become an unqualified
    success. Today, few professional programmers would accept the coding horrors that
    were “standard procedure” at the dawn of the field. Concepts that modern programmers
    take for granted—such as structured programming, proper program layout (like indentation),
    commenting, and good naming policies—are all due to software engineering research.
    Indeed, decades of such research have greatly influenced modern programming languages
    and other programming tools.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering has been around for so long and has had such an impact
    on all facets of computer programming that many people assume the term *software
    engineer* is synonymous with *computer programmer*. It’s certainly true that any
    professional software engineer should also be a capable computer programmer, but
    computer programming constitutes only a small part of software engineering. Software
    engineering largely involves economics and project management. Interestingly,
    those responsible for managing the projects, maintaining the schedules, choosing
    the methodologies to use, and so on are not called software engineers; they’re
    called managers, project leads, and other titles implying a position of authority.
    Likewise, the people we call software engineers don’t actually do the software
    engineering—they simply write the code specified by the actual software engineers
    (managers and project leads). This is, perhaps, why there is so much confusion
    around the term *software engineering*.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.3.1 A Formal Definition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No single definition of *software engineering* seems to satisfy everyone. Different
    authors add their own “spin,” making their definition slightly (or greatly) different
    than those found in other texts. The reason this book is titled *Engineering Software*
    is because I want to avoid adding yet another definition to the mix. As a reminder,
    the IEEE defines *software engineering* as
  prefs: []
  type: TYPE_NORMAL
- en: The application of a systematic, disciplined, quantifiable approach to development,
    operation, and maintenance of software; that is, the application of engineering
    to software.
  prefs: []
  type: TYPE_NORMAL
- en: The original software engineering definition, and the one I use, is
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering is the study of the development and management of large
    software systems.
  prefs: []
  type: TYPE_NORMAL
- en: The operative term here is *large*. Progress in software engineering has mostly
    been funded by defense contracts and the like, so it’s no surprise that software
    engineering is synonymous with large systems. The IEEE definition could apply
    to systems of nearly any size, but because most of the research into software
    engineering deals with very large systems, I prefer the second definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To avoid confusion with the generic term *software engineering*, I use a more
    specialized term, *personal software engineering*, to describe those processes
    and methodologies that apply to a single programmer working on a small project
    or a small part of a larger project. My intent is to describe what computer programmers
    believe is the essence of software engineering without all the extraneous detail
    that has little to do with writing great code.*'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to software development, people have completely different concepts
    of what “large” means. An undergraduate in a computer science program might think
    that a program containing a couple thousand lines of source code is a large system.
    To a project manager at Boeing (or other large firm), a large system contains
    well over one million lines of code. The last time I counted (which was a long
    time ago), Microsoft’s Windows operating system (OS) exceeded 50 million lines
    of source code; no one questions that Windows is a large system!
  prefs: []
  type: TYPE_NORMAL
- en: Because traditional software engineering definitions generally apply to large
    software systems, we need to come up with a reasonable definition of large (and
    small) software systems. Although *lines of code (LOC)* is the metric software
    engineers often use to describe the size of a software system, it is a low-quality
    metric with almost a two-order-of-magnitude variance.^([6](ch19_footnote.xhtml#ch01fn6))
    This book will often use the LOC or *thousands of lines of code (KLOC)* metric.
    But it’s not a good idea to base a formal definition on such a poor metric. Doing
    so weakens the definition.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.3.2 Project Size***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *small project* is one that an average programmer can complete on their own
    in a reasonable amount of time (less than two years). A *medium-sized project*
    is too large for an individual to complete in a reasonable time frame, but a small
    team of two to five programmers can accomplish it. A *large project* requires
    a large team of programmers (more than five members). In terms of LOC, a small
    project contains about 50 to 100 KLOC; medium-sized projects fall into the 50
    to 1,000 KLOC (one million lines of source code) range; and large projects start
    at around 500 to 1,000 KLOC.
  prefs: []
  type: TYPE_NORMAL
- en: Small projects are trivial to manage. Because small projects require no interaction
    between programmers and very little interaction between the programmer and the
    outside world, productivity depends almost solely upon the programmer’s abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Medium-sized projects introduce new challenges. Because multiple programmers
    are working on the project, communication can become a problem, but the team is
    small enough that this overhead is manageable. Nevertheless, the group dynamics
    require extra support, which increases the cost of each line of code written.
  prefs: []
  type: TYPE_NORMAL
- en: Large projects require a large team of programmers. Communication and other
    overhead often consume 50 percent of each engineer’s productivity. Effective project
    management is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering deals with the methodologies, practices, and policies needed
    to successfully manage projects requiring large teams of programmers. Unfortunately,
    practices that work well for individuals, or even small teams, don’t scale up
    to large teams, and large-project methodologies, practices, and policies don’t
    scale down to small and medium-sized projects. Practices that work well for large
    projects typically inject unreasonable overhead into small and medium-sized projects,
    reducing the productivity of those small teams.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at some benefits and drawbacks of projects of different
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3.2.1 Small Projects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On small projects, a single software engineer is completely responsible for
    system design, implementation, testing, debugging, deployment, and documentation.
    On such a project, the lone engineer is accountable for far more tasks than a
    single engineer would be on a medium-sized or large project. But the tasks are
    small and therefore manageable. Because a small project requires an individual
    to perform a wide range of tasks, the programmer must possess a varied skill set.
    Personal software engineering covers all the activities a developer would do on
    a small project.
  prefs: []
  type: TYPE_NORMAL
- en: Small projects make the most efficient use of engineering resources. The engineer
    can employ the most productive approach to solving problems because they don’t
    have to reach a consensus with other engineers on the project. The engineer can
    also optimize the time they spend on each development phase. In a structured software
    design regimen, considerable time is spent documenting operations, which doesn’t
    make sense when there’s only a single programmer on a project (though a different
    programmer might need to work with the code later in the product’s lifetime).
  prefs: []
  type: TYPE_NORMAL
- en: The drawback, and the trap, of a small project is that an engineer must be capable
    of handling all the different tasks required. Many small projects fail (or their
    development cost is too high) because the engineer doesn’t have the proper training
    to handle an entire project. More than any other goal, the purpose of the *Write
    Great Code* series is to teach programmers how to do small projects properly.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3.2.2 Medium-Sized Projects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On a medium-sized project, personal software engineering encompasses those aspects
    of the project for which a single engineer is responsible. This typically includes
    the design of their system component, its implementation (coding), and the documentation
    for that module. Generally, they are also responsible for testing their component
    (*unit testing*), and then the team as a whole tests the entire system (*integration
    testing*). Usually, there’s one engineer in charge of the complete system design
    (the *project head* or *lead programmer*) who also handles deployment. Depending
    on the project, a technical writer might handle system documentation. Because
    engineers share tasks in a medium-sized project, specialization is possible, and
    the project doesn’t require each engineer to be capable of performing all the
    individual tasks. The lead programmer can direct the activities of those less
    experienced to maintain quality throughout the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single engineer on a small project sees the total picture and can optimize
    certain activities based on their understanding of the entire project. On a large
    project, a single engineer is unaware of much of the project beyond their small
    piece of it. Medium-sized projects provide a hybrid of these two extremes: individuals
    can see much of the entire project and adjust their approach to system implementation.
    They can also specialize on certain aspects of the system without becoming overwhelmed
    by the details of the rest of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3.2.3 Large Projects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On a large project, various team members have specialized roles, from system
    design to implementation, testing, documentation, deployment, and system enhancement
    and maintenance. As with medium-sized projects, in large projects personal software
    engineering encompasses only those activities for which an individual programmer
    is responsible. Software engineers on a large project generally do only a few
    tasks (such as coding and unit testing); therefore, they don’t require the wide-ranging
    skill set of a lone programmer on a small project.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the scope of activity, the size of a project affects the productivity
    of its engineers. On a large project, engineers can become very specialized and
    concentrate on their one area of expertise. This allows them to do their job more
    efficiently than if they had to use a more generalized skill set. However, large
    projects must use a common software development approach to be effective, and
    some engineers may not be as productive if they don’t like the approach.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.3.3 Where Software Engineering Fails***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s possible to apply engineering techniques to software development to produce
    applications in a more cost-effective manner. However, as Pete McBreen states
    in *Software Craftsmanship: The New Imperative*, the biggest problem with software
    engineering is the assumption that a “systematic, disciplined, quantifiable approach”
    is the only reasonable approach. In fact, he raises a very good question: is it
    even possible to make software development systematic and quantified? Quoting
    *[http://www.controlchaos.com/](http://www.controlchaos.com/)*, McBreen says:'
  prefs: []
  type: TYPE_NORMAL
- en: If a process can be fully defined, with all things known about it so that it
    can be designed and run repeatedly with predictable results, it is known as a
    defined process, and it can be subjected to automation. If all things about a
    process aren’t fully known—only what generally happens when you mix these inputs
    and what to measure and control to get the desired output—these are called empirical
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Software development is not a defined process; it’s an empirical process. As
    such, software development cannot be fully automated, and it’s often difficult
    to apply engineering principles to software development. Part of the problem is
    that practical engineering relies so much on the reuse of existing designs. Although
    a considerable amount of reuse is possible in computer programming, too, it requires
    much more customization than you find in other engineering professions.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant problem with software engineering, as briefly discussed
    in the book’s introduction, is that software engineering treats software engineers
    as commodity resources that a manager can swap arbitrarily into and out of a project,
    which disregards the importance of an individual’s talents. The issue isn’t that
    engineering techniques aren’t ever valuable, but that management attempts to apply
    them uniformly to everyone and encourages the use of some current set of “best
    practices” in software development. This approach can produce quality software,
    but it doesn’t allow for thinking outside the box and creating new practices that
    might be better.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.4 Software Craftsmanship**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software craftmanship, where a programmer trains and practices skills under
    the tutelage of a master, is about lifelong learning to be the best software developer
    you can be. Following the craftmanship model, a programmer gets an education,
    completes an apprenticeship, becomes a journeyman programmer, and strives to develop
    a masterpiece.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.4.1 Education***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Colleges and universities provide the prerequisites that interns need to be
    software craftsmen. If an internship exposed a beginning programmer (intern/apprentice)
    to the same information and challenges that a formal education does, the internship
    might be equivalent to a formal education. Unfortunately, few software craftsmen
    have the time or ability to train an apprentice from scratch. They’re far too
    busy working on real-world projects to devote the time needed to teach an intern
    everything they need to know. Therefore, education is the first step on the road
    to software craftsmanship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, a formal education at a college or university accomplishes two
    main objectives: first, you’re forced to study those computer science topics that
    you’d probably just skip over if you were studying the material on your own; and
    second, you prove to the world that you’re capable of finishing a major commitment
    that you’ve started. In particular, after you’ve completed a formal computer science
    program, you’re ready to *really* start learning about software development.'
  prefs: []
  type: TYPE_NORMAL
- en: However, a college degree, no matter how advanced, doesn’t automatically qualify
    you as a software craftsman. A person with a graduate degree, which requires a
    deeper and more specialized study of computer science, starts out as an intern,
    just as someone with an undergraduate degree does. The intern with the graduate
    degree might spend fewer years as an apprentice but still needs considerable training.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.4.2 Apprenticeship***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Completing a formal computer science program prepares you to start learning,
    at an apprentice level, how to become a craftsman. A typical computer science
    program teaches you about programming languages (their syntax and semantics),
    data structures, and the theory of compilers, operating systems, and the like,
    but doesn’t teach you *how to program* beyond the first- or second-semester Introduction
    to Programming courses. An apprenticeship shows you what programming is about
    when you enter the real world. The purpose of an apprenticeship is to get the
    experience necessary to use what you’ve learned to approach problems in many different
    ways, and to gain as many different experiences as possible.
  prefs: []
  type: TYPE_NORMAL
- en: An apprentice studies under someone who has mastered advanced programming techniques.
    This person can be either a *software journeyman* (see the next section) or a
    *software craftsman*. The “master” assigns tasks to the apprentice, demonstrates
    how to accomplish the task, and reviews the apprentice’s work, making appropriate
    mid-course corrections to obtain high-quality work. Most important, the apprentice
    also reviews their master’s work. This can take various forms, including testing,
    structured walk-throughs, and debugging. The important factor is that the apprentice
    learns how the master’s code operates.^([7](ch19_footnote.xhtml#ch01fn7)) In doing
    so, the apprentice picks up programming techniques they would never master on
    their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an apprentice is lucky, they’ll have the opportunity to study under several
    masters and learn solid techniques from all of them. With each project completed
    under the tutelage of an advanced programmer, the apprentice nears the end of
    their apprenticeship and moves on to the next stage in the software craftsman’s
    route: the software journeyman.'
  prefs: []
  type: TYPE_NORMAL
- en: In one sense, an apprenticeship never ends. You should always be on the lookout
    for new techniques and new skills. For example, consider all the software engineers
    who grew up on structured programming and had to learn object-oriented programming.
    However, at some point, you reach the stage where you’re using your existing skills
    more often than developing new ones. At that point, you start imparting your wisdom
    to others rather than learning from others. It’s then that the “masters” you’re
    working with feel you’re ready to tackle projects on your own without assistance
    or supervision. That’s when you become a software journeyman.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.4.3 The Software Journeyman***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Software journeymen handle the bulk of software development. As the name suggests,
    they typically move from project to project, applying their skills to solve application
    problems. Even though a software developer’s education never ends, a software
    journeyman is more focused on application development than on learning how to
    develop applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another important task that software journeymen take on is training new software
    apprentices. They review the work of apprentices on their project and share programming
    techniques and knowledge with them.
  prefs: []
  type: TYPE_NORMAL
- en: A software journeyman constantly looks for new tools and techniques that can
    improve the software development process. By adopting new (but proven) techniques
    early on, they stay ahead of the learning curve and keep up with current trends
    to avoid falling behind. Utilizing industry best practices to create efficient
    and cost-effective solutions for customers is the hallmark of this stage of craftsmanship.
    Software journeymen are productive, knowledgeable, and exactly the type of software
    developer most project managers hope to find when assembling a software team.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.4.4 The Master Craftsman***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The traditional way to become a master craftsman is to create a *masterpiece*,
    a work that sets you apart from your peers. Some (high-end) examples of software
    masterpieces include VisiCalc,^([8](ch19_footnote.xhtml#ch01fn8)) the Linux operating
    system, and the vi and emacs text editors. These products were initially the brainchild
    and creation of a single person, even though they went on to involve dozens or
    hundreds of different programmers. A masterpiece doesn’t have to become famous,
    like Linux or some GNU tool. However, your immediate peers must recognize your
    masterpiece as a useful and creative solution to a problem. A masterpiece doesn’t
    have to be a stand-alone original piece of code, either. Writing a complex device
    driver for an operating system, or extending some other program in several useful
    ways, could very well qualify as a masterpiece. The purpose of the masterpiece
    is to create an item in your portfolio that tells the world: “I’m capable of producing
    serious software—take me seriously!” A masterpiece work lets others know that
    they should seriously consider your opinions and trust what you have to say.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the domain of the master craftsman is to determine what current best
    practices are and invent new ones. Best practices describe the best *known* way,
    not necessarily the absolute best way, to accomplish a task. The master craftsman
    investigates whether there’s a better approach for designing applications, recognizes
    the utility of a new technique or methodology as it applies to a wide spectrum
    of applications, and verifies that a practice is best and communicates that information
    to others.
  prefs: []
  type: TYPE_NORMAL
- en: '***1.4.5 Where Software Craftsmanship Fails***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Steve McConnell, in his classic software engineering book *Code Complete*,
    claims that experience is one of those characteristics that doesn’t matter as
    much as people think: “If a programmer hasn’t learned C after a year or two, the
    next three years won’t make much difference.” He then asks, “If you work for 10
    years, do you get 10 years of experience or do you get 1 year of experience 10
    times?” McConnell even suggests that book learning might be more important than
    programming experience. He claims that the computer science field changes so fast
    that someone with 10 years of programming experience has missed out on all the
    great research to which new programmers have been exposed during that decade.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.5 The Path to Writing Great Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing great code doesn’t happen because you follow a list of rules. You must
    make a personal decision to put in the effort to ensure the code you’re writing
    is truly great. Violating well-understood software engineering principles is a
    good way to ensure that your code is not great, but rigidly following such rules
    doesn’t guarantee greatness, either. A well-experienced and meticulous developer,
    or software craftsman, can navigate both approaches: following established practices
    when it’s required, but being unafraid to try a different technique or strategy
    when the need arises.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, a book can only teach you the rules and methodologies. Creativity
    and wisdom are qualities you need to develop on your own. This book teaches you
    the rules and suggests when you might consider breaking them. However, it’s still
    up to you to decide whether to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.6 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hunt, Andrew, and David Thomas. *The Pragmatic Programmer*. Upper Saddle River,
    NJ: Addison-Wesley Professional, 1999.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernighan, Brian, and Rob Pike. *The Practice of Programming*. Upper Saddle
    River, NJ: Addison-Wesley Professional, 1999.'
  prefs: []
  type: TYPE_NORMAL
- en: 'McBreen, Pete. *Software Craftsmanship: The New Imperative*. Upper Saddle River,
    NJ: Addison-Wesley Professional, 2001.'
  prefs: []
  type: TYPE_NORMAL
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: '———. *Rapid Development: Taming Wild Software Schedules*. Redmond, WA: Microsoft
    Press, 1996.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressman, Robert S. *Software Engineering, A Practitioner’s Approach*. New
    York: McGraw-Hill, 2010.'
  prefs: []
  type: TYPE_NORMAL
