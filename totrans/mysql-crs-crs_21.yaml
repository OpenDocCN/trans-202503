- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Weather Database
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this project, you’ll build a weather database for a trucking company. The
    company transports items up and down the East Coast of the United States and needs
    a way to get the current weather for the major cities its drivers travel to.
  prefs: []
  type: TYPE_NORMAL
- en: The company already has a MySQL database set up that contains trucking data,
    but you need to add a new database detailing the current weather conditions for
    areas the truckers drive through. This will allow you to incorporate weather data
    into the existing trucking application to show the weather’s impact on scheduling
    and warn drivers of hazardous conditions like black ice, snow, and extreme temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get these weather data files from a third-party company that provides
    weather data. That company has agreed to send you a CSV file every hour. Recall
    from [Chapter 14](c14.xhtml) that a CSV file is a text file that contains data
    and uses a comma as the delimiter between fields.
  prefs: []
  type: TYPE_NORMAL
- en: The company providing the weather data will use FTP (File Transfer Protocol),
    a standard communication protocol that allows files to be transferred between
    computers, to deliver the *weather.csv* file to your */home/weather_load/ directory
    on one of your Linux servers. The data file will arrive approximately every hour,
    but there can be delays, meaning the files may not arrive exactly at hourly intervals.
    For that reason, you’ll write a program that will run every 5 minutes to check
    for the file and load it into your database when it’s available.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Once you’ve reviewed the necessary technologies, you’ll begin your project
    by creating a new database called `weather` with two tables: `current_weather_load`
    and `current_weather`. You’ll load the data from the file into the `current_weather_load`
    table. Once you ensure that the data loads without any problems, you’ll copy the
    data from `current_weather_load` to the `current_weather` table, which is the
    table that your trucking application will use. You can find the *weather.csv*
    data file at [https://github.com/ricksilva/mysql_cc/tree/main/chapter_16](https://github.com/ricksilva/mysql_cc/tree/main/chapter_16).'
  prefs: []
  type: TYPE_NORMAL
- en: Technologies You’ll Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, you’ll use other technologies in addition to MySQL, including
    cron and Bash. These technologies allow you to schedule the loading of your weather
    data, check whether the data file is available, and create a logfile containing
    any load errors.
  prefs: []
  type: TYPE_NORMAL
- en: cron
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to schedule a script to run every 5 minutes, you’ll use *cron*, a scheduler
    available on Unix-like operating systems (Unix, Linux, and macOS). It is also
    available on Windows through the Windows Subsystem for Linux (WSL), which lets
    you run a Linux environment on a Windows computer. To install WSL, enter `wsl
    --install` on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The tasks that you schedule in cron are called *cron jobs*, and they run in
    the background, not attached to a terminal. You can schedule jobs by adding them
    to a configuration file called the *crontab* (*cron table*) file.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of your scheduled cron jobs by typing `crontab -l`. If you
    need to edit your crontab configuration file, type `crontab -e`. The `-e` option
    will open a text editor where you can add, modify, or delete jobs from your crontab
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To schedule a cron job, you must provide six pieces of information, in this
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: Minute (0–59)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hour (0–23)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Day of the month (1–31)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month (1–12)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Day of the week (0–6) (Sunday to Saturday)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command or script to run
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if you wanted to schedule a script called *pi_day.sh* to run,
    you’d type `crontab -e` and add a crontab entry that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this cron job in place, the *pi_day.sh* script in the */usr/local/bin/*
    directory will execute every year on March 14 at 3:14 AM. Since the day of the
    week has been set to `*` (the wildcard), the job will execute on whatever day
    of the week March 14th happens to be on that year.
  prefs: []
  type: TYPE_NORMAL
- en: Bash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bash* is a shell and command language available in Unix and Linux environments.
    You could use any number of tools or languages, but I’ve chosen Bash because of
    its popularity and relative simplicity. Bash scripts usually have the extension
    *.sh*, like *pi_day.sh* in the preceding example. In this chapter’s project, you’ll
    write a Bash script called *weather.sh* that cron will run every 5 minutes. This
    script will check if a new data file has arrived and call SQL scripts to load
    the data into your database if it has.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQL scripts are text files that contain SQL commands. For this project, you’ll
    write two SQL scripts called *load_weather.sql* and *copy_weather.sql*. The *load_weather.sql*
    script will load the data from the CSV file into the `current_weather_load` table
    and alert you to any load issues. The *copy_weather.sql* script will copy the
    weather data from the `current_weather_load` table to the `current_weather` table.
  prefs: []
  type: TYPE_NORMAL
- en: Project Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll schedule a cron job to run the *weather.sh* script every 5 minutes. If
    a new *weather.csv* data file exists, it will be loaded into the `current_weather_load`
    table. If it is loaded without errors, the data in the `current_weather_load`
    table will be copied to the `current_weather` table, where it will be used by
    your application. [Figure 16-1](#figure16-1) shows the flow of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c16/f16001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-1: An overview of your weather project'
  prefs: []
  type: TYPE_NORMAL
- en: If there isn’t a new *weather.csv* file available, the *weather.sh* script exits
    without running the rest of the commands in the Bash script that load the data
    and log errors. If the file was loaded and there aren’t any errors in *load_weather.log*,
    the Bash script will call *copy_weather.sql* to copy the data you just loaded
    in the `current_weather_load` table to the `current_weather` table.
  prefs: []
  type: TYPE_NORMAL
- en: The Data File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the trucking company travels up and down the US East Coast, you’ve requested
    the weather for the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: Portland, Maine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boston, Massachusetts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providence, Rhode Island
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New York, New York
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Philadelphia, Pennsylvania
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Washington, DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Richmond, Virginia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raleigh, North Carolina
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charleston, South Carolina
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jacksonville, Florida
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miami, Florida
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSV data file will include the fields listed in [Table 16-1](#table16-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-1: Fields in the CSV Data File'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `station_id` | The ID for the weather station where this data originated
    |'
  prefs: []
  type: TYPE_TB
- en: '| `station_city` | The city where the weather station is located |'
  prefs: []
  type: TYPE_TB
- en: '| `station_state` | A two-character code for the state where the weather station
    is located |'
  prefs: []
  type: TYPE_TB
- en: '| `station_lat` | The latitude of this weather station |'
  prefs: []
  type: TYPE_TB
- en: '| `station_lon` | The longitude of this weather station |'
  prefs: []
  type: TYPE_TB
- en: '| `as_of_datetime` | The date and time that the data was gathered |'
  prefs: []
  type: TYPE_TB
- en: '| `temp` | The temperature |'
  prefs: []
  type: TYPE_TB
- en: '| `feels_like` | The temperature that it currently “feels like” |'
  prefs: []
  type: TYPE_TB
- en: '| `wind` | The wind velocity (in kilometers per hour) |'
  prefs: []
  type: TYPE_TB
- en: '| `wind_direction` | The direction of the wind |'
  prefs: []
  type: TYPE_TB
- en: '| `precipitation` | Precipitation in the last hour (in millimeters) |'
  prefs: []
  type: TYPE_TB
- en: '| `pressure` | Barometric pressure |'
  prefs: []
  type: TYPE_TB
- en: '| `visibility` | The distance that can be clearly seen (in miles) |'
  prefs: []
  type: TYPE_TB
- en: '| `humidity` | The percentage of relative humidity in the air |'
  prefs: []
  type: TYPE_TB
- en: '| `weather_desc` | A text description of the current weather |'
  prefs: []
  type: TYPE_TB
- en: '| `sunrise` | The time that the sun rises at this location today |'
  prefs: []
  type: TYPE_TB
- en: '| `sunset` | The time that the sun sets at this location today |'
  prefs: []
  type: TYPE_TB
- en: Approximately every hour, a CSV file containing the data for the locations that
    you requested will be delivered to you. The CSV file should look similar to [Figure
    16-2](#figure16-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c16/f16002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-2: The *weather.csv* data file'
  prefs: []
  type: TYPE_NORMAL
- en: The file has one row for each of the 11 weather stations you requested, with
    every field delimited by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Weather Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a MySQL database called `weather` to store the weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ll create a table called `current_weather_load` to load the CSV file
    data into. The `_load` suffix makes it clear that this table is for loading data
    about the current weather.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-1](#listing16-1) shows the SQL statement to create the `current_weather_load`
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-1: Creating the `current_weather_load` table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a second table called `current_weather` with the same structure
    as `current_weather_load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these two tables in place, you now have a table that you can load the CSV
    file to, as well as a final, user-facing table that you’ll copy the weather data
    to once you are confident it has loaded cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over [Listing 16-1](#listing16-1) in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always choose data types for the columns that match the data in the
    CSV file as closely as possible. For example, you define the `station_id`, `temp`,
    `feels_like`, `wind`, and `humidity` columns as `int` data types since they will
    come to you as numeric values without a decimal point. You define `station_lat`,
    `station_lon`, `precipitation`, `pressure`, and `visibility` as `decimal` data
    types because they will contain decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: You should also consider how large the column values could be. For example,
    you define the `station_lat` column as `decimal(6,4)` because latitudes need to
    store numbers with up to two digits before the decimal point and four digits after
    the decimal point. You define `station_lon` as `decimal(7,4)` because it represents
    a longitude, which needs to store up to *three* digits before the decimal point
    and four digits after it. A longitude column needs to be able to hold a larger
    value than a latitude column.
  prefs: []
  type: TYPE_NORMAL
- en: You have to get creative with the `as_of_dt` column. Its data comes to you in
    the format `YYYYMMDD hh:mm`. MySQL doesn’t have a data type that stores data in
    this format, so you create the `as_of_dt` column with a data type of `datetime`.
    When you load the data file into your load table, you’ll convert this value to
    the `datetime` format. (We’ll discuss how in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: The `station_state` column will always contain two characters, so you define
    it as `char(2)`. Since the `station_city` and `weather_desc` columns will have
    a variable number of characters, you define both as a `varchar` containing up
    to 100 characters. No city or description should have more than 100 characters,
    so if you get a value for those columns that is larger than 100, you can safely
    say the data is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: The `sunrise` and `sunset` values come to you formatted as times with the hour
    and the minute provided. You use the `time` data type for those values, even though
    you aren’t being sent the seconds in the data file. You’ll load the values into
    columns with the `time` data type and let the seconds automatically default to
    zeros. For example, you’ll load the value `17:06` and it will be saved in the
    table as `17:06:00`. This will work fine for your purposes since your application
    doesn’t need to track the sunrise and sunset time down to the second.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You create a primary key on the `station_id` column to enforce uniqueness. If
    the data file comes to you with two records for the same weather station, you
    don’t want to load both records. Setting `station_id` as the primary key will
    prevent the second row from being loaded and will produce a warning message alerting
    you to a problem in the data file.
  prefs: []
  type: TYPE_NORMAL
- en: You add some other constraints to your columns as quality checks of the data
    that will be loaded into the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `station_lat` column must be in the range of a valid latitude value: –90.0000
    to 90.0000\. You already defined `station_lat` with a data type of `decimal(6,4)`
    so there can be only six total digits, with four digits after the decimal point,
    but that won’t prevent an invalid value like `95.5555` from being written to the
    column. Adding a `check` constraint will enforce that the value is in the appropriate
    range. This allows you to store all legitimate latitude values in your column
    and reject any values outside of that range. Similarly, the `station_lon` column
    must be in the range of a valid longitude value: –180.0000 to 180.0000.'
  prefs: []
  type: TYPE_NORMAL
- en: The `wind_direction` column also has a `check` constraint to ensure that it
    contains only one of 16 possible values that you provided in a list (`N` for North,
    `SE` for Southeast, `NNW` for North-Northwest, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The other `check` constraints ensure that your data is within reasonable ranges
    for weather data. For example, a temperature outside of the range of –50 degrees
    to 150 degrees Fahrenheit is likely a mistake, so you’ll reject it. Humidity is
    a percentage, so you enforce that it must be within the range of 0 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: You also declare some of the columns in your load table with the `not null`
    constraint. These columns are so important that you want your load to fail if
    they are not provided. The `station_id` column must not be null since it is the
    primary key of the table.
  prefs: []
  type: TYPE_NORMAL
- en: You define `station_lat` and `station_lon` as `not null` because you want to
    plot the weather station’s location on a map in your trucking application. You
    want to show each weather station’s current temperature, visibility, and conditions
    at the right map location, and you can’t do that if the station’s latitude and
    longitude aren’t provided.
  prefs: []
  type: TYPE_NORMAL
- en: The `temperature`, `visibility`, and `weather_desc` columns are also key pieces
    of data for this project, and thus you define them as `not null` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Data File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you create the *weather.sh* Bash script that checks if a new CSV weather
    file is available, you’ll write the *load_weather.sql* SQL script that will load
    the CSV file into your `current_weather_load` table (see [Listing 16-2](#listing16-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-2: The *load_weather.sql* script'
  prefs: []
  type: TYPE_NORMAL
- en: First, you set your current database to the `weather` database and delete all
    rows from the `current_weather_load` table that may have been left over from a
    previous load.
  prefs: []
  type: TYPE_NORMAL
- en: Then you use the `load data` command you saw in Chapter 14 to load the *weather.csv*
    file into the `current_weather_load` table. Because you’re loading a comma-separated
    file, you need to specify `fields terminated by ','` ❶ so that `load data` knows
    where one field ends and the next field begins. You specify that the data file
    is called *weather.csv* and is in the */home/weather_load/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within parentheses, you list all the columns in the table that you want the
    data fields loaded into, with one exception: instead of loading a value directly
    from the file into the `as_of_dt` column, you load it into a variable called `@aod`
    ❷. This variable holds the value of the `as of date` as it is formatted in the
    CSV file, which, as mentioned earlier, is `YYYYMMDD hh:mm`. You convert the value
    of the `@aod` variable from a string to a `datetime` data type using MySQL’s `str_to_date()`
    function ❸. You use the format specifiers `%Y`, `%m`, `%d`, `%H`, and `%i` to
    specify the format of the string. By specifying `str_to_date(@aod,''%Y%m%d %H:%i'')`,
    you’re saying the `@aod` variable is made up of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%Y`, a four-digit year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%m`, a two-digit month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%d`, a two-digit day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%H`, a two-digit hour (0–23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A colon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%i`, a two-digit minute (0–59)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this information, the `str_to_date()` function has what it needs to convert
    the `@aod` string to the `as_of_date datetime` field in the `current_weather_load`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you check if there were any problems loading the data. The `show warnings`
    command ❹ lists any errors, warnings, or notes from the last command that you
    ran. If problems in the data file caused your `load data` command to fail, `show
    warnings` will tell you what the problem was.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you add a query as a second check that the data loaded properly ❺. In
    this query, you get a list of all the weather stations that had data the last
    time you wrote data into the `current_weather` table. If any of those weather
    stations aren’t in the `current_weather_load` table you just loaded, that likely
    means weather station data was missing from your data file or there was a problem
    with that weather station’s data that caused it not to load. In either case, you
    want to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now written your *load_weather.sql* script to notify you of any problems
    with loading the data. If *load_weather.sql* runs and no output is created, the
    data was loaded into the `current_weather_load` table without a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the Data to Your Final Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the data is loaded from the CSV data file into your `current_weather_load`
    table without issue, you’ll run another SQL script called *copy_weather.sql* to
    copy the data to your final `current_weather` table ([Listing 16-3](#listing16-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-3: The *copy_weather.sql* script'
  prefs: []
  type: TYPE_NORMAL
- en: This SQL script sets your current database to the `weather` database, deletes
    all old rows from the `current_weather` table, and loads the `current_weather`
    table with the data from the `current_weather_load` table.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your SQL scripts written, you can write the Bash script that
    calls them ([Listing 16-4](#listing16-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-4: The *weather.sh* script'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of a Bash script ❶ is known as a *shebang*. It tells the system
    that the interpreter to use for the commands in this file is in the */bin/bash*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use the `cd` command to change directories to */home/weather/* ❷.
  prefs: []
  type: TYPE_NORMAL
- en: In your first `if` statement ❸, you check if the *weather.csv* file exists.
    In Bash scripts, `if` statements start with `if` and end with `fi`. The `-f` command
    checks if a file exists, and `!` is the syntax for `not`. The statement `if [
    ! -f weather.csv ]` checks if the *weather.csv* file does not exist. If it doesn’t,
    that means you don’t have a new CSV data file to load, so you `exit` the Bash
    script and provide an exit code of `0`. By convention, you provide an exit code
    of `0` for success or `1` to signal an error. Exiting the Bash script here prevents
    the rest of the script from running; you don’t need to run the rest of the script,
    since you don’t have a data file to process.
  prefs: []
  type: TYPE_NORMAL
- en: You use the MySQL command line client ❹ (the `mysql` command, described in [Chapter
    14](c14.xhtml)) to run the *load_weather.sql* SQL script. If the *load_weather.sql*
    script has any problems loading the data to the `current_weather_load` table,
    you’ll log those problems to a file called *load_weather.log*.
  prefs: []
  type: TYPE_NORMAL
- en: In Bash, the left arrow (`<`) and right arrow (`>`) are used for *redirection*,
    which lets you take your input from a file and write your output to another file.
    The syntax `< load_weather.sql` tells the MySQL command line client to run the
    commands from the *load_weather.sql* script. The syntax `> load_weather.log` says
    to write any output to the *load_weather.log* file.
  prefs: []
  type: TYPE_NORMAL
- en: The `local_infile=1` option lets you run the `load data` command (used in the
    *load_weather.sql* script) using data files on your local computer, as opposed
    to data files on the server where MySQL is installed. This may be unnecessary
    in your environment, depending upon your configuration settings. (Your DBA can
    set this option as a configuration parameter using the command `set global local_infile
    = on`.)
  prefs: []
  type: TYPE_NORMAL
- en: The `-h` option tells the MySQL command line client which host server MySQL
    is installed on. In this case, `-h 127.0.0.1` indicates that your MySQL host server
    is the same computer that you’re currently using to run the script. Also known
    as *localhost*, 127.0.0.1 is the IP address for the current (local) computer.
    You could also simply type `-h` `localhost` here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you provide the database name, `weather`; your MySQL user ID, `trucking`;
    and your password, `Roger`. Oddly, MySQL doesn’t allow a space after the `-p`,
    so enter your password without a preceding space.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `-s` option to run your SQL script in *silent mode*. This prevents
    the script from giving you too much information in your output. For example, if
    no data gets loaded for the Boston weather station, you want to see the message
    `No data loaded for 375: Boston` in your *load_weather.log* file. But without
    the `-s`, the logfile will also show the beginning of the `select` statement that
    produced that message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `-s` prevents the text `concat(''No data loaded for '',station_id,'':
    '',station_city)` from being written to *load_weather.log*.'
  prefs: []
  type: TYPE_NORMAL
- en: In Bash, the backslash character (`\`) lets you continue your command on the
    next line. After the `-s`, you use a backslash and continue on the next line because
    your line of code was so long.
  prefs: []
  type: TYPE_NORMAL
- en: Next, your Bash script checks to see if any load problems are listed in the
    *load_weather.log* file ❺. In an `if` statement, `-s` checks to see if the file
    size is greater than 0 bytes. You only want to load the data into your final table,
    `current_weather`, if there were no problems loading the data into your load table,
    `current_weather_load`. In other words, you’ll only copy the data to the `current_weather`
    table when the *load_weather.log* file is empty, or 0 bytes. You check that the
    logfile doesn’t have a size greater than 0 using the syntax `if [ ! -s load_weather.log
    ]`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last line of the *weather.sh* Bash script, you rename the *weather.csv*
    file, adding the current date and time as a suffix. For example, you’ll rename
    *weather.csv* to *weather.csv.20240412210125* so that the next time your Bash
    script is run, it won’t try to reload the same *weather.csv* file ❻. The `mv`
    command stands for *move*, and is used to rename or move files to another directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s check out the results. If you are sent a *weather.csv* data file with
    valid data, running the *load_weather.sql* script will result in the `current_weather_load`
    table getting populated with values. This should look similar to [Figure 16-3](#figure16-3).
  prefs: []
  type: TYPE_NORMAL
- en: The data in your `current_weather_load` table looks good. All 11 rows that were
    in the CSV data file are now in the table, and the values look reasonable for
    all of your columns.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you’re sent a *weather.csv* data file with duplicate values,
    or with values that are in the wrong format or out of range, the result of running
    the *load_weather.sql* script will be that your *load_weather.log* file will contain
    a list of the problems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c16/f16003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-3: The `current_weather_load` table'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you got valid data and *copy_weather.sql* ran, the `current_weather`
    table should match [Figure 16-3](#figure16-3).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll create the schedule to run this Bash script using cron.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling the Bash Script on cron
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the command `crontab -e`, create the following crontab entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `*/5` in the `minutes` column tells cron to run this job every 5 minutes.
    You can use the wildcard (`*`) character for all the other values (hour, day of
    month, month, and day of week, respectively), since you want the script to run
    for all hours, months, days, and days of the week. [Figure 16-4](#figure16-4)
    shows what each piece of the crontab entry means.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c16/f16004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-4: Scheduling *weather.sh* on cron to run every 5 minutes'
  prefs: []
  type: TYPE_NORMAL
- en: You then save the crontab file and exit the text editor that was launched by
    the `crontab -e` command.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the saying goes, there are many ways to skin a cat. Likewise, there are many
    other ways you could have approached this project using what you’ve learned so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: You could have loaded the data from the CSV file directly to the final `current_weather`
    table, but using an interim load table enables you to correct any data issues
    behind the scenes without affecting user-facing data. If the CSV file comes to
    you with data problems like duplicate records, incorrectly formatted column values,
    or out-of-range values, your load into the `current_weather_load` table will fail.
    While you work with the CSV file supplier to get a corrected file, your application
    will continue using the existing data in the `current_weather` table and your
    users won’t be affected (though the weather data they see won’t be as up to date
    as it normally would be).
  prefs: []
  type: TYPE_NORMAL
- en: If your weather data provider had an *application programming interface (API)*
    available, you could have received this weather data from an API rather than loading
    a CSV data file. An API is another way to exchange data between two systems, but
    an in-depth discussion is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: You created a primary key and several other constraints on your `current_weather_load`
    table. You wouldn’t do this in cases where you need to load a large number of
    records from a file into a table. For performance reasons, you’d choose to load
    the data into a table that has no constraints. As each row is being written into
    the table, MySQL needs to check that the constraints aren’t being violated, which
    takes time. In your weather project, however, there were only 11 rows being loaded,
    so the load time was almost instantaneous even with the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: You could have added a line of code to the Bash script, *weather.sh*, to have
    it notify you and the data provider by email or text whenever there’s a problem
    loading the data. This wasn’t included in the project because it requires a bit
    of setup. To learn more, use the `man` command to look up the `mailx`, `mail`,
    or `sendmail` commands (for example, `man mailx`).
  prefs: []
  type: TYPE_NORMAL
- en: Also, your database credentials are hardcoded in your *weather.sh* Bash script
    so that the script can call the MySQL command line client. When you load the data,
    MySQL gives you the warning `Using a password on the command line interface can
    be insecure`. It would be worth restructuring the code so that it hides your database
    user ID and password or using the `mysql_config_editor` utility shown in [Chapter
    14](c14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you scheduled a cron job to execute a Bash script that checks
    for the arrival of a CSV data file containing current weather data. When the file
    arrived, you loaded it into your MySQL database. You also checked for problems
    loading the data and, once it loaded cleanly, transferred the data to your final
    weather table.
  prefs: []
  type: TYPE_NORMAL
- en: In the next project, you’ll use triggers to track changes to voter data in a
    MySQL database.*
  prefs: []
  type: TYPE_NORMAL
