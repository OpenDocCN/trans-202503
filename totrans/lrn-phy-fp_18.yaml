- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MECHANICS IN THREE DIMENSIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To predict the motion of a projectile, a satellite, or any object that can move
    unconstrained through three-dimensional space, we need to use three-dimensional
    vectors to describe velocity, acceleration, and force. In this chapter, we’ll
    merge the three-dimensional vectors we described in [Chapter 10](ch10.xhtml) with
    the state-based solution techniques of [Chapter 15](ch15.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Describing the state of an object or particle remains central to our task of
    predicting its future motion. We’ll develop an appropriate set of state variables
    for a particle in three dimensions and define a new type called `ParticleState`
    to hold them.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledging the dependence that forces have on state variables, we assign
    the name *one-body force* to a function that returns a force vector when presented
    with a particle state. We give multiple examples of one-body forces, such as Earth’s
    surface gravity and air resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a mechanics problem is a process of transforming information through
    a sequence of representations, beginning with a list of one-body forces, then
    a differential equation, then a state-update function, and finally a list of states.
    Newton’s second law appears as the transformation from forces to differential
    equation. A numerical method transforms a differential equation into a state-update
    function. Iteration of the state-update function from an initial state produces
    a list of states.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores the foundational ideas and code that allow us to predict
    motion by transforming information through a sequence of representations. Let’s
    start with some introductory code.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter and the next two, we’ll create a module that contains ideas
    for setting up and solving Newton’s second law in three dimensions. Before we
    start adding type signatures and function definitions, there’s some code we need
    to have at the top of our source code file. This introductory code consists of
    four parts: a request for warnings, a request to use a language option, a name
    for the module, and a collection of types and functions we wish to import from
    other modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we begin by turning on warnings. We then turn on the language option
    that allows multi-parameter type classes, just as we did in the last chapter.
    We give this module the name `Mechanics3D`, which is how we will refer to it when
    we use any of the types or functions we define in this module in stand-alone programs
    or in other modules we write in later chapters. The remainder of the code consists
    of import statements, indicating that we wish to use types, type classes, and
    functions defined in modules that other people have written, or those defined
    in modules that we wrote in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we import vector operations from the `SimpleVec` module we wrote
    in [Chapter 10](ch10.xhtml) and some differential equation solving types, type
    classes, and functions from the `Mechanics1D` module we wrote in [Chapter 15](ch15.xhtml).
    We’ve listed the name of each piece we’re importing from the `SimpleVec` and `Mechanics1D`
    modules, as opposed to simply importing the module as a whole. This is my preferred
    style because it shows where each of the names we use in the module comes from.
    If you want to import all of the names, you can write a one-line import statement
    composed of the keyword `import` followed by the module name, as we did in [Chapter
    15](ch15.xhtml). If you import all of the names from many different modules, one
    of the names that you use may be defined in multiple modules, causing the compiler
    to complain. You will then need to clarify which module you want the name imported
    from.
  prefs: []
  type: TYPE_NORMAL
- en: The parenthetical with two dots, `(..)`, after a data type like `Attribute`
    means we want to import the data type and all of its constructors. If we omit
    the two dots, we will only import the name of the data type. Two dots after a
    type class, such as `RealVectorSpace`, mean we want to import the functions owned
    by the type class in addition to the name of the type class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the qualified import of the `Graphics.Gloss` and `Vis` modules.
    The first qualified import statement assigns the short name `G` to the `Graphics.Gloss`
    module, allowing us to access any type or function provided by `Graphics.Gloss`
    as long as it’s prefixed by the short name `G` and a dot. The `Picture` type from
    the `Graphics.Gloss` module, for example, must be referred to as `G.Picture`.
    One reason I chose the qualified import method for the `Graphics.Gloss` and `Vis`
    modules is that they define several identical names, such as `simulate`. I want
    to use both definitions of `simulate` in the code I write, and I need a way of
    telling the compiler which definition I mean in each use.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed our introductory code, let’s look at Newton’s second law in
    three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s Second Law in Three Dimensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Equation 14.1 gave Newton’s second law in one dimension. In three dimensions,
    position, velocity, acceleration, and force are described by vectors rather than
    numbers. In three dimensions, the net force on an object is the vector sum of
    the forces acting on that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/281equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is Newton’s second law in three dimensions as a differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/281equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 16-1](ch16.xhtml#ch16fig1) shows a schematic diagram for Newton’s second
    law in three dimensions. Since acceleration, velocity, and position are being
    treated as vectors now, two of the integrators have vector inputs, vector outputs,
    and vector state.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/282fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Schematic representation of Newton’s second law*'
  prefs: []
  type: TYPE_NORMAL
- en: Here the forces depend on time, position, and velocity. Acceleration depends
    on net force. Velocity is the integration of acceleration, and position is the
    integration of velocity. The type below each integrator indicates the type of
    quantity that the integrator holds as state. The integrator that outputs time
    holds a real number as state. The integrator that outputs position holds a vector
    as state. The integrator that outputs velocity also holds a vector as state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two integrators in loops in the diagram hold velocity and position as state,
    so at a minimum, we need velocity and position to be state variables. We included
    time as a state variable for convenience in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    and we will continue to do so here. Writing Newton’s second law as a set of coupled
    first-order differential equations gives the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/282equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Equations 16.3, 16.4, and 16.5 contain information equivalent to the diagram
    in [Figure 16-1](ch16.xhtml#ch16fig1).
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced Newton’s second law in three dimensions, let’s now turn to
    the question of how we will describe the state of a particle in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The State of One Particle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The state of a particle plays five roles. First, the state specifies the information
    necessary for prediction; it’s the current information about the system that allows
    future prediction without historical information about the system (information
    from the past). Second, the state gives a template for the first-order differential
    Equations 16.3, 16.4, and 16.5 that form the starting point for our numerical
    approximation methods; each first-order differential equation expresses the time
    rate of change of one of the state variables in terms of the state variables themselves.
    Third, the state describes the information that needs to be updated by a state-update
    function. Fourth, the state encompasses the information that the forces depend
    on. Finally, knowing the state at all times counts as a solution to a Newton’s
    second law problem because anything we want to know about a particle is some function
    of its state.
  prefs: []
  type: TYPE_NORMAL
- en: Since the forces that act on a particle can depend on the particle’s mass (such
    as the force of gravity) or charge (such as the Lorentz force law, which we’ll
    discuss later in the chapter), it’s convenient to include mass and charge in the
    state. However, its certainly not necessary; mass and charge remain constant throughout
    most physical situations, so we could treat them as global values independent
    of state. But including mass and charge as state variables will simplify some
    of our code and allow some forces to be expressed as functions of state only instead
    of as functions of state and one or more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `ParticleState` data type we’ll use for the state of one
    particle includes mass, charge, time, position, and velocity as state variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use record syntax to give each field of the new data type its own extraction
    function (`mass`, `charge`, and so on). An extraction function is also called
    an eliminator or selector. We decided to make a new data type (using the `data`
    keyword) rather than a type synonym so that this type has no chance of being confused
    with any other type. We want to be able to display values of this data type, so
    we want `ParticleState` to be an instance of type class `Show`. By including `deriving
    Show`, we ask that the compiler automatically figure out how to make a `Show`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, let’s define a default `ParticleState`, which can be used to
    make new particle states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defaultParticleState` allows us to define a particle state without needing
    to explicitly provide all five pieces of information. For example, to specify
    the state of a 2-kg rock with no net charge, at the origin, moving with velocity
    ![Image](Images/e0284-01.jpg) m/s, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we have the default state, we don’t need to explicitly give state variables
    that are the same as those of the default, such as charge, time, and position.
    Recall that the operator `*^` is used to scale a vector on the right by a number
    on the left.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s second law is a recipe for constructing a differential equation from
    a list of force functions. Throughout [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    we saw the usefulness of force functions in which the force depends on the state
    of the particle. We’ll define a *one-body force* to be a force that depends on
    the current particle state as expressed by `ParticleState`; in other words, a
    force that could depend on time or the particle’s position, velocity, mass, or
    charge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll see in the following section that many common forces in mechanics are
    naturally expressed as one-body forces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we write below for Newton’s second law will produce a differential
    equation. In other words, it will produce a function that gives the time derivatives
    of state variables when presented with the state variables themselves. How should
    we return these time derivatives of state variables? Since the state variables
    are bundled together into an object with type `ParticleState`, we will similarly
    bundle together the time derivatives into an object with type `DParticleState`.
    Here is our definition of the new data type `DParticleState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As there are five quantities contained in the particle state, so there are five
    quantities in the state derivative. The real number whose extraction function
    is `dmdt` (named after the derivative *dm*/*dt*) holds the rate at which mass
    changes. Mass will not change in any of our examples, so this rate will be zero,
    but the ability to have mass change is useful in some situations, such as rocket
    motion (in which a rocket expends fuel). Each of the other extraction functions
    has a name designed to indicate that the quantity represents the rate of change
    of a state variable. The names `dqdt` and `dtdt` label the real numbers for the
    rates at which charge and time change with time, respectively. The rate at which
    time changes with time is 1, so it’s a little silly to keep track of this rate.
    An alternative is to write a data type that omits this quantity; I have chosen
    a data type whose structure parallels that of the state, even if some slots hold
    information that seems obvious. The names `drdt` and `dvdt` label the rates at
    which position and velocity change. These quantities are vectors, as the data
    type definition shows.
  prefs: []
  type: TYPE_NORMAL
- en: The function `newtonSecondPS` below is the Haskell representation of Newton’s
    second law, which is equivalent to differential Equations 16.3, 16.4, and 16.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function `newtonSecondPS` is a recipe for converting a list of one-body
    forces into a differential equation. The PS in the name indicates that the function
    works with the `ParticleState` data type. The differential equation produced by
    `newtonSecondPS` expresses the time rate of change of each of the state variables
    in terms of the state variables themselves. Given values for each of the five
    state variables, the function `newtonSecondPS` returns values for the time rate
    of change of each of these five.
  prefs: []
  type: TYPE_NORMAL
- en: The function `newtonSecondPS` consists of a `let` expression, in which we first
    find the `Vec` representing the net force on the particle in the current state,
    name it `fNet`, then name the mass and velocity of the particle `m` and `v`, respectively,
    and finally compute the acceleration of the particle by dividing the net force
    by the mass. The body of the `let` expression returns a state derivative with
    type `DParticleState`. The derivatives of mass and charge with respect to time
    are 0 because mass and charge do not change. The derivative of time with respect
    to time is 1\. Finally, the derivative of position is the velocity in the current
    state, and the derivative of velocity is the acceleration calculated in the `let`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: We regard the function `newtonSecondPS fs`, where `fs` is the list of one-body
    forces that describes the physical situation, as the Haskell version of the differential
    equation that expresses Newton’s second law. The schematic diagram in [Figure
    16-1](ch16.xhtml#ch16fig1), the differential Equations 16.3, 16.4, and 16.5, and
    the Haskell function `newtonSecondPS` are different ways of expressing Newton’s
    second law for a single object in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Newton’s Second Law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our strategy for constructing and solving Newton’s second law for one particle
    consists of transforming information about the physical situation through a sequence
    of four different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: One-body forces
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differential equation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State-update function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List of states
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) shows a functional diagram of the data representations,
    shown as vertical arrows, and the functions that transform the data from one representation
    to another, shown as boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/286fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: Data flow for solving a one-particle mechanics problem*'
  prefs: []
  type: TYPE_NORMAL
- en: A list of one-body forces is the first in a sequence of four information representations
    we use to describe a physical situation, each getting closer to a solution. The
    list of one-body forces characterizes the physical setting or situation in which
    a particle finds itself, serving as an algebraic analogue to the visual and geometric
    free-body diagrams that introductory physics classes use to show all of the forces
    acting on an object.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s second law provides the means to transform the one-body forces into
    a differential equation, our second information representation. The function `newtonSecondPS`
    expresses Newton’s second law as it applies to the `ParticleState` data type.
    The Haskell representation of a differential equation is a function `ParticleState
    -> DParticleState` that gives the time rates of change of the state variables
    in terms of the state variables themselves.
  prefs: []
  type: TYPE_NORMAL
- en: A state-update function is our third information representation; it describes
    how to take a small step forward in time, producing a new state from an old state.
    The two-and three-dimensional animation tools we use take a state-update function
    as input; inasmuch as an animated visualization of a particle’s motion counts
    as a solution to a mechanics problem, the state-update function at the heart of
    that animation can also be regarded as a solution. To obtain a state-update function
    from a differential equation, we need a numerical method. By using a numerical
    method, we admit that we’re looking only for an approximate solution to our mechanics
    problem rather than an exact solution as can sometimes be found by working with
    a differential equation analytically. We have a choice of numerical methods; `euler
    0.01`, `eulerCromerPS 0.1`, and `rungeKutta4 0.1` will be examples of numerical
    methods that can be used to produce a state-update function. We’ll write the function
    `eulerCromerPS` later in this chapter, and we’ll also show how to make use of
    the general-purpose functions `euler` and `rungeKutta4` that we wrote in the last
    chapter. Having chosen a numerical method, we apply it to the differential equation
    to obtain a state-update function.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth information representation we use is a list of states. The list gives
    the state of the particle at each time calculated by the numerical method; in
    other words, each list element is the state at a particular time that is one time
    step advanced from that of the previous list element. This is pretty much all
    the information we could hope to know about the particle. From it, we can graph
    any state variable as a function of time or some other state variable.
  prefs: []
  type: TYPE_NORMAL
- en: Other quantities we might care about, but that are not contained in the state,
    such as energy or momentum, are functions of the state variables. If we wish,
    we can write a higher-order function that produces a position function or a velocity
    function for the particle from the information contained in the list of states.
    To obtain the list of states from the state-update function, we simply iterate
    the state-update function using the Prelude function `iterate`, which applies
    the state-update function to a given initial state and then to the updated state
    over and over again to make a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) should be regarded as an overview of the
    process of solving a one-particle mechanics problem in three dimensions. The figure
    is similar to [Figure 15-2](ch15.xhtml#ch15fig2); the two main differences are
    (1) we’re using the new `ParticleState` data type, which contains mass, and (2)
    the new figure allows a choice of numerical method where the previous figure insisted
    on the Euler method.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the broad outline of our process is to translate our problem (given
    by one-body forces) into something mathematical (a differential equation), solve
    the mathematics problem (by using a numerical method to produce a state-update
    function and iterating to produce a list of states), and then return to physics
    to interpret the results.
  prefs: []
  type: TYPE_NORMAL
- en: Having given an overview of the process we’ll employ to solve Newton’s second
    law, which begins with a list of one-body forces, let’s take a look at some examples
    of one-body forces.
  prefs: []
  type: TYPE_NORMAL
- en: One-Body Forces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduced the definition of a one-body force earlier in this chapter, but
    we did not give any examples. Many of the common forces that we may want to include
    in Newton’s second law are naturally expressed as one-body forces.
  prefs: []
  type: TYPE_NORMAL
- en: Earth Surface Gravity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An object near Earth’s surface feels a gravitational force from the earth. (This
    is theory 2 from the list of gravity theories on [page 148](ch10.xhtml#ch10lev19).)
    If **g** is the acceleration of gravity that points toward the center of the earth,
    the gravitational force exerted by Earth on a particle or object with mass *m*
    that is near Earth’s surface is
  prefs: []
  type: TYPE_NORMAL
- en: '**F**[*g*] = *m***g**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we agree to let the z-direction of our coordinate system point away from
    Earth’s center, and to use SI units, then a one-body force for Earth surface gravity
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Recall that a one-body force is a function from particle state to force vector.
    The local variable `st` holds the particle state, and `mass st` extracts the mass
    from the particle state using the extraction function `mass` that is automatically
    generated because we used record syntax when we defined `ParticleState`.
  prefs: []
  type: TYPE_NORMAL
- en: If Earth’s surface gravity is a force that acts on our particle, all we need
    to do is include `earthSurfaceGravity` in the list of one-body forces that forms
    the input to `newtonSecondPS`. The appropriate mass will be taken from the state,
    and the force of gravity will be included in Newton’s second law.
  prefs: []
  type: TYPE_NORMAL
- en: Gravity Produced by the Sun
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any object with mass exerts a gravitational force on any other object with mass.
    (This is theory 3 from the list of gravity theories on [page 148](ch10.xhtml#ch10lev19).)
    If the objects are spherical in shape, the force exerted by one object on another
    is directly proportional to the mass of each object and inversely proportional
    to the square of the distance between their centers. This is the content of Newton’s
    law of universal gravity, which we will discuss in more detail in [Chapter 19](ch19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our solar system, there are many examples of pairs of objects with one much
    more massive than the other, such as sun/Earth, Earth/moon, and Earth/telecommunications
    satellite. If we want to understand Earth’s motion as it moves through the solar
    system, it is a good approximation to suppose two things: one, that the gravitational
    attraction of other planets such as Mars, Venus, and Jupiter have a very small
    effect on Earth, and can therefore be ignored; and two, that the sun is so massive
    compared to Earth that its position can be taken to be fixed. Under these approximations,
    the universal gravity produced by the sun can be regarded as a one-body force
    acting on Earth (or on Mars, Venus, Halley’s comet, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: The gravitational force exerted by the sun on an object or particle with mass
    *m* is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/289equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *G* is Newton’s gravitational constant (in SI units, *G* = 6.67408 × 10–^(11)
    N m²/kg²), *M[s]* is the mass of the sun (*M[s]* = 1.98848 × 10^(30) kg), *r*
    is the distance between the center of the sun and the center of the object, and
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/289equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is a unit vector pointing from the sun toward the object. The minus sign implies
    that the force on the object is toward the sun. A one-body force for sun gravity
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we use pattern matching on the input to extract the state variables instead
    of the extraction function we used for the previous one-body force of Earth surface
    gravity. Instead of naming the particle state with a local variable like `st`,
    we match the pattern of a particle state using the `ParticleState` constructor.
    We assign the five local variables that follow the constructor the values mass,
    charge, time, position, and velocity, respectively. We don’t need charge, time,
    or velocity to compute the gravitational force that the sun exerts, so they are
    preceded by underscores. (We could have used *only* the underscore for any or
    all of the unused variables, but providing a name after the underscore reminds
    us of exactly what is being ignored.) The choice of whether to use extraction
    functions or pattern matching to get the state variables out of the state is a
    matter of style, and you can use whatever you like best.
  prefs: []
  type: TYPE_NORMAL
- en: If we are interested in the motion of the moon around the earth, we can express
    Earth’s universal gravity as a one-body force that acts on the moon. Exercise
    16.4 asks you to write a one-body force for the universal gravity produced by
    Earth. If, on the other hand, we are interested in the motion of the moon through
    the solar system, then gravity from both the sun and Earth is important, and it’s
    better to use the techniques of [Chapter 19](ch19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Air Resistance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Air resistance is a one-body force that depends on the velocity of the object
    moving through the air. We assume that the air is still with respect to our coordinate
    system. In [Chapter 14](ch14.xhtml), we developed an expression for air resistance
    that we applied in one-dimensional situations. In three-dimensional situations,
    velocity is a vector, and the force of air resistance appears as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/290equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with the parameters *C*, *ρ*, and *A* still representing the drag coefficient,
    the density of the air, and the cross-sectional area of the object, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Haskell code for the one-body force that corresponds to Equation
    16.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are using pattern matching on the input when we name the incoming particle
    state `ParticleState _m _q _t _r v`. The force depends only on the velocity, so
    the velocity is the only state variable that needs to be named.
  prefs: []
  type: TYPE_NORMAL
- en: For any situation in which we want to include air resistance, we need to estimate
    a drag coefficient, determine the cross-sectional area of our object, and determine
    an appropriate value for the density of air. At a reasonable temperature and pressure
    near Earth’s surface, the density of air is about 1.225 kg/m³. If, for example,
    0.8 was our drag coefficient and 0.003 m² was the cross-sectional area of our
    object, then including
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: in the list of one-body forces for `newtonSecondPS` would include the force
    of air resistance in Newton’s second law.
  prefs: []
  type: TYPE_NORMAL
- en: If we were going to do a lot of air resistance problems, we might put the cross-sectional
    area of the object into the state since it’s clearly a property of the object.
    We might even consider putting the drag coefficient into the state, if that can
    be regarded as a property of the object rather than a property of the interaction
    between the object and the air. We won’t make these modifications to our state
    data type; instead, we’ll stick with our `ParticleState`, and when forces depend
    on parameters that are not included in the state, we’ll just handle it on a case-by-case
    basis, as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: Wind Force
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The one-body force of air resistance just considered assumes that the air is
    motionless with respect to our coordinate system. The one-body wind force we consider
    in this section is a generalization of air resistance in that the air moves at
    some constant velocity with respect to our coordinate system. We can use our air
    resistance formula to find the wind force, but the appropriate velocity to use
    is the *relative velocity* between the object and the wind. If **v** is the velocity
    of the object with respect to our coordinate system, and **v**[wind] is the velocity
    of the air with respect to our coordinate system, then **v** – **v**[wind] is
    the velocity of the object with respect to the air. The wind force can be expressed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/291equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the corresponding Haskell code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code for wind force is similar to the code for air resistance. Exercise
    17.5 gives an opportunity to try out this force. Notice that if the wind velocity
    is chosen to be 0, the wind force becomes the force of air resistance we treated
    in the previous section. Air resistance is the force that stationary air exerts
    on an object, while wind force is the force that moving air exerts on an object.
    If the force of air is important in a situation, you’ll want air resistance or
    the wind force, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: Force from Uniform Electric and Magnetic Fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We haven’t talked about electric or magnetic fields yet, but we will in [Part
    III](part03.xhtml) of the book. For now, the important things to know are that
    these fields are produced by electric charge and that a particle experiences a
    force in the presence of electric and/or magnetic fields. When these fields are
    *uniform*, meaning the same at different places in space, a single vector describes
    the electric field and a single vector describes the magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that **E** is a uniform electric field vector and **B** is a uniform
    magnetic field vector. These fields exert a force on a charged particle traveling
    through them, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0292-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *q* is the electric charge of the particle and **v**(*t*) is the velocity
    of the particle. This equation is called the *Lorentz force law*, and we will
    study it in more detail when we turn to electromagnetic theory, including the
    more general situation in which the fields need not be uniform. Here is the corresponding
    Haskell code for the one-body force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `uniformLorentzForce` has type `Vec -> Vec -> OneBodyForce`, which
    is the same as `Vec -> Vec -> ParticleState -> Vec`. Given a vector `vE :: Vec`
    for the electric field, a vector `vB :: Vec` for the magnetic field, and a particle
    state `ParticleState _m q _t _r v :: ParticleState` using pattern matching on
    the input, the function returns a force vector by applying the Lorentz force law
    (Equation 16.8). The charge and velocity of the particle are the state variables
    needed to compute this electromagnetic force.'
  prefs: []
  type: TYPE_NORMAL
- en: Having seen several examples of one-body forces, let’s continue along [Figure
    16-2](ch16.xhtml#ch16fig2) and explore the state-update process.
  prefs: []
  type: TYPE_NORMAL
- en: State Update for One Particle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A numerical method transforms a differential equation into a state-update function.
    The Euler-Cromer method is a numerical method, and because it’s not a general-purpose
    numerical method, we need to write a new function for it for each state data type
    we want to use. Here is the Euler-Cromer function for the `ParticleState` data
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we saw with the Euler-Cromer method in the last chapter, the key difference
    compared with the Euler method is that it uses an updated velocity to update position.
    The update equations in `eulerCromerPS` are almost identical to those in `eulerCromer1D`
    of the previous chapter, with the one difference being that we are now working
    with vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The Euler and fourth-order Runge-Kutta methods are general-purpose methods for
    solving any differential equation. In [Chapter 15](ch15.xhtml), we wrote the `euler`
    and `rungeKutta4` functions, which can work with any differential equation and
    any state type. To use them with the `ParticleState` data type, we must write
    a `RealVectorSpace` instance for `DParticleState` and a `Diff` instance relating
    the `ParticleState` and `DParticleState` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `RealVectorSpace` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this instance declaration, we define addition to be item-wise addition for
    each item, and we define scalar multiplication to be item-wise scaling for each
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Diff` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each item in the state is shifted by the product of its derivative with the
    time step.
  prefs: []
  type: TYPE_NORMAL
- en: Having made these instance declarations, we now have access to the functions
    `euler` and `rungeKutta4` we wrote in the previous chapter. We can use any of
    the three numerical methods, Euler, Euler-Cromer, or fourth-order Runge-Kutta,
    to produce a state-update function from a differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) showed the four data representations we
    use to solve a mechanics problem and three functions that transform from one data
    representation to another. Compositions of these three functions are important
    enough to name and are shown as arrows on the sides of [Figure 16-3](ch16.xhtml#ch16fig3).
    We wrote `solver` in the last chapter and will write `updatePS` and `statesPS`
    shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/294fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: Data representations and functions that transform among them*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) again shows the four data representations,
    with one small change. Where [Figure 16-2](ch16.xhtml#ch16fig2) has a list of
    states as the final representation, [Figure 16-3](ch16.xhtml#ch16fig3) has a function
    from initial state to list of states, which we call an *evolver*. The reason for
    this change is that we want to view each representation in [Figure 16-3](ch16.xhtml#ch16fig3)
    as the result of applying a single function to the single input consisting of
    the previous representation. In other words, where the initial state appears as
    an input in [Figure 16-2](ch16.xhtml#ch16fig2), it is part of the type of the
    evolver in [Figure 16-3](ch16.xhtml#ch16fig3). To transform between adjacent representations
    in [Figure 16-3](ch16.xhtml#ch16fig3), we apply Newton’s second law, then a numerical
    method, and then iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a function `statesPS` that produces all three transformations of
    [Figure 16-3](ch16.xhtml#ch16fig3) by producing the differential equation from
    the forces, using a numerical method to turn the differential equation into a
    state-update function, and iterating the state-update function to produce an evolver.
    The inputs to this function will be a numerical method and a list of one-body
    forces. The output will be an evolver that can act on an initial state to produce
    an infinite list of states. We call this function `statesPS` because it produces
    a list of states when supplied with an initial state and is for the `ParticleState`
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The local variable `method` stands for the numerical method we provide when
    we use `statesPS`. We see from the definition that this function is a composition
    of three functions, as suggested by [Figure 16-3](ch16.xhtml#ch16fig3). Recall
    that numerical methods are things like `euler 0.01`, `eulerCromerPS 0.1`, and
    `rungeKutta4` `0.1`. Notice that the function `newtonSecondPS`, which transforms
    forces into a differential equation, can be used with any numerical method.
  prefs: []
  type: TYPE_NORMAL
- en: It is similarly useful, especially for animation, to name the function that
    transforms from a list of forces to a state-update function. We’ll call this function
    `updatePS`, and we see from its definition that it is simply the composition of
    Newton’s second law with a numerical method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) demonstrates how this function fits into
    the sequence of data representations.'
  prefs: []
  type: TYPE_NORMAL
- en: The final composition of transformations we might want to make is expressed
    by the function `solver` we wrote in the previous chapter. Unlike `statesPS` and
    `updatePS`, which require the `ParticleState` data type, the function `solver`
    works with any data type (any state space). If you look back on its definition,
    you will see that it is just the composition of a numerical method with iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in a wonderful position. All we need to do to solve any one-body
    problem in mechanics is give the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: A numerical method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of one-body forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body’s initial state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer will then calculate a list of states, which we can use to find
    quantities like position and velocity at arbitrary times.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together, we can write a function `positionPS`, similar to
    `positionFtxv` and others we have written before, that takes the three pieces
    of information listed above and produces a function that gives the position of
    the object at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The function begins by naming the incoming numerical method `method`, the list
    of one-body forces `fs`, the initial particle state `st`, and the time `t`. The
    first line in the `let` clause uses `statesPS` to create an infinite list of particle
    states based on the numerical method, forces, and initial particle state given.
    The second line calculates the time step by subtracting the times of the first
    and second states in the list. The third line finds the number of time steps necessary
    to get as close as possible to the desired time `t`. The fourth line picks out
    the state that is closest to the desired time, and the body of the `let` construction,
    after the `in` keyword, uses the extraction function `posVec` to pick out the
    position from the state.
  prefs: []
  type: TYPE_NORMAL
- en: Having written functions that allow us to solve any one-body mechanics problem
    using the numerical method of our choice, let’s turn our attention to some last
    details about animation.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 13](ch13.xhtml), we discussed how to make 2D and 3D animations with
    the `Graphics.Gloss` and `Vis` modules. Remember that each module has a `simulate`
    function, but the two functions are not parallel in terms of the inputs they require.
    In this section, we’ll ease future strain on our brains by creating two new functions,
    `simulateGloss` and `simulateVis`, that take very similar inputs to each other,
    so we can switch from 2D animation to 3D and back without having to remember all
    of the details about how the `gloss` `simulate` function differs from the `not-gloss`
    `simulate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Two Helpful Animation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each of the functions `simulateGloss` and `simulateVis` calls its own version
    of `simulate` to do the actual work. The intention is that we use these new functions
    instead of either version of `simulate`. We’ll briefly explain how `simulate`
    `Gloss` and `simulateVis` work; however, unlike many of the Haskell functions
    in this book, the point of writing these functions is not to illustrate important
    or beautiful ideas about physics or programming. Instead, the point is to make
    animation easier. We are willing to pay the cost of writing these functions once
    because we’ll then enjoy the benefit of being able to use them again and again
    to make animations in a more convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: It’s more important to understand how to use these functions than it is to understand
    how they work. If you want to skip the definitions and the explanation of how
    the functions work, it will not cause you trouble later. However, do pay attention
    to the types of these two new functions and the inputs that must be provided for
    them to do their job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the type signatures and function definitions for `simulateGloss` and
    `simulateVis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `simulateGloss` function makes a 2D animation, while `simulateVis` makes
    a 3D animation. Each function takes five inputs. The meaning and order of the
    inputs are the same in both functions, even though one of the five inputs has
    a different type in `simulateGloss` than it has in `simulateVis`. Let’s discuss
    the meaning and purpose of each of the five inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Time-Scale Factor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first input to `simulateGloss` and `simulateVis`, `tsFactor`, says how fast
    we want the animation to run compared with physical evolution. There will be times
    when we want the animation to run faster or slower than the corresponding physical
    situation evolves. For example, it takes the moon about a month to orbit Earth,
    but we might want an animation in which the moon makes a full cycle in six seconds.
    We’re almost always going to want an animation that happens in seconds or minutes.
    Smaller than that and it’s too rapid to see; larger than that and we lose patience.
  prefs: []
  type: TYPE_NORMAL
- en: We can distinguish between two forms of time. *Physical time* is the time for
    some process to occur in the physical world. The physical time for one period
    of the moon orbiting Earth is one month. *Animation time* is the time for some
    process to occur in a computer animation. The animation time for one period of
    the moon orbiting Earth is six seconds in our example.
  prefs: []
  type: TYPE_NORMAL
- en: To allow a difference between physical time and animation time, our `simulateGloss`
    and `simulateVis` functions take a *time-scale factor* as their first input, hence
    the name `tsFactor`. The time-scale factor is the ratio of physical time to animation
    time. For the moon orbit example, where the physical time is much larger than
    the animation time, the time-scale factor is a number (much) bigger than 1\. A
    time-scale factor smaller than 1 should be used for a process that occurs very
    quickly in the physical world that we want to view in “slow motion” so we see
    interesting changes as they occur. By specifying a time-scale factor as the first
    input to `simulateGloss` or `simulateVis`, we are declaring how fast we want the
    animation to run compared with physical evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Rate
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *animation rate*, called `rate` in the code shown earlier, is the number
    of picture frames displayed per second of animation time, and it’s the second
    input to `simulateGloss` and `simulateVis`. Because a new picture frame is generated
    every time the state-update function is called to produce a new state, the animation
    rate is also the number of state updates per second of animation time.
  prefs: []
  type: TYPE_NORMAL
- en: There is a relationship between the time-scale factor, the animation rate, and
    the time step. If we let *α* denote the time-scale factor, *r* the animation rate,
    and Δ*t[p]* the time step (which is a physical time, hence subscript p), the relationship
    is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/298fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Only two of these can be chosen independently. Since the time step is a physical
    time, and since we are likely to be interested in situations with physical time
    scales ranging from nanoseconds to years, it’s convenient to tell `simulateGloss`
    or `simulateVis` the time-scale factor and the animation rate and let them calculate
    the time step to be used for state update. This way, if we choose a sensible time-scale
    factor, we can pick something like 20 frames/second for the animation rate and
    we’ll have a decent chance of using a reasonable time step. If we find we need
    a smaller time step, we can increase the animation rate (as we do in the next
    chapter for Halley’s comet).
  prefs: []
  type: TYPE_NORMAL
- en: Initial State
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The third input is the initial state of the particle or system we wish to animate,
    `initialState`. In this chapter, the state of a particle has the type `ParticleState`.
    In the previous chapter, the state of a particle in one dimension had type `State1D`.
    In [Chapter 19](ch19.xhtml), the state of a system of particles will have type
    `MultiParticleState`. Our two animation functions can work with any of these,
    as indicated by the type variable `s` used for the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Display Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The fourth input, `picFunc`, is a display function that must explain what 2D
    or 3D picture to make for a given state. Since `gloss` uses the `Picture` type
    for a picture and `not-gloss` uses the `VisObject R` type, this fourth input has
    a different type in `simulateGloss` than in `simulateVis`. When we want to produce
    an animation for a specific physical situation, we’ll need to write a display
    function for that situation. The `not-gloss` package has its own type for three-dimensional
    vectors, which differs from the `Vec` type we have been using. Since there is
    a three-dimensional translation function called `Trans` that takes a `not-gloss`
    vector as input, it will be useful to have a conversion function around when we
    write the display function for a 3D animation. The function `v3FromVec` produces
    a `not-gloss` vector from a `Vec`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this function in the 3D animations of projectile motion and of a proton
    in a magnetic field in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: State-Update Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The fifth and final input is a state-update function, `updateFunc`. State-update
    functions have been central to our method for solving Newton’s second law, even
    in the absence of animation. Notice that the type of the state-update function
    is `TimeStep -> s -> s`. This function must explain how to create a new state
    from an old state when given a time step. We are not choosing the time step here.
    Instead, we are specifying a function that takes a time step as input, along with
    an old state, and returns a new state. To obtain a state-update function, we can
    either apply a numerical method to a differential equation that comes from Newton’s
    second law or use the `updatePS` function we defined earlier with a numerical
    method and a list of one-body forces.
  prefs: []
  type: TYPE_NORMAL
- en: The five inputs just discussed—the time-scale factor, animation rate, initial
    state, display function, and state-update function—contain everything about the
    physical situation we’re modeling as well as all the information about how to
    produce a picture as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed the inputs to the functions `simulateGloss` and `simulateVis`
    to make 2D and 3D animations, let’s look at how the functions work.
  prefs: []
  type: TYPE_NORMAL
- en: How the Functions Work
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is easier to understand how the `simulateGloss` function works, so we’ll
    start with that one. The `simulateGloss` function names the five inputs, `tsFactor`
    for the time-scale factor, and so on. It calls `gloss`’s `simulate` function to
    do the actual work, passing six arguments to that function. The first argument
    to `simulate` specifies an empty window name, a window size in pixels, and a window
    location. Since these parameters are not so interesting, and since we are unlikely
    to want to change these values from animation to animation, we have picked some
    values that we hope will work once and for all. The second argument to `simulate`
    is a background color, which we choose to be black. The third, fourth, and fifth
    inputs are the animation rate, initial state, and display function. These are
    all inputs to `simulateGloss`, so they can simply be passed along to `gloss`’s
    `simulate`.
  prefs: []
  type: TYPE_NORMAL
- en: The final input required by `gloss`’s `simulate` is an update function, but
    it differs from the state-update function we have been working with in three ways.
    First, `gloss`’s `simulate` expects an update function whose first argument is
    a `ViewPort`, which we do not intend to use. To give a place for the viewport,
    we write an anonymous function that throws away its first argument. Second, `gloss`’s
    `simulate` expects an update function that works with animation time rather than
    physical time. Since our update functions work with physical time, we need to
    do a conversion here using the time-scale factor. Third, we need to convert `R`
    to `Float` using `realToFrac`. In summary, our `simulateGloss` function works
    by providing inputs to `gloss`’s `simulate` function from the inputs given to
    `simulateGloss`. Two of the inputs to `gloss`’s `simulate` are simply specified,
    three are passed unchanged from inputs to `simulateGloss`, and one is a modification
    of a `simulateGloss` input.
  prefs: []
  type: TYPE_NORMAL
- en: The `simulateVis` function gives the same names to its five inputs that `simulateGloss`
    uses because the inputs have the same meanings. It calls `not` `-gloss`’s `simulate`
    function to do the actual work, passing five arguments to that function. The first
    argument to `simulate` specifies some options, which we set, once and for all,
    to the default options. The second argument to `simulate` is the number of seconds
    per frame at which the animation should run. Since this is just the inverse of
    the animation rate, we can invert the `rate` after suitably changing its type
    from an integer to a real number. The third input is the initial state, which
    we pass along unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth input is the display function, which we could pass along unchanged,
    but we don’t because I want to take this opportunity to use the `orient` function,
    originally written in [Chapter 13](ch13.xhtml) and repeated below, to rotate the
    axes so that the y-axis points to the right, the z-axis points up the screen,
    and the x-axis points to the left and appears to extend out of the screen. In
    other words, I’m using `orient` so our animations will automatically use my favorite
    coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The fifth and final input required by `not-gloss`’s `simulate` is an update
    function; however, it differs substantially from the state-update function `updateFunc`
    that we have to work with. Because the difference is so substantial, we use a
    `let` construction to define a local function `visUpdateFunc` that we will pass
    as the final input to `not-gloss`’s `simulate` function. We name the first `visUpdateFunc`
    input `ta` as a reminder that it represents animation time. We name the second
    `visUpdateFunc` input `st` for state. Our strategy is to use the `updateFunc`
    passed to `simulateVis` to calculate the value of `visUpdateFunc ta st`, which
    has type `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between `visUpdateFunc` and `updateFunc` is all in how they
    interpret their first argument. The first input to `visUpdateFunc`, named `ta`,
    is the animation time elapsed since the beginning of the animation. In contrast,
    the first input to `updateFunc` is the physical time *step* since the previous
    state was calculated. Inside the local definition of `visUpdateFunc`, we have
    access to the animation time `ta` that we must use to calculate the physical time
    step `dtp` we will send to `updateFunc`. This conversion is more complicated than
    for `gloss` because we are really doing two conversions: one from animation time
    to physical time and one from physical time since the animation’s start to the
    physical time step. We use a nested `let` construction to define the local variable
    `dtp`, the physical time step we will send to `updateFunc` to produce the new
    state `visUpdateFunc ta st`. We calculate `dtp`, a real number with type `R`,
    by first converting the type of `ta` from `Float` to `R`, scaling this animation
    time by the time-scale factor to produce the physical time since the simulation
    began, and then subtracting the (physical) time of the old state. The physical
    time associated with state `st` is `timeOf st`. I explain how that works next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to know the time (which is one of the state variables in `Particle`
    `State`) of a state. This would be no problem if `simulateVis` was intended to
    work only with the `ParticleState` data type. But we want `simulateVis` to be
    able to work with any state space `s`, or at least any state space `s` that contains
    time as a state variable. To solve this problem, it seems we must invent a new
    type class, called `HasTime`, for types that represent states from which a particular
    value of time can be extracted. The type class owns just one function, `timeOf`,
    which pulls the time out of the state. Here is the definition of the type class
    `HasTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Each type that aspires to be an instance of `HasTime` must express how to implement
    `timeOf` through an instance declaration. Here is the instance declaration for
    `ParticleState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In summary, our `simulateVis` function works by providing inputs to `not` `-gloss`’s
    `simulate` function from the inputs given to `simulateVis`. One of the inputs
    to `not-gloss`’s `simulate` is simply specified, two are passed unchanged from
    inputs to `simulateVis`, and two are modifications of `simulateVis` inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter applies Newtonian mechanics to a single object moving in three
    dimensions. Solving a mechanics problem is a process of transforming information
    through a sequence of four representations, starting with one-body forces, then
    a differential equation, then a state-update function, and finally a list of states.
    Newton’s second law appears in this process as the means to transform a list of
    forces acting on an object into a differential equation. A numerical method transforms
    a differential equation into a state-update function. We used the Euler-Cromer
    method and fourth-order Runge-Kutta method with appropriately chosen time steps
    as numerical methods in this chapter. A state-update function is an essential
    ingredient in an animation of motion.
  prefs: []
  type: TYPE_NORMAL
- en: The state-based paradigm remained central in this chapter, where we defined
    a new data type to hold the state of a particle. This new data type includes the
    particle’s mass and charge, as well as its position and velocity and the time.
    We introduced the notion of a one-body force, which became the main way we talked
    about forces in this chapter. In the next chapter, we apply these ideas to specific
    examples and animate many of our results.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 16.1.** Apply the function `newtonSecondPS` to a very simple list
    of forces, say the list of just a constant force, and a very simple state, say
    the `defaultParticleState`, and find the type of the resulting expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.2.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: that takes a force vector as input and returns a `OneBodyForce` that will return
    the given constant force regardless of what state it is provided with. For example,
    if we use `constantForce` to make a one-body force that always produces 10![Image](Images/icap.jpg)
    N,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: then `tenNewtoniHatForce defaultParticleState` should produce `vec 10.0 0.0
    0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.3.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: that returns the gravitational force exerted by Earth’s moon on an object near
    the moon’s surface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.4.** Write a one-body force for the universal gravity produced
    by Earth.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 16.5.** Use the function `uniformLorentzForce` to find the direction
    of the force on a proton moving in the positive x-direction in a uniform magnetic
    field in the positive z-direction. There is no electric field. You can choose
    the speed of the proton and the magnitude of the magnetic field to be whatever
    you like. Given the direction of the force, what do you expect the subsequent
    motion of the proton to be?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.6.** The tools we’ve developed in this chapter solve a mechanics
    problem by producing an infinite list of particle states. To make sense of that
    solution, we often want to extract some of the data and graph it. Suppose we wanted
    to plot the y-component of velocity as a function of time. We would want a list
    of pairs of (*t*, *v[y]*) values. Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: that produces the desired pair of numbers from the state of one particle. Then
    write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: that produces a list of numerical pairs from a list of states of one particle.
    You can use your `tvyPair` function in the body of this second function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.7.** Write a predicate'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: that returns `True` if the time contained in the state (assumed to be a number
    of seconds) is less than or equal to one year and returns `False` otherwise. This
    predicate could be used with `takeWhile` to transform an infinite list of states
    into a finite list in preparation for making a graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.8.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that produces a function from time to particle state when given a list of states.
    Assume that the times between adjacent states are all the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 16.9.** In all of our work with air resistance so far, we have assumed
    the density of air to be a constant. However, the density of air near Earth’s
    surface actually decreases with altitude. A useful approximation for how air density
    changes with altitude is given by'
  prefs: []
  type: TYPE_NORMAL
- en: '*ρ* = *ρ*0*e*^(–*h*/*h*[0])'
  prefs: []
  type: TYPE_NORMAL
- en: where *ρ*[0] is the air density at sea level, *h* is the distance above sea
    level, *ρ* is the air density at height *h* above sea level, and *h*[0] is a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Taking *h*[0] = 8,500 meters and using the z-component of position for height
    above sea level, write a one-body force
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'that can be used instead of `airResistance` for situations in which an object
    finds itself at high altitude. To test this new function, the following function
    compares the range of a lead ball fired from sea level with some initial velocity
    at some angle under three different conditions: (a) no air resistance, (b) uniform
    air resistance, and (c) air resistance that varies with altitude. The diameter
    of the lead ball is 10 cm. Supply the initial state and the final line of code
    (the two places marked `undefined`), and then use the code to see the ranges for
    a ball fired at 45^∘. Try initial speeds of 10 m/s, 100 m/s, and 300 m/s.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 16.10.** Consider dropping a ball from a height of 10 meters near
    Earth’s surface. Use the functions we defined in this chapter to write a function
    that produces a list of particle states for this motion. Extra credit if you can
    use the `takeWhile` function to extract the particle states with *z* ≥ 0 (those
    in which the ball is still at or above Earth’s surface) from the infinite list.'
  prefs: []
  type: TYPE_NORMAL
