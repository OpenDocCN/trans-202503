- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: A CHERRY-PICKED REVIEW OF PROGRAMMING LANGUAGES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精选编程语言回顾
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: This book’s primary goal is to explore new ways to think about coding. Doing
    so will help you become a better coder, regardless of what language you are using.
    To that end, it makes sense to review existing programming languages, especially
    the languages that first introduced a particular coding paradigm or strongly influenced
    later languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标是探索思考编码的新方式。做到这一点，将帮助你成为一名更好的程序员，无论你使用的是哪种语言。为了这个目标，回顾现有的编程语言是有意义的，特别是那些首次引入某种特定编码范式或对后来的语言产生了深远影响的语言。
- en: The languages discussed in this chapter are not esolangs. Instead, they are
    serious approaches to the process of coding, meaning the process of translating
    thought into something a computer can use to solve a problem. Some of these languages
    are still in use. Others flowered briefly and then died. Still others evolved
    into something new. All of these languages have things to teach us, in addition
    to being fun to learn about and work with.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的语言不是伪语言（esolangs）。相反，它们是对编码过程的严肃探索，即将思维转化为计算机可以用来解决问题的东西的过程。我们讨论的其中一些语言至今仍在使用，另一些语言曾一度繁荣，后来消亡。还有一些语言演变成了新的形态。这些语言除了有趣并值得学习和实践外，还能教给我们很多东西。
- en: We’ll begin the chapter with a bit of programming language paleontology. Following
    that, we’ll consider the first programming languages. Even if you are still relatively
    new to coding, you already have a conception of what coding is and how to do it.
    That wasn’t always the case—the very idea of coding had to come from somewhere.
    It’s worth our time to take a look.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从一点编程语言古生物学开始。接下来，我们将考虑第一批编程语言。即使你仍然是编程的新手，你也已经对编程有了基本的理解，并知道如何进行编码。但这并非一直如此——编程的概念是从某个地方产生出来的。值得我们花时间去了解这一过程。
- en: The remainder of the chapter is a series of vignettes, in roughly chronological
    order, that introduce us to a collection of programming languages we should keep
    in the back of our minds as we move through the book. We’ll spend the next few
    chapters exploring select languages in still more detail before diving into esolangs
    proper.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分是按大致时间顺序排列的一系列小故事，介绍了一些编程语言，随着我们推进本书，它们应该始终存在于我们的脑海中。在接下来的几章中，我们将更详细地探讨一些精选语言，然后再深入研究真正的伪语言。
- en: There are thousands of programming languages (see *[http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm](http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm)*),
    so why this particular set? I selected languages that were important to the development
    of future languages and, as such, often represent a new conception of programming,
    or languages that were novel in some way that will help us when we get to esolangs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有成千上万种（见 *[http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm](http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm)*），那么为什么是这组语言呢？我选择了那些对未来编程语言的发展至关重要的语言，因此，这些语言通常代表了编程的新观念，或者在某些方面具有新颖性，能帮助我们理解伪语言。
- en: 'All of the languages presented in this chapter were invented before the year
    2000\. Of course, that’s not to say programming language development stopped with
    Y2K. There are a plethora of new languages: Rust, Scala, Julia, Go, Kotlin, and
    Swift are all examples of languages developed after 2000\. There will be no end
    to developing new programming languages. However, the current trend in language
    design leans toward multi-paradigm languages that take the best of what came before
    and mix it in some way with the hope of creating synergy. In other words, something
    greater than the sum of its parts. This trend validates our review of older languages
    with novel ideas as that is precisely what new languages are doing.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的所有编程语言都在2000年之前发明。当然，这并不意味着编程语言的发展在千年虫事件（Y2K）后就停止了。事实上，涌现出了大量新的编程语言：Rust、Scala、Julia、Go、Kotlin
    和 Swift 等都是2000年后开发的语言。开发新编程语言的浪潮不会停止。然而，目前语言设计的趋势是向多范式语言倾斜，这些语言融合了前人最佳的部分，并以某种方式进行混合，希望能创造出协同效应。换句话说，产生比各部分之和更强大的效果。这一趋势验证了我们对早期语言进行回顾的意义，因为新语言正是通过这种方式进行创新的。
- en: Let’s begin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: '**Programming Language Paleontology**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程语言古生物学**'
- en: Paleontology, literally the study of ancient being, is concerned with the history
    of life on Earth as well as the equally important diversity of life, that is,
    the number and kind of species. An important event studied by paleontologists
    is the *Cambrian explosion*, which was the sudden appearance of a huge assortment
    of animals in the fossil record.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The best-known fossil site related to the Cambrian explosion, from a time just
    after it, is the Burgess Shale of western Canada. The Burgess Shale is a priceless
    fossil site, half a billion years old, where the soft body parts of a myriad of
    animals, most unlike any living today, are preserved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Burgess Shale fauna, entirely marine, has familiar representatives, like trilobites,
    which are favorites of fossil collectors. But the real stars of the Burgess Shale
    are weird animals like *anomalocaris*, a large predator so unusual that its various
    body parts were originally classified as separate animals, or the five-eyed Opabinia,
    with its single, trunk-like arm and claw. Then there is Hallucigenia, a spiny,
    worm-like creature initially described upside down as if it were walking the sea
    floor on its spines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Later life, which for us means more mainstream life, is definitely more familiar,
    if less diverse. Fish dominated the later Paleozoic seas and eventually wandered
    out of the water onto land to become the first tetrapods, a body plan that land-dwelling
    vertebrates from crocodiles to pterosaurs, dinosaurs, elephants, and humans have
    maintained virtually unchanged ever since.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A geologic time scale of programming languages*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](ch01.xhtml#ch01fig1) shows a time scale of geologic history with
    programming languages marked at various places.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The silhouettes in [Figure 1-1](ch01.xhtml#ch01fig1) indicate the type of life
    dominant at the time. What is important for us is not so much the time scale,
    but the diversity of life. Modern life, signified by the mammals during the Cenozoic
    era, such as Smilodon, the famed sabre-toothed cat, and the mighty mammoth, are
    related to newer languages like Python, Java, and C#. These languages are familiar
    and not at all surprising to us.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: For the Mesozoic we have dinosaurs, including Alectrosaurus, a hunter who terrorized
    the late Cretaceous. Also present are a living tank, Edmontonia, and Achelousaurus,
    the prehistoric equivalent of a buffalo, but with fearsome horns. Although different
    in some ways, and perhaps a bit old, dinosaurs are familiar, so I’ve placed C
    and C++ in their company. Lest you think I’m slighting C and C++, do remember
    that the dinosaurs ruled the land for more than 100 million years and continue
    to rule the air even now, for birds are dinosaurs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The later Paleozoic era, the Age of Fishes, seems a good place for unusual,
    but still not entirely alien, programming languages like Forth, SNOBOL, and CLIPS,
    all three of which we’ll explore in this book. The fish silhouettes from the time
    are Eusthenopteron, the lobe-finned Sarcopterygii, and the jawless and armored
    Ostracoderm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 后期古生代，鱼类的时代，似乎是一些不寻常但仍不完全陌生的编程语言（如 Forth、SNOBOL 和 CLIPS）的合适背景，我们将在本书中探索这三种语言。那个时代的鱼类轮廓包括鱼鳍类（Eusthenopteron）、有鳍肢的硬骨鱼（Sarcopterygii）以及无颚的装甲鱼（Ostracoderm）。
- en: The Burgess Shale, the time of Anomalocaris, Opabinia, and Hallucigenia, is
    also marked. The diversity and unusual body plans of the Burgess Shale seem a
    perfect analogy for esolangs—experimental, perhaps evolutionary dead ends, but
    important all the same because they pushed the boundaries of what could be, before
    natural selection’s heavy hand decided who continued and who didn’t.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔吉斯页岩，那个有异常大眼怪鱼（Anomalocaris）、奥帕比尼亚（Opabinia）和幻觉螳螂（Hallucigenia）的时代，也是标志性的。布尔吉斯页岩的多样性和独特的身体结构似乎是
    esolang 的完美类比——实验性的，或许是进化的死胡同，但同样重要，因为它们推动了可能性边界，在自然选择的重压下，决定了哪些能延续，哪些不能。
- en: To me, esolangs are like the weirdly wonderful animals of the Burgess Shale.
    Like those animals, esolangs are experiments, forays into what could be, existing
    and thriving even if not destined to endure. The animals of the Burgess Shale
    made paleontologists rethink and reevaluate how they approached ancient life.
    Similarly, esolangs, if we let them, make us rethink and reevaluate how we approach
    programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，esolang（另类编程语言）就像布尔吉斯页岩中那些奇异而美妙的动物。像那些动物一样，esolang 是实验，是对可能性的尝试，它们的存在和繁荣虽然可能注定无法持续，但仍然在某种程度上意义重大。布尔吉斯页岩中的动物让古生物学家重新思考并评估他们如何看待古代生命。同样地，如果我们愿意，esolang
    也能让我们重新思考并评估我们如何看待编程。
- en: Esolangs are weird, often very strange and alien, but that’s the point. Like
    the beautifully bizarre animals of the Burgess Shale, esolangs explore niches
    in novel, unusual ways that might not be practical, but are definitely interesting
    and, most of all, fun.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Esolang 很奇怪，往往非常陌生且外星般，但这正是其意义所在。就像布尔吉斯页岩中那些美丽而奇特的动物一样，esolang 探索了以新颖、不寻常的方式填补的空白，这些方式或许不实用，但肯定有趣，最重要的是，充满乐趣。
- en: 'There you have it: geology and computer science living together, sans mass
    hysteria. Hopefully, [Figure 1-1](ch01.xhtml#ch01fig1) provides some food for
    thought, or at least an alternative viewpoint. We’ll refer to [Figure 1-1](ch01.xhtml#ch01fig1)
    from time to time throughout the book, but for now, let’s move on and explore
    the first programming languages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这里有地质学和计算机科学的结合，没有大规模的恐慌。希望[图 1-1](ch01.xhtml#ch01fig1)能提供一些思考的材料，或者至少是一种替代的观点。我们会不时地引用[图
    1-1](ch01.xhtml#ch01fig1)，但现在，让我们继续前进，探索第一个编程语言。
- en: '**The First Programming Languages**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**第一个编程语言**'
- en: 'What was the first programming language? That’s a difficult question to answer
    without defining *programming language*. We’ll define what we mean by a programming
    language in [Chapter 2](ch02.xhtml#ch02). For now, we’ll use an intuitive definition:
    a programming language is a means by which an algorithm can be encoded to control
    a machine, specifically a computer.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个编程语言是什么？没有定义*编程语言*，这是一个很难回答的问题。我们将在[第二章](ch02.xhtml#ch02)中定义我们对编程语言的理解。目前，我们用一个直观的定义：编程语言是将算法编码以控制机器，特别是计算机的工具。
- en: '***Programming Before Computers***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算机之前的编程***'
- en: The idea of a programmable machine predates the idea of a programmable computer.
    The *Jacquard loom*, a loom that used punch cards for control, was introduced
    in 1804\. The pattern of dots on the card controlled the movement of threads in
    the loom to specify the pattern woven. There is a language there, something that
    can be varied to produce a different output. Change the pattern of holes on the
    card and a new pattern emerges from the machine. The rolls for a player piano
    work in much the same way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程机器的概念早于可编程计算机的概念。*贾卡尔织机*（Jacquard loom），一种使用打孔卡片控制的织布机，于1804年问世。卡片上的点阵控制着织机中的线的运动，从而指定了编织的图案。这里有一种语言，可以变化以产生不同的输出。改变卡片上的孔洞图案，机器便会出现新的图案。自鸣琴的卷轴工作方式也差不多。
- en: In fact, the first “modern” computer design, Charles Babbage’s *Analytical Engine*,
    was influenced by the Jacquard loom. Although the Analytical Engine was never
    built, the engine had all the key components found in a modern computer and was
    programmable using punch cards. In 1843, while translating a set of lecture notes
    on the Analytical Engine from French to English, Ada Lovelace, Babbage’s long-time
    friend and daughter of the famous poet Lord Byron, wrote about the capabilities
    and potential uses of the Analytical Engine. She envisioned using the Analytical
    Engine for computation, but went further, imagining that the engine could be used
    for composing music and would release scientists from tedious computation, thereby
    freeing them for more advanced thinking. Ada was correct on both counts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The translation, and more importantly, Ada’s insightful and brilliant notes,
    are in “Sketch of the Analytical Engine” in volume III of *Taylor’s Scientific
    Memoirs* (1843, pp. 666–731). An online search will quickly locate a PDF version.
    I highly recommend reading through Ada’s notes, at least Note A. However, Ada’s
    Note G is most important to us. There, she applied an algorithm to the engine
    to compute Bernoulli numbers to demonstrate how the engine would compute the result.
    Bernoulli numbers are used in different areas of mathematics, but how they are
    used is unimportant to us. What matters is that Ada took an algorithm and structured
    it for the Analytical Engine—that is, she wrote a program for a general-purpose
    computer. It then seems fair to claim that Ada wrote the world’s first computer
    program in 1843\. The programming language she used was the *diagram of development*
    notation she introduced in Note D.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) presents Ada’s program. It details the sequence
    of steps, the variables involved, and how they change during the computation.
    Various people have translated her program into modern programming languages.
    Of particular interest is that she seems to have made an error, the world’s first
    computer bug.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Ada Lovelace’s Analytical Engine program to calculate the eighth
    Bernoulli number (1843)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4 of [Figure 1-2](ch01.xhtml#ch01fig2) calculates `v5 / v4`; however,
    the correct calculation is `v4 / v5`. With that modification, translations into
    modern languages produce the correct result: *–* 1/30\. Translations into C and
    Python are available on the internet. To learn more about Ada’s life, I recommend
    *Ada’s Algorithm*, by James Essinger (Melville House, 2015). She was ahead of
    her time, even though her own life was so short.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '***The First Modern Programming Languages***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first programming language in the modern sense was *Plankalk**ü**l*, developed
    by Konrad Zuse around 1943, 100 years after Ada’s first program. Plankalkül is
    German for “plan calculus” or “plan calculation.” Zuse used Plankalkül as a high-level
    programming language, though it was not implemented for any of his “Z” series
    computers. The language supported structured programming with `for` and `while`
    loops, floating-point arithmetic, arrays, and other features found in modern programming
    languages. Interestingly, the syntax of Plankalkül is 2D, with symbols written
    above other symbols. Zuse’s word for a program was “rechenplan,” which means “arithmetic”
    or “computation” plan. A good summary of Plankalkül can be found in “The Plankalkül
    of Konrad Zuse: A Forerunner of Today’s Programming Languages,” by Bauer and Wössner,
    Communications of the ACM 15, no. 7 (1972).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Lovelace and Zuse, respectively, deserve credit for the first program and the
    first programming language. But neither program nor language worked on actual,
    physical computers. The first programming language for a working computer is likely
    up for much debate. Early computers like ENIAC were programmed by rewiring. The
    Manchester Baby, circa 1948, was the first stored-program computer, so in that
    sense, it had a programming language—the instructions stored in its memory. We
    call the low-level instructions understood by a processor *machine language* or
    *machine code*. Machine code is a programming language, as are the assemblers
    that generate the machine code from *assembly language*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Machine code and assembly aside, the first programming language used on an actual
    computer is probably *Short Code*, developed by John Mauchly in 1949 and implemented
    by William Schmitt for the UNIVAC I in 1950\. Short Code supported arithmetic,
    including branching and a set of library functions like square root and absolute
    value. Expressions were transliterated from algebra to code and then manually
    packed into six 2-byte groups to fit the 12-byte words of the UNIVAC. Short Code
    was interpreted and parsed the meaning of an instruction from a tokenized representation
    of the program. In other words, Short Code worked much like the BASIC that interpreters
    built into early home computers of the 1980s. Running on a computer from the 1950s,
    interpreted Short Code must have been exceedingly slow to execute.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The first proper compiler, at least as credited by Knuth and Pardo in “The Early
    Development of Programming Languages” in *A History of Computing in the Twentieth
    Century* (Academic Press, 1980) is *AUTOCODE* by Alick E. Glennie at the University
    of Manchester, circa 1950–52\. Unlike Short Code, AUTOCODE was compiled, meaning
    it was translated into equivalent machine code instructions. Visually, AUTOCODE
    looks a bit like machine code with text thrown in here and there.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'While AUTOCODE and its successors were under development in the UK, in the
    US, Grace Hopper, Margaret H. Harper, and Richard K. Ridgeway were working on
    their compilers for the UNIVAC: A-0 to A-2\. In 1954, John Backus defined “The
    IBM Mathematical FORmula TRANslating system, FORTRAN,” and by 1957, the first
    *FORTRAN* compiler was released.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The development of FORTRAN was a watershed moment. Programming language design
    kicked into high gear in the late 1950s. Most notable of the languages defined
    in the later 1950s, besides FORTRAN, is John McCarthy’s *Lisp* in 1958\. It is
    truly impressive that both FORTRAN and Lisp are still in widespread use today.
    High-performance computing (HPC) makes frequent use of FORTRAN. Later in the book,
    we’ll use a version of Lisp to implement a *FRACTRAN* interpreter. We’ll focus
    on FRACTRAN, perhaps the most unusual of esolangs, in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The last pre-1960 programming language of note is *COBOL*. It was designed
    by a committee in 1959, with the first version appearing a year later. Rightly
    or wrongly, COBOL is still in use today. Unlike FORTRAN, a language for research
    scientists, and Lisp, a language for computer scientists, COBOL was a language
    intended for business use. COBOL programs are highly structured, rigid, and verbose.
    For example, consider this snippet from the COBOL 60 report defining the language:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The early years of programming language development resulted in the basic form
    and concept of a general-purpose programming language. The three critical languages
    to come out of this era are FORTRAN, Lisp, and COBOL. All three are still in use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'FORTRAN was a natural choice for what is still a primary use of computers:
    number crunching. COBOL is an early example recognizing that commercial use of
    computers was something apart from their scientific use. Lisp was far in advance
    of its time, but slow, resource-limited computers made it difficult for Lisp to
    live up to its potential.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now examine 10 different programming languages. These languages represent
    major transitions in the evolution of programming languages because of what they
    introduced or how they grew in popularity or opened the arcane art of coding to
    a larger population.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**ALGOL**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first language we’ll consider, *ALGOL*, gave rise to entire generations
    of programming languages and still influences programming languages today. ALGOL,
    like COBOL, was designed by committee.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGOL is a compiled, structured, imperative programming language, meaning it
    looks familiar to modern programmers. Subsequent programming languages inspired
    by ALGOL include Simula, PL/I, and Pascal, all mentioned later. ALGOL captured
    the essentials of what *imperative programming* is: a structured way to give step-by-step
    instructions to the computer.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-1](ch01.xhtml#ch01list1) is a simple program to compare two integers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 1-1: Comparing numbers in ALGOL 68*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing the language, the form should be familiar to you if you
    know any modern structured programming language. Notice that the program begins
    with `(` and ends with `)` instead of `BEGIN` and `END`. The latter works as well
    and is what users of Pascal or Modula-2 expect to see, but ALGOL’s free-form approach
    allows parentheses to denote code blocks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in trying ALGOL, you should look to Marcel van der Veer’s
    “Algol 68 Genie” implementation (see *[https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html](https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html)*),
    which runs on Linux and Windows. You’ll find extensive documentation on his site,
    all you need to learn the language. The Ubuntu package is `algol68g`. [Listing
    1-1](ch01.xhtml#ch01list1) is in *bigger.a68*. To run it, enter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 1-3](ch01.xhtml#ch01fig3) shows ALGOL’s descendants.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The ALGOL family tree*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, programming languages can have multiple influences, but this tree
    seems quite reasonable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**APL**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1962, Kenneth E. Iverson published *A Programming Language*, detailing a
    new programming language designed with arrays in mind that, in a show of boundless
    creativity, came to be called *APL*. One of the defining characteristics of APL
    is its nonstandard character set. That fact sometimes turns off would-be learners.
    For us, Iverson’s use of alternative characters is an excellent reason to include
    APL in our list of programming languages. However, the real reason to include
    APL is that it was the first *array-processing language*. Array-processing is
    a paradigm we’ll encounter in a later chapter, but, in a nutshell, it involves
    wholesale operations on arrays in a compact way. For a modern comparison, consider
    Matlab or Python with NumPy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: APL sessions are typically interactive. [Listing 1-2](ch01.xhtml#ch01list2)
    shows GNU APL in action. The user’s input is indented and the system’s responses
    are not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 1-2: APL in action*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The first line of [Listing 1-2](ch01.xhtml#ch01list2) assigns (←) whatever *ι*100
    returns to the variable, *x*. APL’s many operators each have two modes. If used
    in a unary fashion (that is, on a single operand), then the use is *monadic*.
    If used in a binary fashion (on two operands), then the use is *dyadic*. In this
    case, the monadic use of *ι* returns the vector 1 2 3 4 5 6 7 8 9 10, which is
    exactly how it would be entered manually. Thus, the first line is equivalent to
    `x = np.arange(1,11)` in Python using NumPy. The second line in [Listing 1-2](ch01.xhtml#ch01list2)
    multiplies each element of *x* by 10.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The dyadic form of *ι* searches for its second argument in the first. For example,
    consider the following APL code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we use the dyadic form of `?` to set *x* to a 10-element vector of random
    integers from 1 to 10, without repeats. Next, the dyadic form of *ι* searches
    *x* for the number 10 and returns its index, 5\. APL indexes from 1, not 0\. If
    the dyadic form of `?` returns vectors of random integers between 1 and some upper
    limit, what might the monadic form of `?` do? If you guessed return a random integer,
    you are correct: `?`*n* returns a random integer in [1, *n*].'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The second assignment in [Figure 1-2](ch01.xhtml#ch01fig2) sets *y* to a 4 ×
    4 matrix of random integers in [1, 100]. We use `?` to ask for 16 numbers, and
    then use *ρ* (rho) to reshape the 16-element vector into a 4 × 4 matrix before
    assigning it to *y*. To index a vector or array, use ![Image](Images/f0012-01.jpg)
    (vertical rectangle) as in 3 ![Image](Images/f0012-01.jpg) *x* to access the third
    element of vector *x* or 2 3 ![Image](Images/f0012-01.jpg) *y* to access *y*[23]
    of matrix *y*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: One quirk of APL is that expressions are evaluated from right to left, with
    no operator precedence rules. As a consequence, parentheses must be used to enforce
    desired behavior. For example, according to APL, the first of the two expressions
    below is completely correct.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Virtually every other programming language will tell you that both expressions
    equal 20 because multiplication is performed before addition. However, APL parses
    the first expression as “add 2 and 6 to get 8, then multiply by 3 to get 24.”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: APL is compact and powerful but also cryptic, and thus comes with a high learning
    curve. This, to say nothing of the early difficulties in using its alternative
    character set, has limited its use. Perhaps because of these difficulties, Iverson
    and Roger Hui developed *J*, an ASCII version of APL in the early 1990s (*[https://www.jsoftware.com/](https://www.jsoftware.com/)*).
    J retains the power of APL and expands on its capabilities to be more useful on
    modern computer systems. However, like APL, J has a high learning curve, creating
    the potential for high reward in learning a new way to think about what it means
    to code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**BASIC**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost everyone who used a microcomputer in the 1980s is at least somewhat familiar
    with *BASIC*. The “Beginner’s All-purpose Symbolic Instruction Code” was developed
    at Dartmouth College in 1964 by John G. Kemeny and Thomas E. Kurtz. BASIC was
    originally an unstructured programming language, meaning it used gotos to control
    program flow, and was intended for students and non-professionals. In the late
    1970s, when the microcomputer revolution took off, most computers included BASIC,
    usually in ROM. The first programming language many current software engineers
    learned was unstructured BASIC on a personal computer from the 1980s. As a result,
    BASIC’s impact on software development is significant and continues to this day.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: BASIC was interpreted and often stored in memory as tokens, much like Short
    Code, described above. BASIC lives on as *Visual Basic*, which uses structured
    programming and is fully object-oriented. Visual Basic is still one of the most
    widely used programming languages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](ch01.xhtml#ch01list3) shows a simple BASIC program for the Apple
    II to simulate coin flips.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 1-3: An Applesoft BASIC program to simulate coin flips*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: BASIC used line numbers, required for every line, to provide targets for `GOTO`
    statements. Different dialects of BASIC provided various commands, but all had
    `GOTO` and many had `ON-GOTO` to provide a simple computed goto construct. BASIC
    also supported subroutines via `GOSUB`, though most did not support recursion.
    Although perhaps scoffed at by many more serious programmers back in the 1960s
    and onward, the fact that BASIC continues today validates its utility.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**PL/I**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*PL/I (Programming Language 1*) was developed by IBM in the mid-1960s as a
    general-purpose programming language for all uses, scientific to business. As
    such, it competed directly with FORTRAN and COBOL. IBM has maintained PL/I and
    it’s currently available for IBM mainframe computers. The language itself is structured
    and imperative, and borrowed concepts from ALGOL, FORTRAN, and COBOL, as one might
    expect from a jack-of-all-trades language of the time. PL/I was in steady use
    from the late 1970s through the mid-1990s and represents one of the first languages
    intended to meet all programming needs.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Even though PL/I survives on IBM mainframes, its use elsewhere is negligible.
    New development in PL/I is likely equally insignificant. As an example of the
    language, [Listing 1-4](ch01.xhtml#ch01list4) shows a simple loop that outputs
    “Hello, world!” repeatedly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 1-4: A PL/I greeting*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: This example is quite readable, even now, though wordy, requiring four words
    to declare a simple integer variable. The influence of FORTRAN and ALGOL is evident
    via FORTRAN’s `DO` loop and ALGOL’s `END`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Logo**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1967, Wally Feurzeig, Seymour Papert, and Cynthia Solomon gifted generations
    of students with *Logo*, a “simplified” version of Lisp intended to teach programming
    concepts. Logo, which means “word” or “thought” in Greek, is intended to foster
    thinking about programming, especially thinking about how the Logo turtle will
    behave given the commands the students enter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch01fig4) shows a simple Logo session. The user enters
    commands at the bottom of the screen, and the triangular “turtle” responds.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Drawing with the Logo turtle*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Most commands are easy to understand, even if you’ve never seen Logo before.
    The commands in [Figure 1-4](ch01.xhtml#ch01fig4) are, with comments
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The inner `repeat` command draws a square with the turtle ending where it began.
    The 22.5 degree right turn tilts the turtle to draw another square. Since 16 ×
    22*.*5 = 360, 16 repetitions completes the pattern. The final instructions move
    the turtle off the pattern. Note that this particular Logo example is for Berkeley
    Logo. The exact form of the commands might be slightly different for another implementation.
    Logo is still used to teach programming concepts to children; see “Turtle Academy”
    (*[https://turtleacademy.com/](https://turtleacademy.com/)*). As Logo represents
    one of the first attempts to develop a programming language designed for teaching
    children, it deserves a place in our pantheon of languages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Simula**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first object-oriented language was *Simula*, developed by Kristen Nygaard
    and Ole-Johan Dahl. As the name suggests, Simula was first used for discrete-time
    simulations and evolved into a general-purpose language by 1967 (Simula 67). Simula
    brought the world classes, objects, and inheritance. The description that follows
    is specific to Simula 67\. I tested the examples with the GNU cim compiler (*[https://www.gnu.org/software/cim/](https://www.gnu.org/software/cim/)*),
    which is a bit tricky to build (at least version 5.1 is, which is the latest version
    available as of this writing). The cim compiler translates Simula to C before
    calling the standard gcc compiler to build the final executable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The “Hello, world!” program in Simula isn’t particularly impressive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s immediately clear that `OutText` prints something, and it’s reasonable
    to guess that `OutImage` acts like a newline, which it does. Structurally, Simula
    is part of the ALGOL family, with blocks denoted by `Begin` and `End` and semicolons
    to separate statements. Simula isn’t case sensitive, so `Begin` and `BEGIN` are
    equivalent. Comments begin with `comment` or an exclamation point and end with
    a semicolon, like other statements. If you’re familiar with Modula-2 or Pascal,
    then Simula syntax should look familiar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Simula is a structured language, like ALGOL, so both `for` and `while` control
    structures are present. Simula’s `for` is more flexible than in most other languages.
    For example, `for` iterates over a list of values, some of which may specify ranges.
    Consider the program
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'which outputs a table of squares and cubes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `r` is 1 for the first two iterations of the loop, then runs from 3 through
    18 by threes, and ends with –12.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: However, if this were all Simula offered, it wouldn’t be worth discussing. Simula’s
    true gift to the world is object-oriented programming ([Listing 1-5](ch01.xhtml#ch01list5)),
    for which both Nygaard and Dahl received the Turing Award in 2001.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 1-5: Using classes in Simula 67*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](ch01.xhtml#ch01list5) shows us how to define and use classes.
    We define two classes, `Person` and `Pal`, a subclass of `Person`. `Person` uses
    the familiar `class` keyword and then defines `first` and `last` names as type
    `text`, a string object, along with `age`, an integer. `Person` defines one method,
    `Print`, to print the person’s full name and age.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`Pal` is a subclass of `Person`. It adds `nickname` and overrides `Print` to
    output the nickname before throwing in the strange line'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which is a way to call the `Print` method of the superclass, `Person`. The phrase
    `This Pal` is a reference to the object itself. It returns a reference to the
    current object much like `this` in C++. The phrase `Qua Person.Print` interprets
    the reference returned by `This Pal` as a `Person` object so the proper `Print`
    method is called. (“Qua” is derived from Latin and means “in the capacity of”
    or “as.”)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: To use instances of these classes, we must create reference variables and then
    use `new` to assign the references to the actual instances. The `:-` operator
    assigns objects created on the heap to references. The `:=` operator assigns values
    to variables. Simula includes automatic garbage collection, so there is no need
    to delete objects when no longer needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To populate the objects, we use both `:-` and `:=`. Strings are objects, so
    `:-` assigns them to the `text` objects, whereas `:=` is used to assign `age`
    as it is an integer. First we populate the two instances of the parent class,
    `Fred` and `Barney`, with names and ages. Then we populate the two `Pal` subclass
    instances, `Wilma` and `Betty`, in much the same way, this time including nicknames.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The goal of all of [Listing 1-5](ch01.xhtml#ch01list5) is to call the `Print`
    methods of the now populated objects, which produces
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the proper `Print` method is called on each object to produce the
    desired output string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Simula was well ahead of its time. Object-oriented programming took well over
    a decade after Simula 67 to catch on and, arguably, 20 years to become widely
    employed in the commercial software world. Simula’s strong association with simulation
    hurt the adoption of the language. As we’ve seen here, Simula is much more than
    a simulation language and even now fits into what we expect an object-oriented
    language to be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Pascal**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Niklaus Wirth released Pascal in 1970\. It is a direct descendant of ALGOL and
    was widely used into the 1980s, primarily to teach structured programming concepts.
    After unstructured BASIC, many software engineers learned Pascal as their first
    “serious” programming language. Early versions of the Macintosh operating system
    were written, at least partially, in Pascal. UCSD Pascal, followed by commercial
    products like Turbo Pascal, brought the language to microcomputers. As with BASIC
    above, Pascal has strongly influenced a generation of developers, to say nothing
    of programming language development as a whole, so it deserves a place in the
    pantheon as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Look again at [Figure 1-3](ch01.xhtml#ch01fig3). There are two main branches
    of the ALGOL family of languages, one based on C and the other on Pascal. The
    Pascal branch leads to Modula-2, which overcame Pascal’s shortcomings but was
    never particularly popular, at least in North America. Ada was created by the
    US Department of Defense (DoD) as a standard for all development in the 1980s
    (Ada is named after Ada Lovelace). The DoD required the use of Ada for projects
    from 1991 to 1997\. At present, Pascal has fallen into obscurity, and Modula-2
    and its descendants, along with Ada, are even less popular. However, Pascal lives
    on as Delphi/Object Pascal. As a straightforward, structured programming language
    without object-oriented abilities, there was little reason to select Pascal after
    the rise of C and C++.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-6](ch01.xhtml#ch01list6) gives us a feel for the language.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 1-6: Generating the sequence of nonsquare integers*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Pascal looks quite similar to ALGOL and Simula. This particular program produces
    a table of 120 numbers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look carefully at the table; do you see what isn’t there? The table contains
    every integer less than 132 *except* for all the perfect squares: 4, 9, 16, 25,
    36, 49, 64, 81, 100, and 121\. The program implements the sequence'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0020.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: which has the remarkable property of bypassing all perfect squares, as *n* is
    incremented from one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Pascal programs begin with `program` followed by a variable declaration section
    beginning with `var`. Here we define one integer variable, `n`. The body of the
    program is between `begin` at the beginning and `end.` at the end. Note that the
    period is required for the final `end`. Blocks of code are also enclosed within
    `begin` and `end`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The body of this program is a single `for` loop running from 1 to 120\. The
    body of the loop is a `write` statement, which does not move to the next line
    when done. The number output is the equation above for the current value of *n*.
    The argument `:4` tells Pascal to right-justify the output in four spaces. The
    code also tells the program to move to the next line if `n` is a multiple of 10.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Pascal was intended for teaching and wasn’t suitable for system-level programming
    without nonstandard extensions. Wirth enhanced Pascal to make Modula-2, which
    was suitable for system-level programming. However, Modula-2 never reached its
    full potential in the commercial world. Regardless, Wirth’s Pascal, and subsequent
    languages, rightfully earned him the Turing Award in 1984.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Prolog**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most programming languages are imperative. That is, programs are a recipe, a
    series of “do this” followed by “now do that.” However, in *Prolog*, things are
    different. Prolog is a *declarative language*. Relationships are encoded as rules,
    and it’s up to the Prolog engine to figure out how to accomplish the goal of answering
    a user query. Prolog was created in 1972 by Alain Colmerauer and Robert Kowalski
    and is still in limited use today.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A Prolog program is a series of *facts*, *rules*, and *queries*. We’ll learn
    what these are in a bit. Thinking in Prolog is quite different from thinking in
    most languages. Imperative languages are natural, and object-oriented languages
    build on that. Even APL makes sense once you understand the odd characters. But
    Prolog is an entirely different beast. We’ll only scratch the surface of it here.
    Later in the book, we devote an entire chapter to CLIPS, which is somewhat like
    Prolog, so we’ll struggle with this mode of thinking then.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'This section presents two small Prolog examples. I used SWI-Prolog (*[https://www.swi-prolog.org/](https://www.swi-prolog.org/)*),
    which is most easily installed on Ubuntu by typing the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please see the Prolog website for the macOS and Windows versions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '***Modeling Family Relationships***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The canonical Prolog example involves family relationships. Our example is in
    *family.pl*, with the most important parts shown in [Listing 1-7](ch01.xhtml#ch01list7).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 1-7: Family relationships in Prolog*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the code in [Listing 1-7](ch01.xhtml#ch01list7) before exploring
    what Prolog can do with it. The first portion of the code builds a knowledge base,
    which is a listing of facts. The code presents facts about the relationships between
    the classic Greek gods. For example, according to mythology, the parents of Cronus
    are Gaia and Uranus, so the knowledge base uses the lines `parent(uranus, cronus).`
    and `parent(gaia, cronus).` to state this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note that Prolog doesn’t have a `parent` function’ thus, the statements are
    facts relating two *atoms*. Atoms are generic names, a collection of characters
    treated as a symbol and acting as a single unit. There is a relationship called
    `parent` and `gaia` and `cronus` share it. We read the fact as “Gaia is the parent
    of Cronus.” Similarly, the knowledge base also labels the sex of the gods. Read
    `female(hera).` as “Hera is female.” Notice that facts, and later rules and queries,
    end with a period. The knowledge base identifies the sex, parents, and whether
    or not two gods were considered married. Again, these are the facts that Prolog
    will work with. To do anything interesting, we need some rules to go with the
    facts. That’s the second part of [Listing 1-7](ch01.xhtml#ch01list7).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Using family relationships helps because we are all so familiar with them. For
    example, we define a rule to decide if `X` is the father of `Y`, where atoms beginning
    with a capital letter are logical variables. Prolog will try to satisfy rules
    by locating values for these variables. The rule defines the relationship as “If
    *X* is the parent of *Y* and *X* is male, then *X* is the father of *Y*.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of `father(X,Y)` is true *if* the right-hand side is true.
    The right-hand side is true *if* `parent(X,Y)` is true *and* (comma) `male(X)`
    is true. Prolog uses a comma for “and” and a semicolon for “or.” With just this
    bit of knowledge, we can read the rest of the rules. A mother is a parent and
    female. Someone, `X`, is the child of `Y` if `Y` is the parent of `X`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `sibling` says two people are siblings if they share a parent.
    That much makes sense. The last part of the rule is `dif(X,Y)`. It adds “and *X*
    and *Y* are not the same” to the rule. This is there because we don’t normally
    think of ourselves as our own siblings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `wife` uses parentheses and a semicolon for “or.” `X` is a wife
    if she is female and married to `Y`. Prolog doesn’t intuitively know that the
    rule `married(X,Y)` implies `married(Y,X)`, so either case is checked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The final rule is `paramour`, because, after all, we’re talking about ancient
    Greek gods. Here, `X` is a paramour of `Y` if `A` is a child of both `X` and `Y`,
    `X` and `Y` are not married (`\+` is like “not”), and `X` and `Y` are different.
    Read through the rules in [Listing 1-7](ch01.xhtml#ch01list7) until you feel comfortable
    with what they express.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Prolog programs are not loaded, but are rather *consulted*. The line
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: consults *family.pl*, after which Prolog presents its prompt and waits patiently
    for user input. Let’s ask Prolog some questions about the gods and see if it can
    answer them based on the facts and rules we fed it (see [Listing 1-8](ch01.xhtml#ch01list8)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 1-8: Exploring family relationships*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-8](ch01.xhtml#ch01list8) shows a Prolog session where *family.pl*
    has been consulted. User input is in bold with Prolog’s replies following. First,
    we ask Prolog if Zeus and Hera are married. Prolog replies `true`, as this is
    simply a fact in its knowledge base.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we ask Prolog to find an `X` such that `X` is the wife of Zeus. Notice
    that the rule is defined such that `X` is the wife of `Y` so the query is `wife(X,zeus)`
    and not `wife(zeus,X)` which would be asking the question “who is Zeus the wife
    of?” Prolog finds one match, one binding for `X` that makes the query true: Hera.
    The user then enters the bold semicolon. After Prolog finds a solution, if it
    can’t decide that there are no other solutions to the query on its own, it pauses
    and waits for the user to enter a semicolon to tell Prolog to search for more
    solutions. The final `false` is Prolog telling the user that no more solutions
    were found.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Then we ask Prolog, “Hera is the mother of who?” and we’re correctly told Ares,
    Hephaestus, and Eris. Next we ask, “Who is the mother of Hera?” and, again correctly,
    Prolog answers Rhea. The following query tells us that Rhea is also Zeus’s mother.
    The ancient gods certainly had complex family relationships.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We next ask Prolog to identify the children of Zeus. Specifically, we ask, “Zeus
    is the father of who?” and are correctly told he is the father of eight other
    gods, much to the annoyance of Hera.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: A few more examples will drive home how Prolog works. [Listing 1-9](ch01.xhtml#ch01list9)
    shows Prolog’s response to the query “Who are Zeus’s paramours?”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 1-9: More family relationships*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Leto is listed twice. The rule for paramour is
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: meaning that `X` and `Y` are paramours if they are not married and have a child
    together. In mythology, Zeus and Leto have twins, Apollo and Artemis. There-fore,
    Prolog finds that Leto and Zeus are paramours in two different ways, once for
    Apollo and again for Artemis. There are ways to capture responses and return only
    unique solutions, but using them here would only cloud the example. The final
    two queries in [Listing 1-9](ch01.xhtml#ch01list9) illustrate that Prolog can
    resolve queries involving grandparents and great-grandparents.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Fibonacci Sequence***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our last Prolog example shows how it works with numeric data and its support
    for recursion. Specifically, we’ll implement the Fibonacci sequence,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'which is expressible recursively by saying that the next number is the sum
    of the previous two:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '*F[n]* = *F[n–]*[1] + *F[n–]*[2], *F*[1] = 1, *F*[2] = 1'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the Fibonacci sequence in more detail in [Chapter 13](ch13.xhtml#ch13).
    It’s an easy target for esolang examples. For now, we’ll use a recursive Python
    implementation as a guide for a Prolog version. In Python, the equation above
    can be implemented as
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The *n*th Fibonacci number is the sum of the previous two, or if *n* is less
    than or equal to two, just one. This function tells us that *F*[11] = 89, which
    is correct. So how can we express the rule for the Fibonacci sequence in Prolog?
    To do so, we first need two facts that act as the base cases, *F*[1] = 1 and *F*[2]
    = 1\. Then we need to express the recursive relationship. [Listing 1-10](ch01.xhtml#ch01list10)
    has what we need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 1-10: Recursive Fibonacci numbers*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The two base cases are facts. The first Fibonacci number is 1, and the second
    is 1\. When Prolog is eventually trying to satisfy `fib(2,1)`, it will find the
    fact. The “return value” is the second number. The query to find the 11th Fibonacci
    number is `fib(11,F).` or “What F value makes `fib(11,F)` true?” That’s the 11th
    Fibonacci number.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The general rule is `fib(N,F)`. The body is the conjunction (that is, clauses
    linked by “and”) of several things. First, is it true that `N > 2`? Next come
    two “assignments,” which are true when `N1` is *n –* 1 and `N2` is *n –* 2\. So
    far, the statements make sense and are elements of the Python definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines, `fib(N1,F1)` and `fib(N2,F2)`, are strange at first. These
    are the recursive calls, as it were. The first seeks to find *F*[*n–*1] by finding
    an `F1` such that `fib(N1,F1)` is true. Likewise, the second does the same for
    *F*[*n–*2]. If these are found, then `F1` and `F2` have meaningful values, and
    the last line says that `F`, the actual number we’ve been looking for, is the
    sum of `F1` and `F2`, which must be the previous two Fibonacci numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for [Listing 1-10](ch01.xhtml#ch01list10) is in *fib.pl*. Let’s start
    Prolog, consulting *fib.pl*, and ask it for the 11th Fibonacci number:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We see that our example works, as it gives us the same answer as the Python
    version. Now, ask for `fib(26,F)` and see how long it takes Prolog to answer.
    On my machine, Python answers immediately with 121,393\. Prolog also answers with
    121,393 but takes 29 seconds to do so. The double recursive call makes this Fibonacci
    implementation inefficient. However, Prolog’s exceedingly slow response validates
    a common criticism of the language: its performance. Moreover, the Unix utility,
    `top`, reported that during the search, Prolog used 0.5 percent of system memory,
    or about 42MB, which seems excessive for such a simple task.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Tracing lets us watch Prolog work through a query. For example, here’s the output
    tracing the query `fib(3,F)`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we activate `trace` and enter the query: `fib(3,F)`. At each step, Prolog
    pauses, waiting for a command. Pressing ENTER moves to the next step and displays
    `creep`. Therefore, each line above represents entering or exiting a subgoal of
    the rule. Temporary variables have names like `_4072`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the trace is the query with a temporary name for `F`. The
    `8` is similar to a call depth indicator, as it increases as the query is evaluated
    and decreases back to its initial value when the query is satisfied.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: If you walk through the trace, you’ll see that each step works to satisfy the
    particular subgoal, that is, a part of the right-hand side of the rule. The first
    pair, for example, indicates that 3 > 2 is true. The second pair says that 2 =
    3 + (*–*1), which is also true. Interestingly, Prolog adds a –1 instead of subtracting
    1.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The first recursive call ➊ is immediately satisfied because `fib(2,1)` is a
    known fact, one of the base cases of the recursion. The second recursive call
    ➋ is similarly satisfied because `fib(1,1)` is also a fact.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: With the recursive calls satisfied, the final subgoal, `F is F1 + F2`, can be
    satisfied with `F=2`. Thus, the query, `fib(3,2)`, is now satisfied and Prolog
    returns `F = 2`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The trace for `fib(3,F)` produced 14 lines of output and the trace for `fib(26,F)`,
    which took nearly 30 seconds to return, produced 1,456,706 lines, reaching a maximum
    depth 24 above the base depth.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been a bit unfair to Prolog. The double recursive Fibonacci algorithm
    is inefficient because it is not *tail recursive*. A tail-recursive call is one
    in which the last invocation is the recursive part. Tail-recursive functions can
    be implemented without storing the current call’s stack frame. The recursion becomes
    essentially a jump to the beginning of the function without involving the call
    stack.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-11](ch01.xhtml#ch01list11) is a tail-recursive version of the Fibonacci
    program. You’ll find it in the file *fib_tail.pl*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 1-11: Fibonacci numbers using tail recursion*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the code uses two additional variables as accumulators: the
    second and third arguments. The base case is any call matching `fib(1,A,F,F)`,
    with `F` being the desired number, and `A` being any other value. Notice that
    the rule `fib(N,A,B,F)` has a recursive call as the final subgoal, unlike [Listing
    1-10](ch01.xhtml#ch01list10), which has two recursive calls, neither of which
    is the final subgoal. Prolog can use tail recursion here because there is nothing
    in the body to come back to.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Run [Listing 1-11](ch01.xhtml#ch01list11) as `fib(26,0,1,F)` to find the 26th
    Fibonacci number. This time, Prolog will respond immediately with 121,383\. Then
    try `fib(266,0,1,F)` to see that Prolog supports arbitrary precision integers.
    The `trace` command will show you how the accumulators are used to ultimately
    arrive at a call matching `fib(1,A,F,F)`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If our goal is to learn to think outside the box in terms of what it means to
    code, and it is, then Prolog promotes such thinking. Keep Prolog in the back of
    your mind. We’ll see a similar approach later when we discuss CLIPS in [Chapter
    6](ch06.xhtml#ch06).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Smalltalk**'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smalltalk came to be in the early 1970s, a product of the Learning Research
    Group at Xerox PARC. It was designed by Alan Kay, Dan Ingalls, and Adele Goldberg
    as a teaching language, much like Logo. Smalltalk is an object-oriented language.
    In fact, it is a *pure object-oriented language*, meaning that everything, even
    numbers, is an object. Pure object-oriented languages stand in contrast to impure
    languages like C++. In C++, *primitives*, such as integers, are not objects. Smalltalk
    objects communicate with each other by sending messages. If an object knows how
    to reply to a message, then that object is a valid receiver of the message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk classes support *duck typing* and may be extended at will. Duck typing
    allows any object that supports a particular method to be used where that method
    is expected. In other words, if it walks like a duck and quacks like a duck, it’s
    a duck.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing the syntax, we can understand that `MyClass` in the following
    example defines a method, `A`, to square its argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At any later time, even if objects of `MyClass` already exist, a new method
    to calculate cubes may be added.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `MyClass` class, including any existing objects, now knows how to use the
    method `B`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Many Smalltalk systems include an extensive graphical interface. This includes
    Smalltalk-80, the version we’ll explore here. Modern Smalltalk systems, like Squeak
    (*[https://squeak.org/](https://squeak.org/)*) or Pharo (*[https://pharo.org/](https://pharo.org/)*),
    follow this tradition. If Smalltalk piques your curiosity, do take a look at one
    or both of these systems. However, the essence of the Smalltalk language is our
    focus, not its graphics abilities. Therefore, we’ll work with GNU Smalltalk, which
    is graphics-free.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along yourself, install GNU Smalltalk by typing
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: On macOS, you can install Smalltalk by typing
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For Windows users, I recommend a Linux virtual machine, Windows Subsystem for
    Linux, or, barring that, Cygwin.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk supports integers, floating-point numbers, strings, and fractions
    (rationals). Smalltalk has 1D arrays, dictionaries, and many other container objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this vignette is to learn what makes Smalltalk unique and a good
    addition to our collection of novel programming languages. First comes a brief
    discussion of what Smalltalk brings to the table. Then we’ll work through a complete
    Smalltalk program to understand, at least superficially, how classes are defined
    and subclassed. Specifically, we simulate a race between four different animals,
    each its own Smalltalk class: bird, wolf, frog, and snail.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Smalltalk Features***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GNU Smalltalk is intended for scripting, just like Python or Perl. For example,
    this code shows our first example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line is not standard Smalltalk. It’s the comment line used by Unix
    systems to make a script executable by pointing to its interpreter. Double quotes
    surround comments in Smalltalk, while single quotes surround strings.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for calling a method on an object is <object> <method> or
    <object> <method>: <argument>. Everything’s an object, including strings (even
    empty ones). Each line in the example above defines a string and then calls the
    `displayNl` method to print it. Notice the period at the end of each line. Smalltalk
    uses periods as statement separators. On a Unix-like system, `chmod a+x hello.st`
    makes *hello.st* executable. The GNU Smalltalk interpreter itself is `gst`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can exit the interpreter with CTRL-D.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The expressions above should give you pause. Smalltalk evaluates from left to
    right without respect to operator precedence. Therefore, the first expression
    is interpreted as `2+3*6 = 5*6 = 30`. Recall that APL is similar but evaluates
    from right to left. In Smalltalk, use parentheses on expressions to enforce the
    desired evaluation ordering.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk syntax is simple but leads to verbose statements. To define and make
    basic use of an array, use
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Smalltalk uses `:=` for assignment, so the first line declares `x` to be an
    array of five elements. Smalltalk variables default to `nil`. The second line
    is `x[0]=3` in most other languages. The method name is `at` and it accepts one
    argument, the index, and a keyword argument, `put`. Smalltalk arrays hold any
    object, as the remaining lines above demonstrate. Smalltalk indexes arrays from
    one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible Smalltalk would win first prize for the longest method name in
    a standard library. Consider the following, which counts how many times a substring
    appears in another string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Graphical Smalltalk systems have a transcript window where messages are displayed.
    GNU Smalltalk uses this for normal output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This little example illustrates several Smalltalk features. First, `Transcript`
    is the name of a class, so we’re using class-level methods, not instance methods.
    Second, Smalltalk uses a semicolon to call methods using the most recent class
    or object, which in this case is `Transcript`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An important concept in Smalltalk is the *block*, which is code between square
    brackets. Blocks are similar to unnamed functions, as they can be assigned to
    variables and later executed. They also form the body of Smalltalk’s control structures,
    which are nothing more than method calls on objects, like everything else in Smalltalk.
    Consider the following example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We define `b` to be a block. The block contains one statement to print a string.
    To execute the block, we call `value`, which prints the string. The second string
    in quotes is the value of the block, the last statement in it, which is the string
    here. In a running program, the second string would not be shown.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Blocks accept arguments and support local variables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s important to understand this example. First, we have `x`, defined outside
    of a block and set to a string. Next, we define block `b`. It accepts an argument,
    `i` (the colon is necessary), and defines a local variable, `y`. Local variables
    are listed between vertical bars (pipes). The body of the block sets `y` to the
    argument, `i`, then uses `y` to assign to `x` and `z`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The block is executed with 42 as the argument. Then we look at the value of
    `x`, `z`, and `y`. What happened? The block updated `x`, which already existed
    outside of the block. It also defined `z` *outside* the block. We didn’t declare
    `z` to be local to the block, so it was defined globally. We did declare `y` to
    be local to the block, so it has no value outside of the block, hence `nil`. The
    moral of the story is: if you want what happens in the block to stay in the block,
    only use local variables. As an exercise, try this example in Python, defining
    a function called `b(i)` in place of the block. Variables defined in the function
    do not alter variables defined globally unless you use `global` explicitly. Smalltalk
    blocks allow unintended consequences, so care is necessary.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Structures**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Smalltalk has the expected control structures, but their syntax is unusual because
    they are really methods. Let’s look quickly at conditional statements, `while`
    loops, and iterated loops. We can’t cover all combinations, especially with iteration,
    but you’ll get the gist of what’s going on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine this short program:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It asks the user for an integer by reading the next line from standard input
    and interpreting the resulting string as an integer before assigning it to `v`.
    Next, the code checks to see if `v` is less than 0, 0, or greater than 0 and sets
    the value of `a` accordingly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The code above looks like an `if-then-else` construct, and it acts like one,
    but it isn’t one. It’s normal Smalltalk <object> <method>: <argument> syntax.
    The `ifTrue` method is applied to the Boolean returned by `(v < 0)`. If the Boolean
    is true, execute the block that sets `a` to –1\. Similarly, `ifFalse` fires if
    the Boolean value is not true. Nesting within the block is perfectly fine, so
    the first `ifFalse` block has its own pair of `ifTrue` and `ifFalse` method calls.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In Smalltalk, `while` loops act similarly. Consider
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where, unlike `ifTrue`, `whileTrue` is applied to a block, `[i < 10]`. As expected,
    this code snippet displays the numbers 1 through 9\. The same output is generated
    by
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: which loops for as long as the code block returns `false`. Note that `while`
    loops are applied to a block, so the block need not be just a simple Boolean expression,
    but need only return a Boolean value. The following is a perfectly valid loop
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: with the side effect of defining `x` and setting it to 100.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: A basic `for` loop in Smalltalk is
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As with `if` and `while`, the loop isn’t a construct; it’s a message `to` sends
    to the integer object, 1\. The first part creates an `Interval` object, which
    is the entity that understands the `do` message. For example, the following code
    produces the same output as the previous.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice that the argument to `do` is a block, with `i` being the argument that
    becomes the loop control variable. Therefore, we can do something like the following
    if we wish:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first line defines `j` as an `Interval` object, the second defines `b` as
    a block (really a `BlockClosure` object), and the third uses `do` to apply the
    block to the interval.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We’ve hit the essentials of Smalltalk, though honestly we’ve barely put our
    little toe in the water. Smalltalk has a simple syntax and an extensive class
    library that we’ve ignored. However, we must press on. Smalltalk is all about
    objects and classes. Let’s see how by going to the races.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '***Going to the Races***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll create a small class hierarchy and use it to race four animals against
    each other. Our plan is this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Define a base class, `Animal`, that responds to messages common to all the animals.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define four subclasses: `Bird`, `Wolf`, `Frog`, and `Snail`. The subclasses
    respond to messages based on how the animals move: `fly`, `run`, `hop`, and `crawl`,
    respectively. The class ignores messages that it doesn’t understand.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of each animal and send randomly selected messages to them.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the distance each animal has moved and declare a winner.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is in *race.st*. We’ll present it in pieces as we walk
    through it. Please read through the full source code file first before proceeding.
    If you do, the discussion will be easier to follow. Recall that the first line
    of the file is not standard Smalltalk; it’s Unix-speak to run the file as a script.
    The `-g` option disables the occasional garbage collection message.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the base class, `Animal`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All Smalltalk classes are subclasses of something. The top of the object hierarchy
    is the class `Object`, so `Animal` subclasses from it. There are three member
    variables: `increment`, `distance`, and `letter`. There are three methods: `init`,
    `getDistance`, and `print`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The `init` method accepts `inc` as an argument along with `letter`, a keyword
    argument. In Smalltalk, instances of a class are usually created with `new` and
    initialized later; however, this process is flexible. We’ll call `init` to set
    up our class instances. In this case, initialization sets the distance traveled
    to zero, the letter associated with the animal when printing, and how far the
    animal moves each time it does move.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The next method is `getDistance`. It returns the current value of `distance`.
    Smalltalk does not have a return statement; rather, it precedes the value to return
    with a carat (`^`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The final method, `print`, displays the animal’s distance traveled as a sequence
    of dashes ending with the animal’s letter. It uses `timesRepeat`, a message sent
    to an integer to repeat a code block a set number of times.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`Animal` defines the base class. The specific animal classes come next:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each class defines `init`, which calls `init` of the superclass, `Animal`, passing
    in the increment and letter associated with the animal. For `Bird`, the increment
    is `6` and the letter is `'B'`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Each subclass defines a method based on how the animal moves. For `Bird`, it’s
    `fly`. The move method adds the increment to the distance. The last method in
    each subclass is `doesNotUnderstand`. This method is called by Smalltalk when
    an object receives a message it has no method for. For example, if we pass the
    `fly` method to a `Wolf` object, `doesNotUnderstand` is be called. We want to
    ignore unknown messages, so the body of the method is empty.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The classes are defined, but no instances have been created. Let’s create an
    instance of each and store the objects in an array.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Each element of the array `animals` is set to the object returned by calling
    `new`. Doing this creates the objects, but they are not yet initialized. The final
    line loops over the array, calling each object’s `init` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The animals are ready, so let’s run the race.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are four movement methods: `fly`, `run`, `hop`, and `crawl`. We want
    to select one of them at random and send it to each animal. If the animal knows
    how to respond to the message, it does; otherwise, it quietly ignores it.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `moves` is set to an array of the method names. This syntax is a shortcut
    for the `at:put:` syntax used above. The `timesRepeat` loop sets the number of
    moves that will happen. The interval, `(1 to: 4)`, is sent `atRandom` to return
    a random integer in [1,4]. This is the index in `moves` to set `m` to a randomly
    selected method string. The `do` loop sends the message in `m` to each animal
    by first converting the string to a symbol representing the method before passing
    it to the object itself via `perform`. Because each animal only responds to one
    of the move messages, only one animal will move during each pass through the `timesRepeat`
    loop.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The race is now over. To see how the animals did, we use the code below to
    call the `print` method of each animal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To declare a winner, we need to find which of the four moved the farthest. For
    that, we’ll use a `Dictionary`,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: where the keys are the object instances and the values are the distance each
    animal moved. To declare a winner we find the maximum distance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To loop over a dictionary, use `associationsDo`, which passes a key-value pair
    to the body of the loop. The `value` of the pair is the distance that animal traveled
    and the `key` is a reference to the object. The phrase `class displayString` converts
    the name of the object class to a string for display.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of *race.st* looks like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The bird will win most often as it flies the farthest each time it moves. The
    wolf wins next most often and the snail least often. The file *run.py* runs 10,000
    races tracking how often each animal wins. For example, one run produced
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The bird won nearly 64 percent of the races, followed by the wolf, who won 28
    percent. The poor snail only won about one race in two hundred.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard ML**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our final language is *Standard ML* (SML), an early functional language based
    on ML. *Functional languages* use composition of functions—that is, functions
    applied to the output of other functions—to implement algorithms. We’ll get to
    what makes SML a functional language in a later chapter when discussing programming
    language paradigms.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The version of SML we’ll work with, SML-NJ (NJ stands for “New Jersey”) largely
    conforms to the language standard promulgated in 1997 (*[https://smlfamily.github.io/sml97-defn.pdf](https://smlfamily.github.io/sml97-defn.pdf)*).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, install SML on Ubuntu using the command
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Versions for macOS and Windows are available at *[http://www.smlnj.org/dist/working/110.99/index.html](http://www.smlnj.org/dist/working/110.99/index.html)*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Run sml to start the interpreter. As with Smalltalk, use CTRL-D to exit.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Ensure that the version number is at least that shown here. The interpreter
    is waiting for us to type something; try `"scary movie";`. The interpreter responds
    with
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This tells us that `"scary movie"` is of type `string`. Moreover, the interpreter
    has defined the variable `it` and assigned the string to `it`. SML statements
    end with a semicolon and SML is a typed language; however, one of its strengths
    is that it infers types in most cases.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'One characteristic of functional languages like SML is *referential transparency*,
    meaning that a function returns the same value for the same input regardless of
    the state of the system as a whole. For example, consider the following Python
    session:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The value returned by `f(y)` depends on the current value of the variable `x`.
    Now consider the equivalent in SML.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, the function uses the value of `x` as it was when the function
    was defined. Changing `x` later does not affect the function value. SML is referentially
    transparent, but Python is not. SML functions are defined with `fun`, followed
    by the function name and argument list in parentheses. At least they can be defined
    that way. We’ll encounter other ways below.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'SML supports the common primitive data types: integers, reals, and strings.
    It also supports lists and tuples, along with more advanced user-defined data
    structures resembling classes. Every member of an SML list must be of the same
    data type. Tuples may mix data types; however, SML functions consider tuples to
    be a compound type rather than a collection of the same type.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: SML is perhaps the only language that requires you to write threatening code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: SML uses `orelse` where most other languages use `or`. So to check if one or
    the other conditional expression is true, you use `orelse`. Similarly, `andalso`
    replaces `and`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: SML supports *unnamed functions*, or *lambda functions* as they are sometimes
    called. For example, the following code defines an unnamed function to add 1 to
    its argument and then immediately applies it to the number 11.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: SML treats functions as *first-class objects*. This means they can be assigned
    to variables and returned from functions. One use of this ability is to return
    a partially evaluated function in which some of the arguments are bound but others
    are not. This is known as *currying*, after Haskell Curry, an American mathematician
    who worked in logic. The Haskell programming language is named after him.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we see currying in action, consider the following two function definitions:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We define `add` twice with the second definition replacing the first. Both definitions
    take two arguments and add them together, so `add(11,22)` produces the same output
    as `add 11 22`. Look carefully at what SML returned after each function definition.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The first definition produced
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: which means that `add` is a function that accepts two integers and returns an
    integer. The second definition produced
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'meaning that `add` is now a function that accepts an integer and produces *a
    function* that accepts an integer and returns an integer. Defined in this form,
    `add` enables currying. Consider:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We define `add` as above and apply it to 11 to return a function that we then
    apply to 22 to get 33.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Currying allows us to fix the first argument, the `x`, and bind the returned
    function, now expecting only the `y`, to a variable. The new function, `add11`,
    accepts an integer argument and returns that argument plus 11\. Lastly, we see
    that `add11` is indeed a function mapping an integer to an integer.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'SML functions can use patterns, much like Prolog. For example, consider these
    definitions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example is in the file *hello.sml*. You can load it with sml hello.sml
    or by entering use "hello.sml"; if you’re already in the interpreter. Either way,
    you’ll see SML’s output as to the functions and their types.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first function, `hello`, accepts no arguments and returns nothing. In SML,
    nothing is represented by `unit`. The `hello` function is used solely for its
    side effect of printing “Hello, world!” Therefore, `hello` accepts `unit` and
    returns `unit`. Both `greetA` and `greetB` accept an integer and return nothing,
    hence `unit`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Look at the definition of `greetA`. It uses a recursive call to `greetA` to
    print “Hello, world!” repeatedly. If the argument is 1, call `hello` and return.
    Otherwise, call `hello` then call `greetA` again after subtracting 1 from the
    argument.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Now look at `greetB`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function uses a pattern. The first pattern is `greetB 1`, meaning that
    if the argument is one, the pattern matches, so call `hello`. The pipe (`|`) marks
    the beginning of the next pattern. This pattern is checked if the previous pattern
    fails to match. Here, the pattern is any `n` that isn’t 1\. In that case, call
    `hello` and then call `greetB` again with `n-1`. This second pattern will repeatedly
    match until the first pattern matches. The first pattern returns nothing, so the
    return value of all recursive calls is nothing. This is why SML tells us that
    `greetB` maps an integer to `unit`. As an exercise, try implementing the recursive
    factorial function using a pattern.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of Standard ML we’ll consider is *higher-order functions*.
    Higher-order functions are functions that accept functions as arguments. The most
    common higher-order function is `map`, which applies a function to every element
    of a list. Consider these examples:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first two definitions use currying to define `add3`, a function that adds
    3 to its argument. The next line uses `map` to apply `add3` to each element of
    the list `[0,1,2,3,4]`, producing `[3,4,5,6,7]`. The final example applies an
    unnamed function to prefix a list of strings using `^` , which concatenates two
    strings.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The function `map` is straightforward to understand. Let’s now look at two more
    higher-order functions supplied by SML. They go by the names `foldl` and `foldr`.
    Review the following and try to work out what they do.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The first line shows yet another way to define a function by assigning an unnamed
    function to a variable. The function `f` accepts two arguments and returns the
    first prepended by the second. Note the flip between `x` and `y`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line calls `foldr` with `f` and two arguments: the string `"a "` and
    a list of strings. The result is a string. The following statement uses `foldl`
    in place of `foldr`. It also produces a string, but the order of the strings in
    the list is reversed from the `foldr` example. Do you see the pattern?'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The `foldl` function traverses the list from left to right, so the `foldl` call
    is equivalent to
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: whereas `foldr` traverses from right to left
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The fold higher-order functions are useful numerically as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The notation `op+` refers to the binary addition operator, so the first line
    sums a list of integers. Likewise, `op*` is multiplication, meaning the second
    line calculates the product of a list of integers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to Standard ML, including an extensive library of data types.
    However, we’ve reviewed enough to get a feel for the language.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we compared programming languages to paleontology, a metaphor
    we’ll return to throughout the book. Then, we briefly explored 10 programming
    languages to understand how they approach the idea of coding. The selected languages
    either introduced fundamental concepts or programming paradigms, like object-oriented
    programming, or were novel simply because they were first. In some cases, the
    language was foundational to a collection of future languages, like ALGOL. Reviewing
    what was and is helps us see where we might go and puts us in a frame of mind
    conducive to what esolangs have to offer.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The vignettes in this chapter are superficial, but necessarily so. Let’s step
    back a bit now and consider what it means to be a programming language, to grasp
    at their essence.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
