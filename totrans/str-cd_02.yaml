- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CHERRY-PICKED REVIEW OF PROGRAMMING LANGUAGES
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This book’s primary goal is to explore new ways to think about coding. Doing
    so will help you become a better coder, regardless of what language you are using.
    To that end, it makes sense to review existing programming languages, especially
    the languages that first introduced a particular coding paradigm or strongly influenced
    later languages.
  prefs: []
  type: TYPE_NORMAL
- en: The languages discussed in this chapter are not esolangs. Instead, they are
    serious approaches to the process of coding, meaning the process of translating
    thought into something a computer can use to solve a problem. Some of these languages
    are still in use. Others flowered briefly and then died. Still others evolved
    into something new. All of these languages have things to teach us, in addition
    to being fun to learn about and work with.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin the chapter with a bit of programming language paleontology. Following
    that, we’ll consider the first programming languages. Even if you are still relatively
    new to coding, you already have a conception of what coding is and how to do it.
    That wasn’t always the case—the very idea of coding had to come from somewhere.
    It’s worth our time to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the chapter is a series of vignettes, in roughly chronological
    order, that introduce us to a collection of programming languages we should keep
    in the back of our minds as we move through the book. We’ll spend the next few
    chapters exploring select languages in still more detail before diving into esolangs
    proper.
  prefs: []
  type: TYPE_NORMAL
- en: There are thousands of programming languages (see *[http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm](http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm)*),
    so why this particular set? I selected languages that were important to the development
    of future languages and, as such, often represent a new conception of programming,
    or languages that were novel in some way that will help us when we get to esolangs.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the languages presented in this chapter were invented before the year
    2000\. Of course, that’s not to say programming language development stopped with
    Y2K. There are a plethora of new languages: Rust, Scala, Julia, Go, Kotlin, and
    Swift are all examples of languages developed after 2000\. There will be no end
    to developing new programming languages. However, the current trend in language
    design leans toward multi-paradigm languages that take the best of what came before
    and mix it in some way with the hope of creating synergy. In other words, something
    greater than the sum of its parts. This trend validates our review of older languages
    with novel ideas as that is precisely what new languages are doing.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Language Paleontology**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Paleontology, literally the study of ancient being, is concerned with the history
    of life on Earth as well as the equally important diversity of life, that is,
    the number and kind of species. An important event studied by paleontologists
    is the *Cambrian explosion*, which was the sudden appearance of a huge assortment
    of animals in the fossil record.
  prefs: []
  type: TYPE_NORMAL
- en: The best-known fossil site related to the Cambrian explosion, from a time just
    after it, is the Burgess Shale of western Canada. The Burgess Shale is a priceless
    fossil site, half a billion years old, where the soft body parts of a myriad of
    animals, most unlike any living today, are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Burgess Shale fauna, entirely marine, has familiar representatives, like trilobites,
    which are favorites of fossil collectors. But the real stars of the Burgess Shale
    are weird animals like *anomalocaris*, a large predator so unusual that its various
    body parts were originally classified as separate animals, or the five-eyed Opabinia,
    with its single, trunk-like arm and claw. Then there is Hallucigenia, a spiny,
    worm-like creature initially described upside down as if it were walking the sea
    floor on its spines.
  prefs: []
  type: TYPE_NORMAL
- en: Later life, which for us means more mainstream life, is definitely more familiar,
    if less diverse. Fish dominated the later Paleozoic seas and eventually wandered
    out of the water onto land to become the first tetrapods, a body plan that land-dwelling
    vertebrates from crocodiles to pterosaurs, dinosaurs, elephants, and humans have
    maintained virtually unchanged ever since.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A geologic time scale of programming languages*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](ch01.xhtml#ch01fig1) shows a time scale of geologic history with
    programming languages marked at various places.'
  prefs: []
  type: TYPE_NORMAL
- en: The silhouettes in [Figure 1-1](ch01.xhtml#ch01fig1) indicate the type of life
    dominant at the time. What is important for us is not so much the time scale,
    but the diversity of life. Modern life, signified by the mammals during the Cenozoic
    era, such as Smilodon, the famed sabre-toothed cat, and the mighty mammoth, are
    related to newer languages like Python, Java, and C#. These languages are familiar
    and not at all surprising to us.
  prefs: []
  type: TYPE_NORMAL
- en: For the Mesozoic we have dinosaurs, including Alectrosaurus, a hunter who terrorized
    the late Cretaceous. Also present are a living tank, Edmontonia, and Achelousaurus,
    the prehistoric equivalent of a buffalo, but with fearsome horns. Although different
    in some ways, and perhaps a bit old, dinosaurs are familiar, so I’ve placed C
    and C++ in their company. Lest you think I’m slighting C and C++, do remember
    that the dinosaurs ruled the land for more than 100 million years and continue
    to rule the air even now, for birds are dinosaurs.
  prefs: []
  type: TYPE_NORMAL
- en: The later Paleozoic era, the Age of Fishes, seems a good place for unusual,
    but still not entirely alien, programming languages like Forth, SNOBOL, and CLIPS,
    all three of which we’ll explore in this book. The fish silhouettes from the time
    are Eusthenopteron, the lobe-finned Sarcopterygii, and the jawless and armored
    Ostracoderm.
  prefs: []
  type: TYPE_NORMAL
- en: The Burgess Shale, the time of Anomalocaris, Opabinia, and Hallucigenia, is
    also marked. The diversity and unusual body plans of the Burgess Shale seem a
    perfect analogy for esolangs—experimental, perhaps evolutionary dead ends, but
    important all the same because they pushed the boundaries of what could be, before
    natural selection’s heavy hand decided who continued and who didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: To me, esolangs are like the weirdly wonderful animals of the Burgess Shale.
    Like those animals, esolangs are experiments, forays into what could be, existing
    and thriving even if not destined to endure. The animals of the Burgess Shale
    made paleontologists rethink and reevaluate how they approached ancient life.
    Similarly, esolangs, if we let them, make us rethink and reevaluate how we approach
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Esolangs are weird, often very strange and alien, but that’s the point. Like
    the beautifully bizarre animals of the Burgess Shale, esolangs explore niches
    in novel, unusual ways that might not be practical, but are definitely interesting
    and, most of all, fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it: geology and computer science living together, sans mass
    hysteria. Hopefully, [Figure 1-1](ch01.xhtml#ch01fig1) provides some food for
    thought, or at least an alternative viewpoint. We’ll refer to [Figure 1-1](ch01.xhtml#ch01fig1)
    from time to time throughout the book, but for now, let’s move on and explore
    the first programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The First Programming Languages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What was the first programming language? That’s a difficult question to answer
    without defining *programming language*. We’ll define what we mean by a programming
    language in [Chapter 2](ch02.xhtml#ch02). For now, we’ll use an intuitive definition:
    a programming language is a means by which an algorithm can be encoded to control
    a machine, specifically a computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Programming Before Computers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea of a programmable machine predates the idea of a programmable computer.
    The *Jacquard loom*, a loom that used punch cards for control, was introduced
    in 1804\. The pattern of dots on the card controlled the movement of threads in
    the loom to specify the pattern woven. There is a language there, something that
    can be varied to produce a different output. Change the pattern of holes on the
    card and a new pattern emerges from the machine. The rolls for a player piano
    work in much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the first “modern” computer design, Charles Babbage’s *Analytical Engine*,
    was influenced by the Jacquard loom. Although the Analytical Engine was never
    built, the engine had all the key components found in a modern computer and was
    programmable using punch cards. In 1843, while translating a set of lecture notes
    on the Analytical Engine from French to English, Ada Lovelace, Babbage’s long-time
    friend and daughter of the famous poet Lord Byron, wrote about the capabilities
    and potential uses of the Analytical Engine. She envisioned using the Analytical
    Engine for computation, but went further, imagining that the engine could be used
    for composing music and would release scientists from tedious computation, thereby
    freeing them for more advanced thinking. Ada was correct on both counts.
  prefs: []
  type: TYPE_NORMAL
- en: The translation, and more importantly, Ada’s insightful and brilliant notes,
    are in “Sketch of the Analytical Engine” in volume III of *Taylor’s Scientific
    Memoirs* (1843, pp. 666–731). An online search will quickly locate a PDF version.
    I highly recommend reading through Ada’s notes, at least Note A. However, Ada’s
    Note G is most important to us. There, she applied an algorithm to the engine
    to compute Bernoulli numbers to demonstrate how the engine would compute the result.
    Bernoulli numbers are used in different areas of mathematics, but how they are
    used is unimportant to us. What matters is that Ada took an algorithm and structured
    it for the Analytical Engine—that is, she wrote a program for a general-purpose
    computer. It then seems fair to claim that Ada wrote the world’s first computer
    program in 1843\. The programming language she used was the *diagram of development*
    notation she introduced in Note D.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) presents Ada’s program. It details the sequence
    of steps, the variables involved, and how they change during the computation.
    Various people have translated her program into modern programming languages.
    Of particular interest is that she seems to have made an error, the world’s first
    computer bug.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Ada Lovelace’s Analytical Engine program to calculate the eighth
    Bernoulli number (1843)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4 of [Figure 1-2](ch01.xhtml#ch01fig2) calculates `v5 / v4`; however,
    the correct calculation is `v4 / v5`. With that modification, translations into
    modern languages produce the correct result: *–* 1/30\. Translations into C and
    Python are available on the internet. To learn more about Ada’s life, I recommend
    *Ada’s Algorithm*, by James Essinger (Melville House, 2015). She was ahead of
    her time, even though her own life was so short.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The First Modern Programming Languages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first programming language in the modern sense was *Plankalk**ü**l*, developed
    by Konrad Zuse around 1943, 100 years after Ada’s first program. Plankalkül is
    German for “plan calculus” or “plan calculation.” Zuse used Plankalkül as a high-level
    programming language, though it was not implemented for any of his “Z” series
    computers. The language supported structured programming with `for` and `while`
    loops, floating-point arithmetic, arrays, and other features found in modern programming
    languages. Interestingly, the syntax of Plankalkül is 2D, with symbols written
    above other symbols. Zuse’s word for a program was “rechenplan,” which means “arithmetic”
    or “computation” plan. A good summary of Plankalkül can be found in “The Plankalkül
    of Konrad Zuse: A Forerunner of Today’s Programming Languages,” by Bauer and Wössner,
    Communications of the ACM 15, no. 7 (1972).'
  prefs: []
  type: TYPE_NORMAL
- en: Lovelace and Zuse, respectively, deserve credit for the first program and the
    first programming language. But neither program nor language worked on actual,
    physical computers. The first programming language for a working computer is likely
    up for much debate. Early computers like ENIAC were programmed by rewiring. The
    Manchester Baby, circa 1948, was the first stored-program computer, so in that
    sense, it had a programming language—the instructions stored in its memory. We
    call the low-level instructions understood by a processor *machine language* or
    *machine code*. Machine code is a programming language, as are the assemblers
    that generate the machine code from *assembly language*.
  prefs: []
  type: TYPE_NORMAL
- en: Machine code and assembly aside, the first programming language used on an actual
    computer is probably *Short Code*, developed by John Mauchly in 1949 and implemented
    by William Schmitt for the UNIVAC I in 1950\. Short Code supported arithmetic,
    including branching and a set of library functions like square root and absolute
    value. Expressions were transliterated from algebra to code and then manually
    packed into six 2-byte groups to fit the 12-byte words of the UNIVAC. Short Code
    was interpreted and parsed the meaning of an instruction from a tokenized representation
    of the program. In other words, Short Code worked much like the BASIC that interpreters
    built into early home computers of the 1980s. Running on a computer from the 1950s,
    interpreted Short Code must have been exceedingly slow to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The first proper compiler, at least as credited by Knuth and Pardo in “The Early
    Development of Programming Languages” in *A History of Computing in the Twentieth
    Century* (Academic Press, 1980) is *AUTOCODE* by Alick E. Glennie at the University
    of Manchester, circa 1950–52\. Unlike Short Code, AUTOCODE was compiled, meaning
    it was translated into equivalent machine code instructions. Visually, AUTOCODE
    looks a bit like machine code with text thrown in here and there.
  prefs: []
  type: TYPE_NORMAL
- en: 'While AUTOCODE and its successors were under development in the UK, in the
    US, Grace Hopper, Margaret H. Harper, and Richard K. Ridgeway were working on
    their compilers for the UNIVAC: A-0 to A-2\. In 1954, John Backus defined “The
    IBM Mathematical FORmula TRANslating system, FORTRAN,” and by 1957, the first
    *FORTRAN* compiler was released.'
  prefs: []
  type: TYPE_NORMAL
- en: The development of FORTRAN was a watershed moment. Programming language design
    kicked into high gear in the late 1950s. Most notable of the languages defined
    in the later 1950s, besides FORTRAN, is John McCarthy’s *Lisp* in 1958\. It is
    truly impressive that both FORTRAN and Lisp are still in widespread use today.
    High-performance computing (HPC) makes frequent use of FORTRAN. Later in the book,
    we’ll use a version of Lisp to implement a *FRACTRAN* interpreter. We’ll focus
    on FRACTRAN, perhaps the most unusual of esolangs, in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last pre-1960 programming language of note is *COBOL*. It was designed
    by a committee in 1959, with the first version appearing a year later. Rightly
    or wrongly, COBOL is still in use today. Unlike FORTRAN, a language for research
    scientists, and Lisp, a language for computer scientists, COBOL was a language
    intended for business use. COBOL programs are highly structured, rigid, and verbose.
    For example, consider this snippet from the COBOL 60 report defining the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The early years of programming language development resulted in the basic form
    and concept of a general-purpose programming language. The three critical languages
    to come out of this era are FORTRAN, Lisp, and COBOL. All three are still in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'FORTRAN was a natural choice for what is still a primary use of computers:
    number crunching. COBOL is an early example recognizing that commercial use of
    computers was something apart from their scientific use. Lisp was far in advance
    of its time, but slow, resource-limited computers made it difficult for Lisp to
    live up to its potential.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now examine 10 different programming languages. These languages represent
    major transitions in the evolution of programming languages because of what they
    introduced or how they grew in popularity or opened the arcane art of coding to
    a larger population.
  prefs: []
  type: TYPE_NORMAL
- en: '**ALGOL**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first language we’ll consider, *ALGOL*, gave rise to entire generations
    of programming languages and still influences programming languages today. ALGOL,
    like COBOL, was designed by committee.
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGOL is a compiled, structured, imperative programming language, meaning it
    looks familiar to modern programmers. Subsequent programming languages inspired
    by ALGOL include Simula, PL/I, and Pascal, all mentioned later. ALGOL captured
    the essentials of what *imperative programming* is: a structured way to give step-by-step
    instructions to the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-1](ch01.xhtml#ch01list1) is a simple program to compare two integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: Comparing numbers in ALGOL 68*'
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing the language, the form should be familiar to you if you
    know any modern structured programming language. Notice that the program begins
    with `(` and ends with `)` instead of `BEGIN` and `END`. The latter works as well
    and is what users of Pascal or Modula-2 expect to see, but ALGOL’s free-form approach
    allows parentheses to denote code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in trying ALGOL, you should look to Marcel van der Veer’s
    “Algol 68 Genie” implementation (see *[https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html](https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html)*),
    which runs on Linux and Windows. You’ll find extensive documentation on his site,
    all you need to learn the language. The Ubuntu package is `algol68g`. [Listing
    1-1](ch01.xhtml#ch01list1) is in *bigger.a68*. To run it, enter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-3](ch01.xhtml#ch01fig3) shows ALGOL’s descendants.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The ALGOL family tree*'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, programming languages can have multiple influences, but this tree
    seems quite reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: '**APL**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1962, Kenneth E. Iverson published *A Programming Language*, detailing a
    new programming language designed with arrays in mind that, in a show of boundless
    creativity, came to be called *APL*. One of the defining characteristics of APL
    is its nonstandard character set. That fact sometimes turns off would-be learners.
    For us, Iverson’s use of alternative characters is an excellent reason to include
    APL in our list of programming languages. However, the real reason to include
    APL is that it was the first *array-processing language*. Array-processing is
    a paradigm we’ll encounter in a later chapter, but, in a nutshell, it involves
    wholesale operations on arrays in a compact way. For a modern comparison, consider
    Matlab or Python with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: APL sessions are typically interactive. [Listing 1-2](ch01.xhtml#ch01list2)
    shows GNU APL in action. The user’s input is indented and the system’s responses
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-2: APL in action*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of [Listing 1-2](ch01.xhtml#ch01list2) assigns (←) whatever *ι*100
    returns to the variable, *x*. APL’s many operators each have two modes. If used
    in a unary fashion (that is, on a single operand), then the use is *monadic*.
    If used in a binary fashion (on two operands), then the use is *dyadic*. In this
    case, the monadic use of *ι* returns the vector 1 2 3 4 5 6 7 8 9 10, which is
    exactly how it would be entered manually. Thus, the first line is equivalent to
    `x = np.arange(1,11)` in Python using NumPy. The second line in [Listing 1-2](ch01.xhtml#ch01list2)
    multiplies each element of *x* by 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dyadic form of *ι* searches for its second argument in the first. For example,
    consider the following APL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use the dyadic form of `?` to set *x* to a 10-element vector of random
    integers from 1 to 10, without repeats. Next, the dyadic form of *ι* searches
    *x* for the number 10 and returns its index, 5\. APL indexes from 1, not 0\. If
    the dyadic form of `?` returns vectors of random integers between 1 and some upper
    limit, what might the monadic form of `?` do? If you guessed return a random integer,
    you are correct: `?`*n* returns a random integer in [1, *n*].'
  prefs: []
  type: TYPE_NORMAL
- en: The second assignment in [Figure 1-2](ch01.xhtml#ch01fig2) sets *y* to a 4 ×
    4 matrix of random integers in [1, 100]. We use `?` to ask for 16 numbers, and
    then use *ρ* (rho) to reshape the 16-element vector into a 4 × 4 matrix before
    assigning it to *y*. To index a vector or array, use ![Image](Images/f0012-01.jpg)
    (vertical rectangle) as in 3 ![Image](Images/f0012-01.jpg) *x* to access the third
    element of vector *x* or 2 3 ![Image](Images/f0012-01.jpg) *y* to access *y*[23]
    of matrix *y*.
  prefs: []
  type: TYPE_NORMAL
- en: One quirk of APL is that expressions are evaluated from right to left, with
    no operator precedence rules. As a consequence, parentheses must be used to enforce
    desired behavior. For example, according to APL, the first of the two expressions
    below is completely correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Virtually every other programming language will tell you that both expressions
    equal 20 because multiplication is performed before addition. However, APL parses
    the first expression as “add 2 and 6 to get 8, then multiply by 3 to get 24.”
  prefs: []
  type: TYPE_NORMAL
- en: APL is compact and powerful but also cryptic, and thus comes with a high learning
    curve. This, to say nothing of the early difficulties in using its alternative
    character set, has limited its use. Perhaps because of these difficulties, Iverson
    and Roger Hui developed *J*, an ASCII version of APL in the early 1990s (*[https://www.jsoftware.com/](https://www.jsoftware.com/)*).
    J retains the power of APL and expands on its capabilities to be more useful on
    modern computer systems. However, like APL, J has a high learning curve, creating
    the potential for high reward in learning a new way to think about what it means
    to code.
  prefs: []
  type: TYPE_NORMAL
- en: '**BASIC**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost everyone who used a microcomputer in the 1980s is at least somewhat familiar
    with *BASIC*. The “Beginner’s All-purpose Symbolic Instruction Code” was developed
    at Dartmouth College in 1964 by John G. Kemeny and Thomas E. Kurtz. BASIC was
    originally an unstructured programming language, meaning it used gotos to control
    program flow, and was intended for students and non-professionals. In the late
    1970s, when the microcomputer revolution took off, most computers included BASIC,
    usually in ROM. The first programming language many current software engineers
    learned was unstructured BASIC on a personal computer from the 1980s. As a result,
    BASIC’s impact on software development is significant and continues to this day.
  prefs: []
  type: TYPE_NORMAL
- en: BASIC was interpreted and often stored in memory as tokens, much like Short
    Code, described above. BASIC lives on as *Visual Basic*, which uses structured
    programming and is fully object-oriented. Visual Basic is still one of the most
    widely used programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](ch01.xhtml#ch01list3) shows a simple BASIC program for the Apple
    II to simulate coin flips.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-3: An Applesoft BASIC program to simulate coin flips*'
  prefs: []
  type: TYPE_NORMAL
- en: BASIC used line numbers, required for every line, to provide targets for `GOTO`
    statements. Different dialects of BASIC provided various commands, but all had
    `GOTO` and many had `ON-GOTO` to provide a simple computed goto construct. BASIC
    also supported subroutines via `GOSUB`, though most did not support recursion.
    Although perhaps scoffed at by many more serious programmers back in the 1960s
    and onward, the fact that BASIC continues today validates its utility.
  prefs: []
  type: TYPE_NORMAL
- en: '**PL/I**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*PL/I (Programming Language 1*) was developed by IBM in the mid-1960s as a
    general-purpose programming language for all uses, scientific to business. As
    such, it competed directly with FORTRAN and COBOL. IBM has maintained PL/I and
    it’s currently available for IBM mainframe computers. The language itself is structured
    and imperative, and borrowed concepts from ALGOL, FORTRAN, and COBOL, as one might
    expect from a jack-of-all-trades language of the time. PL/I was in steady use
    from the late 1970s through the mid-1990s and represents one of the first languages
    intended to meet all programming needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though PL/I survives on IBM mainframes, its use elsewhere is negligible.
    New development in PL/I is likely equally insignificant. As an example of the
    language, [Listing 1-4](ch01.xhtml#ch01list4) shows a simple loop that outputs
    “Hello, world!” repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-4: A PL/I greeting*'
  prefs: []
  type: TYPE_NORMAL
- en: This example is quite readable, even now, though wordy, requiring four words
    to declare a simple integer variable. The influence of FORTRAN and ALGOL is evident
    via FORTRAN’s `DO` loop and ALGOL’s `END`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logo**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1967, Wally Feurzeig, Seymour Papert, and Cynthia Solomon gifted generations
    of students with *Logo*, a “simplified” version of Lisp intended to teach programming
    concepts. Logo, which means “word” or “thought” in Greek, is intended to foster
    thinking about programming, especially thinking about how the Logo turtle will
    behave given the commands the students enter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch01fig4) shows a simple Logo session. The user enters
    commands at the bottom of the screen, and the triangular “turtle” responds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/01fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Drawing with the Logo turtle*'
  prefs: []
  type: TYPE_NORMAL
- en: Most commands are easy to understand, even if you’ve never seen Logo before.
    The commands in [Figure 1-4](ch01.xhtml#ch01fig4) are, with comments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The inner `repeat` command draws a square with the turtle ending where it began.
    The 22.5 degree right turn tilts the turtle to draw another square. Since 16 ×
    22*.*5 = 360, 16 repetitions completes the pattern. The final instructions move
    the turtle off the pattern. Note that this particular Logo example is for Berkeley
    Logo. The exact form of the commands might be slightly different for another implementation.
    Logo is still used to teach programming concepts to children; see “Turtle Academy”
    (*[https://turtleacademy.com/](https://turtleacademy.com/)*). As Logo represents
    one of the first attempts to develop a programming language designed for teaching
    children, it deserves a place in our pantheon of languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simula**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first object-oriented language was *Simula*, developed by Kristen Nygaard
    and Ole-Johan Dahl. As the name suggests, Simula was first used for discrete-time
    simulations and evolved into a general-purpose language by 1967 (Simula 67). Simula
    brought the world classes, objects, and inheritance. The description that follows
    is specific to Simula 67\. I tested the examples with the GNU cim compiler (*[https://www.gnu.org/software/cim/](https://www.gnu.org/software/cim/)*),
    which is a bit tricky to build (at least version 5.1 is, which is the latest version
    available as of this writing). The cim compiler translates Simula to C before
    calling the standard gcc compiler to build the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: The “Hello, world!” program in Simula isn’t particularly impressive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It’s immediately clear that `OutText` prints something, and it’s reasonable
    to guess that `OutImage` acts like a newline, which it does. Structurally, Simula
    is part of the ALGOL family, with blocks denoted by `Begin` and `End` and semicolons
    to separate statements. Simula isn’t case sensitive, so `Begin` and `BEGIN` are
    equivalent. Comments begin with `comment` or an exclamation point and end with
    a semicolon, like other statements. If you’re familiar with Modula-2 or Pascal,
    then Simula syntax should look familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Simula is a structured language, like ALGOL, so both `for` and `while` control
    structures are present. Simula’s `for` is more flexible than in most other languages.
    For example, `for` iterates over a list of values, some of which may specify ranges.
    Consider the program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'which outputs a table of squares and cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `r` is 1 for the first two iterations of the loop, then runs from 3 through
    18 by threes, and ends with –12.
  prefs: []
  type: TYPE_NORMAL
- en: However, if this were all Simula offered, it wouldn’t be worth discussing. Simula’s
    true gift to the world is object-oriented programming ([Listing 1-5](ch01.xhtml#ch01list5)),
    for which both Nygaard and Dahl received the Turing Award in 2001.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-5: Using classes in Simula 67*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](ch01.xhtml#ch01list5) shows us how to define and use classes.
    We define two classes, `Person` and `Pal`, a subclass of `Person`. `Person` uses
    the familiar `class` keyword and then defines `first` and `last` names as type
    `text`, a string object, along with `age`, an integer. `Person` defines one method,
    `Print`, to print the person’s full name and age.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pal` is a subclass of `Person`. It adds `nickname` and overrides `Print` to
    output the nickname before throwing in the strange line'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: which is a way to call the `Print` method of the superclass, `Person`. The phrase
    `This Pal` is a reference to the object itself. It returns a reference to the
    current object much like `this` in C++. The phrase `Qua Person.Print` interprets
    the reference returned by `This Pal` as a `Person` object so the proper `Print`
    method is called. (“Qua” is derived from Latin and means “in the capacity of”
    or “as.”)
  prefs: []
  type: TYPE_NORMAL
- en: To use instances of these classes, we must create reference variables and then
    use `new` to assign the references to the actual instances. The `:-` operator
    assigns objects created on the heap to references. The `:=` operator assigns values
    to variables. Simula includes automatic garbage collection, so there is no need
    to delete objects when no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: To populate the objects, we use both `:-` and `:=`. Strings are objects, so
    `:-` assigns them to the `text` objects, whereas `:=` is used to assign `age`
    as it is an integer. First we populate the two instances of the parent class,
    `Fred` and `Barney`, with names and ages. Then we populate the two `Pal` subclass
    instances, `Wilma` and `Betty`, in much the same way, this time including nicknames.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of all of [Listing 1-5](ch01.xhtml#ch01list5) is to call the `Print`
    methods of the now populated objects, which produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the proper `Print` method is called on each object to produce the
    desired output string.
  prefs: []
  type: TYPE_NORMAL
- en: Simula was well ahead of its time. Object-oriented programming took well over
    a decade after Simula 67 to catch on and, arguably, 20 years to become widely
    employed in the commercial software world. Simula’s strong association with simulation
    hurt the adoption of the language. As we’ve seen here, Simula is much more than
    a simulation language and even now fits into what we expect an object-oriented
    language to be.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pascal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Niklaus Wirth released Pascal in 1970\. It is a direct descendant of ALGOL and
    was widely used into the 1980s, primarily to teach structured programming concepts.
    After unstructured BASIC, many software engineers learned Pascal as their first
    “serious” programming language. Early versions of the Macintosh operating system
    were written, at least partially, in Pascal. UCSD Pascal, followed by commercial
    products like Turbo Pascal, brought the language to microcomputers. As with BASIC
    above, Pascal has strongly influenced a generation of developers, to say nothing
    of programming language development as a whole, so it deserves a place in the
    pantheon as well.
  prefs: []
  type: TYPE_NORMAL
- en: Look again at [Figure 1-3](ch01.xhtml#ch01fig3). There are two main branches
    of the ALGOL family of languages, one based on C and the other on Pascal. The
    Pascal branch leads to Modula-2, which overcame Pascal’s shortcomings but was
    never particularly popular, at least in North America. Ada was created by the
    US Department of Defense (DoD) as a standard for all development in the 1980s
    (Ada is named after Ada Lovelace). The DoD required the use of Ada for projects
    from 1991 to 1997\. At present, Pascal has fallen into obscurity, and Modula-2
    and its descendants, along with Ada, are even less popular. However, Pascal lives
    on as Delphi/Object Pascal. As a straightforward, structured programming language
    without object-oriented abilities, there was little reason to select Pascal after
    the rise of C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-6](ch01.xhtml#ch01list6) gives us a feel for the language.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-6: Generating the sequence of nonsquare integers*'
  prefs: []
  type: TYPE_NORMAL
- en: Pascal looks quite similar to ALGOL and Simula. This particular program produces
    a table of 120 numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully at the table; do you see what isn’t there? The table contains
    every integer less than 132 *except* for all the perfect squares: 4, 9, 16, 25,
    36, 49, 64, 81, 100, and 121\. The program implements the sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which has the remarkable property of bypassing all perfect squares, as *n* is
    incremented from one.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal programs begin with `program` followed by a variable declaration section
    beginning with `var`. Here we define one integer variable, `n`. The body of the
    program is between `begin` at the beginning and `end.` at the end. Note that the
    period is required for the final `end`. Blocks of code are also enclosed within
    `begin` and `end`.
  prefs: []
  type: TYPE_NORMAL
- en: The body of this program is a single `for` loop running from 1 to 120\. The
    body of the loop is a `write` statement, which does not move to the next line
    when done. The number output is the equation above for the current value of *n*.
    The argument `:4` tells Pascal to right-justify the output in four spaces. The
    code also tells the program to move to the next line if `n` is a multiple of 10.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal was intended for teaching and wasn’t suitable for system-level programming
    without nonstandard extensions. Wirth enhanced Pascal to make Modula-2, which
    was suitable for system-level programming. However, Modula-2 never reached its
    full potential in the commercial world. Regardless, Wirth’s Pascal, and subsequent
    languages, rightfully earned him the Turing Award in 1984.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prolog**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most programming languages are imperative. That is, programs are a recipe, a
    series of “do this” followed by “now do that.” However, in *Prolog*, things are
    different. Prolog is a *declarative language*. Relationships are encoded as rules,
    and it’s up to the Prolog engine to figure out how to accomplish the goal of answering
    a user query. Prolog was created in 1972 by Alain Colmerauer and Robert Kowalski
    and is still in limited use today.
  prefs: []
  type: TYPE_NORMAL
- en: A Prolog program is a series of *facts*, *rules*, and *queries*. We’ll learn
    what these are in a bit. Thinking in Prolog is quite different from thinking in
    most languages. Imperative languages are natural, and object-oriented languages
    build on that. Even APL makes sense once you understand the odd characters. But
    Prolog is an entirely different beast. We’ll only scratch the surface of it here.
    Later in the book, we devote an entire chapter to CLIPS, which is somewhat like
    Prolog, so we’ll struggle with this mode of thinking then.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section presents two small Prolog examples. I used SWI-Prolog (*[https://www.swi-prolog.org/](https://www.swi-prolog.org/)*),
    which is most easily installed on Ubuntu by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please see the Prolog website for the macOS and Windows versions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Modeling Family Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The canonical Prolog example involves family relationships. Our example is in
    *family.pl*, with the most important parts shown in [Listing 1-7](ch01.xhtml#ch01list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-7: Family relationships in Prolog*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the code in [Listing 1-7](ch01.xhtml#ch01list7) before exploring
    what Prolog can do with it. The first portion of the code builds a knowledge base,
    which is a listing of facts. The code presents facts about the relationships between
    the classic Greek gods. For example, according to mythology, the parents of Cronus
    are Gaia and Uranus, so the knowledge base uses the lines `parent(uranus, cronus).`
    and `parent(gaia, cronus).` to state this.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Prolog doesn’t have a `parent` function’ thus, the statements are
    facts relating two *atoms*. Atoms are generic names, a collection of characters
    treated as a symbol and acting as a single unit. There is a relationship called
    `parent` and `gaia` and `cronus` share it. We read the fact as “Gaia is the parent
    of Cronus.” Similarly, the knowledge base also labels the sex of the gods. Read
    `female(hera).` as “Hera is female.” Notice that facts, and later rules and queries,
    end with a period. The knowledge base identifies the sex, parents, and whether
    or not two gods were considered married. Again, these are the facts that Prolog
    will work with. To do anything interesting, we need some rules to go with the
    facts. That’s the second part of [Listing 1-7](ch01.xhtml#ch01list7).
  prefs: []
  type: TYPE_NORMAL
- en: Using family relationships helps because we are all so familiar with them. For
    example, we define a rule to decide if `X` is the father of `Y`, where atoms beginning
    with a capital letter are logical variables. Prolog will try to satisfy rules
    by locating values for these variables. The rule defines the relationship as “If
    *X* is the parent of *Y* and *X* is male, then *X* is the father of *Y*.”
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of `father(X,Y)` is true *if* the right-hand side is true.
    The right-hand side is true *if* `parent(X,Y)` is true *and* (comma) `male(X)`
    is true. Prolog uses a comma for “and” and a semicolon for “or.” With just this
    bit of knowledge, we can read the rest of the rules. A mother is a parent and
    female. Someone, `X`, is the child of `Y` if `Y` is the parent of `X`.
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `sibling` says two people are siblings if they share a parent.
    That much makes sense. The last part of the rule is `dif(X,Y)`. It adds “and *X*
    and *Y* are not the same” to the rule. This is there because we don’t normally
    think of ourselves as our own siblings.
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `wife` uses parentheses and a semicolon for “or.” `X` is a wife
    if she is female and married to `Y`. Prolog doesn’t intuitively know that the
    rule `married(X,Y)` implies `married(Y,X)`, so either case is checked.
  prefs: []
  type: TYPE_NORMAL
- en: The final rule is `paramour`, because, after all, we’re talking about ancient
    Greek gods. Here, `X` is a paramour of `Y` if `A` is a child of both `X` and `Y`,
    `X` and `Y` are not married (`\+` is like “not”), and `X` and `Y` are different.
    Read through the rules in [Listing 1-7](ch01.xhtml#ch01list7) until you feel comfortable
    with what they express.
  prefs: []
  type: TYPE_NORMAL
- en: Prolog programs are not loaded, but are rather *consulted*. The line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: consults *family.pl*, after which Prolog presents its prompt and waits patiently
    for user input. Let’s ask Prolog some questions about the gods and see if it can
    answer them based on the facts and rules we fed it (see [Listing 1-8](ch01.xhtml#ch01list8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-8: Exploring family relationships*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-8](ch01.xhtml#ch01list8) shows a Prolog session where *family.pl*
    has been consulted. User input is in bold with Prolog’s replies following. First,
    we ask Prolog if Zeus and Hera are married. Prolog replies `true`, as this is
    simply a fact in its knowledge base.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we ask Prolog to find an `X` such that `X` is the wife of Zeus. Notice
    that the rule is defined such that `X` is the wife of `Y` so the query is `wife(X,zeus)`
    and not `wife(zeus,X)` which would be asking the question “who is Zeus the wife
    of?” Prolog finds one match, one binding for `X` that makes the query true: Hera.
    The user then enters the bold semicolon. After Prolog finds a solution, if it
    can’t decide that there are no other solutions to the query on its own, it pauses
    and waits for the user to enter a semicolon to tell Prolog to search for more
    solutions. The final `false` is Prolog telling the user that no more solutions
    were found.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we ask Prolog, “Hera is the mother of who?” and we’re correctly told Ares,
    Hephaestus, and Eris. Next we ask, “Who is the mother of Hera?” and, again correctly,
    Prolog answers Rhea. The following query tells us that Rhea is also Zeus’s mother.
    The ancient gods certainly had complex family relationships.
  prefs: []
  type: TYPE_NORMAL
- en: We next ask Prolog to identify the children of Zeus. Specifically, we ask, “Zeus
    is the father of who?” and are correctly told he is the father of eight other
    gods, much to the annoyance of Hera.
  prefs: []
  type: TYPE_NORMAL
- en: A few more examples will drive home how Prolog works. [Listing 1-9](ch01.xhtml#ch01list9)
    shows Prolog’s response to the query “Who are Zeus’s paramours?”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-9: More family relationships*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Leto is listed twice. The rule for paramour is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: meaning that `X` and `Y` are paramours if they are not married and have a child
    together. In mythology, Zeus and Leto have twins, Apollo and Artemis. There-fore,
    Prolog finds that Leto and Zeus are paramours in two different ways, once for
    Apollo and again for Artemis. There are ways to capture responses and return only
    unique solutions, but using them here would only cloud the example. The final
    two queries in [Listing 1-9](ch01.xhtml#ch01list9) illustrate that Prolog can
    resolve queries involving grandparents and great-grandparents.
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Fibonacci Sequence***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our last Prolog example shows how it works with numeric data and its support
    for recursion. Specifically, we’ll implement the Fibonacci sequence,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'which is expressible recursively by saying that the next number is the sum
    of the previous two:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F[n]* = *F[n–]*[1] + *F[n–]*[2], *F*[1] = 1, *F*[2] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the Fibonacci sequence in more detail in [Chapter 13](ch13.xhtml#ch13).
    It’s an easy target for esolang examples. For now, we’ll use a recursive Python
    implementation as a guide for a Prolog version. In Python, the equation above
    can be implemented as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The *n*th Fibonacci number is the sum of the previous two, or if *n* is less
    than or equal to two, just one. This function tells us that *F*[11] = 89, which
    is correct. So how can we express the rule for the Fibonacci sequence in Prolog?
    To do so, we first need two facts that act as the base cases, *F*[1] = 1 and *F*[2]
    = 1\. Then we need to express the recursive relationship. [Listing 1-10](ch01.xhtml#ch01list10)
    has what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-10: Recursive Fibonacci numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: The two base cases are facts. The first Fibonacci number is 1, and the second
    is 1\. When Prolog is eventually trying to satisfy `fib(2,1)`, it will find the
    fact. The “return value” is the second number. The query to find the 11th Fibonacci
    number is `fib(11,F).` or “What F value makes `fib(11,F)` true?” That’s the 11th
    Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: The general rule is `fib(N,F)`. The body is the conjunction (that is, clauses
    linked by “and”) of several things. First, is it true that `N > 2`? Next come
    two “assignments,” which are true when `N1` is *n –* 1 and `N2` is *n –* 2\. So
    far, the statements make sense and are elements of the Python definition.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines, `fib(N1,F1)` and `fib(N2,F2)`, are strange at first. These
    are the recursive calls, as it were. The first seeks to find *F*[*n–*1] by finding
    an `F1` such that `fib(N1,F1)` is true. Likewise, the second does the same for
    *F*[*n–*2]. If these are found, then `F1` and `F2` have meaningful values, and
    the last line says that `F`, the actual number we’ve been looking for, is the
    sum of `F1` and `F2`, which must be the previous two Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for [Listing 1-10](ch01.xhtml#ch01list10) is in *fib.pl*. Let’s start
    Prolog, consulting *fib.pl*, and ask it for the 11th Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that our example works, as it gives us the same answer as the Python
    version. Now, ask for `fib(26,F)` and see how long it takes Prolog to answer.
    On my machine, Python answers immediately with 121,393\. Prolog also answers with
    121,393 but takes 29 seconds to do so. The double recursive call makes this Fibonacci
    implementation inefficient. However, Prolog’s exceedingly slow response validates
    a common criticism of the language: its performance. Moreover, the Unix utility,
    `top`, reported that during the search, Prolog used 0.5 percent of system memory,
    or about 42MB, which seems excessive for such a simple task.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing lets us watch Prolog work through a query. For example, here’s the output
    tracing the query `fib(3,F)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we activate `trace` and enter the query: `fib(3,F)`. At each step, Prolog
    pauses, waiting for a command. Pressing ENTER moves to the next step and displays
    `creep`. Therefore, each line above represents entering or exiting a subgoal of
    the rule. Temporary variables have names like `_4072`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the trace is the query with a temporary name for `F`. The
    `8` is similar to a call depth indicator, as it increases as the query is evaluated
    and decreases back to its initial value when the query is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: If you walk through the trace, you’ll see that each step works to satisfy the
    particular subgoal, that is, a part of the right-hand side of the rule. The first
    pair, for example, indicates that 3 > 2 is true. The second pair says that 2 =
    3 + (*–*1), which is also true. Interestingly, Prolog adds a –1 instead of subtracting
    1.
  prefs: []
  type: TYPE_NORMAL
- en: The first recursive call ➊ is immediately satisfied because `fib(2,1)` is a
    known fact, one of the base cases of the recursion. The second recursive call
    ➋ is similarly satisfied because `fib(1,1)` is also a fact.
  prefs: []
  type: TYPE_NORMAL
- en: With the recursive calls satisfied, the final subgoal, `F is F1 + F2`, can be
    satisfied with `F=2`. Thus, the query, `fib(3,2)`, is now satisfied and Prolog
    returns `F = 2`.
  prefs: []
  type: TYPE_NORMAL
- en: The trace for `fib(3,F)` produced 14 lines of output and the trace for `fib(26,F)`,
    which took nearly 30 seconds to return, produced 1,456,706 lines, reaching a maximum
    depth 24 above the base depth.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been a bit unfair to Prolog. The double recursive Fibonacci algorithm
    is inefficient because it is not *tail recursive*. A tail-recursive call is one
    in which the last invocation is the recursive part. Tail-recursive functions can
    be implemented without storing the current call’s stack frame. The recursion becomes
    essentially a jump to the beginning of the function without involving the call
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-11](ch01.xhtml#ch01list11) is a tail-recursive version of the Fibonacci
    program. You’ll find it in the file *fib_tail.pl*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-11: Fibonacci numbers using tail recursion*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the code uses two additional variables as accumulators: the
    second and third arguments. The base case is any call matching `fib(1,A,F,F)`,
    with `F` being the desired number, and `A` being any other value. Notice that
    the rule `fib(N,A,B,F)` has a recursive call as the final subgoal, unlike [Listing
    1-10](ch01.xhtml#ch01list10), which has two recursive calls, neither of which
    is the final subgoal. Prolog can use tail recursion here because there is nothing
    in the body to come back to.'
  prefs: []
  type: TYPE_NORMAL
- en: Run [Listing 1-11](ch01.xhtml#ch01list11) as `fib(26,0,1,F)` to find the 26th
    Fibonacci number. This time, Prolog will respond immediately with 121,383\. Then
    try `fib(266,0,1,F)` to see that Prolog supports arbitrary precision integers.
    The `trace` command will show you how the accumulators are used to ultimately
    arrive at a call matching `fib(1,A,F,F)`.
  prefs: []
  type: TYPE_NORMAL
- en: If our goal is to learn to think outside the box in terms of what it means to
    code, and it is, then Prolog promotes such thinking. Keep Prolog in the back of
    your mind. We’ll see a similar approach later when we discuss CLIPS in [Chapter
    6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: '**Smalltalk**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smalltalk came to be in the early 1970s, a product of the Learning Research
    Group at Xerox PARC. It was designed by Alan Kay, Dan Ingalls, and Adele Goldberg
    as a teaching language, much like Logo. Smalltalk is an object-oriented language.
    In fact, it is a *pure object-oriented language*, meaning that everything, even
    numbers, is an object. Pure object-oriented languages stand in contrast to impure
    languages like C++. In C++, *primitives*, such as integers, are not objects. Smalltalk
    objects communicate with each other by sending messages. If an object knows how
    to reply to a message, then that object is a valid receiver of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk classes support *duck typing* and may be extended at will. Duck typing
    allows any object that supports a particular method to be used where that method
    is expected. In other words, if it walks like a duck and quacks like a duck, it’s
    a duck.
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing the syntax, we can understand that `MyClass` in the following
    example defines a method, `A`, to square its argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At any later time, even if objects of `MyClass` already exist, a new method
    to calculate cubes may be added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `MyClass` class, including any existing objects, now knows how to use the
    method `B`.
  prefs: []
  type: TYPE_NORMAL
- en: Many Smalltalk systems include an extensive graphical interface. This includes
    Smalltalk-80, the version we’ll explore here. Modern Smalltalk systems, like Squeak
    (*[https://squeak.org/](https://squeak.org/)*) or Pharo (*[https://pharo.org/](https://pharo.org/)*),
    follow this tradition. If Smalltalk piques your curiosity, do take a look at one
    or both of these systems. However, the essence of the Smalltalk language is our
    focus, not its graphics abilities. Therefore, we’ll work with GNU Smalltalk, which
    is graphics-free.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along yourself, install GNU Smalltalk by typing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: On macOS, you can install Smalltalk by typing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For Windows users, I recommend a Linux virtual machine, Windows Subsystem for
    Linux, or, barring that, Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk supports integers, floating-point numbers, strings, and fractions
    (rationals). Smalltalk has 1D arrays, dictionaries, and many other container objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this vignette is to learn what makes Smalltalk unique and a good
    addition to our collection of novel programming languages. First comes a brief
    discussion of what Smalltalk brings to the table. Then we’ll work through a complete
    Smalltalk program to understand, at least superficially, how classes are defined
    and subclassed. Specifically, we simulate a race between four different animals,
    each its own Smalltalk class: bird, wolf, frog, and snail.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Smalltalk Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GNU Smalltalk is intended for scripting, just like Python or Perl. For example,
    this code shows our first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first line is not standard Smalltalk. It’s the comment line used by Unix
    systems to make a script executable by pointing to its interpreter. Double quotes
    surround comments in Smalltalk, while single quotes surround strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for calling a method on an object is <object> <method> or
    <object> <method>: <argument>. Everything’s an object, including strings (even
    empty ones). Each line in the example above defines a string and then calls the
    `displayNl` method to print it. Notice the period at the end of each line. Smalltalk
    uses periods as statement separators. On a Unix-like system, `chmod a+x hello.st`
    makes *hello.st* executable. The GNU Smalltalk interpreter itself is `gst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can exit the interpreter with CTRL-D.
  prefs: []
  type: TYPE_NORMAL
- en: The expressions above should give you pause. Smalltalk evaluates from left to
    right without respect to operator precedence. Therefore, the first expression
    is interpreted as `2+3*6 = 5*6 = 30`. Recall that APL is similar but evaluates
    from right to left. In Smalltalk, use parentheses on expressions to enforce the
    desired evaluation ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk syntax is simple but leads to verbose statements. To define and make
    basic use of an array, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Smalltalk uses `:=` for assignment, so the first line declares `x` to be an
    array of five elements. Smalltalk variables default to `nil`. The second line
    is `x[0]=3` in most other languages. The method name is `at` and it accepts one
    argument, the index, and a keyword argument, `put`. Smalltalk arrays hold any
    object, as the remaining lines above demonstrate. Smalltalk indexes arrays from
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible Smalltalk would win first prize for the longest method name in
    a standard library. Consider the following, which counts how many times a substring
    appears in another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Graphical Smalltalk systems have a transcript window where messages are displayed.
    GNU Smalltalk uses this for normal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This little example illustrates several Smalltalk features. First, `Transcript`
    is the name of a class, so we’re using class-level methods, not instance methods.
    Second, Smalltalk uses a semicolon to call methods using the most recent class
    or object, which in this case is `Transcript`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An important concept in Smalltalk is the *block*, which is code between square
    brackets. Blocks are similar to unnamed functions, as they can be assigned to
    variables and later executed. They also form the body of Smalltalk’s control structures,
    which are nothing more than method calls on objects, like everything else in Smalltalk.
    Consider the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We define `b` to be a block. The block contains one statement to print a string.
    To execute the block, we call `value`, which prints the string. The second string
    in quotes is the value of the block, the last statement in it, which is the string
    here. In a running program, the second string would not be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks accept arguments and support local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to understand this example. First, we have `x`, defined outside
    of a block and set to a string. Next, we define block `b`. It accepts an argument,
    `i` (the colon is necessary), and defines a local variable, `y`. Local variables
    are listed between vertical bars (pipes). The body of the block sets `y` to the
    argument, `i`, then uses `y` to assign to `x` and `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block is executed with 42 as the argument. Then we look at the value of
    `x`, `z`, and `y`. What happened? The block updated `x`, which already existed
    outside of the block. It also defined `z` *outside* the block. We didn’t declare
    `z` to be local to the block, so it was defined globally. We did declare `y` to
    be local to the block, so it has no value outside of the block, hence `nil`. The
    moral of the story is: if you want what happens in the block to stay in the block,
    only use local variables. As an exercise, try this example in Python, defining
    a function called `b(i)` in place of the block. Variables defined in the function
    do not alter variables defined globally unless you use `global` explicitly. Smalltalk
    blocks allow unintended consequences, so care is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Structures**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Smalltalk has the expected control structures, but their syntax is unusual because
    they are really methods. Let’s look quickly at conditional statements, `while`
    loops, and iterated loops. We can’t cover all combinations, especially with iteration,
    but you’ll get the gist of what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine this short program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It asks the user for an integer by reading the next line from standard input
    and interpreting the resulting string as an integer before assigning it to `v`.
    Next, the code checks to see if `v` is less than 0, 0, or greater than 0 and sets
    the value of `a` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code above looks like an `if-then-else` construct, and it acts like one,
    but it isn’t one. It’s normal Smalltalk <object> <method>: <argument> syntax.
    The `ifTrue` method is applied to the Boolean returned by `(v < 0)`. If the Boolean
    is true, execute the block that sets `a` to –1\. Similarly, `ifFalse` fires if
    the Boolean value is not true. Nesting within the block is perfectly fine, so
    the first `ifFalse` block has its own pair of `ifTrue` and `ifFalse` method calls.'
  prefs: []
  type: TYPE_NORMAL
- en: In Smalltalk, `while` loops act similarly. Consider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: where, unlike `ifTrue`, `whileTrue` is applied to a block, `[i < 10]`. As expected,
    this code snippet displays the numbers 1 through 9\. The same output is generated
    by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: which loops for as long as the code block returns `false`. Note that `while`
    loops are applied to a block, so the block need not be just a simple Boolean expression,
    but need only return a Boolean value. The following is a perfectly valid loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: with the side effect of defining `x` and setting it to 100.
  prefs: []
  type: TYPE_NORMAL
- en: A basic `for` loop in Smalltalk is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As with `if` and `while`, the loop isn’t a construct; it’s a message `to` sends
    to the integer object, 1\. The first part creates an `Interval` object, which
    is the entity that understands the `do` message. For example, the following code
    produces the same output as the previous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the argument to `do` is a block, with `i` being the argument that
    becomes the loop control variable. Therefore, we can do something like the following
    if we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines `j` as an `Interval` object, the second defines `b` as
    a block (really a `BlockClosure` object), and the third uses `do` to apply the
    block to the interval.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve hit the essentials of Smalltalk, though honestly we’ve barely put our
    little toe in the water. Smalltalk has a simple syntax and an extensive class
    library that we’ve ignored. However, we must press on. Smalltalk is all about
    objects and classes. Let’s see how by going to the races.
  prefs: []
  type: TYPE_NORMAL
- en: '***Going to the Races***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll create a small class hierarchy and use it to race four animals against
    each other. Our plan is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a base class, `Animal`, that responds to messages common to all the animals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define four subclasses: `Bird`, `Wolf`, `Frog`, and `Snail`. The subclasses
    respond to messages based on how the animals move: `fly`, `run`, `hop`, and `crawl`,
    respectively. The class ignores messages that it doesn’t understand.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of each animal and send randomly selected messages to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the distance each animal has moved and declare a winner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is in *race.st*. We’ll present it in pieces as we walk
    through it. Please read through the full source code file first before proceeding.
    If you do, the discussion will be easier to follow. Recall that the first line
    of the file is not standard Smalltalk; it’s Unix-speak to run the file as a script.
    The `-g` option disables the occasional garbage collection message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the base class, `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'All Smalltalk classes are subclasses of something. The top of the object hierarchy
    is the class `Object`, so `Animal` subclasses from it. There are three member
    variables: `increment`, `distance`, and `letter`. There are three methods: `init`,
    `getDistance`, and `print`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `init` method accepts `inc` as an argument along with `letter`, a keyword
    argument. In Smalltalk, instances of a class are usually created with `new` and
    initialized later; however, this process is flexible. We’ll call `init` to set
    up our class instances. In this case, initialization sets the distance traveled
    to zero, the letter associated with the animal when printing, and how far the
    animal moves each time it does move.
  prefs: []
  type: TYPE_NORMAL
- en: The next method is `getDistance`. It returns the current value of `distance`.
    Smalltalk does not have a return statement; rather, it precedes the value to return
    with a carat (`^`).
  prefs: []
  type: TYPE_NORMAL
- en: The final method, `print`, displays the animal’s distance traveled as a sequence
    of dashes ending with the animal’s letter. It uses `timesRepeat`, a message sent
    to an integer to repeat a code block a set number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '`Animal` defines the base class. The specific animal classes come next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each class defines `init`, which calls `init` of the superclass, `Animal`, passing
    in the increment and letter associated with the animal. For `Bird`, the increment
    is `6` and the letter is `'B'`.
  prefs: []
  type: TYPE_NORMAL
- en: Each subclass defines a method based on how the animal moves. For `Bird`, it’s
    `fly`. The move method adds the increment to the distance. The last method in
    each subclass is `doesNotUnderstand`. This method is called by Smalltalk when
    an object receives a message it has no method for. For example, if we pass the
    `fly` method to a `Wolf` object, `doesNotUnderstand` is be called. We want to
    ignore unknown messages, so the body of the method is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The classes are defined, but no instances have been created. Let’s create an
    instance of each and store the objects in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Each element of the array `animals` is set to the object returned by calling
    `new`. Doing this creates the objects, but they are not yet initialized. The final
    line loops over the array, calling each object’s `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: The animals are ready, so let’s run the race.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four movement methods: `fly`, `run`, `hop`, and `crawl`. We want
    to select one of them at random and send it to each animal. If the animal knows
    how to respond to the message, it does; otherwise, it quietly ignores it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `moves` is set to an array of the method names. This syntax is a shortcut
    for the `at:put:` syntax used above. The `timesRepeat` loop sets the number of
    moves that will happen. The interval, `(1 to: 4)`, is sent `atRandom` to return
    a random integer in [1,4]. This is the index in `moves` to set `m` to a randomly
    selected method string. The `do` loop sends the message in `m` to each animal
    by first converting the string to a symbol representing the method before passing
    it to the object itself via `perform`. Because each animal only responds to one
    of the move messages, only one animal will move during each pass through the `timesRepeat`
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The race is now over. To see how the animals did, we use the code below to
    call the `print` method of each animal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To declare a winner, we need to find which of the four moved the farthest. For
    that, we’ll use a `Dictionary`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: where the keys are the object instances and the values are the distance each
    animal moved. To declare a winner we find the maximum distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To loop over a dictionary, use `associationsDo`, which passes a key-value pair
    to the body of the loop. The `value` of the pair is the distance that animal traveled
    and the `key` is a reference to the object. The phrase `class displayString` converts
    the name of the object class to a string for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of *race.st* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The bird will win most often as it flies the farthest each time it moves. The
    wolf wins next most often and the snail least often. The file *run.py* runs 10,000
    races tracking how often each animal wins. For example, one run produced
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The bird won nearly 64 percent of the races, followed by the wolf, who won 28
    percent. The poor snail only won about one race in two hundred.
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard ML**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our final language is *Standard ML* (SML), an early functional language based
    on ML. *Functional languages* use composition of functions—that is, functions
    applied to the output of other functions—to implement algorithms. We’ll get to
    what makes SML a functional language in a later chapter when discussing programming
    language paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The version of SML we’ll work with, SML-NJ (NJ stands for “New Jersey”) largely
    conforms to the language standard promulgated in 1997 (*[https://smlfamily.github.io/sml97-defn.pdf](https://smlfamily.github.io/sml97-defn.pdf)*).
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, install SML on Ubuntu using the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Versions for macOS and Windows are available at *[http://www.smlnj.org/dist/working/110.99/index.html](http://www.smlnj.org/dist/working/110.99/index.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: Run sml to start the interpreter. As with Smalltalk, use CTRL-D to exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the version number is at least that shown here. The interpreter
    is waiting for us to type something; try `"scary movie";`. The interpreter responds
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that `"scary movie"` is of type `string`. Moreover, the interpreter
    has defined the variable `it` and assigned the string to `it`. SML statements
    end with a semicolon and SML is a typed language; however, one of its strengths
    is that it infers types in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'One characteristic of functional languages like SML is *referential transparency*,
    meaning that a function returns the same value for the same input regardless of
    the state of the system as a whole. For example, consider the following Python
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The value returned by `f(y)` depends on the current value of the variable `x`.
    Now consider the equivalent in SML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the function uses the value of `x` as it was when the function
    was defined. Changing `x` later does not affect the function value. SML is referentially
    transparent, but Python is not. SML functions are defined with `fun`, followed
    by the function name and argument list in parentheses. At least they can be defined
    that way. We’ll encounter other ways below.
  prefs: []
  type: TYPE_NORMAL
- en: 'SML supports the common primitive data types: integers, reals, and strings.
    It also supports lists and tuples, along with more advanced user-defined data
    structures resembling classes. Every member of an SML list must be of the same
    data type. Tuples may mix data types; however, SML functions consider tuples to
    be a compound type rather than a collection of the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: SML is perhaps the only language that requires you to write threatening code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: SML uses `orelse` where most other languages use `or`. So to check if one or
    the other conditional expression is true, you use `orelse`. Similarly, `andalso`
    replaces `and`.
  prefs: []
  type: TYPE_NORMAL
- en: SML supports *unnamed functions*, or *lambda functions* as they are sometimes
    called. For example, the following code defines an unnamed function to add 1 to
    its argument and then immediately applies it to the number 11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: SML treats functions as *first-class objects*. This means they can be assigned
    to variables and returned from functions. One use of this ability is to return
    a partially evaluated function in which some of the arguments are bound but others
    are not. This is known as *currying*, after Haskell Curry, an American mathematician
    who worked in logic. The Haskell programming language is named after him.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we see currying in action, consider the following two function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We define `add` twice with the second definition replacing the first. Both definitions
    take two arguments and add them together, so `add(11,22)` produces the same output
    as `add 11 22`. Look carefully at what SML returned after each function definition.
  prefs: []
  type: TYPE_NORMAL
- en: The first definition produced
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: which means that `add` is a function that accepts two integers and returns an
    integer. The second definition produced
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'meaning that `add` is now a function that accepts an integer and produces *a
    function* that accepts an integer and returns an integer. Defined in this form,
    `add` enables currying. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We define `add` as above and apply it to 11 to return a function that we then
    apply to 22 to get 33.
  prefs: []
  type: TYPE_NORMAL
- en: Currying allows us to fix the first argument, the `x`, and bind the returned
    function, now expecting only the `y`, to a variable. The new function, `add11`,
    accepts an integer argument and returns that argument plus 11\. Lastly, we see
    that `add11` is indeed a function mapping an integer to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'SML functions can use patterns, much like Prolog. For example, consider these
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This example is in the file *hello.sml*. You can load it with sml hello.sml
    or by entering use "hello.sml"; if you’re already in the interpreter. Either way,
    you’ll see SML’s output as to the functions and their types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `hello`, accepts no arguments and returns nothing. In SML,
    nothing is represented by `unit`. The `hello` function is used solely for its
    side effect of printing “Hello, world!” Therefore, `hello` accepts `unit` and
    returns `unit`. Both `greetA` and `greetB` accept an integer and return nothing,
    hence `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the definition of `greetA`. It uses a recursive call to `greetA` to
    print “Hello, world!” repeatedly. If the argument is 1, call `hello` and return.
    Otherwise, call `hello` then call `greetA` again after subtracting 1 from the
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now look at `greetB`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This function uses a pattern. The first pattern is `greetB 1`, meaning that
    if the argument is one, the pattern matches, so call `hello`. The pipe (`|`) marks
    the beginning of the next pattern. This pattern is checked if the previous pattern
    fails to match. Here, the pattern is any `n` that isn’t 1\. In that case, call
    `hello` and then call `greetB` again with `n-1`. This second pattern will repeatedly
    match until the first pattern matches. The first pattern returns nothing, so the
    return value of all recursive calls is nothing. This is why SML tells us that
    `greetB` maps an integer to `unit`. As an exercise, try implementing the recursive
    factorial function using a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of Standard ML we’ll consider is *higher-order functions*.
    Higher-order functions are functions that accept functions as arguments. The most
    common higher-order function is `map`, which applies a function to every element
    of a list. Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first two definitions use currying to define `add3`, a function that adds
    3 to its argument. The next line uses `map` to apply `add3` to each element of
    the list `[0,1,2,3,4]`, producing `[3,4,5,6,7]`. The final example applies an
    unnamed function to prefix a list of strings using `^` , which concatenates two
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: The function `map` is straightforward to understand. Let’s now look at two more
    higher-order functions supplied by SML. They go by the names `foldl` and `foldr`.
    Review the following and try to work out what they do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows yet another way to define a function by assigning an unnamed
    function to a variable. The function `f` accepts two arguments and returns the
    first prepended by the second. Note the flip between `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line calls `foldr` with `f` and two arguments: the string `"a "` and
    a list of strings. The result is a string. The following statement uses `foldl`
    in place of `foldr`. It also produces a string, but the order of the strings in
    the list is reversed from the `foldr` example. Do you see the pattern?'
  prefs: []
  type: TYPE_NORMAL
- en: The `foldl` function traverses the list from left to right, so the `foldl` call
    is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: whereas `foldr` traverses from right to left
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The fold higher-order functions are useful numerically as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The notation `op+` refers to the binary addition operator, so the first line
    sums a list of integers. Likewise, `op*` is multiplication, meaning the second
    line calculates the product of a list of integers.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to Standard ML, including an extensive library of data types.
    However, we’ve reviewed enough to get a feel for the language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we compared programming languages to paleontology, a metaphor
    we’ll return to throughout the book. Then, we briefly explored 10 programming
    languages to understand how they approach the idea of coding. The selected languages
    either introduced fundamental concepts or programming paradigms, like object-oriented
    programming, or were novel simply because they were first. In some cases, the
    language was foundational to a collection of future languages, like ALGOL. Reviewing
    what was and is helps us see where we might go and puts us in a frame of mind
    conducive to what esolangs have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: The vignettes in this chapter are superficial, but necessarily so. Let’s step
    back a bit now and consider what it means to be a programming language, to grasp
    at their essence.
  prefs: []
  type: TYPE_NORMAL
