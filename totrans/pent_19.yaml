- en: Chapter 15. Wireless Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ll take a brief look at wireless security. So far we’ve looked
    at several ways to breach the security perimeter. But web application security,
    firewalls, security-awareness training, and so on can do nothing to protect an
    internal network if there’s an attacker sitting on a bench in front of the target
    organization’s building and the organization provides wireless access with weak
    encryption to the internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the examples in this chapter, I’ll be using a Linksys WRT54G2 wireless router,
    but any router that supports WEP and WPA2 encryption will work. By default, my
    Linksys router has a web administration interface at *http://192.168.20.1*, as
    shown in [Figure 15-1](ch15.xhtml#linksys_wrt54g2_web_interface "Figure 15-1. Linksys
    WRT54G2 web interface"). The default username and password for the router is *admin:admin*.
    The default credentials vary from device to device, but it’s common on penetration
    tests to find routing equipment that still uses the default credentials—a failing
    that could allow attackers to gain administrative control over the routers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won’t cover attacking networking devices in this book, but take a look at
    the administrative interfaces on any networking equipment you have. Attacker access
    to enterprise network devices can do significant damage and should not be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linksys WRT54G2 web interface](httpatomoreillycomsourcenostarchimages2030486.png.jpg)Figure 15-1. Linksys
    WRT54G2 web interface'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll also be using an Alfa Networks AWUS036H USB wireless card. This card, and
    similar Alfa USB models, are ideal for wireless security assessments, particularly
    when working with virtual machines. VMware doesn’t have drivers for wireless cards,
    but it is capable of USB passthrough, allowing us to use the wireless drivers
    built into Kali Linux from a virtual machine. The use of a USB wireless card will
    allow us to assess wireless networks from our virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Available Wireless Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After attaching the Alfa wireless card to the Kali virtual machine, enter **`iwconfig`**
    to see the wireless interfaces available on your virtual machine. Note in my case
    that the Alfa card is attached as `wlan0` ❶, as shown in [Example 15-1](ch15.xhtml#kali_linux_wireless_interfaces
    "Example 15-1. Kali Linux wireless interfaces").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1. Kali Linux wireless interfaces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Scan for Access Points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can scan for nearby access points. The command `iwlist wlan0 scan` will
    scan for nearby access points using the `wlan0` interface, as shown in [Example 15-2](ch15.xhtml#scanning_for_nearby_wireless_access_poin
    "Example 15-2. Scanning for nearby wireless access points").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2. Scanning for nearby wireless access points
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From this initial scan we gather almost all the information we’ll need in order
    to attack the base station, as you’ll see later in the chapter. We have its MAC
    address ❶, the channel it’s broadcasting on ❷, we learn that it’s not using encryption
    at this time ❸, and we have its SSID ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before proceeding, let’s put our Alfa card into *monitor mode*. Much like promiscuous
    mode in Wireshark, monitor mode allows us to see additional wireless traffic on
    top of the traffic intended for our wireless card. We’ll use the *Airmon-ng* script,
    part of the Aircrack-ng wireless assessment suite, to put the Alfa card into monitor
    mode. First, make sure that no running processes will interfere with monitor mode
    by entering **`airmon-ng check`**, as shown in [Example 15-3](ch15.xhtml#checking_for_interfering_processes
    "Example 15-3. Checking for interfering processes").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3. Checking for interfering processes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Airmon found two running processes that could interfere. Depending
    on your wireless card and its drivers, you may or may not run into any trouble
    if you don’t kill off these programs. The card we’re using shouldn’t have trouble,
    but some USB wireless cards do. To kill all interfering processes in one step,
    enter **`airmon-ng check kill`**, as shown in [Example 15-4](ch15.xhtml#killing_interfering_processes
    "Example 15-4. Killing interfering processes").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4. Killing interfering processes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now enter **`airmon-ng start wlan0`** to switch the wireless interface into
    monitor mode, as shown in [Example 15-5](ch15.xhtml#putting_the_alfa_card_in_monitor_mode
    "Example 15-5. Putting the Alfa card in monitor mode"). This will allow us to
    capture packets not intended for us. Airmon-ng creates the wireless interface
    `mon0` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-5. Putting the Alfa card in monitor mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Capturing Packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our interface in monitor mode, let’s see what data we can gather using
    Airodump-ng from the Aircrack-ng suite. Airodump-ng is used to capture and save
    wireless packets. [Example 15-6](ch15.xhtml#starting_a_packet_dump_with_airodump-ng
    "Example 15-6. Starting a packet dump with Airodump-ng") shows how we tell Airodump-ng
    to use the wireless interface in monitor mode `mon0`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-6. Starting a packet dump with Airodump-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Airodump-ng output gathers information about the wireless packets, including
    the base service set identification (BSSID), which is the base station’s MAC address
    ❶. We also see additional information such as the encryption algorithm used for
    wireless security ❷ and the Service Set Identification (SSID) ❸. Airodump-ng also
    picks up the MAC addresses of connected clients ❹ and the MAC address of my host
    machine attached to the wireless access point. (We’ll examine the other fields
    in the Airodump-ng output as we move through cracking wireless security later
    in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we know the Linksys access point is open, with no security.
  prefs: []
  type: TYPE_NORMAL
- en: Open Wireless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open wireless networks are a real disaster from a security perspective because
    anyone within antenna range of the access point can connect to that network. While
    open networks could require authentication after connection, and some do, many
    just let anyone connect.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the wireless packets traveling through an open network are not encrypted,
    and anyone listening can see any data in plaintext. Sensitive data may be secured
    by protocols like SSL, but that’s not always the case. For instance, FTP traffic
    on an open wireless network is completely unencrypted, including login information,
    and we don’t even need to use ARP or DNS cache poisoning to capture the packets.
    Any wireless card in monitor mode will be able to see the unencrypted traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at attacking networks that deploy various security protocols
    that keep unwanted entities from connecting to the network and intercepting traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Wired Equivalent Privacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many routers that come with encryption enabled use older encryption called *wired
    equivalent privacy (WEP)* by default. The fundamental problem with WEP is that
    flaws in its algorithm make it possible for an attacker to recover any WEP key.
    WEP uses the Rivest Cipher 4 (RC4) stream cipher and a pre-shared key. Anyone
    who wants to connect to the network can use the same key, made up of a string
    of hexadecimal digits, for both encryption and decryption. The plaintext (unencrypted)
    data undergoes an exclusive or (XOR) bitwise operation with the keystream to create
    encrypted ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitwise XOR operation has four possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 XOR 0 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 XOR 0 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 XOR 1 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 XOR 1 = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zeros and ones in the bitstream in [Figure 15-2](ch15.xhtml#wep_encryption
    "Figure 15-2. WEP encryption") and [Figure 15-3](ch15.xhtml#wep_decryption "Figure 15-3. WEP
    decryption") can represent any data being sent over the network. [Figure 15-2](ch15.xhtml#wep_encryption
    "Figure 15-2. WEP encryption") shows how the plaintext is XORed with the keystream
    to create the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '![WEP encryption](httpatomoreillycomsourcenostarchimages2030488.png)Figure 15-2. WEP
    encryption'
  prefs: []
  type: TYPE_NORMAL
- en: When decrypted, the same keystream is XORed against the ciphertext to restore
    the original plaintext, as shown in [Figure 15-3](ch15.xhtml#wep_decryption "Figure 15-3. WEP
    decryption").
  prefs: []
  type: TYPE_NORMAL
- en: '![WEP decryption](httpatomoreillycomsourcenostarchimages2030490.png)Figure 15-3. WEP
    decryption'
  prefs: []
  type: TYPE_NORMAL
- en: The shared WEP key can be either 64 or 148 bits. In either case, an initialization
    vector (IV) makes up the first 24 bits of the key to add randomness, making the
    effective key length really only 40 or 104 bits. Adding randomness with an IV
    is common in cryptographic systems because if the same key is used repeatedly,
    attackers can examine the resulting ciphertext for patterns and potentially break
    the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cryptanalysts often find that randomness is not correctly implemented in cryptographic
    algorithms, as is the case with WEP. For starters, WEP’s 24 bits of randomization
    is minimal by modern cryptographic standards.
  prefs: []
  type: TYPE_NORMAL
- en: The IV and key are concatenated, then run through a key-scheduling algorithm
    (KSA) and a pseudorandom number generator (PRNG) to create the keystream. (I’ll
    skip the math here.) Next, an integrity check value (ICV) is computed and concatenated
    with the plaintext before encryption in order to prevent attackers from intercepting
    the ciphertexts, flipping some bits, and changing the resulting decrypted plaintext
    to something malicious or, at least, misleading. The plaintext is then XORed with
    the keystream (as shown in [Figure 15-2](ch15.xhtml#wep_encryption "Figure 15-2. WEP
    encryption")). The resulting packet is made up of the IV, the ICV, the ciphertext,
    and a two-bit key ID, as shown in [Figure 15-4](ch15.xhtml#wep_encryption-id00041
    "Figure 15-4. WEP encryption").
  prefs: []
  type: TYPE_NORMAL
- en: '![WEP encryption](httpatomoreillycomsourcenostarchimages2030492.png.jpg)Figure 15-4. WEP
    encryption'
  prefs: []
  type: TYPE_NORMAL
- en: Decryption is similar, as shown in [Figure 15-5](ch15.xhtml#wep_decryption-id00042
    "Figure 15-5. WEP decryption"). The IV and key (denoted by the key ID), stored
    in plaintext as part of the packet, are concatenated and run through the same
    key-scheduling algorithm and pseudorandom number generators to create a keystream
    identical to the one used for encryption. The ciphertext is then XORed with the
    keystream to reveal the plaintext and the ICV. Finally, the decrypted ICV is compared
    with the plaintext ICV value appended to the packet. If the values don’t match,
    the packet is thrown out.
  prefs: []
  type: TYPE_NORMAL
- en: '![WEP decryption](httpatomoreillycomsourcenostarchimages2030494.png.jpg)Figure 15-5. WEP
    decryption'
  prefs: []
  type: TYPE_NORMAL
- en: WEP Weaknesses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, WEP has some inherent problems that allow an attacker to recover
    a key or alter legitimate packets. In fact, every WEP key is recoverable by an
    attacker armed with enough ciphertexts encrypted with the same shared key. The
    only cryptosystem that is truly secure is a random one-time pad, which uses a
    specific key only once. The main trouble with WEP is that the 24-bit IV doesn’t
    introduce enough randomness; it has at most 2^(24) (that is, 16,777,216) values.
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard way for wireless cards and access points to compute IVs,
    and in practice, the IV space used may be even smaller. Either way, given enough
    packets, IVs will be reused, and the same value (static key concatenated with
    the IV) will be used to generate the ciphertext. By passively listening for traffic
    (or better yet, injecting traffic into the network to force more packets and,
    thus, more IVs to be generated), an attacker can gather enough packets to perform
    cryptanalysis and recover the key.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the ICV that attempts to keep attackers from intercepting the encrypted
    message, flipping bits, and changing the resulting plaintext is insufficient.
    Unfortunately, weaknesses in the ICV implementation Cyclic Redundancy Check 32
    (CRC-32) may allow attackers to craft the correct ICV for a modified message.
    Because CRC-32 is a linear algorithm, flipping a specific bit in the ciphertext
    has a deterministic result on the resulting ICV, and an attacker with knowledge
    of how CRC-32 is calculated could cause a modified message to be accepted. Thus,
    the ICV implementation, like the IV, is not considered sound by modern cryptographic
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Aircrack-ng suite to recover the shared key from a wireless network
    secured with WEP. Again, the math behind the cryptographic attacks is beyond the
    scope of this book. Luckily, we have tools that will take care of the hard stuff
    if we can capture the required traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WEP Keys with Aircrack-ng
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple ways to crack WEP keys, including the fake authentication
    attack, fragmentation attack, chopchop attack, caffé latte attack, and PTW attack.
    We’ll take a closer look at the fake authentication attack, which requires at
    least one legitimate client connected to the access point.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the host system to simulate an attached client. First, change the
    wireless security on your router to WEP (see your user guide if you need help),
    and then make sure your wireless card is in monitor mode so that you can capture
    traffic from the network without first authenticating.
  prefs: []
  type: TYPE_NORMAL
- en: Now to see what data we can collect using the Airodump-ng tool from Aircrack-ng.
    Tell Airodump-ng to use the wireless interface in monitor mode `mon0`, as shown
    in [Example 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi "Example 15-7. Airodump-ng
    capture for WEP cryptanalysis"), and use the `-w` flag to save all packets to
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-7. Airodump-ng capture for WEP cryptanalysis
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This initial scan gathers all the information we need to begin a WEP attack
    against the base station. Here we have the BSSID ❶, wireless channel ❷, encryption
    algorithm ❸, and the SSID ❹. We’ll use this information to gather the packets
    to crack the WEP key. Your own setup’s information is likely different, of course,
    but here’s what we’ll work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base Station MAC Address**: 00:23:69:F5:B4:2B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSID**: linksys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting Packets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the Airodump-ng output in [Example 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi
    "Example 15-7. Airodump-ng capture for WEP cryptanalysis") shows some traffic
    from the access point, to crack a 64-bit WEP key, we need about 250,000 IVs, and
    for a 148-bit WEP key, about 1,500,000\. Rather than idly listen for packets,
    we’ll capture and retransmit packets to the access point to generate unique IVs
    quickly. We need to authenticate, because if our MAC address isn’t authenticated
    with the access point, any packets we send will be dropped, and we’ll receive
    a deauthentication request. We’ll use Aireplay-ng to fake authentication with
    the access point and trick it into responding to our injected packets.
  prefs: []
  type: TYPE_NORMAL
- en: When using fake authentication, we tell the access point we’re ready to prove
    we know the WEP key, as shown in [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng"). Of course, because we don’t
    know the key yet, we don’t send it, but our MAC address is now on the list of
    clients that can send packets to the access point, hence the fake authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-8. Fake authentication with Aireplay-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We fake authentication using the following flags with their associated data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`-1`** tells Aireplay-ng to fake authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`0`** is the retransmission time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-e`** is the SSID; in my case `linksys`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-a`** is the MAC address of the access point we want to authenticate with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-h`** is the MAC address of our card (which should be on a sticker on the
    device).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`mon0`** is the interface to use for the fake authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After sending the Aireplay-ng request, you should receive a smiley face and
    indication that authentication was successful ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Generating IVs with the ARP Request Relay Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the base station willing to accept packets from us, we can capture and
    rebroadcast legitimate packets. While the access point won’t allow us to send
    traffic without first sending the WEP key to authenticate, we can rebroadcast
    traffic from properly authenticated clients.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the attack technique known as *ARP Request Replay* to generate IVs
    quickly by having Aireplay-ng listen for an ARP request and then retransmit it
    back to the base station. (When the access point receives an ARP request, it rebroadcasts
    it with a new IV.) Aireplay-ng will rebroadcast the same ARP packet repeatedly,
    and each time it’s broadcast, it will have a new IV.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay "Example 15-9. Rebroadcasting
    ARP packets with Aireplay-ng") shows the attack in action. Aireplay-ng reads packets
    looking for an ARP request. You won’t see any data until Aireplay-ng sees an ARP
    request it can rebroadcast. We will see that next.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-9. Rebroadcasting ARP packets with Aireplay-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We use these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`-3`** performs the ARP request replay attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-b`** is the base station MAC address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-h`** is our Alfa card MAC address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`mon0`** is the interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an ARP Request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, as you can see in [Example 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay
    "Example 15-9. Rebroadcasting ARP packets with Aireplay-ng"), we don’t see any
    ARP requests. To generate an ARP request, we’ll use the host system as a simulated
    client by pinging an IP address on the network from the connected host system.
    Aireplay-ng will see the ARP request and retransmit it to the access point over
    and over.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the Airodump-ng screen, shown in [Example 15-10](ch15.xhtml#ivs_being_captured_in_airodump-ng
    "Example 15-10. IVs being captured in Airodump-ng"), the `#Data` ❶ number, indicating
    captured IVs, increases rapidly as Aireplay-ng continues to retransmit the ARP
    packet, causing the access point to generate more IVs. (If your `aireplay-ng -3`
    says `"Got adeauth/disassoc"` or something similar and your `#Data` number is
    not quickly rising, run the fake association command from [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng") again to reassociate with
    the access point. Your `#Data` field should again start rising rapidly.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-10. IVs being captured in Airodump-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cracking the Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember, we need about 250,000 IVs to crack a 64-bit WEP key. As long as you
    remain associated with the base station, as shown in [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng"), (rerunning the command
    if it becomes necessary) and have generated an ARP request on the network, it
    should only take a few minutes to collect enough IVs. Once we’ve gathered enough
    IVs, we can use Aircrack-ng to do the math to turn the collected IVs into the
    correct WEP key. [Example 15-11](ch15.xhtml#recovering_the_wep_key_with_aircrack-ng
    "Example 15-11. Recovering the WEP key with Aircrack-ng") shows how we crack the
    key by using the `-b` flag and providing the filename we used in Airodump-ng followed
    by `*.cap` ❶. This tells Aircrack-ng to read from all .*cap* files saved by Airodump-ng.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-11. Recovering the WEP key with Aircrack-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds of analysis Aircrack-ng returns the correct key ❷. We can
    now authenticate with the network. If this were a pentest client’s network, we
    could now directly attack any systems on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with WEP Cracking
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with many topics discussed in this book, information about wireless attacks
    could fill a book, and I’ve shown you only one attack. One thing to keep in mind
    when attacking WEP is that clients may use filters in an attempt to thwart attacks
    like this. For example, access points could use MAC filtering to allow only wireless
    cards with certain MAC addresses to connect, and if your Alfa card isn’t on the
    list, your fake authentication attempt will fail. To bypass MAC filtering, you
    could use a tool like MAC Changer in Kali to spoof a MAC address and create an
    accepted value. Keep in mind that WEP keys are always crackable if we can gather
    enough packets, and for security reasons, WEP encryption should not be used in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the Wifite tool, installed by default in Kali Linux,
    behaves as a wrapper around the Aircrack-ng suite and will automate the process
    of attacking wireless networks, including cracking WEP. But while you are learning
    how Wi-Fi attacks work, it is better to walk through the process step by step
    instead of using an automation wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: We now turn our attention to the stronger wireless encryption protocols, WPA
    and WPA2.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Protected Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As weaknesses in WEP came to light, a more robust wireless security system was
    needed and a new system (which ultimately became WPA2) was built to replace WEP.
    However, the creation of a secure cryptographic system for wireless took time,
    and in the meantime, additional security was needed that was compatible with deployed
    wireless hardware. Thus, *Wi-Fi Protected Access (WPA)*, also known as *Temporal
    Key Integrity Protocol (TKIP)*, was born.
  prefs: []
  type: TYPE_NORMAL
- en: WPA uses the same underlying algorithm as WEP (RC4) but seeks to address WEP’s
    weaknesses by adding keystream randomness to IVs and integrity to ICV. Unlike
    WEP, which uses a 40 or 104-bit key combined with weak IVs for each packet, WPA
    generates a 148-bit key for each packet to ensure that each packet is encrypted
    with a unique keystream.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, WPA replaces WEP’s weak CRC-32 message integrity check with a
    message authentication code (MAC) algorithm called *Michael*, to prevent attackers
    from easily calculating the resulting changes to the ICV when a bit is flipped.
    Though both WPA and even WPA2 have their weaknesses, the most common vulnerability
    (which we’ll exploit later in this chapter) is the use of weak passphrases.
  prefs: []
  type: TYPE_NORMAL
- en: WPA2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WPA2 was built from the ground up to provide a secure encryption system for
    wireless networks. It implements an encryption protocol built specifically for
    wireless security called *Counter Mode with Cipher Block Chaining Message Authentication
    Code Protocol (CCMP)*. CCMP is built on the Advanced Encryption Standard (AES).
  prefs: []
  type: TYPE_NORMAL
- en: WPA and WPA2 support both personal and enterprise setups. WPA/WPA2 personal
    uses a pre-shared key, similar to WEP. WPA/WPA2 enterprise adds an additional
    element called a *Remote Authentication Dial-In User Service (RADIUS) server*
    to manage client authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The Enterprise Connection Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In WPA/WPA2 enterprise networks, the client connection process comprises four
    steps, as shown in [Figure 15-6](ch15.xhtml#wpasoliduswpa2_enterprise_connection
    "Figure 15-6. WPA/WPA2 enterprise connection"). First the client and the access
    point agree on mutually supported security protocols. Then, based on the authentication
    protocol chosen, the access point and the RADIUS server exchange messages to generate
    a master key. Once a master key is generated, a message that authentication was
    successful is sent to the access point and passed on to the client, and the master
    key is sent to the access point. The access point and the client exchange and
    verify keys for mutual authentication, message encryption, and message integrity
    via a four-way handshake, as discussed in [The Four-Way Handshake](ch15.xhtml#four-way_handshake
    "The Four-Way Handshake") on this page. Following key exchange, traffic between
    the client and the access point is secured with WPA or WPA2.
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA/WPA2 enterprise connection](httpatomoreillycomsourcenostarchimages2030496.png.jpg)Figure 15-6. WPA/WPA2
    enterprise connection'
  prefs: []
  type: TYPE_NORMAL
- en: The Personal Connection Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The WPA/WPA2 personal connection process is slightly simpler than the enterprise
    one: No RADIUS server is required, and the entire process is between the access
    point and the client. No authentication or master key step occurs, and instead
    of a RADIUS server and master key, WPA/WPA2 personal use pre-shared keys, which
    are generated using pre-shared passphrases.'
  prefs: []
  type: TYPE_NORMAL
- en: The WPA/WPA2 personal passphrase that you enter when you connect to a secured
    network is static, whereas enterprise setups use dynamic keys generated by the
    RADIUS server. Enterprise setups are more secure, but most personal networks and
    even most small businesses lack RADIUS servers.
  prefs: []
  type: TYPE_NORMAL
- en: The Four-Way Handshake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first phase of the connection between an access point and supplicant
    (client), a pairwise master key (PMK), which is static throughout the entire session,
    is created. This is not the key that will be used for encryption itself, but it
    will be used during the second phase, where a four-way handshake will take place
    between access point and client, with the purpose of establishing a channel of
    communication and exchanging the encryption keys used for further data communication,
    as shown in [Figure 15-7](ch15.xhtml#wpasoliduswpa2_four-way_handshake "Figure 15-7. WPA/WPA2
    four-way handshake").
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA/WPA2 four-way handshake](httpatomoreillycomsourcenostarchimages2030498.png.jpg)Figure 15-7. WPA/WPA2
    four-way handshake'
  prefs: []
  type: TYPE_NORMAL
- en: 'This PMK is generated from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The passphrase (pre-shared key, or PSK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access point’s SSID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSID length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of hashing iterations (4096)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting length in bits (256) of the generated shared key (PMK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values are fed into a hashing algorithm called PBKDF2, which creates
    a 256-bit shared key (PMK). While your passphrase (PSK) may be *GeorgiaIsAwesome*,
    this is not the PMK that will be used in a second phase. That said, anyone who
    knows the passphrase and the access point’s SSID can use the PBKDF2 algorithm
    to generate the correct PMK. During the four-way handshake, a pairwise transient
    key (PTK) is created and used to encrypt traffic between the access point and
    the client; a group transient key (GTK) is exchanged and used to encrypt broadcast
    traffic. The PTK is made up of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The shared key (the PMK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random number (nonce) from the access point (ANonce)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonce from the client (SNonce)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MAC address of the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MAC address of the access point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values are fed into the PBKDF2 hashing algorithm to create the PTK.
  prefs: []
  type: TYPE_NORMAL
- en: To generate the PTK, the access point and the client exchange MAC addresses
    and nonces (random values). The static shared key (PMK) is never sent over the
    air, because both the access point and the client know the passphrase (PSK) and,
    thus, can generate the shared key independently.
  prefs: []
  type: TYPE_NORMAL
- en: The shared nonces and MAC addresses are used by both the client and the access
    point to generate the PTK. In the first step of the four-way handshake, the access
    point sends its nonce (ANonce). Next, the client chooses a nonce, generates the
    PTK, and sends its nonce (SNonce) to the access point. (The *S* in SNonce stands
    for supplicant, another name for the client in a wireless setup.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to sending its nonce, the client sends a message integrity code
    (MIC) to guard against forgery attacks. In order to compute the correct MIC, the
    passphrase used to generate the pre-shared key must be correct, or the PTK will
    be wrong. The access point independently generates the PTK based on the SNonce
    and MAC address sent by the client, then checks the MIC sent by the client. If
    it’s correct, the client has authenticated successfully, and the access point
    sends over the GTK plus the MIC to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth part of the handshake, the client acknowledges the GTK.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WPA/WPA2 Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike WEP, the cryptographic algorithms used in WPA and WPA2 are robust enough
    to stop attackers from recovering the key simply by capturing enough traffic and
    performing cryptanalysis. The Achilles’ heel in WPA/WPA2 personal networks lies
    in the quality of the pre-shared key (passphrase) used. If the Windows *Administrator*
    password you found during post exploitation is the same as the WPA or WPA2 personal
    passphrase or the passphrase is written on a whiteboard in the front office of
    the organization, it’s game over.
  prefs: []
  type: TYPE_NORMAL
- en: To try to guess a weak password, we first need to capture the four-way handshake
    for analysis. Recall that given the correct passphrase and the SSID of the access
    point, the PBKDF2 hashing algorithm can be used to generate the shared key (PMK).
    Given the PMK, we still need the ANonce, SNonce, and the MAC addresses of the
    access point and client to calculate the PTK. Of course, the PTK will differ for
    each client, because the nonces will differ in each four-way handshake, but if
    we can capture a four-way handshake from any legitimate client, we can use its
    MAC addresses and nonces to calculate the PTK for a given passphrase. For example,
    we can use the SSID and the passphrase *password* to generate a PMK, then combine
    the generated PMK with the captured nonces and MAC addresses to calculate a PTK.
    If the MICs comes out like the ones in the captured handshake, we know that *password*
    is the correct passphrase. This technique can be applied to a wordlist of possible
    passphrases to try to guess the correct passphrase. Luckily, if we can capture
    a four-way handshake and supply a wordlist, we have Aircrack-ng to take care of
    all the math.
  prefs: []
  type: TYPE_NORMAL
- en: Using Aircrack-ng to Crack WPA/WPA2 Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use Aircrack-ng to crack WPA/WPA2, first set up your wireless access point
    for WPA2 personal. Choose a pre-shared key (passphrase) and then connect your
    host system to your access point to simulate a real client.
  prefs: []
  type: TYPE_NORMAL
- en: To use a wordlist to try to guess the WPA2 pre-shared key (passphrase), we need
    to capture the four-way handshake. Enter **`airodump-ng -c 6`** for the channel,
    **`--bssid`** with the base station MAC address, **`-w`** to specify the filename
    for output (use a different filename than you used in the WEP cracking example),
    and **`mon0`** for the monitor interface, as shown in [Example 15-12](ch15.xhtml#airodump-ng_for_wpa2_cracking
    "Example 15-12. Airodump-ng for WPA2 cracking").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-12. Airodump-ng for WPA2 cracking
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the host is connected ❶. To capture a four-way handshake, we
    can either wait for another wireless client to sign on or speed up the process
    by kicking a client off the network and forcing it to reconnect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force a client to reconnect, use Aireplay-ng to send a message to a connected
    client telling it that it is no longer connected to the access point. When the
    client reauthenticates, we’ll capture the four-way handshake between the client
    and access point. The Aireplay-ng options we’ll need are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`-0`** means deauthentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`1`** is the number of deauthentication requests to send.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-a 00:14:6C:7E:40:80`** is the MAC address of the base station.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`-c 00:0F:B5:FD:FB:C2`** is the MAC address of the client to deauthenticate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 15-13](ch15.xhtml#sending_a_deauthentication_request_to_a "Example 15-13. Sending
    a deauthentication request to a client") shows the `aireplay-ng` command and the
    deauthentication request.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-13. Sending a deauthentication request to a client
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we return to the Airodump-ng window, as shown in [Example 15-14](ch15.xhtml#wpa2_handshake_captured_in_airodump-ng
    "Example 15-14. WPA2 handshake captured in Airodump-ng").
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-14. WPA2 handshake captured in Airodump-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the Airodump-ng capture sees a four-way handshake with a client, it records
    it in the first line of the captured output ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve captured the WPA2 handshake, close Airodump-ng, and open the *.cap*
    file in Wireshark with File4Open4*filename.cap*. Once in Wireshark, filter for
    the `eapol` protocol to see the four packets that make up the handshake, as shown
    in [Figure 15-8](ch15.xhtml#wpa2_handshake_packets_in_wireshark "Figure 15-8. WPA2
    handshake packets in Wireshark").
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA2 handshake packets in Wireshark](httpatomoreillycomsourcenostarchimages2030500.png.jpg)Figure 15-8. WPA2
    handshake packets in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes Aircrack-ng will claim that the handshake has been captured, but when
    you look at the packets in Wireshark, you will see you do not have all four messages.
    If this is the case, run the deauthentication attack again, as you will need all
    four messages to attempt to guess the correct key.
  prefs: []
  type: TYPE_NORMAL
- en: Now we create a wordlist like the ones we used in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks"), making sure that the correct WPA2 key is included in the list. The
    success of our attack against WPA2 is contingent on our ability to compare the
    hashed values for our passphrase with the values in the handshake.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the handshake, we can do the rest of the calculations to recover
    the key offline; we no longer need to be in range of the access point or send
    it any packets. Next we use Aircrack-ng to test the keys in the wordlist, specifying
    a list with the `-w` option, as shown in [Example 15-15](ch15.xhtml#recovering_a_wpa2_key_with_aircrack-ng
    "Example 15-15. Recovering a WPA2 key with Aircrack-ng"). Otherwise, the command
    is identical to cracking the WEP key. If the correct key is in the wordlist, it
    will be recovered with Aircrack-ng.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-15. Recovering a WPA2 key with Aircrack-ng
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the correct key is in our wordlist and is recovered ❶. This
    sort of dictionary attack against WPA/WPA2 can be prevented by using a strong
    passphrase, as discussed in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks").
  prefs: []
  type: TYPE_NORMAL
- en: Aircrack-ng is just one suite of tools for cracking wireless. It is ideal for
    beginners, because starting different tools for each step of the process will
    help you become familiar with how these attacks work. Other widely used Wi-Fi
    auditing tools that you may encounter are Kismet and Wifite.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Protected Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Wi-Fi Protected Setup (WPS)* was designed to allow users to attach their devices
    to secure networks with an eight-digit pin instead of a potentially long and complicated
    passphrase. When the correct pin is supplied, the access point sends over the
    passphrase.'
  prefs: []
  type: TYPE_NORMAL
- en: Problems with WPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last digit of the pin is a checksum for the previous seven digits, so the
    keyspace should be 10⁷, or 10,000,000 possible pins. However, when a pin is sent
    to the access point by the client, the validity of the first four digits and second
    four digits is reported separately. The first four digits are all in play, so
    there are 10,000 possibilities. Of the second four digits, only the first three
    are in play (1000 possible guesses), so it would take at most 11,000 guesses to
    brute-force the correct WPS pin. This decreases the time required to brute-force
    to under four hours. The only way to fix this issue is to disable WPS on the access
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking WPS with Bully
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kali provides tools that you can use to implement a brute-force attack against
    WPS. One such tool is Bully. We can use Bully to brute-force the WPS pin as well
    as test a specific pin. To use Bully we need the SSID, MAC address, and channel
    of the access point, which we found with `iwlist` at the beginning of this chapter.
    Use the `-b` flag to specify the MAC address, the `-e` flag for the SSID, and
    the `-c` flag for the channel, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Bully should be able to brute-force the pin in around four hours and recover
    the correct pre-shared PIN. WPS is enabled by default on many wireless access
    points and may be an easier way in than guessing a strong WPA/WPA2 passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireless security is an often-overlooked piece of an organization’s security
    posture. Time and money are put into securing the perimeter, deploying the latest
    firewalls and intrusion-prevention systems, but all this is for naught if an attacker
    can just sit at the coffee shop across the street with a strong antenna and join
    your corporate network. Wireless connections may save corporations from lawsuits
    by distracted employees tripping over Ethernet wires, but they introduce potential
    security vulnerabilities and should be audited regularly. In this chapter, we
    used Aircrack-ng to recover WEP and WPA2 personal wireless keys by eavesdropping
    on and injecting traffic into a wireless network, and we used Bully to brute-force
    a WPS pin.
  prefs: []
  type: TYPE_NORMAL
