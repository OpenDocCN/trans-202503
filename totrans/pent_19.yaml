- en: Chapter 15. Wireless Attacks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 15 章. 无线攻击
- en: In this chapter we’ll take a brief look at wireless security. So far we’ve looked
    at several ways to breach the security perimeter. But web application security,
    firewalls, security-awareness training, and so on can do nothing to protect an
    internal network if there’s an attacker sitting on a bench in front of the target
    organization’s building and the organization provides wireless access with weak
    encryption to the internal network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍无线安全。到目前为止，我们已经看了几种突破安全边界的方法。但如果有攻击者坐在目标组织大楼前的长椅上，而组织提供了弱加密的无线访问到内部网络，那么网络应用安全、火墙、信息安全培训等都无法保护内部网络。
- en: Setting Up
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: For the examples in this chapter, I’ll be using a Linksys WRT54G2 wireless router,
    but any router that supports WEP and WPA2 encryption will work. By default, my
    Linksys router has a web administration interface at *http://192.168.20.1*, as
    shown in [Figure 15-1](ch15.xhtml#linksys_wrt54g2_web_interface "Figure 15-1. Linksys
    WRT54G2 web interface"). The default username and password for the router is *admin:admin*.
    The default credentials vary from device to device, but it’s common on penetration
    tests to find routing equipment that still uses the default credentials—a failing
    that could allow attackers to gain administrative control over the routers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我将使用一台 Linksys WRT54G2 无线路由器，但任何支持 WEP 和 WPA2 加密的路由器都可以使用。默认情况下，我的 Linksys
    路由器具有一个 Web 管理界面，地址是 *http://192.168.20.1*，如 [图 15-1](ch15.xhtml#linksys_wrt54g2_web_interface
    "图 15-1. Linksys WRT54G2 网络界面") 所示。路由器的默认用户名和密码是 *admin:admin*。默认凭据因设备而异，但在渗透测试中，常常会发现路由设备仍然使用默认凭据——这会导致攻击者获得对路由器的管理控制。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won’t cover attacking networking devices in this book, but take a look at
    the administrative interfaces on any networking equipment you have. Attacker access
    to enterprise network devices can do significant damage and should not be overlooked.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖对网络设备的攻击，但请检查你所拥有的任何网络设备的管理接口。攻击者访问企业网络设备可能会造成严重损害，因此不容忽视。
- en: '![Linksys WRT54G2 web interface](httpatomoreillycomsourcenostarchimages2030486.png.jpg)Figure 15-1. Linksys
    WRT54G2 web interface'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![Linksys WRT54G2 网络界面](httpatomoreillycomsourcenostarchimages2030486.png.jpg)图
    15-1. Linksys WRT54G2 网络界面'
- en: I’ll also be using an Alfa Networks AWUS036H USB wireless card. This card, and
    similar Alfa USB models, are ideal for wireless security assessments, particularly
    when working with virtual machines. VMware doesn’t have drivers for wireless cards,
    but it is capable of USB passthrough, allowing us to use the wireless drivers
    built into Kali Linux from a virtual machine. The use of a USB wireless card will
    allow us to assess wireless networks from our virtual machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将使用一个 Alfa Networks AWUS036H USB 无线网卡。这个网卡以及类似的 Alfa USB 型号，非常适合用于无线安全评估，特别是在使用虚拟机时。VMware
    不支持无线网卡的驱动，但它支持 USB 直通功能，允许我们从虚拟机中使用 Kali Linux 内置的无线驱动。使用 USB 无线网卡可以让我们从虚拟机中评估无线网络。
- en: Viewing Available Wireless Interfaces
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看可用的无线接口
- en: After attaching the Alfa wireless card to the Kali virtual machine, enter **`iwconfig`**
    to see the wireless interfaces available on your virtual machine. Note in my case
    that the Alfa card is attached as `wlan0` ❶, as shown in [Example 15-1](ch15.xhtml#kali_linux_wireless_interfaces
    "Example 15-1. Kali Linux wireless interfaces").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Alfa 无线网卡连接到 Kali 虚拟机后，输入 **`iwconfig`** 以查看虚拟机上可用的无线接口。请注意，在我的案例中，Alfa 网卡连接为
    `wlan0` ❶，如 [示例 15-1](ch15.xhtml#kali_linux_wireless_interfaces "示例 15-1. Kali
    Linux 无线接口") 所示。
- en: Example 15-1. Kali Linux wireless interfaces
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-1. Kali Linux 无线接口
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Scan for Access Points
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描访问点
- en: Now we can scan for nearby access points. The command `iwlist wlan0 scan` will
    scan for nearby access points using the `wlan0` interface, as shown in [Example 15-2](ch15.xhtml#scanning_for_nearby_wireless_access_poin
    "Example 15-2. Scanning for nearby wireless access points").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扫描附近的接入点了。命令 `iwlist wlan0 scan` 将使用 `wlan0` 接口扫描附近的接入点，如 [示例 15-2](ch15.xhtml#scanning_for_nearby_wireless_access_poin
    "示例 15-2. 扫描附近的无线接入点") 所示。
- en: Example 15-2. Scanning for nearby wireless access points
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-2. 扫描附近的无线接入点
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From this initial scan we gather almost all the information we’ll need in order
    to attack the base station, as you’ll see later in the chapter. We have its MAC
    address ❶, the channel it’s broadcasting on ❷, we learn that it’s not using encryption
    at this time ❸, and we have its SSID ❹.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个初步扫描，我们几乎收集到了所有需要的信息，以便稍后在本章中进行攻击。我们有它的 MAC 地址 ❶，它广播的频道 ❷，我们了解到它目前没有使用加密
    ❸，还有它的 SSID ❹。
- en: Monitor Mode
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视模式
- en: Before proceeding, let’s put our Alfa card into *monitor mode*. Much like promiscuous
    mode in Wireshark, monitor mode allows us to see additional wireless traffic on
    top of the traffic intended for our wireless card. We’ll use the *Airmon-ng* script,
    part of the Aircrack-ng wireless assessment suite, to put the Alfa card into monitor
    mode. First, make sure that no running processes will interfere with monitor mode
    by entering **`airmon-ng check`**, as shown in [Example 15-3](ch15.xhtml#checking_for_interfering_processes
    "Example 15-3. Checking for interfering processes").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们将 Alfa 卡设置为*监视模式*。就像 Wireshark 中的混杂模式一样，监视模式允许我们看到除了专门为无线卡传输的流量之外的额外无线流量。我们将使用
    *Airmon-ng* 脚本，这属于 Aircrack-ng 无线评估工具套件的一部分，来将 Alfa 卡设置为监视模式。首先，确保没有正在运行的进程会干扰监视模式，通过输入
    **`airmon-ng check`**，如[示例 15-3](ch15.xhtml#checking_for_interfering_processes
    "示例 15-3. 检查干扰进程")所示。
- en: Example 15-3. Checking for interfering processes
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-3. 检查干扰进程
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, Airmon found two running processes that could interfere. Depending
    on your wireless card and its drivers, you may or may not run into any trouble
    if you don’t kill off these programs. The card we’re using shouldn’t have trouble,
    but some USB wireless cards do. To kill all interfering processes in one step,
    enter **`airmon-ng check kill`**, as shown in [Example 15-4](ch15.xhtml#killing_interfering_processes
    "Example 15-4. Killing interfering processes").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Airmon 找到了两个可能干扰的运行进程。根据你的无线卡和驱动程序，如果不终止这些程序，你可能会遇到一些问题。我们使用的这张卡应该不会有问题，但一些
    USB 无线卡可能会。如果你想一步终止所有干扰进程，可以输入 **`airmon-ng check kill`**，如[示例 15-4](ch15.xhtml#killing_interfering_processes
    "示例 15-4. 终止干扰进程")所示。
- en: Example 15-4. Killing interfering processes
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-4. 终止干扰进程
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now enter **`airmon-ng start wlan0`** to switch the wireless interface into
    monitor mode, as shown in [Example 15-5](ch15.xhtml#putting_the_alfa_card_in_monitor_mode
    "Example 15-5. Putting the Alfa card in monitor mode"). This will allow us to
    capture packets not intended for us. Airmon-ng creates the wireless interface
    `mon0` ❶.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入 **`airmon-ng start wlan0`** 来将无线接口切换为监视模式，如[示例 15-5](ch15.xhtml#putting_the_alfa_card_in_monitor_mode
    "示例 15-5. 将 Alfa 卡设置为监视模式")所示。这将允许我们捕获原本不属于我们的数据包。Airmon-ng 创建了无线接口 `mon0` ❶。
- en: Example 15-5. Putting the Alfa card in monitor mode
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-5. 将 Alfa 卡设置为监视模式
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Capturing Packets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获数据包
- en: With our interface in monitor mode, let’s see what data we can gather using
    Airodump-ng from the Aircrack-ng suite. Airodump-ng is used to capture and save
    wireless packets. [Example 15-6](ch15.xhtml#starting_a_packet_dump_with_airodump-ng
    "Example 15-6. Starting a packet dump with Airodump-ng") shows how we tell Airodump-ng
    to use the wireless interface in monitor mode `mon0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视模式下的接口上，我们来看一下使用 Aircrack-ng 套件中的 Airodump-ng 可以收集到什么数据。Airodump-ng 用于捕获并保存无线数据包。[示例
    15-6](ch15.xhtml#starting_a_packet_dump_with_airodump-ng "示例 15-6. 使用 Airodump-ng
    开始数据包转储")展示了如何告诉 Airodump-ng 使用监视模式下的无线接口 `mon0`。
- en: Example 15-6. Starting a packet dump with Airodump-ng
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-6. 使用 Airodump-ng 开始数据包转储
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Airodump-ng output gathers information about the wireless packets, including
    the base service set identification (BSSID), which is the base station’s MAC address
    ❶. We also see additional information such as the encryption algorithm used for
    wireless security ❷ and the Service Set Identification (SSID) ❸. Airodump-ng also
    picks up the MAC addresses of connected clients ❹ and the MAC address of my host
    machine attached to the wireless access point. (We’ll examine the other fields
    in the Airodump-ng output as we move through cracking wireless security later
    in the chapter.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Airodump-ng 输出收集有关无线数据包的信息，包括基础服务集标识符（BSSID），即基站的 MAC 地址 ❶。我们还会看到额外的信息，如用于无线安全的加密算法
    ❷，以及服务集标识符（SSID） ❸。Airodump-ng 还会获取连接客户端的 MAC 地址 ❹，以及我主机附着到无线接入点的 MAC 地址。（在本章稍后的无线安全破解过程中，我们将进一步检查
    Airodump-ng 输出中的其他字段。）
- en: Now we know the Linksys access point is open, with no security.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 Linksys 接入点是开放的，没有安全性。
- en: Open Wireless
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放无线
- en: Open wireless networks are a real disaster from a security perspective because
    anyone within antenna range of the access point can connect to that network. While
    open networks could require authentication after connection, and some do, many
    just let anyone connect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开放无线网络从安全角度来看是一个真正的灾难，因为任何在接入点天线范围内的人都可以连接到该网络。虽然开放网络在连接后可能需要身份验证，有些确实如此，但许多开放网络让任何人都能连接。
- en: Also, the wireless packets traveling through an open network are not encrypted,
    and anyone listening can see any data in plaintext. Sensitive data may be secured
    by protocols like SSL, but that’s not always the case. For instance, FTP traffic
    on an open wireless network is completely unencrypted, including login information,
    and we don’t even need to use ARP or DNS cache poisoning to capture the packets.
    Any wireless card in monitor mode will be able to see the unencrypted traffic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过开放网络传输的无线数据包是未加密的，任何监听的人都可以看到明文中的任何数据。敏感数据可能通过如SSL等协议进行加密，但这并非总是如此。例如，开放无线网络上的FTP流量是完全未加密的，包括登录信息，我们甚至不需要使用ARP或DNS缓存中毒来捕获数据包。任何处于监听模式的无线网卡都能够看到未加密的流量。
- en: Now let’s look at attacking networks that deploy various security protocols
    that keep unwanted entities from connecting to the network and intercepting traffic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看那些部署了各种安全协议的网络，这些协议可以防止不希望的实体连接到网络并截获流量。
- en: Wired Equivalent Privacy
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有线等效隐私（Wired Equivalent Privacy）
- en: Many routers that come with encryption enabled use older encryption called *wired
    equivalent privacy (WEP)* by default. The fundamental problem with WEP is that
    flaws in its algorithm make it possible for an attacker to recover any WEP key.
    WEP uses the Rivest Cipher 4 (RC4) stream cipher and a pre-shared key. Anyone
    who wants to connect to the network can use the same key, made up of a string
    of hexadecimal digits, for both encryption and decryption. The plaintext (unencrypted)
    data undergoes an exclusive or (XOR) bitwise operation with the keystream to create
    encrypted ciphertext.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 许多启用加密的路由器默认使用较老的加密方式，即*有线等效隐私（WEP）*。WEP的根本问题在于其算法的缺陷，使得攻击者能够恢复任何WEP密钥。WEP使用Rivest
    Cipher 4（RC4）流密码和一个预共享密钥。任何想要连接网络的人都可以使用相同的密钥，这个密钥由一串十六进制数字组成，用于加密和解密。明文（未加密）数据与密钥流进行异或（XOR）按位操作，生成加密的密文。
- en: 'The bitwise XOR operation has four possibilities:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或（XOR）操作有四种可能性：
- en: 0 XOR 0 = 0
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 XOR 0 = 0
- en: 1 XOR 0 = 1
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 XOR 0 = 1
- en: 0 XOR 1 = 1
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 XOR 1 = 1
- en: 1 XOR 1 = 0
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 XOR 1 = 0
- en: The zeros and ones in the bitstream in [Figure 15-2](ch15.xhtml#wep_encryption
    "Figure 15-2. WEP encryption") and [Figure 15-3](ch15.xhtml#wep_decryption "Figure 15-3. WEP
    decryption") can represent any data being sent over the network. [Figure 15-2](ch15.xhtml#wep_encryption
    "Figure 15-2. WEP encryption") shows how the plaintext is XORed with the keystream
    to create the ciphertext.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-2](ch15.xhtml#wep_encryption "图15-2. WEP加密")和[图15-3](ch15.xhtml#wep_decryption
    "图15-3. WEP解密")中的比特流的零和一可以表示任何通过网络传输的数据。[图15-2](ch15.xhtml#wep_encryption "图15-2.
    WEP加密")展示了明文如何与密钥流进行异或（XOR）操作，从而生成密文。'
- en: '![WEP encryption](httpatomoreillycomsourcenostarchimages2030488.png)Figure 15-2. WEP
    encryption'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![WEP加密](httpatomoreillycomsourcenostarchimages2030488.png)图15-2. WEP加密'
- en: When decrypted, the same keystream is XORed against the ciphertext to restore
    the original plaintext, as shown in [Figure 15-3](ch15.xhtml#wep_decryption "Figure 15-3. WEP
    decryption").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当解密时，使用相同的密钥流对密文进行异或操作，以恢复原始明文，如[图15-3](ch15.xhtml#wep_decryption "图15-3. WEP解密")所示。
- en: '![WEP decryption](httpatomoreillycomsourcenostarchimages2030490.png)Figure 15-3. WEP
    decryption'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![WEP解密](httpatomoreillycomsourcenostarchimages2030490.png)图15-3. WEP解密'
- en: The shared WEP key can be either 64 or 148 bits. In either case, an initialization
    vector (IV) makes up the first 24 bits of the key to add randomness, making the
    effective key length really only 40 or 104 bits. Adding randomness with an IV
    is common in cryptographic systems because if the same key is used repeatedly,
    attackers can examine the resulting ciphertext for patterns and potentially break
    the encryption.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 共享WEP密钥可以是64位或148位。在这两种情况下，初始化向量（IV）占密钥的前24位，以增加随机性，使有效密钥长度实际上仅为40位或104位。在加密系统中添加随机性是常见的做法，因为如果同一个密钥被重复使用，攻击者可以检查生成的密文是否存在模式，从而可能破解加密。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Cryptanalysts often find that randomness is not correctly implemented in cryptographic
    algorithms, as is the case with WEP. For starters, WEP’s 24 bits of randomization
    is minimal by modern cryptographic standards.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 密码分析师通常发现，密码算法中的随机性没有得到正确实现，就像 WEP 一样。首先，WEP 的 24 位随机化在现代密码学标准下是最小的。
- en: The IV and key are concatenated, then run through a key-scheduling algorithm
    (KSA) and a pseudorandom number generator (PRNG) to create the keystream. (I’ll
    skip the math here.) Next, an integrity check value (ICV) is computed and concatenated
    with the plaintext before encryption in order to prevent attackers from intercepting
    the ciphertexts, flipping some bits, and changing the resulting decrypted plaintext
    to something malicious or, at least, misleading. The plaintext is then XORed with
    the keystream (as shown in [Figure 15-2](ch15.xhtml#wep_encryption "Figure 15-2. WEP
    encryption")). The resulting packet is made up of the IV, the ICV, the ciphertext,
    and a two-bit key ID, as shown in [Figure 15-4](ch15.xhtml#wep_encryption-id00041
    "Figure 15-4. WEP encryption").
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化向量（IV）和密钥被连接起来，然后通过密钥调度算法（KSA）和伪随机数生成器（PRNG）生成密钥流。（这里省略数学部分。）接下来，计算出一个完整性校验值（ICV），并在加密之前将其与明文连接起来，以防止攻击者拦截密文、翻转某些位，并将解密后的明文更改为恶意或至少具有误导性的内容。然后，明文与密钥流进行异或操作（如
    [图 15-2](ch15.xhtml#wep_encryption "图 15-2. WEP 加密") 所示）。生成的数据包由 IV、ICV、密文和一个两位的密钥
    ID 组成，如 [图 15-4](ch15.xhtml#wep_encryption-id00041 "图 15-4. WEP 加密") 所示。
- en: '![WEP encryption](httpatomoreillycomsourcenostarchimages2030492.png.jpg)Figure 15-4. WEP
    encryption'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![WEP 加密](httpatomoreillycomsourcenostarchimages2030492.png.jpg)图 15-4. WEP
    加密'
- en: Decryption is similar, as shown in [Figure 15-5](ch15.xhtml#wep_decryption-id00042
    "Figure 15-5. WEP decryption"). The IV and key (denoted by the key ID), stored
    in plaintext as part of the packet, are concatenated and run through the same
    key-scheduling algorithm and pseudorandom number generators to create a keystream
    identical to the one used for encryption. The ciphertext is then XORed with the
    keystream to reveal the plaintext and the ICV. Finally, the decrypted ICV is compared
    with the plaintext ICV value appended to the packet. If the values don’t match,
    the packet is thrown out.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解密过程类似，如 [图 15-5](ch15.xhtml#wep_decryption-id00042 "图 15-5. WEP 解密") 所示。IV
    和密钥（由密钥 ID 表示），作为数据包的一部分存储为明文，被连接起来并通过相同的密钥调度算法和伪随机数生成器生成与加密时使用的密钥流完全相同的密钥流。然后，密文与密钥流进行异或操作，揭示出明文和
    ICV。最后，将解密后的 ICV 与附加到数据包上的明文 ICV 值进行比较。如果值不匹配，则丢弃该数据包。
- en: '![WEP decryption](httpatomoreillycomsourcenostarchimages2030494.png.jpg)Figure 15-5. WEP
    decryption'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![WEP 解密](httpatomoreillycomsourcenostarchimages2030494.png.jpg)图 15-5. WEP
    解密'
- en: WEP Weaknesses
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WEP 的弱点
- en: Unfortunately, WEP has some inherent problems that allow an attacker to recover
    a key or alter legitimate packets. In fact, every WEP key is recoverable by an
    attacker armed with enough ciphertexts encrypted with the same shared key. The
    only cryptosystem that is truly secure is a random one-time pad, which uses a
    specific key only once. The main trouble with WEP is that the 24-bit IV doesn’t
    introduce enough randomness; it has at most 2^(24) (that is, 16,777,216) values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，WEP 存在一些固有的问题，允许攻击者恢复密钥或篡改合法的数据包。事实上，任何 WEP 密钥都可以被携带足够密文并使用相同共享密钥的攻击者恢复。唯一真正安全的加密系统是随机一次性密码本，它只使用一个特定的密钥一次。WEP
    的主要问题在于 24 位的初始化向量（IV）没有引入足够的随机性；它最多有 2^(24)（即 16,777,216）个值。
- en: There is no standard way for wireless cards and access points to compute IVs,
    and in practice, the IV space used may be even smaller. Either way, given enough
    packets, IVs will be reused, and the same value (static key concatenated with
    the IV) will be used to generate the ciphertext. By passively listening for traffic
    (or better yet, injecting traffic into the network to force more packets and,
    thus, more IVs to be generated), an attacker can gather enough packets to perform
    cryptanalysis and recover the key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无线网卡和接入点没有标准的方法来计算初始化向量（IV），而在实际应用中，使用的 IV 空间可能更小。无论如何，给定足够的数据包，IV 会被重复使用，且相同的值（静态密钥与
    IV 连接）将被用来生成密文。通过被动监听网络流量（或更好的是，注入流量到网络中，迫使生成更多的数据包，从而生成更多的 IV），攻击者可以收集足够的数据包进行密码分析并恢复密钥。
- en: Similarly, the ICV that attempts to keep attackers from intercepting the encrypted
    message, flipping bits, and changing the resulting plaintext is insufficient.
    Unfortunately, weaknesses in the ICV implementation Cyclic Redundancy Check 32
    (CRC-32) may allow attackers to craft the correct ICV for a modified message.
    Because CRC-32 is a linear algorithm, flipping a specific bit in the ciphertext
    has a deterministic result on the resulting ICV, and an attacker with knowledge
    of how CRC-32 is calculated could cause a modified message to be accepted. Thus,
    the ICV implementation, like the IV, is not considered sound by modern cryptographic
    standards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，ICV（用于防止攻击者拦截加密消息、翻转位并更改结果明文）不足以保证安全。不幸的是，ICV 实现中的循环冗余校验 32（CRC-32）存在弱点，可能允许攻击者为修改后的消息构造正确的
    ICV。由于 CRC-32 是线性算法，在密文中翻转特定的比特位会对生成的 ICV 产生确定性结果，且了解 CRC-32 计算方式的攻击者可能会导致修改后的消息被接受。因此，ICV
    的实现和 IV 一样，按照现代加密标准并不可靠。
- en: We can use the Aircrack-ng suite to recover the shared key from a wireless network
    secured with WEP. Again, the math behind the cryptographic attacks is beyond the
    scope of this book. Luckily, we have tools that will take care of the hard stuff
    if we can capture the required traffic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Aircrack-ng 套件从使用 WEP 安全的无线网络中恢复共享密钥。同样，密码攻击背后的数学原理超出了本书的范围。幸运的是，我们有一些工具，如果能够捕获所需的流量，它们会处理复杂的部分。
- en: Cracking WEP Keys with Aircrack-ng
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Aircrack-ng 破解 WEP 密钥
- en: There are multiple ways to crack WEP keys, including the fake authentication
    attack, fragmentation attack, chopchop attack, caffé latte attack, and PTW attack.
    We’ll take a closer look at the fake authentication attack, which requires at
    least one legitimate client connected to the access point.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 破解 WEP 密钥有多种方法，包括伪认证攻击、分片攻击、chopchop 攻击、caffé latte 攻击和 PTW 攻击。我们将详细了解伪认证攻击，它要求至少有一个合法客户端连接到接入点。
- en: We’ll use the host system to simulate an attached client. First, change the
    wireless security on your router to WEP (see your user guide if you need help),
    and then make sure your wireless card is in monitor mode so that you can capture
    traffic from the network without first authenticating.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用主机系统模拟一个连接的客户端。首先，将路由器的无线安全设置更改为 WEP（如果需要帮助，请参阅用户手册），然后确保无线网卡处于监视模式，以便可以在无需先认证的情况下捕获网络流量。
- en: Now to see what data we can collect using the Airodump-ng tool from Aircrack-ng.
    Tell Airodump-ng to use the wireless interface in monitor mode `mon0`, as shown
    in [Example 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi "Example 15-7. Airodump-ng
    capture for WEP cryptanalysis"), and use the `-w` flag to save all packets to
    a file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一下我们可以使用 Airodump-ng 工具从 Aircrack-ng 收集到哪些数据。告诉 Airodump-ng 使用无线接口 `mon0`
    的监视模式，如 [示例 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi "示例 15-7.
    Airodump-ng 捕获用于 WEP 密码分析") 所示，并使用 `-w` 标志将所有数据包保存到文件中。
- en: Example 15-7. Airodump-ng capture for WEP cryptanalysis
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-7. Airodump-ng 捕获用于 WEP 密码分析
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This initial scan gathers all the information we need to begin a WEP attack
    against the base station. Here we have the BSSID ❶, wireless channel ❷, encryption
    algorithm ❸, and the SSID ❹. We’ll use this information to gather the packets
    to crack the WEP key. Your own setup’s information is likely different, of course,
    but here’s what we’ll work with:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这次初步扫描收集了我们开始对基站发起 WEP 攻击所需的所有信息。在这里，我们有 BSSID ❶、无线频道 ❷、加密算法 ❸ 和 SSID ❹。我们将使用这些信息来收集数据包以破解
    WEP 密钥。当然，您自己的设置可能不同，但以下是我们将使用的内容：
- en: '**Base Station MAC Address**: 00:23:69:F5:B4:2B'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基站 MAC 地址**: 00:23:69:F5:B4:2B'
- en: '**SSID**: linksys'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSID**: linksys'
- en: '**Channel**: 6'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道**: 6'
- en: Injecting Packets
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注入数据包
- en: Although the Airodump-ng output in [Example 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi
    "Example 15-7. Airodump-ng capture for WEP cryptanalysis") shows some traffic
    from the access point, to crack a 64-bit WEP key, we need about 250,000 IVs, and
    for a 148-bit WEP key, about 1,500,000\. Rather than idly listen for packets,
    we’ll capture and retransmit packets to the access point to generate unique IVs
    quickly. We need to authenticate, because if our MAC address isn’t authenticated
    with the access point, any packets we send will be dropped, and we’ll receive
    a deauthentication request. We’ll use Aireplay-ng to fake authentication with
    the access point and trick it into responding to our injected packets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 [示例 15-7](ch15.xhtml#airodump-ng_capture_for_wep_cryptanalysi "示例 15-7. Airodump-ng
    捕获 WEP 加密分析") 中的 Airodump-ng 输出显示来自接入点的一些流量，但要破解一个 64 位的 WEP 密钥，我们需要大约 250,000
    个 IV，而破解一个 148 位的 WEP 密钥需要大约 1,500,000 个 IV。与其无所事事地监听数据包，我们会捕获并重新广播数据包到接入点，以快速生成唯一的
    IV。我们需要进行认证，因为如果我们的 MAC 地址没有通过接入点认证，任何我们发送的数据包都会被丢弃，并且我们将收到一个去认证请求。我们将使用 Aireplay-ng
    伪造认证与接入点进行交互，并欺骗它响应我们注入的数据包。
- en: When using fake authentication, we tell the access point we’re ready to prove
    we know the WEP key, as shown in [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng"). Of course, because we don’t
    know the key yet, we don’t send it, but our MAC address is now on the list of
    clients that can send packets to the access point, hence the fake authentication.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用伪造认证时，我们告诉接入点我们准备好证明我们知道 WEP 密钥，如 [示例 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "示例 15-8. 使用 Aireplay-ng 伪造认证") 所示。 当然，因为我们还不知道密钥，所以不会发送它，但我们的 MAC 地址现在已在可以向接入点发送数据包的客户端列表中，因此这是伪造的认证。
- en: Example 15-8. Fake authentication with Aireplay-ng
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-8. 使用 Aireplay-ng 伪造认证
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We fake authentication using the following flags with their associated data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下标志及其相关数据伪造认证：
- en: '**`-1`** tells Aireplay-ng to fake authentication.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-1`** 告诉 Aireplay-ng 伪造认证。'
- en: '**`0`** is the retransmission time.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`0`** 是重新传输时间。'
- en: '**`-e`** is the SSID; in my case `linksys`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-e`** 是 SSID；在我的例子中是 `linksys`。'
- en: '**`-a`** is the MAC address of the access point we want to authenticate with.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-a`** 是我们想要认证的接入点的 MAC 地址。'
- en: '**`-h`** is the MAC address of our card (which should be on a sticker on the
    device).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-h`** 是我们卡片的 MAC 地址（应该在设备上的标签上）。'
- en: '**`mon0`** is the interface to use for the fake authentication.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mon0`** 是用于伪造认证的接口。'
- en: After sending the Aireplay-ng request, you should receive a smiley face and
    indication that authentication was successful ❶.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 Aireplay-ng 请求后，你应该会收到一个笑脸和认证成功的提示 ❶。
- en: Generating IVs with the ARP Request Relay Attack
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 ARP 请求转发攻击生成 IVs
- en: With the base station willing to accept packets from us, we can capture and
    rebroadcast legitimate packets. While the access point won’t allow us to send
    traffic without first sending the WEP key to authenticate, we can rebroadcast
    traffic from properly authenticated clients.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当基站愿意接收我们的数据包时，我们可以捕获并重新广播合法的数据包。虽然接入点在没有首先发送 WEP 密钥进行认证的情况下不会允许我们发送流量，但我们可以重新广播来自正确认证客户端的流量。
- en: We’ll use the attack technique known as *ARP Request Replay* to generate IVs
    quickly by having Aireplay-ng listen for an ARP request and then retransmit it
    back to the base station. (When the access point receives an ARP request, it rebroadcasts
    it with a new IV.) Aireplay-ng will rebroadcast the same ARP packet repeatedly,
    and each time it’s broadcast, it will have a new IV.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用被称为 *ARP 请求重放* 的攻击技术，通过让 Aireplay-ng 监听 ARP 请求，然后将其重新广播回基站，以快速生成 IV。 （当接入点收到
    ARP 请求时，它会用新的 IV 重新广播该请求。）Aireplay-ng 会反复重新广播相同的 ARP 数据包，每次广播时都会生成一个新的 IV。
- en: '[Example 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay "Example 15-9. Rebroadcasting
    ARP packets with Aireplay-ng") shows the attack in action. Aireplay-ng reads packets
    looking for an ARP request. You won’t see any data until Aireplay-ng sees an ARP
    request it can rebroadcast. We will see that next.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay "示例 15-9. 使用
    Aireplay-ng 重新广播 ARP 数据包") 展示了该攻击的实际操作。Aireplay-ng 会读取数据包，查找 ARP 请求。直到 Aireplay-ng
    看到它可以重新广播的 ARP 请求之前，你不会看到任何数据。我们接下来会看到这一点。'
- en: Example 15-9. Rebroadcasting ARP packets with Aireplay-ng
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-9. 使用 Aireplay-ng 重新广播 ARP 数据包
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use these options:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下选项：
- en: '**`-3`** performs the ARP request replay attack.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-3`** 执行 ARP 请求重放攻击。'
- en: '**`-b`** is the base station MAC address.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-b`** 是基站的 MAC 地址。'
- en: '**`-h`** is our Alfa card MAC address.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-h`** 是我们的 Alfa 卡的 MAC 地址。'
- en: '**`mon0`** is the interface.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`mon0`** 是接口。'
- en: Generating an ARP Request
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成 ARP 请求
- en: Unfortunately, as you can see in [Example 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay
    "Example 15-9. Rebroadcasting ARP packets with Aireplay-ng"), we don’t see any
    ARP requests. To generate an ARP request, we’ll use the host system as a simulated
    client by pinging an IP address on the network from the connected host system.
    Aireplay-ng will see the ARP request and retransmit it to the access point over
    and over.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如你在 [示例 15-9](ch15.xhtml#rebroadcasting_arp_packets_with_aireplay "示例
    15-9. 使用 Aireplay-ng 重新广播 ARP 数据包") 中看到的，我们没有看到任何 ARP 请求。为了生成 ARP 请求，我们将通过从连接的主机系统
    ping 网络上的一个 IP 地址，使用主机系统作为模拟客户端。Aireplay-ng 会看到 ARP 请求并反复将其转发到接入点。
- en: As you can see in the Airodump-ng screen, shown in [Example 15-10](ch15.xhtml#ivs_being_captured_in_airodump-ng
    "Example 15-10. IVs being captured in Airodump-ng"), the `#Data` ❶ number, indicating
    captured IVs, increases rapidly as Aireplay-ng continues to retransmit the ARP
    packet, causing the access point to generate more IVs. (If your `aireplay-ng -3`
    says `"Got adeauth/disassoc"` or something similar and your `#Data` number is
    not quickly rising, run the fake association command from [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng") again to reassociate with
    the access point. Your `#Data` field should again start rising rapidly.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 Airodump-ng 屏幕中看到的，[示例 15-10](ch15.xhtml#ivs_being_captured_in_airodump-ng
    "示例 15-10. IV 正在 Airodump-ng 中被捕获")所示，`#Data` ❶ 数字（表示捕获的 IV 数量）会迅速增加，因为 Aireplay-ng
    会不断重新传输 ARP 数据包，导致接入点生成更多的 IV。（如果你的 `aireplay-ng -3` 显示 “Got adeauth/disassoc”
    或类似信息，并且 `#Data` 数字没有快速上升，请再次运行 [示例 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "示例 15-8. 使用 Aireplay-ng 进行虚假身份验证")中的虚假关联命令，以重新关联接入点。你的 `#Data` 字段应再次开始快速上升。）
- en: Example 15-10. IVs being captured in Airodump-ng
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-10. IV 正在 Airodump-ng 中被捕获
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Cracking the Key
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 破解密钥
- en: Remember, we need about 250,000 IVs to crack a 64-bit WEP key. As long as you
    remain associated with the base station, as shown in [Example 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "Example 15-8. Fake authentication with Aireplay-ng"), (rerunning the command
    if it becomes necessary) and have generated an ARP request on the network, it
    should only take a few minutes to collect enough IVs. Once we’ve gathered enough
    IVs, we can use Aircrack-ng to do the math to turn the collected IVs into the
    correct WEP key. [Example 15-11](ch15.xhtml#recovering_the_wep_key_with_aircrack-ng
    "Example 15-11. Recovering the WEP key with Aircrack-ng") shows how we crack the
    key by using the `-b` flag and providing the filename we used in Airodump-ng followed
    by `*.cap` ❶. This tells Aircrack-ng to read from all .*cap* files saved by Airodump-ng.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们需要大约 250,000 个 IV 来破解 64 位 WEP 密钥。只要你保持与基站的关联，如 [示例 15-8](ch15.xhtml#fake_authentication_with_aireplay-ng
    "示例 15-8. 使用 Aireplay-ng 进行虚假身份验证") 中所示，（如果有必要，重新运行命令）并且已经在网络上生成了 ARP 请求，收集足够的
    IV 应该只需要几分钟。一旦我们收集到足够的 IV，就可以使用 Aircrack-ng 进行计算，将收集到的 IV 转换为正确的 WEP 密钥。[示例 15-11](ch15.xhtml#recovering_the_wep_key_with_aircrack-ng
    "示例 15-11. 使用 Aircrack-ng 恢复 WEP 密钥")展示了我们如何通过使用 `-b` 标志，并提供在 Airodump-ng 中使用的文件名，再加上
    `*.cap` ❶ 来破解密钥。这告诉 Aircrack-ng 从 Airodump-ng 保存的所有 .*cap* 文件中读取数据。
- en: Example 15-11. Recovering the WEP key with Aircrack-ng
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-11. 使用 Aircrack-ng 恢复 WEP 密钥
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After a few seconds of analysis Aircrack-ng returns the correct key ❷. We can
    now authenticate with the network. If this were a pentest client’s network, we
    could now directly attack any systems on the network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟的分析后，Aircrack-ng 返回正确的密钥 ❷。我们现在可以通过网络进行身份验证。如果这是渗透测试客户的网络，我们现在可以直接攻击网络上的任何系统。
- en: Challenges with WEP Cracking
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WEP 破解的挑战
- en: As with many topics discussed in this book, information about wireless attacks
    could fill a book, and I’ve shown you only one attack. One thing to keep in mind
    when attacking WEP is that clients may use filters in an attempt to thwart attacks
    like this. For example, access points could use MAC filtering to allow only wireless
    cards with certain MAC addresses to connect, and if your Alfa card isn’t on the
    list, your fake authentication attempt will fail. To bypass MAC filtering, you
    could use a tool like MAC Changer in Kali to spoof a MAC address and create an
    accepted value. Keep in mind that WEP keys are always crackable if we can gather
    enough packets, and for security reasons, WEP encryption should not be used in
    production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中讨论的许多话题一样，无线攻击的信息量足以填满一本书，而我这里只展示了一种攻击方法。在攻击 WEP 时需要牢记的一点是，客户端可能会使用过滤器来阻止类似的攻击。例如，接入点可能会使用
    MAC 过滤功能，只允许特定 MAC 地址的无线网卡连接，如果你的 Alfa 卡不在列表中，你的假认证尝试将会失败。为了绕过 MAC 过滤，你可以使用 Kali
    中的 MAC Changer 工具来伪造一个 MAC 地址并创建一个被接受的值。请记住，只要我们能够收集足够的数据包，WEP 密钥总是可以被破解的，出于安全原因，不应在生产环境中使用
    WEP 加密。
- en: It’s worth noting that the Wifite tool, installed by default in Kali Linux,
    behaves as a wrapper around the Aircrack-ng suite and will automate the process
    of attacking wireless networks, including cracking WEP. But while you are learning
    how Wi-Fi attacks work, it is better to walk through the process step by step
    instead of using an automation wrapper.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Kali Linux 中默认安装的 Wifite 工具实际上是 Aircrack-ng 套件的一个封装，它会自动化攻击无线网络的过程，包括破解
    WEP。但在你学习 Wi-Fi 攻击的原理时，最好是逐步完成整个过程，而不是使用自动化封装工具。
- en: We now turn our attention to the stronger wireless encryption protocols, WPA
    and WPA2.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向更强大的无线加密协议 WPA 和 WPA2。
- en: Wi-Fi Protected Access
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wi-Fi 保护访问
- en: As weaknesses in WEP came to light, a more robust wireless security system was
    needed and a new system (which ultimately became WPA2) was built to replace WEP.
    However, the creation of a secure cryptographic system for wireless took time,
    and in the meantime, additional security was needed that was compatible with deployed
    wireless hardware. Thus, *Wi-Fi Protected Access (WPA)*, also known as *Temporal
    Key Integrity Protocol (TKIP)*, was born.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 WEP 弱点的暴露，迫切需要一个更强大的无线安全系统，于是一个新的系统（最终成为 WPA2）应运而生，取代了 WEP。然而，构建一个安全的无线加密系统花费了时间，在此期间，仍然需要一个与已部署的无线硬件兼容的额外安全措施。因此，*Wi-Fi
    保护访问 (WPA)*，也被称为 *临时密钥完整性协议 (TKIP)*，应运而生。
- en: WPA uses the same underlying algorithm as WEP (RC4) but seeks to address WEP’s
    weaknesses by adding keystream randomness to IVs and integrity to ICV. Unlike
    WEP, which uses a 40 or 104-bit key combined with weak IVs for each packet, WPA
    generates a 148-bit key for each packet to ensure that each packet is encrypted
    with a unique keystream.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: WPA 使用与 WEP 相同的基础算法（RC4），但通过向 IVs 添加密钥流随机性并向 ICV 添加完整性来解决 WEP 的弱点。与 WEP 使用 40
    或 104 位密钥并为每个数据包使用弱 IV 不同，WPA 为每个数据包生成 148 位密钥，以确保每个数据包都使用唯一的密钥流进行加密。
- en: Additionally, WPA replaces WEP’s weak CRC-32 message integrity check with a
    message authentication code (MAC) algorithm called *Michael*, to prevent attackers
    from easily calculating the resulting changes to the ICV when a bit is flipped.
    Though both WPA and even WPA2 have their weaknesses, the most common vulnerability
    (which we’ll exploit later in this chapter) is the use of weak passphrases.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，WPA 用消息认证码（MAC）算法 *Michael* 替代了 WEP 的弱 CRC-32 消息完整性检查，防止攻击者轻易计算出当位被翻转时 ICV
    产生的变化。尽管 WPA 和 WPA2 都存在一些弱点，但最常见的漏洞（我们将在本章稍后利用）是使用弱密码短语。
- en: WPA2
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WPA2
- en: WPA2 was built from the ground up to provide a secure encryption system for
    wireless networks. It implements an encryption protocol built specifically for
    wireless security called *Counter Mode with Cipher Block Chaining Message Authentication
    Code Protocol (CCMP)*. CCMP is built on the Advanced Encryption Standard (AES).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: WPA2 从零开始构建，旨在为无线网络提供一个安全的加密系统。它实现了一种专为无线安全设计的加密协议，称为 *计数模式与密码块链消息认证码协议 (CCMP)*。CCMP
    基于高级加密标准 (AES)。
- en: WPA and WPA2 support both personal and enterprise setups. WPA/WPA2 personal
    uses a pre-shared key, similar to WEP. WPA/WPA2 enterprise adds an additional
    element called a *Remote Authentication Dial-In User Service (RADIUS) server*
    to manage client authentication.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: WPA 和 WPA2 支持个人和企业两种设置。WPA/WPA2 个人版使用预共享密钥，类似于 WEP。WPA/WPA2 企业版则增加了一个名为 *远程认证拨号用户服务
    (RADIUS) 服务器* 的额外元素，用于管理客户端身份验证。
- en: The Enterprise Connection Process
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业连接过程
- en: In WPA/WPA2 enterprise networks, the client connection process comprises four
    steps, as shown in [Figure 15-6](ch15.xhtml#wpasoliduswpa2_enterprise_connection
    "Figure 15-6. WPA/WPA2 enterprise connection"). First the client and the access
    point agree on mutually supported security protocols. Then, based on the authentication
    protocol chosen, the access point and the RADIUS server exchange messages to generate
    a master key. Once a master key is generated, a message that authentication was
    successful is sent to the access point and passed on to the client, and the master
    key is sent to the access point. The access point and the client exchange and
    verify keys for mutual authentication, message encryption, and message integrity
    via a four-way handshake, as discussed in [The Four-Way Handshake](ch15.xhtml#four-way_handshake
    "The Four-Way Handshake") on this page. Following key exchange, traffic between
    the client and the access point is secured with WPA or WPA2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPA/WPA2企业网络中，客户端连接过程包括四个步骤，如[图15-6](ch15.xhtml#wpasoliduswpa2_enterprise_connection
    "图15-6. WPA/WPA2企业连接")所示。首先，客户端和接入点达成一致，支持相同的安全协议。然后，根据选择的认证协议，接入点和RADIUS服务器交换消息以生成主密钥。一旦主密钥生成后，会向接入点发送认证成功的消息，并传递给客户端，同时主密钥也会发送到接入点。接入点和客户端通过四次握手交换并验证密钥，以进行相互认证、消息加密和消息完整性验证，如在[四次握手](ch15.xhtml#four-way_handshake
    "四次握手")中所讨论的那样。密钥交换后，客户端和接入点之间的流量将通过WPA或WPA2进行安全保护。
- en: '![WPA/WPA2 enterprise connection](httpatomoreillycomsourcenostarchimages2030496.png.jpg)Figure 15-6. WPA/WPA2
    enterprise connection'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![WPA/WPA2企业连接](httpatomoreillycomsourcenostarchimages2030496.png.jpg)图15-6.
    WPA/WPA2企业连接'
- en: The Personal Connection Process
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 个人连接过程
- en: 'The WPA/WPA2 personal connection process is slightly simpler than the enterprise
    one: No RADIUS server is required, and the entire process is between the access
    point and the client. No authentication or master key step occurs, and instead
    of a RADIUS server and master key, WPA/WPA2 personal use pre-shared keys, which
    are generated using pre-shared passphrases.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: WPA/WPA2个人连接过程比企业连接过程稍微简单一些：不需要RADIUS服务器，整个过程仅在接入点和客户端之间进行。不需要认证或主密钥步骤，取而代之的是，WPA/WPA2个人使用的是预共享密钥，这些密钥是通过预共享密码生成的。
- en: The WPA/WPA2 personal passphrase that you enter when you connect to a secured
    network is static, whereas enterprise setups use dynamic keys generated by the
    RADIUS server. Enterprise setups are more secure, but most personal networks and
    even most small businesses lack RADIUS servers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接到安全网络时，WPA/WPA2个人密码短语是静态的，而企业设置使用的是由RADIUS服务器生成的动态密钥。企业设置更安全，但大多数个人网络甚至大多数小型企业都没有RADIUS服务器。
- en: The Four-Way Handshake
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四次握手
- en: In the first phase of the connection between an access point and supplicant
    (client), a pairwise master key (PMK), which is static throughout the entire session,
    is created. This is not the key that will be used for encryption itself, but it
    will be used during the second phase, where a four-way handshake will take place
    between access point and client, with the purpose of establishing a channel of
    communication and exchanging the encryption keys used for further data communication,
    as shown in [Figure 15-7](ch15.xhtml#wpasoliduswpa2_four-way_handshake "Figure 15-7. WPA/WPA2
    four-way handshake").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在接入点和客户端（申请者）之间的连接的第一阶段，会创建一个对称的主密钥（PMK），它在整个会话期间保持静态。这个密钥不是用于加密的密钥，而是用于第二阶段，在这个阶段，接入点和客户端之间会进行四次握手，目的是建立通信通道并交换用于后续数据通信的加密密钥，如[图15-7](ch15.xhtml#wpasoliduswpa2_four-way_handshake
    "图15-7. WPA/WPA2四次握手")所示。
- en: '![WPA/WPA2 four-way handshake](httpatomoreillycomsourcenostarchimages2030498.png.jpg)Figure 15-7. WPA/WPA2
    four-way handshake'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![WPA/WPA2四次握手](httpatomoreillycomsourcenostarchimages2030498.png.jpg)图15-7.
    WPA/WPA2四次握手'
- en: 'This PMK is generated from the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PMK是通过以下方式生成的：
- en: The passphrase (pre-shared key, or PSK)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码短语（预共享密钥，或PSK）
- en: The access point’s SSID
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接入点的SSID
- en: The SSID length
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSID长度
- en: The number of hashing iterations (4096)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希迭代次数（4096）
- en: The resulting length in bits (256) of the generated shared key (PMK)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的共享密钥（PMK）的最终长度（256位）
- en: 'These values are fed into a hashing algorithm called PBKDF2, which creates
    a 256-bit shared key (PMK). While your passphrase (PSK) may be *GeorgiaIsAwesome*,
    this is not the PMK that will be used in a second phase. That said, anyone who
    knows the passphrase and the access point’s SSID can use the PBKDF2 algorithm
    to generate the correct PMK. During the four-way handshake, a pairwise transient
    key (PTK) is created and used to encrypt traffic between the access point and
    the client; a group transient key (GTK) is exchanged and used to encrypt broadcast
    traffic. The PTK is made up of the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值被输入到一个名为 PBKDF2 的哈希算法中，生成一个 256 位的共享密钥（PMK）。虽然你的密码短语（PSK）可能是*GeorgiaIsAwesome*，但这不是在第二阶段使用的
    PMK。也就是说，任何知道密码短语和接入点 SSID 的人都可以使用 PBKDF2 算法来生成正确的 PMK。在四次握手期间，创建了一个配对临时密钥（PTK），并用于加密接入点与客户端之间的流量；同时，交换了一个组临时密钥（GTK），用于加密广播流量。PTK
    由以下内容组成：
- en: The shared key (the PMK)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享密钥（PMK）
- en: A random number (nonce) from the access point (ANonce)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自接入点的一个随机数（ANonce）
- en: A nonce from the client (SNonce)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的一个随机数（SNonce）
- en: The MAC address of the client
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的 MAC 地址
- en: The MAC address of the access point
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接入点的 MAC 地址
- en: These values are fed into the PBKDF2 hashing algorithm to create the PTK.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值被输入到 PBKDF2 哈希算法中，以创建 PTK。
- en: To generate the PTK, the access point and the client exchange MAC addresses
    and nonces (random values). The static shared key (PMK) is never sent over the
    air, because both the access point and the client know the passphrase (PSK) and,
    thus, can generate the shared key independently.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 PTK，接入点和客户端交换 MAC 地址和随机数（随机值）。静态共享密钥（PMK）永远不会通过无线电发送，因为接入点和客户端都知道密码短语（PSK），因此可以独立生成共享密钥。
- en: The shared nonces and MAC addresses are used by both the client and the access
    point to generate the PTK. In the first step of the four-way handshake, the access
    point sends its nonce (ANonce). Next, the client chooses a nonce, generates the
    PTK, and sends its nonce (SNonce) to the access point. (The *S* in SNonce stands
    for supplicant, another name for the client in a wireless setup.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的随机数和 MAC 地址被客户端和接入点共同使用以生成 PTK。在四次握手的第一步中，接入点发送其随机数（ANonce）。接下来，客户端选择一个随机数，生成
    PTK，并将其随机数（SNonce）发送给接入点。（SNonce 中的 *S* 代表请求方，在无线网络设置中也就是客户端的另一个名字。）
- en: In addition to sending its nonce, the client sends a message integrity code
    (MIC) to guard against forgery attacks. In order to compute the correct MIC, the
    passphrase used to generate the pre-shared key must be correct, or the PTK will
    be wrong. The access point independently generates the PTK based on the SNonce
    and MAC address sent by the client, then checks the MIC sent by the client. If
    it’s correct, the client has authenticated successfully, and the access point
    sends over the GTK plus the MIC to the client.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送随机数外，客户端还发送一个消息完整性码（MIC），以防止伪造攻击。为了计算正确的 MIC，生成预共享密钥的密码短语必须正确，否则 PTK 会出错。接入点基于客户端发送的
    SNonce 和 MAC 地址独立生成 PTK，然后检查客户端发送的 MIC。如果正确，客户端就已成功认证，接入点会将 GTK 和 MIC 一起发送给客户端。
- en: In the fourth part of the handshake, the client acknowledges the GTK.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手的第四部分，客户端确认 GTK。
- en: Cracking WPA/WPA2 Keys
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破解 WPA/WPA2 密钥
- en: Unlike WEP, the cryptographic algorithms used in WPA and WPA2 are robust enough
    to stop attackers from recovering the key simply by capturing enough traffic and
    performing cryptanalysis. The Achilles’ heel in WPA/WPA2 personal networks lies
    in the quality of the pre-shared key (passphrase) used. If the Windows *Administrator*
    password you found during post exploitation is the same as the WPA or WPA2 personal
    passphrase or the passphrase is written on a whiteboard in the front office of
    the organization, it’s game over.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WEP 不同，WPA 和 WPA2 中使用的加密算法足够强大，可以防止攻击者仅通过捕获足够的流量并进行密码分析来恢复密钥。WPA/WPA2 个人网络的
    Achilles’ heel 在于所使用的预共享密钥（密码短语）的质量。如果你在后期利用漏洞获得的 Windows *管理员*密码与 WPA 或 WPA2
    个人密码短语相同，或者密码短语写在公司前办公室的白板上，那就完了。
- en: To try to guess a weak password, we first need to capture the four-way handshake
    for analysis. Recall that given the correct passphrase and the SSID of the access
    point, the PBKDF2 hashing algorithm can be used to generate the shared key (PMK).
    Given the PMK, we still need the ANonce, SNonce, and the MAC addresses of the
    access point and client to calculate the PTK. Of course, the PTK will differ for
    each client, because the nonces will differ in each four-way handshake, but if
    we can capture a four-way handshake from any legitimate client, we can use its
    MAC addresses and nonces to calculate the PTK for a given passphrase. For example,
    we can use the SSID and the passphrase *password* to generate a PMK, then combine
    the generated PMK with the captured nonces and MAC addresses to calculate a PTK.
    If the MICs comes out like the ones in the captured handshake, we know that *password*
    is the correct passphrase. This technique can be applied to a wordlist of possible
    passphrases to try to guess the correct passphrase. Luckily, if we can capture
    a four-way handshake and supply a wordlist, we have Aircrack-ng to take care of
    all the math.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试猜测一个弱密码，我们首先需要捕获四次握手以进行分析。回想一下，给定正确的密码和接入点的 SSID，可以使用 PBKDF2 哈希算法生成共享密钥（PMK）。有了
    PMK，我们仍然需要接入点和客户端的 ANonce、SNonce 以及 MAC 地址来计算 PTK。当然，PTK 会因每个客户端而异，因为每次四次握手中的
    nonces 是不同的，但如果我们能从任何合法客户端捕获四次握手，我们可以利用其 MAC 地址和 nonces 来计算给定密码的 PTK。例如，我们可以使用
    SSID 和密码 *password* 来生成 PMK，然后将生成的 PMK 与捕获的 nonces 和 MAC 地址结合起来计算 PTK。如果计算出的 MIC
    与捕获的握手中的 MIC 一致，我们就知道 *password* 是正确的密码。这个技术可以应用于一个可能的密码字典中，尝试猜测正确的密码。幸运的是，如果我们能捕获到四次握手并提供一个密码字典，我们就可以利用
    Aircrack-ng 完成所有数学计算。
- en: Using Aircrack-ng to Crack WPA/WPA2 Keys
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Aircrack-ng 破解 WPA/WPA2 密钥
- en: To use Aircrack-ng to crack WPA/WPA2, first set up your wireless access point
    for WPA2 personal. Choose a pre-shared key (passphrase) and then connect your
    host system to your access point to simulate a real client.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Aircrack-ng 破解 WPA/WPA2，首先将无线接入点设置为 WPA2 个人模式。选择一个共享密钥（密码），然后将主机系统连接到接入点，以模拟一个真实客户端。
- en: To use a wordlist to try to guess the WPA2 pre-shared key (passphrase), we need
    to capture the four-way handshake. Enter **`airodump-ng -c 6`** for the channel,
    **`--bssid`** with the base station MAC address, **`-w`** to specify the filename
    for output (use a different filename than you used in the WEP cracking example),
    and **`mon0`** for the monitor interface, as shown in [Example 15-12](ch15.xhtml#airodump-ng_for_wpa2_cracking
    "Example 15-12. Airodump-ng for WPA2 cracking").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用字典猜测 WPA2 共享密钥（密码），我们需要捕获四次握手。输入 **`airodump-ng -c 6`** 来选择频道，**`--bssid`**
    后接基站的 MAC 地址，**`-w`** 来指定输出的文件名（使用不同于 WEP 破解示例中的文件名），以及 **`mon0`** 作为监视接口，如 [示例
    15-12](ch15.xhtml#airodump-ng_for_wpa2_cracking "示例 15-12. 使用 Airodump-ng 进行 WPA2
    破解") 中所示。
- en: Example 15-12. Airodump-ng for WPA2 cracking
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-12. 使用 Airodump-ng 进行 WPA2 破解
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see the host is connected ❶. To capture a four-way handshake, we
    can either wait for another wireless client to sign on or speed up the process
    by kicking a client off the network and forcing it to reconnect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主机已连接 ❶。为了捕获四次握手，我们可以等待另一个无线客户端连接，或者通过将某个客户端踢出网络并迫使其重新连接来加速这一过程。
- en: 'To force a client to reconnect, use Aireplay-ng to send a message to a connected
    client telling it that it is no longer connected to the access point. When the
    client reauthenticates, we’ll capture the four-way handshake between the client
    and access point. The Aireplay-ng options we’ll need are:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制客户端重新连接，可以使用 Aireplay-ng 向已连接的客户端发送一条消息，告知它不再连接到接入点。当客户端重新认证时，我们将捕获客户端与接入点之间的四次握手。我们需要的
    Aireplay-ng 选项如下：
- en: '**`-0`** means deauthentication.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-0`** 表示去认证。'
- en: '**`1`** is the number of deauthentication requests to send.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`1`** 是要发送的去认证请求的数量。'
- en: '**`-a 00:14:6C:7E:40:80`** is the MAC address of the base station.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-a 00:14:6C:7E:40:80`** 是基站的 MAC 地址。'
- en: '**`-c 00:0F:B5:FD:FB:C2`** is the MAC address of the client to deauthenticate.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`-c 00:0F:B5:FD:FB:C2`** 是要去认证的客户端的 MAC 地址。'
- en: '[Example 15-13](ch15.xhtml#sending_a_deauthentication_request_to_a "Example 15-13. Sending
    a deauthentication request to a client") shows the `aireplay-ng` command and the
    deauthentication request.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-13](ch15.xhtml#sending_a_deauthentication_request_to_a "示例 15-13. 向客户端发送去认证请求")
    显示了 `aireplay-ng` 命令和去认证请求。'
- en: Example 15-13. Sending a deauthentication request to a client
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-13. 向客户端发送去认证请求
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we return to the Airodump-ng window, as shown in [Example 15-14](ch15.xhtml#wpa2_handshake_captured_in_airodump-ng
    "Example 15-14. WPA2 handshake captured in Airodump-ng").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到 Airodump-ng 窗口，如[示例 15-14](ch15.xhtml#wpa2_handshake_captured_in_airodump-ng
    "示例 15-14. 在 Airodump-ng 中捕获 WPA2 握手")所示。
- en: Example 15-14. WPA2 handshake captured in Airodump-ng
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-14. 在 Airodump-ng 中捕获 WPA2 握手
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the Airodump-ng capture sees a four-way handshake with a client, it records
    it in the first line of the captured output ❶.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Airodump-ng 捕获到与客户端的四次握手，它会将其记录在捕获输出的第一行 ❶。
- en: Once you’ve captured the WPA2 handshake, close Airodump-ng, and open the *.cap*
    file in Wireshark with File4Open4*filename.cap*. Once in Wireshark, filter for
    the `eapol` protocol to see the four packets that make up the handshake, as shown
    in [Figure 15-8](ch15.xhtml#wpa2_handshake_packets_in_wireshark "Figure 15-8. WPA2
    handshake packets in Wireshark").
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦捕获到 WPA2 握手，关闭 Airodump-ng，然后在 Wireshark 中通过文件菜单打开 *.cap* 文件，路径为 File4Open4*filename.cap*。进入
    Wireshark 后，使用过滤器 `eapol` 协议查看构成握手的四个数据包，如[图 15-8](ch15.xhtml#wpa2_handshake_packets_in_wireshark
    "图 15-8. Wireshark 中的 WPA2 握手数据包")所示。
- en: '![WPA2 handshake packets in Wireshark](httpatomoreillycomsourcenostarchimages2030500.png.jpg)Figure 15-8. WPA2
    handshake packets in Wireshark'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![Wireshark 中的 WPA2 握手数据包](httpatomoreillycomsourcenostarchimages2030500.png.jpg)图
    15-8. Wireshark 中的 WPA2 握手数据包'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes Aircrack-ng will claim that the handshake has been captured, but when
    you look at the packets in Wireshark, you will see you do not have all four messages.
    If this is the case, run the deauthentication attack again, as you will need all
    four messages to attempt to guess the correct key.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 Aircrack-ng 会声称已经捕获到握手，但当你查看 Wireshark 中的数据包时，会发现并没有捕获到所有四个消息。如果是这种情况，请重新运行去身份验证攻击，因为你需要所有四个消息才能尝试猜测正确的密钥。
- en: Now we create a wordlist like the ones we used in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks"), making sure that the correct WPA2 key is included in the list. The
    success of our attack against WPA2 is contingent on our ability to compare the
    hashed values for our passphrase with the values in the handshake.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个类似于[第9章](ch09.xhtml "第9章 密码攻击")中使用的单词列表，确保正确的 WPA2 密钥包含在列表中。我们对 WPA2
    攻击的成功取决于我们是否能够将我们密码短语的哈希值与握手中的值进行比较。
- en: Once we have the handshake, we can do the rest of the calculations to recover
    the key offline; we no longer need to be in range of the access point or send
    it any packets. Next we use Aircrack-ng to test the keys in the wordlist, specifying
    a list with the `-w` option, as shown in [Example 15-15](ch15.xhtml#recovering_a_wpa2_key_with_aircrack-ng
    "Example 15-15. Recovering a WPA2 key with Aircrack-ng"). Otherwise, the command
    is identical to cracking the WEP key. If the correct key is in the wordlist, it
    will be recovered with Aircrack-ng.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们捕获到握手数据包，就可以离线进行剩余的计算来恢复密钥；我们不再需要靠近接入点或向其发送数据包。接下来，我们使用 Aircrack-ng 来测试单词列表中的密钥，指定一个带有
    `-w` 选项的列表，如[示例 15-15](ch15.xhtml#recovering_a_wpa2_key_with_aircrack-ng "示例 15-15.
    使用 Aircrack-ng 恢复 WPA2 密钥")所示。否则，命令与破解 WEP 密钥时相同。如果正确的密钥在单词列表中，它将通过 Aircrack-ng
    恢复。
- en: Example 15-15. Recovering a WPA2 key with Aircrack-ng
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-15. 使用 Aircrack-ng 恢复 WPA2 密钥
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the correct key is in our wordlist and is recovered ❶. This
    sort of dictionary attack against WPA/WPA2 can be prevented by using a strong
    passphrase, as discussed in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，正确的密钥在我们的单词列表中，并且已经恢复 ❶。通过使用强密码短语（如[第9章](ch09.xhtml "第9章 密码攻击")中所讨论的那样），可以防止这种针对
    WPA/WPA2 的字典攻击。
- en: Aircrack-ng is just one suite of tools for cracking wireless. It is ideal for
    beginners, because starting different tools for each step of the process will
    help you become familiar with how these attacks work. Other widely used Wi-Fi
    auditing tools that you may encounter are Kismet and Wifite.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Aircrack-ng 只是破解无线网络的众多工具之一。它非常适合初学者，因为在每个步骤中启动不同的工具有助于你熟悉这些攻击的工作原理。你可能遇到的其他广泛使用的
    Wi-Fi 审计工具包括 Kismet 和 Wifite。
- en: Wi-Fi Protected Setup
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wi-Fi 保护设置
- en: '*Wi-Fi Protected Setup (WPS)* was designed to allow users to attach their devices
    to secure networks with an eight-digit pin instead of a potentially long and complicated
    passphrase. When the correct pin is supplied, the access point sends over the
    passphrase.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*Wi-Fi 保护设置 (WPS)* 旨在让用户通过八位数字 PIN 而非潜在的长而复杂的密码短语，将设备连接到安全网络。当提供正确的 PIN 时，接入点会发送密码短语。'
- en: Problems with WPS
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WPS 的问题
- en: The last digit of the pin is a checksum for the previous seven digits, so the
    keyspace should be 10⁷, or 10,000,000 possible pins. However, when a pin is sent
    to the access point by the client, the validity of the first four digits and second
    four digits is reported separately. The first four digits are all in play, so
    there are 10,000 possibilities. Of the second four digits, only the first three
    are in play (1000 possible guesses), so it would take at most 11,000 guesses to
    brute-force the correct WPS pin. This decreases the time required to brute-force
    to under four hours. The only way to fix this issue is to disable WPS on the access
    point.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PIN 码的最后一位是前七位数字的校验和，因此密钥空间应为 10⁷，即 10,000,000 种可能的 PIN 码。然而，当客户端向接入点发送 PIN
    时，前四位和后四位的有效性会分别报告。前四位全部有效，所以有 10,000 种可能性。后四位中，只有前三位有效（有 1000 种可能的猜测），因此暴力破解正确的
    WPS PIN 最多需要 11,000 次猜测。这使得暴力破解所需的时间减少到四小时以内。解决此问题的唯一方法是禁用接入点上的 WPS。
- en: Cracking WPS with Bully
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Bully 破解 WPS
- en: Kali provides tools that you can use to implement a brute-force attack against
    WPS. One such tool is Bully. We can use Bully to brute-force the WPS pin as well
    as test a specific pin. To use Bully we need the SSID, MAC address, and channel
    of the access point, which we found with `iwlist` at the beginning of this chapter.
    Use the `-b` flag to specify the MAC address, the `-e` flag for the SSID, and
    the `-c` flag for the channel, as shown here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 提供了可以用于对 WPS 进行暴力破解的工具。其中一个工具是 Bully。我们可以使用 Bully 来暴力破解 WPS PIN 码，也可以测试特定的
    PIN 码。使用 Bully 时，我们需要获取接入点的 SSID、MAC 地址和频道，这些信息在本章开始时我们通过 `iwlist` 获取。使用 `-b`
    标志指定 MAC 地址，`-e` 标志指定 SSID，`-c` 标志指定频道，如下所示。
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Bully should be able to brute-force the pin in around four hours and recover
    the correct pre-shared PIN. WPS is enabled by default on many wireless access
    points and may be an easier way in than guessing a strong WPA/WPA2 passphrase.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Bully 应该能在大约四小时内暴力破解 PIN 码，并恢复正确的预共享 PIN。许多无线接入点默认启用 WPS，且相比猜测强密码的 WPA/WPA2
    密码，WPS 可能是更容易的突破口。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Wireless security is an often-overlooked piece of an organization’s security
    posture. Time and money are put into securing the perimeter, deploying the latest
    firewalls and intrusion-prevention systems, but all this is for naught if an attacker
    can just sit at the coffee shop across the street with a strong antenna and join
    your corporate network. Wireless connections may save corporations from lawsuits
    by distracted employees tripping over Ethernet wires, but they introduce potential
    security vulnerabilities and should be audited regularly. In this chapter, we
    used Aircrack-ng to recover WEP and WPA2 personal wireless keys by eavesdropping
    on and injecting traffic into a wireless network, and we used Bully to brute-force
    a WPS pin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 无线安全常常是组织安全防护中被忽视的一部分。尽管组织投入了时间和资金来保护外围，部署最新的防火墙和入侵防御系统，但如果攻击者能够仅仅在街对面的咖啡店坐着，带着强大的天线就能加入到你的公司网络中，那一切投入都将是徒劳的。无线连接虽然可以让公司避免因员工绊倒以太网电缆而遭遇诉讼，但也带来了潜在的安全漏洞，因此应定期进行审计。本章中，我们使用
    Aircrack-ng 通过监听和注入无线网络流量来恢复 WEP 和 WPA2 个人无线密钥，并使用 Bully 来暴力破解 WPS PIN。
