- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 8 SOPHISTICATED ARRAYS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll take a more sophisticated approach to PHP arrays and
    explore how to manually assign an array’s keys. This opens up the possibility
    of using meaningful strings as keys instead of PHP’s default behavior of using
    sequential integers. We’ll also discuss multidimensional arrays, where the value
    of an array element is itself another array, and we’ll look at more functions
    and operators for working with arrays. With this expanded look at PHP arrays,
    you’ll begin to see how they can store and manipulate more complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: '### Declaring Array Keys Explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed how PHP will automatically assign sequential integer keys to
    array elements, starting from 0, in which case the resulting array will meet the
    definition of a *list*. Rather than relying on this default behavior, however,
    you can use the double-arrow operator (=>) when declaring an array to explicitly
    map a key to each value. Then you aren’t obligated to follow the default pattern
    for keys. For example, you can use nonsequential integers as keys, or start counting
    from a number other than 0\. Either way, the resulting array will no longer be
    considered a list, but it will be a valid array nonetheless. To illustrate, [Listing
    8-1](#lis8-1) shows a script that explicitly uses nonsequential integer keys in
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Explicitly declaring integer array keys out of sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare a $rainfallValues array. Inside the square brackets of the array,
    we use the => operator to explicitly assign a key to each array element. For example,
    0 => 10 adds an element to the array with a value of 10 and a key of 0. The key/value
    pairs are separated by commas, just as we separated the array values by commas
    in [Chapter 7](chapter7.xhtml) when we weren’t explicitly declaring the keys.
    In this case, we’ve also placed each key/value pair on its own indented line,
    for clarity. With the array declared, the script continues by looping through
    it and printing its key/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the array keys we’ve declared aren’t sequential. The second array
    element has a key of 4, and the third element has a key of 3. This may not be
    the most intuitive scheme for assigning keys, but if that’s what we want, PHP
    is perfectly fine with it. The array won’t meet the definition of a list (so the
    call to array_is_list() at the end of the script should return false), but the
    array is still valid. Here’s the output of running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The foreach loop works even though the array isn’t a proper list, iterating
    through the array’s key/value pairs and printing them out. Notice that the element
    with key 4 prints before key 3. What matters is the order in which the elements
    are *declared*, not the numerical order of the keys themselves. The false at the
    end of the output confirms that the array no longer meets the requirements of
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: Once you start explicitly declaring keys, you don’t necessarily have to declare
    one for *every* array element. If an element is declared without a key, PHP will
    automatically look for the most recent integer key, increment it, and use that
    as the new key. This can be useful if you want an array to have sequential keys
    that don’t start from 0.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you have a class of students and want an array mapping the
    students’ IDs to their grades. Each ID is a seven-digit number, beginning with
    the year and followed by three digits that increment sequentially. In 2025, for
    instance, the first student would have a numeric ID of 2025001, the next 2025002,
    and so on. In this case, you can explicitly declare just the first array key and
    let PHP automatically assign the rest. [Listing 8-2](#lis8-2) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Declaring the first array key explicitly and the rest automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the $studentGrades array, we explicitly give the first element a key
    of 2025001. Then, beginning with the second element ❶, we supply only the values.
    By default, PHP will map these values to the integer keys 2025002, 2025003, and
    so on. As before, we finish the script by looping through and printing the key/value
    pairs and testing whether the array counts as a list. The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that PHP has assigned the remaining keys sequentially, incrementing from
    the explicitly declared key of 2025001. However, even though the keys are sequential,
    they don’t start from 0\. Therefore, the array isn’t a list, as the false at the
    end of the output confirms.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays with Strings as Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take our coding a step further: now that we’re assigning array keys explicitly,
    who’s to say they have to be integers? They can just as easily be strings, in
    which case each value in the array can be given a meaningful name as a key. Returning
    to the $rainfallValues array from [Listing 8-1](#lis8-1), for example, we can
    use month names as keys instead of integers. This change will better indicate
    that each value in the array is a monthly rainfall total. [Listing 8-3](#lis8-3)
    revises the script accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Using strings as array keys'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we’ve assigned the key ''jan'' to the value 10, the key ''feb'' to
    the value 8, and the key ''march'' to the value 12. We use the same => operator
    as before to pair keys with values. The only difference is that the keys are now
    strings. Here’s the script’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The string keys clarify what the values actually represent. The false at the
    end of the output shows that this array isn’t a list. This isn’t surprising, since
    the keys aren’t even integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing individual values from an array with string keys works just like
    accessing values from arrays with integer keys: provide the key in square brackets,
    after the array name. For example, here’s how to print the rainfall value for
    the month of March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can also use square-bracket notation to add or update array
    elements with string keys. Here we add a new rainfall total for April:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example, but hopefully you can begin to see the potential power
    of PHP arrays to build meaningful collections of data. When you don’t need the
    full range of features of object-oriented programming (discussed in [Part V](part5.xhtml)),
    using arrays with string keys allows you to work with data whose values are naturally
    associated with keys that make sense for the task (such as dates or months, people’s
    names or IDs, or product names or codes).
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to now, the arrays we’ve been exploring have been *single-dimensional*:
    they contain a sequence of elements, and each element is a scalar (single) value
    mapped to a key. However, you can also declare arrays containing elements that
    are arrays themselves, resulting in a *multidimensional array*. For example, say
    you want to create an array of tasks and the time each task will take in minutes.
    Each element in the array could itself be an array holding the name of a task
    and its associated duration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here $tasksAndMinutes is a multidimensional array. Its first element, ['shopping',
    30], is a two-element array holding a string task name and the integer number
    of minutes to allocate for that task. The other array elements follow this same
    format. With a multidimensional array like this, we refer to the overall $tasksAndMinutes
    as the *outer* array and its elements as the *inner* arrays.
  prefs: []
  type: TYPE_NORMAL
- en: One way to work with a multidimensional array is to use a nested set of foreach
    loops, one to iterate over the elements of the outer array and the other to iterate
    over the elements of each inner array. In the $tasksAndMinutes array, however,
    all the inner arrays have the same structure (which won’t always be a given).
    Therefore, in cases like these, you can use your knowledge of that structure to
    extract the values from each inner array by using a single foreach loop that iterates
    over the outer array. [Listing 8-4](#lis8-4) illustrates this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Working with a multidimensional array'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the $tasksAndMinutes array as shown previously. Next, we declare
    a foreach loop that iterates through the elements of $tasksAndMinutes, using the
    $item variable to represent the current element. As we’ve seen, each element is
    itself an array containing a task name and a time in minutes. We can therefore
    extract the first element of $item (using integer index 0) into the $task variable
    and the second element (index 1) into $minutes. Then we print a message about
    the current task by using these two variables, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The times and task names have successfully been extracted from each inner array
    during the foreach loop.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the inner arrays use integer keys by default, but as you know,
    arrays can also use non-numeric keys. Pairing the values in each inner array with
    meaningful string keys like 'task' and 'minutes' will make the code much more
    readable. For example, we’ll be able to access the task from the current element
    of $tasksAndMinutes with $task = $item['task'] rather than $task = $item[0]. [Listing
    8-5](#lis8-5) shows this improvement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Refactoring [Listing 8-4](#lis8-4) to use string keys in the inner
    arrays'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we explicitly assign the string keys ''task'' and ''minutes'' to
    the values in each of the arrays inside $tasksAndMinutes. Then we use those meaningful
    keys inside the foreach loop to extract the values from the current inner array
    being processed. The result is exactly the same as before, but the code is easier
    to read. Before PHP allowed for object-oriented programming, well-labeled multidimensional
    arrays like this were an integral part of the code for the data-related features
    of many programs.  ### More Array Operations'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](chapter7.xhtml), we discussed array operations such as adding
    an element to and removing an element from the end of a simple array. Now that
    we’ve explored sophisticated arrays, let’s consider more array operations. We’ll
    look at how to remove an element from anywhere in an array, how to use array operators
    like union (+) and spread (...), and how to extract the elements of an array into
    separate variables.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Any Element from an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can remove an element from an array by passing the element’s key to the
    unset() function. Unlike the array_pop() function covered in the previous chapter,
    which specifically removes the *last* element in an array, unset() can remove
    an element from *any* position. Also unlike array_pop(), the unset() function
    doesn’t return the deleted element; it’s simply gone.
  prefs: []
  type: TYPE_NORMAL
- en: Using unset() becomes more appropriate when you start assigning strings rather
    than integers as array keys. With string keys, the order of the array elements
    often loses its significance, so it’s more meaningful to remove an element based
    on its key rather than its position in the array. [Listing 8-6](#lis8-6) revisits
    the $rainfallValues array as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: Using unset() to remove an element from an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use unset() to remove the element with the ''feb'' key from the $rainfallValues
    array. Then we loop through the array to print details for the remaining elements
    as before. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that no data is printed for an element with the key 'feb', since that
    element no longer exists within the array.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Calling* unset() *on a whole array, such as* unset($rainfallValues)*, would
    delete the entire array, just as calling* unset() *on any other variable would
    clear that variable.*  #### Combining and Comparing Arrays'
  prefs: []
  type: TYPE_NORMAL
- en: You can combine or compare arrays by using some of the same addition, equality,
    and identity operators that apply to scalar (single-value) variables. [Table 8-1](#tab8-1)
    summarizes the six array operators available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Array Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Symbol | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Union | + | $a + $b | Returns an array with the elements of arrays $a and
    $b. |'
  prefs: []
  type: TYPE_TB
- en: '| Spread | ... | [1, ...$a] | Returns an array that has 1 as the first element,
    followed by the elements of array $a. |'
  prefs: []
  type: TYPE_TB
- en: '| Equal | == | $a == $b | Returns true if arrays $a and $b have the same key/value
    pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| Identical | === | $a === $b | Returns true if arrays $a and $b are identical:
    they have the same key/value pairs, and their elements are in the same order and
    of the same types. |'
  prefs: []
  type: TYPE_TB
- en: '| Not equal | != or <> | $a != $b$a <> $b | Returns true if arrays $a and $b
    do not have the same key/value pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| Not identical | !== | $a !== $b | Returns true if array $a is not identical
    to array $b. |'
  prefs: []
  type: TYPE_TB
- en: '[Listing 8-7](#lis8-7) shows some of these operators in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Using array operators'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare some example arrays to work with: $cars1 and $cars2 have
    car makes as keys and car colors as values, while $names1 and $names2 have first
    names as keys and last names as values. (Notice that $names1 and $names2 have
    the same elements, but in the opposite order.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we apply operators to these arrays and print the results. We use the union
    (+) operator to combine $cars1 and $cars2, and we test the equal (==) and identical
    (===) operators on $names1 and $names2. We also use the array spread operator
    (...) to create a new array with a key of ''rolls royce'' mapped to a value of
    ''yellow'', as well as all the elements of the $cars1 and $names1 arrays ❶. Notice
    that we use print_r() to show the results of the operations that return arrays;
    this function displays arrays more succinctly than var_dump(). Running the script
    results in this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the output shows the result of $cars1 + $cars2 ❶. Both arrays
    of cars have an element with a key of 'audi', but an array can’t have two identical
    keys. As such, the union operator takes the 'audi' => 'silver' element from $cars1
    but ignores 'audi' => 'white' from $cars2, resulting in a three-element array.
    Next, the true and false outputs ❷ indicate that the $names1 and $names2 arrays
    are *equal*, since they have the same keys and values, but not *identical*, since
    the sequence of elements is different. The final array shows the result of using
    the spread operator (...) ❸. The new array has a 'rolls royce' element, followed
    by the elements from $cars1 and $names1.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth underscoring what the spread operator (...) is doing here: it extracts
    the elements from one array and inserts them, one at a time, into another array.
    Without the spread operator, the entire array would be inserted as a single element
    into the new array, thus creating a multidimensional array, rather than its individual
    elements being spread into the new array. To illustrate, say we had omitted the
    spread operator before $cars1 ❶ in [Listing 8-7](#lis8-7), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting array would have an element containing the whole $cars1 array,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now the second element in the array, with key 0, is itself an array containing
    the complete contents of $cars1. This example also illustrates how an array can
    mix integer keys with non-integer keys. When the whole $cars1 array is added as
    an element to the new array, it’s automatically given the first available integer
    key, 0, since it wasn’t given a key manually. Meanwhile, the other elements in
    the new array all have explicitly assigned string keys. Arrays with mixed keys
    like this are rare; usually such an array would indicate something has gone wrong,
    such as the missing spread operator here.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring an Array into Multiple Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it can be useful to extract the values from an array and assign them
    to separate variables, a process known as *destructuring*. If you know the number
    of elements in the array, you can destructure it in a single statement, as shown
    in [Listing 8-8](#lis8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: Destructuring a three-element array into three separate variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the $rainfallValues array to have three elements. Then we destructure
    the array into the $jan, $feb, and $march variables ❶. For that, we list the target
    variables inside square brackets on the left of an assignment operator (=) and
    provide the variable containing the whole array on the right. Finally, we print
    out the values in the three variables, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the values from the array are successfully assigned into, and print
    out from, the individual $jan, $feb, and $march variables.  ### Callback Functions
    and Arrays'
  prefs: []
  type: TYPE_NORMAL
- en: A *callback function*, or simply a *callback*, is a function that isn’t called
    directly, but rather is passed as an argument to another function. The other function
    then calls the callback function for you. PHP has several functions that use callbacks
    in conjunction with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For example, array_walk() takes in an array and a callback function as arguments
    and applies the callback function to each element in the array, transforming the
    original array in the process. Similarly, array_map() takes in an array and a
    callback function, applies the callback to each array element, and returns a new
    array containing the results. Both array_walk() and array_map() are known as *higher-order
    functions*, since they take in a function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve declared a function in a separate file (as previously discussed in
    [Chapter 5](chapter5.xhtml)) or are using one of PHP’s built-in functions, you
    can use that function as a callback by passing a string containing the function’s
    name to a higher-order function. For example, say we’ve declared a function called
    my_function() and we want to apply it to every element in $my_array by using array_map().
    Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We pass the string 'my_function' (the name of the desired callback) and the
    array as arguments to array_map(), which will call my_function() for each element
    in the array. The results are returned in a new array, which we store in the $my_new_array
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than declare the callback function separately, another common approach
    is to define an *anonymous* (unnamed) callback function directly in the argument
    list for the higher-order function. Before we look at an anonymous function in
    the context of a higher-order function like array_map(), though, let’s consider
    an anonymous function by itself to better understand the syntax. Here’s a simple
    anonymous function that takes in a number and returns double its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The function begins with the function keyword, followed by the function’s signature,
    (int $n): int, which indicates that the function takes a single integer parameter
    $n and returns an integer value. Notice that the function signature doesn’t include
    a name, since the function is anonymous. After the signature comes the anonymous
    function’s body, which is enclosed in curly brackets. The body returns twice the
    value of the provided $n argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to write the anonymous callback as an *arrow function*, using
    a more concise syntax that uses the double-arrow operator (=>) to separate the
    function’s signature and body. This syntax removes the need for the return keyword,
    the curly brackets around the body, and the semicolon to end the statement in
    the body. Here’s the arrow-function version of our doubling operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of function, we now begin with fn, a reserved keyword for declaring
    arrow functions. Then comes the function’s signature as before. Next, we write
    the double-arrow operator (=>), followed by an expression defining the function’s
    return value (in this case, $n * 2). Without the curly brackets, semicolon, and
    return keyword, the arrow function is extremely compact.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try using this arrow function as a callback. [Listing 8-9](#lis8-9)
    shows how to pass the arrow function to array_map() in order to double every value
    in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: Passing an arrow callback function to array_map()'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a $numbers array containing 10, 20, and 30. We then call the array_map()
    function. For the first argument, we use arrow-function syntax to declare the
    doubling callback function we just discussed ❶. Notice that the arrow function
    ends with a comma, since it’s part of the list of arguments to array_map(). The
    second argument is the $numbers array. The array_map() function will automatically
    apply the arrow function to each element in the array and return a new array containing
    the results. We store that new array in the $doubleNumbers variable. Here’s the
    output of running this script and printing the resulting array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The $doubleNumbers array contains the values 20, 40, and 60. This indicates
    that the array_map() function successfully accessed each value in the $numbers
    array and applied the doubling arrow function to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are flexible data structures, especially when we begin assigning meaningful
    string keys to the values of the elements instead of using the default integer
    keys. In this chapter, you learned how to work with string-keyed arrays. You also
    saw how to embed arrays inside other arrays to create multidimensional arrays,
    and how to apply callback functions (written with arrow-function syntax) to every
    element of an array. Techniques like this are what make the array a sophisticated
    structure for representing and manipulating complex data.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Use an array with string keys to store the following pairs of names and
    heights in meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Write a foreach loop to iterate through the array elements and print them out.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Create a multidimensional array to represent the following data about
    movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 3.   Declare one array containing the odd numbers up to nine (1, 3, 5, 7, 9)
    and another with the even numbers (2, 4, 6, 8). Use the array spread operator
    (...) to combine the two arrays, and then sort them into numerical order with
    PHP’s built-in sort() function.
  prefs: []
  type: TYPE_NORMAL
