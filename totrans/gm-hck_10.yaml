- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**CODE INJECTION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码注入**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Imagine being able to walk into a game company’s office, sit down, and start
    adding code to their game client. Imagine that you can do this for any game you
    want, whenever you want, and for any functionality you want. Almost any gamer
    you talk to will have ideas on how to improve a game, but, as far as they know,
    it’s just a pipe dream. But you know that dreams are meant to be fulfilled, and
    now that you’ve learned a bit about how memory works, you’re ready to start throwing
    the rules out the window. Using code injection, you can, for all intents and purposes,
    become as powerful as any game’s developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你能够走进一家游戏公司的办公室，坐下来，开始向他们的游戏客户端添加代码。想象一下，你可以在任何你想要的时间、为任何你想要的游戏、添加任何你想要的功能。几乎所有你交谈过的玩家都会有改进游戏的想法，但在他们看来，这只是一个空想。然而，你知道梦想是可以实现的，现在你已经学会了一些关于内存如何工作的知识，你准备好开始抛弃规则。通过代码注入，你实际上可以变得和任何游戏的开发者一样强大。
- en: '*Code injection* is a means of forcing any process to execute foreign code
    within its own memory space and execution context. I touched on this topic previously
    in “[Bypassing ASLR in Production](ch06.xhtml#ch00lev1sec132)” on [page 128](ch06.xhtml#page_128),
    where I showed you how to remotely subvert ASLR using `CreateRemoteThread()`,
    but that example only scratched the surface. In the first part of this chapter,
    you’ll learn how to create code caves, inject new threads, and hijack thread execution
    to force games to execute small snippets of assembly code. In the second part,
    you’ll learn how to inject foreign binaries directly into games, forcing those
    games to execute entire programs that you’ve created.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码注入*是强制任何进程在其自己的内存空间和执行上下文中执行外部代码的一种方法。我之前在[《绕过生产环境中的ASLR》](ch06.xhtml#ch00lev1sec132)中提到过这个话题，位于[第128页](ch06.xhtml#page_128)，在那里我向你展示了如何通过`CreateRemoteThread()`远程绕过ASLR，但那个例子只是触及了表面。在本章的第一部分，你将学习如何创建代码洞、注入新线程、并劫持线程执行，强制游戏执行小段的汇编代码。在第二部分，你将学习如何直接将外部二进制文件注入游戏，迫使游戏执行你创建的整个程序。'
- en: '**Injecting Code Caves with Thread Injection**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过线程注入注入代码洞**'
- en: The first step to injecting code into another process is writing position-agnostic
    assembly code, known as *shellcode*, in the form of a byte array. You can write
    shellcode to remote processes to form *code caves*, which act as the entry point
    for a new thread that you want a game to execute. Once a code cave is created,
    you can execute it using either *thread injection* or *thread hijacking*. I’ll
    show you an example of thread injection in this section, and I’ll illustrate thread
    hijacking in “[Hijacking a Game’s Main Thread to Execute Code Caves](ch07.xhtml#ch00lev1sec139)”
    on [page 138](ch07.xhtml#page_138).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 向另一个进程注入代码的第一步是编写位置无关的汇编代码，通常称为*shellcode*，其形式为字节数组。你可以将shellcode写入远程进程中，形成*代码洞*，它们作为你希望游戏执行的新线程的入口点。一旦创建了代码洞，你可以通过*线程注入*或*线程劫持*来执行它。在本节中，我将展示一个线程注入的例子，线程劫持的例子将在[《劫持游戏的主线程以执行代码洞》](ch07.xhtml#ch00lev1sec139)中讲解，详见[第138页](ch07.xhtml#page_138)。
- en: You’ll find example code for this chapter in this book’s resource files in the
    directory *GameHackingExamples/Chapter7_CodeInjection*. Open *main-codeInjection.cpp*
    to follow along as I explain how to build a simplified version of the function
    `injectCodeUsingThreadInjection()` from that file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的资源文件中找到本章的示例代码，位于目录*GameHackingExamples/Chapter7_CodeInjection*。打开*main-codeInjection.cpp*，跟随我一起讲解如何构建该文件中简化版的`injectCodeUsingThreadInjection()`函数。
- en: '***Creating an Assembly Code Cave***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建汇编代码洞***'
- en: In “[Bypassing ASLR in Production](ch06.xhtml#ch00lev1sec132)” on [page 128](ch06.xhtml#page_128),
    I used thread injection to call the function `GetModuleHandle()` by way of `CreateRemoteThread()`
    and obtain a process handle. In that case, `GetModuleHandle()` acted as the code
    cave; it had the proper code structure to act as the entry point for a new thread.
    Thread injection isn’t always that easy, though.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[《绕过生产环境中的ASLR》](ch06.xhtml#ch00lev1sec132)中，位于[第128页](ch06.xhtml#page_128)，我使用线程注入通过`CreateRemoteThread()`调用了`GetModuleHandle()`函数并获取了进程句柄。在那种情况下，`GetModuleHandle()`充当了代码洞；它具有合适的代码结构，可以作为新线程的入口点。不过，线程注入并不总是这么简单。
- en: 'For example, say you want your external bot to remotely call a function within
    a game, and the function has this prototype:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你希望你的外部机器人远程调用游戏中的一个函数，并且该函数具有以下原型：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A few things make remotely calling this function tricky. First, it has two parameters,
    meaning you need to create a code cave that will both set up the stack and properly
    make the call. `CreateRemoteThread()` allows you to pass one argument to the code
    cave, and you can access that argument relative to `ESP`, but the other one would
    still need to be hardcoded into the code cave. Hardcoding the first argument,
    `times`, is easiest. Additionally, you’d need to make sure that the cave properly
    cleans the stack.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个因素使得远程调用这个函数变得复杂。首先，它有两个参数，这意味着你需要创建一个代码洞来设置堆栈并正确地进行调用。`CreateRemoteThread()`允许你将一个参数传递给代码洞，你可以相对于`ESP`访问该参数，但另一个参数仍然需要硬编码到代码洞中。硬编码第一个参数`times`是最简单的。此外，你还需要确保代码洞能够正确清理堆栈。
- en: '**NOTE**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall that when bypassing ASLR in [Chapter 6](ch06.xhtml#ch06), I used* `CreateRemoteThread()`
    *to start new threads by executing any arbitrary code at a given address and passing
    that code a single parameter. That’s why these examples can pass one parameter
    using the stack.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下，在绕过[第6章](ch06.xhtml#ch06)的ASLR时，我使用了*`CreateRemoteThread()`*来通过在给定地址执行任意代码并传递一个参数来启动新线程。这就是为什么这些示例可以通过堆栈传递一个参数的原因。*'
- en: 'Ultimately, the code cave to inject that call to `someFunction` into a running
    game process would look something like this pseudocode:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，将调用`someFunction`注入到正在运行的游戏进程中的代码洞将类似于以下伪代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code cave is almost perfect, but it could be less complex. The `CALL`
    operation expects one of two operands: either a register with an absolute function
    address or an immediate integer that holds an offset to a function, relative to
    the return address. This means you’d have to do a bunch of offset calculations,
    which can be tedious.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码洞几乎是完美的，但它可以更简单一些。`CALL`操作需要两个操作数中的一个：要么是包含绝对函数地址的寄存器，要么是包含相对返回地址的函数偏移量的立即数。这意味着你需要做一堆偏移量计算，这会非常繁琐。
- en: To keep the cave position agnostic, modify it to use a register instead, as
    in [Listing 7-1](ch07.xhtml#ch7exe1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码洞的位置无关，修改它以改用寄存器，如[列表 7-1](ch07.xhtml#ch7exe1)所示。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-1: A code cave to call `someFunction`*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：调用`someFunction`的代码洞*'
- en: Since a caller knows that a function it calls will overwrite `EAX` with its
    return value, the caller should ensure that `EAX` doesn’t hold any critical data.
    Knowing this, you can use `EAX` to hold the absolute address of `someFunction`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用者知道它调用的函数会用返回值覆盖`EAX`，调用者应该确保`EAX`不包含任何重要数据。了解这一点后，你可以使用`EAX`来存储`someFunction`的绝对地址。
- en: '***Translating the Assembly to Shellcode***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将汇编代码转换为Shellcode***'
- en: Because code caves need to be written to another process’s memory, they cannot
    be written directly in assembly. Instead, you’ll need to write them byte by byte.
    There’s no standard way to determine which bytes represent which assembly code,
    but there are a few hacky approaches. My personal favorite is to compile an empty
    C++ application with the assembly code in a function and use OllyDbg to inspect
    that function. Alternatively, you could open OllyDbg on any arbitrary process
    and scan through the disassembly until you find the bytes for all of the operations
    you need. This method is actually really good, as your code caves should be written
    as simply as possible, meaning all of the operations should be very common. You
    can also find charts of assembly opcodes online, but I find that they’re all pretty
    hard to read; the methods I just described are easier overall.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码洞需要写入另一个进程的内存，它们不能直接用汇编语言编写。相反，你需要逐字节编写它们。没有标准的方法来确定哪些字节表示哪些汇编代码，但有一些巧妙的方法。我个人最喜欢的是将包含汇编代码的空C++应用程序编译出来，然后使用OllyDbg检查该函数。或者，你可以在任何任意进程中打开OllyDbg，扫描反汇编代码，直到找到你需要的所有操作的字节。这种方法实际上非常好，因为你的代码洞应该尽可能简单地编写，这意味着所有操作应该是非常常见的。你也可以在网上找到汇编操作码的图表，但我发现它们都很难阅读；我刚才描述的方法总体上更容易。
- en: When you know what your bytes should be, you can use C++ to easily generate
    the proper shellcode. [Listing 7-2](ch07.xhtml#ch7exe2) shows the finished shellcode
    skeleton for the assembly in [Listing 7-1](ch07.xhtml#ch7exe1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道字节应该是什么时，你可以使用C++轻松生成正确的shellcode。[列表 7-2](ch07.xhtml#ch7exe2)展示了[列表 7-1](ch07.xhtml#ch7exe1)中的汇编代码的最终shellcode骨架。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-2: Shellcode skeleton*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：Shellcode骨架*'
- en: This example creates a `BYTE` array containing the needed bytes of shellcode.
    But the `times` argument needs to be dynamic, and it’s impossible to know the
    address of `someFunction` at compile time, which is why this shellcode is written
    as a skeleton. The two groups of four sequential 0x00 bytes are placeholders for
    `times` and the address of `someFunction`, and you can insert the real values
    into your code cave at runtime by calling `memcpy()`, as in the snippet in [Listing
    7-3](ch07.xhtml#ch7exe3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个`BYTE`数组，包含所需的shellcode字节。但是，`times`参数需要动态处理，而且在编译时无法知道`someFunction`的地址，这也是为什么这个shellcode是作为骨架编写的原因。两组四个连续的0x00字节是`times`和`someFunction`地址的占位符，你可以通过在运行时调用`memcpy()`将实际的值插入到代码洞中，正如[清单7-3](ch07.xhtml#ch7exe3)中的代码片段所示。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-3: Inserting `times` and the location of `someFunction` into the
    code cave*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-3：将`times`和`someFunction`的位置插入到代码洞中*'
- en: Both `times` and the address of `someFunction` are 4 bytes each (recall that
    `times` is an `int` and addresses are 32-bit values), and they belong at `codeCave[5-8]`
    and `codeCave[10-13]`, respectively. The two calls to `memcpy()` pass this information
    as parameters to fill the blanks in the `codeCave` array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`times`和`someFunction`的地址各占4个字节（回想一下，`times`是`int`类型，地址是32位值），它们分别位于`codeCave[5-8]`和`codeCave[10-13]`。两次调用`memcpy()`将这些信息作为参数传递，以填补`codeCave`数组中的空白。'
- en: '***Writing the Code Cave to Memory***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将代码洞写入内存***'
- en: With the proper shellcode created, you can place it inside the target process
    using `VirtualAllocEx()` and `WriteProcessMemory()`. [Listing 7-4](ch07.xhtml#ch7exe4)
    shows one way to do this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了合适的shellcode之后，你可以通过`VirtualAllocEx()`和`WriteProcessMemory()`将它放入目标进程中。[清单7-4](ch07.xhtml#ch7exe4)展示了实现这一点的一种方法。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-4: Writing the final shellcode to a code cave memory*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-4：将最终的shellcode写入代码洞内存*'
- en: First, this code determines exactly how many bytes of memory it will need to
    write the `string` argument and the code cave into the game’s memory, and it stores
    that value in `fulllen` ➊. Then, it calls the API function `VirtualAllocEx()`
    to allocate `fulllen` bytes inside of `process` with `PAGE_EXECUTE` protection
    (you can always use `0` and `MEM_COMMIT`, respectively, for the second and fourth
    parameters), and it stores the address of the memory in `remoteString` ➋. It also
    increments `remoteString` by `stringlen` bytes and stores the result in `remoteCave`
    ➌, as the shellcode should be written directly to the memory following the `string`
    argument. Finally, it uses `WriteProcessMemory()` to fill the allocated buffer
    with `string` ➍ and the assembly bytes ➎ stored in `codeCave`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码确定了它需要多少字节的内存来将`string`参数和代码洞写入游戏的内存，并将该值存储在`fulllen` ➊中。接着，它调用API函数`VirtualAllocEx()`来分配`fulllen`字节的内存到`process`中，并使用`PAGE_EXECUTE`保护（你总是可以将第二个和第四个参数分别设置为`0`和`MEM_COMMIT`），并将该内存的地址存储在`remoteString`
    ➋中。它还将`remoteString`地址加上`stringlen`字节，并将结果存储在`remoteCave` ➌中，因为shellcode应该直接写入紧随`string`参数后的内存。最后，它使用`WriteProcessMemory()`将`string`
    ➍和存储在`codeCave`中的汇编字节 ➎填充到分配的缓冲区中。
- en: '[Table 7-1](ch07.xhtml#ch7tab1) shows how a memory dump of the code cave might
    look, assuming that it is allocated at 0x030000, `someFunction` is at 0xDEADBEEF,
    `times` is set to `5`, and `string` is pointing to the `injected!` text.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7-1](ch07.xhtml#ch7tab1)展示了代码洞的内存转储可能的样子，假设它被分配在0x030000，`someFunction`位于0xDEADBEEF，`times`被设置为`5`，而`string`指向`injected!`文本。'
- en: '**Table 7-1:** Code Cave Memory Dump'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 代码洞内存转储'
- en: '| **Address** | **Code representation** | **Raw data** | **Data meaning** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **代码表示** | **原始数据** | **数据含义** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0x030000 | `remoteString[0-4]` | 0x69 0x6E 0x6A 0x65 0x63 | `injec` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 0x030000 | `remoteString[0-4]` | 0x69 0x6E 0x6A 0x65 0x63 | `injec` |'
- en: '| 0x030005 | `remoteString[5-9]` | 0x74 0x65 0x64 0x0A 0x00 | `ted!\0` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 0x030005 | `remoteString[5-9]` | 0x74 0x65 0x64 0x0A 0x00 | `ted!\0` |'
- en: '| 0x03000A | `remoteCave[0-3]` | 0xFF 0x74 0x24 0x04 | `PUSH DWORD` `PTR[ESP+0x4]`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 0x03000A | `remoteCave[0-3]` | 0xFF 0x74 0x24 0x04 | `PUSH DWORD` `PTR[ESP+0x4]`
    |'
- en: '| 0x03000E | `remoteCave[4-8]` | 0x68 0x05 0x00 0x00 0x00 | `PUSH 0x05` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 0x03000E | `remoteCave[4-8]` | 0x68 0x05 0x00 0x00 0x00 | `PUSH 0x05` |'
- en: '| 0x030013 | `remoteCave[9-13]` | 0xB8 0xEF 0xBE 0xAD 0xDE | `MOV EAX, 0xDEADBEEF`
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0x030013 | `remoteCave[9-13]` | 0xB8 0xEF 0xBE 0xAD 0xDE | `MOV EAX, 0xDEADBEEF`
    |'
- en: '| 0x030018 | `remoteCave[14-15]` | 0xFF 0xD0 | `CALL EAX` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0x030018 | `remoteCave[14-15]` | 0xFF 0xD0 | `CALL EAX` |'
- en: '| 0x03001A | `remoteCave[16-18]` | 0x83 0xC4 0x08 | `ADD ESP, 0x08` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0x03001A | `remoteCave[16-18]` | 0x83 0xC4 0x08 | `ADD ESP, 0x08` |'
- en: '| 0x03001D | `remoteCave[19]` | 0xC3 | `RETN` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0x03001D | `remoteCave[19]` | 0xC3 | `RETN` |'
- en: The Address column shows where each piece of the cave is located in memory;
    the Code representation column tells you which indexes of `remoteString` and `remoteCave`
    correspond to the bytes in the Raw data column; and the Data meaning column shows
    what the bytes represent, in human-readable format. You can see the `injected!`
    string at 0x030000, the value of `times` at 0x03000E, and the address of `someFunction`
    at 0x030014.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 地址列显示每个代码洞部分在内存中的位置；代码表示列告诉你`remoteString`和`remoteCave`的哪些索引对应原始数据列中的字节；数据意义列以人类可读的格式显示字节的含义。你可以看到0x030000处的`injected!`字符串，0x03000E处的`times`值，以及0x030014处的`someFunction`地址。
- en: '***Using Thread Injection to Execute the Code Cave***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用线程注入执行代码洞***'
- en: 'With a complete code cave written to memory, the only thing left to do is execute
    it. In this example, you could execute the cave using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中写入完整的代码洞后，剩下的唯一任务就是执行它。在这个例子中，你可以使用以下代码来执行代码洞：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The calls to `CreateRemoteThread()`, `WaitForSingleObject()`, and `CloseHandle()`
    work to inject and execute the code cave, and `VirtalFreeEx()` covers the bot’s
    tracks by freeing the memory allocated in code like [Listing 7-4](ch07.xhtml#ch7exe4).
    In the simplest form, that’s all there is to executing a code cave injected into
    a game. In practice, you should also check return values after calling `VirtualAllocEx()`,
    `WriteProcessMemory()`, and `CreateRemoteThread()` to make sure that everything
    was successful.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`CreateRemoteThread()`、`WaitForSingleObject()`和`CloseHandle()`可以注入并执行代码洞，`VirtalFreeEx()`通过释放代码中分配的内存（如[示例7-4](ch07.xhtml#ch7exe4)所示）来掩盖机器人的痕迹。最简单的形式就是执行注入到游戏中的代码洞。实际上，你还应在调用`VirtualAllocEx()`、`WriteProcessMemory()`和`CreateRemoteThread()`后检查返回值，以确保一切顺利。
- en: For instance, if `VirtualAllocEx()` returns 0x00000000, it means that the memory
    allocation failed. If you don’t handle the failure, `WriteProcessMemory()` will
    also fail and `CreateRemoteThread()` will begin executing with an entry point
    of 0x00000000, ultimately crashing the game. The same is true for the return values
    of `WriteProcessMemory()` and `CreateRemoteThread()`. Typically, these functions
    will only fail when the process handle is opened without the required access flags.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`VirtualAllocEx()`返回0x00000000，意味着内存分配失败。如果你不处理这个失败，`WriteProcessMemory()`也会失败，且`CreateRemoteThread()`将以0x00000000为入口点开始执行，最终导致游戏崩溃。`WriteProcessMemory()`和`CreateRemoteThread()`的返回值也是如此。通常，只有在打开进程句柄时没有使用所需的访问标志时，这些函数才会失败。
- en: '**Hijacking a Game’s Main Thread to Execute Code Caves**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**劫持游戏主线程以执行代码洞**'
- en: In some cases, injected code caves need to be in sync with the main thread of
    the game process. Solving this problem can be very tricky because it means that
    you must control the existing threads in an external process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，注入的代码洞需要与游戏进程的主线程同步。解决这个问题可能非常棘手，因为这意味着你必须控制外部进程中的现有线程。
- en: You could simply suspend the main thread until the code cave finishes executing,
    which might work, but that would prove very slow. The overhead required to wait
    for a code cave and then resume a thread is pretty heavy. A faster alternative
    is to force the thread to execute the code for you, a process called *thread hijacking*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地暂停主线程，直到代码洞执行完毕，这可能有效，但速度非常慢。等待代码洞并恢复线程的开销相当大。一个更快的替代方法是强制线程为你执行代码，这个过程称为*线程劫持*。
- en: '**NOTE**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Open the* main-codeInjection.cpp *file in this book’s source code files to
    follow along with building this thread-hijacking example, which is a simplified
    version of* `injectCodeUsingThreadHijacking()`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*打开* main-codeInjection.cpp *文件，以便跟随本书中的源代码构建这个线程劫持示例，这是一个简化版的* `injectCodeUsingThreadHijacking()`。'
- en: '***Building the Assembly Code Cave***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建汇编代码洞***'
- en: As with thread injection, the first step to thread hijacking is knowing what
    you want to happen in your code cave. This time, however, you don’t know what
    the thread will be executing when you hijack it, so you’ll need to make sure to
    save the thread’s state when the code cave starts and restore the state when you’re
    done hijacking it. This means your shellcode needs to be wrapped in some assembly,
    as in [Listing 7-5](ch07.xhtml#ch7exe5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程注入类似，线程劫持的第一步是知道你希望在代码洞中发生什么。然而，这次你并不知道劫持的线程会执行什么内容，所以你需要确保在代码洞开始时保存线程的状态，并在劫持完成后恢复状态。这意味着你的shellcode需要包裹在一些汇编代码中，如[示例7-5](ch07.xhtml#ch7exe5)所示。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-5: A framework for the thread-hijacking code cave*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-5：线程劫持代码洞的框架*'
- en: If you were to call the same `someFunction` that you did with thread injection,
    you could use shellcode similar to that in [Listing 7-2](ch07.xhtml#ch7exe2).
    The only difference is that you couldn’t pass the second parameter to your bot
    using the stack because you wouldn’t be using `CreateRemoteThread()`. But that’s
    no problem; you could just push it the same way you’d push the first parameter.
    The part of the code cave that executes the function you want to call would need
    to look like [Listing 7-6](ch07.xhtml#ch7exe6).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调用与线程注入时相同的`someFunction`，你可以使用类似于[清单7-2](ch07.xhtml#ch7exe2)中的Shellcode。唯一的不同是，你不能通过栈将第二个参数传递给你的机器人，因为你不会使用`CreateRemoteThread()`。但这没有问题；你可以像推送第一个参数那样推送第二个参数。执行你想要调用的函数的代码洞部分应该类似于[清单7-6](ch07.xhtml#ch7exe6)中的内容。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-6: Assembly skeleton for calling `someFunction`*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-6：调用`someFunction`的汇编骨架*'
- en: All that’s changed here from [Listing 7-1](ch07.xhtml#ch7exe1) is that this
    example pushes `string` explicitly and there’s no `RETN`. You don’t call `RETN`
    in this case because you want the game thread to go back to whatever it was doing
    before you hijacked it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单7-1](ch07.xhtml#ch7exe1)相比，唯一的变化是这个例子显式地推送了`string`，并且没有`RETN`。在这种情况下，你不调用`RETN`，因为你希望游戏线程回到它在被劫持之前所做的事情。
- en: To resume the execution of the thread normally, the cave needs to jump back
    to the thread’s original EIP without using registers. Fortunately, you can use
    the `GetThreadContext()` function to fetch `EIP`, filling the shellcode skeleton
    in C++. Then you can push it to the stack inside your code cave and do a return.
    [Listing 7-7](ch07.xhtml#ch7exe7) shows how your code cave would need to end.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要正常恢复线程的执行，代码洞需要跳转回线程原始的EIP，而不使用寄存器。幸运的是，你可以使用`GetThreadContext()`函数来获取`EIP`，然后在C++中填充Shellcode骨架。接着，你可以将其推入栈中并执行返回操作。[清单7-7](ch07.xhtml#ch7exe7)展示了代码洞应该如何结束。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-7: Jumping to EIP indirectly*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-7：间接跳转到EIP*'
- en: 'A return jumps to the value on the top of the stack, so doing this immediately
    after pushing EIP will do the trick. You should use this method instead of a jump,
    because jumps require offset calculation and make the shellcode a bit more complex
    to generate. If you tie [Listings 7-5](ch07.xhtml#ch7exe5) through [7-7](ch07.xhtml#ch7exe7)
    together, you come up with the following code cave:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指令跳转到栈顶的值，因此，在压入EIP之后立即执行跳转即可实现目标。你应该使用这种方法，而不是跳转指令，因为跳转需要偏移量计算，并且会使生成Shellcode变得稍微复杂。如果将[清单7-5](ch07.xhtml#ch7exe5)到[7-7](ch07.xhtml#ch7exe7)连接起来，你会得到以下代码洞：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, follow the instructions in “[Translating the Assembly to Shellcode](ch07.xhtml#ch00lev1sec136)”
    on [page 135](ch07.xhtml#page_135) and plug those bytes into an array representing
    your code cave.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照“[将汇编代码转换为Shellcode](ch07.xhtml#ch00lev1sec136)”中的指示，在[第135页](ch07.xhtml#page_135)上将这些字节插入到表示代码洞的数组中。
- en: '***Generating Skeleton Shellcode and Allocating Memory***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成骨架Shellcode并分配内存***'
- en: Using the same method shown in [Listing 7-2](ch07.xhtml#ch7exe2), you could
    generate the shellcode for this cave, as shown in [Listing 7-8](ch07.xhtml#ch7exe8).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[清单7-2](ch07.xhtml#ch7exe2)中展示的相同方法，你可以生成此代码洞的Shellcode，如[清单7-8](ch07.xhtml#ch7exe8)所示。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 7-8: Creating the thread-hijacking shellcode array*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-8：创建线程劫持Shellcode数组*'
- en: 'As in [Listing 7-3](ch07.xhtml#ch7exe3), `memcpy()` is used to put the variables
    into the skeleton. Unlike in that listing, though, there are two variables that
    cannot be copied right away; `times` and `func` are known immediately, but `remoteString`
    is a result of allocation and `threadContext.Eip` will be known only once the
    thread is frozen. It also makes sense to allocate memory before freezing the thread,
    because you don’t want the thread to be frozen any longer than it has to be. Here’s
    how this might look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[清单7-3](ch07.xhtml#ch7exe3)中所示，`memcpy()`被用来将变量放入骨架中。不过，与该清单中的不同之处在于，有两个变量不能立即复制；`times`和`func`是立即已知的，但`remoteString`是分配的结果，`threadContext.Eip`只有在线程被冻结后才会知道。冻结线程之前分配内存也是合理的，因为你不希望线程冻结的时间比必要的更长。下面是可能的实现方式：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The allocation code is the same as it was for thread injection, so you can reuse
    the same snippet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分配内存的代码与线程注入时相同，因此你可以重复使用相同的代码片段。
- en: '***Finding and Freezing the Main Thread***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找并冻结主线程***'
- en: 'The code to freeze the main thread is a bit trickier. First, you get the thread’s
    unique identifier. This works much like getting a PID, and you can do it using
    `CreateToolhelp32Snapshot()`, `Thread32First()`, and `Thread32Next()` from *TlHelp32.h*.
    As discussed in “[Obtaining the Game’s Process Identifier](ch06.xhtml#ch00lev1sec120)”
    on [page 120](ch06.xhtml#page_120), these functions are used to essentially iterate
    over a list. A process can have many threads, but the following example assumes
    that the first thread the game process created is the one that needs to be hijacked:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结主线程的代码稍微复杂一些。首先，你需要获取线程的唯一标识符。这与获取 PID 类似，你可以使用 `CreateToolhelp32Snapshot()`、`Thread32First()`
    和 `Thread32Next()` 函数，来自 *TlHelp32.h* 文件。如同在 “[获取游戏的进程标识符](ch06.xhtml#ch00lev1sec120)”（第
    120 页）中所讨论的，这些函数基本上是用来遍历一个列表的。一个进程可以有多个线程，但以下示例假设游戏进程创建的第一个线程是需要被劫持的线程：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code simply iterates over the list of all threads on the system and finds
    the first one that matches the game’s PID. Then it gets the thread identifier
    from the snapshot entry. Once you know the thread identifier, fetch the thread’s
    current register state like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地遍历系统中所有线程的列表，找到与游戏的 PID 匹配的第一个线程。然后它从快照条目中获取线程标识符。一旦你知道了线程标识符，就可以像这样获取线程当前的寄存器状态：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code uses `OpenThread()` to get a thread handle. It then suspends the thread
    using `SuspendThread()` and obtains the values of its registers using `GetThreadContext()`.
    After this, the `memcpy()` code in [Listing 7-8](ch07.xhtml#ch7exe8) should have
    all of the variables it needs to finish generating the shellcode.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `OpenThread()` 获取线程句柄。然后，它通过 `SuspendThread()` 暂停线程，并使用 `GetThreadContext()`
    获取其寄存器的值。之后，[列表 7-8](ch07.xhtml#ch7exe8) 中的 `memcpy()` 代码应该拥有生成 shellcode 所需的所有变量。
- en: 'With the shellcode generated, the code cave can be written to the allocated
    memory in the same fashion as in [Listing 7-4](ch07.xhtml#ch7exe4):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成了 shellcode 后，可以像在 [列表 7-4](ch07.xhtml#ch7exe4) 中一样将代码洞写入已分配的内存：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the cave is ready and waiting in memory, all you need to do is set the
    thread’s `EIP` to the address of the code cave and let the thread resume execution,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码洞准备好并在内存中等待，你所需要做的就是将线程的 `EIP` 设置为代码洞的地址，让线程恢复执行，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code causes the thread to resume execution at the address of the code cave.
    Because of the way the code cave is written, the thread has no clue that anything
    has changed. The cave stores the thread’s original state, executes the payload,
    restores the thread’s original state, and then returns to the original code with
    everything intact.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使线程在代码洞的地址处恢复执行。由于代码洞的写法，线程根本不知道任何事情已经改变。代码洞保存了线程的原始状态，执行有效负载，恢复线程的原始状态，然后带着一切完整无损地返回到原始代码。
- en: When you’re using any form of code injection, it is also important to understand
    what data your code caves touch. For example, if you were to create a code cave
    that calls a game’s internal functions to create and send a network packet, you’d
    need to make sure that any global variables that the functions touch (like a packet
    buffer, packet position marker, and so on) are safely restored once you’re done.
    You never know what the game is doing when your code cave is executed—it could
    be calling the same function as you!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用任何形式的代码注入时，了解你的代码洞会接触到哪些数据也很重要。例如，如果你创建一个代码洞来调用游戏的内部函数以创建并发送网络数据包，你需要确保当你完成后，任何函数接触到的全局变量（如数据包缓冲区、数据包位置标记等）都能安全地恢复。你永远无法知道在代码洞执行时游戏在做什么——它可能也在调用与你相同的函数！
- en: '**Injecting DLLs for Full Control**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注入 DLL 实现完全控制**'
- en: 'Code caves are very powerful (you can make a game do anything using assembly
    shellcode), but handcrafting shellcode isn’t practical. It would be much more
    convenient to inject C++ code, wouldn’t it? That’s possible, but the process is
    far more complex: the code must be compiled to assembly, packaged in a position-agnostic
    format, made aware of any external dependencies, entirely mapped into memory,
    and then executed on some entry point.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码洞非常强大（你可以使用汇编语言的 shellcode 让游戏做任何事情），但手工编写 shellcode 并不实际。注入 C++ 代码会方便得多，不是吗？这是可能的，但过程要复杂得多：代码必须先编译成汇编语言，打包成与位置无关的格式，意识到任何外部依赖项，完全映射到内存中，然后在某个入口点执行。
- en: Luckily, all of these things are already taken care of in Windows. By changing
    a C++ project to compile as a dynamic library, you can create a self-contained,
    position-agnostic binary called a *dynamic link library (DLL)*. Then you can use
    a mix of thread injection or hijacking and the `LoadLibrary()` API function to
    map your DLL file into a game’s memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Windows已经处理了所有这些问题。通过将一个C++项目改为编译为动态库，你可以创建一个自包含、位置无关的二进制文件，称为*动态链接库（DLL）*。然后，你可以使用线程注入或劫持和`LoadLibrary()`API函数的混合方法，将你的DLL文件映射到游戏的内存中。
- en: Open *main-codeInjection.cpp* in the *GameHackingExamples/Chapter7_ CodeInjection*
    directory and *dllmain.cpp* under *GameHackingExamples/Chapter7_CodeInjection_DLL*
    to follow along with some example code as you read this section. In *main-codeInjection.cpp*,
    look at the `LoadDLL()` function specifically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*main-codeInjection.cpp*，该文件位于*GameHackingExamples/Chapter7_ CodeInjection*目录下，以及*GameHackingExamples/Chapter7_CodeInjection_DLL*中的*dllmain.cpp*，按照这部分内容中的一些示例代码进行操作。在*main-codeInjection.cpp*中，特别查看`LoadDLL()`函数。
- en: '***Tricking a Process into Loading Your DLL***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***欺骗进程加载你的DLL***'
- en: 'Using a code cave, you can trick a remote process into invoking `LoadLibrary()`
    on a DLL, effectively loading foreign code into its memory space. Because `LoadLibrary()`
    takes only a single parameter, you could create a code cave to call it as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代码洞，你可以欺骗远程进程调用`LoadLibrary()`来加载DLL，从而有效地将外部代码加载到其内存空间中。由于`LoadLibrary()`只接受一个参数，因此你可以创建一个代码洞来调用它，如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is somewhat a mix of the thread injection code from “[Bypassing ASLR
    in Production](ch06.xhtml#ch00lev1sec132)” on [page 128](ch06.xhtml#page_128)
    and the code cave created to call `someFunction` in [Listings 7-2](ch07.xhtml#ch7exe2)
    and [7-3](ch07.xhtml#ch7exe3). Like the former, this example uses the body of
    a single-parameter API function, namely `LoadLibrary`, as the body of the code
    cave. Like the latter, though, it has to inject a string into memory, since `LoadLibrary`
    expects a string pointer as its first argument. Once the thread is injected, it
    forces `LoadLibrary` to load the DLL whose name was injected into memory, effectively
    putting foreign code into a game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上是混合了来自“[绕过ASLR生产环境](ch06.xhtml#ch00lev1sec132)”第128页的线程注入代码和在[Listings
    7-2](ch07.xhtml#ch7exe2)和[7-3](ch07.xhtml#ch7exe3)中创建的调用`someFunction`的代码洞。与前者类似，这个示例使用单参数API函数的函数体，具体是`LoadLibrary`，作为代码洞的主体。不过像后者一样，它需要将一个字符串注入到内存中，因为`LoadLibrary`将字符串指针作为第一个参数。一旦线程被注入，它会强制`LoadLibrary`加载被注入内存中的DLL，从而有效地将外部代码注入到游戏中。
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Give any DLL you plan to inject a unique name, like* MySuperBotV2Hook.dll.
    *Simpler names, such as* Hook.dll *or* Injected.dll*, are dangerously generic.
    If the name conflicts with a DLL that is already loaded,* `LoadLibrary()` *will
    assume that it is the same DLL and not load it!*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*为你计划注入的任何DLL起一个独特的名字，比如*MySuperBotV2Hook.dll。*更简单的名字，例如*Hook.dll*或*Injected.dll*，则过于通用，具有潜在危险。如果名字与已经加载的DLL冲突，*`LoadLibrary()`*将认为它是同一个DLL，从而不加载它！*'
- en: 'Once the `LoadLibrary()` code cave loads your DLL into a game, the DLL’s entry
    point—known as `DllMain()`—will be executed with `DLL_PROCESS_ATTACH` as the reason.
    When the process is killed or `FreeLibrary()` is called on the DLL, its entry
    point will be called with the `DLL_PROCESS_DETACH` reason. Handling these events
    from the entry point might look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`LoadLibrary()`代码洞将你的DLL加载到游戏中，DLL的入口点——即`DllMain()`——将以`DLL_PROCESS_ATTACH`作为原因被执行。当进程被终止或调用`FreeLibrary()`时，DLL的入口点将以`DLL_PROCESS_DETACH`作为原因被调用。从入口点处理这些事件可能看起来是这样的：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example function starts by checking why `DllMain()` was called. It then
    outputs text indicating whether it was called because the DLL was attached or
    detached, returning `TRUE` either way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例函数首先检查为什么调用了`DllMain()`。然后输出文本，指示它是因为DLL被附加还是分离而被调用，无论哪种情况，都会返回`TRUE`。
- en: Keep in mind that the entry point of a DLL is executed inside a *loader lock*,
    which is a global synchronization lock used by all functions that read or modify
    the list of modules loaded in a process. This loader lock gets used by functions
    like `GetModuleHandle()`, `GetModuleFileName()`, `Module32First()`, and `Module32Next()`,
    which means that running nontrivial code from a DLL entry point can lead to deadlocks
    and should be avoided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，DLL的入口点是在*加载器锁*内执行的，加载器锁是一个全局同步锁，用于所有读取或修改进程中加载的模块列表的函数。像`GetModuleHandle()`、`GetModuleFileName()`、`Module32First()`和`Module32Next()`等函数会使用这个加载器锁，这意味着从DLL入口点运行复杂代码可能会导致死锁，应当避免。
- en: 'If you need to run code from a DLL entry point, do so from a new thread, as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从DLL入口点运行代码，请通过新线程来执行，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From `DllMain()`, this code creates a new thread starting on the function `runBot()`.
    It then immediately closes its handle to the thread, as doing any further operations
    from `DllMain()` can lead to serious problems. From inside this `runBot()`, you
    can begin executing your bot’s code. The code runs inside the game, meaning you
    can directly manipulate memory using the type-casting methods. You can also do
    a lot more, as you’ll see in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从`DllMain()`开始，这段代码创建了一个新线程，线程从`runBot()`函数开始。然后它立即关闭了对该线程的句柄，因为从`DllMain()`执行进一步操作可能会导致严重的问题。在`runBot()`内部，你可以开始执行你的机器人代码。代码在游戏内部运行，这意味着你可以直接使用类型转换方法来操作内存。你还能做更多的事情，正如你将在[第8章](ch08.xhtml#ch08)中看到的。
- en: When injecting DLLs, make sure you have no dependency issues. If your DLL relies
    on some nonstandard DLLs, for example, you have to either inject those DLLs into
    the game first or put them in a folder that `LoadLibrary()` will search, such
    as any folder in the `PATH` environment variable. The former will work only if
    the DLLs have no dependencies of their own, whereas the latter is a bit tricky
    to implement and subject to name collisions. The best option is to link all external
    libraries statically so that they are compiled directly into your DLL.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入DLL时，确保没有依赖问题。如果你的DLL依赖某些非标准的DLL，例如，你必须先将这些DLL注入游戏中，或者将它们放在`LoadLibrary()`会搜索的文件夹中，比如`PATH`环境变量中的任何文件夹。前者只有在这些DLL没有自己的依赖关系时才有效，而后者实现起来有些棘手，并且容易发生名称冲突。最佳的选择是将所有外部库静态链接，这样它们就会直接编译到你的DLL中。
- en: '***Accessing Memory in an Injected DLL***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问注入DLL中的内存***'
- en: 'When you’re trying to access a game’s memory from an injected DLL, process
    handles and API functions are a hindrance. Because a game shares the same memory
    space as all code injected into it, you can access a game’s memory directly from
    injected code. For example, to access a `DWORD` value from injected code, you
    could write the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试从注入的DLL访问游戏内存时，进程句柄和API函数会成为障碍。因为游戏与所有注入其中的代码共享相同的内存空间，所以你可以直接从注入的代码访问游戏的内存。例如，要从注入的代码访问一个`DWORD`值，你可以写如下代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This simply typecasts the memory address `adr` to a `DWORD*` and dereferences
    that pointer to a `DWORD`. Doing typecasts in place like that is fine, but your
    memory access code will look cleaner if the functions are abstracted and made
    generic, just like the Windows API wrappers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将内存地址`adr`强制转换为`DWORD*`类型，然后解引用该指针为一个`DWORD`。这样进行类型转换是可以的，但如果将函数抽象化并通用化，像Windows
    API包装器一样，你的内存访问代码会更加简洁。
- en: 'The generic functions for accessing memory from inside injected code look something
    like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从注入的代码内部访问内存的通用函数看起来像这样：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using these templates is just like using the functions under “[Writing Templated
    Memory Access Functions](ch06.xhtml#ch00lev1sec126)” on [page 123](ch06.xhtml#page_123).
    Here’s an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模板就像在[第123页](ch06.xhtml#page_123)的“[编写模板化内存访问函数](ch06.xhtml#ch00lev1sec126)”部分使用函数一样。以下是一个例子：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These calls are nearly identical to the calls in [Listing 6-6](ch06.xhtml#ch6exe6)
    on [page 124](ch06.xhtml#page_124); they just don’t need to take the process handle
    as an argument because they’re being called from inside the process itself. You
    can make this method even more flexible by creating a third templated function
    called `pointMemory()`, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用与[清单6-6](ch06.xhtml#ch6exe6)中[第124页](ch06.xhtml#page_124)的调用几乎完全相同；它们只是无需将进程句柄作为参数传入，因为它们是从进程内部调用的。你可以通过创建一个名为`pointMemory()`的第三个模板函数来使这个方法更灵活，如下所示：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function skips the dereferencing step of a memory read and simply gives
    you the pointer to the data. From there, you’re free to both read from and write
    to the memory by dereferencing that pointer yourself, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数跳过了内存读取的解引用步骤，直接给你数据的指针。从这里开始，你可以自由地通过解引用这个指针来读取和写入内存，就像这样：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With a function like `pointMemory()` in place, you could eliminate the calls
    to `readMemory()` and `writeMemory()`. You’d still need to find `adr` ahead of
    time, but from there, the code to read a value, change it, and write it back would
    be much simpler to follow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`pointMemory()`这样的函数，你可以省略对`readMemory()`和`writeMemory()`的调用。你仍然需要事先找到`adr`，但从那时起，读取值、改变值并将其写回的代码会变得更加简洁。
- en: '***Bypassing ASLR in an Injected DLL***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绕过注入DLL中的ASLR***'
- en: 'Similarly, since the code is injected, there’s no need to inject a thread into
    the game to get the base address. Instead, you can just call `GetModuleHandle()`
    directly, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，由于代码已经被注入，因此无需再为游戏注入一个线程来获取基地址。相反，你可以直接调用`GetModuleHandle()`，像这样：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A faster way to get the base address is to utilize the game’s FS memory segment,
    which is another superpower you get from injected code. This memory segment points
    to a structure called the *thread environment block (TEB)*, and 0x30 bytes into
    the TEB is a pointer to the *process environment block (PEB)* structure. These
    structures are used by the operating system and contain a ton of data about the
    current thread and the current process, but we’re interested only in the base
    address of the main module, which is stored 0x8 bytes into the PEB. Using inline
    assembly, you can traverse these structures to get `newBase`, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 获取基地址的一个更快方法是利用游戏的FS内存段，这是你从注入的代码中获得的另一个超能力。这个内存段指向一个叫做*线程环境块（TEB）*的结构体，而TEB中偏移0x30的地方是指向*进程环境块（PEB）*结构体的指针。操作系统使用这些结构体，它们包含大量关于当前线程和当前进程的数据，但我们只对存储在PEB中的主模块基地址感兴趣，基地址位于PEB的偏移0x8处。通过内联汇编，你可以遍历这些结构来获取`newBase`，像这样：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first command stores the `PEB` address in `EAX`, and the second command
    reads the main module’s base address and stores it in `EAX`. The final command
    then copies `EAX` to `newBase`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将`PEB`地址存储在`EAX`中，第二个命令读取主模块的基地址并将其存储在`EAX`中。最后一个命令将`EAX`复制到`newBase`。
- en: '**Closing Thoughts**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结思考**'
- en: In [Chapter 6](ch06.xhtml#ch06), I showed you how to read from memory remotely
    and how an injected DLL can directly access a game’s memory using pointers. This
    chapter demonstrated how to inject all types of code, from pure assembly byte
    code to entire C++ binaries. In the next chapter, you’ll learn just how much power
    being in a game’s memory space actually gives you. If you thought assembly code
    injection was cool, you’ll love what you can do when you mix injected C++ with
    control flow manipulation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml#ch06)中，我向你展示了如何远程读取内存，以及注入的DLL如何通过指针直接访问游戏的内存。本章展示了如何注入各种类型的代码，从纯汇编字节码到完整的C++二进制文件。在下一章，你将了解到进入游戏内存空间究竟能赋予你多少权力。如果你觉得汇编代码注入很酷，那么你会喜欢将注入的C++与控制流操作结合后的效果。
- en: The example code for this chapter contains proofs of concept for everything
    we’ve discussed. If you’re still unclear about any of the topics, you can poke
    at the code to learn exactly what’s going on and see all of the tricks in action.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码包含了我们讨论的所有概念验证。如果你对其中的任何主题仍然不清楚，可以通过查看代码来了解具体发生了什么，并看到所有技巧的实际应用。
