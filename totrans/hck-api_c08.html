<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 8: Attacking Authentication</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_179" title="179"/>8</span><br/>
<span class="ChapterTitle">Attacking Authentication</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">When it comes to testing authentication, you’ll find that many of the flaws that have plagued web applications for decades have been ported over to APIs: bad passwords and password requirements, default credentials, verbose error messaging, and bad password reset processes.</p>
<p>In addition, several weaknesses are much more commonly found in APIs than traditional web apps. Broken API authentication comes in many forms. You might encounter a lack of authentication altogether, a lack of rate limiting applied to authentication attempts, the use of a single token or key for all requests, tokens created with insufficient entropy, and several JSON Web Token (JWT) configuration weaknesses.</p>
<p>This chapter will guide you through classic authentication attacks like brute-force attacks and password spraying, and then we’ll cover API-specific token attacks, such as token forgery and JWT attacks. Generally, these attacks share the common goal of gaining unauthorized access, whether this means <span epub:type="pagebreak" id="Page_180" title="180"/>going from a state of no access to a state of unauthorized access, obtaining access to the resources of other users, or going from a state of limited API access to one of privileged access.</p>
<h2 id="h1-502444c08-0001">Classic Authentication Attacks</h2>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we covered the simplest form of authentication used in APIs: basic authentication. To authenticate using this method, the consumer issues a request containing a username and password. As we know, RESTful APIs do not maintain state, so if the API uses basic authentication across the API, a username and password would have to be issued with every request. Thus, providers typically use basic authentication only as part of a registration process. Then, after users have successfully authenticated, the provider issues an API key or token. The provider then checks that the username and password match the authentication information stored. If the credentials match, the provider issues a successful response. If they don’t match, the API may issue one of several responses. The provider may just send a generic response for all incorrect authentication attempts: “Incorrect username or password.” This tells us the least amount of information, but sometimes providers will tilt the scales toward consumer convenience and provide us with more useful information. The provider could specifically tell us that a username does not exist. Then we will have a response we can use to help us discover and validate usernames.</p>
<h3 id="h2-502444c08-0001">Password Brute-Force Attacks</h3>
<p class="BodyFirst">One of the more straightforward methods for gaining access to an API is performing a brute-force attack. Brute-forcing an API’s authentication is not very different from any other brute-force attack, except you’ll send the request to an API endpoint, the payload will often be in JSON, and the authentication values may be base64 encoded. Brute-force attacks are loud, often time-consuming, and brutish, but if an API lacks security controls to prevent brute-force attacks, we should not shy away from using this to our advantage.</p>
<p>One of the best ways to fine-tune your brute-force attack is to generate passwords specific to your target. To do this, you could leverage the information revealed in an excessive data exposure vulnerability, like the one you found in Lab #4, to compile a username and password list. The excess data could reveal technical details about the user’s account, such as whether the user was using multifactor authentication, whether they had a default password, and whether the account has been activated. If the excess data involved information about the user, you could feed it to tools that can generate large, targeted password lists for brute-force attacks. For more information about creating targeted password lists, check out the Mentalist app (<a class="LinkURL" href="https://github.com/sc0tfree/mentalist">https://github.com/sc0tfree/mentalist</a>) or the Common User Passwords Profiler (<a class="LinkURL" href="https://github.com/Mebus/cupp">https://github.com/Mebus/cupp</a>).</p>
<p>To actually perform the brute-force attack once you have a suitable wordlist, you can use tools such as Burp Suite’s brute forcer or Wfuzz, <span epub:type="pagebreak" id="Page_181" title="181"/>introduced in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>. The following example uses Wfuzz with an old, well-known password list, <em>rockyou.txt</em>:</p>
<pre><code>$ <b>wfuzz -d '{"email":"a@email.com","password":"FUZZ"}' --hc 405 -H 'Content-Type: application/json' -z file,/home/hapihacker/rockyou.txt http://192.168.195.130:8888/api/v2/auth</b>
==================================================================
ID             Response   Lines    Word       Chars       Payload
==================================================================
000000007:   200        0 L      1 W        225 Ch      "Password1!"
000000005:   400        0 L      34 W       474 Ch      "win"</code></pre>
<p>The <code>-d</code> option allows you to fuzz content that is sent in the body of a POST request. The curly brackets that follow contain the POST request body. To discover the request format used in this example, I attempted to authenticate to a web application using a browser, and then I captured the authentication attempt and replicated its structure here. In this instance, the web app issues a POST request with the parameters <code>"email"</code> and <code>"password"</code>. The structure of this body will change for each API. In this example, you can see that we’ve specified a known email and used the <code>FUZZ</code> parameter as the password.</p>
<p>The <code>--hc</code> option hides responses with certain response codes. This is useful if you often receive the same status code, word length, and character count in many requests. If you know what a typical failure response looks like for your target, there is no need to see hundreds or thousands of that same response. The <code>–hc</code> option helps you filter out the responses you don’t want to see.</p>
<p>In the tested instance, the typical failed request results in a 405 status code, but this may also differ with each API. Next, the <code>-H</code> option lets you add a header to the request. Some API providers may issue an HTTP 415 Unsupported Media Type error code if you don’t include the <code>Content-Type:application/json</code> header when sending JSON data in the request body.</p>
<p>Once your request has been sent, you can review the results in the command line. If your <code>–hc</code> Wfuzz option has worked out, your results should be fairly easy to read. Otherwise, status codes in the 200s and 300s should be good indicators that you have successfully brute-forced credentials.</p>
<h3 id="h2-502444c08-0002">Password Reset and Multifactor Authentication Brute-Force Attacks</h3>
<p class="BodyFirst">While you can apply brute-force techniques directly to the authentication requests, you can also use them against password reset and multifactor authentication (MFA) functionality. If a password reset process includes security questions and does not apply rate limiting to requests, we can target it in such an attack.</p>
<p>Like GUI web applications, APIs often use SMS recovery codes or one-time passwords (OTPs) in order to verify the identity of a user who wants to reset their password. Additionally, a provider may deploy MFA to successful authentication attempts, so you’ll have to bypass that process to gain access to the account. On the backend, an API often implements this functionality using a service that sends a four- to six-digit code to the phone number <span epub:type="pagebreak" id="Page_182" title="182"/>or email associated with the account. If we’re not stopped by rate limiting, we should be able to brute-force these codes to gain access to the targeted account.</p>
<p>Begin by capturing a request for the relevant process, such as a password reset process. In the following request, you can see that the consumer includes an OTP in the request body, along with the username and new password. Thus, to reset a user’s password, we’ll need to guess the OTP.</p>
<pre><code>POST /identity/api/auth/v3/check-otp HTTP/1.1
Host: 192.168.195.130:8888
User-Agent: Mozilla/5.0 (x11; Linux x86_64; rv: 78.0) Gecko/20100101
Accept: */*
Accept -Language: en-US, en;q=0.5
Accept-Encoding: gzip,deflate
Referer: http://192.168.195.130:8888/forgot-password
Content-Type: application/json
Origin: http://192.168.195.130:8888
Content-Length: 62
Connection: close

{
"email":"a@email.com",
<b>"otp":"1234"</b>,
"password": "Newpassword"
}</code></pre>
<p>In this example, we’ll leverage the brute forcer payload type in Burp Suite, but you could configure and run an equivalent attack using Wfuzz with brute-force options. Once you’ve captured a password reset request in Burp Suite, highlight the OTP and add the attack position markers discussed in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> to turn the value into a variable. Next, select the <b>Payloads</b> tab and set the payload type to <b>brute forcer</b> (see <a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a>).</p>
<figure>
<img alt="Screenshot of the Burp Suite Payloads tab with the “Payload set” field set to “1,” the “Payload type” field set to “Brute forcer,” the “Character set” field set to” 0123456789,” and the Min length and Max length fields both set to “4”" class="keyline" src="image_fi/502444c08/F08001.png"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: Configuring Burp Suite Intruder with the brute forcer payload type set</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_183" title="183"/>If you’ve configured your payload settings correctly, they should match those in <a href="#figure8-1">Figure 8-1</a>. In the character set field, only include numbers and characters used for the OTP. In its verbose error messaging, the API provider may indicate what values it expects. You can often test this by initiating a password reset of your own account and checking to see what the OTP consists of. For example, if the API uses a four-digit numeric code, add the numbers 0 to 9 to the character set. Then set the minimum and maximum length of the code to <b>4</b>.</p>
<p>Brute-forcing the password reset code is definitely worth a try. However, many web applications will both enforce rate limiting and limit the number of times you can guess the OTP. If rate limiting is holding you back, perhaps one of the evasion techniques in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> could be of some use.</p>
<h3 id="h2-502444c08-0003">Password Spraying</h3>
<p class="BodyFirst">Many security controls could prevent you from successfully brute-forcing an API’s authentication. A technique called <em>password spraying</em> can evade many of these controls by combining a long list of users with a short list of targeted passwords. Let’s say you know that an API authentication process has a lockout policy in place and will only allow 10 login attempts. You could craft a list of the nine most likely passwords (one less password than the limit) and use these to attempt to log in to many user accounts.</p>
<p>When you’re password spraying, large and outdated wordlists like <em>rockyou.txt</em> won’t work. There are way too many unlikely passwords in such a file to have any success. Instead, craft a short list of likely passwords, taking into account the constraints of the API provider’s password policy, which you can discover during reconnaissance. Most password policies likely require a minimum character length, upper- and lowercase letters, and perhaps a number or special character.</p>
<p>Try mixing your password-spraying list with two types of <em>path of small-resistance (POS)</em> passwords, or passwords that are simple enough to guess but complex enough to meet basic password requirements (generally a minimum of eight characters, a symbol, upper- and lowercase letters, and a number). The first type includes obvious passwords like QWER!@#$, Password1!, and the formula <em>Season+Year+Symbol</em> (such as Winter2021!, Spring2021?, Fall2021!, and Autumn2021?). The second type includes more advanced passwords that relate directly to the target, often including a capitalized letter, a number, a detail about the organization, and a symbol. Here is a short password-spraying list I might generate if I were attacking an endpoint for Twitter employees:</p>
<ol class="none">
<li>Winter2021!</li>
<li>Spring2021!</li>
<li>QWER!@#$</li>
<li>Password1!</li>
<li>March212006!</li>
<li>July152006!</li>
<li>Twitter@2022</li>
<li>JPD1976!</li>
<li>Dorsey@2021</li>
</ol>
<p><span epub:type="pagebreak" id="Page_184" title="184"/>The key to password spraying is to maximize your user list. The more usernames you include, the higher your odds of gaining access. Build a user list during your reconnaissance efforts or by discovering excessive data exposure vulnerabilities.</p>
<p>In Burp Suite’s Intruder, you can set up this attack in a similar manner to the standard brute-force attack, except you’ll use both a list of users and a list of passwords. Choose the cluster bomb attack type and set the attack positions around the username and password, as shown in <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a>.</p>
<figure>
<img alt="Screenshot of the Burp Suite Payload Positions screen with the Attack type set to “Cluster bomb” and the email and password fields set to payload positions in the POST request body" class="keyline" src="image_fi/502444c08/F08002.png"/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: A credential-spraying attack using Intruder</p></figcaption>
</figure>
<p>Notice that the first attack position is set to replace the username in front of <em>@email.com</em>, which you can do if you’ll only be testing for users within a specific email domain.</p>
<p>Next, add the list of collected users as the first payload set and a short list of passwords as your second payload set. Once your payloads are configured as in <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>, you’re ready to perform a password-spraying attack.</p>
<figure>
<img alt="Two screenshots of Burp Suite’s Payload Sets and Payload Options screens. The first has the “Payload set” field set to one and a list of names as the Payload Options. The second has the “Payload set” field set to 2 and a list of common passwords as the Payload Options." class="keyline" src="image_fi/502444c08/F08003.png"/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: Burp Suite Intruder example payloads for a cluster bomb attack</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_185" title="185"/>When you’re analyzing the results, it helps if you have an idea of what a standard successful login looks like. If you’re unsure, search for anomalies in the lengths and response codes returned. Most web applications respond to successful login results with an HTTP status code in the 200s or 300s. In <a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a>, you can see a successful password-spraying attempt that has two anomalous features: a status code of 200 and a response length of 682.</p>
<figure>
<img alt="Screenshot of Burp Suite Intruder with a list of submitted payloads, the status codes received in the response, and the length of each response. Most have a status code of 500 and a length of 479, but one has a status code of 200 and a length of 682." class="keyline" src="image_fi/502444c08/F08004.png"/>
<figcaption><p><a id="figure8-4">Figure 8-4</a>: A successful password-spraying attack using Intruder</p></figcaption>
</figure>
<p>To help spot anomalies using Intruder, you can sort the results by status code or response length.</p>
<h3 id="h2-502444c08-0004">Including Base64 Authentication in Brute-Force Attacks</h3>
<p class="BodyFirst">Some APIs will base64-encode authentication payloads sent in an API request. There are many reasons to do this, but it’s important to know that security is not one of them. You can easily bypass this minor inconvenience.</p>
<p>If you test an authentication attempt and notice that an API is encoding to base64, it is likely making a comparison to base64-encoded credentials on the backend. This means you should adjust your fuzzing attacks to include base64 payloads using Burp Suite Intruder, which can both encode and decode base64 values. For example, the password and email values in <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a> are base64 encoded. You can decode them by highlighting the payload, right-clicking, and selecting <b>Base64-decode</b> (or the shortcut <span class="KeyCaps">ctrl-shift</span>-B). This will reveal the payload so that you can see how it is formatted.</p>
<p>To perform, say, a password-spraying attack using base64 encoding, begin by selecting the attack positions. In this case, we’ll select the base64-encoded password from the request in <a href="#figure8-5">Figure 8-5</a>. Next, add the payload set; we’ll use the passwords listed in the previous section.</p>
<p>Now, in order to encode each password before it is sent in a request, we must use a payload-processing rule. Under the Payloads tab is an option to add such a rule. Select <b>Add</b><span class="MenuArrow">▶</span><b>Encoded</b><span class="MenuArrow">▶</span><b>Base64-encode</b> and then click <b>OK</b>. Your payload-processing window should look like <a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>.</p>
<span epub:type="pagebreak" id="Page_186" title="186"/><figure>
<img alt="Screenshot of an HTTP request in Burp Suite with a value highlighted and right-clicked, and “Convert selection, Base64, Base64-decode” selected in the menu" class="keyline" src="image_fi/502444c08/F08005.png"/>
<figcaption><p><a id="figure8-5">Figure 8-5</a>: Decoding base64 using Burp Suite Intruder</p></figcaption>
</figure>
<figure>
<img alt="Screenshot of Burp Suite’s “Add Payload Processing Rule” menu. “Encode” and “Base64-encode” are selected in the drop-down menus." class="keyline" src="image_fi/502444c08/F08006.png"/>
<figcaption><p><a id="figure8-6">Figure 8-6</a>: Adding a payload-processing rule to Burp Suite Intruder</p></figcaption>
</figure>
<p>Now your base64-encoded password-spraying attack is ready to launch.</p>
<h2 id="h1-502444c08-0002"><span epub:type="pagebreak" id="Page_187" title="187"/>Forging Tokens</h2>
<p class="BodyFirst">When implemented correctly, tokens can be an excellent way for APIs to authenticate users and authorize them to access their resources. However, if anything goes wrong when generating, processing, or handling tokens, they’ll become our keys to the kingdom.</p>
<p>The problem with tokens is that they can be stolen, leaked, and forged. We’ve already covered how to steal and find leaked tokens in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. In this section, I’ll guide you through the process of forging your own tokens when weaknesses are present in the token generation process. This requires first analyzing how predictable an API provider’s token generation process is. If we can discover any patterns in the tokens being provided, we may be able to forge our own or hijack another user’s tokens.</p>
<p>APIs will often use tokens as an authorization method. A consumer may have to initially authenticate using a username and password combination, but then the provider will generate a token and give that token to the consumer to use with their API requests. If the token generation process is flawed, we will be able to analyze the tokens, hijack other user tokens, and then use them to access the resources and additional API functionality of the affected users.</p>
<p>Burp Suite’s Sequencer provides two methods for token analysis: manually analyzing tokens provided in a text file and performing a live capture to automatically generate tokens. I will guide you through both processes.</p>
<h3 id="h2-502444c08-0005">Manual Load Analysis</h3>
<p class="BodyFirst">To perform a manual load analysis, select the <b>Sequencer</b> module and choose the <b>Manual Load</b> tab. Click <b>Load</b> and provide the list of tokens you want to analyze. The more tokens you have in your sample, the better the results will be. Sequencer requires a minimum of 100 tokens to perform a basic analysis, which includes a <em>bit-level</em> analysis, or an automated analysis of the token converted to sets of bits. These sets of bits are then put through a series of tests involving compression, correlation, and spectral testing, as well as four tests based on the Federal Information Processing Standard (FIPS) 140-2 security requirements.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	If you would like to follow along with the examples in this section, generate your own tokens or use the bad tokens hosted on the Hacking-APIs GitHub repo (<a class="LinkURL" href="https://github.com/hAPI-hacker/Hacking-APIs">https://github.com/hAPI-hacker/Hacking-APIs</a>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>A full analysis will also include <em>character-level</em> analysis, a series of tests performed on each character in the given position in the original form of the tokens. The tokens are then put through a character count analysis and a character transition analysis, two tests that analyze how characters are distributed within a token and the differences between tokens. To perform a full analysis, Sequencer could require thousands of tokens, depending on the size and complexity of each individual token.</p>
<p><span epub:type="pagebreak" id="Page_188" title="188"/>Once your tokens are loaded, you should see the total number of tokens loaded, the shortest token, and the longest token, as shown in <a href="#figure8-7" id="figureanchor8-7">Figure 8-7</a>.</p>
<figure>
<img alt="Screenshot of Burp Suite Sequencer with token values loaded to the Manual Load field." class="keyline" src="image_fi/502444c08/F08007.png"/>
<figcaption><p><a id="figure8-7">Figure 8-7</a>: Manually loaded tokens in Burp Suite Sequencer</p></figcaption>
</figure>
<p>Now you can begin the analysis by clicking <b>Analyze Now</b>. Burp Suite should then generate a report (see <a href="#figure8-8" id="figureanchor8-8">Figure 8-8</a>).</p>
<figure>
<img alt="Screenshot of the Burp Suite Sequencer Summary tab with “Overall result” and “Effective Entropy” sections describing the results of the analysis" class="keyline" src="image_fi/502444c08/F08008.png"/>
<figcaption><p><a id="figure8-8">Figure 8-8</a>: The Summary tab of the token analysis report provided by Sequencer</p></figcaption>
</figure>
<p>The token analysis report begins with a summary of the findings. The overall results include the quality of randomness within the token sample. In <a href="#figure8-8">Figure 8-8</a>, you can see that the quality of randomness was extremely poor, indicating that we’ll likely be able to brute-force other existing tokens.</p>
<p>To minimize the effort required to brute-force tokens, we’ll want to determine if there are parts of the token that do not change and other parts that often change. Use the character position analysis to determine which characters should be brute-forced (see <a href="#figure8-9" id="figureanchor8-9">Figure 8-9</a>). You can find this feature under Character Set<b> </b>within the Character-Level Analysis tab.</p>
<p>As you can see, the token character positions do not change all that much, with the exception of the final three characters; the string <code>Ab4dt0k3n</code> remains the same throughout the sampling. Now we know we should perform a brute force of only the final three characters and leave the remainder of the token untouched.</p>
<span epub:type="pagebreak" id="Page_189" title="189"/><figure>
<img alt="Screenshot of the Burp Suite Sequencer “Character Set” menu. Shows a chart of the size of the character set used in each position. Most positions have a character set smaller than 5, but the 10th position has more than 25 characters in its character set." class="keyline" src="image_fi/502444c08/F08009.png"/>
<figcaption><p><a id="figure8-9">Figure 8-9</a>: The character position chart found within Sequencer’s character-level analysis</p></figcaption>
</figure>
<h3 id="h2-502444c08-0006">Live Token Capture Analysis</h3>
<p class="BodyFirst">Burp Suite’s Sequencer can automatically ask an API provider to generate 20,000 tokens for analysis. To do this, we simply intercept the provider’s token generation process and then configure Sequencer. Burp Suite will repeat the token generation process up to 20,000 times to analyze the tokens for similarities.</p>
<p>In Burp Suite, intercept the request that initiates the token generation process. Select <b>Action </b>(or right-click the request) and then forward it to Sequencer. Within Sequencer, make sure you have the live capture tab selected, and under <b>Token Location Within Response</b>, select the <b>Configure for the Custom Location</b> option. As shown in <a href="#figure8-10" id="figureanchor8-10">Figure 8-10</a>, highlight the generated token and click <b>OK</b>.</p>
<p>Select <b>Start Live Capture</b>. Burp Sequencer will now begin capturing tokens for analysis. If you select the Auto analyze checkbox, Sequencer will show the effective entropy results at different milestones.</p>
<p>In addition to performing an entropy analysis, Burp Suite will provide you with a large collection of tokens, which could be useful for evading security controls (a topic we explore in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>). If an API doesn’t invalidate the tokens once new ones are created and the security controls use tokens as the method of identity, you now have up to 20,000 identities to help you avoid detection.</p>
<p>If there are token character positions with low entropy, you can attempt a brute-force attack against those character positions. Reviewing tokens with low entropy could reveal certain patterns you could take advantage of. For example, if you noticed that characters in certain positions only contained lowercase letters, or a certain range of numbers, you’ll be able to enhance your brute-force attacks by minimizing the number of request attempts.</p>
<span epub:type="pagebreak" id="Page_190" title="190"/><figure>
<img alt="Screenshot of Burp Suite Sequencer’s “Define custom token location” menu. “Define start and end” is checked, an expression is set for both the “Start after expression” and “End at delimiter” fields, and a token value is shown highlighted in an HTTP response." class="" src="image_fi/502444c08/F08010.png"/>
<figcaption><p><a id="figure8-10">Figure 8-10</a>: The API provider’s token response selected for analysis</p></figcaption>
</figure>
<h3 id="h2-502444c08-0007">Brute-Forcing Predictable Tokens</h3>
<p class="BodyFirst">Let’s return to the bad tokens discovered during manual load analysis (whose final three characters are the only ones that change) and brute-force possible letter and number combinations to find other valid tokens. Once we’ve discovered valid tokens, we can test our access to the API and find out what we’re authorized to do.</p>
<p>When you’re brute-forcing through combinations of numbers and letters, it is best to minimize the number of variables. The character-level analysis has already informed us that the first nine characters of the token <code>Ab4dt0k3n</code> remain static. The final three characters are the variables, and based on the sample, we can see that they follow a pattern of <em>letter1</em> + <em>letter2</em> + <em>number</em>. Moreover, a sample of the tokens tells us that that <em>letter1</em> only ever consists of letters between <em>a</em> and <em>d</em>. Observations like this will help minimize the total amount of brute force required.</p>
<p>Use Burp Suite Intruder or Wfuzz to brute-force the weak token. In Burp Suite, capture a request to an API endpoint that requires a token. In <a href="#figure8-11" id="figureanchor8-11">Figure 8-11</a>, we use a GET request to the <em>/identity/api/v2/user/dashboard</em> endpoint and include the token as a header. Send the captured request to Intruder, and under the Intruder Payload Positions tab, select the attack positions.</p>
<span epub:type="pagebreak" id="Page_191" title="191"/><figure>
<img alt="The Burp Suite Payload Positions menu, with the attack type set to “Cluster bomb” and the last three characters of the token each set to a payload position" class="keyline" src="image_fi/502444c08/F08011.png"/>
<figcaption><p><a id="figure8-11">Figure 8-11</a>: A cluster bomb attack in Burp Suite Intruder</p></figcaption>
</figure>
<p>Since we’re brute-forcing the final three characters only, create three attack positions: one for the third character from the end, one for the second character from the end, and one for the final character. Update the attack type to <b>cluster bomb</b> so Intruder will iterate through each possible combination. Next, configure the payloads, as shown in <a href="#figure8-12" id="figureanchor8-12">Figure 8-12</a>.</p>
<figure>
<img alt="Screenshot of the Burp Suite Payloads tab with “Payload set” set to “1,” “Payload type” set to “Brute forcer,” “Character set” set to “abcd,” and the “Min length” and “Max length” fields both set to “1”" class="keyline" src="image_fi/502444c08/F08012.png"/>
<figcaption><p><a id="figure8-12">Figure 8-12</a>: The payloads tab in Burp Suite’s Intruder</p></figcaption>
</figure>
<p>Select the <b>Payload Set</b> number, which represents a specific attack position, and set the payload type to <b>brute forcer</b>. In the character set field, include all numbers and letters to be tested in that position. Because the first two payloads are letters, we’ll want to try all letters from <em>a</em> to <em>d</em>. For payload set 3, the character set should include the digits 0 through 9. Set both the minimum and maximum length to <b>1</b>, as each attack position is one character long. Start the attack, and Burp Suite will send all 160 token possibilities in requests to the endpoint.</p>
<p><span epub:type="pagebreak" id="Page_192" title="192"/>Burp Suite CE throttles Intruder requests. As a faster, free alternative, you may want to use Wfuzz, like so:</p>
<pre><code>$ <b>wfuzz -u vulnexample.com/api/v2/user/dashboard –hc 404 -H "token: Ab4dt0k3nFUZZFUZ2ZFUZ3Z1" -z list,a-b-c-d -z list,a-b-c-d -z range,0-9</b>
============================================================================
ID           Response   Lines    Word            Chars       Payload
============================================================================
000000117:   200        1 L      10 W            345 Ch      " Ab4dt0k3nca1"
000000118:   200        1 L      10 W            345 Ch      " Ab4dt0k3ncb2"
000000119:   200        1 L      10 W            345 Ch      " Ab4dt0k3ncc3"
000000120:   200        1 L      10 W            345 Ch      " Ab4dt0k3ncd4"
000000121:   200        1 L      10 W            345 Ch      " Ab4dt0k3nce5"</code></pre>
<p>Include a header token in your request using <code>-H</code>. To specify three payload positions, label the first as <code>FUZZ</code>, the second as <code>FUZ2Z</code>, and the third as <code>FUZ3Z</code>. Following <code>-z</code>, list the payloads. We use <code class="bold">-z list,a-b-c-d</code> to cycle through the letters <em>a</em> to <em>d</em> for the first two payload positions, and we use <code>-z range,0-9</code> to cycle through the numbers in the final payload position.</p>
<p>Armed with a list of valid tokens, leverage them in API requests to find out more about what privileges they have. If you have a collection of requests in Postman, try simply updating the token variable to a captured one and use the Postman Runner to quickly test all the requests in the collection. That should give you a fairly good idea of a given token’s capabilities.</p>
<h2 id="h1-502444c08-0003">JSON Web Token Abuse</h2>
<p class="BodyFirst">I introduced JSON Web Tokens (JWTs) in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. They’re one of the more prevalent API token types because they operate across a wide variety of programming languages, including Python, Java, Node.js, and Ruby. While the tactics described in the last section could work against JWTs as well, these tokens can be vulnerable to several additional attacks. This section will guide you through a few attacks you can use to test and break poorly implemented JWTs. These attacks could grant you basic unauthorized access or even administrative access to an API.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	For testing purposes, you might want to generate your own JWTs. Use <a class="LinkURL" href="https://jwt.io">https://jwt.io</a>, a site created by Auth0, to do so. Sometimes the JWTs have been configured so improperly that the API will accept any JWT.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you’ve captured another user’s JWT, you can try sending it to the provider and pass it off as your own. There is a chance that the token is still valid and you can gain access to the API as the user specified in the payload. More commonly, though, you’ll register with an API and the provider will respond with a JWT. Once you have been issued a JWT, you will need to include it in all subsequent requests. If you are using a browser, this process will happen automatically.</p>
<h3 id="h2-502444c08-0008"><span epub:type="pagebreak" id="Page_193" title="193"/>Recognizing and Analyzing JWTs</h3>
<p class="BodyFirst">You should be able to distinguish JWTs from other tokens because they consist of three parts separated by periods: the header, payload, and signature. As you can see in the following JWT, the header and payload will normally begin with <code>ey</code>:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJoYWNrYXBpcy5pbyIsImV4cCI6IDE1ODM2Mzc0ODgsInVzZXJuYW1lIjoiU2N1dHRsZXBoMXNoIiwic3VwZXJhZG1pbiI6dHJ1ZX0.1c514f4967142c27e4e57b612a7872003fa6cbc7257b3b74da17a8b4dc1d2ab9</code></pre>
<p>The first step to attacking a JWT is to decode and analyze it. If you discovered exposed JWTs during reconnaissance, stick them into a decoder tool to see if the JWT payload contains any useful information, such as username and user ID. You might also get lucky and obtain a JWT that contains username and password combinations. In Burp Suite’s Decoder, paste the JWT into the top window, select <b>Decode As</b>, and choose the <b>Base64</b> option (see <a href="#figure8-13" id="figureanchor8-13">Figure 8-13</a>).</p>
<figure>
<img alt="Screenshot of the Burp Suite Decoder with a long string decoded to a series of header fields" class="keyline" src="image_fi/502444c08/F08013.png"/>
<figcaption><p><a id="figure8-13">Figure 8-13</a>: Using Burp Suite Decoder to decode a JWT</p></figcaption>
</figure>
<p>The<em> header</em> is a base64-encoded value that includes information about the type of token and hashing algorithm used for signing. A decoded header will look like the following:</p>
<pre><code>{
"alg": "HS256"
"typ": "JWT"
}</code></pre>
<p>In this example, the hashing algorithm is HMAC using SHA256. HMAC is primarily used to provide integrity checks similar to digital signatures. SHA256 is a hashing encryption with function developed by the NSA and released in 2001. Another common hashing algorithm you might see is RS256, or RSA using SHA256, an asymmetric hashing algorithm. For additional information, check out the Microsoft API documentation on cryptography at <a class="LinkURL" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography">https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography</a>.</p>
<p><span epub:type="pagebreak" id="Page_194" title="194"/>When a JWT uses a symmetric key system, both the consumer and provider will need to have a single key. When a JWT uses an asymmetric key system, the provider and consumer will use two different keys. Understanding the difference between symmetric and asymmetric encryption will give you a boost when performing a JWT algorithm bypass attack, found later in this chapter.</p>
<p>If the algorithm value is <code>"none"</code>, the token has not been signed with any hashing algorithm. We will return to how we can take advantage of JWTs without a hashing algorithm later in this chapter.</p>
<p>The <em>payload</em><b> </b>is the data included within the token. The fields within the payload differ per API but typically contain information used for authorization, such as a username, user ID, password, email address, date of token creation (often called IAT), and privilege level. A decoded payload should look like the following:</p>
<pre><code>{
  "userID": "1234567890",
  "name": "hAPI Hacker",
  "iat": 1516239022
}</code></pre>
<p>Finally,<b> </b>the<b> </b><em>signature </em>is the output of HMAC used for token validation and generated with the algorithm specified in the header. To create the signature, the API base64-encodes the header and payload and then applies the hashing algorithm and a secret. The secret can be in the form of a password or a secret string, such as a 256-bit key. Without knowledge of the secret, the payload of the JWT will remain encoded.</p>
<p>A signature using HS256 will look like the following:</p>
<pre><code>HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  thebest1)</code></pre>
<p>To help you analyze JWTs, leverage the JSON Web Token Toolkit by using the following command:</p>
<pre><code>$ <b>jwt_tool eyghbocibiJIUZZINIISIRSCCI6IkpXUCJ9.eyIzdW1101IxMjMENTY3ODkwIiwibmFtZSI6ImhBuEkgSGFja2VyIiwiaWFQIjoxNTE2MjM5MDIyfQ.IX-Iz_e1CrPrkel FjArExaZpp3Y2tfawJUFQaNdftFw</b>
Original JWT:
Decoded Token Values:
Token header values:
[+] alg - "HS256"
[+] typ - "JWT"
Token payload values:
[+] sub = "1234567890"
[+] name - "HAPI Hacker"
[+] iat - 1516239022 = TIMESTAMP - 2021-01-17 17:30:22 (UTC)
JWT common timestamps:
iat - Issuedat
exp – Expires
nbf - NotBefore</code></pre>
<p><span epub:type="pagebreak" id="Page_195" title="195"/>As you can see, <code>jwt_tool</code> makes the header and payload values nice and clear.</p>
<p>Additionally, <code>jwt_tool</code> has a “Playbook Scan” that can be used to target a web application and scan for common JWT vulnerabilities. You can run this scan by using the following:</p>
<pre><code>$ <b>jwt_tool -t http://target-site.com/ -rc "Header: JWT_Token" -M pb</b></code></pre>
<p>To use this command, you’ll need to know what you should expect as the JWT header. When you have this information, replace <code>"Header"</code><em> </em>with the name of the header and <code>"JWT_Token"</code> with the actual token value.</p>
<h3 id="h2-502444c08-0009">The None Attack</h3>
<p class="BodyFirst">If you ever come across a JWT using <code>"none"</code> as its algorithm, you’ve found an easy win. After decoding the token, you should be able to clearly see the header, payload, and signature. From here, you can alter the information contained in the payload to be whatever you’d like. For example, you could change the username to something likely used by the provider’s admin account (like root, admin, administrator, test, or adm), as shown here:</p>
<pre><code>{
   "username": "root",
   "iat": 1516239022
}</code></pre>
<p>Once you’ve edited the payload, use Burp Suite’s Decoder to encode the payload with base64; then insert it into the JWT. Importantly, since the algorithm is set to <code>"none"</code>, any signature that was present can be removed. In other words, you can remove everything following the third period in the JWT. Send the JWT to the provider in a request and check whether you’ve gained unauthorized access to the API.</p>
<h3 id="h2-502444c08-0010">The Algorithm Switch Attack</h3>
<p class="BodyFirst">There is a chance the API provider isn’t checking the JWTs properly. If this is the case, we may be able to trick a provider into accepting a JWT with an altered algorithm.</p>
<p>One of the first things you should attempt is sending a JWT without including the signature. This can be done by erasing the signature altogether and leaving the last period in place, like this:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJoYWNrYXBpcy5pbyIsImV4cCI6IDE1ODM2Mzc0ODgsInVzZXJuYW1lIjoiU2N1dHRsZXBoMXNoIiwic3VwZXJhZG1pbiI6dHJ1ZX0.</code></pre>
<p>If this isn’t successful, attempt to alter the algorithm header field to <code>"none"</code>. Decode the JWT, updating the <code>"alg"</code> value to <code>"none"</code>, base64-encode the header, and send it to the provider. If successful, pivot to the None attack.</p>
<pre><code><span epub:type="pagebreak" id="Page_196" title="196"/>{
"alg": "none"
"typ": "JWT"
}</code></pre>
<p>You can use JWT_Tool to create a variety of tokens with the algorithm set to <code>"none"</code>:</p>
<pre><code>$ <b>jwt_tool &lt;JWT_Token&gt; -X a</b></code></pre>
<p>Using this command will automatically create several JWTs that have different forms of “no algorithm” applied.</p>
<p>A more likely scenario than the provider accepting no algorithm is that they accept multiple algorithms. For example, if the provider uses RS256 but doesn’t limit the acceptable algorithm values, we could alter the algorithm to HS256. This is useful, as RS256 is an asymmetric encryption scheme, meaning we need both the provider’s private key and a public key in order to accurately hash the JWT signature. Meanwhile, HS256 is symmetric encryption, so only one key is used for both the signature and verification of the token. If you can discover the provider’s RS256 public key and then switch the algorithm from RS256 to HS256, there is a chance you may be able to leverage the RS256 public key as the HS256 key.</p>
<p>The JWT_Tool can make this attack a bit easier. It uses the format <code>jwt_tool &lt;JWT_Token&gt; -X k -pk public-key.pem</code>, as shown next. You will need to save the captured public key as a file on your attacking machine.</p>
<pre><code>$ <b>jwt_tool eyJBeXAiOiJKV1QiLCJhbGciOiJSUZI1Ni 19.eyJpc3MiOi JodHRwOlwvxC9kZW1vLnNqb2VyZGxhbmdrzwiwZXIubmxcLyIsIm1hdCI6MTYYCJkYXRhIjp7ImhlbGxvijoid29ybGQifx0.MBZKIRF_MvG799nTKOMgdxva_S-dqsVCPPTR9N9L6q2_10152pHq2YTRafwACdgyhR1A2Wq7wEf4210929BTWsVk19_XkfyDh_Tizeszny_GGsVzdb103NCITUEjFRXURJ0-MEETROOC-TWB8n6wOTOjWA6SLCEYANSKWaJX5XvBt6HtnxjogunkVz2sVp3 VFPevfLUGGLADKYBphfumd7jkh80ca2lvs8TagkQyCnXq5VhdZsoxkETHwe_n7POBISAZYSMayihlweg -x k-pk public-key-pem</b>
Original JWT:
File loaded: public-key. pem
jwttool_563e386e825d299e2fc@aadaeec25269 - EXPLOIT: Key-Confusion attack (signing using the Public key as the HMAC secret)
(This will only be valid on unpatched implementations of JWT.)
[+] ey JoexAiOiJK1QiLCJhbGciOiJIUZI1NiJ9.eyJpc3MiOiJodHRwOi8vZGVtby5zam91cmRsYW5na2VtcGVyLmSsLyIsIm1hdCI6MTYyNTc4NzkzOSwizhlbGxvIjoid29ybGQifxo.gyti NhqYsSiDIn10e-6-6SfNPJle-9EZbJZjhaa30</code></pre>
<p>Once you run the command, JWT_Tool will provide you with a new token to use against the API provider. If the provider is vulnerable, you’ll be able to hijack other tokens, since you now have the key required to sign tokens. Try repeating the process, this time creating a new token based on other API users, especially administrative ones.</p>
<h3 id="h2-502444c08-0011">The JWT Crack Attack</h3>
<p class="BodyFirst">The JWT Crack attack attempts to crack the secret used for the JWT signature hash, giving us full control over the process of creating our own valid <span epub:type="pagebreak" id="Page_197" title="197"/>JWTs. Hash-cracking attacks like this take place offline and do not interact with the provider. Therefore, we do not need to worry about causing havoc by sending millions of requests to an API provider.</p>
<p>You can use JWT_Tool or a tool like Hashcat to crack JWT secrets. You’ll feed your hash cracker a list of words. The hash cracker will then hash those words and compare the values to the original hashed signature to determine if one of those words was used as the hash secret. If you’re performing a long-term brute-force attack of every character possibility, you may want to use the dedicated GPUs that power Hashcat instead of JWT_Tool. That being said, JWT_Tool can still test 12 million passwords in under a minute.</p>
<p>To perform a JWT Crack attack using JWT_Tool, use the following command:</p>
<pre><code>$ <b>jwt_tool</b><b> </b><b>&lt;JWT Token&gt;</b><b> </b><b>-C -d /wordlist.txt</b></code></pre>
<p>The <code>-C</code> option indicates that you’ll be conducting a hash crack attack and the <code>-d</code> option specifies the dictionary or wordlist you’ll be using against the hash. In this example, the name of my dictionary is <em>wordlist.txt</em>, but you can specify the directory and name of whatever wordlist you would like to use. JWT_Tool will either return “CORRECT key!” for each value in the dictionary or indicate an unsuccessful attempt with “key not found in dictionary.”</p>
<h2 id="h1-502444c08-0004">Summary</h2>
<p class="BodyFirst">This chapter covered various methods of hacking API authentication, exploiting tokens, and attacking JSON Web Tokens specifically. When present, authentication is usually an API’s first defense mechanism, so if your authentication attacks are successful, your unauthorized access can become a foothold for additional attacks.</p>
<h2 class="HeadProject" id="h1-502444c08-0005"><span>Lab #5: Cracking a crAPI JWT Signature</span></h2>
<p class="BodyFirst">Return to the crAPI authentication page to try your hand at attacking the authentication process. We know that this authentication process has three parts: account registration, password reset functionality, and the login operation. All three of these should be thoroughly tested. In this lab, we’ll focus on attacking the token provided after a successful authentication attempt.</p>
<p>If you remember your crAPI login information, go ahead and log in. (Otherwise, sign up for a new account.) Make sure you have Burp Suite open and FoxyProxy set to proxy traffic to Burp so you can intercept the login request. Then forward the intercepted request to the crAPI provider. If you’ve entered in your email and password correctly, you should receive an HTTP 200 response and a Bearer token.</p>
<p><span epub:type="pagebreak" id="Page_198" title="198"/>Hopefully, you now notice something special about the Bearer token. That’s right: it is broken down into three parts separated by periods, and the first two parts begin with <code>ey</code>. We have ourselves a JSON Web Token! Let’s begin by analyzing the JWT using a site like <a class="LinkURL" href="https://jwt.io">https://jwt.io</a> or JWT_Tool. For visual purposes, <a href="#figure8-14" id="figureanchor8-14">Figure 8-14</a> shows the token in the JWT.io debugger.</p>
<figure>
<img alt="Screenshot of jwt.io with a long string in the “Encoded” field and each section of the JWT decoded in the “Decoded” field" class="keyline" src="image_fi/502444c08/F08014.png"/>
<figcaption><p><a id="figure8-14">Figure 8-14</a>: A captured JWT being analyzed in JWT.io’s debugger</p></figcaption>
</figure>
<p>As you can see, the JWT header tells us that the algorithm is set to HS512, an even stronger hash algorithm than those covered earlier. Also, the payload contains a <code>"sub"</code> value with our email. The payload also contains two values used for token expiration: <code>iat</code> and <code>exp</code>. Finally, the signature confirms that HMAC+SHA512 is in use and that a secret key is required to sign the JWT.</p>
<p>A natural next step would be to conduct None attacks to try to bypass the hashing algorithm. I will leave that for you to explore on your own. We won’t attempt any other algorithm switch attack, as we’re already attacking a symmetric key encryption system, so switching the algorithm type won’t benefit us here. That leaves us with performing JWT Crack attacks.</p>
<p>To perform a Crack attack against your captured token, copy the token from the intercepted request. Open a terminal and run JWT_Tool. As a first-round attack, we can use the <em>rockyou.txt</em> file as our dictionary:</p>
<pre><code>$ <b>jwt_tool eyJhbGciOiJIUZUxMi19.eyJzdWIiOiJhQGVtYWlsLmNvbSIsImlhdCI6MTYYNTC4NzA4MywiZXhwIjoxNjI10DCzNDgzfQ. EYx8ae40nE2n9ec4yBPI6Bx0z0-BWuaUQVJg2Cjx_BD_-eT9-Rpn87IAU@QM8 -C -d rockyou.txt</b>
Original JWT:
[*] Tested 1 million passwords so far
[*] Tested 2 million passwords so far
[*] Tested 3 million passwords so far
<span epub:type="pagebreak" id="Page_199" title="199"/>[*] Tested 4 million passwords so far
[*] Tested 5 million passwords so far
[*] Tested 6 million passwords so far
[*] Tested 7 million passwords so far
[*] Tested 8 million passwords so far
[*] Tested 9 million passwords so far
[*] Tested 10 million passwords so far
[*] Tested 11 million passwords so far
[*] Tested 12 million passwords so far
[*] Tested 13 million passwords so far
[*] Tested 14 million passwords so far
[-] Key not in dictionary</code></pre>
<p>At the beginning of this chapter, I mentioned that <em>rockyou.txt</em> is outdated, so it likely won’t yield any successes. Let’s try brainstorming some likely secrets and save them to our own <em>crapi.txt</em> file (see <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>). You can also generate a similar list using a password profiler, as recommended earlier in this chapter.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: Potential crAPI JWT Secrets</p></figcaption>
<table border="1" id="table-502444c08-0001"><tbody>
<tr>
<td>Crapi2020</td>
<td>OWASP</td>
<td>iparc2022</td>
</tr>
<tr>
<td>crapi2022</td>
<td>owasp</td>
<td>iparc2023</td>
</tr>
<tr>
<td>crAPI2022</td>
<td>Jwt2022</td>
<td>iparc2020</td>
</tr>
<tr>
<td>crAPI2020</td>
<td>Jwt2020</td>
<td>iparc2021</td>
</tr>
<tr>
<td>crAPI2021</td>
<td>Jwt_2022</td>
<td>iparc</td>
</tr>
<tr>
<td>crapi</td>
<td>Jwt_2020</td>
<td>JWT</td>
</tr>
<tr>
<td>community</td>
<td>Owasp2021</td>
<td>jwt2020</td>
</tr>
</tbody>
</table>
</figure>
<p>Now run this targeted hash crack attack using JWT_Tool:</p>
<pre><code>$ <b>jwt_tool eyJhbGciOiJIUzUxMi19.eyJzdwiOiJhQGVtYWlsLmNvbSIsImlhdCI6MTYYNTC4NzA4MywiZXhwIjoxNjI10DCzNDgzfQ. EYx8ae40nE2n9ec4yBPi6Bx0z0-BWuaWQVJg2Cjx_BD_-eT9-Rp 871Au@QM8-wsTZ5aqtxEYRd4zgGR51t5PQ -C -d crapi.txt</b>
Original JWT:
[+] crapi is the CORRECT key!
You can tamper/fuzz the token contents (-T/-I) and sign it using:
python3 jwt_tool.py [options here] -5 HS512 -p "crapi"</code></pre>
<p>Great! We’ve discovered that the crAPI JWT secret is <code>"crapi"</code>.</p>
<p>This secret isn’t too useful unless we have email addresses of other valid users, which we’ll need to forge their tokens. Luckily, we accomplished this at the end of <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>’s lab. Let’s see if we can gain unauthorized access to the robot account. As you can see in <a href="#figure8-15" id="figureanchor8-15">Figure 8-15</a>, we use JWT.io to generate a token for the crAPI robot account.</p>
<span epub:type="pagebreak" id="Page_200" title="200"/><figure>
<img alt="Screenshot of jwt.io with a long string in the “Encoded” field and each section of the JWT decoded in the “Decoded field" class="keyline" src="image_fi/502444c08/F08015.png"/>
<figcaption><p><a id="figure8-15">Figure 8-15</a>: Using JWT.io to generate a token</p></figcaption>
</figure>
<p>Don’t forget that the algorithm value of this token is HS512 and that you need to add the HS512 secret to the signature. Once the token is generated, you can copy it into a saved Postman request or into a request using Burp Suite’s Repeater, and then you can send it to the API. If successful, you’ll have hijacked the crAPI robot account. Congrats!</p>
</section>
</body>
</html>