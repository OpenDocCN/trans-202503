- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTERACTIVE
    AUTHENTICATION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you authenticate to your Windows system, you’ll usually access a login
    interface, enter your credentials, and be greeted with the desktop. But quite
    a lot happens behind the scenes to make this authentication process work. *Interactive
    authentication* is the mechanism that converts a set of credentials into a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that you can use to
    interact with authorization systems, such as access checks.
  prefs: []
  type: TYPE_NORMAL
- en: Windows uses many types of interactive authentication for a variety of purposes.
    For example, it uses one type when a user creates an interactive desktop and another
    when the user has provided credentials to a network-facing service. We’ll begin
    this chapter by exploring how Windows creates your interactive desktop when you
    authenticate to a Windows system. We’ll then cover how this interactive authentication
    is implemented through the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. Finally, we’ll look at the various types of interactive authentication, the
    differences between them, and when they might be used.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a User’s Desktop</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way of interacting with a Windows system is via the user interface
    on a desktop. [Figure 12-1](chapter12.xhtml#fig12-1) summarizes the process of
    creating a user’s desktop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An overview of
    interactive desktop creation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When the Windows system starts, the session manager creates a console session,
    as described in [Chapter 3](chapter3.xhtml). In this console session it starts
    an instance of the Winlogon process, which gathers credentials and starts the
    new user’s processes once they’re authenticated. The Winlogon process then creates
    the LogonUI process to display a UI. The LogonUI process reads the credentials
    from the user and passes them back to Winlogon ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Winlogon process sends the credentials to the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API to verify that they’re correct ❷. If the user has successfully authenticated,
    a token representing the user’s identity is returned to Winlogon ❸. The console
    session can then be reconfigured for the user, a process that includes creating
    a window station and desktop and spawning the user initialization process using
    the user’s token ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API directly
    supports the most common type of credential, a username and password pair. However,
    Windows allows many other local authentication factors as well, such as biometric
    data (for example, a scanning of the user’s face) or a simple PIN. To handle these,
    Winlogon loads a credential provider when needed. Each provider is responsible
    for mapping its credential type to one that <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    supports to get the token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The LsaLogonUser API</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know the basics of how to create a desktop on Windows. Now let’s dig into
    how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API
    implements the interactive authentication service for Winlogon and other applications
    on the local system. This API might seem quite complex, but it really requires
    only three pieces of information from an application to authenticate a user:'
  prefs: []
  type: TYPE_NORMAL
- en: The logon type requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The security package identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user’s credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API uses the *logon type* to accommodate different authentication scenarios.
    [Table 12-1](chapter12.xhtml#tab12-1) lists the logon types most commonly used
    by applications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Logon Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Interact with a local desktop.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_11">Run
    as a background process, even if no desktop is available.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_11">Run
    as a system service.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_11">Interact
    with the system from a network client.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_11">Perform network authentication, but store the
    user’s credentials for later use.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">Clone the caller’s token and change network user
    credentials.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_11">Interact with a desktop via the Remote Desktop
    Protocol.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">Verify
    the user’s credentials for unlocking the desktop.</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> is a special type
    that Winlogon uses to verify a user’s credentials on the lock screen, and it isn’t
    typically used by applications directly. We’ll come back to some of the other
    logon types later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Windows abstracts the details of authentication to a *security package*, which
    provides a standardized interface to an authentication protocol. The authentication
    protocol is a formal process that takes a set of credentials and verifies that
    they’re valid. It also provides a mechanism to return information about the verified
    user, such as their group memberships. We also sometimes refer to a security package
    as a *security support provider (SSP).*
  prefs: []
  type: TYPE_NORMAL
- en: We can enumerate the available security packages using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPackage</samp>
    PowerShell command, as shown in [Listing 12-1](chapter12.xhtml#Lis12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Enumerating the supported security packages'
  prefs: []
  type: TYPE_NORMAL
- en: Applications typically access a security package via a more generic API that
    is agnostic to the authentication protocol used. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    works across multiple different packages by accepting a unique identifier for
    the package to use. A security package can also implement a network authentication
    protocol, which we’ll cover in more depth in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used security packages for local authentication are *Negotiate*
    ❶ and *NT LAN Manager (NTLM)* ❷. The NTLM authentication protocol was introduced
    in Windows NT 3.1, and it’s also sometimes referred to as the *Microsoft Authentication
    Package V1.0* in documentation. The Negotiate package can automatically select
    between different authentication protocols, depending on the circumstances. For
    example, it might select NTLM if authenticating locally to the SAM database or
    Kerberos when authenticating to a domain.
  prefs: []
  type: TYPE_NORMAL
- en: The supported credential types depend on the security package being used for
    the authentication. For example, NTLM supports only username and password credentials,
    whereas Kerberos supports X.509 certificates and smart card authentication in
    addition to a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s explore how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API authenticates a user in more detail. [Figure 12-2](chapter12.xhtml#fig12-2)
    gives an overview of this process for a user in the local SAM database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The local authentication
    process using LsaLogonUser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complexities of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API, it’s more common for an application to use a simpler API provided by the
    system. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>
    API accepts a username, a domain name, a password, and the logon type and formats
    the parameters appropriately for the underlying security package.
  prefs: []
  type: TYPE_NORMAL
- en: It then forwards these parameters, including the user’s credentials, to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API in the LSA
    process ❶. The API in turn forwards the authentication request to the chosen security
    package, which in this case is the NTLM package implemented in the *MSV1_0.DLL*
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The security package checks whether the user exists in the local SAM database.
    If it does, the user’s password is converted to an NT hash (discussed in [Chapter
    10](chapter10.xhtml)), and then it is compared against the value stored in the
    database ❷. If the hashes match and the user account is enabled, the authentication
    proceeds and the user’s details, such as group membership, are read from the SAM
    database for the authentication process to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the security package knows the user’s group membership and account
    details, it can check whether the local security policy allows the user to authenticate
    ❸. The main policy checks whether the logon type requested is granted an account
    right. [Table 12-2](chapter12.xhtml#tab12-2) lists the logon types and the account
    rights the user must be granted in order to authenticate. Note that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> logon type doesn’t
    need a specific account right; we’ll cover why in the “Network Credentials” box
    on page 407.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">Logon
    Types and Associated Allow and Deny Account Rights</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Allow
    account right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Deny account right</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">The
    same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp>
    | <samp class="SANS_Futura_Std_Book_11">The same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: If the user doesn’t have the necessary account right granted or is explicitly
    denied the right, the authentication will fail. There can be other limitations
    on authentication, as well; for example, you could configure a user so that they’re
    allowed to authenticate only between certain times, or even only on certain days
    of the week. If the user doesn’t meet one of the policy requirements, the security
    package will reject the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: If the user’s credentials are valid and the policy permits them to authenticate,
    the LSA can create a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call based on the information about the user and their privileges extracted
    from the SAM and LSA policy databases ❹. The application receives a handle to
    a token, which the user can subsequently use for impersonation or to create a
    new process within the limits of the assignment, as described in [Chapter 4](chapter4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Authenticating a user to a domain controller is not significantly different
    from local authentication, but it’s still worth highlighting the small distinctions.
    [Figure 12-3](chapter12.xhtml#fig12-3) shows the domain authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The domain authentication
    process using LsaLogonUser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The domain authentication process starts in the same manner as local authentication.
    The application provides the credentials and other parameters to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API running in the LSA process ❶. At this point, it’s likely that API will use
    the Negotiate security package to select the most appropriate security package
    to authenticate with.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it once again uses the NTLM security package, which is easy
    to understand. However, in a modern Windows network, you’re more likely to find
    Kerberos used. Interactive authentication with Kerberos is much more complex,
    so I’ll wait until [Chapter 14](chapter14.xhtml) to provide details about it.
  prefs: []
  type: TYPE_NORMAL
- en: Windows also supports online authentication protocols, such as those for Microsoft
    and Azure Active Directory accounts. Authentication for these accounts uses the
    *CloudAP* security package, which Negotiate will select automatically if it’s
    the best security package to use. Details of this selection process are beyond
    the scope of this book, although we’ll cover some aspects of Negotiate in [Chapter
    15](chapter15.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The NTLM security package once again generates the NT hash, but instead of consulting
    the local SAM database, it determines the domain controller for the user’s domain.
    It then forwards the authentication request containing the user’s name and NT
    hash to the domain controller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API using the *Netlogon* network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: While Windows has deprecated the Netlogon protocol for primary domain authentication,
    it has not removed the protocol in the latest versions. Not removing legacy features
    can result in important security issues as technology becomes obsolete and security
    expectations change. For example, CVE-2020-1472, dubbed *Zerologon*, was a serious
    vulnerability in the Netlogon protocol that allowed unauthenticated users to compromise
    the entire domain network due to a flaw in the weak cryptography used by the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The domain controller verifies the user’s credentials in the domain’s user database
    ❷. For modern versions of Windows, this is Active Directory, not a SAM database.
    The user must also be enabled for the authentication to succeed. If the hashes
    match, the user’s information is extracted from Active Directory and returned
    to the client system.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user’s credentials have been validated, the client system can verify
    its local policy ❸ to determine whether the user is permitted to authenticate
    based on the logon type and other restrictions, such as time limits. If every
    check succeeds, the LSA generates the token and returns it to the application
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logon and Console
    Sessions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API
    has verified the user’s credentials, it can create an initial token for the user.
    Before it can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>,
    however, the LSA must set up an associated logon session. We discussed the logon
    session in [Chapter 4](chapter4.xhtml), in the context of the token’s authentication
    ID, but it’s worth going into more depth about what it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by querying the LSA for all current logon sessions using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtLogonSession</samp> PowerShell command,
    as shown in [Listing 12-2](chapter12.xhtml#Lis12-2). You should run this command
    as an administrator to display all the logon sessions on the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Displaying all current logon sessions'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the first two sessions are for service accounts ❶, as indicated
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> value. Oddly,
    the third session is also a service account, for the *SYSTEM* user, but notice
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> is undefined
    ❷. This is because the kernel creates the *SYSTEM* logon session before the LSA
    process is started, which means no authentication has taken place.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the logon sessions are for interactive accounts, as indicated by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type
    ❸. Only one user is authenticated ❹; the other accounts belong to system processes
    such as the user-mode font driver (UMFD) and the desktop window manager (DWM).
    We won’t cover these system processes in any detail. Observe that the current
    user has two logon sessions. This is because of UAC, introduced in [Chapter 4](chapter4.xhtml);
    we’ll come back to why UAC generates two sessions in “Token Creation” on page
    407.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionId</samp>
    is shown for each logon session, in addition to the authentication identifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp>) that identifies
    the account. This is the console session ID. It’s important not to confuse the
    logon session and console session types. As this output shows, it’s possible for
    a single console session to host multiple separate logon sessions, and for a single
    logon session to be used across multiple console sessions.
  prefs: []
  type: TYPE_NORMAL
- en: The LSA stores the console session ID originally associated with the logon session
    when it was created. In [Listing 12-3](chapter12.xhtml#Lis12-3), we query the
    LSA for all current console sessions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtConsoleSession</samp>.
    This behavior allows multiple users to share the same console and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Displaying all current console sessions'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionName</samp> column
    indicates where the console session is connected. Session 0 is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Services</samp>
    console, meaning it’s used only for system services. The <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp>
    column indicates the state of the UI. For session 0 this is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnected</samp>,
    as there is no UI displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Session 1 is created on demand when the user successfully completes the interactive
    authentication process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    column identifies the authenticated user. The session state is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>,
    as this is the console session in which I ran the PowerShell command. The session
    name is a unique value indicating that this is a remote desktop connection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, session 2 lives on the physical console. It shows a state of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Connected</samp>, as it currently hosts
    a LogonUI in case a user tries to physically log in to the machine. However, at
    this point there’s no authenticated user in session 2, as you can see by the absence
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp> in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-4](chapter12.xhtml#fig12-4) summarizes the relationships between
    logon sessions and console sessions in this example. The console sessions are
    the gray boxes in the background, and the logon sessions are the white boxes in
    the foreground.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The console and
    logon sessions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that console session 0 contains the service logon sessions, such as
    those for the local system, the network service, and the local service. The local
    system logon session is also used for the LogonUI process running in console session
    2\. At the bottom right is console session 1, which contains two user logon sessions:
    one for the UAC administrator and one for the filtered non-administrator.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Token Creation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With a new logon session, the LSA can create the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the user. To do this, it must gather information about the token’s
    various security properties, including the user’s groups, privileges, and logon
    session ID, then pass these to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering where the user’s groups come from. As domain authentication
    is the most complex case, let’s consider the groups assigned to a domain user
    token when Winlogon authenticates the user. (The group assignment will look similar
    in the local authentication process, except that the LSA will consider only local
    groups.) [Table 12-3](chapter12.xhtml#tab12-3) shows the group assignments for
    the *alice* user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp> <samp class="SANS_Futura_Std_Book_11">Groups
    Added to an Interactive Token on a Domain-Joined System</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Group name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Group
    source</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\alice</samp> | <samp
    class="SANS_Futura_Std_Book_11">Domain user account</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Domain Users</samp>
    | <samp class="SANS_Futura_Std_Book_11">Domain group membership</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority
    asserted identity</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Claims Valid</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Local Resource</samp>
    | <samp class="SANS_Futura_Std_Book_11">Domain-local resource group membership</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Administrators</samp>
    | <samp class="SANS_Futura_Std_Book_11">Local group membership</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Users</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp>
    | <samp class="SANS_Futura_Std_Book_11">Automatic LSA groups</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Authenticated
    Users</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Everyone</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Mandatory Label\High Mandatory
    Level</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\LogonSessionId_0_6077548</samp>
    | <samp class="SANS_Futura_Std_Book_11">Winlogon groups</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL</samp> |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the groups added to the token come from six sources. The first
    entry comes from the domain user account. (In a local authentication scenario,
    the group would come from the local user account instead.)
  prefs: []
  type: TYPE_NORMAL
- en: Next are the domain group memberships. These come from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scopes,
    discussed in the previous chapter. The *alice* user is a member of the first group,
    *Domain Users*. The other two groups are generated automatically when the user
    authenticates. The *Authentication authority asserted identity* group relates
    to a feature called *Service for User (S4U)*, which we’ll explore when we talk
    about Kerberos authentication in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The following source includes the groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>
    scope. These domain-local groups are marked in the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp>
    group attribute, although the attribute doesn’t affect their use in an access
    check. The list of domain-local resource groups a user belongs to is returned
    in the response from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API, known as a *privilege attribute certificate (PAC)*. We’ll also come back
    to the PAC in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Next, any local groups the user is a member of are added to the token. These
    local groups can be selected based on the domain SIDs provided during the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: These are followed by the automatic LSA groups. Membership in the *Everyone*
    and *Authenticated Users* groups is granted to all authenticated tokens automatically.
    *INTERACTIVE* group membership is granted when a user is authenticated using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type. [Table
    12-4](chapter12.xhtml#tab12-4) provides a list of the SIDs added for different
    logon types. The LSA adds the *Mandatory Label\High Mandatory Level* SID automatically
    if the user is considered an administrator (for example, if they’re in the *Administrators*
    group or have certain high-level privileges). This sets the integrity level of
    the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>. Normal
    users get the *Medium Mandatory Level* SID, while system service users (such as
    *SYSTEM*) get the *System Mandatory Level* SID.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp> <samp class="SANS_Futura_Std_Book_11">The
    SIDs Added to the Token for Each Logon Type</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\BATCH</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-3</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SERVICE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-6</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\NETWORK</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">The same as that of the original token</samp>
    | <samp class="SANS_Futura_Std_Book_11">N/A</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\REMOTE INTERACTIVE LOGON</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-14</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">The
    same as the logon session that is being unlocked</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Providing a unique SID for each logon type allows a security descriptor to secure
    resources depending on the type of logon. For example, a security descriptor could
    explicitly deny access to the *NT AUTHORITY\NETWORK* SID, meaning a user authenticated
    from the network would be denied access to the resource, while other authenticated
    users would be granted access.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth set of SIDs added to the token are for the groups added by Winlogon
    when it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. The API allows a caller with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled to add arbitrary group SIDs to the created token, so Winlogon adds a logon
    session and a *LOCAL* SID. This logon session SID’s two RID values are the two
    32-bit integers from a LUID generated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateLocallyUniqueId</samp>
    system call. You might assume that the LUID would match the one used for the logon
    session. However, as the SID is created before the call to the LSA that creates
    the logon session, this isn’t possible. This SID is used to secure ephemeral resources
    such as the user’s *BaseNamedObjects* directory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you don’t specify a logon session SID when creating the token, the LSA
    will add its own for you. However, it will follow the same pattern of using a
    different LUID from that of the token’s logon session.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As discussed in [Chapter 10](chapter10.xhtml), the token’s privileges are based
    on the account rights stored in the local LSA policy database. This is true even
    in domain authentication; however, the account rights can be modified using a
    domain group policy deployed to computers in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is considered an administrator, UAC is enabled, and the user is
    authenticating with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> logon
    type, the LSA will first build the full token and create a new logon session,
    then create a second copy of the full token with a new logon session but call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> to remove administrator
    privileges (see [Chapter 4](chapter4.xhtml) for a more in-depth description of
    this). The LSA will then link the two tokens together and return the filtered
    token back to the caller. This behavior is why we observed two logon sessions
    for the same user in [Listing 12-2](chapter12.xhtml#Lis12-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can disable the token-splitting behavior by adjusting the system’s UAC
    settings. It’s also disabled by default for the *Administrator* user, which is
    always created when Windows is installed but only enabled by default on Windows
    Server systems. The LSA checks the last RID of the user’s SID: if it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>,
    which matches the *Administrator* user, the token won’t be split.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using the LsaLogonUser API from PowerShell</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API works, let’s see how to access the API from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    PowerShell module. Unless you run PowerShell with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    some features of the API will be blocked, such as adding new group SIDs to the
    token, but you’ll be able to create a new token if you have the user’s username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: We access the API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logon</samp> parameter.
    [Listing 12-4](chapter12.xhtml#Lis12-4) shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    to authenticate a new user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: Authenticating a user'
  prefs: []
  type: TYPE_NORMAL
- en: It’s best not to enter passwords on the command line. Instead, we use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp>
    property to read the password as a secure string.
  prefs: []
  type: TYPE_NORMAL
- en: We can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    specifying the username, the domain, and the password. (Replace the username in
    this example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp>,
    with that of a valid local user.) We set the domain to the name of the local computer,
    indicating that we want to authenticate using a local account. You can set any
    logon type, but in this case we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>,
    which works for all users. Whether the LSA will allow other logon types depends
    on the assigned account rights.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*By default, the LsaLogonUser API won’t authenticate a user with an empty password
    outside of the physical console. If you try running the command with a user account
    that has an empty password, the call will fail.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The logon type also determines what type of token <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    will return based on the created token’s likely purpose, such as creating a new
    process or impersonation. [Table 12-5](chapter12.xhtml#tab12-5) shows the mappings
    of logon type to token type. (We can freely convert between primary and impersonation
    tokens through duplication, so the tokens don’t have to be used in the expected
    way.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp> <samp class="SANS_Futura_Std_Book_11">Logon
    Types Mapped to Token Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Token
    type</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Primary</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_11">Impersonation</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_11">Impersonation</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">Primary</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_11">Primary</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'In [Listing 12-4](chapter12.xhtml#Lis12-4), the command returned an impersonation
    token. You might be wondering: Are we allowed to impersonate the token without
    having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    enabled, especially if the token belongs to a different user? The LSA sets the
    new token’s origin ID to the caller’s authentication ID, so based on the rules
    for impersonation covered in [Chapter 4](chapter4.xhtml), we can, even if the
    token belongs to a different user.'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t considered a security issue, because if you know the user’s password,
    you can already fully authenticate as that user. In [Listing 12-5](chapter12.xhtml#Lis12-5),
    we check whether the origin and authentication IDs match using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenId</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: Comparing the authentication ID and origin ID'
  prefs: []
  type: TYPE_NORMAL
- en: We query the primary token for its authentication ID, then query the new token
    for its origin ID. The output shows that the IDs are equal.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one restriction on impersonating the token. If the user being
    authenticated is an administrator, and the authentication process uses a logon
    type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>,
    the command won’t return a filtered token. Instead, it will return an administrator
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level.
    This integrity level prevents the token from being impersonated from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>-level
    process. But because the returned token handle has write access, we can reduce
    the integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    before impersonating it. We do this in [Listing 12-6](chapter12.xhtml#Lis12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: Testing the ability to impersonate the returned token'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the token we’ve authenticated is a member of the *Administrators*
    group and so has a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity
    level. We try to impersonate it, and as you can see, the command returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. We then set the token’s
    integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    and test impersonation again. The operation now returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a New Process with a Token</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use a logon type that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>
    token, you might assume that the token will enable you to create a new process.
    To test this, run [Listing 12-7](chapter12.xhtml#Lis12-7) as a non-administrator
    user, making sure to change the username to that of a valid account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-7: Creating a new process with an authenticated token'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find that creating the new process fails. This is because the new token
    doesn’t meet the requirements for primary token assignment described in [Chapter
    4](chapter4.xhtml). The process creation would work if the calling process had
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    which Winlogon would have; however, a normal user process doesn’t have this privilege.
  prefs: []
  type: TYPE_NORMAL
- en: If you rerun the command as an administrator, though, it should succeed, even
    though administrators are not granted the privilege by default. Let’s explore
    why this works. The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command first tries to create the process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>
    API, which runs in-process. As the calling process doesn’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    this operation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Upon this failure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    API will fall back to calling an alternative API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>.
    This API isn’t implemented in-process; instead, it’s implemented in a system service,
    the secondary logon service, which does have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>.
    In this case, the service will check whether the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    before creating the new process.
  prefs: []
  type: TYPE_NORMAL
- en: The command therefore works for administrators who are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>.
    Even so, administrators shouldn’t rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>
    exclusively, because the API doesn’t support many features of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>,
    such as inheriting arbitrary handles to the new process.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a way for a non-administrator user to create a process as a different
    user. The secondary logon service exposes a second API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>,
    that accepts the username, domain, and password for the user to create instead
    of a token handle. The service authenticates the user using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>,
    then uses the authenticated token with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>.
    As the service has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    the process creation will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp>
    parameter when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command to use <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>,
    as shown in [Listing 12-8](chapter12.xhtml#Lis12-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-8: Calling CreateProcessWithLogon using New-Win32Process'
  prefs: []
  type: TYPE_NORMAL
- en: Here we read the credentials for the *alice* user and create the new process
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>, specifying
    the credentials with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp>
    parameter. This will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The API will return a process and thread handle to use. For example, we can
    query for the process user, which shows it was created with a token for the authenticated
    *alice* user.
  prefs: []
  type: TYPE_NORMAL
- en: The API doesn’t allow you to specify the logon type of the user (it defaults
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>), but you
    can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetCredentialsOnly</samp>
    flag to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonFlags</samp> parameter
    to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    logon type instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Service Logon Type</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s wrap up this chapter by talking a little more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type. The service control manager uses this logon type to create tokens
    for system service processes. It will allow any user account that has been granted
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp> account
    right to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: However, the LSA also supports four well-known local service accounts that are
    not stored in the SAM database. We can create them using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    by specifying the domain name as <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type and one of the usernames in [Table 12-6](chapter12.xhtml#tab12-6),
    which also shows the user SIDs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp> <samp class="SANS_Futura_Std_Book_11">Usernames
    and SIDs for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    <samp class="SANS_Futura_Std_Book_11">Logon Type</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Username</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">User
    SID</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">IUSR</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-17</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SYSTEM</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL SERVICE</samp> <samp
    class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LocalService</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NETWORK SERVICE</samp> <samp
    class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">NetworkService</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> |'
  prefs: []
  type: TYPE_TB
- en: The *SYSTEM* user is the only administrator of the four users; the other three
    are not members of the *Administrators* group, but they do have high-level privileges
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>,
    which makes them effectively equivalent to an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The *IUSR* account represents the anonymous internet user. It’s available to
    reduce the privileges for the Internet Information Services (IIS) web server when
    it’s configured for anonymous authentication. When a request is made to the IIS
    web server with no user credentials, it will impersonate an *IUSR* account token
    before opening any resources, such as files. This prevents inadvertently exposing
    resources remotely as a privileged user.
  prefs: []
  type: TYPE_NORMAL
- en: For these built-in service accounts, you don’t need to specify a password, but
    you do need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled,
    which prevents it from being used outside of a system service. [Listing 12-9](chapter12.xhtml#Lis12-9)
    shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    to create a *SYSTEM* user token. Run these commands as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-9: Getting the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user token'
  prefs: []
  type: TYPE_NORMAL
- en: Even as an administrator you don’t receive <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    by default, so the command supports a <samp class="SANS_TheSansMonoCd_W5Regular_11">WithTcb</samp>
    parameter, which automatically impersonates a token with the privilege enabled.
    You can also simplify the creation of a service account by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    parameter and specifying the name of the service user to create.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some examples that demonstrate how to use the various commands
    introduced in this chapter in security research or systems analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing Privileges
    and Logon Account Rights</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I mentioned in [Chapter 10](chapter10.xhtml) that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    command to add a SID to the list of account rights. Now that we know how to authenticate
    a user, let’s use this command to explore these account rights. In [Listing 12-10](chapter12.xhtml#Lis12-10),
    we assign privileges and logon account rights to a new user. Run these commands
    as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-10: Assigning account rights to a new user'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new user ❶ and testing that we can authenticate interactively
    ❷. We can do so because the user is automatically part of the *BUILTIN\Users*
    group, which has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    by default. We also check that the token hasn’t been filtered for UAC by looking
    at the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> parameter,
    which shows up as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>,
    indicating that no filtering took place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we assign the user the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    privilege ❸. This is a high-level privilege, so we should expect the LSA to perform
    UAC filtering. We find this to be the case when we authenticate the user: we can’t
    enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>,
    since it’s been filtered ❹, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp>
    is now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we can instead use network authentication ❺, which isn’t subject to
    the default UAC filtering rules. We can now enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    ❻, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> once again,
    indicating that no filtering took place.
  prefs: []
  type: TYPE_NORMAL
- en: We then test the logon account rights. Remember that the user is granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> because
    they are a member of the *BUILTIN\Users* group. We can’t remove that logon right
    without also removing them from that group, so instead we explicitly deny it to
    the specific user by adding their SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    ❼. Then we verify the intended behavior by trying to log on interactively ❽, which
    now returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the user’s SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>,
    which allows them to authenticate as a batch logon session. Normally, only members
    of the *Administrators* group receive this access right. We verify we’ve authenticated
    as a batch logon session by checking for the *NT AUTHORITY\BATCH* group that the
    LSA assigns ❾.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we clean up the account right assignments using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>
    command ❿. This isn’t strictly necessary, as the LSA will clean up the assignments
    when the local user is removed, but I’ve included the operations here to demonstrate
    the use of the command.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Process
    in a Different Console Session</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In certain scenarios, you might want to start a process inside a different console
    session. For example, if you’re running code in a system service using session
    0, you might want to show a message on the currently authenticated user’s desktop.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully create a process on another desktop, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    to change a token’s session ID and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>
    to create the process. By default, an administrator user has neither of these
    privileges, so to test the example code provided here you’ll need to run PowerShell
    as the *SYSTEM* user.
  prefs: []
  type: TYPE_NORMAL
- en: 'First run the following command as an administrator to create a shell process
    on your desktop with the required privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, make sure that you have two users authenticated at the same time on different
    desktops on the same machine. If you use Fast User Switching, you’ll be able to
    easily confirm that a process was created on each desktop.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-11](chapter12.xhtml#Lis12-11) starts by finding the console session
    for the new process. Run these commands as the *SYSTEM* user.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-11: Creating a new process in a different console session'
  prefs: []
  type: TYPE_NORMAL
- en: We start by selecting the console session belonging to a user named *GRAPHITE\user*
    ❶. We then create a duplicate of our current token (which belongs to the *SYSTEM*
    user), enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    and assign the console session ID to the token ❷.
  prefs: []
  type: TYPE_NORMAL
- en: With this new token, we can create a new process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    parameter ❸. In this case we’re creating a copy of Notepad, but you can change
    this process to any application you’d like by altering the command. Also note
    that we set the name of the window station and desktop, separated by a backslash,
    for the new process. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>, respectively,
    ensures that we create the application on the default desktop; otherwise, the
    user interface would be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that we’ve created the process in the target session by comparing
    the expected session ID with the actual session ID assigned to the process ❹.
    In this case, the comparison returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    which indicates success. If you now switch back to the other user, you should
    find a copy of Notepad running as the *SYSTEM* user on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticating Virtual
    Accounts</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 10](chapter10.xhtml), I mentioned that you can create your own SID-to-name
    mappings in the LSA using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command. Once you’ve set up a mapping, you can also create a new token for that
    SID through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>.
    [Listing 12-12](chapter12.xhtml#Lis12-12) demonstrates; run these commands as
    an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-12: Creating a virtual account token'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by setting up some parameters to use in later commands ❶. We create
    three SIDs: the domain, a group, and a user. These values don’t need to reflect
    real SIDs or names. We then need to add the SIDs and create a token, all of which
    requires <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    so we impersonate a *SYSTEM* token ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: We register the three SIDs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command ❸. Note that you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp>
    parameter; otherwise, you’ll merely add the SID to the PowerShell module’s name
    cache and won’t register it with LSASS. Once we’ve added the SIDs, we need to
    grant the user <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    so that we can authenticate them and receive a token ❹. You could choose a different
    logon right, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>,
    if you wanted.
  prefs: []
  type: TYPE_NORMAL
- en: We can now authenticate the user via <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> ❺. Make
    sure to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Virtual</samp>
    logon provider and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    logon type. You don’t need to specify a password, but you can’t perform the operation
    without <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish impersonating, we remove the logon right and then delete the
    domain SID ❻. Deleting the domain SID will also delete the group and user SIDs
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we format the token. Now we can see that the user SID is the virtual
    SID we created ❼, and that the token is automatically granted the group SID as
    well ❽. Note that if we hadn’t added the SID-to-name mapping for the group SID,
    we’d still be granted it, but the SID would not be resolvable to a name. We can
    now impersonate the token or use it to create a new process running under that
    user identity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen, interactive authentication, the process used to access the Windows
    desktop, is an extremely complicated topic. The authentication process requires
    a combination of a user interface, which collects the credentials, and the Winlogon
    process, which calls the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. Once the API has validated the user’s credentials, it creates a new logon
    session, along with a token that Winlogon can use to create the user’s initial
    processes. The logon session can also cache the credentials so the user won’t
    need to re-enter them to access network services.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined the differences between local authentication and domain authentication.
    We only touched on how authentication works with Netlogon here, but we’ll cover
    the more common Kerberos in [Chapter 14](chapter14.xhtml). With an understanding
    of the basic authentication mechanisms in hand, we discussed how the LSA uses
    the user information to build a token, including how it assigns groups and privileges
    and how UAC results in token filtering for administrators.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed how to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API using the PowerShell module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We saw that we can use the token returned from the API to impersonate
    a user, because the LSA sets the token’s origin ID to the caller’s authentication
    ID. We also saw how to create a new process as a different user via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, exposed
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked briefly at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type and the four accounts that the LSA predefines. The service control
    manager uses these for its system service processes. In the next chapter, we’ll
    begin exploring how network authentication allows a user to authenticate to another
    Windows system. This will also allow us to understand the protocols used by domain
    authentication.
  prefs: []
  type: TYPE_NORMAL
