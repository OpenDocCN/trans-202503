- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Managing Complex Projects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理复杂项目
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Most assembly language source files aren’t stand-alone programs. They’re components
    of a large set of source files, in different languages, compiled and linked together
    to form complex applications. *Programming in the large* is the term software
    engineers have coined to describe the processes, methodologies, and tools for
    handling the development of large software projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编语言源文件并不是独立的程序。它们是多个源文件的组成部分，可能用不同的语言编写，编译并链接在一起，形成复杂的应用程序。*大型编程*是软件工程师用来描述处理大型软件项目开发的过程、方法和工具的术语。
- en: While everyone has their own idea of what *large* is, *separate compilation*
    is one of the more popular techniques that support programming in the large. Using
    separate compilation, you first break your large source files into manageable
    chunks. Then you compile the separate files into object code modules. Finally,
    you link the object modules together to form a complete program. If you need to
    make a small change to one of the modules, you need to reassemble only that one
    module; you do not need to reassemble the entire program. Once you’ve debugged
    and tested a large section of your code, continuing to assemble that same code
    when you make a small change to another part of your program is a waste of time.
    Imagine having to wait 20 or 30 minutes on a fast PC to assemble a program to
    which you’ve made a one-line change!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个人对什么是*大型*程序有自己的理解，*单独编译*是支持大型编程的流行技术之一。使用单独编译，你首先将大型源文件拆分成易于管理的部分。然后你将这些单独的文件编译成目标代码模块。最后，你将目标模块链接在一起，形成一个完整的程序。如果你需要对某个模块进行小的修改，你只需要重新组装那个模块；不需要重新组装整个程序。一旦你调试并测试了代码的大部分，当你对程序的其他部分进行小的修改时，继续组装相同的代码就是浪费时间。想象一下，在一台快速的
    PC 上，你只改动了一行代码，却要等 20 或 30 分钟才能重新组装程序！
- en: The following sections describe the tools MASM provides for separate compilation
    and how to effectively employ these tools in your programs for modularity and
    reduced development time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了 MASM 提供的单独编译工具，以及如何有效地在程序中使用这些工具，以实现模块化和减少开发时间。
- en: 15.1 The include Directive
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 `include` 指令
- en: The `include` directive, when encountered in a source file, merges a specified
    file into the compilation at the point of the `include` directive. The syntax
    for the `include` directive is
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当源文件中遇到 `include` 指令时，它会在 `include` 指令的位置将指定的文件合并到编译中。`include` 指令的语法是
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where `filename` is a valid filename. By convention, MASM include files have
    an *.inc* (include) suffix, but the name of any file containing MASM assembly
    language source will work fine. A file being included into another file during
    assembly may itself include files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `filename` 是一个有效的文件名。根据约定，MASM 的 include 文件具有 *.inc*（include）后缀，但任何包含 MASM
    汇编语言源代码的文件都可以正常使用。被包含的文件可以在汇编过程中再次包含其他文件。
- en: 'Using the `include` directive by itself does not provide separate compilation.
    You *could* use the `include` directive to break a large source file into separate
    modules and join these modules together when you compile your file. The following
    example would include the *print.inc* and *getTitle.inc* files during the compilation
    of your program:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用 `include` 指令并不能实现单独编译。你*可以*使用 `include` 指令将一个大型源文件拆分成多个模块，并在编译时将这些模块合并在一起。下面的示例会在程序编译时包括
    *print.inc* 和 *getTitle.inc* 文件：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now your program will benefit from modularity. Alas, you will not save any development
    time. The `include` directive inserts the source file at the point of the `include`
    during compilation, exactly as though you had typed that code yourself. MASM still
    has to compile the code, and that takes time. If you are including a large number
    of source files (such as a huge library) into your assembly, the compilation process
    could take *forever*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序将受益于模块化。可惜，你并不会节省任何开发时间。`include` 指令在编译时将源文件插入到 `include` 指令的位置，就像你自己手动输入这些代码一样。MASM
    仍然需要编译代码，而这需要时间。如果你在汇编过程中包含了大量源文件（例如一个庞大的库），编译过程可能需要*永远*。
- en: In general, you should *not* use the `include` directive to include source code
    as shown in the preceding example.^([1](#c15-footnote-1)) Instead, you should
    use the `include` directive to insert a common set of constants, types, external
    procedure declarations, and other such items into a program. Typically, an assembly
    language include file does *not* contain any machine code (outside of a macro;
    see Chapter 13 for details). The purpose of using `include` files in this manner
    will become clearer after you see how the external declarations work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你*不*应该使用`include`指令来包含前面示例中展示的源代码^([1](#c15-footnote-1))。相反，你应该使用`include`指令将一组通用的常量、类型、外部过程声明以及其他类似的项目插入程序中。通常，汇编语言的包含文件*不*包含任何机器代码（宏外的部分；详细信息请参见第13章）。以这种方式使用`include`文件的目的，在你看到外部声明如何工作的之后，会变得更加清晰。
- en: 15.2 Ignoring Duplicate Include Operations
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 忽略重复的包含操作
- en: 'As you begin to develop sophisticated modules and libraries, you will eventually
    discover a big problem: some header files need to include other header files.
    Well, this isn’t actually a big problem, but a problem will occur when one header
    file includes another, and that second header file includes another, and that
    third header file includes another, and . . . that last header file includes the
    first header file. Now *this* is a big problem, because it creates an infinite
    loop in the compiler and makes MASM complain about duplicate symbol definitions.
    After all, the first time it reads the header file, it processes all the declarations
    in that file; the second time around, it views all those symbols as duplicate
    symbols.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始开发复杂的模块和库时，你最终会发现一个大问题：一些头文件需要包含其他头文件。其实，这并不是什么大问题，但问题出现在当一个头文件包含另一个头文件，而第二个头文件又包含另一个，第三个头文件又包含另一个……最后那个头文件又包含第一个头文件时。现在*这*就是一个大问题，因为它会在编译器中产生一个无限循环，并导致MASM抱怨重复的符号定义。毕竟，第一次读取头文件时，它会处理该文件中的所有声明；第二次读取时，它会将这些符号视为重复符号。
- en: 'The standard technique for ignoring duplicate includes, well-known to C/C++
    programmers, is to use conditional assembly to have MASM ignore the content of
    an include file. (See “Conditional Assembly (Compile-Time Decisions)” in Chapter
    13.) The trick is to place an `ifndef` (*if not defined*) statement around all
    statements in the include file. You specify the include file’s filename as the
    `ifndef` operand, substituting underlines for periods (or any other undefined
    symbol). Then, immediately after the `ifndef` statement, you define that symbol
    (using a numeric equate and assigning the symbol the constant 0 is typical). Here’s
    an example of this `ifndef` usage in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略重复包含的标准技巧，C/C++程序员非常熟悉，就是使用条件汇编让MASM忽略包含文件的内容。（请参见第13章中的“条件汇编（编译时决策）”）诀窍是将一个`ifndef`（*如果未定义*）语句放在包含文件的所有语句周围。你将包含文件的文件名作为`ifndef`操作数，使用下划线替换点（或其他任何未定义的符号）。然后，在`ifndef`语句之后，立即定义该符号（通常使用数值等式并将该符号赋值为常数0）。以下是这个`ifndef`用法的一个示例：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the second inclusion, MASM simply skips over the contents of the include
    file (including any `include` directives), which prevents the infinite loop and
    all the duplicate symbol definitions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次包含时，MASM会直接跳过包含文件的内容（包括任何`include`指令），这样就避免了无限循环和所有的重复符号定义。
- en: 15.3 Assembly Units and External Directives
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 汇编单元和外部指令
- en: An *assembly unit* is the assembly of a source file plus any files it includes
    or indirectly includes. An assembly unit produces a single *.obj* file after assembly.
    The Microsoft linker takes multiple object files (produced by MASM or other compilers,
    such as MSVC) and combines them into a single executable unit (an *.exe* file).
    The main purpose of this section (and, indeed, this whole chapter) is to describe
    how these assembly units (*.obj* files) communicate linkage information to one
    another during the linking process. Assembly units are the basis for creating
    modular programs in assembly language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编单元*是一个源文件及其直接或间接包含的任何文件的集合。汇编单元在汇编后会生成一个单独的*.obj*文件。微软链接器将多个目标文件（由MASM或其他编译器生成，如MSVC）结合成一个单独的可执行单元（*.exe*文件）。本节的主要目的（实际上，这一整章的目的）是描述这些汇编单元（*.obj*文件）在链接过程中如何相互传递链接信息。汇编单元是创建汇编语言模块化程序的基础。'
- en: To use MASM’s assembly unit facilities, you must create at least two source
    files. One file contains a set of variables and procedures used by the second.
    The second file uses those variables and procedures without knowing how they’re
    implemented.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 MASM 的汇编单元功能，你必须创建至少两个源文件。一个文件包含第二个文件使用的变量和过程。第二个文件使用这些变量和过程，但不知道它们是如何实现的。
- en: Instead of using the `include` directive to create modular programs, which wastes
    time because MASM must recompile bug-free code every time you assemble the main
    program, a much better solution would be to preassemble the debugged modules and
    link the object code modules together. This is what the `public`, `extern`, and
    `externdef` directives allow you to do.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用 `include` 指令来创建模块化程序（因为每次汇编主程序时，MASM 都必须重新编译无错误的代码，浪费时间），不如预先汇编调试好的模块并将目标代码模块链接在一起，这样的解决方案要好得多。这正是
    `public`、`extern` 和 `externdef` 指令所允许你做的事情。
- en: 'Technically, all of the programs appearing in this book up to this point have
    been separately assembled modules (which happen to link with a C/C++ main program
    rather than another assembly language module). The assembly language main program
    named `asmMain` is nothing but a function compatible with C++ that the generic
    *c.cpp* program has called from its main program. Consider the body of `asmMain`
    from [Listing 2-1](c02.xhtml#listing2-1) in Chapter 2:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，本书到目前为止出现的所有程序都是单独汇编的模块（这些模块恰好与 C/C++ 主程序链接，而不是与其他汇编语言模块链接）。名为 `asmMain`
    的汇编语言主程序只是一个与 C++ 兼容的函数，通用的 *c.cpp* 程序从其主程序中调用了这个函数。考虑 [第 2 章](c02.xhtml#listing2-1)
    中 [Listing 2-1](c02.xhtml#listing2-1) 的 `asmMain` 函数体：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `public asmMain` statement has been included in every program that has had
    an `asmMain` function without any definition or explanation. Well, now it’s time
    to deal with that oversight.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含 `asmMain` 函数的程序中都包含了 `public asmMain` 语句，而没有任何定义或解释。好了，现在是时候解决这个遗漏了。
- en: Normal symbols in a MASM source file are *private* to that particular source
    file and are inaccessible from other source files (which don’t directly include
    the file containing those private symbols, of course). That is, the *scope* of
    most symbols in a source file is limited to those lines of code within that particular
    source file (and any files it includes). The `public` directive tells MASM to
    make the specified symbol global to the assembly unit—accessible by other assembly
    units during the link phase. Through the `public asmMain` statement in the example
    programs appearing throughout this book, these sample programs have made the `asmMain`
    symbol global to the source file containing them so that the *c.cpp* program can
    call the `asmMain` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 源文件中的普通符号是该源文件*私有*的，其他源文件无法访问这些符号（当然，前提是这些源文件没有直接包含包含这些私有符号的文件）。也就是说，源文件中大多数符号的*作用域*仅限于该源文件中的代码行（以及它包含的任何文件）。`public`
    指令告诉 MASM 将指定符号设置为全局符号——在链接阶段，其他汇编单元可以访问它。通过本书示例程序中的 `public asmMain` 语句，这些示例程序将
    `asmMain` 符号设置为包含它们的源文件的全局符号，以便 *c.cpp* 程序可以调用 `asmMain` 函数。
- en: 'Simply making a symbol public is insufficient to use that symbol in another
    source file. The source file that wants to use the symbol must also declare that
    symbol as an *external* symbol. This notifies the linker that it will have to
    patch in the address of a public symbol whenever the file with the external declaration
    uses that symbol. For example, the *c.cpp* source file defines the `asmMain` symbol
    as external in the following lines of code (for what it’s worth, this declaration
    also defines the external symbols `getTitle` and `readLine`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将符号设置为公共符号不足以在另一个源文件中使用该符号。想要使用该符号的源文件还必须将该符号声明为*外部*符号。这会通知链接器，当包含外部声明的文件使用该符号时，链接器必须修补该公共符号的地址。例如，*c.cpp*
    源文件在以下代码行中将 `asmMain` 符号定义为外部符号（顺便提一下，这个声明还定义了外部符号 `getTitle` 和 `readLine`）：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note, in this example, that `readLine` is a C++ function defined in the *c.cpp*
    source file. C/C++ does not have an explicit public declaration. Instead, if you
    supply the source code for a function in a source file that declares that function
    to be external, C/C++ will automatically make that symbol public by virtue of
    the external declaration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，`readLine` 是一个在 *c.cpp* 源文件中定义的 C++ 函数。C/C++ 没有显式的公共声明。相反，如果你为一个源文件中的函数提供源代码，并且声明该函数为外部函数，C/C++
    会通过外部声明自动将该符号设置为公共符号。
- en: 'MASM actually has two external symbol declaration directives: `extern` and
    `externdef`.^([2](#c15-footnote-2)) These two directives use the syntax'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MASM实际上有两个外部符号声明指令：`extern`和`externdef`。^([2](#c15-footnote-2))这两个指令的语法是：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'where `symbol` is the identifier you want to use from another assembly unit,
    and `type` is the data type of that symbol. The data type can be any of the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`symbol`是你想要从另一个汇编单元中使用的标识符，而`type`是该符号的数据类型。数据类型可以是以下任何一种：
- en: '`proc`, which indicates that the symbol is a procedure (function) name or a
    statement label'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc`，表示该符号是一个过程（函数）名称或语句标签'
- en: Any MASM built-in data type (such as `byte`, `word`, `dword`, `qword`, `oword`,
    and so on)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意MASM内建数据类型（例如`byte`、`word`、`dword`、`qword`、`oword`等）
- en: Any user-defined data type (such as a struct name)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意用户自定义数据类型（例如结构体名称）
- en: '`abs`, which indicates a constant value'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs`，表示一个常量值'
- en: The `abs` type isn’t for declaring generic external constants such as `someConst
    = 0`. Pure constant declarations, such as this one, would normally appear in a
    header file (an include file), which this section will describe shortly. Instead,
    the `abs` type is generally reserved for constants that are based on code offsets
    within an object module. For example, if you have the following code in an assembly
    unit,
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs`类型并不是用来声明通用外部常量（例如`someConst = 0`）。像这样的纯常量声明通常会出现在头文件（即包含文件）中，本节稍后会描述这一点。相反，`abs`类型通常保留给基于对象模块中代码偏移量的常量。例如，如果你在一个汇编单元中有以下代码，'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`someLen`’s type, in an `extern` declaration, would be `abs`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`someLen`的类型，在`extern`声明中，将是`abs`。'
- en: 'Both directives use a comma-delimited list to allow multiple symbol declarations;
    for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令使用逗号分隔的列表来允许多个符号声明；例如：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I’d argue, however, that your programs will be more readable if you limit your
    external declarations to one symbol per statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为，如果将每个声明限制为单个符号，你的程序会更易于阅读。
- en: When you place an `extern` directive in your program, MASM treats that declaration
    the same as any other symbol declaration. If the symbol already exists, MASM will
    generate a symbol-redefinition error. Generally, you should place all external
    declarations near the beginning of the source file to avoid any scoping or forward
    reference issues. Because the public directive does not actually define the symbol,
    the placement of the public directive is not as critical. Some programmers put
    all the public declarations at the beginning of a source file; others put the
    public declaration right before the definition of the symbol (as I’ve done with
    the `asmMain` symbol in most of the same programs). Either position is fine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在程序中放置`extern`指令时，MASM会将该声明视为任何其他符号声明。如果符号已存在，MASM会生成符号重定义错误。通常，应该将所有外部声明放在源文件的开始部分，以避免作用域或前向引用问题。由于`public`指令实际上并不定义符号，因此`public`指令的位置并不像`extern`指令那么关键。有些程序员将所有公共声明放在源文件的开头；其他程序员则将公共声明放在符号定义之前（如我在大多数相同程序中对`asmMain`符号所做的那样）。这两种位置都可以。
- en: 15.4 Header Files in MASM
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 MASM中的头文件
- en: 'Because a public symbol from one source file can be used by many assembly units,
    a small problem develops: you have to replicate the `extern` directive in all
    the files that use that symbol. For a small number of symbols, this is not much
    of a problem. However, as the number of external symbols increases, maintaining
    all these external symbols across multiple source files becomes burdensome. The
    MASM solution is the same as the C/C++ solution: header files.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个源文件中的公共符号可以被多个汇编单元使用，因此会出现一个小问题：你必须在所有使用该符号的文件中复制`extern`指令。对于少量符号来说，这不是什么大问题。然而，随着外部符号数量的增加，跨多个源文件维护这些外部符号会变得繁琐。MASM的解决方案与C/C++相同：头文件。
- en: '*Header files* are include files that contain external (and other) declarations
    that are common among multiple assembly units. They are called *header files*
    because the include statement that injects their code into a source file normally
    appears at the beginning (at the *head*) of the source file that uses them. This
    turns out to be the primary use of include files in MASM: to include external
    (and other) common declarations.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*头文件*是包含多个汇编单元间共有的外部（以及其他）声明的包含文件。之所以叫做*头文件*，是因为通常会在使用它们的源文件的开始部分（*头部*）插入包含语句。这实际上是MASM中包含文件的主要用途：包含外部（以及其他）公共声明。'
- en: 15.5 The externdef Directive
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5 `externdef`指令
- en: When you start using header files with large sets of library modules (assembly
    units), you’ll quickly discover a huge problem with the `extern` directive. Typically,
    you will create a single header file for a large set of library functions, with
    each function possibly appearing in its own assembly unit. Some library functions
    might use other functions in the same *library module* (a collection of object
    files); therefore, that particular library function’s source file might want to
    include the header file for the library in order to reference the external name
    of the other library function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用包含大量库模块（汇编单元）的头文件时，你会很快发现`extern`指令存在一个大问题。通常，你会为一大套库函数创建一个头文件，每个函数可能会出现在自己的汇编单元中。有些库函数可能会使用同一*库模块*（一组目标文件）中的其他函数；因此，该特定库函数的源文件可能会想要包含库的头文件，以便引用其他库函数的外部名称。
- en: 'Unfortunately, if the header file contains the external definition for the
    function in the current source file, a symbol redefinition error occurs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果头文件包含当前源文件中函数的外部定义，则会发生符号重新定义错误：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Assembly of the following source file produces an error because `func1` is
    already defined in the *header.inc* include file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源文件的汇编会产生错误，因为`func1`已经在*header.inc*头文件中定义：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: C/C++ doesn’t suffer from this problem because the external keyword doubles
    as both a public and an external declaration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++不会遇到这个问题，因为`external`关键字既作为公共声明，也作为外部声明。
- en: 'To overcome this problem, MASM introduced the `externdef` directive. This directive
    is similar to C/C++’s `external` directive: it behaves like an `extern` directive
    when the symbol is not present in a source file, and it behaves like a `public`
    directive when the symbol is defined in a source file. In addition, multiple `externdef`
    declarations for the same symbol may appear in a source file (though they should
    specify the same type for the symbol if multiple declarations do appear). Consider
    the previous *header.inc* header file modified to use `externdef` definitions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，MASM引入了`externdef`指令。该指令类似于C/C++中的`external`指令：当符号在源文件中不存在时，它表现得像一个`extern`指令，而当符号在源文件中定义时，它表现得像一个`public`指令。此外，同一符号的多个`externdef`声明可以出现在源文件中（尽管如果出现多个声明，它们应该指定相同的符号类型）。考虑修改后的*header.inc*头文件，使用`externdef`定义：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using this header file, the *func1.asm* assembly unit will compile correctly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个头文件，*func1.asm*汇编单元将会正确编译。
- en: 15.6 Separate Compilation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6 分离编译
- en: Way back in “The MASM Include Directive” in Chapter 11, I started putting the
    `print` and `getTitle` functions in include files so that I could simply include
    them in every source file that needed to use these functions rather than manually
    cutting and pasting these functions into every program. Clearly, these are good
    examples of programs that should be made into assembly units and linked with other
    programs rather than being included during assembly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很早在第11章的“MASM包含指令”中，我就开始将`print`和`getTitle`函数放入头文件中，这样我就可以在每个需要使用这些函数的源文件中简单地包含它们，而无需手动将这些函数复制粘贴到每个程序中。显然，这些是应该制作成汇编单元并与其他程序链接的好例子，而不是在汇编过程中被包含进来。
- en: '[Listing 15-1](#listing15-1) is a header file that incorporates the necessary
    `print` and `getTitle` declarations:^([3](#c15-footnote-3))'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-1](#listing15-1) 是一个头文件，其中包含了必要的`print`和`getTitle`声明：^([3](#c15-footnote-3))'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 15-1: *aoalib.inc* header file'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-1：*aoalib.inc*头文件
- en: '[Listing 15-2](#listing15-2) contains the `print` function used in “The MASM
    Include Directive” in Chapter 11 converted to an assembly unit.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-2](#listing15-2) 包含了在第11章“MASM包含指令”中使用的`print`函数，并将其转换为一个汇编单元。'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 15-2: The `print` function appearing in an assembly unit'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-2：出现在汇编单元中的`print`函数
- en: To complete all the common *aoalib* functions used thus far, here is [Listing
    15-3](#listing15-3).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成迄今为止使用的所有常见*aoalib*函数，这里是[清单 15-3](#listing15-3)。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 15-3: The `getTitle` function as an assembly unit'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-3：作为汇编单元的`getTitle`函数
- en: '[Listing 15-4](#listing15-4) is a program that uses the assembly units in Listings
    15-2 and 15-3.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-4](#listing15-4) 是一个使用清单15-2和15-3中汇编单元的程序。'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 15-4: A main program that uses the `print` and `getTitle` assembly
    modules'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-4：一个使用`print`和`getTitle`汇编模块的主程序
- en: 'So how do you build and run this program? Unfortunately, the *build.bat* batch
    file this book has been using up to this point will not do the job. Here’s a command
    that will assemble all the units and link them together:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何构建和运行这个程序呢？不幸的是，本书到目前为止使用的*build.bat*批处理文件无法完成这个任务。这里有一个命令，它会将所有单元汇集并将它们链接在一起：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands will properly compile all source files and link together their
    object code to produce the executable file *c.exe*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将正确地编译所有源文件并将它们的目标代码链接在一起，生成可执行文件*c.exe*。
- en: Unfortunately, the preceding commands defeat one of the major benefits of separate
    compilation. When you issue the `ml64 /c print.asm getTitle.asm listing15-4.asm`
    command, it will compile all the assembly source files. Remember, a major reason
    for separate compilation is to reduce compilation time on large projects. While
    the preceding commands work, they don’t achieve this goal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的命令失去了分离编译的一个主要优势。当你执行`ml64 /c print.asm getTitle.asm listing15-4.asm`命令时，它会编译所有的汇编源文件。记住，分离编译的一个主要原因是为了减少大项目的编译时间。虽然前面的命令有效，但它们并没有实现这个目标。
- en: 'To separately compile the two modules, you must run MASM separately on them.
    To compile the three source files separately, break the `ml64` invocation into
    three separate commands:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要分别编译这两个模块，你必须分别对它们运行MASM。要分别编译这三个源文件，可以将`ml64`调用拆分成三个单独的命令：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, this sequence still compiles all three assembly source files. However,
    after the first time you execute these commands, you’ve built the *print.obj*
    and *getTitle.obj* files. From this point forward, as long as you don’t change
    the *print.asm* or *getTitle.asm* source files (and don’t delete the *print.obj*
    or *getTitle.obj* files), you can build and run the program in [Listing 15-4](#listing15-4)
    by using these commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个顺序仍然会编译所有三个汇编源文件。然而，在第一次执行这些命令之后，你已经构建了*print.obj*和*getTitle.obj*文件。从此以后，只要你不更改*print.asm*或*getTitle.asm*源文件（并且不删除*print.obj*或*getTitle.obj*文件），你就可以通过使用这些命令来构建和运行[Listing
    15-4](#listing15-4)中的程序：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, you’ve saved the time needed to compile the *print.asm* and *getTitle.asm*
    files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你节省了编译*print.asm*和*getTitle.asm*文件所需的时间。
- en: 15.7 An Introduction to Makefiles
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7 Makefile简介
- en: 'The *build.bat* file used throughout this book has been far more convenient
    than typing the individual build commands. Unfortunately, the build mechanism
    that *build.bat* supports is really good for only a few fixed source files. While
    you could easily construct a batch file to compile all the files in a large assembly
    project, running the batch file would reassemble every source file in the project.
    Although you can use complex command line functions to avoid some of this, there
    is an easier way: makefiles.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的*build.bat*文件比逐个输入构建命令要方便得多。不幸的是，*build.bat*支持的构建机制实际上只适用于少数固定的源文件。虽然你可以轻松构造一个批处理文件来编译一个大型汇编项目中的所有文件，但运行该批处理文件时会重新汇编项目中的每一个源文件。虽然你可以使用复杂的命令行功能来避免一些这种情况，但有一种更简单的方法：makefile。
- en: 'A *makefile* is a script in a special language (designed in early releases
    of Unix) that specifies how to execute a series of commands based on certain conditions,
    executed by the program make. If you’ve installed MSVC and MASM as part of Visual
    Studio, you’ve probably also installed (as part of that same process) Microsoft’s
    variant of make: `nmake.exe`.^([4](#c15-footnote-4)) To use `nmake.exe`, you execute
    it from a Windows command line as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*makefile*是一种特殊语言的脚本（最早在Unix的早期版本中设计），它指定了如何基于某些条件执行一系列命令，这些命令由make程序执行。如果你已经安装了MSVC和MASM作为Visual
    Studio的一部分，那么你可能也已经安装了（作为同一过程的一部分）Microsoft版本的make：`nmake.exe`。^([4](#c15-footnote-4))
    要使用`nmake.exe`，你可以在Windows命令行中按如下方式执行：'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you execute `nmake` on a command line by itself (without any arguments),
    `nmake.exe` will search for a file named *makefile* and attempt to process the
    commands in that file. For many projects, this is very convenient. You will have
    all your project’s source files in a single directory (or in subdirectories hanging
    off that directory), and you will place a single makefile (named *makefile*) in
    that directory. By changing into that directory and executing `nmake` (or `make`),
    you can build the project with minimal fuss.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中单独执行`nmake`（没有任何参数），`nmake.exe`将搜索名为*makefile*的文件，并尝试处理该文件中的命令。对于许多项目来说，这是非常方便的。你将把所有项目的源文件放在一个目录中（或该目录下的子目录中），并将一个名为*makefile*的单一makefile放在该目录中。通过切换到该目录并执行`nmake`（或`make`），你可以轻松构建项目。
- en: 'If you want to use a different filename than *makefile*, you must preface the
    filename with the `/f` option, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用不同于 *makefile* 的文件名，必须在文件名前加上 `/f` 选项，如下所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The filename doesn’t have to have the extension *.mak*. However, this is a popular
    convention when using makefiles that are not named *makefile*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名不一定需要具有 *.mak* 扩展名。然而，当使用非 *makefile* 命名的 makefile 时，这是一个常见的约定。
- en: The `nmake` program does provide many command line options, and `/help` will
    list them. Look up `nmake` documentation online for a description of the other
    command line options (most of them are advanced and are unnecessary for most tasks).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmake` 程序确实提供了许多命令行选项，`/help` 将列出它们。请查阅 `nmake` 文档以了解其他命令行选项的描述（其中大多数是高级选项，对于大多数任务来说不必要）。'
- en: 15.7.1 Basic Makefile Syntax
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.1 基本 Makefile 语法
- en: 'A makefile is a standard ASCII text file containing a sequence of lines (or
    a set of multiple occurrences of this sequence) as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: makefile 是一个标准的 ASCII 文本文件，包含以下格式的一系列行（或该序列的多个出现）：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `target``:` `dependencies` line is optional. The `commands` item is a list
    of one or more command line commands, also optional. The `target` item, if present,
    must begin in column 1 of the source line it is on. The `commands` items must
    have at least one whitespace character (space or tab) in front of them (that is,
    they must not begin in column 1 of the source line). Consider the following valid
    makefile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`target``:` `dependencies` 行是可选的。`commands` 项是一个包含一个或多个命令行命令的列表，也是可选的。`target`
    项，如果存在，必须从它所在的源行的第 1 列开始。`commands` 项必须在前面至少有一个空白字符（空格或制表符）（即，它们不能从源行的第 1 列开始）。考虑以下有效的
    makefile：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If these commands appear in a file named *makefile* and you execute `nmake`,
    then `nmake` will execute these commands exactly like the command line interpreter
    would have executed them had they appeared in a batch file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些命令出现在名为 *makefile* 的文件中，并且您执行 `nmake`，那么 `nmake` 将像命令行解释器在批处理文件中出现这些命令时那样执行它们。
- en: 'A `target` item is an identifier or a filename of some sort. Consider the following
    makefile:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`target` 项是某种标识符或文件名。考虑以下 makefile：'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This separates the build commands into two groups: one group specified by the
    `executable` label and one group specified by the `library` label.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建命令分为两组：一组由 `executable` 标签指定，另一组由 `library` 标签指定。
- en: If you run `nmake` without any command line options, `nmake` will execute only
    those commands associated with the very first target in the makefile. In this
    example, if you run `nmake` by itself, it will assemble *listing15-4.asm*, *print.asm*,
    and *getTitle.asm*; compile *c.cpp*; and attempt to link the resulting *c.obj*
    with *print.obj*, *getTitle.obj*, and *listing15-4.obj*. This should successfully
    produce the *c.exe* executable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有任何命令行选项运行 `nmake`，`nmake` 只会执行与 makefile 中第一个目标相关的命令。在这个例子中，如果您单独运行 `nmake`，它将汇编
    *listing15-4.asm*、*print.asm* 和 *getTitle.asm*；编译 *c.cpp*；并尝试将生成的 *c.obj* 与 *print.obj*、*getTitle.obj*
    和 *listing15-4.obj* 链接。这应该能够成功生成 *c.exe* 可执行文件。
- en: 'To process the commands after the library target, specify the target name as
    an `nmake` command line argument:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理库目标之后的命令，请将目标名称作为 `nmake` 命令行参数指定：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `nmake` command compiles *print.asm* and *getTitle.asm*. So if you execute
    this command once (and never change *print.asm* or *getTitle.asm* thereafter),
    you need only execute the `nmake` command by itself to generate the executable
    file (or use `nmake executable` if you want to explicitly state that you are building
    the executable).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该 `nmake` 命令编译 *print.asm* 和 *getTitle.asm*。因此，如果您执行该命令一次（且以后不再更改 *print.asm*
    或 *getTitle.asm*），只需执行 `nmake` 命令本身即可生成可执行文件（或者如果您希望明确说明正在构建可执行文件，可以使用 `nmake
    executable`）。
- en: 15.7.2 Make Dependencies
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.2 Make 依赖关系
- en: Although the ability to specify which targets you want to build on the command
    line is very useful, as your projects get larger (with many source files and library
    modules), keeping track of which source files you need to recompile all the time
    can be burdensome and error prone; if you’re not careful, you’ll forget to compile
    an obscure library module after you’ve made changes to it and wonder why the application
    is still failing. The make dependencies option allows you to automate the build
    process to help avoid these problems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在命令行中指定要构建的目标非常有用，但随着项目的增大（包含许多源文件和库模块），始终跟踪哪些源文件需要重新编译可能会变得繁琐且容易出错；如果不小心，您可能会忘记在对某个不常用的库模块进行修改后重新编译它，并且困惑为何应用程序仍然失败。make
    依赖选项可以让您自动化构建过程，帮助避免这些问题。
- en: 'A list of one or more (whitespace-separated) dependencies can follow a target
    in a makefile:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在makefile中，一个或多个（以空格分隔的）依赖项可以跟随一个目标：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Dependencies are either target names (of targets appearing in that makefile)
    or filenames. If a dependency is a target name (that is not also a filename),
    `nmake` will go execute the commands associated with that target. Consider the
    following makefile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项可以是目标名称（出现在该makefile中的目标）或文件名。如果依赖项是一个目标名称（而不是文件名），`nmake`会执行与该目标相关联的命令。请考虑以下makefile：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `all` target depends on the `library` and `executable` targets, so it will
    go execute the commands associated with those targets (and in the order `library`,
    `executable`, which is important because the `library` object files must be built
    before the associated object modules can be linked into the executable program).
    The `all` identifier is a common target in makefiles. Indeed, it is often the
    first or second target to appear in a makefile.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`目标依赖于`library`和`executable`目标，因此它会执行与这些目标相关联的命令（并按`library`、`executable`的顺序执行，这一点很重要，因为`library`目标文件必须在相关的目标模块链接到可执行程序之前构建）。`all`标识符是makefile中常见的目标，实际上，它通常是makefile中出现的第一个或第二个目标。'
- en: If a `target``:` `dependencies` line becomes too long to be readable (`nmake`
    doesn’t really care too much about line length), you can break the line into multiple
    lines by putting a backslash character (`\`) as the last character on a line.
    The `nmake` program will combine source lines that end with a backslash with the
    next line in the makefile.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`target``:` `dependencies`行变得过长，导致无法读取（`nmake`并不特别关心行长问题），你可以通过在行末放置一个反斜杠字符（`\`）来将这一行拆分为多行。`nmake`程序会将以反斜杠结尾的源行与makefile中的下一行合并。
- en: 'Target names and dependencies can also be filenames. Specifying a filename
    as a target name is generally done to tell the make system how to build that particular
    file. For example, we could rewrite the current example as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称和依赖项也可以是文件名。将文件名指定为目标名称通常是为了告诉构建系统如何构建该特定文件。例如，我们可以将当前示例重写如下：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When dependencies are associated with a target that is a filename, you can read
    the `target``:` `dependencies` statement as “`target` depends on `dependencies`.”
    When processing a make command, `nmake` compares the modification date and time
    stamp of the files specified as target filenames and dependency filenames.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖项与目标关联且目标为文件名时，你可以将`target``:` `dependencies`语句理解为“`target`依赖于`dependencies`”。在处理make命令时，`nmake`会比较指定为目标文件名和依赖文件名的文件的修改日期和时间戳。
- en: If the date and time of the target are older than *any* of the dependencies
    (or the target file doesn’t exist), `nmake` will execute the commands after the
    target. If the target file’s modification date and time are later (newer) than
    *all* of the dependent files, `nmake` will not execute the commands. If one of
    the dependencies after a target is itself a target elsewhere, `nmake` will first
    execute that command (to see if it modifies the target object, changing its modification
    date and time, and possibly causing `nmake` to execute the current target’s commands).
    If a target or dependency is just a label (it is not a filename), `nmake` will
    treat its modification date and time as older than any file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标的日期和时间早于*任何*依赖项（或者目标文件不存在），`nmake`会执行目标后的命令。如果目标文件的修改日期和时间比*所有*依赖文件的日期和时间都要晚（更新），`nmake`则不会执行命令。如果目标后面的某个依赖项本身是其他地方的目标，`nmake`会首先执行该命令（以查看它是否修改目标对象，改变其修改日期和时间，可能会导致`nmake`执行当前目标的命令）。如果目标或依赖项只是一个标签（而不是文件名），`nmake`会将其修改日期和时间视为比任何文件都要旧。
- en: 'Consider the following modification to the running `makefile` example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑对运行中的`makefile`示例做如下修改：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the `all` and `library` targets were removed (they turn out to be
    unnecessary) and that `executable` was changed to *c.exe* (the final target executable
    file).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`all`和`library`目标已被移除（它们被认为是不必要的），而`executable`被更改为*c.exe*（最终的目标可执行文件）。
- en: Consider the *c.exe* target. Because *print.obj*, *getTitle.obj*, and *listing15-4.obj*
    are all targets (as well as filenames), `nmake` will first go execute those targets.
    After executing those targets, `nmake` will compare the modification date and
    time of *c.exe* against that of the three object files. If *c.exe* is older than
    any of those object files, `nmake` will execute the command following the *c.exe*
    target line (to compile *c.cpp* and link it with the object files). If *c.exe*
    is newer than its dependent object files, `nmake` will not execute the command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 *c.exe* 目标。因为 *print.obj*、*getTitle.obj* 和 *listing15-4.obj* 都是目标（也是文件名），`nmake`
    会首先执行这些目标。执行这些目标后，`nmake` 会比较 *c.exe* 的修改日期和时间与这三个目标文件的修改日期和时间。如果 *c.exe* 比其中任何一个目标文件都要旧，`nmake`
    会执行 *c.exe* 目标行后面的命令（编译 *c.cpp* 并将其与目标文件链接）。如果 *c.exe* 比依赖的目标文件更新，`nmake` 将不会执行该命令。
- en: The same process happens, recursively, for each of the dependent object files
    following the *c.exe* target. While processing the *c.exe* target, `nmake` will
    go off and process the *print.obj*, *getTitle.obj*, and *listing15-4.obj* targets
    (in that order). In each case, `nmake` will compare the modification date and
    time of the *.obj* file with the corresponding *.asm* file. If the *.obj* file
    is newer than the *.asm* file, `nmake` returns to processing the *c.exe* target
    without doing anything; if the *.obj* file is older than the *.asm* file (or doesn’t
    exist), `nmake` executes the corresponding `ml64` command to generate a new *.obj*
    file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个依赖的目标文件，`nmake` 会按相同的过程递归执行，依次处理 *print.obj*、*getTitle.obj* 和 *listing15-4.obj*
    目标。在处理 *c.exe* 目标时，`nmake` 会依次处理 *print.obj*、*getTitle.obj* 和 *listing15-4.obj*
    目标（按这个顺序）。在每一种情况下，`nmake` 会比较 *.obj* 文件的修改日期和时间与对应的 *.asm* 文件。如果 *.obj* 文件比 *.asm*
    文件更新，`nmake` 会返回处理 *c.exe* 目标，而不做任何操作；如果 *.obj* 文件比 *.asm* 文件旧（或不存在），`nmake` 会执行相应的
    `ml64` 命令生成新的 *.obj* 文件。
- en: If *c.exe* is newer than all the *.obj* files (and they are all newer than the
    *.asm* files), executing `nmake` does nothing (well, it will report that *c.exe*
    is up to date, but it will not process any of the commands in the makefile). If
    any of the files are out of date (because they’ve been modified), this makefile
    will compile and link only the files necessary to bring *c.exe* up to date.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *c.exe* 比所有的 *.obj* 文件都更新（且它们都比 *.asm* 文件更新），执行 `nmake` 不会做任何事情（好吧，它会报告 *c.exe*
    已经是最新的，但不会处理 makefile 中的任何命令）。如果任何文件是过时的（因为它们已被修改），这个 makefile 只会编译和链接必要的文件，以使
    *c.exe* 更新。
- en: 'The makefiles thus far are missing an important dependency: all of the *.asm*
    files include the *aoalib.inc* file. A change to *aoalib.inc* could possibly require
    a recompilation of these *.asm* files. This dependency has been added to [Listing
    15-5](#listing15-5). This listing also demonstrates how to include comments in
    a makefile by using the `#` character at the beginning of a line.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，makefile 缺少一个重要的依赖关系：所有的 *.asm* 文件都包含了 *aoalib.inc* 文件。对 *aoalib.inc*
    的更改可能会导致这些 *.asm* 文件的重新编译。这个依赖关系已经添加到 [Listing 15-5](#listing15-5) 中。这个列表还演示了如何通过在行首使用
    `#` 字符来在 makefile 中包含注释。
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 15-5: Makefile to build [Listing 15-4](#listing15-4)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 15-5: 用于构建 [Listing 15-4](#listing15-4) 的 makefile'
- en: 'Here’s the `nmake` command to build the program in [Listing 15-4](#listing15-4)
    by using the makefile (*listing15-5.mak*) in [Listing 15-5](#listing15-5):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 [Listing 15-5](#listing15-5) 中的 makefile 来构建 [Listing 15-4](#listing15-4)
    程序的 `nmake` 命令：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 15.7.3 Make Clean and Touch
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7.3 Make Clean 和 Touch
- en: One common target you will find in most professionally made makefiles is `clean`.
    The `clean` target will delete an appropriate set of files to force the entire
    system to be remade the next time you execute the makefile. This command typically
    deletes all the *.obj* and *.exe* files associated with the project. [Listing
    15-6](#listing15-6) provides a `clean` target for the makefile in [Listing 15-5](#listing15-5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数专业制作的 makefile 中，你会找到一个常见的目标 `clean`。`clean` 目标会删除一组适当的文件，以便下次执行 makefile
    时强制重新构建整个系统。这个命令通常会删除与项目相关的所有 *.obj* 和 *.exe* 文件。[Listing 15-6](#listing15-6)
    提供了 [Listing 15-5](#listing15-5) 中的 `clean` 目标。
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 15-6: A `clean` target example'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 15-6: 一个 `clean` 目标示例'
- en: 'Here is a sample clean and remake operation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例的清理和重建操作：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want to force the recompilation of a single file (without manually editing
    and modifying it), a Unix utility comes in handy: `touch`. The `touch` program
    accepts a filename as its argument and goes in and updates the modification date
    and time of the file (without otherwise modifying the file). For example, after
    building [Listing 15-4](#listing15-4) by using the makefile in [Listing 15-6](#listing15-6),
    were you to execute the command'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想强制重新编译一个文件（而不需要手动编辑和修改它），一个Unix工具会派上用场：`touch`。`touch`程序接受一个文件名作为参数，然后更新文件的修改日期和时间（而不对文件本身进行修改）。例如，在使用[Listing
    15-6](#listing15-6)中的makefile构建[Listing 15-4](#listing15-4)之后，如果你执行命令
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: and then execute the makefile in [Listing 15-6](#listing15-6) again, it would
    reassemble the code in [Listing 15-4](#listing15-4), recompile *c.cpp*, and produce
    a new executable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次执行[Listing 15-6](#listing15-6)中的makefile，它会重新组装[Listing 15-4](#listing15-4)中的代码，重新编译*c.cpp*，并生成一个新的可执行文件。
- en: Unfortunately, while `touch` is a standard Unix application and comes with every
    Unix and Linux distribution, it is not a standard Windows application.^([5](#c15-footnote-5))
    Fortunately, you can easily find a version of `touch` for Windows on the internet.
    It’s also a relatively simple program to write.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，虽然`touch`是一个标准的Unix应用程序，并且在每个Unix和Linux发行版中都会附带，但它不是Windows的标准应用程序^([5](#c15-footnote-5))。幸运的是，你可以很容易地在互联网上找到适用于Windows的`touch`版本。这也是一个相对简单的程序，可以自行编写。
- en: 15.8 The Microsoft Linker and Library Code
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8 Microsoft链接器和库代码
- en: 'Many common projects reuse code that developers created long ago (or they use
    code that came from a source outside the developer’s organization). These libraries
    of code are relatively *static*: they rarely change during the development of
    a project that uses the library code. In particular, you would not normally incorporate
    the building of the libraries into a given project’s makefile. A specific project
    might list the library files as dependencies in the makefile, but the assumption
    is that the library files are built elsewhere and supplied as a whole to the project.
    Beyond that, one major difference exists between a library and a set of object
    code files: packaging.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的项目会重用开发人员早期创建的代码（或者使用来自开发者组织外部的代码）。这些代码库相对来说是*静态的*：在使用这些库代码的项目开发过程中，它们很少发生变化。特别地，通常不会将库的构建过程纳入特定项目的makefile中。一个特定项目可能会在makefile中将库文件列为依赖项，但假设库文件是在其他地方构建的，并作为整体提供给项目。除此之外，库和一组目标代码文件之间还存在一个主要的区别：打包。
- en: Dealing with a myriad of separate object files can become troublesome when you’re
    working with true sets of library object files. A library may contain tens, hundreds,
    or even thousands of object files. Listing all of these object files (or even
    just the ones a project uses) is a lot of work and can lead to consistency errors.
    A common way to deal with this problem is to combine various object files into
    a separate package (file) known as a *library file*. Under Windows, library files
    typically have a *.lib* suffix.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量单独的目标文件时，尤其是当你在处理真正的库目标文件集时，会变得很麻烦。一个库可能包含几十、几百甚至上千个目标文件。列出所有这些目标文件（甚至仅仅是项目使用的文件）是一项繁重的工作，并且可能导致一致性错误。解决这个问题的常见方法是将各种目标文件组合成一个单独的包（文件），称为*库文件*。在Windows下，库文件通常具有*.lib*后缀。
- en: 'For many projects, you will be given a library (*.lib*) file that packages
    together a specific library module. You supply this file to the linker when building
    your program, and the linker automatically picks out the object modules it needs
    from the library. This is an important point: including a library while building
    an executable does not automatically insert all of the code from that library
    into the executable. The linker is smart enough to extract only the object files
    it needs and to ignore the object files it doesn’t use (remember, a library is
    just a package containing a bunch of object files).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多项目，你会获得一个库（*.lib*）文件，它将特定的库模块打包在一起。你在构建程序时将这个文件提供给链接器，链接器会自动从库中挑选出它需要的目标模块。这是一个重要的要点：在构建可执行文件时包含一个库，并不会自动将该库中的所有代码插入到可执行文件中。链接器足够智能，能够只提取它需要的目标文件，并忽略它不使用的目标文件（记住，库只是一个包含大量目标文件的包）。
- en: So the question is, “How do you create a library file?” The short answer is,
    “By using the Microsoft Library Manager program (*lib.exe*).” The basic syntax
    for the `lib` program is
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是，“如何创建一个库文件？”简短的回答是，“通过使用Microsoft Library Manager程序（*lib.exe*）。”`lib`程序的基本语法是
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'where `libname.lib` is the name of the library file you want to produce, and
    `list_of_.obj_files` is a (space-separated) list of object filenames you want
    to collect into the library. For example, if you want to combine the *print.obj*
    and *getTitle.obj* files into a library module (*aoalib.lib*), here’s the command
    to do it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`libname.lib`是你要生成的库文件的名称，`list_of_.obj_files`是你要合并到库中的（以空格分隔的）目标文件列表。例如，如果你想将*print.obj*和*getTitle.obj*文件合并成一个库模块（*aoalib.lib*），可以使用以下命令：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once you have a library module, you can specify it on a linker (or `ml64` or
    `cl`) command line just as you would an object file. For example, to link in the
    *aoalib.lib* module with the program in [Listing 15-4](#listing15-4), you could
    use the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个库模块，你可以像指定目标文件一样，在链接器（或`ml64`或`cl`）命令行中指定它。例如，要将*aoalib.lib*模块与[Listing
    15-4](#listing15-4)中的程序链接，你可以使用以下命令：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `lib` program supports several command line options. You can get a list
    of those options by using this command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`程序支持多种命令行选项。你可以通过使用以下命令获取这些选项的列表：'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See the online Microsoft documentation for a description of the various commands.
    Perhaps the most useful of the options is
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅在线的Microsoft文档，了解各种命令的描述。最有用的选项之一可能是
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'where `lib_filename.lib` represents a library filename. This will print a list
    of the object files contained within that library module. For example, `lib /list
    aoalib.lib` produces the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`lib_filename.lib`表示库文件名。这将打印该库模块中包含的目标文件列表。例如，`lib /list aoalib.lib`会输出如下内容：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: MASM provides a special directive, `includelib`, that lets you specify libraries
    to include. This directive has the syntax
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MASM提供了一条特殊指令`includelib`，允许你指定要包含的库。此指令的语法为
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: where `lib_filename.lib` is the name of the library file you want to include.
    This directive embeds a command in the object file that MASM produces that passes
    this library filename along to the linker. The linker will then automatically
    load the library file when processing the object module containing the `includelib`
    directive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`lib_filename.lib`是你要包含的库文件的名称。此指令在MASM生成的目标文件中嵌入一条命令，将该库文件名传递给链接器。链接器将在处理包含`includelib`指令的目标模块时自动加载库文件。
- en: This activity is identical to manually specifying the library filename to the
    linker (from the command line). Whether you prefer to put the `includelib` directive
    in a MASM source file, or include the library name on the linker (or `ml64`/`cl`)
    command line, is up to you. In my experience, most assembly language programmers
    (especially when writing stand-alone assembly language programs) prefer the `includelib`
    directive.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这一操作与手动将库文件名指定给链接器（通过命令行）是相同的。你是否偏好将`includelib`指令放在MASM源文件中，或是在链接器（或`ml64`/`cl`）命令行中包含库名称，取决于你自己。根据我的经验，大多数汇编语言程序员（尤其是在编写独立的汇编语言程序时）更喜欢使用`includelib`指令。
- en: 15.9 Object File and Library Impact on Program Size
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9 目标文件和库对程序大小的影响
- en: The basic unit of linkage in a program is the object file. When combining object
    files to form an executable, the Microsoft linker will take all of the data from
    a single object file and merge it into the final executable. This is true even
    if the main program doesn’t call all the functions (directly or indirectly) in
    the object module or use all the data in that object file. So, if you put 100
    routines in a single assembly language source file and compile them into an object
    module, the linker will include the code for all 100 routines in your final executable
    even if you use only one of them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的基本链接单元是目标文件。在将目标文件组合成可执行文件时，Microsoft链接器将把单个目标文件中的所有数据合并到最终的可执行文件中。即使主程序没有直接或间接调用该目标模块中的所有函数，或没有使用该目标文件中的所有数据，这也是成立的。所以，如果你将100个例程放入一个单独的汇编语言源文件并将它们编译成一个目标模块，链接器会将这100个例程的代码全部包含到你的最终可执行文件中，即使你只使用其中的一个例程。
- en: If you want to avoid this situation, you should break those 100 routines into
    100 separate object modules and combine the resulting 100 object files into a
    single library. When the Microsoft linker processes that library file, it will
    pick out the single object file containing the function the program uses and incorporate
    only that object file into the final executable. Generally, this is far more efficient
    than linking in a single object file with 100 functions buried in it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免这种情况，你应该将这100个例程拆分成100个独立的目标模块，并将这100个目标文件组合成一个单一的库。当微软的链接器处理这个库文件时，它将选择包含程序使用的函数的单个目标文件，并仅将该目标文件合并到最终的可执行文件中。*通常*，这种方式比将一个包含100个函数的目标文件链接进来更高效。
- en: The key word in that last sentence is *generally*. In fact, there are some good
    reasons for combining multiple functions into a single object file. First of all,
    consider what happens when the linker merges an object file into an executable.
    To ensure proper alignment, whenever the linker takes a section or segment (for
    example, the `.code` section) from an object file, it adds sufficient padding
    so that the data in that section is aligned on that section’s specified alignment
    boundary. Most sections have a default 16-byte section alignment, so the linker
    will align each section from the object file it links in on a 16-byte boundary.
    Normally, this isn’t too bad, especially if your procedures are large. However,
    suppose those 100 procedures you’ve created are all really short (a few bytes
    each). Then you wind up wasting a lot of space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上一句话中的关键词是*通常*。事实上，将多个函数合并成一个目标文件是有一些合理原因的。首先，考虑当链接器将目标文件合并到可执行文件中时会发生什么。为了确保正确的对齐，每当链接器从目标文件中获取一个部分或段（例如，`.code`段）时，它会添加足够的填充，以确保该段中的数据对齐到指定的对齐边界。大多数段的默认对齐为16字节，因此链接器会将它链接的每个目标文件中的段对齐到16字节边界。通常，这并不算太糟糕，特别是当你的过程较大时。然而，假设你创建的这100个过程都是非常短小的（每个只有几字节）。那么你就会浪费很多空间。
- en: Granted, on modern machines, a few hundred bytes of wasted space won’t amount
    to much. However, it might be more practical to combine several of these procedures
    into a single object module (even if you don’t call them all) to fill in some
    of the wasted space. Don’t go overboard, though; once you’ve gone beyond the alignment,
    whether you’re wasting space because of padding or wasting space because you’re
    including code that never gets called, you’re still wasting space.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现代计算机上，几百字节的浪费空间并不会造成太大影响。然而，结合这些过程中的几个到一个单独的目标模块（即使你并不调用所有的）来填补一些浪费的空间可能更为实际。不过，不要过度操作；一旦你超出了对齐边界，不管是因为填充浪费了空间，还是因为你包含了从未被调用的代码，最终你还是在浪费空间。
- en: 15.10 For More Information
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10 更多信息
- en: Although it is an older book, covering MASM version 6, *The Waite Group’s Microsoft
    Macro Assembler Bible* by Nabajyoti Barkakati and this author (Sams, 1992) goes
    into much greater detail about MASM’s external directives (`extern`, `externdef`,
    and `public`) and include files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一本较旧的书，涵盖的是MASM 6版本，*《Waite Group的微软宏汇编语言宝典》* 由纳巴乔提·巴尔卡提和本书作者编写（Sams，1992年），它详细讨论了MASM的外部指令（`extern`，`externdef`，和`public`）和包含文件。
- en: You can also find the MASM 6 manual (the last published edition) online.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上找到MASM 6手册（最后发布的版本）。
- en: 'For more information about makefiles, check out these resources:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于makefile的信息，请参考以下资源：
- en: 'Wikipedia: [https://en.wikipedia.org/wiki/Make_(software)](https://en.wikipedia.org/wiki/Make_(software))'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科：[https://en.wikipedia.org/wiki/Make_(software)](https://en.wikipedia.org/wiki/Make_(software))
- en: '*Managing Projects with GNU Make*, Third Edition, by Robert Mecklenburg (O’Reilly
    Media, 2004)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用GNU Make管理项目*，第三版，作者：罗伯特·梅克伦堡（O''Reilly Media，2004年）'
- en: '*The GNU Make Book* by John Graham-Cumming (No Starch Press, 2015)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《GNU Make书》* 由约翰·格雷厄姆-卡明（No Starch Press，2015年）'
- en: 15.11 Test Yourself
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.11 测试自己
- en: What statement(s) would you use to prevent recursive include files?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么语句来防止递归包含文件？
- en: What is an assembly unit?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是汇编单元？
- en: What directive would you use to tell MASM that a symbol is global and visible
    outside the current source file?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么指令来告诉MASM一个符号是全局的，并且在当前源文件外可见？
- en: What directive(s) would you use to tell MASM to use a global symbol from another
    object module?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么指令来告诉MASM使用另一个目标模块中的全局符号？
- en: Which directive prevents duplicate symbol errors when an external symbol is
    defined within an assembly source file?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个指令可以防止在汇编源文件中定义外部符号时出现重复符号错误？
- en: What external data type declaration would you use to access an external constant
    symbol?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么外部数据类型声明来访问外部常量符号？
- en: What external data type declaration would you use to access an external procedure?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么外部数据类型声明来访问外部过程？
- en: What is the name of Microsoft’s make program?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软的 make 程序叫什么名字？
- en: What is the basic makefile syntax?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本的 makefile 语法是什么？
- en: What is a makefile-dependent file?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 makefile 依赖的文件？
- en: What does a makefile `clean` command typically do?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: makefile 中的 `clean` 命令通常做什么？
- en: What is a library file?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是库文件？
