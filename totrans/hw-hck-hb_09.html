<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="265" id="Page_265"/>9</span><br/>
<span class="ChapterTitle">Bench Time: Simple Power Analysis</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll introduce a simple laboratory environment that allows you to experiment with some code samples. Rather than attack devices we know nothing about, we’ll start attacking real devices we have on hand in our lab with specific algorithms of our choosing. This practice will allow us to gain experience on these kinds of attacks rather than having to do a lot of guessing of what a “closed” device is up to. First, we’ll walk through the generics of building the simple power analysis (SPA) setup, and then we’ll program an Arduino with an SPA-vulnerable password verification and see whether we can extract the password. Finally, we’ll perform the same experiment with the ChipWhisperer-Nano. Consider this chapter to be like cracking your knuckles to warm up before actually playing the piano.</p>
<h2 id="h1-278748c09-0001"><span epub:type="pagebreak" title="266" id="Page_266"/>The Home Lab</h2>
<p class="BodyFirst">To build a simple SPA lab, you need a tool to measure power traces, a target device on a power-measurement-enabled circuit board, and a computer that instructs the target to perform an operation while recording the device’s power traces and input/output.</p>
<h3 id="h2-278748c09-0001">Building a Basic Hardware Setup</h3>
<p class="BodyFirst">Your lab doesn’t need to be expensive or complicated, as <a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a> shows.</p>
<figure>
<img src="image_fi/278748c09/f09001.png" alt="f09001"/>
<figcaption><p><a id="figure9-1">Figure 9-1</a>: A homemade experimental platform</p></figcaption>
</figure>
<p>This simple home-built lab consists of a USB-connected oscilloscope <span class="CodeAnnotation" aria-label="annotation1">1</span>, a target device on a breadboard with some electronics enabling measurement <span class="CodeAnnotation" aria-label="annotation2">2</span>, and a standard computer with a USB-serial adapter <span class="CodeAnnotation" aria-label="annotation3">3</span>. The ATmega328P microcontroller, as used in an Arduino, is mounted on a special board with a current measurement resistor.</p>
<h4 id="h3-278748c09-0001">Basic Oscilloscopes</h4>
<p class="BodyFirst">When using a regular oscilloscope, the most important requirement is that it’s capable of sampling at 100 MS/s (mega-samples per second) or higher on two channels. Many oscilloscopes specify a maximum sample rate that you can get only on a single channel. If you use two channels, the sample rate on each channel is half of that maximum, which means a 100 MS/s scope can sample only at 50 MS/s if you want to measure two inputs at once. For these experiments, we’ll use the second channel as a trigger only. Your scope may have an external trigger (which still allows you to get the maximum sample rate from one channel), but if not, be sure you can <span epub:type="pagebreak" title="267" id="Page_267"/>sample on two channels simultaneously at 100 MS/s or better. Attacking more advanced implementations, such as hardware AES, will require much faster sampling rates—sometimes 1 GS/s or higher.</p>
<p>Very low-cost generic oscilloscopes may not have a useful computer interface. For example, you will find USB-connected oscilloscopes that lack an API to allow you to interface with the device. When purchasing an oscilloscope for side-channel analysis, make sure you can control the device from your computer and that you can quickly download data from the oscilloscope.</p>
<p>Also, pay attention to the sample size buffer. Low-cost devices have a small buffer of, say, only 15,000 samples, which will make your work much more difficult. This is because you’ll need to trigger the capture at the exact moment of the sensitive operation; otherwise, you’ll overflow the oscilloscope’s memory buffer. You’ll also be unable to perform certain work, such as simple power analysis on longer public-key algorithms that would require a much larger buffer.</p>
<p>Special-purpose sampling devices that allow synchronous sampling can reduce your sample rate requirements by keeping a relationship between the device clock and your sample clock (like the ChipWhisperer does). See <span class="xref" itemid="xref_target_Appendix A">Appendix A</span> for more information on oscilloscopes.</p>
<h4 id="h3-278748c09-0002">Choosing a Microcontroller</h4>
<p class="BodyFirst">Select a microcontroller that you can program directly and that isn’t running any operating system. The Arduino is a perfect choice. Don’t begin your side-channel career by attempting to use a target such as a Raspberry Pi or BeagleBone. Those products have too many complicating factors, such as the difficulty of getting a reliable trigger, high clock speeds, and their operating systems. We’re building a skill, so let’s start in easy mode.</p>
<h4 id="h3-278748c09-0003">Building a Target Board</h4>
<p class="BodyFirst">The first thing we need to build is a microcontroller target board that has a shunt resistor inserted into the power line. <em>Shunt resistor</em> is a generic term we give to a resistor that we insert into a circuit’s path to measure current. Current flow through that resistor will cause a voltage to be developed across it, and we can measure that voltage using an oscilloscope.</p>
<p><a href="#figure9-1">Figure 9-1</a> shows an example of a test target. <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a> details the insertion of a shunt resistor, where the low side of the shunt resistor goes to the oscilloscope channel. Ohm’s law tells us that a voltage “developed” across a resistor is equal to the resistance multiplied by the current (<em>V</em> = <em>I </em>× <em>R</em>). The voltage polarity will be such that a lower voltage is present on the low side. If the high side was 3.3 V, and the low side was 2.8 V, this means that 0.5 V (3.3 – 2.8) was developed across the resistor.</p>
<span epub:type="pagebreak" title="268" id="Page_268"/><figure>
<img src="image_fi/278748c09/f09002.png" alt="f09002"/>
<figcaption><p><a id="figure9-2">Figure 9-2</a>: A shunt resistor makes it easy to measure power consumption.</p></figcaption>
</figure>
<p>If we wanted to measure only the voltage across the shunt resistor, we could use an instrument called a <em>differential probe</em>. With a differential probe, we’ll get only the exact voltage across the shunt resistor itself, which should provide the most accurate measurement.</p>
<p>An easier method that doesn’t require additional gear (and how we’ll work in this lab) is to assume the high side of the shunt resistor is connected to a clean and constant voltage power supply, which means any noise on the high side of the shunt resistor will add to measurement noise on the low side. We’ll measure power consumption across this shunt resistor simply by measuring the voltage on the low side, which will be the value of our constant “high side” voltage minus the drop on the shunt resistor. As the current increases in the shunt, the voltage drop across the shunt increases as well, and thus the “low side” voltage becomes smaller.</p>
<p>The resistance value you’ll need for your shunt resistor depends on the current power consumption of your target device. Using Ohm’s law, <em>V</em> = <em>I </em>× <em>R</em>, you can calculate reasonable resistance values. Most oscilloscopes have good voltage resolution of 50 mV to 5 V. The current (<em>I</em>) is determined by the device, but it will range from dozens of mA for microcontrollers to several A for large System-on-Chips (SoCs). For example, if your target is a small microcontroller at 50 mA, you should be able to use a resistance of 10 Ω to 50 Ω, but a field-programmable gate array (FPGA) with 5 A consumption might require 0.05 Ω to 0.5 Ω. Higher value resistors produce a larger voltage drop that provides a strong signal for your oscilloscope, but that may reduce the device voltage to such a low point that it stops operating.</p>
<p><a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a> shows a schematic of the target board <span class="CodeAnnotation" aria-label="annotation2">2</span> from <a href="#figure9-1">Figure 9-1</a>.</p>
<span epub:type="pagebreak" title="269" id="Page_269"/><figure>
<img src="image_fi/278748c09/f09003.png" alt="f09003"/>
<figcaption><p><a id="figure9-3">Figure 9-3</a>: A schematic of the target board</p></figcaption>
</figure>
<p>The ATmega328P microcontroller runs the target code, a resistor (R2) allows us to take power measurements, and noise filtering of the input voltage source is done with C1, C2, C3, and R1. An external USB-TTL serial adapter is connected to the RX and TX line. Note that the digital power supply has <em>no</em> decoupling capacitors; they would filter out details of the power consumption that contain potentially interesting information. You can easily modify this circuit to use other microcontrollers if you prefer.</p>
<p>You’ll need to be able to program the microcontroller with your target code, which might mean moving the physical chip between the target breadboard and the Arduino. An Arduino Uno uses the same ATmega328P microcontroller we mentioned before, so whenever we say “Arduino,” we just mean a board that can be used to program the microcontroller.</p>
<h3 id="h2-278748c09-0002">Buying a Setup</h3>
<p class="BodyFirst">If you’d rather not build your own lab for side-channel analysis, you can purchase one. The ChipWhisperer-Nano (shown in <a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a>) or the ChipWhisperer-Lite (shown in <a href="#figure9-5" id="figureanchor9-5">Figure 9-5</a>) replaces all the hardware shown in <a href="#figure9-1">Figure 9-1</a> for about US$50 or US$250, respectively.</p>
<span epub:type="pagebreak" title="270" id="Page_270"/><figure>
<img src="image_fi/278748c09/f09004.png" alt="f09004"/>
<figcaption><p><a id="figure9-4">Figure 9-4</a>: The ChipWhisperer-Nano</p></figcaption>
</figure>
<p>The ChipWhisperer-Nano is a device that allows you to program the included STM32F0 with various algorithms and perform power analysis. You can break off the included target to look at other devices. The glitching functionality is very limited compared to the ChipWhisperer-Lite.</p>
<figure>
<img src="image_fi/278748c09/f09005.png" alt="f09005"/>
<figcaption><p><a id="figure9-5">Figure 9-5</a>: The ChipWhisperer-Lite</p></figcaption>
</figure>
<p>The ChipWhisperer-Lite provides capture hardware along with a sample target board. The included target is available as either an Atmel XMEGA or STM32F303 ARM. Beyond side-channel analysis, this device also allows you to perform experiments of clock and voltage glitching. Again, you can break off the included target to look at more advanced devices. These devices include both the target and the capture hardware all on one board. The ChipWhisperer-Lite is an open source design, so you can also build it yourself. Alternatively, commercial tools like Riscure’s <span epub:type="pagebreak" title="271" id="Page_271"/>Inspector or CRI’s DPA Workstation are available; they’re developed for higher complexity and higher security targets but are outside the average hardware hacker’s budget.</p>
<h3 id="h2-278748c09-0003">Preparing the Target Code</h3>
<p class="BodyFirst">We’ll assume an Arduino as the target for now and afterward demonstrate the same attack on a ChipWhisperer-Nano. Regardless of your choice of hardware, you’ll need to program the microcontroller to perform the encryption or password check algorithm.</p>
<p><a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> shows an example of the firmware code you need to program into your target.</p>
<pre><code>// Trigger is Pin 2
int triggerPin = 2;

String known_passwordstr = String("ilovecheese");
String input_passwordstr;
char input_password[20];
char tempchr;
int index;

// the setup routine runs once when you press reset:
void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
  pinMode(triggerPin, OUTPUT);
  tempchr = '0';
  index = 0;
}

// the loop routine runs over and over again forever:
void loop() {
  //Wait a little bit after startup &amp; clear everything
  digitalWrite(triggerPin, LOW);
  delay(250);
  Serial.flush();
  Serial.write("Enter Password:");

  // wait for last character
  while ((tempchr != '\n') &amp;&amp; (index &lt; 19)){
    if(Serial.available() &gt; 0){
      tempchr = Serial.read();
      input_password[index++] = tempchr;
    }
  }

  // Null terminate and strip non-characters
  input_password[index] = '\0';
  input_passwordstr = String(input_password);
  input_passwordstr.trim();
  index = 0;
  tempchr = 0;

<span epub:type="pagebreak" title="272" id="Page_272"/><span class="CodeAnnotationCode" aria-label="annotation1">1</span> digitalWrite(triggerPin, HIGH); 

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> if(input_passwordstr == known_passwordstr){ 
    Serial.write("Password OK\n");
  } else {
    //Delay up to 500ms randomly
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> delay(random(500)); 
    Serial.write("Password Bad\n");
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: Sample microcontroller firmware using Arduino for performing a simple operation with a trigger</p>
<p>The target first reads in a password from the user. Then the target compares that password with the stored password <span class="CodeAnnotation" aria-label="annotation2">2</span> (in this case, the hardcoded password is <code>ilovecheese</code>). A specific I/O line is set high during the password comparison operation, allowing you to trigger your oscilloscope into measuring the signal during this operation <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>This firmware has a trick up its sleeve. Even though it uses a leaky string comparison <span class="CodeAnnotation" aria-label="annotation2">2</span> (like in our introduction on timing attacks in Listing 8-1), it makes timing attacks difficult by doing a random wait of up to 500ms at the end of the operation <span class="CodeAnnotation" aria-label="annotation3">3</span>, making it ripe for an SPA attack.</p>
<h3 id="h2-278748c09-0004">Building the Setup</h3>
<p class="BodyFirst">On the computer side, your work will involve the following:</p>
<ul>
<li>Communicating with the target device (sending commands and data and receiving a response)</li>
<li>Setting up the oscilloscope as appropriate (channels, triggers, and scales)</li>
<li>Downloading data from the oscilloscope to the computer</li>
<li>Storing the power trace and data sent to the device in a database or file</li>
</ul>
<p>We’ll look at the requirements for each of these steps in the next few sections. The end objective is to measure the power consumption of a microcontroller while executing a simple program, as shown in <a href="#listing9-1">Listing 9-1</a>.</p>
<h4 id="h3-278748c09-0004">Communicating with the Target Device</h4>
<p class="BodyFirst">Since you’re targeting a device that you program yourself, you can define your own communications protocol. In <a href="#listing9-1">Listing 9-1</a>, it’s simply a serial interface that reads a password. For simplicity, the “correct” password is hardcoded in the program, but in general, it’s good to allow configuration of the “sensitive information” (such as the password). This practice allows you to experiment more easily (for example, with a longer and shorter password). When you start targeting crypto, this practice also holds: configuration of the key material from the computer enables experimentation.</p>
<p><span epub:type="pagebreak" title="273" id="Page_273"/>The other part of communication is triggering the oscilloscope. While the target device is running the task with the “sensitive operation,” you need to monitor the device’s power consumption. <a href="#listing9-1">Listing 9-1</a> shows triggering, where we put a trigger line high right before the comparison occurs and pull it back low after the comparison.</p>
<h4 id="h3-278748c09-0005">The Shunt Resistor</h4>
<p class="BodyFirst">The shunt resistor’s output signal is fairly strong, and it should be able to drive your oscilloscope directly. Connect the signal directly to your oscilloscope using the BNC connector input, rather than feed it through the probes, which might introduce noise through the ground connection. Also, if your oscilloscope has only fixed 10:1 probes, you’ll be reducing the peak-to-peak voltage. After doing this, your scope can measure the voltage differentials caused by varying power consumption of the target.</p>
<h4 id="h3-278748c09-0006">Oscilloscope Settings</h4>
<p class="BodyFirst">You’ll need to get a few settings on your scope in the right ballpark: the voltage range, coupling, and sampling rate. This is “Oscilloscope 101,” so we’ll give only a few brief tips on specifics when doing side-channel captures. More details on using scopes can be found in the section “Digital Oscilloscope” in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. If you need to purchase an oscilloscope, see the section “Viewing Analog Waveforms (Oscilloscopes)” in <span class="xref" itemid="xref_target_Appendix A">Appendix A</span>.</p>
<p>The <em>voltage range</em> should be selected high enough such that the captured signal doesn’t clip. For instance, when you have a 1.3 V signal but your range is set to 1.0 V, you’ll lose all information above 1.0 V. On the other hand, it needs to be selected low enough so as not to cause quantization errors. This means if your range is set to 5 V, but you have a 1.3 V signal, you’ve wasted 3.7 V of range. If your scope gives you a choice between 1 V and 2 V, for the 1.3 V signal, you’d pick 2 V.</p>
<p>Your scope’s <em>input coupling </em>mode isn’t typically too critical. Unless you have a good reason not to, just use AC-coupled mode, as it centers the signal around the 0 V level. You can use DC-coupled mode and adjust the offset as well to achieve the same results. The advantage of AC-coupled mode is that it eliminates any gradual shift in voltage or very low-frequency noise that might complicate measurements if, for example, the output of your voltage regulator drifts as the system warms up. It will also compensate for the DC offset introduced if you are using a shunt on the VCC side, as we showed in <a href="#figure9-2">Figure 9-2</a>. DC offsets do not typically carry side-channel information.</p>
<p>For the <em>sampling rate</em>, the trade-off is increased processing time but better capture quality at a higher rate versus faster processing but at a lower quality at a lower rate. When getting started, use the rule of thumb that you sample at one to five times your target’s clock speed.</p>
<p>Your scope might have other useful features too, such as a 20 MHz <em>bandwidth limit</em> that can reduce high-frequency noise. You can also introduce analog lowpass filters with the same effect. If you were attacking <span epub:type="pagebreak" title="274" id="Page_274"/>lower-frequency devices, this reduction in high-frequency noise would prove useful, but if you were attacking a very fast device, you might require data from the higher-frequency components. A good practice is to put a bandwidth limiter at about five times your sampling rate. For example, a 5 MHz target can be sampled at 10 MS/s and bandwidth limited at 50 MHz.</p>
<p>Be sure to experiment to determine the best measurement setup for any given device and algorithm. It’s a good learning experience and will teach you how settings affect quality and acquisition speed.</p>
<h4 id="h3-278748c09-0007">Communicating with the Scope</h4>
<p class="BodyFirst">To actually perform the attack, you’ll need some way to download trace data to the computer. For simple power analysis attacks, you might be able to do it by inspecting the oscilloscope display visually. Any of the more advanced attacks will require you to download data from the oscilloscope to the computer.</p>
<p>The method of communicating with your oscilloscope will depend almost entirely on the oscilloscope’s vendor. Some vendors have their own library with language bindings to use that library in languages such as C and Python. Many other vendors rely instead on the <em>Virtual Instrument Software Architecture (VISA)</em>, an industry standard for communications between test equipment. If your scope supports VISA, you should be able to find high-level libraries in almost all languages to help you interface with it, such as PyVISA for Python. You’ll need to implement specific commands or options for your oscilloscope, but the vendor should provide some instruction.</p>
<h4 id="h3-278748c09-0008">Data Storage</h4>
<p class="BodyFirst">How you store your traces depends almost entirely on your planned analysis platform. If you’re planning on doing the analysis entirely in Python, you might look for the storage format that works with the popular NumPy library. If using MATLAB, you would take advantage of the native MATLAB file format. If you plan on experimenting with distributed computing, you’ll need to investigate the preferred filesystem for your cluster.</p>
<p>When working with really large trace sets, the storage format will matter, and you’ll want to optimize it for fast linear access. In professional labs, sets of 1TB are no exception. On the other hand, for your initial work and investigation, your data storage requirements should be fairly small. Attacking a software implementation on an 8-bit microcontroller may take only 10 or 20 power measurements, so almost anything better than copy/pasting the data out of a spreadsheet will work!</p>
<h2 id="h1-278748c09-0002"><span epub:type="pagebreak" title="275" id="Page_275"/>Pulling It Together: An SPA Attack</h2>
<p class="BodyFirst">With our fresh setup, let’s perform the actual SPA attack, working with the code from <a href="#listing9-1">Listing 9-1</a>. As mentioned previously, this code has a leaky password comparison. The random wait at the end of the code hides the timing leak, so it’s not directly exploitable through timing. We’ll have to look closer, using SPA on traces, to see whether we can identify the individual character comparisons. If the traces give away which character is incorrect, we can do a very limited brute-force attack to recover the password, exactly like we did in the pure timing attacks in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.</p>
<p>First, we’ll need to do a bit of additional preparation on our Arduino. Then, we’ll measure power traces when we provide correct, partially correct, and incorrect passwords. If these traces reveal the index of the first wrong character, we can brute-force the rest to recover the correct password.</p>
<h3 id="h2-278748c09-0005">Preparing the Target</h3>
<p class="BodyFirst">To demonstrate a no-soldering approach to capturing traces, we need to extend the setup shown in <a href="#figure9-1">Figure 9-1</a>. We basically take an Arduino Uno and simply move the ATmega328P microcontroller onto a breadboard (see <a href="#figure9-6" id="figureanchor9-6">Figure 9-6</a>). As mentioned earlier, we need the current shunt in the VCC pin, which is why we can’t just use a regular Arduino board (at least without doing some soldering).</p>
<figure>
<img src="image_fi/278748c09/f09006.png" alt="f09006"/>
<figcaption><p><a id="figure9-6">Figure 9-6</a>: The humble Arduino used as a side-channel analysis attack target</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="276" id="Page_276"/><a href="#figure9-7" id="figureanchor9-7">Figure 9-7</a> shows details of the required wiring for the Arduino Uno.</p>
<figure>
<img src="image_fi/278748c09/f09007.png" alt="f09007"/>
<figcaption><p><a id="figure9-7">Figure 9-7</a>: Details of the required wiring for the Arduino Uno (this image was created with Fritzing).</p></figcaption>
</figure>
<p>Pins 9 and 10 are wired from the empty integrated circuit (IC) socket, where the microcontroller used to be, onto the breadboard. These jumper wires bring the crystal frequency from the board as needed by the microcontroller IC. The wires should be as short as possible. It’s not a great idea to wire these sensitive lines outside the board like we’ve done, but in practice, it tends to work. If you have trouble getting the system operating, it might be that these lines are too long.</p>
<p>The value of resistors and capacitors is not critical. The resistors here are 100 Ω, but anything from 22–100 Ω should work. Capacitors in the range of 100μF to 330μF will work. (The schematic in <a href="#figure9-3">Figure 9-3</a> shows some details. Note that Y1, C5, and C6 shown in <a href="#figure9-3">Figure 9-3</a> are not required here as those parts are on the Arduino baseboard instead.)</p>
<p>Now that the Arduino has been modded for power measurements, we program the code from <a href="#listing9-1">Listing 9-1</a>. After connecting with a serial terminal, you should have a prompt where you can enter your password (see <a href="#figure9-8" id="figureanchor9-8">Figure 9-8</a>).</p>
<p>Be sure to test that the code behaves correctly for both a valid and an invalid password. You can do so by typing in a password manually or making a test program that communicates with the target code directly. At this point, you are ready for an attack!</p>
<span epub:type="pagebreak" title="277" id="Page_277"/><figure>
<img src="image_fi/278748c09/f09008.png" alt="f09008"/>
<figcaption><p><a id="figure9-8">Figure 9-8</a>: Serial output from the programmed Arduino</p></figcaption>
</figure>
<h3 id="h2-278748c09-0006">Preparing the Oscilloscope</h3>
<p class="BodyFirst">Set your oscilloscope to trigger on the digital I/O line in use. We use “Digital IO 2,” which is pin 4 on the ATmega328P chip. The code on the target pulls the line high just before the sensitive operation (in this case, the password comparison).</p>
<p>First, experiment by sending the same password repeatedly. You should get very similar looking traces. If not, go debug your setup. Your trigger may not be caught by the oscilloscope, or maybe your test program isn’t running correctly. The trace captures left of the dotted line in the upcoming <a href="#figure9-9" id="figureanchor9-9">Figure 9-9</a> provide an idea of how similar the traces should look.</p>
<p>Once you’re convinced that the measurement setup is working, experiment with various oscilloscope settings, heeding our advice from the previous section. An Arduino Uno runs at 16 MHz, so set your oscilloscope to anything between 20 MS/s and 100 MS/s. Tune your scope range to fit the signal snugly without clipping.</p>
<p>For ease of build, we’ve used oscilloscope probes. As mentioned earlier, this will produce some signal loss compared to feeding a BNC-connected wire into the scope directly. On this target, there’s plenty of signal, so it’s not a big deal.</p>
<p>If you have oscilloscope probes that are switchable between 10× and 1×, you may find they work much better in the 1× position. The 1× position provides less noise, but with a greatly reduced bandwidth. For this specific case, the lower bandwidth is actually helpful, so we prefer to use the 1× setting. If your oscilloscope has a bandwidth limit (many have a 20 MHz bandwidth limit option), enable it to see whether the signal becomes clearer. If you are looking at picking up an oscilloscope for this, we’ll cover what sort of options you might need in <span class="xref" itemid="xref_target_Appendix A">Appendix A</span>.</p>
<h3 id="h2-278748c09-0007"><span epub:type="pagebreak" title="278" id="Page_278"/>Analysis of the Signal</h3>
<p class="BodyFirst">Now you can start to experiment with different passwords; you should see a noticeable difference when sending the correct and incorrect passwords. <a href="#figure9-9">Figure 9-9</a> shows an example of the power measurement recorded with different passwords when running: the power traces for the correct password (top, <code>ilovecheese</code>), a fully incorrect password (bottom, <code>test</code>), and a partially correct password (middle, <code>iloveaaaaaa</code>).</p>
<figure>
<img src="image_fi/278748c09/f09009.png" alt="f09009"/>
<figcaption><p><a id="figure9-9">Figure 9-9</a>: Power traces are shown for correct, partially correct, and incorrect passwords; arrows indicate character-comparison operation. The black signal overlaying each trace is the trigger signal.</p></figcaption>
</figure>
<p>A clear difference is visible between the top two traces and the bottom trace. The string comparison function more quickly detects if the number of characters differs—the bottom trace shows a shorter trigger signal. The more interesting area is where the same number of characters is compared but with incorrect values, as shown in the top and middle traces. For those traces, the power signature is the same up until the dashed line, after which <span epub:type="pagebreak" title="279" id="Page_279"/>the character comparisons start. By carefully inspecting the correct password, you can see about 11 repeated segments, indicated by the arrows, which perfectly match the 11 characters of <code>ilovecheese</code>.</p>
<p>Now by looking at the <code>iloveaaaaaa</code> password trace in the middle, you can see only five such segments. Each “segment” means a single iteration through some comparison loop, so the number of these segments corresponds to the length of the correct password prefix. As with the timing attack in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, that means we only must guess each possible input character, one at a time, and that means we can guess the password very quickly (assuming we write a script to do this).</p>
<h3 id="h2-278748c09-0008">Scripting the Communication and Analysis</h3>
<p class="BodyFirst">You’ll want to have interfaced both the oscilloscope and target to some programming environment for this section. This interface will allow you to write a script to send arbitrary passwords while noting the power measurement. We will use this script to determine how many initial characters were accepted.</p>
<p>The specifics of this script will depend a lot on what system you’re using to download data from an oscilloscope. <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a> shows a script that works with a PicoScope USB device and the Arduino password-checking code. You’ll need to tweak the settings for your specific target; it’s not just a copy-paste-run task.</p>
<pre><code>#Simple Arduino password SPA/timing characterization
import numpy as np
import pylab as plt
import serial
import time
#picoscope module from https://github.com/colinoflynn/pico-python
from picoscope import ps2000

#Adjust serial port as needed
try:
    ser = serial.Serial(
    port='com42',
    baudrate=9600,
    timeout=0.500
    )

    ps = ps2000.PS2000()

    print("Found the following picoscope:")
    print(ps.getAllUnitInfo())

    #Need at least 13us from trigger
    obs_duration = 13E-6

    #Sample at least 4096 points within that window
    sampling_interval = obs_duration / 4096

    #Configure timebase
<span epub:type="pagebreak" title="280" id="Page_280"/>    (actualSamplingInterval, nSamples, maxSamples) = \
        ps.setSamplingInterval(sampling_interval, obs_duration)

    print("Sampling interval = %f us" % (actualSamplingInterval *
                                         nSamples * 1E6))
    #Channel A is trigger
    ps.setChannel('A', 'DC', 10.0, 0.0, enabled=True)
    ps.setSimpleTrigger('A', 1.0, 'Rising', timeout_ms=2000, enabled=True)

    #50mV range on channel B, AC coupled, 20MHz BW limit
    ps.setChannel('B', 'AC', 0.05, 0.0, enabled=True, BWLimited=True)

    #Passwords to check
    test_list = ["ilovecheese", "iloveaaaaaa"]
    data_list = []

    #Clear system
    ser.write((test_list[0] + "\n").encode("utf-8"))
    ser.read(128)

    for pw_test in test_list:
        #Run capture
        ps.runBlock()
        time.sleep(0.05)
        ser.write((pw_test + "\n").encode("utf-8"))
        ps.waitReady()
        print('Sent "%s" - received "%s"' %(pw_test, ser.read(128)))
        data = ps.getDataV('B', nSamples, returnOverflow=False)
        #Normalize data by std-dev and mean
        data = (data - np.mean(data)) / np.std(data)
        data_list.append(data)

    #Plot password tests
    x = range(0, nSamples)
    pltstyles = ['-', '--', '-.']
    pltcolor = ['0.5', '0.1', 'r']
    plt.figure().gca().set_xticks(range(0, nSamples, 25))
    for i in range(0, len(data_list)):
        plt.plot(x, data_list[i], pltstyles[i], c=pltcolor[i], label= \        test_list[i])
    plt.legend()
    plt.xlabel("Sample Number")
    plt.ylabel("Normalized Measurement")
    plt.title("Password Test Plot")
    plt.grid()
    plt.show()
finally:
    #Always close off things
    ser.close()
    ps.stop()
    ps.close()</code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: A sample script to connect a computer to a PicoScope 2000 series along with its Arduino target</p>
<p><span epub:type="pagebreak" title="281" id="Page_281"/>The Python script in <a href="#listing9-2">Listing 9-2</a> will display a diagram like the one shown in <a href="#figure9-10" id="figureanchor9-10">Figure 9-10</a>. Note that the markers in this diagram were added with additional code not shown in <a href="#listing9-2">Listing 9-2</a>. If you want to see the exact marker generation code, look at the companion repository, which includes the code used to generate <a href="#figure9-10">Figure 9-10</a>.</p>
<figure>
<img src="image_fi/278748c09/f09010.png" alt="f09010"/>
<figcaption><p><a id="figure9-10">Figure 9-10</a>: Two power traces of two different password guesses (correct marked with circles; incorrect marked with squares)</p></figcaption>
</figure>
<p><a href="#figure9-10">Figure 9-10</a> is zoomed in compared to <a href="#figure9-9">Figure 9-9</a>, with the comparison starting at sample 148. The solid line is for the correct password; the partially correct password is shown with dashes. You can observe that every 25 samples, starting at sample number 148, a pattern is repeated—seemingly one pattern per comparison. The lines overlap for five of the comparisons. Notice at sample number 273 the correct password and partially correct password have diverged, which coincides with the idea that the first five characters (<code>ilove</code>) are the same between both password guesses. To emphasize this, we’ve marked the value of the correct password power trace with circles every 25 samples, and the value of the incorrect password power trace with squares every 25 samples. Notice the square and circle are close to each other for the first five marked locations, but on the sixth location, it is noticeably different.</p>
<p>In order to script this attack, we can compare the sample value of the power trace every 25 samples, starting at sample 148. Taking the markers from <a href="#figure9-10">Figure 9-10</a>, we can see that there is some threshold voltage around 1.2 V that could be used to separate the good and bad iterations.</p>
<p><span epub:type="pagebreak" title="282" id="Page_282"/>How did we know the comparison started at sample point 148? You can determine the start of the comparison by using the “fully incorrect” password, which should show divergence as soon as the comparison starts. To do this, you’ll have to add to the list of guessed passwords a third option that sends a fully incorrect password, such as <code>aaaaaaaaaaa</code>.</p>
<h3 id="h2-278748c09-0009">Scripting the Attack</h3>
<p class="BodyFirst">We’ve used the “squint at traces” technique to identify the segments, which is the usual starting point for SPA, but in order to script this, we need to be a bit more accurate. We need a <em>distinguisher</em> that tells a script whether there is a segment. With that in mind, we devised the following rule: a character comparison segment index <em>i</em> is detected as being successful if there is a peak <em>larger</em> than 1.2 V at sample 148 + 25<em>i</em>. You’ll notice in <a href="#figure9-10">Figure 9-10</a> the incorrect password diverged at sample 273, and at that time the incorrect password trace had a value of about 1.06 V. Note traces can be noisy and may require you to add filtering onto the signal or to check a few times to confirm your results match.</p>
<p>You also need to use a search on an area around the sample by ± 1 samples because the oscilloscope may have some jitter. A quick check in <a href="#figure9-10">Figure 9-10</a> shows that this should work. With that knowledge, we can build the Python script in <a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a>, which automatically guesses the correct password.</p>
<pre><code>#Simple Arduino password SPA/timing attack
import numpy as np
import pylab as plt
import serial
import time
#picoscope module from https://github.com/colinoflynn/pico-python
from picoscope import ps2000

#Adjust serial port as needed
try:
    ser = serial.Serial(
    port='com42',
    baudrate=9600,
    timeout=0.500
    )

    ps = ps2000.PS2000()

    print("Found the following picoscope:")
    print(ps.getAllUnitInfo())

    #Need at least 13us from trigger
    obs_duration = 13E-6

    #Sample at least 4096 points within that window
    sampling_interval = obs_duration / 4096

    #Configure timebase
    (actualSamplingInterval, nSamples, maxSamples) = \
        ps.setSamplingInterval(sampling_interval, obs_duration)

<span epub:type="pagebreak" title="283" id="Page_283"/>    #Channel A is trigger
    ps.setChannel('A', 'DC', 10.0, 0.0, enabled=True)
    ps.setSimpleTrigger('A', 1.0, 'Rising', timeout_ms=2000, enabled=True)

    #50mV range on channel B, AC coupled, 20MHz BW limit
    ps.setChannel('B', 'AC', 0.05, 0.0, enabled=True, BWLimited=True)

    guesspattern="abcdefghijklmnopqrstuvwxyz"
    current_pw = ""

    start_index = 148
    inc_index = 25

    #Currently uses fixed length of 11, could also use response
    for guesschar in range(0,11):
        for g in guesspattern:
            #Make guess, ensure minimum length too
            pw_test = current_pw + g
            pw_test = pw_test.ljust(11, 'a')

            #Run capture
            ps.runBlock()
            time.sleep(0.05)
            ser.write((pw_test + "\n").encode("utf-8"))
            ps.waitReady()
            response = ser.read(128).decode("utf-8").replace("\n","")
            print('Sent "%s" - received "%s"' %(pw_test, response))
            if "Password OK" in response:
                print("****FOUND PASSWORD = %s"%pw_test)
                raise Exception("password found")
            data = ps.getDataV('B', nSamples, returnOverflow=False)
            #Normalized by std-dev and mean
            data = (data - np.mean(data)) / np.std(data)

            #Location of check
            idx = (guesschar*inc_index) + start_index

            #Empirical threshold, check around location a bit
            if max(data[idx-1 : idx+2]) &gt; 1.2:
                print("***Character %d = %s"%(guesschar, g))
                current_pw = current_pw + g;
                break

            print

    print("Password = %s"%current_pw)

finally:
    #Always close off things
    ser.close()
    ps.stop()
    ps.close()</code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: A sample script to exploit the leakage discovered and guess a password</p>
<p><span epub:type="pagebreak" title="284" id="Page_284"/>This script implements the basic SPA attack: it captures a password check, uses the height of the peak at 148 + 25<em>i</em> to determine if character <em>i</em> is correct, and simply loops through all characters until the full password is found:</p>
<p><code>****FOUND PASSWORD = ilovecheese</code></p>
<p>This script is a bit slow to keep things simple. There are two areas for improvement. First, the timeout in the <code>serial.read()</code> function is set always to wait for 500ms. We could instead look for the newline (<code>\n</code>) and stop trying to read more data. Second, the password-checker firmware in the Arduino has a delay when a wrong password is entered. We could use an I/O line to reset the Arduino chip after every attempt to skip that delay. We’ll leave those improvements as an exercise for the reader.</p>
<p>When looking at your traces, you will need to very carefully scrutinize the power traces. Depending on where you position your distinguisher, you may need to flip the sign of the comparison for this example to work. There will be multiple locations showing the leakage, so minor adjustments in the code may change your results.</p>
<p>If you would like to see this example running on known hardware, the companion notebook (see <a href="https://nostarch.com/hardwarehacking/" class="LinkURL">https://nostarch.com/hardwarehacking/</a>) shows how to use a ChipWhisperer-Nano or ChipWhisperer-Lite to communicate with the Arduino target. In addition, the companion notebook includes “pre-recorded” power traces so you can run this example without hardware. However, we can make this attack more consistent by targeting one of the built-in targets instead of the Arduino you built, which we’ll look at next. In addition, we’ll work to make a more automated attack that doesn’t require us to manually determine the location and value of the distinguisher.</p>
<h2 id="h1-278748c09-0003">ChipWhisperer-Nano Example</h2>
<p class="BodyFirst">Now let’s examine a similar attack on the ChipWhisperer-Nano that includes the target, programmer, oscilloscope, and serial port all in one package, which means we can concentrate on the sample code and automate the attack. As in other chapters, you’ll use a companion notebook (<a href="https://nostarch.com/hardwarehacking/" class="LinkURL">https://nostarch.com/hardwarehacking/</a>); open that up if you have a ChipWhisperer-Nano.</p>
<h3 id="h2-278748c09-0010">Building and Loading Firmware</h3>
<p class="BodyFirst">First, you need to build the sample software (similar to <a href="#listing9-1">Listing 9-1</a>) for the STM32F0 microcontroller target. You don’t need to write your own code, as you’ll use the source code that’s part of the ChipWhisperer project. Building the firmware simply requires calling <code class="bold">make</code> from the notebook with the appropriate platform specified, as shown in <a href="#listing9-4" id="listinganchor9-4">Listing 9-4</a>.</p>
<pre><code>%%bash
<b>cd ../hardware/victims/firmware/basic-passwdcheck</b>
<b>make PLATFORM=CWNANO CRYPTO_TARGET=NONE</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: Building the <code>basic-passwdcheck</code> firmware, similar to <a href="#listing9-1">Listing 9-1</a></p>
<p><span epub:type="pagebreak" title="285" id="Page_285"/>You can then connect to the target and program the onboard STM32F0 with the notebook code in <a href="#listing9-5" id="listinganchor9-5">Listing 9-5</a>.</p>
<pre><code>SCOPETYPE = 'OPENADC'
PLATFORM = 'CWNANO'
%run "Helper_Scripts/Setup_Generic.ipynb"
fw_path = '../hardware/victims/firmware/basic-passwdcheck/basic-passwdcheck-CWNANO.hex'
cw.program_target(scope, prog, fw_path)</code></pre>
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: Initial setup and programming the included target with our custom firmware</p>
<p>This code creates some default settings for performing the power analysis and then programs the firmware hex file built in <a href="#listing9-4">Listing 9-4</a>.</p>
<h3 id="h2-278748c09-0011">A First Glance at the Communication</h3>
<p class="BodyFirst">Next, let’s look at what boot messages the device is printing on reset. The notebook environment has a function called <code>reset_target()</code> that toggles the <code>nRST</code> line to perform a target reset, after which we can record the serial data coming in. To do this, we’ll run the code from <a href="#listing9-6" id="listinganchor9-6">Listing 9-6</a>.</p>
<pre><code>ret = ""
target.flush()
reset_target(scope)
time.sleep(0.001)
num_char = target.in_waiting()
while num_char &gt; 0:
    ret += target.read(timeout=10)
    time.sleep(0.01)
    num_char = target.in_waiting()
print(ret)</code></pre>
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: Resetting the device and reading the boot messages</p>
<p>This reset results in the boot messages shown in <a href="#listing9-7" id="listinganchor9-7">Listing 9-7</a>.</p>
<pre><code>*****Safe-o-matic 3000 Booting...
Aligning bits........[DONE]
Checking Cesium RNG..[DONE]
Masquerading flash...[DONE]
Decrypting database..[DONE]

WARNING: UNAUTHORIZED ACCESS WILL BE PUNISHED
Please enter password to continue:</code></pre>
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: The boot messages from the demo password check code</p>
<p>Looks like some serious boot security . . . but perhaps we can use SPA to attack the password comparison. Let’s see what’s actually implemented.</p>
<h3 id="h2-278748c09-0012">Capturing a Trace</h3>
<p class="BodyFirst">Because the ChipWhisperer integrates everything into one platform, it’s much easier to build a function that performs a power capture on the <span epub:type="pagebreak" title="286" id="Page_286"/>password comparison. The code in <a href="#listing9-8" id="listinganchor9-8">Listing 9-8</a> defines a function that captures the power trace with a given test password. Most of this code is actually just waiting for the boot messages to end, after which the target is waiting for a password to be input.</p>
<pre><code>def cap_pass_trace(pass_guess):
    ret = ""
    reset_target(scope)
    time.sleep(0.01)
    num_char = target.in_waiting()
    #Wait for boot messages to finish so we are ready to enter password
    while num_char &gt; 0:
        ret += target.read(num_char, 10)
        time.sleep(0.01)
        num_char = target.in_waiting()

    scope.arm()
    target.write(pass_guess)
    ret = scope.capture()
    if ret:
        print('Timeout happened during acquisition')

    trace = scope.get_last_trace()
    return trace</code></pre>
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: Function to record the power trace of the target processing any arbitrary password</p>
<p>Next, we simply use <code>scope.arm()</code> to tell the ChipWhisperer to wait for the trigger event. We send the password to the target, at which point the target will perform the password check. Our cooperative target is telling ChipWhisperer the moment the comparison is starting through the trigger (in this case, a GPIO pin going high, which is the little bit of a cheat we added to the target firmware). Finally, we record the power trace and pass it back to the caller.</p>
<p>With that function defined, we could run <a href="#listing9-9" id="listinganchor9-9">Listing 9-9</a> to capture the trace.</p>
<pre><code>%matplotlib notebook
import matplotlib.pylab as plt
trace = cap_pass_trace("hunter2\n")
plt.plot(trace[0:800], 'g')</code></pre>
<p class="CodeListingCaption"><a id="listing9-9">Listing 9-9</a>: Capturing the trace for a particular password</p>
<p>That code should generate the power trace shown in <a href="#figure9-11" id="figureanchor9-11">Figure 9-11</a>.</p>
<span epub:type="pagebreak" title="287" id="Page_287"/><figure>
<img src="image_fi/278748c09/f09011.png" alt="f09011"/>
<figcaption><p><a id="figure9-11">Figure 9-11</a>: The power consumption of the device as it is processing a particular password</p></figcaption>
</figure>
<p>Now that we have the ability to take a power trace for a particular password, let’s see if we can turn it into an attack.</p>
<h3 id="h2-278748c09-0013">From Trace to Attack</h3>
<p class="BodyFirst">As before, the first step is simply sending several different passwords and seeing whether we notice a difference between them. The code in <a href="#listing9-10" id="listinganchor9-10">Listing 9-10</a> sends five different single-character passwords: <code>0</code>, <code>a</code>, <code>b</code>, <code>c</code>, or <code>h</code>. It then generates a plot of the power traces during processing of those passwords. (In this case, we’ve cheated, as we know the correct password starts with <code>h</code>, but we want to make the resulting figures reasonably visible. In reality, you may have to look at multiple figures to find the outlier—for example, by grouping initial characters <code>a</code>–<code>h</code>, <code>i</code>–<code>p</code>, <code>q</code>–<code>x</code>, and <code>y</code>–<code>z</code> into separate plots.)</p>
<pre><code>%matplotlib notebook
import matplotlib.pylab as plt
plt.figure(figsize=(10,4))
for guess in "0abch":
    trace = cap_pass_trace(guess + "\n")
    plt.plot(trace[0:100])
plt.show()</code></pre>
<p class="CodeListingCaption"><a id="listing9-10">Listing 9-10</a>: A simple test of five password first characters</p>
<p>The resulting traces are plotted in <a href="#figure9-12" id="figureanchor9-12">Figure 9-12</a>, which shows the first 100 samples of the power consumption as the device processes two of the five different password first characters. One of the characters is the correct start to the password. Around sample 18, the power consumption of different characters starts to deviate. This is due to the timing leak: if the loop exits early (because the first character is wrong), the resulting code execution follows a different path from when the first character is correct.</p>
<span epub:type="pagebreak" title="288" id="Page_288"/><figure>
<img src="image_fi/278748c09/f09012.png" alt="f09012"/>
<figcaption><p><a id="figure9-12">Figure 9-12</a>: Power consumption for five different initial characters</p></figcaption>
</figure>
<p>If we were to zoom in on <a href="#figure9-12">Figure 9-12</a> and plot all five power traces, we would see that four characters have pretty much the same power trace, and one is the clear outlier. We would guess that the outlier is the correct first character, as only one character can be correct. We then build up a guess using the correct first character and do the same analysis for the unknown second character.</p>
<h4 id="h3-278748c09-0009">Using SAD to Find the Password (and Become Happy)</h4>
<p class="BodyFirst">Rather than fine-tune the timing of particular peaks as we did earlier in this chapter, we could try to be a bit cleverer and possibly more generic. First, we could assume we know a password that will always fail the first character comparison. We’ll make an “invalid password template power trace” and compare each following trace to the template. In this case, we’ll use a single character set to hex 0x00 as an invalid password. If we see a major difference between the template and the power trace of the device processing a particular character, it suggests that that particular character is correct.</p>
<p>A simple method of comparing two arrays is a <em>sum of absolute difference (SAD)</em>. To calculate the SAD, we find the difference between each point in two traces, turn it into an absolute number, then sum up those points. The SAD is a measure of how alike two traces are, where 0 means they are exactly the same, and higher numbers mean traces are less alike (see <a href="#figure9-13" id="figureanchor9-13">Figure 9-13</a>).</p>
<p>If we don’t sum up the points and look only at the absolute difference, we can see some interesting patterns. In <a href="#figure9-13">Figure 9-13</a>, we’ve taken the invalid password trace and calculated the absolute difference with two traces. One trace was taken using a password with the wrong first character (such as <code>e</code>), shown as the bottom line with peak far above 0.1. The other trace was taken with a password with the correct first character (<code>h</code>), shown as the top noisy <span epub:type="pagebreak" title="289" id="Page_289"/>line that hovers just above 0. The difference at each point is much larger for the correct password. We can now sum up all those points, effectively calculating the SAD. We should get a large value for the incorrect character and a much smaller value for the correct character.</p>
<figure>
<img src="image_fi/278748c09/f09013.png" alt="f09013"/>
<figcaption><p><a id="figure9-13">Figure 9-13</a>: Absolute differences in traces for a correct (top) and incorrect (bottom) first password character</p></figcaption>
</figure>
<h4 id="h3-278748c09-0010">A Single-Character Attack</h4>
<p class="BodyFirst">Because we now have a “goodness” metric in the form of SAD, we can automate the attack for the first character. The code in <a href="#listing9-11" id="listinganchor9-11">Listing 9-11</a> shows a script that runs through a guess list (in this case, lowercase letters and numbers) and checks whether any of them results in an obviously different code path. If so, it flags that as a likely correct password character.</p>
<pre><code><span epub:type="pagebreak" title="290" id="Page_290"/>bad_trace = cap_pass_trace("\x00" + "\n")
for guess in "abcdefghijklmnopqrstuvwxyz0123456789":
    diff = cap_pass_trace(guess + "\n") - bad_trace
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> #print(sum(abs(diff))) 
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> if sum(abs(diff)) &gt; <b>80</b>: 
        print("Best guess: " + guess)
        break</code></pre>
<p class="CodeListingCaption"><a id="listing9-11">Listing 9-11</a>: Testing a single character against a known-bad password.</p>
<p>You’ll need to adjust the threshold for your setup at <span class="CodeAnnotation" aria-label="annotation2">2</span>, which is most easily done by uncommenting the <code>print</code> statement at <span class="CodeAnnotation" aria-label="annotation1">1</span> and checking what differences look like for good and bad passwords.</p>
<h4 id="h3-278748c09-0011">A Full Password Recovery</h4>
<p class="BodyFirst">Building this into a full attack requires only slightly more effort, as implemented in <a href="#listing9-12" id="listinganchor9-12">Listing 9-12</a>. As mentioned previously, our template is built using a single-character bad password. Now that we’ve used that template to guess the first character, we need another template that represents “first character correct, second character wrong.” We do that by capturing a new template from the power consumption of the guessed first password character, plus another 0x00.</p>
<pre><code>full_guess = ""
while(len(full_guess) &lt; 5):
    bad_trace = cap_pass_trace(full_guess + "\x00" + "\n")
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if sum(abs(cap_pass_trace(full_guess + "\x00" + "\n") - bad_trace)) &gt; <b>50</b>: 
        continue
    for guess in "abcdefghijklmnopqrstuvwxyz0123456789":
        diff = cap_pass_trace(full_guess + guess + "\n") - bad_trace
        if sum(abs(diff)) &gt; <b>80</b>:
            full_guess += guess
            print("Best guess: " + full_guess)
            break</code></pre>
<p class="CodeListingCaption"><a id="listing9-12">Listing 9-12</a>: A full attack script that automatically discovers the password</p>
<p>We’ve built in a mechanism to validate that the new template is representative. The captures can sometimes be noisy, and a noisy reference trace will generate false positives. So, a new template is created by grabbing two power traces with the same (invalid) password and making sure that the SAD is below some threshold at <span class="CodeAnnotation" aria-label="annotation1">1</span>. You’ll have to tune this threshold for your setup as well.</p>
<p>A more robust solution would be to average several traces or to detect a trace that is an outlier from the full set automatically. The two magic numbers <code>50</code> and <code>80</code> in <a href="#listing9-12">Listing 9-12</a>, however, are the shortest way to accomplish the goal.</p>
<p>Running this code should print the full password of <code>h0px3</code>. That’s an SPA timing attack in just a handful of Python lines.</p>
<h2 id="h1-278748c09-0004"><span epub:type="pagebreak" title="291" id="Page_291"/>Summary</h2>
<p class="BodyFirst">This chapter concentrated on how to perform a simple timing attack using power analysis. You can use the methods described here for all sorts of attacks on real systems. The only way to get a good handle on them is through hands-on experimentation. When it comes time to attacking real systems, you’ll also learn that the first step is almost always to characterize the system. These characterizations take the same form as the experiments you did here, such as simply measuring what sort of leakage you can find.</p>
<p>If you want to try public-key cryptography for the SPA examples, you could use an open source library like avr-crypto-lib. You’ll even find ports of this library to Arduino.</p>
<p>The ChipWhisperer platform helps abstract away some of the dirty low-level hardware details, so you can concentrate on the more interesting high-level aspects of the attack. The ChipWhisperer site includes tutorials and Python-based sample code to interface to a variety of devices, including various oscilloscopes, serial port drivers, and smartcard readers. Not all targets are part of the ChipWhisperer platform, so for that reason, it can be beneficial to implement “bare-metal” attacks yourself.</p>
<p>Next, we’ll expand on this simple attack to read data out of a device under test. Doing so means not only seeing what sort of program flow is occurring, but also actually determining the secret data being used. </p>
</section>
</body></html>