["```\nadcs dest, source1, source2 // dest := source1 + source2 + C\n```", "```\n .data\nX:      .qword   0\nY:      .qword   0\n```", "```\nlea   x0, X\nldr   x3, [x0]    // Add together the LO 64 bits\nlea   x1, Y       // of the numbers and store the\nldr   x4, [x1]    // result into the LO dword of Z.\nadds  x5, x3, x4\nlea   x2, Z\nstr   x5, [x2]\n\nldr   x3, [x0, #8]    // Add together the HO 64 bits (with\nldr   x4, [x1, #8]    // carry) and store the result into\nadcs  x5, x3, x4      // the HO dword of Z.\nstr   x5, [x2, #8]\n```", "```\n .data\nBigVal1: .space  4*8        // Array of four double words\nBigVal2: .space  4*8\nBigVal3: .space  4*8        // Holds the sum\n     .\n     .\n     .\n    lea  x0, BigVal1\n    lea  x1, BigVal2\n    lea  x2, BigVal3\n\n ldr  x4, [x0]           // BigVal1[0]\n    ldr  x5, [x1]           // BigVal2[0]\n    adds x6, x4, x5\n    str  x6, [x2]           // BigVal3[0]\n\n    ldr  x4, [x0, #8]       // BigVal1[1]\n    ldr  x5, [x1, #8]       // BigVal2[1]\n    adcs x6, x4, x5\n    str  x6, [x2, #8]       // BigVal3[1]\n\n    ldr  x4, [x0, #16]      // BigVal1[2]\n    ldr  x5, [x1, #16]      // BigVal2[2]\n    adcs x6, x4, x5\n    str  x6, [x2, #16]      // BigVal3[2]\n\n    ldr  x4, [x0, #24]      // BigVal1[3]\n    ldr  x5, [x1, #24]      // BigVal2[3]\n    adcs x6, x4, x5\n    str  x6, [x2, #24]      // BigVal3[3]\n```", "```\n .data\nLeft:   .qword   .-.\nRight:  .qword   .-.\nDiff:   .qword   .-.\n     .\n     .\n     .\n    lea  x0, Left\n    ldr  x3, [x0]\n    lea  x1, Right\n    ldr  x4, [x1]\n    subs x5, x3, x4\n    lea  x2, Diff\n    str  x5, [x2]\n\n    ldr  x3, [x0, #8]\n    ldr  x4, [x1, #8]\n    sbcs x5, x3, x4\n    str  x5, [x2, #8]\n```", "```\n .data\nBigVal1: .space  4*8      // Array of four dwords\nBigVal2: .space  4*8\nBigVal3: .space  4*8\n     .\n     .\n     .\n\n// Compute BigVal3 := BigVal1 - BigVal2.\n\n    lea  x0, BigVal1\n    lea  x1, BigVal2\n    lea  x2, BigVal3\n\n    ldr  x4, [x0]           // BigVal1[0]\n    ldr  x5, [x1]           // BigVal2[0]\n    subs x6, x4, x5\n    str  x6, [x2]           // BigVal3[0]\n\n    ldr  x4, [x0, #8]       // BigVal1[1]\n    ldr  x5, [x1, #8]       // BigVal2[1]\n    sbcs x6, x4, x5\n    str  x6, [x2, #8]       // BigVal3[1]\n\n    ldr  x4, [x0, #16]      // BigVal1[2]\n    ldr  x5, [x1, #16]      // BigVal2[2]\n    sbcs x6, x4, x5\n    str  x6, [x2, #16]      // BigVal3[2]\n\n    ldr  x4, [x0, #24]      // BigVal1[3]\n    ldr  x5, [x1, #24]      // BigVal2[3]\n    sbcs x6, x4, x5\n    str  x6, [x2, #24]      // BigVal3[3]\n```", "```\n// This sequence transfers control to location \"IsGreater\" if\n// DwordValue > DwordValue2\\. It transfers control to \"IsLess\" if\n// DwordValue < DwordValue2\\. It falls through to the instruction\n// following this sequence if DwordValue = DwordValue2.\n// To test for inequality, change the \"IsGreater\" and \"IsLess\"\n// operands to \"NotEqual\" in this code.\n\n        ldr x0, [fp, #DwordValue+8]   // Get HO dword.\n        ldr x1, [fp, #DwordValue2 + 8]\n        cmp x0, x1\n        bgt IsGreater\n        blt IsLess\n\n        ldr x0, [fp, #DwordValue+0]   // If HO qwords equal,\n        ldr x1, [fp, #DwordValue2 + 0] // then we must compare\n        cmp x0, x1                    // the LO dwords.\n        bgt IsGreater\n        blt IsLess\n\n// Fall through to this point if the two values are equal.\n```", "```\nlocals  lcl\noword   OW1\noword   OW2\nbyte    stkSpace, 64\nendl    lcl\n```", "```\n ldr x0, [fp, #OW1 + 8]   // Gets HO dword\n    ldr x1, [fp, #OW2 + 8]\n    cmp x0, x1\n    bgt NotLess\n    blt IsLess\n\n    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\n    ldr x1, [fp, #OW2 + 0]   // dwords are equal.\n    cmp x0, x1\n    blt IsLess\nNotLess:\n```", "```\n ldr x0, [fp, #OW1 + 8]   // Gets HO dword\n    ldr x1, [fp, #OW2 + 8]\n    cmp x0, x1\n    bgt NotLessEQ\n    blt IsLessEQ\n\n    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\n    ldr x1, [fp, #OW2 + 0]   // dwords are equal.\n    cmp x0, x1\n    ble IsLessEQ\nNotLessEQ:\n```", "```\n ldr x0, [fp, #OW1 + 8]   // Gets HO dword\n    ldr x1, [fp, #OW2 + 8]\n    cmp x0, x1\n    bgt IsGtr\n    blt NotGtr\n\n    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\n    ldr x1, [fp, #OW2 + 0]   // dwords are equal.\n    cmp x0, x1\n    bgt IsGtr\nNotGtr:\n```", "```\n ldr x0, [fp, #OW1 + 8]   // Gets HO dword\n    ldr x1, [fp, #OW2 + 8]\n    cmp x0, x1\n    bgt IsGtrEQ\n    blt NotGtrEQ\n\n    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\n    ldr x1, [fp, #OW2 + 0]   // dwords are equal.\n    cmp x0, x1\n    bge IsGtrEQ\nNotGtrEQ:\n```", "```\n ldr x0, [fp, #OW1 + 8]   // Gets HO dword\n    ldr x1, [fp, #OW2 + 8]\n cmp x0, x1\n    bne NotEqual\n\n    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\n    ldr x1, [fp, #OW2 + 0]   // dwords are equal.\n    cmp x0, x1\n    beq IsEqual\nNotEqual:                  // Fall through to here if not equal.\n```", "```\nldr x0, [fp, #OW1 + 8]   // Gets HO dword\nldr x1, [fp, #OW2 + 8]\ncmp x0, x1\nbne NotEqual\n\nldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO\nldr x1, [fp, #OW2 + 0]   // dwords are equal.\ncmp x0, x1\nbne NotEqual\n\n// Fall through to here if they are equal.\n```", "```\n locals cmp256\n        dword  Big1, 4\n        dword  Big2, 4\n        endl   cmp256\n\n         .\n         .\n         .\n        ldr  x0, [fp, #Big1 + 24]\n        ldr  x1, [fp, #Big2 + 24]\n        cmp  x0, x1\n        blo  isLE\n        bhi  notLE\n\n        ldr  x0, [fp, #Big1 + 16]\n        ldr  x1, [fp, #Big2 + 16]\n        cmp  x0, x1\n        blo  isLE\n        bhi  notLE\n\n ldr  x0, [fp, #Big1 + 8]\n        ldr  x1, [fp, #Big2 + 8]\n        cmp  x0, x1\n        blo  isLE\n        bhi  notLE\n\n        ldr  x0, [fp, #Big1 + 0]\n        ldr  x1, [fp, #Big2 + 0]\n        cmp  x0, x1\n        bnls notLE\nisLE:\n\n `Code to execute if Big1 <= Big2`\n         .\n         .\n         .\nnotLE:\n\n `Code to execute if Big1 > Big2`\n```", "```\nsmull  Xdest, Wsrc1, Wsrc2        // Xdest = Wsrc1 * Wsrc2 (signed long)\numull  Xdest, Wsrc1, Wsrc2        // Xdest = Wsrc1 * Wsrc2 (unsigned long)\n\nsmnegl Xdest, Wsrc1, Wsrc2        // Xdest = -(Wsrc1 * Wsrc2)\numnegl Xdest, Wsrc1, Wsrc2        // Xdest = -(Wsrc1 * Wsrc2)\n\nsmaddl Xdest, Wsrc1, Wsrc2, Xsrc3  // Xdest = (Wsrc1 * Wsrc2) + Xsrc3\numaddl Xdest, Wsrc1, Wsrc2, Xsrc3  // Xdest = (Wsrc1 * Wsrc2) + Xsrc3\n\nsmsubl Xdest, Wsrc1, Wsrc2, Xsrc3  // Xdest = (Wsrc1 * Wsrc2) - Xsrc3\numsubl Xdest, Wsrc1, Wsrc2, Xsrc3  // Xdest = (Wsrc1 * Wsrc2) - Xsrc3\n```", "```\nsmulh  Xdest, Xsrc1, Xsrc2   // Xdest = (Xsrc1 * Xsrc2) asr 64\numulh  Xdest, Xsrc1, Xsrc2   // Xdest = (Xsrc1 * Xsrc2) lsr 64\n```", "```\n// Multiply X0 × X1, producing a 128-bit result in X3:X2\n// (unsigned).\n\n    mul    x2, x0, x1\n    umulh  x3, x0, x1\n```", "```\n// Listing8-1.S\n//\n// 128-bit multiplication\n\n#include \"aoaa.inc\"\n\n            .code\n            .extern printf\n\nttlStr:     wastr   \"Listing 8-1\"\n\nfmtStr1:    .ascii  \"%016lx_%016lx * %016lx_%016lx  = \\n\"\n            wastr   \"    %016lx_%016lx_%016lx_%016lx\\n\"\n\nop1:        .qword  0x10001000100010001000100010001000\nop2:        .qword  0x10000000000000000000000000000000\n\n// Return program title to C++ program:\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n// mul128\n//\n// Multiplies two unsigned 128-bit values passed on the stack by\n// doing a 128x128-bit multiplication, producing a 256-bit\n// result\n//\n// Stores result to location pointed at by X8\n\n          ❶ proc    mul128\n\n            args    a128\n            qword   m128.mp    // Multiplier\n            qword   m128.mc    // Multiplicand\n            enda    a128\n\n            locals  m128\n            qword   m128.saveX01\n            qword   m128.saveX23\n            qword   m128.saveX45\n            qword   m128.saveX67\n            byte    stkSpace, 64\n            endl    m128\n\n            enter   m128.size\n\n          ❷ stp     x0, x1, [fp, #m128.saveX01]  // Preserve\n            stp     x2, x3, [fp, #m128.saveX23]  // these\n            stp     x4, x5, [fp, #m128.saveX45]  // register\n            stp     x6, x7, [fp, #m128.saveX67]  // values.\n\n// Load operands into registers:\n\n          ❸ ldr     x0, [fp, #m128.mp]\n            ldr     x1, [fp, #m128.mp+8]\n ldr     x2, [fp, #m128.mc]\n            ldr     x3, [fp, #m128.mc+8]\n\n// X5:X4 = X0 * X2\n\n            mul     x4, x0, x2\n            umulh   x5, x0, x2\n\n// X6:X7 = X1 * X2, then X5 = X5 + X7 (and save carry for later):\n\n            mul     x7, x1, x2\n            umulh   x6, x1, x2\n            adds    x5, x5, x7\n\n// X7 = X0 * X3, then X5 = X5 + X7 + C (from earlier):\n\n            mul     x7, x0, x3\n            adcs    x5, x5, x7\n            umulh   x7, x0, x3\n            adcs    x6, x6, x7  // Add in carry from adcs earlier.\n\n// X7:X2 = X3 * X1\n\n            mul     x2, x3, x1\n            umulh   x7, x3, x1\n\n            adc     x7, x7, xzr  // Add in C from previous adcs.\n            adds    x6, x6, x2   // X6 = X6 + X2\n            adc     x7, x7, xzr  // Add in carry from adds.\n\n// X7:X6:X5:X4 contains 256-bit result at this point:\n\n          ❹ stp     x4, x5, [x8]      // Save result to location\n            stp     x6, x7, [x8, #16] // pointed at by X8.\n\n            ldp     x0, x1, [fp, #m128.saveX01] // Restore\n            ldp     x2, x3, [fp, #m128.saveX23] // saved\n            ldp     x4, x5, [fp, #m128.saveX45] // registers.\n            ldp     x6, x7, [fp, #m128.saveX67]\n            leave\n            endp    mul128\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n            locals  am\n            oword   product\n            byte    stkSpace, 128\n            endl    am\n\n            enter   am.size\n\n            str     xzr, [fp, #product]\n\n// Test the mul128 function:\n\n          ❺ lea     x2, op1\n            ldp     x0, x1, [x2]\n            stp     x0, x1, [sp]\n\n            lea     x2, op2\n            ldp     x0, x1, [x2]\n            stp     x0, x1, [sp, #16]\n            add     x8, fp, #product\n            bl      mul128\n\n// Print the result:\n\n          ❻ lea     x0, op1         // Note: display HO\n            ldr     x1, [x0, #8]    // dwords first so the\n            mstr    x1, [sp]        // values appear normal.\n\n            ldr     x2, [x0]\n            mstr    x2, [sp, #8]\n\n            lea     x0, op2\n            ldr     x3, [x0, #8]\n            mstr    x3, [sp, #16]\n            ldr     x4, [x0]\n            mstr    x4, [sp, #24]\n\n            ldr     x5, [fp, #product+24]\n            mstr    x5, [sp, #32]\n\n            ldr     x6, [fp, #product+16]\n            mstr    x6, [sp, #40]\n\n            ldr     x7, [fp, #product+8]\n            mstr    x7, [sp, #48]\n\n            ldr     x0, [fp, #product]\n// Under macOS, all arguments must be on stack for printf,\n// under Linux, only eighth argument is on stack.\n\nEightthArg   =       56  // For macOS\n//EightthArg =       0   // For Linux\n\n             str     x0, [sp, #EighthArg]\n\n             lea     x0, fmtStr1\n             bl      printf\n\n             leave   // Returns to caller\n             endp    asmMain\n```", "```\n$ ./build Listing8-1\n$ ./Listing8-1\nCalling Listing8-1:\n1000100010001000_1000100010001000 * 1000000000000000_0000000000000000  =\n    0100010001000100_0100010001000100_0000000000000000_1000100010001000\nListing8-1 terminated\n```", "```\nQuotient := Dividend;\nRemainder := 0;\nfor i := 1 to NumberBits do\n\n    Remainder:Quotient := Remainder:Quotient LSL 1;\n    if Remainder >= Divisor then\n\n        Remainder := Remainder - Divisor;\n        Quotient := Quotient + 1;\n\n    endif\nendfor\n```", "```\n// Listing8-2.S\n//\n// 128-bit by 128-bit division\n\n#include \"aoaa.inc\"\n\n            .data\n\n// op1 is a 128-bit value. Initial values were chosen\n// to make it easy to verify the result.\n\nop1:        .qword   0x2000400060008000A000C000E0001000\nop2:        .qword   2\nop3:        .qword   0xEEEECCCCAAAA88886666444422221111\nresult:     .qword   0\nremain:     .qword   0\n\n            .code\n            .extern  printf\n\nttlStr:     wastr    \"Listing 8-2\"\nfmtStr1:    .ascii   \"quotient  = \"\n            wastr    \"%016lx_%016lx\\n\"\n\nfmtStr2:    .ascii   \"remainder = \"\n            wastr    \"%016lx_%016lx\\n\"\n\nfmtStr3:    .ascii   \"quotient (2)  = \"\n            wastr    \"%016lx_%016lx\\n\"\n\n// Return program title to C++ program:\n\n            proc     getTitle, public\n            lea      x0, ttlStr\n            ret\n            endp     getTitle\n\n// div128\n//\n// This procedure does a general 128 / 128 division operation\n// using the following algorithm (all variables are assumed\n// to be 128-bit objects):\n//\n// Quotient := Dividend\n// Remainder := 0\n// for i := 1 to NumberBits do\n//\n//  Remainder:Quotient := Remainder:Quotient SHL 1\n//  if Remainder >= Divisor then\n//\n//      Remainder := Remainder - Divisor\n//      Quotient := Quotient + 1\n//\n// endif\n// endfor\n//\n// Data passed:\n//\n// 128-bit dividend, by reference in X0\n// 128-bit divisor, by reference in X1\n//\n// Data returned:\n//\n// Pointer to 128-bit quotient in X8\n// Pointer to 128-bit remainder in X9\n\n          ❶ proc    div128\n\n#define remainderL  x10\n#define remainderH  x11\n#define dividendL   x12\n#define dividendH   x13\n#define quotientL   dividendL\n#define quotientH   dividendH\n#define divisorL    x14\n#define divisorH    x15\n\n            locals  d128\n            dword   saveX0\n            qword   saveX1011\n            qword   saveX1213\n            qword   saveX1415\n            byte    stkSpace, 64\n            endl    d128\n\nquotient    =       dividend        // Alias to dividend\n\n            enter   d128.size       // Set up activation record.\n\n// Preserve registers div128 modifies:\n\n          ❷ str     x0, [fp, #saveX0]\n            stp     x10, x11, [fp, #saveX1011]\n            stp     x12, x13, [fp, #saveX1213]\n            stp     x14, x15, [fp, #saveX1415]\n\n// Initialize remainder with 0:\n\n          ❸ mov     remainderL, #0\n            mov     remainderH, #0\n\n// Copy the dividend to local storage:\n\n            ldp     dividendL, dividendH, [x0]\n\n// Copy the divisor to local storage:\n\n            ldp     divisorL, divisorH, [x1]\n\n            mov     w0, #128           // Count off bits in W0.\n\n// Compute Remainder:Quotient := Remainder:Quotient LSL 1\n//\n// Note: adds x, x, x is equivalent to lsl x, x, #1\n//       adcs x, x, x is equivalent to rol x, x, #1\n//                    (if rol existed)\n//\n// The following four instructions perform a 256-bit\n// extended-precision shift (left) dividend through\n// remainder:\n\nrepeatLp:   adds    dividendL, dividendL, dividendL\n            adcs    dividendH, dividendH, dividendH\n            adcs    remainderL, remainderL, remainderL\n            adc     remainderH, remainderH, remainderH\n\n// Do a 128-bit comparison to see if the remainder\n// is greater than or equal to the divisor:\n\n            cmp     remainderH, divisorH\n            bhi     isGE\n            blo     notGE\n\n            cmp     remainderL, divisorL\n            bhi     isGE\n            blo     notGE\n\n// Remainder := Remainder - Divisor\n\nisGE:       subs    remainderL, remainderL, divisorL\n            sbc     remainderH, remainderH, divisorH\n\n// Quotient := Quotient + 1:\n\n            adds    quotientL, quotientL, #1\n            adc     quotientH, quotientH, xzr\n\n// Repeat for 128 bits:\n\nnotGE:      subs    w0, w0, #1\n            bne     repeatLp\n\n// Okay, copy the quotient (left in the Dividend variable)\n// and the remainder to their return locations:\n\n          ❹ stp     quotientL, quotientH, [x8]\n            stp     remainderL, remainderH, [x9]\n\n// Restore the registers div128 modified:\n\n          ❺ ldr     x0, [fp, #saveX0]\n            ldp     x10, x11, [fp, #saveX1011]\n            ldp     x12, x13, [fp, #saveX1213]\n            ldp     x14, x15, [fp, #saveX1415]\n            leave   // Return to caller.\n            endp    div128\n\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n            locals  am\n            byte    am.stkSpace, 64\n            endl    am\n\n            enter   am.size         // Sets up activation record\n\n// Test the div128 function:\n\n          ❻ lea     x0, op1\n            lea     x1, op2\n            lea     x8, result\n            lea     x9, remain\n            bl      div128\n\n// Print the results:\n\n            ldr     x1, [x8, #8]    // X8 still points at result.\n            mstr    x1, [sp]\n            ldr     x2, [x8]\n            mstr    x2, [sp, #8]\n\n            lea     x0, fmtStr1\n            bl      printf\n\n            lea     x9, remain      // Assume printf munged X9,\n            ldr     x1, [x9, #8]    // must reload.\n            mstr    x1, [sp]\n            ldr     x2, [x9]\n            mstr    x2, [sp, #8]\n\n            lea     x0, fmtStr2\n            bl      printf\n\n// Test the div128 function (again):\n\n            lea     x0, op3\n            lea     x1, op2\n            lea     x8, result\n            lea     x9, remain\n            bl      div128\n\n// Print the results:\n\n            ldr     x1, [x8, #8]    // X8 still points at result.\n            mstr    x1, [sp]\n            ldr     x2, [x8]\n            mstr    x2, [sp, #8]\n\n            lea     x0, fmtStr3\n            bl      printf\n\n            lea     x9, remain      // Must reload\n            ldr     x1, [x9, #8]    // (because of printf).\n            mstr    x1, [sp]\n            ldr     x2, [x9]\n            mstr    x2, [sp, #8]\n\n            lea     x0, fmtStr2\n            bl      printf\n\n            leave   // Returns to caller\n            endp    asmMain\n```", "```\n$ ./build Listing8-2\n$ ./Listing8-2\nCalling Listing8-2:\nquotient  = 1000200030004000_5000600070000800\nremainder = 0000000000000000_0000000000000000\nquotient (2)  = 7777666655554444_3333222211110888\nremainder = 0000000000000000_0000000000000001\nListing8-2 terminated\n```", "```\nldr  x0, [fp, #value320]\nsubs x0, xzr, x0\nstr  x0, [fp, #value320]\n\nldr  x0, [fp, #value320 + 8]\nsbcs x0, xzr, x0\nstr  x0, [fp, #value320 + 8]\n\nldr  x0, [fp, #value320 + 16]\nsbcs x0, xzr, x0\nstr  x0, [fp, #value320 + 16]\n\nldr  x0, [fp, #value320 + 24]\nsbcs x0, xzr, x0\nstr  x0, [fp, #value320 + 24]\n\nldr  x0, [fp, #value320 + 32]\nsbcs x0, xzr, x0\nstr  x0, [fp, #value320 + 32]\n```", "```\nldp x0, x1, [fp, #source1]\nldp x2, x3, [fp, #source2]\nand x2, x2, x0\nand x3, x3, x1\nstp x2, x3, [fp, #dest]\n```", "```\nldp  x0, x1, [fp, #source1]\nldp  x2, x3, [fp, #source2]\nand  x2, x2, x0\nands x3, x3, x1\nstp  x2, x3, [fp, #dest]\nccmp x2, #0, 0b0100, eq   // Sets Z if X3 == 0 && X2 == 0\n```", "```\nldp x0, x1, [fp, #source1]\nldp x2, x3, [fp, #source1 + 16]\nldp x4, x5, [fp, #source2]\nldp x6, x7, [fp, #source2 + 16]\n\norr x0, x0, x4\norr x1, x1, x5\norr x2, x2, x6\norr x3, x3, x7\n\nstp x0, x1, [fp, #dest]\nstp x2, x3, [fp, #dest+16]\n```", "```\nldp x0, x1, [fp, #source1]\nldp x2, x3, [fp, #source2]\neor x2, x2, x0\neor x3, x3, x1\nstp x2, x3, [fp, #dest]\n```", "```\nmvn x0, x0\nmvn x1, x1\n```", "```\nadds x0, x0, x0  // Same as lsl x0, x0, #1\n```", "```\nadds x0, x0, x0\nadcs x1, x1, x1\n```", "```\nadds x0, x0, x0\nadcs x1, x1, x1\nadcs x2, x2, x2\n```", "```\nShiftLoop:\n    adds x0, x0, x0\n    adcs x1, x1, x1\n    adcs x2, x2, x2\n    subs w3, w3, #1\n    bne  ShiftLoop\n```", "```\nrol     x2, x0, #8       // Shift HO 8 bits into LO 8\nand     x2, x2, #0xFF    // bits and clear other bits.\nlsl     x0, x0, #8       // Shift X0 8 bits.\nlsl     x1, x1, #8       // Shift X1 8 bits.\norr     x1, x1, x2       // Merge in LO 8 bits.\n```", "```\nror     x2, x0, #64-8    // Shift HO 8 bits into LO 8\nand     x2, x2, #0xFF    // bits and clear other bits.\nlsl     x0, x0, #8       // Shift X0 8 bits.\nlsl     x1, x1, #8       // Shift X1 8 bits.\norr     x1, x1, x2       // Merge in LO 8 bits.\n```", "```\nmov x3, #1\nlsl x3, x3, x4   // Assume X4 contains the shift count.\nsub x3, x3, #1   // Generates 1 bits in positions 0 to (n-1)\nand x2, x2, x3   // Clears unused bits of X2\n```", "```\nror x2, x1, #8            // Shifts bits 64-71 into HO\nand x2, x2, #0xFF << 56   // 8 bits and clears bits 64-119\nlsr x1, x1, #8            // Shifts X1 8 bits\nlsr x0, x0, #8            // Shifts X0 8 bits\norr x0, x0, x2            // Merges in bits 56-63\n```", "```\nror x2, x1, #8            // Shifts bits 64-71 into HO\nand x2, x2, #0xFF << 56   // 8 bits and clears bits 64-119\nasr x1, x1, #8            // Arithmetic shift X1 8 bits\nlsr x0, x0, #8            // Shifts X0 8 bits\norr x0, x0, x2            // Merges in bits 56-63\n```", "```\nror x3, x2, #4            // Temp copy holding bits 128-131\nAnd x3, x3, #0xF << 60    // Clears all but HO 4 bits of temp\nasr x2, x2, #4            // Arithmetic shift right X2 4 bits\nror x4, x2, #4            // Temp (2) copy holding bits 64-67\nAnd x4, x4, #0xF << 60    // Clears all but HO 4 bits of temp2\nlsr x2, x2, #4            // Shifts the original 3 dwords 4 bits\nlsr x1, x1, #4\nlsr x0, x0, #4\norr x1, x1, x3            // Merges in bits 124-127\norr x0, x0, x4            // Merges in bits 60-63\n```", "```\nlocals  lcl\nbyte    var1\nhword   var2\nalign   3\ndword   var3\nendl    lcl\n .\n .\n .\n// Unsigned addition (8-bit + 16-bit addition\n// producing a 16-bit result):\n\nldrb    w0, [fp, #var1] // Zero-extends byte to 32 bits\nldrh    w1, [fp, #var2] // Zero-extends hword to 32 bits\nadd     w0, w0, w1      // Adds 32 bits\nstrh    w0, [fp, #var2] // Store LO 16 bits in var2.\n\n// Signed addition (8-bit + 16-bit addition\n// producing a 16-bit result):\n\nldrsb   w0, [fp, #var1] // Sign-extends byte to 32 bits\nldrsh   w1, [fp, #var2] // Sign-extends hword to 32 bits\nadd     w0, w0, w1      // Adds 32 bits\nstrh    w0, [fp, #var2] // Store LO 16 bits in var2.\n```", "```\nldrsb   x0, [fp, #var1] // Sign-extends byte to 64 bits\nasr     x1, x0, #63     // Sneaky sign-extend to 128 bits\nldp     x2, x3, [fp, #var3]\nadds    x2, x2, x0      // Adds LO dwords\nadc     x3, x3, x1      // Adds HO dwords\nstp     x2, x3, [fp, #var3]\n```", "```\n// Assume 8-bit value is in W0 and 128-bit value is in X3:X2.\n// Add byte in W0 to 128-bit value in X3:X2.\n\nsxtb    x0, w0          // Sign-extends byte to 64 bits\nasr     x1, x0, #63     // Sneaky sign-extend to 128 bits\nadds    x2, x2, x0      // Adds LO dwords\nadc     x3, x3, x1      // Adds HO dwords\n```", "```\n// Add 8-bit unsigned value in W0 to 32-bit value in W1:\n\nadd    w1, w1, w0, uxtb #0\n\n// Add 8-bit signed value in W0 to 32-bit value in W1:\n\nadd    w1, w1, w0, sxtb #0\n\n// Add 16-bit unsigned value in W0 to 32-bit value in W1:\n\nadd    w1, w1, w0, uxth #0\n\n// Add 16-bit signed value in W0 to 32-bit value in W1:\n\nadd    w1, w1, w0, sxth #0\n\n// Add 32-bit unsigned value in W0 to 64-bit value in X1:\n\nadd    x1, x1, w0, uxtw #0\n\n// Add 32-bit signed value in W0 to 64-bit value in X1:\n\nadd    x1, x1, w0, sxtw #0\n```"]