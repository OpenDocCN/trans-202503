- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: How the Internet Works
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网如何工作
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Before you jump into hunting for bugs, let’s take some time to understand how
    the internet works. Finding web vulnerabilities is all about exploiting weaknesses
    in this technology, so all good hackers should have a solid understanding of it.
    If you’re already familiar with these processes, feel free to skip ahead to my
    discussion of the internet’s security controls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始寻找bug之前，让我们先花点时间了解一下互联网的工作原理。发现网页漏洞的关键在于利用这一技术中的薄弱环节，因此，所有优秀的黑客都应该对其有一个扎实的理解。如果你已经熟悉这些过程，可以跳过，直接进入我对互联网安全控制的讨论。
- en: 'The following question provides a good starting place: what happens when you
    enter *www.google.com* in your browser? In other words, how does your browser
    know how to go from a domain name, like google.com, to the web page you’re looking
    for? Let’s find out.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题提供了一个很好的起点：当你在浏览器中输入*www.google.com*时发生了什么？换句话说，浏览器是如何从像google.com这样的域名，找到你正在寻找的网页的？我们一起来探讨一下。
- en: The Client-Server Model
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器模型
- en: 'The internet is composed of two kind of devices: clients and servers. *Clients*
    request resources or services, and *servers* provide those resources and services.
    When you visit a website with your browser, it acts as a client and requests a
    web page from a web server. The web server will then send your browser the web
    page ([Figure 3-1](#figure3-1)).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网由两种设备组成：客户端和服务器。*客户端* 请求资源或服务，而*服务器* 提供这些资源和服务。当你使用浏览器访问网站时，浏览器充当客户端并请求从web服务器获取网页。然后，web服务器会将网页发送给你的浏览器（见[图3-1](#figure3-1)）。
- en: '![f03001](image_fi/501546c03/f03001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/501546c03/f03001.png)'
- en: 'Figure 3-1: Internet clients request resources from servers.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：互联网客户端从服务器请求资源。
- en: A web page is nothing more than a collection of resources or files sent by the
    web server. For example, at the very least, the server will send your browser
    a text file written in *Hypertext Markup Language (**HTML)*, the language that
    tells your browser what to display. Most web pages also include *Cascading Style
    Sheets (CSS**)* files to make them pretty. Sometimes web pages also contain *JavaScript
    (**JS)* files, which enable sites to animate the web page and react to user input
    without going through the server. For example, JavaScript can resize images as
    users scroll through the page and validate a user input on the client side before
    sending it to the server. Finally, your browser might receive embedded resources,
    such as images and videos. Your browser will combine these resources to display
    the web page you see.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页不过是由web服务器发送的一组资源或文件。例如，至少服务器会发送给你的浏览器一个用*超文本标记语言 (**HTML)* 编写的文本文件，这种语言告诉浏览器应该显示什么内容。大多数网页还包括*层叠样式表
    (**CSS**)* 文件，以使页面更加美观。有时，网页还包含*JavaScript (**JS)* 文件，这些文件使得网页能够进行动画处理，并且能够在不经过服务器的情况下响应用户输入。例如，JavaScript可以在用户滚动页面时调整图像大小，并且在将用户输入发送到服务器之前，在客户端验证这些输入。最后，你的浏览器可能会接收到嵌入式资源，如图像和视频。浏览器会将这些资源合并，展示出你所看到的网页。
- en: Servers don’t just return web pages to the user, either. Web APIs enable applications
    to request the data of other systems. This enables applications to interact with
    each other and share data and resources in a controlled way. For example, Twitter’s
    APIs allow other websites to send requests to Twitter’s servers to retrieve data
    such as lists of public tweets and their authors. APIs power many internet functionalities
    beyond this, and we’ll revisit them, along with their security issues, in Chapter
    24.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不仅仅是将网页返回给用户。Web API允许应用程序请求其他系统的数据。这使得应用程序能够相互交互，并以受控的方式共享数据和资源。例如，Twitter的API允许其他网站向Twitter的服务器发送请求，以获取公开推文及其作者等数据。API还为互联网的许多其他功能提供支持，我们将在第24章中重新探讨它们以及相关的安全问题。
- en: The Domain Name System
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名系统
- en: 'How do your browser and other web clients know where to find these resources?
    Well, every device connected to the internet has a unique *Internet Protocol (IP)*
    address that other devices can use to find it. However, IP addresses are made
    up of numbers and letters that are hard for humans to remember. For example, the
    older format of IP addresses, IPv4, looks like this: 123.45.67.89\. The new version,
    IPv6, looks even more complicated: 2001:db8::ff00:42:8329.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，浏览器和其他web客户端是如何知道在哪里找到这些资源的呢？每个连接到互联网的设备都有一个独特的*互联网协议（IP）* 地址，其他设备可以利用这个地址找到它。然而，IP地址由数字和字母组成，对人类来说很难记住。例如，旧版的IP地址格式IPv4像这样：123.45.67.89。新版的IPv6看起来更复杂：2001:db8::ff00:42:8329。
- en: This is where the *Domain Name System (DNS)* comes in. A DNS server functions
    as the phone book for the internet, translating domain names into IP addresses
    ([Figure 3-2](#figure3-2)). When you enter a domain name in your browser, a DNS
    server must first convert the domain name into an IP address. Our browser asks
    the DNS server, “Which IP address is this domain located at?”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这时*域名系统（DNS）*发挥作用。DNS服务器充当互联网的电话簿，将域名转换为IP地址（[图 3-2](#figure3-2)）。当你在浏览器中输入一个域名时，DNS服务器必须首先将该域名转换为IP地址。我们的浏览器会询问DNS服务器：“这个域名对应的IP地址是什么？”
- en: '![f03002](image_fi/501546c03/f03002.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](image_fi/501546c03/f03002.png)'
- en: 'Figure 3-2: A DNS server will translate a domain name to an IP address.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：DNS服务器会将域名转换为IP地址。
- en: Internet Ports
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网端口
- en: After your browser acquires the correct IP address, it will attempt to connect
    to that IP address via a port. A *port* is a logical division on devices that
    identifies a specific network service. We identify ports by their port numbers,
    which can range from 0 to 65,535.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器获取到正确的IP地址后，它会尝试通过端口连接到该IP地址。*端口*是设备上的逻辑划分，用来标识特定的网络服务。我们通过端口号来识别端口，端口号的范围是0到65,535。
- en: Ports allow a server to provide multiple services to the internet at the same
    time. Because conventions exist for the traffic received on certain ports, port
    numbers also allow the server to quickly forward arriving internet messages to
    a corresponding service for processing. For example, if an internet client connects
    to port 80, the web server understands that the client wishes to access its web
    services ([Figure 3-3](#figure3-3)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 端口允许服务器同时为互联网提供多个服务。由于对某些端口接收的流量有约定，端口号还允许服务器快速将到达的互联网消息转发到相应的服务进行处理。例如，如果一个互联网客户端连接到端口80，网页服务器就能理解客户端希望访问其网页服务（[图
    3-3](#figure3-3)）。
- en: '![f03003](image_fi/501546c03/f03003.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/501546c03/f03003.png)'
- en: 'Figure 3-3: Ports allow servers to provide multiple services. Port numbers
    help forward client requests to the right service.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：端口允许服务器提供多个服务。端口号帮助将客户端请求转发到正确的服务。
- en: By default, we use port 80 for HTTP messages and port 443 for HTTPS, the encrypted
    version of HTTP.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们使用端口80来处理HTTP消息，使用端口443来处理HTTPS，HTTPS是HTTP的加密版本。
- en: HTTP Requests and Responses
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 请求和响应
- en: Once a connection is established, the browser and server communicate via the
    *HyperText Transfer Protocol (**HTTP)*. HTTP is a set of rules that specifies
    how to structure and interpret internet messages, and how web clients and web
    servers should exchange information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接建立，浏览器和服务器通过*超文本传输协议（**HTTP**）*进行通信。HTTP是一套规则，规定了如何构建和解释互联网消息，以及网页客户端和网页服务器应如何交换信息。
- en: When your browser wants to interact with a server, it sends the server an *HTTP
    request*. There are different types of HTTP requests, and the two most common
    are GET and POST. By convention, GET requests retrieve data from the server, while
    POST requests submit data to it. Other common HTTP methods include OPTIONS, used
    to request permitted HTTP methods for a given URL; PUT, used to update a resource;
    and DELETE, used to delete a resource.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的浏览器想要与服务器交互时，它会发送*HTTP请求*给服务器。HTTP请求有不同的类型，最常见的是GET和POST。按惯例，GET请求从服务器获取数据，而POST请求将数据提交给服务器。其他常见的HTTP方法包括OPTIONS，用于请求某个URL允许的HTTP方法；PUT，用于更新资源；DELETE，用于删除资源。
- en: 'Here is an example GET request that asks the server for the home page of *www.google.com*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例GET请求，它请求服务器的*www.google.com*主页：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s walk through the structure of this request, since you’ll be seeing a lot
    of these in this book. All HTTP requests are composed of a request line, request
    headers, and an optional request body. The preceding example contains only the
    request line and headers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起走一遍这个请求的结构，因为在本书中你会看到很多这样的例子。所有的HTTP请求都由请求行、请求头和可选的请求体组成。前面的例子仅包含了请求行和请求头。
- en: The *request line* is the first line of the HTTP request. It specifies the request
    method, the requested URL, and the version of HTTP used. Here, you can see that
    the client is sending an HTTP GET request to the home page of *www.google.com*
    using HTTP version 1.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求行*是HTTP请求的第一行。它指定了请求方法、请求的URL和所使用的HTTP版本。在这里，你可以看到客户端正在使用HTTP版本1.1向*www.google.com*的主页发送HTTP
    GET请求。'
- en: The rest of the lines are HTTP *request headers*. These are used to pass additional
    information about the request to the server. This allows the server to customize
    results sent to the client. In the preceding example, the `Host` header specifies
    the hostname of the request. The `User-Agent` header contains the operating system
    and software version of the requesting software, such as the user’s web browser.The
    `Accept`, `Accept-Language`, and `Accept-Encoding` headers tell the server which
    format the responses should be in. And the `Connection` header tells the server
    whether the network connection should stay open after the server responds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的几行是HTTP*请求头*。这些头部用于将关于请求的附加信息传递给服务器。这允许服务器定制发送给客户端的结果。在前面的示例中，`Host`头指定了请求的主机名。`User-Agent`头包含请求软件的操作系统和软件版本，例如用户的Web浏览器。`Accept`、`Accept-Language`和`Accept-Encoding`头告诉服务器响应应该采用什么格式。而`Connection`头则告诉服务器在响应后是否应保持网络连接。
- en: You might see a few other common headers in requests. The `Cookie` header is
    used to send cookies from the client to the server. The `Referer` header specifies
    the address of the previous web page that linked to the current page. And the
    `Authorization` header contains credentials to authenticate a user to a server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在请求中看到一些其他常见的头部。`Cookie`头用于将客户端的Cookie发送到服务器。`Referer`头指定链接到当前页面的上一网页的地址。`Authorization`头包含用于认证用户的凭证。
- en: 'After the server receives the request, it will try to fulfill it. The server
    will return all the resources used to construct your web page by using *HTTP responses*.
    An HTTP response contains multiple things: an HTTP status code to indicate whether
    the request succeeded; HTTP headers, which are bits of information that browsers
    and servers use to communicate with each other about authentication, content format,
    and security policies; and the HTTP response body, or the actual web content that
    you requested. The web content could include HTML code, CSS style sheets, JavaScript
    code, images, and more.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器接收到请求后，它会尝试满足请求。服务器会通过使用*HTTP响应*返回构建网页所需的所有资源。一个HTTP响应包含多个内容：HTTP状态码，用来指示请求是否成功；HTTP头部，包含浏览器和服务器用来相互通信的有关认证、内容格式和安全策略的信息；以及HTTP响应体，即你请求的实际网页内容。网页内容可以包括HTML代码、CSS样式表、JavaScript代码、图片等。
- en: 'Here is an example of an HTTP response:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个HTTP响应的示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the `200 OK` message on the first line 1. This is the status code. An
    HTTP status code in the 200 range indicates a successful request. A status code
    in the 300 range indicates a redirect to another page, whereas the 400 range indicates
    an error on the client’s part, like a request for a nonexistent page. The 500
    range means that the server itself ran into an error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行中的`200 OK`消息。这是状态码。200范围内的HTTP状态码表示请求成功。300范围表示重定向到另一个页面，而400范围表示客户端出错，比如请求了一个不存在的页面。500范围表示服务器本身出现了错误。
- en: As a bug bounty hunter, you should always keep an eye on these status codes,
    because they can tell you a lot about how the server is operating. For example,
    a status code of 403 means that the resource is forbidden to you. This might mean
    that sensitive data is hidden on the page that you could reach if you can bypass
    the access controls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个漏洞奖励猎人，你应该时刻关注这些状态码，因为它们能告诉你很多关于服务器运行情况的信息。例如，状态码403表示资源对你是禁止的。这可能意味着页面上隐藏了敏感数据，如果你能够绕过访问控制，可能就能访问到这些数据。
- en: The next few lines separated by a colon (`:`) in the response are the HTTP response
    headers. They allow the server to pass additional information about the response
    to the client. In this case, you can see that the time of the response was `Tue,
    31 Aug 2021 17:38:14 GMT` 2. The `Content-Type` header indicates the file type
    of the response body. In this case, The `Content-Type` of this page is `text/html`3.
    The server version is Google Web Server (`gws`) 4, and the `Content-Length` is
    190,532 bytes 5. Usually, additional response headers will specify the content’s
    format, language, and security policies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中用冒号（`:`）分隔的接下来几行是HTTP响应头。它们允许服务器将有关响应的附加信息传递给客户端。在这种情况下，你可以看到响应时间是`Tue, 31
    Aug 2021 17:38:14 GMT`。`Content-Type`头表示响应体的文件类型。在本例中，该页面的`Content-Type`是`text/html`。服务器版本是Google
    Web Server（`gws`），`Content-Length`为190,532字节。通常，额外的响应头会指定内容的格式、语言和安全策略。
- en: In addition to these, you might encounter a few other common response headers.
    The `Set-Cookie` header is sent by the server to the client to set a cookie. The
    `Location` header indicates the URL to which to redirect the page. The `Access-Control-Allow-Origin`
    header indicates which origins can access the page’s content. (We will talk about
    this more in Chapter 19.) `Content-Security-Policy` controls the origin of the
    resources the browser is allowed to load, while the `X-Frame-Options` header indicates
    whether the page can be loaded within an iframe (discussed further in Chapter
    8).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，你还可能会遇到一些其他常见的响应头。`Set-Cookie` 头由服务器发送给客户端，用于设置一个 cookie。`Location` 头表示页面重定向的
    URL。`Access-Control-Allow-Origin` 头指示哪些来源可以访问页面内容。（我们将在第 19 章中详细讨论这一点。）`Content-Security-Policy`
    控制浏览器允许加载的资源的来源，而 `X-Frame-Options` 头指示页面是否可以在 iframe 中加载（第 8 章将进一步讨论这一点）。
- en: The data after the blank line is the response body. It contains the actual content
    of the web page, such as the HTML and JavaScript code. Once your browser receives
    all the information needed to construct the web page, it will render everything
    for you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 空白行之后的数据是响应体，包含网页的实际内容，比如 HTML 和 JavaScript 代码。一旦浏览器接收到构建网页所需的所有信息，它会为你渲染所有内容。
- en: Internet Security Controls
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络安全控制
- en: Now that you have a high-level understanding of how information is communicated
    over the internet, let’s dive into some fundamental security controls that protect
    it from attackers. To hunt for bugs effectively, you will often need to come up
    with creative ways to bypass these controls, so you’ll first need to understand
    how they work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对信息如何在互联网中传输有了高层次的理解，接下来让我们深入探讨一些基本的安全控制措施，这些措施能够保护信息免受攻击者的侵害。为了有效地寻找漏洞，你通常需要想出创造性的方式绕过这些控制，因此你首先需要理解它们是如何工作的。
- en: Content Encoding
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容编码
- en: Data transferred in HTTP requests and responses isn’t always transmitted in
    the form of plain old text. Websites often encode their messages in different
    ways to prevent data corruption.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求和响应中传输的数据并不总是以纯文本的形式进行传输。网站通常会以不同的方式对消息进行编码，以防止数据损坏。
- en: Data encoding is used as a way to transfer binary data reliably across machines
    that have limited support for different content types. Characters used for encoding
    are common characters not used as controlled characters in internet protocols.
    So when you encode content using common encoding schemes, you can be confident
    that your data is going to arrive at its destination uncorrupted. In contrast,
    when you transfer your data in its original state, the data might be screwed up
    when internet protocols misinterpret special characters in the message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据编码作为一种方式，用于在支持不同内容类型有限的机器之间可靠地传输二进制数据。用于编码的字符是常见的字符，在互联网协议中不会作为受控字符使用。因此，当你使用常见的编码方案对内容进行编码时，你可以放心，数据将完整地传输到目的地。相反，如果你以原始状态传输数据，当互联网协议误解消息中的特殊字符时，数据可能会出现问题。
- en: '*Base64 encoding* is one of the most common ways of encoding data. It’s often
    used to transport images and encrypted information within web messages. This is
    the base64-encoded version of the string `"Content Encoding"`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Base64 编码* 是最常见的数据编码方式之一。它常用于在网页消息中传输图像和加密信息。这是字符串 `"Content Encoding"` 的
    Base64 编码版本：'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Base64 encoding’s character set includes the uppercase alphabet characters A
    to Z, the lowercase alphabet characters a to z, the number characters 0 to 9,
    the characters + and /, and finally, the = character for padding. *Base64url*
    *encoding* is a modified version of base64 used for the URL format. It’s similar
    to base64, but uses different non-alphanumeric characters and omits padding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码的字符集包括大写字母 A 到 Z、小写字母 a 到 z、数字字符 0 到 9、字符 + 和 /，最后是用于填充的 = 字符。*Base64url*
    *编码* 是 Base64 的一种修改版本，专门用于 URL 格式。它与 Base64 相似，但使用了不同的非字母数字字符，并且省略了填充。
- en: 'Another popular encoding method is hex encoding. *Hexadecimal encoding*, or
    *hex,* is a way of representing characters in a base-16 format, where characters
    range from 0 to F. Hex encoding takes up more space and is less efficient than
    base64 but provides for a more human-readable encoded string. This is the hex-encoded
    version of the string `"Content Encoding"`; you can see that it takes up more
    characters than its base64 counterpart:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的编码方法是十六进制编码。*十六进制编码*，或称*hex*，是一种用基数 16 格式表示字符的方法，其中字符的范围是从 0 到 F。十六进制编码占用的空间比
    base64 多，效率也较低，但提供了更易于人类阅读的编码字符串。这是字符串“Content Encoding”的十六进制编码版本；你可以看到它比 base64
    对应的编码版本占用更多的字符：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*URL encoding* is a way of converting characters into a format that is more
    easily transmitted over the internet. Each character in a URL-encoded string can
    be represented by its designated hex number preceded by a % symbol. See Wikipedia
    for more information about URL encoding: [https://en.wikipedia.org/wiki/Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)*.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*URL 编码*是一种将字符转换为更容易通过互联网传输的格式的方法。URL 编码字符串中的每个字符可以通过其指定的十六进制数字表示，并以 % 符号开头。有关
    URL 编码的更多信息，请参阅维基百科：[https://en.wikipedia.org/wiki/Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)*。*'
- en: For example, the word *localhost* can be represented with its URL-encoded equivalent,
    `%6c%6f%63%61%6c%68%6f%73%74`. You can calculate a hostname’s URL-encoded equivalent
    by using a URL calculator like URL Decode and Encode ([https://www.urlencoder.org/](https://www.urlencoder.org/)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单词*localhost*可以用它的 URL 编码等效形式表示，即`%6c%6f%63%61%6c%68%6f%73%74`。你可以使用像 URL
    Decode and Encode（[https://www.urlencoder.org/](https://www.urlencoder.org/)）这样的
    URL 计算器来计算主机名的 URL 编码等效形式。
- en: We’ll cover a couple of additional types of character encoding—octal encoding
    and dword encoding—when we discuss SSRFs in Chapter 13. When you see encoded content
    while investigating a site, always try to decode it to discover what the website
    is trying to communicate. You can use Burp Suite’s decoder to decode encoded content.
    We’ll cover how to do this in the next chapter. Alternatively, you can use CyberChef
    ([https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)) to decode
    both base64 content and other types of encoded content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 13 章讨论 SSRF 时介绍几种额外的字符编码类型——八进制编码和双字编码。当你在调查网站时看到编码内容时，始终尝试解码它，以发现网站想要传达的内容。你可以使用
    Burp Suite 的解码器来解码编码的内容。我们将在下一章介绍如何操作。或者，你也可以使用 CyberChef（[https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)）来解码
    base64 内容和其他类型的编码内容。
- en: Servers sometimes also *encrypt* their content before transmission. This keeps
    the data private between the client and server and prevents anyone who intercepts
    the traffic from eavesdropping on the messages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有时还会在传输前*加密*其内容。这可以保持客户端和服务器之间的数据私密性，并防止任何拦截流量的人窃听消息。
- en: Session Management and HTTP Cookies
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话管理和 HTTP Cookie
- en: Why is it that you don’t have to re-log in every time you close your email tab?
    It’s because the website remembers your session. *Session management* is a process
    that allows the server to handle multiple requests from the same user without
    asking the user to log in again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么每次关闭电子邮件标签页后你不需要重新登录？因为网站记住了你的会话。*会话管理*是一个过程，它允许服务器处理来自同一用户的多个请求，而不要求用户再次登录。
- en: Websites maintain a session for each logged-in user, and a new session starts
    when you log in to the website ([Figure 3-4](#figure3-4)). The server will assign
    an associated *session ID* for your browser that serves as proof of your identity.
    The session ID is usually a long and unpredictable sequence designed to be unguessable.
    When you log out, the server ends the session and revokes the session ID. The
    website might also end sessions periodically if you don’t manually log out.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 网站会为每个已登录的用户维护一个会话，并且当你登录网站时，一个新的会话开始（[图 3-4](#figure3-4)）。服务器会为你的浏览器分配一个相关的*会话
    ID*，作为你身份的证明。会话 ID 通常是一个长且不可预测的序列，旨在无法猜测。当你登出时，服务器结束会话并撤销会话 ID。如果你没有手动登出，网站可能也会定期结束会话。
- en: '![F03004](image_fi/501546c03/F03004.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![F03004](image_fi/501546c03/F03004.png)'
- en: 'Figure 3-4: After you log in, the server creates a session for you and issues
    a session ID, which uniquely identifies a session.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：在你登录后，服务器为你创建一个会话并发放会话 ID，该 ID 唯一地标识一个会话。
- en: Most websites use cookies to communicate session information in HTTP requests.
    *HTTP cookies* are small pieces of data that web servers send to your browser.
    When you log in to a site, the server creates a session for you and sends the
    session ID to your browser as a cookie. After receiving a cookie, your browser
    stores it and includes it in every request to the same server ([Figure 3-5](#figure3-5)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站使用 cookie 来在 HTTP 请求中传递会话信息。*HTTP cookies* 是网站服务器发送到你浏览器的小片数据。当你登录网站时，服务器为你创建一个会话，并将会话
    ID 作为 cookie 发送到你的浏览器。浏览器收到 cookie 后，会将其存储，并在每次向同一服务器发起请求时都包含它（[图 3-5](#figure3-5)）。
- en: That’s how the server knows it’s you! After the cookie for the session is generated,
    the server will track it and use it to validate your identity. Finally, when you
    log out, the server will invalidate the session cookie so that it cannot be used
    again. The next time you log in, the server will create a new session and a new
    associated session cookie for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务器如何知道是你的原因！在会话 cookie 生成之后，服务器会跟踪它并用它来验证你的身份。最后，当你登出时，服务器会使会话 cookie 无效，从而防止它再次使用。下次你登录时，服务器将为你创建一个新的会话和一个新的关联会话
    cookie。
- en: '![f03005](image_fi/501546c03/f03005.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![f03005](image_fi/501546c03/f03005.png)'
- en: 'Figure 3-5: Your session ID correlates with session information that is stored
    on the server.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5：你的会话 ID 与存储在服务器上的会话信息相关联。
- en: Token-Based Authentication
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: In session-based authentication, the server stores your information and uses
    a corresponding session ID to validate your identity, whereas a *token-based authentication*
    system stores this info directly in some sort of token. Instead of storing your
    information server-side and querying it using a session ID, tokens allow servers
    to deduce your identity by decoding the token itself. This way, applications won’t
    have to store and maintain session information server-side.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于会话的身份验证中，服务器存储你的信息，并使用相应的会话 ID 来验证你的身份，而 *基于令牌的身份验证* 系统则直接将这些信息存储在某种令牌中。令牌允许服务器通过解码令牌本身来推断你的身份，而不是将信息存储在服务器端并使用会话
    ID 查询它。这样，应用程序就不必在服务器端存储和维护会话信息。
- en: 'This system comes with a risk: if the server uses information contained in
    the token to determine the user’s identity, couldn’t users modify the information
    in the tokens and log in as someone else? To prevent token forgery attacks like
    these, some applications encrypt their tokens, or encode the token so that it
    can be read by only the application itself or other authorized parties. If the
    user can’t understand the contents of the token, they probably can’t tamper with
    it effectively either. Encrypting or encoding a token does not prevent token forgery
    completely. There are ways that an attacker can tamper with an encrypted token
    without understanding its contents. But it’s a lot more difficult than tampering
    with a plaintext token. Attackers can often decode encoded tokens to tamper with
    them.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统有一个风险：如果服务器使用令牌中包含的信息来确定用户的身份，用户是否可以修改令牌中的信息，从而冒充其他人登录？为了防止像这样的令牌伪造攻击，一些应用程序对令牌进行加密，或对令牌进行编码，使得只有应用程序本身或其他授权方可以读取。如果用户无法理解令牌的内容，他们可能也无法有效篡改它。加密或编码令牌并不能完全防止令牌伪造。攻击者仍然有办法在不理解令牌内容的情况下篡改加密的令牌。但这比篡改明文令牌要困难得多。攻击者通常可以解码编码的令牌来篡改它们。
- en: 'Another more reliable way applications protect the integrity of a token is
    by signing the token and verifying the token signature when it arrives at the
    server. *Signatures* are used to verify the integrity of a piece of data. They
    are special strings that can be generated only if you know a secret key. Since
    there is no way of generating a valid signature without the secret key, and only
    the server knows what the secret key is, a valid signature suggests that the token
    is probably not altered by the client or any third party. Although the implementations
    by applications can vary, token-based authentication works like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序保护令牌完整性的另一种更可靠方法是对令牌进行签名，并在令牌到达服务器时验证其签名。*签名*用于验证数据的完整性。它们是只有知道秘密密钥的人才能生成的特殊字符串。由于没有办法在没有秘密密钥的情况下生成有效的签名，并且只有服务器知道这个秘密密钥，因此有效签名表明令牌可能没有被客户端或任何第三方篡改。尽管应用程序的实现可能有所不同，但基于令牌的身份验证就是这样工作的：
- en: The user logs in with their credentials.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用他们的凭证进行登录。
- en: The server validates those credentials and provides the user with a signed token.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器验证这些凭证并为用户提供一个签名令牌。
- en: The user sends the token with every request to prove their identity.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在每次请求时都会发送令牌，以证明他们的身份。
- en: Upon receiving and validating the token, the server reads the user’s identity
    information from the token and responds with confidential data.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到并验证令牌后，服务器会从令牌中读取用户的身份信息并响应机密数据。
- en: JSON Web Tokens
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON Web 令牌
- en: 'The *JSON Web Token (**JWT**)* is one of the most commonly used types of authentication
    tokens. It has three components: a header, a payload, and a signature.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON Web Token（**JWT**）*是最常用的认证令牌类型之一。它由三个部分组成：头部、负载和签名。'
- en: 'The *header* identifies the algorithm used to generate the signature. It’s
    a base64url-encoded string containing the algorithm name. Here’s what a JWT header
    looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部*标识用于生成签名的算法。它是一个包含算法名称的base64url编码字符串。下面是JWT头部的示例：'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This string is the base64url-encoded version of this text:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串是以下文本的base64url编码版本：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The *payload*section contains information about the user’s identity. This section,
    too, is base64url encoded before being used in the token. Here’s an example of
    the payload section, which is the base64url-encoded string of `{ "``user_name``"
    : "``admin``", }`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载*部分包含有关用户身份的信息。这个部分在用于令牌之前，也会进行base64url编码。以下是负载部分的示例，它是`{ "``user_name``"
    : "``admin``", }`的base64url编码字符串：'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the *signature* section validates that the user hasn’t tampered with
    the token. It’s calculated by concatenating the header with the payload, then
    signing it with the algorithm specified in the header, and a secret key. Here’s
    what a JWT signature looks like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*签名*部分验证用户是否篡改了令牌。它通过将头部与负载连接在一起，然后使用头部中指定的算法和密钥对其进行签名来计算。下面是JWT签名的示例：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For this specific token, the signature was generated by signing the string
    `eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg` with the
    HS256 algorithm using the secret key `key`. The complete token concatenates each
    section (the header, payload, and signature), separating them with a period (`.`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的令牌，签名是通过使用密钥`key`，使用HS256算法对字符串`eyBhbGcgOiBIUzI1NiwgdHlwIDogSldUIH0K.eyB1c2VyX25hbWUgOiBhZG1pbiB9Cg`进行签名生成的。完整的令牌将每个部分（头部、负载和签名）连接在一起，使用句点（`.`）分隔它们：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When implemented correctly, JSON web tokens provide a secure way to identify
    the user. When the token arrives at the server, the server can verify that the
    token has not been tampered with by checking that the signature is correct. Then
    the server can deduce the user’s identity by using the information contained in
    the payload section. And since the user does not have access to the secret key
    used to sign the token, they cannot alter the payload and sign the token themselves.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确实现时，JSON Web 令牌提供了一种安全的方式来识别用户。当令牌到达服务器时，服务器可以通过检查签名是否正确来验证令牌是否被篡改过。然后，服务器可以通过使用负载部分中的信息推断用户的身份。而且，由于用户无法访问用于签署令牌的密钥，他们无法篡改负载并自行签署令牌。
- en: But if implemented incorrectly, there are ways that an attacker can bypass the
    security mechanism and forge arbitrary tokens.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果实现不当，攻击者可以绕过安全机制并伪造任意令牌。
- en: Manipulating the alg Field
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作`alg`字段
- en: Sometimes applications fail to verify a token’s signature after it arrives at
    the server. This allows an attacker to simply bypass the security mechanism by
    providing an invalid or blank signature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序在令牌到达服务器后未能验证其签名。这使得攻击者可以通过提供无效或空白签名，轻松绕过安全机制。
- en: One way that attackers can forge their own tokens is by tampering with the `alg`field
    of the token header, which lists the algorithm used to encode the signature. If
    the application does not restrict the algorithm type used in the JWT, an attacker
    can specify which algorithm to use, which could compromise the security of the
    token.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者伪造令牌的一种方式是篡改令牌头部中的`alg`字段，该字段列出了用于编码签名的算法。如果应用程序未限制JWT中使用的算法类型，攻击者可以指定要使用的算法，从而可能危及令牌的安全性。
- en: 'JWT supports a `none` option for the algorithm type. If the `alg` field is
    set to `none`, even tokens with empty signature sections would be considered valid.
    Consider, for example, the following token:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JWT支持`none`选项作为算法类型。如果`alg`字段设置为`none`，即使令牌的签名部分为空，也会被认为是有效的。例如，考虑以下令牌：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This token is simply the base64url-encoded versions of these two blobs, with
    no signature present:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌只是这两个数据块的base64url编码版本，没有签名部分：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This feature was originally used for debugging purposes, but if not turned off
    in a production environment, it would allow attackers to forge any token they
    want and impersonate anyone on the site.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能最初是为了调试目的而使用的，但如果在生产环境中没有关闭，它会允许攻击者伪造任何他们想要的令牌，并冒充任何人。
- en: Another way attackers can exploit the `alg` field is by changing the type of
    algorithm used. The two most common types of signing algorithms used for JWTs
    are HMAC and RSA. HMAC requires the token to be signed with a key and then later
    verified with the same key. When using RSA, the token would first be created with
    a private key, then verified with the corresponding public key, which anyone can
    read. It is critical that the secret key for HMAC tokens and the private key for
    RSA tokens be kept a secret.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可以通过更改`alg`字段的算法类型来利用这一点。JWT使用的两种最常见签名算法是HMAC和RSA。HMAC要求令牌用密钥签署，然后再用相同的密钥验证。当使用RSA时，令牌首先用私钥创建，然后用相应的公钥进行验证，公钥是任何人都可以读取的。对于HMAC令牌，密钥和RSA令牌的私钥必须保密，这是至关重要的。
- en: Now let’s say that an application was originally designed to use RSA tokens.
    The tokens are signed with a private key A, which is kept a secret from the public.
    Then the tokens are verified with public key B, which is available to anyone.
    This is okay as long as the tokens are always treated as RSA tokens. Now if the
    attacker changes the `alg` field to HMAC, they might be able to create valid tokens
    by signing the forged tokens with the RSA public key, B. When the signing algorithm
    is switched to HMAC, the token is still verified with the RSA public key B, but
    this time, the token can be signed with the same public key too.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个应用程序最初设计时使用RSA令牌。这些令牌用私钥A签署，私钥A对外部是保密的。然后，令牌用公钥B进行验证，公钥B是公开的，任何人都可以访问。只要令牌始终作为RSA令牌处理，这种做法是没问题的。现在，如果攻击者将`alg`字段更改为HMAC，他们可能通过用RSA公钥B签署伪造的令牌，创建有效的令牌。当签名算法切换为HMAC时，令牌仍然用RSA公钥B进行验证，但这时，令牌也可以使用同一个公钥进行签署。
- en: Brute-Forcing the Key
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 暴力破解密钥
- en: 'It could also be possible to guess, or *brute-force*, the key used to sign
    a JWT. The attacker has a lot of information to start with: the algorithm used
    to sign the token, the payload that was signed, and the resulting signature. If
    the key used to sign the token is not complex enough, they might be able to brute-force
    it easily. If an attacker is not able to brute-force the key, they might try leaking
    the secret key instead. If another vulnerability, like a directory traversal,
    external entity attack (XXE), or SSRF exists that allows the attacker to read
    the file where the key value is stored, the attacker can steal the key and sign
    arbitrary tokens of their choosing. We’ll talk about these vulnerabilities in
    later chapters.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能通过猜测或*暴力破解*来获取签署JWT所使用的密钥。攻击者可以从很多信息入手：签署令牌时使用的算法、已签名的负载以及结果签名。如果用来签署令牌的密钥不够复杂，他们可能很容易进行暴力破解。如果攻击者无法暴力破解密钥，他们可能会尝试泄露密钥。若存在其他漏洞，比如目录遍历、外部实体攻击（XXE）或SSRF等，攻击者可能会读取存储密钥值的文件，窃取密钥并签署任意令牌。我们将在后续章节讨论这些漏洞。
- en: Reading Sensitive Information
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读敏感信息
- en: Since JSON web tokens are used for access control, they often contain information
    about the user. If the token is not encrypted, anyone can base64-decode the token
    and read the token’s payload. If the token contains sensitive information, it
    might become a source of information leaks. A properly implemented signature section
    of the JSON web token provides data integrity, not confidentiality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON Web令牌用于访问控制，它们通常包含有关用户的信息。如果令牌没有加密，任何人都可以对令牌进行base64解码，并读取令牌的负载。如果令牌包含敏感信息，可能会成为信息泄露的源头。正确实现的JSON
    Web令牌签名部分提供数据完整性，而非保密性。
- en: These are just a few examples of JWT security issues. For more examples of JWT
    vulnerabilities, use the search term *JWT security issues*. The security of any
    authentication mechanism depends not only on its design, but also its implementation.
    JWTs can be secure, but only if implemented properly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是JWT安全问题的一些例子。想了解更多JWT漏洞的例子，可以搜索*JWT安全问题*。任何身份验证机制的安全性不仅取决于其设计，还取决于其实现。JWT是可以安全的，但前提是要正确实施。
- en: The Same-Origin Policy
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同源策略
- en: 'The *same-origin policy (**SOP)* is a rule that restricts how a script from
    one origin can interact with the resources of a different origin. In one sentence,
    the SOP is this: a script from page A can access data from page B only if the
    pages are of the same origin. This rule protects modern web applications and prevents
    many common web vulnerabilities.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*同源策略（**SOP**)* 是一条限制来自一个源的脚本如何与另一个源的资源进行交互的规则。用一句话来说，SOP 就是：来自页面 A 的脚本只能在页面
    A 和页面 B 属于同一源的情况下访问页面 B 的数据。这条规则保护现代网页应用程序，并防止许多常见的网络漏洞。'
- en: 'Two URLs are said to have the same origin if they share the same protocol,
    hostname, and port number. Let’s look at some examples. Page A is at this URL:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个 URL 共享相同的协议、主机名和端口号，那么它们就被认为是同源的。让我们来看一些例子。页面 A 的 URL 是：
- en: '*https://medium.com/@vickieli*'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://medium.com/@vickieli*'
- en: 'It uses HTTPS, which, remember, uses port 443 by default. Now look at the following
    pages to determine which has the same origin as page A, according to the SOP:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 HTTPS，记住，HTTPS 默认使用端口 443。现在，查看以下页面，依据 SOP 判断哪些与页面 A 具有相同的源：
- en: '*https://medium.com/*'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://medium.com/*'
- en: '*http://medium.com/*'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*http://medium.com/*'
- en: '*https://twitter.com/@vickieli7*'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://twitter.com/@vickieli7*'
- en: '*https://medium.com:8080/@vickieli*'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://medium.com:8080/@vickieli*'
- en: The *https://medium.com/* URL is of the same origin as page A, because the two
    pages share the same origin, protocol, hostname, and port number. The other three
    pages do not share the same origin as page A. *http://medium.com/* is of a different
    origin from page A, because their protocols differ. *https://medium.com/* uses
    HTTPS, whereas *http://medium.com/* uses HTTP. *https://twitter.com/@vickieli7*
    is of a different origin as well, because it has a different hostname. Finally,
    *https://medium.com:8080/@vickieli* is of a different origin because it uses port
    8080, instead of port 443.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*https://medium.com/* 的 URL 与页面 A 属于同一源，因为这两个页面共享相同的源、协议、主机名和端口号。其他三个页面与页面
    A 不属于同一源。*http://medium.com/* 与页面 A 属于不同的源，因为它们的协议不同。*https://medium.com/* 使用
    HTTPS，而 *http://medium.com/* 使用 HTTP。*https://twitter.com/@vickieli7* 也是不同源，因为它有不同的主机名。最后，*https://medium.com:8080/@vickieli*
    也是不同源，因为它使用端口 8080，而不是端口 443。'
- en: Now let’s consider an example to see how SOP protects us. Imagine that you’re
    logged in to your banking site at *onlinebank.com*. Unfortunately, you click on
    a malicious site, *attacker.com*, in the same browser.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个例子来看 SOP 是如何保护我们的。假设你已登录到你的银行网站 *onlinebank.com*。不幸的是，你在同一个浏览器中点击了一个恶意网站
    *attacker.com*。
- en: The malicious site issues a GET request to *onlinebank.com* to retrieve your
    personal information. Since you’re logged into the bank, your browser automatically
    includes your cookies in every request you send to *onlinebank.com*, even if the
    request is generated by a script on a malicious site. Since the request contains
    a valid session ID, the server of *onlinebank.com* fulfills the request by sending
    the HTML page containing your info. The malicious script then reads and retrieves
    the private email addresses, home addresses, and banking information contained
    on the page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意网站向 *onlinebank.com* 发出一个 GET 请求以获取你的个人信息。由于你已登录银行，你的浏览器会自动将你的 cookies 包含在每个发送到
    *onlinebank.com* 的请求中，即使请求是由恶意网站上的脚本生成的。由于请求中包含了有效的会话 ID，*onlinebank.com* 的服务器会通过发送包含你信息的
    HTML 页面来满足该请求。然后，恶意脚本读取并获取页面上的私人电子邮件地址、家庭住址和银行信息。
- en: Luckily, the SOP will prevent the malicious script hosted on *attacker.com*
    from reading the HTML data returned from *onlinebank.com*. This keeps the malicious
    script on page A from obtaining sensitive information embedded within page B.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SOP 会阻止在 *attacker.com* 上托管的恶意脚本读取从 *onlinebank.com* 返回的 HTML 数据。这避免了页面
    A 上的恶意脚本获取嵌入在页面 B 中的敏感信息。
- en: Learn to Program
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习编程
- en: You should now have a solid background to help you understand most of the vulnerabilities
    we will cover. Before you set up your hacking tools, I recommend that you learn
    to program. Programming skills are helpful, because hunting for bugs involves
    many repetitive tasks, and by learning a programming language such as Python or
    shell scripting, you can automate these tasks to save yourself a lot of time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有了坚实的基础，能够帮助你理解我们将要讨论的大多数漏洞。在设置你的黑客工具之前，我建议你学习编程。编程技能非常有用，因为寻找漏洞涉及许多重复性任务，通过学习
    Python 或 Shell 脚本等编程语言，你可以将这些任务自动化，从而节省大量时间。
- en: You should also learn to read JavaScript, the language with which most sites
    are written. Reading the JavaScript of a site can teach you about how it works,
    giving you a fast track to finding bugs. Many top hackers say that their secret
    sauce is that they read JavaScript and search for hidden endpoints, insecure programming
    logic, and secret keys. I’ve also found many vulnerabilities by reading JavaScript
    source code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该学习阅读JavaScript，这是大多数网站使用的编程语言。阅读一个网站的JavaScript代码可以帮助你了解它的工作原理，让你快速找到漏洞。许多顶级黑客表示，他们的秘诀就是阅读JavaScript，寻找隐藏的端点、不安全的编程逻辑和秘密密钥。我也通过阅读JavaScript源代码发现了许多漏洞。
- en: Codecademy is a good resource for learning how to program. If you prefer to
    read a book instead, *Learn Python the Hard Way* by Zed Shaw (Addison-Wesley Professional,
    2013) is a great way to learn Python. And reading *Eloquent JavaScript*, Third
    Edition, by Marijn Haverbeke (No Starch Press, 2019) is one of the best ways to
    master JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Codecademy是一个学习编程的好资源。如果你更喜欢阅读书籍的话，*《Learn Python the Hard Way》*（Zed Shaw著，Addison-Wesley
    Professional，2013）是学习Python的好方法。而阅读*《Eloquent JavaScript》第三版*（Marijn Haverbeke著，No
    Starch Press，2019）是掌握JavaScript的最佳途径之一。
