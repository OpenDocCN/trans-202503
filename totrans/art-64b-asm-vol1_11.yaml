- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numeric Conversion
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the conversion between various numeric formats, including
    integer to decimal string, integer to hexadecimal string, floating-point to string,
    hexadecimal string to integer, decimal string to integer, and real string to floating-point.
    In addition to the basic conversions, this chapter discusses error handling (for
    string-to-numeric conversions) and performance enhancements. This chapter discusses
    standard-precision conversions (for 8-, 16-, 32-, and 64-bit integer formats)
    as well as extended-precision conversions (for example, 128-bit integer and string
    conversions).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Converting Numeric Values to Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, this book has relied upon the C Standard Library to perform
    numeric I/O (writing numeric data to the display and reading numeric data from
    the user). However, the C Standard Library doesn’t provide extended-precision
    numeric I/O facilities (and even 64-bit numeric I/O is questionable; this book
    has been using a Microsoft extension to `printf()` to do 64-bit numeric output).
    Therefore, it’s time to break down and discuss how to do numeric I/O in assembly
    language—well, sort of. Because most operating systems support only character
    or string input and output, we aren’t going to do actual numeric I/O. Instead,
    we’re going write functions that convert between numeric values and strings, and
    then do string I/O.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section work specifically with 64-bit (non-extended-precision)
    and 128-bit values, but the algorithms are general and extend to any number of
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1 Converting Numeric Values to Hexadecimal Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting a numeric value to a hexadecimal string is relatively straightforward.
    Just take each nibble (4 bits) in the binary representation and convert that to
    one of the 16 characters “0” through “9” or “A” through “F”. Consider the `btoh`
    function in [Listing 9-1](#listing9-1) that takes a byte in the AL register and
    returns the two corresponding characters in AH (HO nibble) and AL (LO nibble).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: A function that converts a byte to two hexadecimal characters'
  prefs: []
  type: TYPE_NORMAL
- en: You can convert any numeric value in the range 0 to 9 to its corresponding ASCII
    character by ORing the numeric value with 0 (30h). Unfortunately, this maps numeric
    values in the range 0Ah through 0Fh to 3Ah through 3Fh. So, the code in [Listing
    9-1](#listing9-1) checks to see if it produces a value greater than 3Ah and adds
    7 to produce a final character code in the range 41h to 46h (“A” through “F”).
  prefs: []
  type: TYPE_NORMAL
- en: Once we can convert a single byte to a pair of hexadecimal characters, creating
    a string, output to the display is straightforward. We can call the `btoh` (*byte
    to hex*) function for each byte in the number and store the corresponding characters
    away in a string. [Listing 9-2](#listing9-2) provides examples of `btoStr` (*byte
    to string*), `wtoStr` (*word to string*), `dtoStr` (*double word to string*),
    and `qtoStr` (*quad word to string*) functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: `btoStr`, `wtoStr`, `dtoStr`, and `qtoStr` functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each successive function in [Listing 9-2](#listing9-2) builds on the work done
    in the previous functions. For example, `wtoStr` calls `btoStr` twice to convert
    the 2 bytes in AX to a string of four hexadecimal characters. The code would be
    faster (but a lot larger) if you were to inline-expand each of these functions
    wherever the code calls them. If you needed only *one* of these functions, an
    inline expansion of any calls it makes would be worth the extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a version of `qtoStr` with two improvements: inline expansion of the
    calls to `dtoStr`, `wtoStr`, and `btoStr`, plus the use of a simple table lookup
    (array access) to do the nibble-to-hex-character conversion (see Chapter 10 for
    more information on table lookups). The framework for this faster version of `qtoStr`
    appears in [Listing 9-3](#listing9-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: Faster implementation of `qtoStr`'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a short main program that contains the following loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and then using a stopwatch on an old 2012-era 2.6 GHz Intel Core i7 processor,
    I got the approximate timings for the inline and original versions of `qtoStr`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline version: 19 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Original version: 85 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the inline version is significantly (four times) faster, but
    you probably won’t convert 64-bit numbers to hexadecimal strings often enough
    to justify the kludgy code of the inline version.
  prefs: []
  type: TYPE_NORMAL
- en: For what it’s worth, you could probably cut the time almost in half by using
    a much larger table (256 16-bit entries) for the hex characters and convert a
    whole byte at a time rather than a nibble. This would require half the instructions
    of the inline version (though the table would be 32 times bigger).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.2 Converting Extended-Precision Hexadecimal Values to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extended-precision hexadecimal-to-string conversion is easy. It’s simply an
    extension of the normal hexadecimal conversion routines from the previous section.
    For example, here’s a 128-bit hexadecimal conversion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 9.1.3 Converting Unsigned Decimal Values to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decimal output is a little more complicated than hexadecimal output because
    the HO bits of a binary number affect the LO digits of the decimal representation
    (this was not true for hexadecimal values, which is why hexadecimal output is
    so easy). Therefore, we will have to create the decimal representation for a binary
    number by extracting one decimal digit at a time from the number.
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0 to 9, and this value corresponds to the LO digit of
    the decimal number. Successive divisions by 10 (and their corresponding remainder)
    extract successive digits from the number.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. Then the code extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the LO digits first and
    the HO digits last, the opposite of the way you need to print them).
  prefs: []
  type: TYPE_NORMAL
- en: 'This section employs a *recursive solution* because it is a little more elegant.
    This solution begins by dividing the value by 10 and saving the remainder in a
    local variable. If the quotient is not 0, the routine recursively calls itself
    to output any leading digits first. On return from the recursive call (which outputs
    all the leading digits), the recursive algorithm outputs the digit associated
    with the remainder to complete the operation. Here’s how the operation works when
    printing the decimal value 789:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide 789 by 10\. The quotient is 78, and the remainder is 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Recursive entry 1*: Divide 78 by 10\. The quotient is 7, and the remainder
    is 8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Recursive entry 2*: Divide 7 by 10\. The quotient is 0, and the remainder
    is 7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (7) in a local variable. Because the quotient is 0, don’t
    call the routine recursively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the remainder value saved in the local variable (7). Return to the caller
    (recursive entry 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Return to recursive entry 1*: Output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Original invocation*: Output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-4](#listing9-4) implements the recursive algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: Unsigned integer-to-string function (recursive)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unlike hexadecimal output, there really is no need to provide a byte-size, word-size,
    or dword-size numeric-to-decimal-string conversion function. Simply zero-extending
    the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions,
    there are no leading zeros emitted by the `qtoStr` function, so the output is
    the same for all sizes of variables (64 bits and smaller).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the hexadecimal conversion (which is very fast to begin with, plus you
    don’t really call it that often), you will frequently call the integer-to-string
    conversion function. Because it uses the `div` instruction, it can be fairly slow.
    Fortunately, we can speed it up by using the `fist` and `fbstp` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The `fbstp` instruction converts the 80-bit floating-point value currently sitting
    on the top of stack to an 18-digit packed BCD value (using the format appearing
    in [Figure 6-7](c06.xhtml#figure6-7) in Chapter 6). The `fist` instruction allows
    you to load a 64-bit integer onto the FPU stack. So, by using these two instructions,
    you can (mostly) convert a 64-bit integer to a packed BCD value, which encodes
    a single decimal digit per 4 bits. Therefore, you can convert the packed BCD result
    that `fbstp` produces to a character string by using the same algorithm you use
    for converting hexadecimal numbers to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one catch with using `fist` and `fbstp` to convert an integer
    to a string: the Intel packed BCD format (see [Figure 6-7](c06.xhtml#figure6-7)
    in Chapter 6) supports only 18 digits, whereas a 64-bit integer can have up to
    19 digits. Therefore, any `fbstp`-based `utoStr` function will have to handle
    that 19th digit as a special case. With all this in mind, [Listing 9-5](#listing9-5)
    provides this new version of the `utoStr` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: A `fist` and `fbstp`-based `utoStr` function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output from this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The program in [Listing 9-5](#listing9-5) does use a `div` instruction, but
    it executes only once or twice, and only if there are 19 or 20 digits in the number.
    Therefore, the execution time of this `div` instruction will have little overall
    impact on the speed of the `utoStr` function (especially when you consider how
    often you actually print 19-digit numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'I got the following execution times on a 2.6 GHz circa-2012 Core i7 processor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Original `utoStr`: 108 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fist` and `fbstp` implementation: 11 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, the `fist` and `fbstp` implementation is the winner.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.4 Converting Signed Integer Values to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert a signed integer value to a string, you first check to see if the
    number is negative; if it is, you emit a hyphen (-) character and negate the value.
    Then you call the `utoStr` function to finish the job. [Listing 9-6](#listing9-6)
    shows the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Signed integer-to-string conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.5 Converting Extended-Precision Unsigned Integers to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For extended-precision output, the only operation through the entire string-conversion
    algorithm that requires extended-precision arithmetic is the divide-by-10 operation.
    Because we are dividing an extended-precision value by a value that easily fits
    into a quad word, we can use the fast (and easy) extended-precision division algorithm
    that uses the `div` instruction (see “Special Case Form Using `div` Instruction”
    in “Extended-Precision Division” in Chapter 8). [Listing 9-7](#listing9-7) implements
    a 128-bit decimal output routine utilizing this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: 128-bit extended-precision decimal output routine'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, we cannot use the `fbstp` instruction to improve the performance of this
    algorithm as `fbstp` is limited to 80-bit BCD values.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.6 Converting Extended-Precision Signed Decimal Values to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an extended-precision unsigned decimal output routine, writing
    an extended-precision signed decimal output routine is easy. The basic algorithm
    is similar to that for 64-bit integers given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the sign of the number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is positive, call the unsigned output routine to print it. If the number
    is negative, print a minus sign. Then negate the number and call the unsigned
    output routine to print it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check the sign of an extended-precision integer, test the HO bit of the number.
    To negate a large value, the best solution is probably to subtract that value
    from 0\. [Listing 9-8](#listing9-8) is a quick version of `i128toStr` that uses
    the `otoStr` routine from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: 128-bit signed integer-to-string conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.7 Formatted Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in the previous sections converted signed and unsigned integers to
    strings by using the minimum number of necessary character positions. To create
    nicely formatted tables of values, you will need to write functions that provide
    appropriate padding in front of the string of digits before actually emitting
    the digits. Once you have the “unformatted” versions of these routines, implementing
    the formatted versions is easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write `iSize` and `uSize` routines that compute the minimum
    number of character positions needed to display the value. One algorithm to accomplish
    this is similar to the numeric string conversion routines. In fact, the only difference
    is that you initialize a counter to 0 upon entry into the routine (for example,
    the nonrecursive shell routine), and you increment this counter rather than outputting
    a digit on each recursive call. (Don’t forget to increment the counter inside
    `iSize` if the number is negative; you must allow for the output of the minus
    sign.) After the calculation is complete, these routines should return the size
    of the operand in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem is that such a conversion scheme is slow (using recursion
    and `div` is not very fast). As it turns out, a brute-force version that simply
    compares the integer value against 1, 10, 100, 1000, and so on, works much faster.
    Here’s the code that will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For signed integers, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For extended-precision size operations, the brute-force approach quickly becomes
    unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision
    value by a power of 10 (say, 1e+18). This will reduce the size of the number by
    18 digits. Repeat this process as long as the quotient is greater than 64 bits
    (keeping track of the number of times you’ve divided the number by 1e+18). When
    the quotient fits into 64 bits (19 or 20 digits), call the 64-bit `uSize` function
    and add in the number of digits you eliminated with the division operation (18
    for each division by 1e+18). The implementation is left to you on this one . .
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the `iSize` and `uSize` routines, writing the formatted output
    routines, `utoStrSize` or `itoStrSize`, is easy. On initial entry, these routines
    call the corresponding `iSize` or `uSize` routine to determine the number of character
    positions for the number. If the value that the `iSize` or `uSize` routine returns
    is greater than the value of the minimum size parameter (passed into `utoStrSize`
    or `itoStrSize`), no other formatting is necessary. If the value of the parameter
    size is greater than the value `iSize` or `uSize` returns, the program must compute
    the difference between these two values and emit that many spaces (or other filler
    characters) to the output string before the numeric conversion. [Listing 9-9](#listing9-9)
    shows the `utoStrSize` and `itoStrSize` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: Formatted integer-to-string conversion functions'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8 Converting Floating-Point Values to Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code appearing thus far in this chapter has dealt with converting integer
    numeric values to character strings (typically for output to the user). Converting
    floating-point values to a string is just as important. This section (and its
    subsections) covers that conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating-point values can be converted to strings in one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal notation conversion (for example, ± *xxx.yyy* format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential (or scientific) notation conversion (for example, ± *x.yyyyye* ±
    *zz* format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the final output format, two distinct operations are needed to
    convert a value in floating-point form to a character string. First, you must
    convert the mantissa to an appropriate string of digits. Second, you must convert
    the exponent to a string of digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this isn’t a simple case of converting two integer values to a decimal
    string and concatenating them (with an *e* between the mantissa and exponent).
    First of all, the mantissa is not an integer value: it is a fixed-point fractional
    binary value. Simply treating it as an *n*-bit binary value (where *n* is the
    number of mantissa bits) will almost always result in an incorrect conversion.
    Second, while the exponent is, more or less, an integer value,^([1](#c09-footnote-1))
    it represents a power of 2, not a power of 10\. Displaying that power of 2 as
    an integer value is not appropriate for decimal floating-point representation.
    Dealing with these two issues (fractional mantissa and binary exponent) is the
    major complication associated with converting a floating-point value to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Though there are three floating-point formats on the x86-64—single-precision
    (32-bit `real4`), double-precision (64-bit `real8`), and extended-precision (80-bit
    `real10`)—the x87 FPU automatically converts the `real4` and `real8` formats to
    `real10` upon loading the value into the FPU. Therefore, by using the x87 FPU
    for all floating-point arithmetic during the conversion, all we need to do is
    write code to convert `real10` values into string form.
  prefs: []
  type: TYPE_NORMAL
- en: '`real10` floating-point values have a 64-bit mantissa. This is not a 64-bit
    integer. Instead, those 64 bits represent a value between 0 and slightly less
    than 2\. (See “IEEE Floating-Point Formats” in Chapter 2 for more details on the
    IEEE 80-bit floating-point format.) Bit 63 is usually 1\. If bit 63 is 0, the
    mantissa is denormalized, representing numbers between 0 and about 3.65 × 10^(-4951).'
  prefs: []
  type: TYPE_NORMAL
- en: To output the mantissa in decimal form with approximately 18 digits of precision,
    the trick is to successively multiply or divide the floating-point value by 10
    until the number is between 1e+18 and just less than 1e+19 (that is, 9.9999 .
    . . e+18). Once the exponent is in the appropriate range, the mantissa bits form
    an 18-digit integer value (no fractional part), which can be converted to a decimal
    string to obtain the 18 digits that make up the mantissa value (using our friend,
    the `fbstp` instruction). In practice, you would multiply or divide by large powers
    of 10 to get the value into the range 1e+18 to 1e+19\. This is faster (fewer floating-point
    operations) and more accurate (also because of fewer floating-point operations).
  prefs: []
  type: TYPE_NORMAL
- en: To convert the exponent to an appropriate decimal string, you need to track
    the number of multiplications or divisions by 10\. For each division by 10, add
    1 to the decimal exponent value; for each multiplication by 10, subtract 1 from
    the decimal exponent value. At the end of the process, subtract 18 from the decimal
    exponent value (as this process produces a value whose exponent is 18) and convert
    the decimal exponent value to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.1 Converting Floating-Point Exponents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert the exponent to a string of decimal digits, use the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: If the number is 0.0, directly produce the mantissa output string of “ 000000000000000000”
    (notice the space at the beginning of the string).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the decimal exponent to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent is negative, emit a hyphen (-) character and negate the value;
    if it is positive, emit a space character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the (possibly negated) exponent is less than 1.0, go to step
    8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Positive exponents*: Compare the number against successively smaller powers
    of 10, starting with 10^(+4096), then 10^(+2048), then 10^(+1024), then . . .
    , then 10⁰. After each comparison, if the current value is greater than the power
    of 10, divide by that power of 10 and add the power of 10 exponent (4096, 2048,
    . . . , 0) to the decimal exponent value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 5 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to step 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Negative exponents*: Compare the number against successful larger powers of
    10 starting with 10^(-4096), then 10^(-2048), then 10^(-1024), then . . . , then
    10⁰. After each comparison, if the current value is less than the power of 10,
    divide by that power of 10 and subtract the power of 10 exponent (4096, 2048,
    . . . , 0) from the decimal exponent value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 8 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certain legitimate floating-point values are too large to represent with 18
    digits (for example, 9,223,372,036,854,775,807 fits into 63 bits but requires
    more than 18 significant digits to represent). Specifically, values in the range
    403A_DE0B_6B3A_763F_FF01h to 403A_DE0B_6B3A_763F_FFFFh are greater than 999,999,999,999,999,999
    but still fit within a 64-bit mantissa. The `fbstp` instruction will not be able
    to convert these values to a packed BCD value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To resolve this issue, the code should explicitly test for values in this range
    and round them up to 1e+17 (and increment the decimal exponent value, should this
    happen). In some cases, values could be greater than 1e+19\. In such instances,
    one last division by 10.0 will solve the problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, the floating-point value is a reasonable number that the `fbstp`
    instruction can convert to a packed BCD value, so the conversion function uses
    `fbstp` to do this conversion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, convert the packed BCD value to a string of ASCII characters using
    an operation converting numeric values to hexadecimal (BCD) to strings (see “Converting
    Unsigned Decimal Values to Strings” on page 500 and [Listing 9-5](#listing9-5)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-10](#listing9-10) provides the (abbreviated) code and data to implement
    the mantissa-to-string conversion function, `FPDigits`. `FPDigits` converts the
    mantissa to a sequence of 18 digits and returns the decimal exponent value in
    the EAX register. It doesn’t place a decimal point anywhere in the string, nor
    does it process the exponent at all.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: Floating-point mantissa-to-string conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.2 Converting a Floating-Point Value to a Decimal String
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `FPDigits` function does most of the work needed to convert a floating-point
    value to a string in decimal notation: it converts the mantissa to a string of
    digits and provides the exponent in a decimal integer form. Although the decimal
    format does not explicitly display the exponent value, a procedure that converts
    the floating-point value to a decimal string will need the (decimal) exponent
    value to determine where to put the decimal point. Along with a few additional
    arguments that the caller supplies, it’s relatively easy to take the output from
    `FPDigits` and convert it to an appropriately formatted decimal string of digits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function to write is `r10ToStr`, the main function to call when converting
    a `real10` value to a string. This is a formatted output function that translates
    the binary floating-point value by using standard formatting options to control
    the output width, the number of positions after the decimal point, and any fill
    characters to write where digits don’t appear (usually, this is a space). The
    `r10ToStr` function call will need the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r10`'
  prefs: []
  type: TYPE_NORMAL
- en: The `real10` value to convert to a string (if `r10` is a `real4` or `real8`
    value, the FPU will automatically convert it to a `real10` value when loading
    it into the FPU).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fWidth`'
  prefs: []
  type: TYPE_NORMAL
- en: The field width. This is the total number of character positions that the string
    will consume. This count includes room for a sign (which could be a space or a
    hyphen) but does not include space for a zero-terminating byte for the string.
    The field width must be greater than 0 and less than or equal to 1024.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`decDigits`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of digits to the right of the decimal point. This value must be at
    least 3 less than `fWidth` because there must be room for a sign character, at
    least one digit to the left of the decimal point, and the decimal point. If this
    value is 0, the conversion routine will not emit a decimal point to the string.
    This is an unsigned value; if the caller supplies a negative number here, the
    procedure will treat it as a very large positive value (and will return an error).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fill`'
  prefs: []
  type: TYPE_NORMAL
- en: The fill character. If the numeric string that `r10ToStr` produces uses fewer
    characters than `fWidth`, the procedure will right-justify the numeric value in
    the output string and fill the leftmost characters with this `fill` character
    (which is usually a space character).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`buffer`'
  prefs: []
  type: TYPE_NORMAL
- en: A buffer to receive the numeric string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`maxLength`'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the buffer (including the zero-terminating byte). If the conversion
    routine attempts to create a string larger than this value (meaning `fWidth` is
    greater than or equal to this value), then it returns an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The string output operation has only three real tasks: properly position the
    decimal point (if present), copy only those digits specified by the `fWidth` value,
    and round the truncated digits into the output digits.'
  prefs: []
  type: TYPE_NORMAL
- en: The rounding operation is the most interesting part of the procedure. The `r10ToStr`
    function converts the `real10` value to ASCII characters before rounding because
    it’s easier to round the result after the conversion. So the rounding operation
    consists of adding 5 to the (ASCII) digit just beyond the least significant displayed
    digit. If this sum exceeds (the character) 9, the rounding algorithm has to add
    1 to the least significant displayed digit. If that sum exceeds 9, the algorithm
    must subtract (the value) 10 from the character and add 1 to the next least significant
    digit. This process repeats until reaching the most significant digit or until
    there is no carry out of a given digit (that is, the sum does not exceed 9). In
    the (rare) case that rounding bubbles through all the digits (for example, the
    string is “999999 . . . 9”), then the rounding algorithm has to replace the string
    with “10000 . . . 0” and increment the decimal exponent by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for emitting the string differs for values with negative and
    non-negative exponents. Negative exponents are probably the easiest to process.
    Here’s the algorithm for emitting values with a negative exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by adding 3 to `decDigits`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is less than 4, the function sets it to 4 as a default value.^([3](#c09-footnote-3))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is greater than `fWidth`, the function emits `fWidth "#"` characters
    to the string and returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is less than `fWidth`, then output `(fWidth - decDigits)` padding
    characters (`fill`) to the output string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `r10` was negative, emit `-0.` to the string; otherwise, emit `0.` to the
    string (with a leading space in front of the 0 if non-negative).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, output the digits from the converted number. If the field width is less
    than 21 (18 digits plus the 3 leading `0.` or `-0.` characters), then the function
    outputs the specified (`fWidth`) characters from the converted digit string. If
    the width is greater than 21, the function emits all 18 digits from the converted
    digits and follows it by however many 0 characters are necessary to fill out the
    field width.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the function zero-terminates the string and returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the exponent is positive or 0, the conversion is slightly more complicated.
    First, the code has to determine the number of character positions required by
    the result. This is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `exponent` value is the number of digits to the left of the decimal point
    (minus 1). The `2` component is present because there is always a position for
    the sign character (space or hyphen) and there is always at least one digit to
    the left of the decimal point. The `decDigits` component adds in the number of
    digits to appear after the decimal point. Finally, this equation adds in 1 for
    the dot character if a decimal point is present (that is, if `decDigits` is greater
    than 0).
  prefs: []
  type: TYPE_NORMAL
- en: Once the required width is computed, the function compares this value against
    the `fWidth` value the caller supplies. If the computed value is greater than
    `fWidth`, the function emits `fWidth` “`#`” characters and returns. Otherwise,
    it can emit the digits to the output string.
  prefs: []
  type: TYPE_NORMAL
- en: As happens with negative exponents, the code begins by determining whether the
    number will consume all the character positions in the output string. If not,
    it computes the difference between `fWidth` and the actual number of characters
    and outputs the `fill` character to pad the numeric string. Next, it outputs a
    space or a hyphen character (depending on the sign of the original value). Then
    the function outputs the digits to the left of the decimal point (by counting
    down the `exponent` value). If the `decDigits` value is nonzero, the function
    emits the dot character and any digits remaining in the digit string that `FPDigits`
    produced. If the function ever exceeds the 18 digits that `FPDigits` produces
    (either before or after the decimal point), then the function fills the remaining
    positions with the 0 character. Finally, the function emits the zero-terminating
    byte for the string and returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](#listing9-11) provides the source code for the `r10ToStr` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: `r10ToStr` conversion function'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.3 Converting a Floating-Point Value to Exponential Form
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Converting a floating-point value to exponential (scientific) form is a bit
    easier than converting it to decimal form. The mantissa always takes the form
    `sx.y` where `s` is a hyphen or a space, `x` is exactly one decimal digit, and
    `y` is one or more decimal digits. The `FPDigits` function does almost all the
    work to create this string. The exponential conversion function needs to output
    the mantissa string with sign and decimal point characters and then output the
    decimal exponent for the number. Converting the exponent value (returned as a
    decimal integer in the EAX register by `FPDigits`) to a string is just the numeric-to-decimal
    string conversion given earlier in this chapter, using different output formatting.
  prefs: []
  type: TYPE_NORMAL
- en: The function this chapter presents allows you to specify the number of digits
    for the exponent as 1, 2, 3, or 4\. If the exponent requires more digits than
    the caller specifies, the function returns a failure. If it requires fewer digits
    than the caller specifies, the function pads the exponent with leading 0s. To
    emulate the typical floating-point conversion forms, specify an exponent size
    of 2 for single-precision values, 3 for double-precision values, and 4 for extended-precision
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-12](#listing9-12) provides a quick-and-dirty function that converts
    the decimal exponent value to the appropriate string form and emits those characters
    to a buffer. This function leaves RDI pointing beyond the last exponent digit
    and doesn’t zero-terminate the string. It’s really just a helper function to output
    characters for the `e10ToStr` function that will appear in the next listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: Exponent conversion function'
  prefs: []
  type: TYPE_NORMAL
- en: The actual `e10ToStr` function in [Listing 9-13](#listing9-13) is similar to
    the `r10ToStr` function. The output of the mantissa is less complex because the
    form is fixed, but there is a little additional work at the end to output the
    exponent. Refer back to “Converting a Floating-Point Value to a Decimal String”
    on page 527 for details on the operation of this code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-13: `e10ToStr` conversion function'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 String-to-Numeric Conversion Routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The routines converting numeric values to strings, and strings to numeric values,
    have a couple of fundamental differences. First of all, numeric-to-string conversions
    generally occur without possibility of error;^([4](#c09-footnote-4)) string-to-numeric
    conversion, on the other hand, must handle the real possibility of errors such
    as illegal characters and numeric overflow.
  prefs: []
  type: TYPE_NORMAL
- en: A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, in C++ a statement like `cin >> i32;` reads
    a line of text from the user and converts a sequence of digits appearing at the
    beginning of that line of text into a 32-bit signed integer (assuming `i32` is
    a 32-bit `int` object). The `cin >> i32;` statement skips over certain characters,
    like leading spaces, in the string that may appear before the actual numeric characters.
    The input string may also contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must determine where the numeric
    data ends in the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, C++ achieves this by looking for a character from a set of *delimiter*
    characters. The delimiter character set could be something as simple as “any character
    that is not a numeric digit” or the set of whitespace characters (space, tab,
    and so on), and perhaps a few other characters such as a comma (`,`) or some other
    punctuation character. For the sake of example, the code in this section will
    assume that any leading spaces or tab characters (ASCII code 9) may precede any
    numeric digits, and the conversion stops on the first nondigit character it encounters.
    Possible error conditions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No numeric digits at all at the beginning of the string (following any spaces
    or tabs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string of digits is a value that would be too large for the intended numeric
    size (for example, 64 bits).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be up to the caller to determine if the numeric string ends with an
    invalid character (upon return from the function call).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 Converting Decimal Strings to Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic algorithm to convert a string containing decimal digits to a number
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an accumulator variable to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip any leading spaces or tabs in the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the first character after the spaces or tabs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the character is not a numeric digit, return an error. If the character is
    a numeric digit, fall through to step 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the numeric character to a numeric value (using AND 0Fh).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the accumulator = (accumulator × 10) + current numeric value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If overflow occurs, return and report an error. If no overflow occurs, fall
    through to step 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the next character from the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the character is a numeric digit, go back to step 5, else fall through to
    step 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return success, with accumulator containing the converted value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For signed integer input, you use this same algorithm with the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: If the first non-space or tab character is a hyphen (`-`), set a flag denoting
    that the number is negative and skip the “`-`” character (if the first character
    is not `-`, then clear the flag).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of a successful conversion, if the flag is set, then negate the integer
    result before return (must check for overflow on the negate operation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 9-14](#listing9-14) implements the conversion algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-14: Numeric-to-string conversions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For an extended-precision string-to-numeric conversion, you simply modify the
    `strtou` function to have an extend-precision accumulator and then do an extended-precision
    multiplication by 10 (rather than a standard multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Converting Hexadecimal Strings to Numeric Form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for hexadecimal-string-to-numeric
    conversion is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an extended-precision accumulator value to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each input character that is a valid hexadecimal digit, repeat steps 3 through
    6; drop down to step 7 when it is not a valid hexadecimal digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the hexadecimal character to a value in the range 0 to 15 (0h to 0Fh).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the HO 4 bits of the extended-precision accumulator value are nonzero, raise
    an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the current extended-precision value by 16 (that is, shift left 4 bits).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the converted hexadecimal digit value to the accumulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the current input character to ensure it is a valid delimiter. Raise an
    exception if it is not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-15](#listing9-15) implements this extended-precision hexadecimal
    input routine for 64-bit values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-15: Hexadecimal string-to-numeric conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For hexadecimal string conversions that handle numbers greater than 64 bits,
    you have to use an extended-precision shift left by 4 bits. [Listing 9-16](#listing9-16)
    demonstrates the necessary modifications to the `strtoh` function for a 128-bit
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-16: 128-bit hexadecimal string-to-numeric conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.3 Converting Unsigned Decimal Strings to Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for unsigned decimal input is nearly identical to that for hexadecimal
    input. In fact, the only difference (beyond accepting only decimal digits) is
    that you multiply the accumulating value by 10 rather than 16 for each input character
    (in general, the algorithm is the same for any base; just multiply the accumulating
    value by the input base). [Listing 9-17](#listing9-17) demonstrates how to write
    a 64-bit unsigned decimal input routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-17: Unsigned decimal string-to-numeric conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for the program in [Listing 9-17](#listing9-17):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Is it possible to create a faster function that uses the `fbld` (x87 FPU BCD
    store) instruction? Probably not. The `fbstp` instruction was much faster for
    integer conversions because the standard algorithm used multiple executions of
    the (very slow) `div` instruction. Decimal-to-numeric conversion uses the `mul`
    instruction, which is much faster than `div`. Though I haven’t actually tried
    it, I suspect using `fbld` won’t produce faster running code.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4 Conversion of Extended-Precision String to Unsigned Integer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for (decimal) string-to-numeric conversion is the same regardless
    of integer size. You read a decimal character, convert it to an integer, multiply
    the accumulating result by 10, and add in the converted character. The only things
    that change for larger-than-64-bit values are the multiplication by 10 and addition
    operations. For example, to convert a string to a 128-bit integer, you would need
    to be able to multiply a 128-bit value by 10 and add an 8-bit value (zero-extended
    to 128 bits) to a 128-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-18](#listing9-18) demonstrates how to write a 128-bit unsigned decimal
    input routine. Other than the 128-bit multiplication by 10 and 128-bit addition
    operations, this code is functionally identical to the 64-bit string to integer
    conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-18: Extended-precision unsigned decimal input'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.5 Conversion of Extended-Precision Signed Decimal String to Integer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an unsigned decimal input routine, writing a signed decimal input
    routine is easy, as described by the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Consume any delimiter characters at the beginning of the input stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next input character is a minus sign, consume this character and set
    a flag noting that the number is negative; else just drop down to step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the unsigned decimal input routine to convert the rest of the string to
    an integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the return result to make sure its HO bit is clear. Raise a value out
    of range exception if the HO bit of the result is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code encountered a minus sign in step 2, negate the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’ll leave the actual code implementation as a programming exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.6 Conversion of Real String to Floating-Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting a string of characters representing a floating-point number to the
    80-bit `real10` format is slightly easier than the `real10`-to-string conversion
    appearing earlier in this chapter. Because decimal conversion (with no exponent)
    is a subset of the more general scientific notation conversion, if you can handle
    scientific notation, you get decimal conversion for free. Beyond that, the basic
    algorithm is to convert the mantissa characters to a packed BCD form (so the function
    can use the `fbld` instruction to do the string-to-numeric conversion) and then
    read the (optional) exponent and adjust the `real10` exponent accordingly. The
    algorithm to do the conversion is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by stripping away any leading space or tab characters (and any other delimiters).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for a leading plus (`+`) or minus (`-`) sign character. Skip it if one
    is present. Set a sign flag to true if the number is negative (false if non-negative).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize an exponent value to –18\. The algorithm will create a left-justified
    packed BCD value from the mantissa digits in the string to provide to the `fbld`
    instruction, and left-justified packed BCD values are always greater than or equal
    to 10^(18). Initializing the exponent to –18 accounts for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a significant-digit-counter variable that counts the number of significant
    digits processed thus far to 18.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number begins with any leading zeros, skip over them (do not change the
    exponent or significant digit counters for leading zeros to the left of the decimal
    point).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the scan encounters a decimal point after processing any leading zeros, go
    to step 11; else fall through to step 7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each nonzero digit to the left of the decimal point, if the significant
    digit counter is not zero, insert the nonzero digit into a “digit string” array
    at the position specified by the significant digit counter (minus 1).^([5](#c09-footnote-5))
    Note that this will insert the characters into the string in a reversed position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each digit to the left of the decimal point, increment the exponent value
    (originally initialized to –18) by 1\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the significant digit counter is not zero, decrement the significant digit
    counter (this will also provide the index into the digit string array).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the first nondigit encountered is not a decimal point, skip to step 14.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip over the decimal point character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each digit encountered to the right of the decimal point, continue adding
    the digits (in reverse order) to the digit string array as long as the significant
    digit counter is not zero. If the significant digit counter is greater than zero,
    decrement it. Also, decrement the exponent value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*If the algorithm hasn’t encountered at least one decimal digit by this point,
    report an illegal character exception and return*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current character is not `e` or `E`, then go to step 20.^([6](#c09-footnote-6))
    Otherwise, skip over the `e` or `E` character and continue with step 15.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next character is `+` or `-`, skip over it. Set a flag to true if the
    sign character is `-`, and set it to false otherwise (note that this exponent
    sign flag is different from the mantissa sign flag set earlier in this algorithm).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next character is not a decimal digit, report an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the string of digits (starting with the current decimal digit character)
    to an integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the converted integer to the exponent value (which was initialized to –18
    at the start of this algorithm).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent value is outside the range –4930 to +4930, report an out-of-range
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the digit string array of characters to an 18-digit (9-byte) packed
    BCD value by stripping the HO 4 bits of each character, merging pairs of characters
    into a single byte (by shifting the odd-indexed byte to the left 4 bits and logically
    ORing with the even-indexed byte of each pair), and then setting the HO (10th)
    byte to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the packed BCD value to a `real10` value (using the `fbld` instruction).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the absolute value of the exponent (though preserve the sign of the exponent).
    This value will be 13 bits or less (4096 has bit 12 set, so 4930 or less will
    have some combination of bits 0 to 13 set to 1, with all other bits 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent was positive, then for each set bit in the exponent, multiply
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, multiply the `real10` value by 10^(4096),
    10^(1024), and 10².
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent was negative, then for each set bit in the exponent, divide
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, divide the `real10` value by 10^(4096),
    10^(1024), and 10².
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mantissa is negative (the first sign flag set at the beginning of the
    algorithm), then negate the floating-point number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-19](#listing9-19) provides an implementation of this algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-19: A `strToR10` function'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the build command and sample output for [Listing 9-19](#listing9-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 9.3 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming*, Volume 2: *Seminumerical
    Algorithms* (Addison-Wesley Professional, 1997) contains a lot of useful information
    about decimal arithmetic and extended-precision arithmetic, though that text is
    generic and doesn’t describe how to do this in x86 assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Test Yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the code that will convert an 8-bit hexadecimal value in AL into two
    hexadecimal digits (in AH and AL)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many hexadecimal digits will `dToStr` produce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how to use `qToStr` to write a 128-bit hexadecimal output routine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction should you use to produce the fastest 64-bit decimal-to-string
    conversion function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write a signed decimal-to-string conversion if you’re given a function
    that does an unsigned decimal-to-string conversion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameters for the `utoStrSize` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What string will `uSizeToStr` produce if the number requires more print positions
    than specified by the `minDigits` parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameters for the `r10ToStr` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What string will `r10ToStr` produce if the output won’t fit in the string size
    specified by the `fWidth` argument?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the arguments to the `e10ToStr` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a delimiter character?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two possible errors that could occur during a string-to-numeric conversion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
