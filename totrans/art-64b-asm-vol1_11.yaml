- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numeric Conversion
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the conversion between various numeric formats, including
    integer to decimal string, integer to hexadecimal string, floating-point to string,
    hexadecimal string to integer, decimal string to integer, and real string to floating-point.
    In addition to the basic conversions, this chapter discusses error handling (for
    string-to-numeric conversions) and performance enhancements. This chapter discusses
    standard-precision conversions (for 8-, 16-, 32-, and 64-bit integer formats)
    as well as extended-precision conversions (for example, 128-bit integer and string
    conversions).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Converting Numeric Values to Strings
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, this book has relied upon the C Standard Library to perform
    numeric I/O (writing numeric data to the display and reading numeric data from
    the user). However, the C Standard Library doesn’t provide extended-precision
    numeric I/O facilities (and even 64-bit numeric I/O is questionable; this book
    has been using a Microsoft extension to `printf()` to do 64-bit numeric output).
    Therefore, it’s time to break down and discuss how to do numeric I/O in assembly
    language—well, sort of. Because most operating systems support only character
    or string input and output, we aren’t going to do actual numeric I/O. Instead,
    we’re going write functions that convert between numeric values and strings, and
    then do string I/O.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section work specifically with 64-bit (non-extended-precision)
    and 128-bit values, but the algorithms are general and extend to any number of
    bits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1 Converting Numeric Values to Hexadecimal Strings
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting a numeric value to a hexadecimal string is relatively straightforward.
    Just take each nibble (4 bits) in the binary representation and convert that to
    one of the 16 characters “0” through “9” or “A” through “F”. Consider the `btoh`
    function in [Listing 9-1](#listing9-1) that takes a byte in the AL register and
    returns the two corresponding characters in AH (HO nibble) and AL (LO nibble).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: A function that converts a byte to two hexadecimal characters'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: You can convert any numeric value in the range 0 to 9 to its corresponding ASCII
    character by ORing the numeric value with 0 (30h). Unfortunately, this maps numeric
    values in the range 0Ah through 0Fh to 3Ah through 3Fh. So, the code in [Listing
    9-1](#listing9-1) checks to see if it produces a value greater than 3Ah and adds
    7 to produce a final character code in the range 41h to 46h (“A” through “F”).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Once we can convert a single byte to a pair of hexadecimal characters, creating
    a string, output to the display is straightforward. We can call the `btoh` (*byte
    to hex*) function for each byte in the number and store the corresponding characters
    away in a string. [Listing 9-2](#listing9-2) provides examples of `btoStr` (*byte
    to string*), `wtoStr` (*word to string*), `dtoStr` (*double word to string*),
    and `qtoStr` (*quad word to string*) functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: `btoStr`, `wtoStr`, `dtoStr`, and `qtoStr` functions'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each successive function in [Listing 9-2](#listing9-2) builds on the work done
    in the previous functions. For example, `wtoStr` calls `btoStr` twice to convert
    the 2 bytes in AX to a string of four hexadecimal characters. The code would be
    faster (but a lot larger) if you were to inline-expand each of these functions
    wherever the code calls them. If you needed only *one* of these functions, an
    inline expansion of any calls it makes would be worth the extra effort.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a version of `qtoStr` with two improvements: inline expansion of the
    calls to `dtoStr`, `wtoStr`, and `btoStr`, plus the use of a simple table lookup
    (array access) to do the nibble-to-hex-character conversion (see Chapter 10 for
    more information on table lookups). The framework for this faster version of `qtoStr`
    appears in [Listing 9-3](#listing9-3).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Faster implementation of `qtoStr`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Writing a short main program that contains the following loop
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and then using a stopwatch on an old 2012-era 2.6 GHz Intel Core i7 processor,
    I got the approximate timings for the inline and original versions of `qtoStr`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline version: 19 seconds'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Original version: 85 seconds'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the inline version is significantly (four times) faster, but
    you probably won’t convert 64-bit numbers to hexadecimal strings often enough
    to justify the kludgy code of the inline version.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: For what it’s worth, you could probably cut the time almost in half by using
    a much larger table (256 16-bit entries) for the hex characters and convert a
    whole byte at a time rather than a nibble. This would require half the instructions
    of the inline version (though the table would be 32 times bigger).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.2 Converting Extended-Precision Hexadecimal Values to Strings
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extended-precision hexadecimal-to-string conversion is easy. It’s simply an
    extension of the normal hexadecimal conversion routines from the previous section.
    For example, here’s a 128-bit hexadecimal conversion function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.1.3 Converting Unsigned Decimal Values to Strings
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decimal output is a little more complicated than hexadecimal output because
    the HO bits of a binary number affect the LO digits of the decimal representation
    (this was not true for hexadecimal values, which is why hexadecimal output is
    so easy). Therefore, we will have to create the decimal representation for a binary
    number by extracting one decimal digit at a time from the number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0 to 9, and this value corresponds to the LO digit of
    the decimal number. Successive divisions by 10 (and their corresponding remainder)
    extract successive digits from the number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. Then the code extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the LO digits first and
    the HO digits last, the opposite of the way you need to print them).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的迭代解决方案通常会分配足够大的存储空间来容纳整个数字的字符字符串。然后，代码在循环中提取十进制数字，并将它们逐一放入字符串中。在转换过程结束时，例程会以相反的顺序打印字符串中的字符（记住，除法算法先提取低位数字，最后提取高位数字，这与你需要打印的顺序正好相反）。
- en: 'This section employs a *recursive solution* because it is a little more elegant.
    This solution begins by dividing the value by 10 and saving the remainder in a
    local variable. If the quotient is not 0, the routine recursively calls itself
    to output any leading digits first. On return from the recursive call (which outputs
    all the leading digits), the recursive algorithm outputs the digit associated
    with the remainder to complete the operation. Here’s how the operation works when
    printing the decimal value 789:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节采用了*递归解决方案*，因为它稍微更优雅一些。该解决方案首先通过将值除以 10 并将余数保存在局部变量中开始。如果商不为 0，例程会递归调用自己，先输出所有前导数字。递归调用返回后（输出了所有前导数字），递归算法会输出与余数相关的数字，完成操作。当打印十进制值
    789 时，操作过程如下：
- en: Divide 789 by 10\. The quotient is 78, and the remainder is 9.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 789 除以 10。商为 78，余数为 9。
- en: Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（9）保存在一个局部变量中，并递归地调用该例程，使用商值作为参数。
- en: '*Recursive entry 1*: Divide 78 by 10\. The quotient is 7, and the remainder
    is 8.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*递归入口 1*：将 78 除以 10。商为 7，余数为 8。'
- en: Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（8）保存在局部变量中，并递归地调用该例程，使用商值作为参数。
- en: '*Recursive entry 2*: Divide 7 by 10\. The quotient is 0, and the remainder
    is 7.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*递归入口 2*：将 7 除以 10。商为 0，余数为 7。'
- en: Save the remainder (7) in a local variable. Because the quotient is 0, don’t
    call the routine recursively.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（7）保存在局部变量中。由于商为 0，不再递归调用例程。
- en: Output the remainder value saved in the local variable (7). Return to the caller
    (recursive entry 1).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出保存在局部变量中的余数值（7）。返回到调用者（递归入口 1）。
- en: '*Return to recursive entry 1*: Output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回到递归入口 1*：输出在递归入口 1 中保存在局部变量中的余数值（8）。返回到调用者（原始例程调用）。'
- en: '*Original invocation*: Output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*原始调用*：输出原始调用中保存在局部变量中的余数值（9）。返回到输出例程的原始调用者。'
- en: '[Listing 9-4](#listing9-4) implements the recursive algorithm.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-4](#listing9-4) 实现了递归算法。'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-4: Unsigned integer-to-string function (recursive)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：无符号整数到字符串的转换函数（递归）
- en: 'Here’s the build command and program output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike hexadecimal output, there really is no need to provide a byte-size, word-size,
    or dword-size numeric-to-decimal-string conversion function. Simply zero-extending
    the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions,
    there are no leading zeros emitted by the `qtoStr` function, so the output is
    the same for all sizes of variables (64 bits and smaller).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制输出不同，实际上没有必要提供字节大小、字大小或双字大小的数字到十进制字符串的转换函数。只需要将较小的值零扩展到 64 位即可。与十六进制转换不同，`qtoStr`
    函数不会输出前导零，因此对于所有大小的变量（64 位及以下），输出是相同的。
- en: Unlike the hexadecimal conversion (which is very fast to begin with, plus you
    don’t really call it that often), you will frequently call the integer-to-string
    conversion function. Because it uses the `div` instruction, it can be fairly slow.
    Fortunately, we can speed it up by using the `fist` and `fbstp` instructions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制转换（本身就非常快速，而且你也不常用它）不同，整数到字符串的转换函数你会频繁调用。因为它使用了 `div` 指令，所以可能会比较慢。幸运的是，我们可以通过使用
    `fist` 和 `fbstp` 指令来加速它。
- en: The `fbstp` instruction converts the 80-bit floating-point value currently sitting
    on the top of stack to an 18-digit packed BCD value (using the format appearing
    in [Figure 6-7](c06.xhtml#figure6-7) in Chapter 6). The `fist` instruction allows
    you to load a 64-bit integer onto the FPU stack. So, by using these two instructions,
    you can (mostly) convert a 64-bit integer to a packed BCD value, which encodes
    a single decimal digit per 4 bits. Therefore, you can convert the packed BCD result
    that `fbstp` produces to a character string by using the same algorithm you use
    for converting hexadecimal numbers to a string.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one catch with using `fist` and `fbstp` to convert an integer
    to a string: the Intel packed BCD format (see [Figure 6-7](c06.xhtml#figure6-7)
    in Chapter 6) supports only 18 digits, whereas a 64-bit integer can have up to
    19 digits. Therefore, any `fbstp`-based `utoStr` function will have to handle
    that 19th digit as a special case. With all this in mind, [Listing 9-5](#listing9-5)
    provides this new version of the `utoStr` function.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-5: A `fist` and `fbstp`-based `utoStr` function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output from this program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program in [Listing 9-5](#listing9-5) does use a `div` instruction, but
    it executes only once or twice, and only if there are 19 or 20 digits in the number.
    Therefore, the execution time of this `div` instruction will have little overall
    impact on the speed of the `utoStr` function (especially when you consider how
    often you actually print 19-digit numbers).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'I got the following execution times on a 2.6 GHz circa-2012 Core i7 processor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Original `utoStr`: 108 seconds'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fist` and `fbstp` implementation: 11 seconds'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, the `fist` and `fbstp` implementation is the winner.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.4 Converting Signed Integer Values to Strings
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert a signed integer value to a string, you first check to see if the
    number is negative; if it is, you emit a hyphen (-) character and negate the value.
    Then you call the `utoStr` function to finish the job. [Listing 9-6](#listing9-6)
    shows the relevant code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-6: Signed integer-to-string conversion'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.5 Converting Extended-Precision Unsigned Integers to Strings
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For extended-precision output, the only operation through the entire string-conversion
    algorithm that requires extended-precision arithmetic is the divide-by-10 operation.
    Because we are dividing an extended-precision value by a value that easily fits
    into a quad word, we can use the fast (and easy) extended-precision division algorithm
    that uses the `div` instruction (see “Special Case Form Using `div` Instruction”
    in “Extended-Precision Division” in Chapter 8). [Listing 9-7](#listing9-7) implements
    a 128-bit decimal output routine utilizing this technique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-7: 128-bit extended-precision decimal output routine'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sadly, we cannot use the `fbstp` instruction to improve the performance of this
    algorithm as `fbstp` is limited to 80-bit BCD values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，我们不能使用`fbstp`指令来提高该算法的性能，因为`fbstp`仅限于 80 位 BCD 值。
- en: 9.1.6 Converting Extended-Precision Signed Decimal Values to Strings
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.6 将扩展精度有符号十进制值转换为字符串
- en: 'Once you have an extended-precision unsigned decimal output routine, writing
    an extended-precision signed decimal output routine is easy. The basic algorithm
    is similar to that for 64-bit integers given earlier:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了扩展精度无符号十进制输出例程，编写扩展精度有符号十进制输出例程就很简单了。基本算法与之前给出的 64 位整数类似：
- en: Check the sign of the number.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数字的符号。
- en: If it is positive, call the unsigned output routine to print it. If the number
    is negative, print a minus sign. Then negate the number and call the unsigned
    output routine to print it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是正数，调用无符号输出例程打印它。如果是负数，则打印一个负号。然后将该数字取反，并调用无符号输出例程打印它。
- en: To check the sign of an extended-precision integer, test the HO bit of the number.
    To negate a large value, the best solution is probably to subtract that value
    from 0\. [Listing 9-8](#listing9-8) is a quick version of `i128toStr` that uses
    the `otoStr` routine from the previous section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查扩展精度整数的符号，请测试数字的 HO 位。为了取反一个大数，最好的解决方案可能是从 0 中减去该值。[列表 9-8](#listing9-8)是一个快速版的`i128toStr`，它使用了上一节中的`otoStr`例程。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-8: 128-bit signed integer-to-string conversion'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-8：128 位有符号整数到字符串的转换
- en: 9.1.7 Formatted Conversions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.7 格式化转换
- en: The code in the previous sections converted signed and unsigned integers to
    strings by using the minimum number of necessary character positions. To create
    nicely formatted tables of values, you will need to write functions that provide
    appropriate padding in front of the string of digits before actually emitting
    the digits. Once you have the “unformatted” versions of these routines, implementing
    the formatted versions is easy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面部分的代码通过使用最少的必要字符位置将有符号和无符号整数转换为字符串。为了创建格式化良好的值表，你需要编写在输出数字之前为数字字符串提供适当填充的函数。一旦你有了这些例程的“未格式化”版本，实现格式化版本就很容易了。
- en: The first step is to write `iSize` and `uSize` routines that compute the minimum
    number of character positions needed to display the value. One algorithm to accomplish
    this is similar to the numeric string conversion routines. In fact, the only difference
    is that you initialize a counter to 0 upon entry into the routine (for example,
    the nonrecursive shell routine), and you increment this counter rather than outputting
    a digit on each recursive call. (Don’t forget to increment the counter inside
    `iSize` if the number is negative; you must allow for the output of the minus
    sign.) After the calculation is complete, these routines should return the size
    of the operand in the EAX register.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写`iSize`和`uSize`例程，计算显示值所需的最小字符位置数。实现此目标的一个算法类似于数字字符串转换例程。实际上，唯一的区别是进入例程时初始化一个计数器为
    0（例如，非递归外壳例程），然后在每次递归调用时增加此计数器，而不是输出一个数字。（不要忘记在数字为负时在`iSize`中增加计数器；你必须为输出负号留出空间。）计算完成后，这些例程应该将操作数的大小返回到
    EAX 寄存器。
- en: 'The only problem is that such a conversion scheme is slow (using recursion
    and `div` is not very fast). As it turns out, a brute-force version that simply
    compares the integer value against 1, 10, 100, 1000, and so on, works much faster.
    Here’s the code that will do this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是这种转换方案速度较慢（使用递归和`div`并不是很快）。事实证明，一个简单的暴力版本，通过将整数值与 1、10、100、1000 等进行比较，运行得要快得多。以下是实现这一点的代码：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For signed integers, you can use the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数，可以使用以下代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For extended-precision size operations, the brute-force approach quickly becomes
    unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision
    value by a power of 10 (say, 1e+18). This will reduce the size of the number by
    18 digits. Repeat this process as long as the quotient is greater than 64 bits
    (keeping track of the number of times you’ve divided the number by 1e+18). When
    the quotient fits into 64 bits (19 or 20 digits), call the 64-bit `uSize` function
    and add in the number of digits you eliminated with the division operation (18
    for each division by 1e+18). The implementation is left to you on this one . .
    .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度的大小操作，暴力算法方法很快就变得不切实际（64 位已经够糟糕了）。最佳解决方案是将扩展精度值除以 10 的幂（例如，1e+18）。这样可以将数字的大小减少
    18 位。只要商大于 64 位（并跟踪除以 1e+18 的次数），就重复这一过程。当商适合 64 位（19 或 20 位数字）时，调用 64 位的 `uSize`
    函数，并加上你通过除法操作消除的数字位数（每除以 1e+18 减少 18 位）。这个实现留给你自己完成……
- en: Once you have the `iSize` and `uSize` routines, writing the formatted output
    routines, `utoStrSize` or `itoStrSize`, is easy. On initial entry, these routines
    call the corresponding `iSize` or `uSize` routine to determine the number of character
    positions for the number. If the value that the `iSize` or `uSize` routine returns
    is greater than the value of the minimum size parameter (passed into `utoStrSize`
    or `itoStrSize`), no other formatting is necessary. If the value of the parameter
    size is greater than the value `iSize` or `uSize` returns, the program must compute
    the difference between these two values and emit that many spaces (or other filler
    characters) to the output string before the numeric conversion. [Listing 9-9](#listing9-9)
    shows the `utoStrSize` and `itoStrSize` functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `iSize` 和 `uSize` 例程，编写格式化输出例程 `utoStrSize` 或 `itoStrSize` 就变得容易了。初次进入时，这些例程会调用相应的
    `iSize` 或 `uSize` 例程来确定数字所需的字符位置数。如果 `iSize` 或 `uSize` 例程返回的值大于最小大小参数（传入 `utoStrSize`
    或 `itoStrSize` 的值），则不需要其他格式化操作。如果参数大小的值大于 `iSize` 或 `uSize` 返回的值，程序必须计算这两个值之间的差异，并在数字转换之前将相应数量的空格（或其他填充字符）输出到字符串中。[清单
    9-9](#listing9-9) 显示了 `utoStrSize` 和 `itoStrSize` 函数。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-9: Formatted integer-to-string conversion functions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-9：格式化整数到字符串的转换函数
- en: 9.1.8 Converting Floating-Point Values to Strings
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.8 将浮点值转换为字符串
- en: The code appearing thus far in this chapter has dealt with converting integer
    numeric values to character strings (typically for output to the user). Converting
    floating-point values to a string is just as important. This section (and its
    subsections) covers that conversion.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止的代码涉及将整数数值转换为字符字符串（通常用于输出给用户）。将浮点数值转换为字符串同样重要。本节（及其子节）涵盖了这一转换。
- en: 'Floating-point values can be converted to strings in one of two forms:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数值可以转换为两种形式的字符串：
- en: Decimal notation conversion (for example, ± *xxx.yyy* format)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制表示法转换（例如，± *xxx.yyy* 格式）
- en: Exponential (or scientific) notation conversion (for example, ± *x.yyyyye* ±
    *zz* format)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数（或科学）表示法转换（例如，± *x.yyyyye* ± *zz* 格式）
- en: Regardless of the final output format, two distinct operations are needed to
    convert a value in floating-point form to a character string. First, you must
    convert the mantissa to an appropriate string of digits. Second, you must convert
    the exponent to a string of digits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论最终的输出格式如何，都需要两个不同的操作来将浮点值转换为字符字符串。首先，你必须将尾数转换为适当的数字字符串。其次，你必须将指数转换为数字字符串。
- en: 'However, this isn’t a simple case of converting two integer values to a decimal
    string and concatenating them (with an *e* between the mantissa and exponent).
    First of all, the mantissa is not an integer value: it is a fixed-point fractional
    binary value. Simply treating it as an *n*-bit binary value (where *n* is the
    number of mantissa bits) will almost always result in an incorrect conversion.
    Second, while the exponent is, more or less, an integer value,^([1](#c09-footnote-1))
    it represents a power of 2, not a power of 10\. Displaying that power of 2 as
    an integer value is not appropriate for decimal floating-point representation.
    Dealing with these two issues (fractional mantissa and binary exponent) is the
    major complication associated with converting a floating-point value to a string.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Though there are three floating-point formats on the x86-64—single-precision
    (32-bit `real4`), double-precision (64-bit `real8`), and extended-precision (80-bit
    `real10`)—the x87 FPU automatically converts the `real4` and `real8` formats to
    `real10` upon loading the value into the FPU. Therefore, by using the x87 FPU
    for all floating-point arithmetic during the conversion, all we need to do is
    write code to convert `real10` values into string form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`real10` floating-point values have a 64-bit mantissa. This is not a 64-bit
    integer. Instead, those 64 bits represent a value between 0 and slightly less
    than 2\. (See “IEEE Floating-Point Formats” in Chapter 2 for more details on the
    IEEE 80-bit floating-point format.) Bit 63 is usually 1\. If bit 63 is 0, the
    mantissa is denormalized, representing numbers between 0 and about 3.65 × 10^(-4951).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: To output the mantissa in decimal form with approximately 18 digits of precision,
    the trick is to successively multiply or divide the floating-point value by 10
    until the number is between 1e+18 and just less than 1e+19 (that is, 9.9999 .
    . . e+18). Once the exponent is in the appropriate range, the mantissa bits form
    an 18-digit integer value (no fractional part), which can be converted to a decimal
    string to obtain the 18 digits that make up the mantissa value (using our friend,
    the `fbstp` instruction). In practice, you would multiply or divide by large powers
    of 10 to get the value into the range 1e+18 to 1e+19\. This is faster (fewer floating-point
    operations) and more accurate (also because of fewer floating-point operations).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: To convert the exponent to an appropriate decimal string, you need to track
    the number of multiplications or divisions by 10\. For each division by 10, add
    1 to the decimal exponent value; for each multiplication by 10, subtract 1 from
    the decimal exponent value. At the end of the process, subtract 18 from the decimal
    exponent value (as this process produces a value whose exponent is 18) and convert
    the decimal exponent value to a string.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.1 Converting Floating-Point Exponents
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert the exponent to a string of decimal digits, use the following algorithm:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: If the number is 0.0, directly produce the mantissa output string of “ 000000000000000000”
    (notice the space at the beginning of the string).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the decimal exponent to 0.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent is negative, emit a hyphen (-) character and negate the value;
    if it is positive, emit a space character.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the (possibly negated) exponent is less than 1.0, go to step
    8.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Positive exponents*: Compare the number against successively smaller powers
    of 10, starting with 10^(+4096), then 10^(+2048), then 10^(+1024), then . . .
    , then 10⁰. After each comparison, if the current value is greater than the power
    of 10, divide by that power of 10 and add the power of 10 exponent (4096, 2048,
    . . . , 0) to the decimal exponent value.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 5 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to step 10.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Negative exponents*: Compare the number against successful larger powers of
    10 starting with 10^(-4096), then 10^(-2048), then 10^(-1024), then . . . , then
    10⁰. After each comparison, if the current value is less than the power of 10,
    divide by that power of 10 and subtract the power of 10 exponent (4096, 2048,
    . . . , 0) from the decimal exponent value.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 8 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certain legitimate floating-point values are too large to represent with 18
    digits (for example, 9,223,372,036,854,775,807 fits into 63 bits but requires
    more than 18 significant digits to represent). Specifically, values in the range
    403A_DE0B_6B3A_763F_FF01h to 403A_DE0B_6B3A_763F_FFFFh are greater than 999,999,999,999,999,999
    but still fit within a 64-bit mantissa. The `fbstp` instruction will not be able
    to convert these values to a packed BCD value.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To resolve this issue, the code should explicitly test for values in this range
    and round them up to 1e+17 (and increment the decimal exponent value, should this
    happen). In some cases, values could be greater than 1e+19\. In such instances,
    one last division by 10.0 will solve the problem.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, the floating-point value is a reasonable number that the `fbstp`
    instruction can convert to a packed BCD value, so the conversion function uses
    `fbstp` to do this conversion.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, convert the packed BCD value to a string of ASCII characters using
    an operation converting numeric values to hexadecimal (BCD) to strings (see “Converting
    Unsigned Decimal Values to Strings” on page 500 and [Listing 9-5](#listing9-5)).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-10](#listing9-10) provides the (abbreviated) code and data to implement
    the mantissa-to-string conversion function, `FPDigits`. `FPDigits` converts the
    mantissa to a sequence of 18 digits and returns the decimal exponent value in
    the EAX register. It doesn’t place a decimal point anywhere in the string, nor
    does it process the exponent at all.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-10: Floating-point mantissa-to-string conversion'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.2 Converting a Floating-Point Value to a Decimal String
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `FPDigits` function does most of the work needed to convert a floating-point
    value to a string in decimal notation: it converts the mantissa to a string of
    digits and provides the exponent in a decimal integer form. Although the decimal
    format does not explicitly display the exponent value, a procedure that converts
    the floating-point value to a decimal string will need the (decimal) exponent
    value to determine where to put the decimal point. Along with a few additional
    arguments that the caller supplies, it’s relatively easy to take the output from
    `FPDigits` and convert it to an appropriately formatted decimal string of digits.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function to write is `r10ToStr`, the main function to call when converting
    a `real10` value to a string. This is a formatted output function that translates
    the binary floating-point value by using standard formatting options to control
    the output width, the number of positions after the decimal point, and any fill
    characters to write where digits don’t appear (usually, this is a space). The
    `r10ToStr` function call will need the following arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`r10`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The `real10` value to convert to a string (if `r10` is a `real4` or `real8`
    value, the FPU will automatically convert it to a `real10` value when loading
    it into the FPU).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fWidth`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The field width. This is the total number of character positions that the string
    will consume. This count includes room for a sign (which could be a space or a
    hyphen) but does not include space for a zero-terminating byte for the string.
    The field width must be greater than 0 and less than or equal to 1024.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`decDigits`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The number of digits to the right of the decimal point. This value must be at
    least 3 less than `fWidth` because there must be room for a sign character, at
    least one digit to the left of the decimal point, and the decimal point. If this
    value is 0, the conversion routine will not emit a decimal point to the string.
    This is an unsigned value; if the caller supplies a negative number here, the
    procedure will treat it as a very large positive value (and will return an error).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fill`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The fill character. If the numeric string that `r10ToStr` produces uses fewer
    characters than `fWidth`, the procedure will right-justify the numeric value in
    the output string and fill the leftmost characters with this `fill` character
    (which is usually a space character).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`buffer`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: A buffer to receive the numeric string.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`maxLength`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The size of the buffer (including the zero-terminating byte). If the conversion
    routine attempts to create a string larger than this value (meaning `fWidth` is
    greater than or equal to this value), then it returns an error.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The string output operation has only three real tasks: properly position the
    decimal point (if present), copy only those digits specified by the `fWidth` value,
    and round the truncated digits into the output digits.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The rounding operation is the most interesting part of the procedure. The `r10ToStr`
    function converts the `real10` value to ASCII characters before rounding because
    it’s easier to round the result after the conversion. So the rounding operation
    consists of adding 5 to the (ASCII) digit just beyond the least significant displayed
    digit. If this sum exceeds (the character) 9, the rounding algorithm has to add
    1 to the least significant displayed digit. If that sum exceeds 9, the algorithm
    must subtract (the value) 10 from the character and add 1 to the next least significant
    digit. This process repeats until reaching the most significant digit or until
    there is no carry out of a given digit (that is, the sum does not exceed 9). In
    the (rare) case that rounding bubbles through all the digits (for example, the
    string is “999999 . . . 9”), then the rounding algorithm has to replace the string
    with “10000 . . . 0” and increment the decimal exponent by 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for emitting the string differs for values with negative and
    non-negative exponents. Negative exponents are probably the easiest to process.
    Here’s the algorithm for emitting values with a negative exponent:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by adding 3 to `decDigits`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is less than 4, the function sets it to 4 as a default value.^([3](#c09-footnote-3))
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is greater than `fWidth`, the function emits `fWidth "#"` characters
    to the string and returns.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `decDigits` is less than `fWidth`, then output `(fWidth - decDigits)` padding
    characters (`fill`) to the output string.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `r10` was negative, emit `-0.` to the string; otherwise, emit `0.` to the
    string (with a leading space in front of the 0 if non-negative).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, output the digits from the converted number. If the field width is less
    than 21 (18 digits plus the 3 leading `0.` or `-0.` characters), then the function
    outputs the specified (`fWidth`) characters from the converted digit string. If
    the width is greater than 21, the function emits all 18 digits from the converted
    digits and follows it by however many 0 characters are necessary to fill out the
    field width.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the function zero-terminates the string and returns.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the exponent is positive or 0, the conversion is slightly more complicated.
    First, the code has to determine the number of character positions required by
    the result. This is computed as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `exponent` value is the number of digits to the left of the decimal point
    (minus 1). The `2` component is present because there is always a position for
    the sign character (space or hyphen) and there is always at least one digit to
    the left of the decimal point. The `decDigits` component adds in the number of
    digits to appear after the decimal point. Finally, this equation adds in 1 for
    the dot character if a decimal point is present (that is, if `decDigits` is greater
    than 0).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Once the required width is computed, the function compares this value against
    the `fWidth` value the caller supplies. If the computed value is greater than
    `fWidth`, the function emits `fWidth` “`#`” characters and returns. Otherwise,
    it can emit the digits to the output string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: As happens with negative exponents, the code begins by determining whether the
    number will consume all the character positions in the output string. If not,
    it computes the difference between `fWidth` and the actual number of characters
    and outputs the `fill` character to pad the numeric string. Next, it outputs a
    space or a hyphen character (depending on the sign of the original value). Then
    the function outputs the digits to the left of the decimal point (by counting
    down the `exponent` value). If the `decDigits` value is nonzero, the function
    emits the dot character and any digits remaining in the digit string that `FPDigits`
    produced. If the function ever exceeds the 18 digits that `FPDigits` produces
    (either before or after the decimal point), then the function fills the remaining
    positions with the 0 character. Finally, the function emits the zero-terminating
    byte for the string and returns to the caller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-11](#listing9-11) provides the source code for the `r10ToStr` function.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-11: `r10ToStr` conversion function'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.8.3 Converting a Floating-Point Value to Exponential Form
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Converting a floating-point value to exponential (scientific) form is a bit
    easier than converting it to decimal form. The mantissa always takes the form
    `sx.y` where `s` is a hyphen or a space, `x` is exactly one decimal digit, and
    `y` is one or more decimal digits. The `FPDigits` function does almost all the
    work to create this string. The exponential conversion function needs to output
    the mantissa string with sign and decimal point characters and then output the
    decimal exponent for the number. Converting the exponent value (returned as a
    decimal integer in the EAX register by `FPDigits`) to a string is just the numeric-to-decimal
    string conversion given earlier in this chapter, using different output formatting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The function this chapter presents allows you to specify the number of digits
    for the exponent as 1, 2, 3, or 4\. If the exponent requires more digits than
    the caller specifies, the function returns a failure. If it requires fewer digits
    than the caller specifies, the function pads the exponent with leading 0s. To
    emulate the typical floating-point conversion forms, specify an exponent size
    of 2 for single-precision values, 3 for double-precision values, and 4 for extended-precision
    values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-12](#listing9-12) provides a quick-and-dirty function that converts
    the decimal exponent value to the appropriate string form and emits those characters
    to a buffer. This function leaves RDI pointing beyond the last exponent digit
    and doesn’t zero-terminate the string. It’s really just a helper function to output
    characters for the `e10ToStr` function that will appear in the next listing.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-12: Exponent conversion function'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The actual `e10ToStr` function in [Listing 9-13](#listing9-13) is similar to
    the `r10ToStr` function. The output of the mantissa is less complex because the
    form is fixed, but there is a little additional work at the end to output the
    exponent. Refer back to “Converting a Floating-Point Value to a Decimal String”
    on page 527 for details on the operation of this code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-13: `e10ToStr` conversion function'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 String-to-Numeric Conversion Routines
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The routines converting numeric values to strings, and strings to numeric values,
    have a couple of fundamental differences. First of all, numeric-to-string conversions
    generally occur without possibility of error;^([4](#c09-footnote-4)) string-to-numeric
    conversion, on the other hand, must handle the real possibility of errors such
    as illegal characters and numeric overflow.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, in C++ a statement like `cin >> i32;` reads
    a line of text from the user and converts a sequence of digits appearing at the
    beginning of that line of text into a 32-bit signed integer (assuming `i32` is
    a 32-bit `int` object). The `cin >> i32;` statement skips over certain characters,
    like leading spaces, in the string that may appear before the actual numeric characters.
    The input string may also contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must determine where the numeric
    data ends in the input stream.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, C++ achieves this by looking for a character from a set of *delimiter*
    characters. The delimiter character set could be something as simple as “any character
    that is not a numeric digit” or the set of whitespace characters (space, tab,
    and so on), and perhaps a few other characters such as a comma (`,`) or some other
    punctuation character. For the sake of example, the code in this section will
    assume that any leading spaces or tab characters (ASCII code 9) may precede any
    numeric digits, and the conversion stops on the first nondigit character it encounters.
    Possible error conditions are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: No numeric digits at all at the beginning of the string (following any spaces
    or tabs).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string of digits is a value that would be too large for the intended numeric
    size (for example, 64 bits).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be up to the caller to determine if the numeric string ends with an
    invalid character (upon return from the function call).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 Converting Decimal Strings to Integers
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic algorithm to convert a string containing decimal digits to a number
    is the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an accumulator variable to 0.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip any leading spaces or tabs in the string.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the first character after the spaces or tabs.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the character is not a numeric digit, return an error. If the character is
    a numeric digit, fall through to step 5.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the numeric character to a numeric value (using AND 0Fh).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the accumulator = (accumulator × 10) + current numeric value.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If overflow occurs, return and report an error. If no overflow occurs, fall
    through to step 8.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the next character from the string.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the character is a numeric digit, go back to step 5, else fall through to
    step 10.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return success, with accumulator containing the converted value.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For signed integer input, you use this same algorithm with the following modifications:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If the first non-space or tab character is a hyphen (`-`), set a flag denoting
    that the number is negative and skip the “`-`” character (if the first character
    is not `-`, then clear the flag).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of a successful conversion, if the flag is set, then negate the integer
    result before return (must check for overflow on the negate operation).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 9-14](#listing9-14) implements the conversion algorithm.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-14: Numeric-to-string conversions'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for this program:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For an extended-precision string-to-numeric conversion, you simply modify the
    `strtou` function to have an extend-precision accumulator and then do an extended-precision
    multiplication by 10 (rather than a standard multiplication).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Converting Hexadecimal Strings to Numeric Form
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for hexadecimal-string-to-numeric
    conversion is the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an extended-precision accumulator value to 0.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each input character that is a valid hexadecimal digit, repeat steps 3 through
    6; drop down to step 7 when it is not a valid hexadecimal digit.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the hexadecimal character to a value in the range 0 to 15 (0h to 0Fh).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the HO 4 bits of the extended-precision accumulator value are nonzero, raise
    an exception.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the current extended-precision value by 16 (that is, shift left 4 bits).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the converted hexadecimal digit value to the accumulator.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the current input character to ensure it is a valid delimiter. Raise an
    exception if it is not.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-15](#listing9-15) implements this extended-precision hexadecimal
    input routine for 64-bit values.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-15: Hexadecimal string-to-numeric conversion'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For hexadecimal string conversions that handle numbers greater than 64 bits,
    you have to use an extended-precision shift left by 4 bits. [Listing 9-16](#listing9-16)
    demonstrates the necessary modifications to the `strtoh` function for a 128-bit
    conversion.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-16: 128-bit hexadecimal string-to-numeric conversion'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.3 Converting Unsigned Decimal Strings to Integers
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for unsigned decimal input is nearly identical to that for hexadecimal
    input. In fact, the only difference (beyond accepting only decimal digits) is
    that you multiply the accumulating value by 10 rather than 16 for each input character
    (in general, the algorithm is the same for any base; just multiply the accumulating
    value by the input base). [Listing 9-17](#listing9-17) demonstrates how to write
    a 64-bit unsigned decimal input routine.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-17: Unsigned decimal string-to-numeric conversion'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for the program in [Listing 9-17](#listing9-17):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Is it possible to create a faster function that uses the `fbld` (x87 FPU BCD
    store) instruction? Probably not. The `fbstp` instruction was much faster for
    integer conversions because the standard algorithm used multiple executions of
    the (very slow) `div` instruction. Decimal-to-numeric conversion uses the `mul`
    instruction, which is much faster than `div`. Though I haven’t actually tried
    it, I suspect using `fbld` won’t produce faster running code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4 Conversion of Extended-Precision String to Unsigned Integer
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for (decimal) string-to-numeric conversion is the same regardless
    of integer size. You read a decimal character, convert it to an integer, multiply
    the accumulating result by 10, and add in the converted character. The only things
    that change for larger-than-64-bit values are the multiplication by 10 and addition
    operations. For example, to convert a string to a 128-bit integer, you would need
    to be able to multiply a 128-bit value by 10 and add an 8-bit value (zero-extended
    to 128 bits) to a 128-bit value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-18](#listing9-18) demonstrates how to write a 128-bit unsigned decimal
    input routine. Other than the 128-bit multiplication by 10 and 128-bit addition
    operations, this code is functionally identical to the 64-bit string to integer
    conversion.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-18: Extended-precision unsigned decimal input'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.5 Conversion of Extended-Precision Signed Decimal String to Integer
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an unsigned decimal input routine, writing a signed decimal input
    routine is easy, as described by the following algorithm:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Consume any delimiter characters at the beginning of the input stream.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next input character is a minus sign, consume this character and set
    a flag noting that the number is negative; else just drop down to step 3.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the unsigned decimal input routine to convert the rest of the string to
    an integer.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the return result to make sure its HO bit is clear. Raise a value out
    of range exception if the HO bit of the result is set.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code encountered a minus sign in step 2, negate the result.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’ll leave the actual code implementation as a programming exercise for you.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.6 Conversion of Real String to Floating-Point
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting a string of characters representing a floating-point number to the
    80-bit `real10` format is slightly easier than the `real10`-to-string conversion
    appearing earlier in this chapter. Because decimal conversion (with no exponent)
    is a subset of the more general scientific notation conversion, if you can handle
    scientific notation, you get decimal conversion for free. Beyond that, the basic
    algorithm is to convert the mantissa characters to a packed BCD form (so the function
    can use the `fbld` instruction to do the string-to-numeric conversion) and then
    read the (optional) exponent and adjust the `real10` exponent accordingly. The
    algorithm to do the conversion is the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Begin by stripping away any leading space or tab characters (and any other delimiters).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for a leading plus (`+`) or minus (`-`) sign character. Skip it if one
    is present. Set a sign flag to true if the number is negative (false if non-negative).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize an exponent value to –18\. The algorithm will create a left-justified
    packed BCD value from the mantissa digits in the string to provide to the `fbld`
    instruction, and left-justified packed BCD values are always greater than or equal
    to 10^(18). Initializing the exponent to –18 accounts for this.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a significant-digit-counter variable that counts the number of significant
    digits processed thus far to 18.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number begins with any leading zeros, skip over them (do not change the
    exponent or significant digit counters for leading zeros to the left of the decimal
    point).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the scan encounters a decimal point after processing any leading zeros, go
    to step 11; else fall through to step 7.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each nonzero digit to the left of the decimal point, if the significant
    digit counter is not zero, insert the nonzero digit into a “digit string” array
    at the position specified by the significant digit counter (minus 1).^([5](#c09-footnote-5))
    Note that this will insert the characters into the string in a reversed position.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each digit to the left of the decimal point, increment the exponent value
    (originally initialized to –18) by 1\.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the significant digit counter is not zero, decrement the significant digit
    counter (this will also provide the index into the digit string array).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the first nondigit encountered is not a decimal point, skip to step 14.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip over the decimal point character.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each digit encountered to the right of the decimal point, continue adding
    the digits (in reverse order) to the digit string array as long as the significant
    digit counter is not zero. If the significant digit counter is greater than zero,
    decrement it. Also, decrement the exponent value.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*If the algorithm hasn’t encountered at least one decimal digit by this point,
    report an illegal character exception and return*.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current character is not `e` or `E`, then go to step 20.^([6](#c09-footnote-6))
    Otherwise, skip over the `e` or `E` character and continue with step 15.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next character is `+` or `-`, skip over it. Set a flag to true if the
    sign character is `-`, and set it to false otherwise (note that this exponent
    sign flag is different from the mantissa sign flag set earlier in this algorithm).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next character is not a decimal digit, report an error.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the string of digits (starting with the current decimal digit character)
    to an integer.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the converted integer to the exponent value (which was initialized to –18
    at the start of this algorithm).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent value is outside the range –4930 to +4930, report an out-of-range
    exception.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the digit string array of characters to an 18-digit (9-byte) packed
    BCD value by stripping the HO 4 bits of each character, merging pairs of characters
    into a single byte (by shifting the odd-indexed byte to the left 4 bits and logically
    ORing with the even-indexed byte of each pair), and then setting the HO (10th)
    byte to 0.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the packed BCD value to a `real10` value (using the `fbld` instruction).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the absolute value of the exponent (though preserve the sign of the exponent).
    This value will be 13 bits or less (4096 has bit 12 set, so 4930 or less will
    have some combination of bits 0 to 13 set to 1, with all other bits 0).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent was positive, then for each set bit in the exponent, multiply
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, multiply the `real10` value by 10^(4096),
    10^(1024), and 10².
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the exponent was negative, then for each set bit in the exponent, divide
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, divide the `real10` value by 10^(4096),
    10^(1024), and 10².
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mantissa is negative (the first sign flag set at the beginning of the
    algorithm), then negate the floating-point number.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 9-19](#listing9-19) provides an implementation of this algorithm.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-19: A `strToR10` function'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the build command and sample output for [Listing 9-19](#listing9-19).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 9.3 For More Information
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming*, Volume 2: *Seminumerical
    Algorithms* (Addison-Wesley Professional, 1997) contains a lot of useful information
    about decimal arithmetic and extended-precision arithmetic, though that text is
    generic and doesn’t describe how to do this in x86 assembly language.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Test Yourself
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the code that will convert an 8-bit hexadecimal value in AL into two
    hexadecimal digits (in AH and AL)?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many hexadecimal digits will `dToStr` produce?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how to use `qToStr` to write a 128-bit hexadecimal output routine.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction should you use to produce the fastest 64-bit decimal-to-string
    conversion function?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write a signed decimal-to-string conversion if you’re given a function
    that does an unsigned decimal-to-string conversion?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameters for the `utoStrSize` function?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What string will `uSizeToStr` produce if the number requires more print positions
    than specified by the `minDigits` parameter?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the parameters for the `r10ToStr` function?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What string will `r10ToStr` produce if the output won’t fit in the string size
    specified by the `fWidth` argument?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the arguments to the `e10ToStr` function?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a delimiter character?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two possible errors that could occur during a string-to-numeric conversion?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
