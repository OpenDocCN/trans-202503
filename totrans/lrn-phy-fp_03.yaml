- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WRITING BASIC FUNCTIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The function is the central idea of functional programming. In this chapter,
    we’ll learn how to define functions and constants and how to use those functions
    and constants in GHCi. We’ll discuss the language we use to talk about functions,
    and we’ll see how communicating with computers often requires more precision than
    communicating with people. We’ll then introduce Haskell’s system of *anonymous
    functions*, which are functions without a name. After a brief glimpse of Haskell’s
    type system (which we’ll describe more in [Chapter 3](ch03.xhtml)), we’ll show
    how the function composition operator can be used to compose functions. Finally,
    we’ll show the kind of error you get if you use a name that has not been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Constants, Functions, and Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Programming in Haskell is a process of defining functions. Functions express
    to the computer how to calculate something we want. Haskell functions are much
    like mathematical functions: they take inputs and produce an output that depends
    on the inputs. Like mathematical functions, Haskell functions have a domain, describing
    the kind of entities that can be used as input, and a codomain (sometimes called
    range), describing the kind of entities that will be produced as output.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike mathematical functions, Haskell functions must be *constructive*. They
    must give a clear, well-defined recipe for constructing the output from the inputs.
    Abelson and Sussman, in their wonderful book *Structure and Interpretation of
    Computer Programs* [**[3](bib.xhtml#bib3)**], note that the square root function,
    defined as a number that is nonnegative and squares to equal the input, is a perfectly
    legitimate mathematical function. But this definition does not give a recipe for
    how to construct the square root from the input, so it cannot be made into a Haskell
    function. Fortunately, there are other definitions of square root that are constructive
    and can be made into Haskell functions.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to define functions inside GHCi, but since we’ll want to use
    most functions we define more than once, it’s better to define our functions in
    a *source code file*, also called a *program file*, and then load that file into
    GHCi.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need a text editor to create such a file. Examples of popular text editors
    are GNU Emacs, Vim, and gedit.
  prefs: []
  type: TYPE_NORMAL
- en: Word processing programs you might use to type a letter or a document are not
    appropriate for this purpose because they store the text you type with additional
    information (such as font type and size) that will make no sense to the Haskell
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a text editor, let’s create a file named *first.hs* for our first program.
    (The *.hs* extension indicates a Haskell program.) Put the following lines in
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This program file defines a constant and a function. The lines that begin with
    a double hyphen are *comments*. The Haskell compiler ignores any line that begins
    with a double hyphen; in fact, it ignores whatever is written after a double hyphen
    until the end of the line, unless the double hyphen is part of a string or certain
    other special environments. Comments are meant to help humans read the code.
  prefs: []
  type: TYPE_NORMAL
- en: The first two non-comment lines of the file define the constant *e*, the base
    of natural logarithms. Unlike *π*, *e* is not included in the Haskell Prelude.
    The line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: declares the *type* of `e` to be `Double`. A *type* is a description of commonality
    in how entities can be used. Every expression in Haskell has a type, which tells
    the compiler about the situations in which the expression can be used and the
    situations in which it cannot. For example, the `Double` type tells the compiler
    that `e` is an approximation of a real number, sometimes called a floating-point
    number. The name `Double` is used for historical reasons to mean a *double-precision*
    floating-point number. This type of number is capable of about 15 decimal digits
    of precision, compared with a single-precision number that is capable of about
    seven decimal digits of precision. Haskell has a type `Float` for single-precision
    numbers. Unless there is a compelling reason to do otherwise, we’ll always use
    type `Double` for our (approximations of) real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `Double`, there are several other types we might want to use.
    Haskell has a type `Int` for small integers (up to at least a few billion) and
    a type `Integer` for arbitrary-size integers. [Chapter 3](ch03.xhtml) is all about
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to our *first.hs* program file. As we said earlier, the first
    non-comment line of the file declares the type of the name `e` to be `Double`.
    This kind of line, with a name followed by a double colon followed by a type,
    is called a *type signature*. We may also call such a line a *declaration*, because
    it declares the name `e` to have type `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: The second non-comment line of the file actually *defines* `e`. Here, we use
    the built-in function `exp` applied to the number `1` to produce the constant
    `e`. Remember that we don’t need parentheses to apply a function to an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a type signature for the function `square`. The type of `square`
    is declared to be `Double -> Double`. A type containing an arrow is called a *function
    type*. (Function types will be explored in more detail in the next chapter.) It
    says that `square` is a function that takes a `Double` as input and produces a
    `Double` as output. The last line defines the function `square`. Note the `**`
    operator used for exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: To load this program file into GHCi, use GHCi’s `:load` command (`:l` for short).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After we load *first.hs*, the GHCi prompt changes from `Prelude>` to `*Main>`.
    This indicates that our program file has been successfully loaded and given the
    default name `Main`. We now have access to the constant and function defined in
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: The names `e` and `square` defined in the file *first.hs* are examples of *variable
    identifiers* in Haskell. Variable identifiers must begin with a lowercase letter,
    followed by zero or more uppercase letters, lowercase letters, digits, underscores,
    and single quotes. Names that begin with an uppercase letter are reserved for
    types, type classes (which we’ll discuss in [Chapter 8](ch08.xhtml)), and module
    names.
  prefs: []
  type: TYPE_NORMAL
- en: If you forget or don’t know the type of something, you can ask GHCi for the
    type with the `:type` command (`:t` for short).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The notation used for defining a function in Haskell is similar to mathematical
    notation in some ways and different in a few others. Let’s comment on the differences.
    [Table 2-1](ch02.xhtml#ch2tab1) shows a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Comparison of Function Definitions in Traditional Mathematical
    Notation with Function Definitions in Haskell'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mathematical definition** | **Haskell definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *f*(*x*) = *x*³ | `f x = x**3` |'
  prefs: []
  type: TYPE_TB
- en: '| *f*(*x*) = 3*x*² – 4*x* + 5 | `f x = 3 * x**2 - 4 * x + 5` |'
  prefs: []
  type: TYPE_TB
- en: '| *g*(*x*) = cos 2*x* | `g x = cos (2 * x)` |'
  prefs: []
  type: TYPE_TB
- en: '| *v*(*t*) = 10*t* + 20 | `v t = 10 * t + 20` |'
  prefs: []
  type: TYPE_TB
- en: '| *h*(*x*) = *e*^(*–x*) | `h x = exp (-x)` |'
  prefs: []
  type: TYPE_TB
- en: First, notice that traditional mathematical notation (and some computer algebra
    systems) use juxtaposition to represent multiplication. For example, 2*x* means
    2 multiplied by *x*, just because the symbols are next to each other. Haskell
    requires use of the multiplication operator `*`. In Haskell, juxtaposition means
    function application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that traditional mathematical notation requires that function arguments
    be put in parentheses after the function name. This is true for function definitions
    (compare *f* (*x*) = *x*³ with Haskell’s `f x = x**3`) as well as function applications
    (compare *f* (2) with Haskell’s `f 2`). Haskell does not require parentheses in
    function definition or application. Haskell uses parentheses to indicate the order
    of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, traditional mathematical notation tries to get away with single-letter
    function names, such as *f* . Haskell allows single-letter function names, but
    it is much more common to use a multi-letter word for a function name (such as
    `square` above), especially when the word can serve as a good description of what
    the function does.
  prefs: []
  type: TYPE_NORMAL
- en: How We Talk About Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we define a function *f* as *f* (*x*) = *x*² – 3*x* + 2\. It’s common
    in mathematics and physics to speak of “the function *f* (*x*).” Haskell invites
    us to think a bit more carefully and precisely about this bad habit. (Well, it
    really *requires* us to think more carefully about it, but it’s always nicer to
    be invited than required, no?) Instead of saying “the function *f* (*x*),” we
    should say one of the following, depending on what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: The function *f*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value *f* (*x*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a number *x*, the value of the function *f* at *x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third bullet points are two ways of saying the same thing. The
    first bullet point is saying something different from the second and third.
  prefs: []
  type: TYPE_NORMAL
- en: What’s wrong with saying “the function *f* (*x*)?” It’s common in mathematics
    and physics to use “the function *f*” and “the function *f* (*x*)” interchangeably,
    with the second expression merely indicating explicitly that *f* depends on *x*.
    We think of mathematical notation as being a precise representation of an idea,
    but this is a case where the commonly used notation is not precise.
  prefs: []
  type: TYPE_NORMAL
- en: One reason for shunning the language “the function *f* (*x*)” is that if *f*
    (*x*) = *x*² – 3*x* + 2, then *f* (*y*) = ^(*y*2) – 3*y* + 2\. The letter *x*
    really has nothing to do with the function *f* . Granted, we need *some* letter
    to use to make the definition, but it doesn’t matter which one. We call *x* a
    *dummy variable* when it’s used to define something else.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, we say *f* (*x*) when we want to evaluate the function *f* using
    the input *x*. We say *f* when we want to speak about the function itself, not
    evaluate it (that is, not give it any input). What else is there to do with a
    function except give it an input? Well, you could *integrate* the function between
    given limits. You could *differentiate* the function to obtain another function.
    You could, in some cases, apply the function twice. In short, there are many things
    we might want to do with a function other than simply evaluating it.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell’s type system helps us understand the key distinction between *f* and
    *f* (*x*). The variable *x* is a number, so it has a type like `Double`. Now *f*
    is a function, so it has a type like `Double -> Double`. Finally, *f* (*x*) means
    the function *f* evaluated at the number *x*, so *f* (*x*) has type `Double`.
    Things that have type `Double -> Double` are functions. Things that have type
    `Double` are numbers. The table below summarizes these distinctions.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Math notation** | **Haskell notation** | **Haskell type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *f* | `f` | `Double -> Double` |'
  prefs: []
  type: TYPE_TB
- en: '| *f* (3) | `f 3` | `Double` |'
  prefs: []
  type: TYPE_TB
- en: '| *f* (*x*) | `f x` | `Double` |'
  prefs: []
  type: TYPE_TB
- en: Computers are notorious for being inflexible in understanding what a person
    means. Computers look at exactly what you say, and they give warnings and errors
    if your input doesn’t meet their requirements for format and interpretation. Most
    of the time, this is a pain in the neck. We would like to have an assistant that
    understands what we mean and does what we want.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of types and functions, Haskell’s inflexibility is a great
    teaching aid. Haskell is helping us to organize our thinking so we will be prepared
    to do more complex things in a structured and organized way. In [Chapter 6](ch06.xhtml),
    which covers higher-order functions, we’ll see examples of how careful thinking
    about types and functions allows us to encode more complex ideas simply and easily.
  prefs: []
  type: TYPE_NORMAL
- en: When we use Haskell, we make a trade-off. We agree to use language in a precise
    and careful way (the compiler is going to check us on this), and in exchange,
    we’ll be able to say things in the language that are rather complex and difficult
    to say in a language that accommodates imprecision. Thus, we’ll be able expose
    the essential structure of a physical theory like Newtonian mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell provides a way to specify a function without naming it. For example,
    the function that squares its argument can be written as `\x -> x**2`.
  prefs: []
  type: TYPE_NORMAL
- en: A function specified in this way is called an *anonymous function* or a *lambda
    function* after the lambda calculus developed by Alonzo Church in the 1930s. (Church
    was Alan Turing’s PhD advisor.) The backslash character (`\`) was thought by Haskell’s
    creators to look a bit like the lowercase Greek letter lambda (*λ*).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-2](ch02.xhtml#ch2tab2) shows examples of mathematical functions written
    as lambda functions. This is an alternative way to define the functions in [Table
    2-1](ch02.xhtml#ch2tab1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Comparison of Function Definitions in Traditional Mathematical
    Notation with Lambda Functions Defined in Haskell'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mathematical function** | **Haskell lambda function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *f* (*x*) = *x*³ | `f = \x -> x**3` |'
  prefs: []
  type: TYPE_TB
- en: '| *f* (*x*) = 3*x*² – 4*x* + 5 | `f = \x -> 3 * x**2 - 4 * x + 5` |'
  prefs: []
  type: TYPE_TB
- en: '| *g*(*x*) = cos 2*x* | `g = \x -> cos (2 * x)` |'
  prefs: []
  type: TYPE_TB
- en: '| *v*(*t*) = 10*t* + 20 | `v = \t -> 10 * t + 20` |'
  prefs: []
  type: TYPE_TB
- en: '| *h*(*x*) = *e*^(*–x*) | `h = \x -> exp (-x)` |'
  prefs: []
  type: TYPE_TB
- en: The real power of lambda functions comes from using them in places where we
    need a function but don’t want to spend the effort (that is, a declaration and
    a definition) to name a new function. We’ll see examples of how this is useful
    in [Chapter 6](ch06.xhtml), where we discuss higher-order functions that take
    other functions as input. These other functions are sometimes conveniently expressed
    as anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the anonymous squaring function `\x -> x**2` to the argument 3
    by writing `(\x -> x**2) 3` at the GHCi prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we write `\x -> x**2`, we are *not* defining what `x` is. Instead
    we are saying that if we temporarily allow `x` to stand for the argument of the
    function (such as `3` above), we have a rule for determining the value of the
    function applied to the argument. The same remark is true of (named) mathematical
    functions; when we define *f* (*x*) = *x*², this is a definition for *f*, not
    a definition for *x*. The function `\x -> x**2` is the same as the function `\y
    -> y**2`; the variable we use to name the argument is not important. Both are
    the function that squares its argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-3](ch02.xhtml#ch2tab3) shows examples of the application of anonymous
    functions to an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Examples of Applying Anonymous Functions to an Argument'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(\x -> x**2) 3` | ⇝ | 9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\y -> y**2) 3` | ⇝ | 9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\x -> x**3) 3` | ⇝ | 27.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\x -> 3 * x**2 - 4 * x + 5) 3` | ⇝ | 20.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\x -> cos (2 * x)) pi` | ⇝ | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\t -> 10 * t + 20) 3` | ⇝ | 50 |'
  prefs: []
  type: TYPE_TB
- en: '| `(\x -> exp (-x)) (log 2)` | ⇝ | 0.5 |'
  prefs: []
  type: TYPE_TB
- en: These examples can be evaluated at the GHCi prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing cos² *x* is shorthand for (cos *x*)², which means “take the cosine of
    *x* and then square the result.” When we use the output of one function *f* as
    the input to another function *g*, we are *composing* the two functions to produce
    a new function. We write *g* ∘*f*, called *g after f*, for the function that applies
    *f* to its input and then applies *g* to the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/021equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The *function composition operator* (`.`) from [Table 1-2](ch01.xhtml#ch1tab2)
    serves the role that ∘ serves in mathematical notation. The following four functions
    are equivalent ways of defining the cosine squared function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `cosSq`, defines the square of the cosine of a number in
    the most straightforward way. It’s clear from the parentheses that the cosine
    acts on `x` first, and then the function `square` gets applied. The second function,
    `cosSq'`, does the same thing, but it uses the function application operator `$`
    instead of parentheses (see “The Application Operator” in [Chapter 1](ch01.xhtml)
    ). The third function, `cosSq''`, shows how the composition operator can be used
    to compose the functions `square` and `cos`. The expression `square . cos` is
    like the *g* ∘*f* on the left side of Equation 2.1, where `square` plays the role
    of *g* and `cos` plays the role of *f* . The fourth function, `cosSq'''`, shows
    how Haskell lets us define a function without mentioning the argument to which
    it will be applied. Such a definition is called *point-free style*. If *h* is
    the function defined by *h*(*x*) = *g*(*f* (*x*)), mathematical notation allows
    us to alternatively define *h* by *h* = *g* ∘*f*. The function `cosSq''` expresses
    the former definition, and the function `cosSq'''` expresses the latter. If you
    feel the need to define a cosine squared function, any of the four functions would
    be perfectly acceptable. The choice is a matter of style. The last definition
    is my favorite because of its concision.
  prefs: []
  type: TYPE_NORMAL
- en: The definitions just shown are examples of Haskell’s delightful feature of allowing
    tick marks (single quotes) in identifiers. This is nice because it supports our
    mathematical usage of the concise “*x* prime” for something that is related to
    *x*.
  prefs: []
  type: TYPE_NORMAL
- en: The function composition operator can be used between any two functions in which
    the output type of the first function applied matches the input type of the second.
    In practice, the function composition operator often serves as a way to avoid
    naming a new function. If the functions `square` and `cos` are available, there
    is really no need to make any of the four definitions because `square . cos` is
    a perfectly good function that can be used anywhere `cosSq` can be.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Not in Scope Error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the simplest types of error comes from using a name that has not been
    defined. If we ask GHCi for the value of `x` without having defined `x`, we’ll
    get a “Variable not in scope” error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *scope* of a name is the set of situations in which the name can be used
    and properly understood by the compiler. The “Variable not in scope” error might
    be better called “name not recognized.” Any name the compiler expects to recognize
    but doesn’t will produce this error. The error comes from the use of a name we
    haven’t defined or haven’t told the compiler where to find. This applies to functions,
    constants, and local variables (which we will introduce later)—essentially any
    entity that can have a name. Common identifiers, such as `x`, can be reused, and
    there are ways to unambiguously control which `x` we are referring to at a particular
    point in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we saw how to define functions in a source code file and load
    them into GHCi to use them. We showed how anonymous functions can be used in places
    where we need a function but don’t want to name it. The need for and usefulness
    of anonymous functions will become clearer in [Chapter 6](ch06.xhtml). The function
    composition operator can be used to compose any two functions in which the output
    type of the first matches the input type of the second. We saw how a “Variable
    not in scope” error can arise when the computer thinks it should know the meaning
    of a name but doesn’t. In the next chapter, we’ll look more deeply into Haskell’s
    system of types, which provides a powerful tool to organize our thinking and reflect
    that organization in our writing.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 2.1.** In a Haskell program file (a new file with a new name that
    ends in *.hs*), define the function ![Image](Images/023equ01.jpg). As we did for
    the function `square`, give both a type signature and a function definition. Then
    load this file into GHCi and check that *f* (0) gives 1, *f* (1) gives about 1.414,
    and *f* (3) gives 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 2.2.** Consider throwing a rock straight upward from the ground
    at 30 m/s. Ignoring air resistance, find an expression *y*(*t*) for the height
    of the rock as a function of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Add on to your program file *first.hs* by writing a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: that accepts as input the time (after the rock was thrown) in seconds and gives
    as output the height of the rock in meters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 2.3.** Continuing with the rock example, write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: that accepts as input the time (after the rock was thrown) in seconds and gives
    as output the upward velocity of the rock in meters per second. (A downward velocity
    should be returned as a negative number.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 2.4.** Define a function `sinDeg` that computes the sine of an angle
    given in degrees. Test your function by evaluating `sinDeg 30`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 2.5.** Write Haskell function definitions for the following mathematical
    functions. In each case, write a type signature (the type should be `Double ->
    Double` for each function) and a function definition. You will need to pick alternative
    names for some of these functions because Haskell functions must begin with a
    lowercase letter. Do not use more than two levels of nested parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) ![Image](Images/024equ01.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (b) *g*(*y*) = *e^y* + 8^(*y*)
  prefs: []
  type: TYPE_NORMAL
- en: (c) ![Image](Images/024equ02.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (d) ![Image](Images/024equ03.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (e) ![Image](Images/024equ04.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (f) ![Image](Images/024equ05.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (g) ![Image](Images/024equ06.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: (h) ![Image](Images/024equ07.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 2.6.**'
  prefs: []
  type: TYPE_NORMAL
- en: (a) Express ![Image](Images/024equ08.jpg) as an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Write an expression that applies the anonymous function from part (a) to
    the argument 0.8\. What result do you get from GHCi?
  prefs: []
  type: TYPE_NORMAL
