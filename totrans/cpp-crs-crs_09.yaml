- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: EXPRESSIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式**
- en: '*Here is the essence of mankind’s creative genius: not the edifices of civilization
    nor the bang-flash weapons which can end it, but the words which fertilize new
    concepts like spermatozoa attacking an ovum.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这就是人类创造性天才的本质：不是文明的建筑物，也不是可以终结一切的闪光武器，而是像精子攻击卵子的过程一样，滋养新概念的语言。*'
- en: —Dan Simmons,* Hyperion
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Dan Simmons,* 《超越人类》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*Expressions* are computations that produce results and side effects. Generally,
    expressions contain operands and operators that do work on them. A number of operators
    are baked into the core language, and you’ll see a majority of them in this chapter.
    The chapter begins with a discussion of built-in operators before moving on to
    discuss the overloading operator `new` and user-defined literals and then diving
    into an exploration of type conversions. When you create your own user-defined
    types, you’ll often need to describe how these types convert into other types.
    You’ll explore these user-defined conversions before learning about `constexpr`
    constant expressions and the widely misunderstood `volatile` keyword.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*是产生结果和副作用的计算。通常，表达式包含操作数和对其进行操作的运算符。许多运算符被内置在核心语言中，你将在本章中看到大多数运算符。本章开始讨论内置运算符，然后介绍重载运算符`new`、用户定义字面量，并进一步探讨类型转换。当你创建自己的用户定义类型时，通常需要描述这些类型如何转换为其他类型。在学习`constexpr`常量表达式和广泛误解的`volatile`关键字之前，你将探讨这些用户定义的转换。'
- en: '**Operators**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: Operators, such as the addition (`+`) and address-of (`&`) operators, do work
    on arguments called operands, such as numerical values or objects. In this section,
    we’ll look at logical, arithmetic, assignment, increment/decrement, comparison,
    member access, ternary conditional, and comma operators.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符，如加法（`+`）和取地址（`&`）运算符，会对称为操作数的参数进行操作，这些操作数可以是数值或对象。在本节中，我们将介绍逻辑运算符、算术运算符、赋值运算符、增量/减量运算符、比较运算符、成员访问运算符、三元条件运算符和逗号运算符。
- en: '***Logical Operators***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逻辑运算符***'
- en: The C++ expression suite includes a full complement of logical operators. Within
    this category are the (regular) operators AND (`&&`), OR (`||`), and NOT (`!`),
    which take `bool`-convertible operands and return an object of type `bool`. Also,
    *bitwise logical operators* work on integral types like `bool, int`, and `unsigned
    long`. These operators include AND (`&`), OR (`|`), XOR (`^`), complement (`~`),
    left shift (`<<`), and right shift (`>>`). Each performs a Boolean operation at
    the bit level and returns an integral type matching its operands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++表达式套件包括完整的逻辑运算符。在这一类别中，有（常规）运算符与（`&&`）、或（`||`）和非（`!`），它们接受可转换为`bool`的操作数并返回`bool`类型的对象。此外，*按位逻辑运算符*适用于像`bool`、`int`和`unsigned
    long`这样的整数类型。这些运算符包括与（`&`）、或（`|`）、异或（`^`）、取反（`~`）、左移（`<<`）和右移（`>>`）。每个运算符在位级别执行布尔操作，并返回与其操作数匹配的整数类型。
- en: '[Table 7-1](ch07.xhtml#ch07tab01) lists all of these logical operators alongside
    some examples.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7-1](ch07.xhtml#ch07tab01)列出了所有这些逻辑运算符，并附有一些示例。'
- en: '**Table 7-1:** Logical Operators'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 逻辑运算符'
- en: '| **Operator** | **Name** | **Example expression** | **Result** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **名称** | **示例表达式** | **结果** |'
- en: '| `x & y` | Bitwise AND | `0b1100 & 0b1010` | `0b1000` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `x & y` | 按位与 | `0b1100 & 0b1010` | `0b1000` |'
- en: '| `x &#124; y` | Bitwise OR | `0b1100 &#124; 0b1010` | `0b1110` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124; y` | 按位或 | `0b1100 &#124; 0b1010` | `0b1110` |'
- en: '| `x ^ y` | Bitwise XOR | `0b1100 ^ 0b1010` | `0b0110` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `x ^ y` | 按位异或 | `0b1100 ^ 0b1010` | `0b0110` |'
- en: '| `~x` | Bitwise complement | `~0b1010` | `0b0101` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `~x` | 按位取反 | `~0b1010` | `0b0101` |'
- en: '| `x << y` | Bitwise left shift | `0b1010 << 2``0b0011 << 4` | `0b101000``0b110000`
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `x << y` | 按位左移 | `0b1010 << 2``0b0011 << 4` | `0b101000``0b110000` |'
- en: '| `x >> y` | Bitwise right shift | `0b1010 >> 2``0b10110011 >> 4` | `0b10``0b1011`
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `x >> y` | 按位右移 | `0b1010 >> 2``0b10110011 >> 4` | `0b10``0b1011` |'
- en: '| `x && y` | AND | `true && false``true && true` | `false``true` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `x && y` | 与 | `true && false``true && true` | `false``true` |'
- en: '| `x &#124;&#124; y` | OR | `true &#124;&#124; false``false &#124;&#124; false`
    | `true``false` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124;&#124; y` | 或 | `true &#124;&#124; false``false &#124;&#124; false`
    | `true``false` |'
- en: '| `!x` | NOT | `!true``!false` | `false``true` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `!x` | 非 | `!true``!false` | `false``true` |'
- en: '***Arithmetic Operators***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算术运算符***'
- en: Additional unary and binary *arithmetic operators* work with both integral and
    floating-point types (also called the *arithmetic types*). You’ll use built-in
    arithmetic operators wherever you need to perform mathematical computations. They
    perform some of the most basic elements of work, whether you’re incrementing an
    index variable or performing computationally intensive statistical simulations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 Unary 和 Binary *算术运算符* 适用于整数和浮动点类型（也称为 *算术类型*）。在你需要执行数学计算的地方，你会使用内建的算术运算符。它们执行一些最基本的工作元素，无论是递增索引变量还是执行计算密集型的统计模拟。
- en: '**Unary Arithmetic Operators**'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一元算术运算符**'
- en: The *unary plus* `+` and *unary minus* `-` operators take a single arithmetic
    operand. Both operators *promote* their operands to `int`. So, if the operand
    is of type `bool, char`, or `short int`, the result of the expression is an `int`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元加* `+` 和 *一元减* `-` 运算符接受一个算术操作数。两个运算符都将其操作数*提升*为 `int`。因此，如果操作数的类型是 `bool`、`char`
    或 `short int`，则表达式的结果为 `int`。'
- en: Unary plus doesn’t do much besides promotion; unary minus, on the other hand,
    will flip the sign of the operand. For example, given `char x = 10, +x` results
    in an `int` with a value of 10 and `-x` results in an `int` with a value of –10.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一元加除了提升之外没有太多作用；而一元减则会翻转操作数的符号。例如，给定 `char x = 10`，`+x` 会得到一个值为10的 `int`，而 `-x`
    会得到一个值为-10的 `int`。
- en: '**Binary Arithmetic Operators**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**二元算术运算符**'
- en: 'Aside from the two unary arithmetic operators, there are five *binary* arithmetic
    operators: *addition* `+`, *subtraction* `-`, *multiplication* `*`, *division*
    `/`, and *modulo* `%`. These operators take two operands and perform the indicated
    mathematical operation. Like their unary counterparts, these binary operators
    cause integer promotion on their operands. For example, adding two `char` operands
    will result in an `int`. There are floating-point promotion rules, too:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个一元算术运算符外，还有五个*二元*算术运算符：*加法* `+`、*减法* `-`、*乘法* `*`、*除法* `/` 和 *取模* `%`。这些运算符接受两个操作数并执行相应的数学运算。和它们的一元运算符一样，这些二元运算符会对它们的操作数进行整数提升。例如，两个
    `char` 操作数相加将得到一个 `int`。同样也有浮动点提升规则：
- en: If an operand is `long double`, the other operand is promoted to `long double`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `long double`，则另一个操作数将提升为 `long double`。
- en: If an operand is `double`, the other operand is promoted to `double`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `double`，则另一个操作数将提升为 `double`。
- en: If an operand is `float`, the other operand is promoted to `float`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `float`，则另一个操作数将提升为 `float`。
- en: 'If none of the floating-point promotion rules apply, you then check whether
    either argument is signed. If so, both operands become signed. Finally, as with
    the promotion rules for floating-point types, the size of the largest operand
    is used to promote the other operand:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有浮动点提升规则适用，则接下来检查任一操作数是否为带符号。如果是，则两个操作数都变为带符号。最后，和浮动点类型的提升规则一样，较大的操作数的大小将用于提升另一个操作数：
- en: If an operand is `long long`, the other operand is promoted to `long long`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `long long`，则另一个操作数将提升为 `long long`。
- en: If an operand is `long`, the other operand is promoted to `long`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `long`，则另一个操作数将提升为 `long`。
- en: If an operand is `int`, the other operand is promoted to `int`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数是 `int`，则另一个操作数将提升为 `int`。
- en: Although these rules are not too complicated to memorize, I recommend checking
    your work by leaning on `auto` type deduction. Just assign the result of an expression
    to an `auto`-declared variable and check the deduced type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些规则并不太复杂以至于难以记忆，但我建议通过依赖 `auto` 类型推导来检查你的工作。只需将表达式的结果赋值给一个 `auto` 声明的变量，并检查推导出的类型。
- en: Don’t confuse casting and promotion. Casting is when you have an object of one
    type and need to convert it to another type. Promotion is the set of rules for
    interpreting literals. For example, if you have a platform with a 2-byte `short`
    and you performed signed conversion on an `unsigned short` with a value of 40000,
    the result is an integer overflow and undefined behavior. This is entirely different
    from processing promotion rules on the literal 40000\. If it needs to be signed,
    the literal’s type is signed `int`, because a signed `short` is not large enough
    to hold such a value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆类型转换和提升。类型转换是当你有一个某种类型的对象，并需要将其转换为另一种类型时。而提升则是一组规则，用于解释字面值。例如，如果你有一个2字节的
    `short` 类型的平台，并对一个值为40000的 `unsigned short` 进行了有符号转换，结果会是整数溢出和未定义行为。这与对字面量40000进行提升规则处理完全不同。如果它需要带符号，则字面量的类型是带符号的
    `int`，因为带符号的 `short` 不能容纳这么大的值。
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use your IDE or even RTTI’s `*typeid*` to print the type to console.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用你的IDE，甚至是RTTI的`*typeid*`来打印类型到控制台。*'
- en: '[Table 7-2](ch07.xhtml#ch07tab02) summarizes the arithmetic operators.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 7-2](ch07.xhtml#ch07tab02)总结了算术运算符。'
- en: '**Table 7-2:** Arithmetic Operators'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 7-2：** 算术运算符'
- en: '| **Operator** | **Name** | **Examples** | **Result** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **名称** | **示例** | **结果** |'
- en: '| `+x` | Unary plus | `+10` | `10` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `+x` | 一元加法 | `+10` | `10` |'
- en: '| `-x` | Unary minus | `-10` | `-10` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `-x` | 一元减法 | `-10` | `-10` |'
- en: '| `x + y` | Binary addition | `1 + 2` | `3` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `x + y` | 二进制加法 | `1 + 2` | `3` |'
- en: '| `x - y` | Binary subtraction | `1 - 2` | `-1` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `x - y` | 二进制减法 | `1 - 2` | `-1` |'
- en: '| `x * y` | Binary multiplication | `10 * 20` | `200` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `x * y` | 二进制乘法 | `10 * 20` | `200` |'
- en: '| `x / y` | Binary division | `300 / 15` | `20` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `x / y` | 二进制除法 | `300 / 15` | `20` |'
- en: '| `x % y` | Binary modulo | `42 % 5` | `2` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `x % y` | 二进制模运算 | `42 % 5` | `2` |'
- en: Many of the binary operators in [Tables 7-1](ch07.xhtml#ch07tab01) and [7-2](ch07.xhtml#ch07tab02)
    have corollary as *assignment operators* as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表格 7-1](ch07.xhtml#ch07tab01)和[表格 7-2](ch07.xhtml#ch07tab02)中，许多二进制运算符也有相应的*赋值运算符*。
- en: '***Assignment Operators***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***赋值运算符***'
- en: An assignment operator performs a given operation and then assigns the result
    to the first operand. For example, the *addition assignment* `x += y` computes
    the value `x + y` and assigns `x` equal to the result. You can achieve similar
    results with the expression `x = x + y`, but the *assignment operator* is more
    syntactically compact and at least as runtime efficient. [Table 7-3](ch07.xhtml#ch07tab03)
    summarizes all of the available assignment operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符执行指定的操作，然后将结果赋值给第一个操作数。例如，*加法赋值* `x += y` 计算值 `x + y` 并将 `x` 赋值为结果。你也可以使用表达式
    `x = x + y` 达到类似的效果，但*赋值运算符*语法更简洁，且至少在运行时效率更高。[表格 7-3](ch07.xhtml#ch07tab03)总结了所有可用的赋值运算符。
- en: '**Table 7-3:** Assignment Operators'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 7-3：** 赋值运算符'
- en: '| **Operator** | **Name** | **Examples** | **Result (value of x)** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **名称** | **示例** | **结果（x的值）** |'
- en: '| `x = y` | Simple assignment | `x = 10` | `10` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `x = y` | 简单赋值 | `x = 10` | `10` |'
- en: '| `x += y` | Addition assignment | `x += 10` | `15` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `x += y` | 加法赋值 | `x += 10` | `15` |'
- en: '| `x -= y` | Subtraction assignment | `x -= 10` | `-5` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `x -= y` | 减法赋值 | `x -= 10` | `-5` |'
- en: '| `x *= y` | Multiplication assignment | `x *= 10` | `50` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `x *= y` | 乘法赋值 | `x *= 10` | `50` |'
- en: '| `x /= y` | Division assignment | `x /= 2` | `2` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `x /= y` | 除法赋值 | `x /= 2` | `2` |'
- en: '| `x %= y` | Modulo assignment | `x %= 2` | `1` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `x %= y` | 模运算赋值 | `x %= 2` | `1` |'
- en: '| `x &= y` | Bitwise *AND* assignment | `x &= 0b1100` | `0b0100` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `x &= y` | 位运算*与*赋值 | `x &= 0b1100` | `0b0100` |'
- en: '| `x &#124;= y` | Bitwise *OR* assignment | `x &#124;= 0b1100` | `0b1101` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `x &#124;= y` | 位运算*或*赋值 | `x &#124;= 0b1100` | `0b1101` |'
- en: '| `x ^= y` | Bitwise *XOR* assignment | `x ^= 0b1100` | `0b1001` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `x ^= y` | 位运算*异或*赋值 | `x ^= 0b1100` | `0b1001` |'
- en: '| `x <<= y` | Bitwise *left-shift* assignment | `x <<= 2` | `0b10100` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `x <<= y` | 位运算*左移*赋值 | `x <<= 2` | `0b10100` |'
- en: '| `x >>= y` | Bitwise *right-shift* assignment | `x >>= 2` | `0b0001` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `x >>= y` | 位运算*右移*赋值 | `x >>= 2` | `0b0001` |'
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Promotion rules don’t really apply when using assignment operators; the type
    of the assigned to operand won’t change. For example, given int `x = 5`, the type
    of `x` after `x /= 2.0f` is still `int`.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用赋值运算符时，提升规则并不适用；被赋值操作数的类型不会改变。例如，给定 `int x = 5`，在 `x /= 2.0f` 之后，`x` 的类型仍然是
    `int`。*'
- en: '***Increment and Decrement Operators***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增量和减量运算符***'
- en: There are four (unary) *increment*/*decrement* operators, as outlined in [Table
    7-4](ch07.xhtml#ch07tab04).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表格 7-4](ch07.xhtml#ch07tab04)中列出了四个（一元）*增量*/*减量*运算符。
- en: '**Table 7-4:** The Increment and Decrement Operators (values given for `x=5`)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 7-4：** 增量和减量运算符（给定 `x=5` 的值）'
- en: '| Operator | Name | Value of x after evaluation | Value of expression |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 | 计算后x的值 | 表达式的结果 |'
- en: '| `++x` | Prefix increment | `6` | `6` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `++x` | 前缀增量 | `6` | `6` |'
- en: '| `x++` | Postfix increment | `6` | `5` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `x++` | 后缀增量 | `6` | `5` |'
- en: '| `--x` | Prefix decrement | `4` | `4` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `--x` | 前缀减量 | `4` | `4` |'
- en: '| `x--` | Postfix decrement | `4` | `5` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `x--` | 后缀减量 | `4` | `5` |'
- en: As [Table 7-4](ch07.xhtml#ch07tab04) shows, increment operators increase the
    value of their operand by 1, whereas decrement operators decrease by 1\. The value
    returned by the operator depends on whether it is prefix or postfix. A prefix
    operator will return the value of the operand after modification, whereas a postfix
    operator will return the value before modification.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [表 7-4](ch07.xhtml#ch07tab04) 所示，自增运算符将操作数的值增加 1，而自减运算符则减少 1。运算符返回的值取决于它是前缀还是后缀运算符。前缀运算符将在修改后返回操作数的值，而后缀运算符则会在修改前返回操作数的值。
- en: '***Comparison Operators***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较运算符***'
- en: Six comparison operators compare the given operands and evaluate to a `bool`,
    as outlined in [Table 7-5](ch07.xhtml#ch07tab05). For arithmetic operands, the
    same type conversions (promotions) occur as with the arithmetic operators. The
    comparison operators also work with pointers, and they work approximately how
    you would expect them to.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 六个比较运算符比较给定的操作数并计算为 `bool`，如 [表 7-5](ch07.xhtml#ch07tab05) 所述。对于算术操作数，与算术运算符相同的类型转换（提升）会发生。比较运算符也适用于指针，并且它们的工作方式大致符合你的预期。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are some nuances to pointer comparison. Interested readers should refer
    to [expr.rel].*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针比较有一些细微差别。有兴趣的读者可以参阅 [expr.rel].*'
- en: '**Table 7-5:** The Comparison Operators'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-5：** 比较运算符'
- en: '| **Operator** | **Name** | **Examples (all evaluate to true)** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **名称** | **示例（均评估为真）** |'
- en: '| `x == y` | Equal-to operator | `100 == 100` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | 等于运算符 | `100 == 100` |'
- en: '| `x != y` | Not-equal-to operator | `100 != 101` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `x != y` | 不等于运算符 | `100 != 101` |'
- en: '| `x < y` | Less-than operator | `10 < 20` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `x < y` | 小于运算符 | `10 < 20` |'
- en: '| `x > y` | Greater-than operator | `-10 > -20` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `x > y` | 大于运算符 | `-10 > -20` |'
- en: '| `x <= y` | Less-than-or-equal-to operator | `10 <= 10` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `x <= y` | 小于或等于运算符 | `10 <= 10` |'
- en: '| `x >= y` | Greater-than-or-equal-to operator | `20 >= 10` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `x >= y` | 大于或等于运算符 | `20 >= 10` |'
- en: '***Member Access Operators***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员访问运算符***'
- en: You use *member access operators* to interact with pointers, arrays, and many
    of the classes you’ll meet in [Part II](part02.xhtml#part02). The six such operators
    include *subscript* `[]`, *indirection* `*`, *address-of* `&`, *member-of-object*
    `.`, and *member-of-pointer* `->`. You met these operators in [Chapter 3](ch03.xhtml#ch03),
    but this section provides a brief summary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 *成员访问运算符* 与指针、数组及你将在 [第二部分](part02.xhtml#part02) 中遇到的许多类进行交互。六个这样的运算符包括
    *下标* `[]`、*间接* `*`、*取地址* `&`、*对象成员* `.` 和 *指针成员* `->`。你在 [第三章](ch03.xhtml#ch03)
    中已经遇到过这些运算符，但本节提供了简要总结。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are also* pointer-to-member-of-object .* *and* pointer-to-member-of-pointer
    ->* *operators, but these are uncommon. Refer to [expr.mptr.oper]*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*也有* 指向对象成员的指针。*和* 指向指针成员的指针 ->* *运算符，但这些并不常见。请参阅 [expr.mptr.oper]*。'
- en: The subscript operator `x[y]` provides access to the `y`th element of the array
    pointed to by `x`, whereas the indirection operator `*x` provides access to the
    element pointed to by `x`. You can create a pointer to an element `x` using the
    address-of operator `&x`. This is essentially the inverse operation to the indirection
    operator. For elements `x` with a member `y`, you use the member-of-object operator
    `x.y`. You can also access members of a pointed-to object; given a pointer `x`,
    you use the member-of-pointer operator `x->y` to access an object pointed to by
    `x`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下标运算符 `x[y]` 提供对由 `x` 指向的数组的第 `y` 个元素的访问，而间接运算符 `*x` 提供对 `x` 指向的元素的访问。你可以使用取地址运算符
    `&x` 创建一个指向元素 `x` 的指针。这本质上是间接运算符的反操作。对于有成员 `y` 的元素 `x`，你使用对象成员运算符 `x.y`。你也可以访问指向对象的成员；给定一个指针
    `x`，你使用指针成员运算符 `x->y` 访问 `x` 指向的对象。
- en: '***Ternary Conditional Operator***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三元条件运算符***'
- en: 'The *ternary conditional operator* `x ? y : z` is a lump of syntactic sugar
    that takes three operands (hence “ternary”). It evaluates the first operand `x`
    as a Boolean expression and returns the second operand `y` or the third operand
    `z` depending on whether the Boolean is `true` or `false` (respectively). Consider
    the following step function that returns 1 if the parameter `input` is positive;
    otherwise, it returns zero:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*三元条件运算符* `x ? y : z` 是一种语法糖，接受三个操作数（因此是“三元”）。它将第一个操作数 `x` 作为布尔表达式进行求值，并根据布尔值是否为
    `true` 或 `false`（分别）返回第二个操作数 `y` 或第三个操作数 `z`。考虑以下返回 1 的步进函数，当参数 `input` 为正时；否则返回零：'
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using an equivalent if-then statement, you could also implement `step` the
    following way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等效的 if-then 语句，你也可以以下列方式实现 `step`：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two approaches are runtime equivalent, but the ternary conditional operator
    requires less typing and usually results in cleaner code. Use it generously.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在运行时是等效的，但三元条件运算符需要的输入较少，通常会产生更简洁的代码。请大胆使用它。
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The conditional ternary operator has a more fashionable moniker: the* Elvis
    operator. *If you rotate the book 90 degrees clockwise and squint, you’ll see
    why: `?:`*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件三元运算符有一个更时髦的名字：* Elvis 运算符。*如果你将书顺时针旋转90度并眯起眼睛，你会明白为什么：`?:`*'
- en: '***The Comma Operator***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逗号运算符***'
- en: The *comma operator*, on the other hand, doesn’t usually promote cleaner code.
    It allows several expressions separated by commas to be evaluated within a larger
    expression. The expressions evaluate from left to right, and the rightmost expression
    is the return value, as [Listing 7-1](ch07.xhtml#ch07ex01) illustrates.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*逗号运算符*，另一方面，通常不会促进更简洁的代码。它允许在一个更大的表达式内，多个由逗号分隔的表达式进行求值。这些表达式从左到右求值，最右边的表达式是返回值，正如[清单7-1](ch07.xhtml#ch07ex01)所示。'
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-1: A confusing function employing the comma operator*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-1：一个使用逗号运算符的令人困惑的函数*'
- en: After invoking `confusing, x` equals `10` ➊ and `y` equals `5` ➋.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`confusing`后，`x`等于`10` ➊，`y`等于`5` ➋。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A vestigial structure from C’s wilder and altogether less-inhibited college
    days, the comma operator permits a particular kind of expression-oriented programming.
    Eschew the comma operator; its use is exceedingly uncommon and likely to sow confusion.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是C语言在大学时代更加狂野、没有拘束的结构遗留物，逗号运算符允许一种特定类型的面向表达式的编程。避免使用逗号运算符；它的使用非常罕见，且容易引起混乱。*'
- en: '***Operator Overloading***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运算符重载***'
- en: For each fundamental type, some portion of the operators covered in this section
    will be available. For user-defined types, you can specify custom behavior for
    these operators by employing *operator overloading*. To specify behavior for an
    operator in a user-defined class, simply name the method with the word `operator`
    immediately followed by the operator; ensure that the return types and parameters
    match the types of the operands you want to deal with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种基本类型，本节中涵盖的某些运算符将可用。对于用户定义的类型，你可以通过使用*运算符重载*来指定这些运算符的自定义行为。要为用户定义的类指定运算符的行为，只需将方法命名为`operator`后面紧跟运算符；确保返回类型和参数与要处理的操作数类型匹配。
- en: '[Listing 7-2](ch07.xhtml#ch07ex02) defines a `CheckedInteger`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单7-2](ch07.xhtml#ch07ex02)定义了一个`CheckedInteger`。'
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-2: A `CheckedInteger` class that detects overflow at runtime*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-2：一个`CheckedInteger`类，它在运行时检测溢出*'
- en: In this class, you’ve defined a constructor that takes a single `unsigned int`.
    This argument is used ➊ to member initialize the public field `value` ➎. Because
    `value` is `const, CheckedInteger` is *immutable*—after construction, it’s not
    possible to modify the state of a `CheckedInteger`. The method of interest here
    is `operator+` ➋, which allows you to add an ordinary `unsigned int` to a `CheckedInteger`
    to produce a new `CheckedInteger` with the correct `value`. The return value of
    `operator+` is constructed at ➌. Whenever addition results in the overflow of
    an `unsigned int`, the result will be less than the original values. You check
    for this condition at ➍. If an overflow is detected, you throw an exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，你定义了一个构造函数，它接受一个`unsigned int`。这个参数被用来➊初始化公共字段`value` ➎。因为`value`是`const`，`CheckedInteger`是*不可变的*——构造后，不能修改`CheckedInteger`的状态。这里感兴趣的方法是`operator+`
    ➋，它允许你将一个普通的`unsigned int`加到`CheckedInteger`上，从而生成一个具有正确`value`的新`CheckedInteger`。`operator+`的返回值在➌构造。每当加法导致`unsigned
    int`溢出时，结果将小于原始值。你在➍检查这个条件。如果检测到溢出，就会抛出异常。
- en: '[Chapter 6](ch06.xhtml) described `type_traits`, which allow you to determine
    features of your types at compile time. A related family of type support is available
    in the `<limits>` header, which allows you to query various properties of arithmetic
    types.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](ch06.xhtml)描述了`type_traits`，它允许你在编译时确定类型的特征。一个相关的类型支持家族可以在`<limits>`头文件中找到，它允许你查询算术类型的各种属性。'
- en: Within `<limits>`, the template class `numeric_limits` exposes a number of member
    constants that provide information about the template parameter. One such example
    is the `max()` method, which returns the highest finite value of a given type.
    You can use this method to kick the tires of the `CheckedInteger` class. [Listing
    7-3](ch07.xhtml#ch07ex03) illustrates the behavior of the `CheckedInteger`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<limits>` 中，模板类 `numeric_limits` 提供了多个成员常量，用于获取模板参数的相关信息。其中一个例子是 `max()`
    方法，它返回给定类型的最大有限值。你可以使用这个方法来测试 `CheckedInteger` 类。[列表 7-3](ch07.xhtml#ch07ex03)
    展示了 `CheckedInteger` 的行为。
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-3: A program illustrating the use of `CheckedInteger`*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-3：一个演示 `CheckedInteger` 使用的程序*'
- en: After constructing a `CheckedInteger` ➊, you can add it to an `unsigned int`
    ➋. Because the resulting value, 300, is guaranteed to fit inside an `unsigned
    int`, this statement executes without throwing an exception. Next, you add the
    same `CheckedInteger a` to the maximum value of an `unsigned int` via `numeric_limits`
    ➌. This causes an overflow, which is detected by the `operator+` overload and
    results in a thrown `overflow_error`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造 `CheckedInteger` ➊ 后，你可以将其与 `unsigned int` ➋ 相加。由于结果值 300 可以确保适合 `unsigned
    int`，此语句会在不抛出异常的情况下执行。接下来，你将相同的 `CheckedInteger a` 加到 `unsigned int` 的最大值上（通过
    `numeric_limits`） ➌。这会导致溢出，`operator+` 的重载会检测到这一点，并抛出 `overflow_error` 异常。
- en: '***Overloading Operator new***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重载 Operator new***'
- en: Recall from [Chapter 4](ch04.xhtml#ch04) that you allocate objects with dynamic
    storage duration using operator `new`. By default, operator `new` will allocate
    memory on the free store to make space for your dynamic objects. The *free store*,
    also known as the *heap*, is an implementation-defined storage location. On desktop
    operating systems, the kernel usually manages the free store (see the `HeapAlloc`
    on Windows and `malloc` on Linux and macOS) and is generally vast.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾 [第 4 章](ch04.xhtml#ch04)，你可以使用 `new` 运算符来分配具有动态存储持续时间的对象。默认情况下，`new` 运算符会在自由存储上分配内存，以为你的动态对象腾出空间。*自由存储*，也叫
    *堆*，是一个由实现定义的存储位置。在桌面操作系统中，内核通常管理自由存储（例如，Windows 上的 `HeapAlloc` 和 Linux/macOS
    上的 `malloc`），且通常非常庞大。
- en: '**Free Store Availability**'
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自由存储可用性**'
- en: In some environments, like the Windows kernel or embedded systems, there is
    no free store available to you by default. In other settings, such as game development
    or high-frequency trading, free store allocations simply involve too much latency,
    because you’ve delegated its management to the operating system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，比如 Windows 内核或嵌入式系统，默认情况下没有自由存储可用。在其他场景中，例如游戏开发或高频交易，自由存储分配的延迟太大，因为你将其管理交给了操作系统。
- en: You could try to avoid using the free store entirely, but this is severely limiting.
    One major limitation this would introduce is to preclude the use of stdlib containers,
    which after reading [Part II](part02.xhtml#part02) you’ll agree is a major loss.
    Rather than settling for these severe restrictions, you can overload the free
    store operations and take control over allocations. You do this by overloading
    operator `new`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试完全避免使用自由存储，但这样会带来严重限制。其中一个主要的限制是无法使用标准库容器，阅读 [第二部分](part02.xhtml#part02)
    后，你会同意这是一个巨大的损失。与其接受这些严格限制，不如重载自由存储操作，掌控内存分配。你可以通过重载 `new` 运算符来实现这一点。
- en: '**The <new> Header**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**<new> 头文件**'
- en: 'In environments that support free store operations, the `<new>` header contains
    the following four operators:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持自由存储操作的环境中，`<new>` 头文件包含以下四个运算符：
- en: '`void* operator new(size_t);`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void* operator new(size_t);`'
- en: '`void operator delete(void*);`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void operator delete(void*);`'
- en: '`void* operator new[](size_t);`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void* operator new[](size_t);`'
- en: '`void operator delete[](void*);`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void operator delete[](void*);`'
- en: Notice that the return type of operator `new` is `void*`. The free store operators
    deal in raw, uninitialized memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`new` 运算符的返回类型是 `void*`。自由存储运算符处理的是原始、未初始化的内存。
- en: It’s possible to provide your own versions of these four operators. All you
    do is define them once in your program. The compiler will use your versions rather
    than the defaults.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供这四个运算符的自定义版本。你只需要在程序中定义一次，编译器将使用你的版本而不是默认版本。
- en: Free store management is a surprisingly complicated task. One of the major issues
    is *memory fragmentation*. Over time, large numbers of memory allocations and
    releases can leave free blocks of memory scattered throughout the region dedicated
    for the free store. It’s possible to get into situations where there is plenty
    of free memory, but it’s scattered across allocated memory. When this happens,
    large requests for memory will fail, even though there is technically enough free
    memory to provide to the requester. [Figure 7-1](ch07.xhtml#ch07fig01) illustrates
    such a situation. There is plenty of memory for the desired allocation, but the
    available memory is noncontiguous.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自由存储管理是一个令人惊讶的复杂任务。一个主要问题是 *内存碎片化*。随着时间的推移，大量的内存分配和释放可能会导致自由存储区域中散布着许多空闲的内存块。这可能导致某些情况，虽然有大量的空闲内存，但它们分散在已经分配的内存区域中。当这种情况发生时，大的内存请求会失败，尽管从技术上讲，空闲内存足够提供给请求者。[图
    7-1](ch07.xhtml#ch07fig01)展示了这种情况。所需的内存分配有足够的内存，但可用内存是非连续的。
- en: '![image](../images/fig7_1.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig7_1.jpg)'
- en: '*Figure 7-1: The memory fragmentation problem*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：内存碎片化问题*'
- en: '**Buckets**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**桶**'
- en: 'One approach is to chop allocated memory into so-called *buckets* of a fixed
    size. When you request memory, the environment allocates a whole bucket, even
    if you didn’t request all the memory. For example, Windows provides two functions
    for allocating dynamic memory: `VirtualAllocEx` and `HeapAlloc`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将分配的内存划分为所谓的 *桶*，每个桶的大小是固定的。当你请求内存时，环境会分配整个桶，即使你没有请求全部的内存。例如，Windows 提供了两个函数来分配动态内存：`VirtualAllocEx`
    和 `HeapAlloc`。
- en: The `VirtualAllocEx` function is low level, which allows you to provide many
    options, such as which process to allocate memory into, the preferred memory address,
    the requested size, and permissions, like whether the memory should be readable,
    writable, and executable. This function will never allocate fewer than 4096 bytes
    (a so-called *page*).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAllocEx` 函数是低级的，它允许你提供许多选项，例如将内存分配到哪个进程、首选的内存地址、请求的大小以及权限，比如内存是否应该是可读、可写和可执行的。该函数永远不会分配少于
    4096 字节（一个所谓的 *页*）。'
- en: On the other hand, `HeapAlloc` is a higher-level function that hands out less
    than a page of memory when it can; otherwise, it will invoke `VirtualAllocEx`
    on your behalf. At least with the Visual Studio compiler, `new` will call `HeapAlloc`
    by default.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`HeapAlloc` 是一个较高级的函数，当可以时，它分配少于一页的内存；否则，它会代表你调用 `VirtualAllocEx`。至少在 Visual
    Studio 编译器中，`new` 默认会调用 `HeapAlloc`。
- en: This arrangement prevents memory fragmentation in exchange for some overhead
    associated with rounding up allocations to bucket size. Modern operating systems
    like Windows will have fairly complex schemes for allocating memory of different
    sizes. You don’t see any of this complexity unless you want to take control.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排通过对内存分配进行桶大小的四舍五入来避免内存碎片化，但需要一些附加开销。像 Windows 这样的现代操作系统将有相当复杂的内存分配方案，支持不同大小的内存分配。除非你想要控制，否则你不会看到这些复杂性。
- en: '**Taking Control of the Free Store**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制自由存储**'
- en: '[Listing 7-4](ch07.xhtml#ch07ex04) demonstrates implementing very simple `Bucket`
    and `Heap` classes. These will facilitate taking control over dynamic memory allocation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](ch07.xhtml#ch07ex04)演示了如何实现非常简单的 `Bucket` 和 `Heap` 类。这些类将帮助控制动态内存分配：'
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-4: `Heap` and `Bucket` classes*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：`Heap` 和 `Bucket` 类*'
- en: The `Bucket` class ➊ is responsible for taking up space in memory. As an homage
    to the Windows heap manager, the bucket size is hardcoded to 4096\. All of the
    management logic goes into the `Heap` class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bucket` 类 ➊ 负责占用内存空间。作为对 Windows 堆管理器的致敬，桶的大小被硬编码为 4096。所有的管理逻辑都集中在 `Heap`
    类中。'
- en: 'Two important accounting members are in `Heap`: `buckets` ➍ and `bucket_used`
    ➎. The `buckets` member houses all the `Buckets`, neatly packed into a contiguous
    string. The `bucket_used` member is a relatively tiny array containing objects
    of type `bool` that keeps track of whether a `Bucket` in `buckets` with the same
    index has been loaned out yet. Both members are initialized to zero.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Heap` 中有两个重要的成员：`buckets` ➍ 和 `bucket_used` ➎。`buckets` 成员存放所有的 `Buckets`，这些
    `Buckets` 被紧凑地打包成一个连续的字符串。`bucket_used` 成员是一个相对较小的数组，包含 `bool` 类型的对象，用来跟踪 `buckets`
    中同一索引的 `Bucket` 是否已经被借出。两个成员都初始化为零。'
- en: 'The `Heap` class has two methods: `allocate` ➋ and `free` ➌. The `allocate`
    method first checks whether the number of bytes requested is greater than the
    bucket size. If it is, it throws a `std::bad_alloc` exception. Once the size check
    passes, `Heap` iterates through the `buckets` looking for one that isn’t marked
    `true` in `bucket_used`. If it finds one, it returns the `data` member pointer
    for the associated `Bucket`. If it can’t find an unused `Bucket`, it throws a
    `std::bad_alloc` exception. The `free` method accepts a `void*` and iterates through
    all the `buckets` looking for a matching `data` member pointer. If it finds one,
    it sets `bucket_used` for the corresponding bucket to `false` and returns.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Heap` 类有两个方法：`allocate` ➋ 和 `free` ➌。`allocate` 方法首先检查请求的字节数是否大于桶的大小。如果是，它会抛出一个
    `std::bad_alloc` 异常。一旦大小检查通过，`Heap` 会遍历 `buckets`，寻找一个在 `bucket_used` 中没有标记为 `true`
    的桶。如果找到了，它会返回与该 `Bucket` 关联的 `data` 成员指针。如果找不到未使用的 `Bucket`，它会抛出一个 `std::bad_alloc`
    异常。`free` 方法接受一个 `void*` 并遍历所有的 `buckets`，寻找匹配的 `data` 成员指针。如果找到了，它会将对应桶的 `bucket_used`
    设置为 `false` 并返回。'
- en: '**Using Our Heap**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用我们的堆**'
- en: One way to allocate a `Heap` is to declare it at namespace scope so it has static
    storage duration. Because its lifetime begins when the program starts, you can
    use it inside the `operator new` and `operator delete` overrides, as shown in
    [Listing 7-5](ch07.xhtml#ch07ex05).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个 `Heap` 的一种方式是将其声明为命名空间作用域内的对象，这样它就具有静态存储持续时间。因为它的生命周期从程序启动时就开始，所以你可以在 `operator
    new` 和 `operator delete` 重载中使用它，正如 [示例 7-5](ch07.xhtml#ch07ex05) 中所示。
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-5: Overriding the `new` and `delete` operators to use the `Heap`
    class from [Listing 7-4](ch07.xhtml#ch07ex04)*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-5：重载 `new` 和 `delete` 运算符以使用 [示例 7-4](ch07.xhtml#ch07ex04) 中的 `Heap`
    类*'
- en: '[Listing 7-5](ch07.xhtml#ch07ex05) declares a `Heap` ➊ and uses it inside the
    operator `new` overload ➋ and the operator `delete` overload ➌. Now if you use
    `new` and `delete`, dynamic memory management will use `heap` instead of the default
    free store offered by the environment. [Listing 7-6](ch07.xhtml#ch07ex06) kicks
    the tires of the overloaded dynamic memory management.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-5](ch07.xhtml#ch07ex05) 声明了一个 `Heap` ➊ 并在 `new` 运算符重载 ➋ 和 `delete` 运算符重载
    ➌ 中使用它。现在，如果你使用 `new` 和 `delete`，动态内存管理将使用 `heap`，而不是环境提供的默认自由存储。[示例 7-6](ch07.xhtml#ch07ex06)
    测试了重载的动态内存管理。'
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-6: A program illustrating the use of `Heap` to manage dynamic allocations*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6：演示使用 `Heap` 管理动态分配的程序*'
- en: You’ve printed the memory address of the first `buckets` element of the `heap`
    ➊. This is the memory location loaned out to the first `new` invocation. You verify
    that this is the case by printing the memory address and value pointed to by `breakfast`
    ➋. Notice that the memory address matches the memory address of the first `Bucket`
    in `heap`. You’ve done the same for the memory pointed to by `dinner` ➌. Notice
    that the memory address is exactly `0x1000` greater than that of `breakfast`.
    This coincides exactly with the 4096-byte length of a `Bucket`, as defined in
    the `const static` member `Bucket::data_size`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经打印出了 `heap` 中第一个 `buckets` 元素的内存地址 ➊。这是借给第一个 `new` 调用的内存位置。通过打印 `breakfast`
    ➋ 的内存地址和指向的值，你验证了这一点。注意，内存地址与 `heap` 中第一个 `Bucket` 的内存地址相同。你对 `dinner` ➌ 指向的内存做了同样的操作。注意，内存地址比
    `breakfast` 的内存地址大正好 `0x1000`。这与 `Bucket` 的 4096 字节大小完全一致，正如 `const static` 成员
    `Bucket::data_size` 中定义的那样。
- en: After printing printing ➋➌, you delete `breakfast` and `dinner`. Then, you allocate
    `char` objects with reckless abandon until a `std::bad_alloc` is thrown when `heap`
    runs out of memory. Each time you make an allocation, you print `Allocated` a
    `char`. starting at ➍. There are 10 lines before you see a `std::bad_alloc` exception
    ➎. Notice that this is exactly the number of `buckets` you’ve set in `Heap::n_heap_buckets`.
    This means that, for each `char` you’ve allocated, you’ve taken up 4096 bytes
    of memory!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印了 ➋➌ 后，你删除了 `breakfast` 和 `dinner`。然后，你不加节制地分配 `char` 对象，直到 `heap` 内存用尽并抛出
    `std::bad_alloc` 异常为止。每次分配时，你都会打印出 `Allocated` 一个 `char`，从 ➍ 开始。你会看到，在出现 `std::bad_alloc`
    异常 ➎ 之前，总共有 10 行。注意，这正好是你在 `Heap::n_heap_buckets` 中设置的 `buckets` 数量。这意味着，每分配一个
    `char`，你就占用了 4096 字节的内存！
- en: '**Placement Operators**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定位运算符**'
- en: 'Sometimes, you don’t want to override *all* free store allocations. In such
    situations, you can use the placement operators, which perform the appropriate
    initialization on preallocated memory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不想覆盖*所有*的自由存储分配。在这种情况下，你可以使用定位运算符，它们对预分配的内存执行适当的初始化：
- en: '`void* operator new(size_t, void*);`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void* operator new(size_t, void*);`'
- en: '`void operator delete(size_t, void*);`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void* operator new[](void*, void*);`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void operator delete[](void*, void*);`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using placement operators, you can manually construct objects in arbitrary memory.
    This has the advantage of enabling you to manually manipulate an object’s lifetime.
    However, you cannot use `delete` to release the resulting dynamic objects. You
    must call the object’s destructor directly (and exactly once!), as demonstrated
    in [Listing 7-7](ch07.xhtml#ch07ex07).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-7: Using placement `new` to initialize dynamic objects*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The constructor ➊ prints a message indicating that a `Point` at a particular
    address was constructed, and the destructor ➋ prints a corresponding message indicating
    that the `Point` is getting destructed. You’ve printed the address of `data`,
    which is the first address where placement `new` initializes a `Point` ➌.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Observe that each placement `new` has allocated the `Point` within the memory
    occupied by your `data` array ➍➎➏. You must invoke each destructor individually
    ➐➑➒.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '***Operator Precedence and Associativity***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When more than one operator appears in an expression, *operator precedence*
    and *operator associativity* decide how the expression parses. Operators with
    higher precedence are bound tighter to their arguments than operators with lower
    precedence. If two operators have the same precedence, their associativity breaks
    the tie to decide how arguments bind. Associativity is either *left to right*
    or *right to left*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-6](ch07.xhtml#ch07tab06) contains every C++ operator sorted by its
    precedence and annotated with its associativity. Each row contains one or more
    operators with the same precedence along with a description and its associativity.
    Higher rows have higher precedence.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-6:** Operator Precedence and Associativity'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Associativity** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `a::b` | Scope resolution | Left to right |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `a++` | Postfix increment | Left to right |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `a--` | Postfix decrement |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `fn()` | Function call |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `a[b]` | Subscript |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `a->b` | Member of pointer |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `a.b` | Member of object |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `Type(a)` | Functional cast |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `Type{ a }` | Functional cast |  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `++a` | Prefix increment | Right to left |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `--a` | Prefix decrement |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `+a` | Unary plus |  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Unary minus |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `!a` | Logical NOT |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `~a` | Bitwise complement |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `(Type)a` | C-style cast |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `*a` | Dereference |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `&a` | Address of |  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `sizeof(Type)` | Size of |  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `new Type` | Dynamic allocation |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `new Type[]` | Dynamic allocation (array) |  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `delete a` | Dynamic deallocation |  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `delete[] a` | Dynamic deallocation (array) |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `.*``->*` | Pointer-to-member-of-pointerPointer-to-member-of-object | Left
    to right |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `a * b``a / b``a % b` | MultiplicationDivisionModulo division | Left to right
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `a + b``a - b` | AdditionSubtraction | Left to right |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `a << b``a >> b` | Bitwise left shiftBitwise right shift | Left to right
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | Less than | Left to right |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `a < b` | 小于 | 从左到右 |'
- en: '| `a > b` | Greater than |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `a > b` | 大于 |  |'
- en: '| `a <= b` | Less than or equal to |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `a <= b` | 小于或等于 |  |'
- en: '| `a >= b` | Greater than or equal to |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `a >= b` | 大于或等于 |  |'
- en: '| `a == b``a != b` | EqualsNot equals | Left to right |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `a == b``a != b` | 等于不等于 | 从左到右 |'
- en: '| `a & b` | Bitwise AND | Left to right |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `a & b` | 位运算与 | 从左到右 |'
- en: '| `a ^ b` | Bitwise XOR | Left to right |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `a ^ b` | 位运算异或 | 从左到右 |'
- en: '| `a &#124; b` | Bitwise OR | Left to right |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124; b` | 位运算或 | 从左到右 |'
- en: '| `a && b` | Logical AND | Left to right |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `a && b` | 逻辑与 | 从左到右 |'
- en: '| `a &#124;&#124; b` | Logical OR | Left to right |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124;&#124; b` | 逻辑或 | 从左到右 |'
- en: '| `a ? b : c` | Ternary | Right to left |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `a ? b : c` | 三元运算 | 从右到左 |'
- en: '| `throw a` | Throw |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `throw a` | 抛出 |  |'
- en: '| `a = b` | Assignment |  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `a = b` | 赋值 |  |'
- en: '| `a += b` | Sum assignment |  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `a += b` | 和赋值 |  |'
- en: '| `a -= b` | Difference assignment |  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `a -= b` | 差赋值 |  |'
- en: '| `a *= b` | Product assignment |  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `a *= b` | 积赋值 |  |'
- en: '| `a /= b` | Quotient assignment |  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `a /= b` | 商赋值 |  |'
- en: '| `a %= b` | Remainder assignment |  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `a %= b` | 余数赋值 |  |'
- en: '| `a <<= b` | Bitwise-left-shift assignment |  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `a <<= b` | 位运算左移赋值 |  |'
- en: '| `a >>= b` | Bitwise-right-shift assignment |  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `a >>= b` | 位运算右移赋值 |  |'
- en: '| `a &= b` | Bitwise AND assignment |  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `a &= b` | 位运算与赋值 |  |'
- en: '| `a ^= b` | Bitwise XOR assignment |  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `a ^= b` | 位运算异或赋值 |  |'
- en: '| `a &#124;= b` | Bitwise OR assignment |  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124;= b` | 位运算或赋值 |  |'
- en: '| `a, b` | Comma | Left to right |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `a, b` | 逗号 | 从左到右 |'
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You haven’t yet met the scope resolution operator (it first appears in [Chapter
    8](ch08.xhtml#ch08)), but [Table 7-6](ch07.xhtml#ch07tab06) includes it for completeness.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还没有遇到作用域解析运算符（它首次出现在[第8章](ch08.xhtml#ch08)），但[表7-6](ch07.xhtml#ch07tab06)包括了它以保持完整性。*'
- en: Because C++ has many operators, the operator precedence and associativity rules
    can be hard to keep track of. For the mental health of those reading your code,
    try to make expressions as clear as possible.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为C++有很多运算符，所以运算符的优先级和结合性规则可能很难追踪。为了读者的心理健康，尽量使表达式尽可能清晰。
- en: 'Consider the following expression:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下表达式：
- en: '[PRE9]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because postfix addition has higher precedence than the dereference operator
    `*`, it binds first to the argument `a`, meaning the result of `a++` is the argument
    to the dereference operator. Multiplication `*` has higher precedence than addition
    `+`, so the multiplication operator `*` binds to `b` and `c`, and the addition
    operator `+` binds to the results of `*a++` and `b * c`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后缀加法运算的优先级高于解引用运算符`*`，它首先绑定到参数`a`，这意味着`a++`的结果是解引用运算符的参数。乘法`*`的优先级高于加法`+`，所以乘法运算符`*`绑定到`b`和`c`，加法运算符`+`绑定到`*a++`和`b
    * c`的结果。
- en: 'You can impose precedence within an expression by adding parentheses, which
    have higher precedence than any operator. For example, you can rewrite the preceding
    expression using parentheses:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加括号来强制表达式中的优先级，因为括号的优先级高于任何运算符。例如，你可以使用括号重写前面的表达式：
- en: '[PRE10]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As a general rule, add parentheses wherever a reader could become confused about
    operator precedence. If the result is a bit ugly (as in this example), your expression
    is probably too complicated; you might consider breaking it up into multiple statements.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，在哪里可能让读者对运算符的优先级产生困惑，就在哪儿加上括号。如果结果看起来有点复杂（像这个例子一样），那么你的表达式可能太复杂了；你可以考虑将其拆分成多个语句。
- en: '***Evaluation Order***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算顺序***'
- en: 'Evaluation order determines the execution sequence of operators in an expression.
    A common misconception is that precedence and evaluation order are equivalent:
    they are not. *Precedence* is a compile time concept that drives how operators
    bind to operands. *Evaluation order* is a runtime concept that drives the scheduling
    of operator execution.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 计算顺序决定了表达式中运算符的执行顺序。一个常见的误解是，优先级和计算顺序是等同的：它们不是。*优先级*是一个编译时概念，决定了运算符如何与操作数绑定。*计算顺序*是一个运行时概念，决定了运算符执行的调度顺序。
- en: '*In general, C++ has no clearly specified execution order for operands.* Although
    operators bind to operands in the well-defined way explained in the preceding
    sections, those operands evaluate in an undefined order. The compiler can order
    operand evaluation however it likes.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，C++对操作数的执行顺序没有明确规定。* 虽然运算符按照前述部分中清晰定义的方式与操作数绑定，但这些操作数的计算顺序是不确定的。编译器可以以任何它喜欢的方式来安排操作数的计算顺序。'
- en: 'You might be tempted to think that the parentheses in the following expression
    drive evaluation order for the functions `stop, drop`, and `roll`, or that some
    left-to-right associativity has some runtime effect:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会误以为下面表达式中的括号决定了`stop`、`drop`和`roll`函数的执行顺序，或者某种从左到右的结合性有运行时效果：
- en: '[PRE11]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'They do not. The `roll` function might execute before, after, or between evaluations
    of `stop` and `drop`. If you require operations to execute in a specific order,
    simply place them into separate statements in the desired sequence, as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不会。`roll`函数可能会在`stop`和`drop`的执行之前、之后或之间执行。如果你需要操作按特定顺序执行，只需将它们放入按所需顺序排列的单独语句中，如下所示：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you aren’t careful, you can even get undefined behavior. Consider the following
    expression:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不小心，甚至可能会导致未定义行为。考虑以下表达式：
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because the ordering of the expressions `++a` and `a` is not specified, and
    because the value of `++a + a` depends on which expression evaluates first, the
    value of `b` cannot be well defined.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表达式`++a`和`a`的执行顺序没有指定，并且`++a + a`的值取决于哪个表达式先计算，所以`b`的值无法很好地定义。
- en: 'In some special situations, execution order is specified by the language. The
    most commonly encountered scenarios are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊情况下，执行顺序是由语言指定的。最常遇到的情况如下：
- en: The built-in logical AND operator `a && b` and built-in logical OR operator
    `a || b` guarantee that `a` executes before `b`.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置逻辑与运算符`a && b`和内置逻辑或运算符`a || b`保证`a`在`b`之前执行。
- en: 'The ternary operator `a ? b : c` guarantees that `a` executes before `b` and
    `c`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符`a ? b : c`保证`a`在`b`和`c`之前执行。'
- en: The comma operator `a, b` guarantees that `a` executes before `b`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号运算符`a, b`保证`a`在`b`之前执行。
- en: The constructor arguments in a `new` expression evaluate before the call to
    the allocator function.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`new`表达式中，构造函数的参数会在调用分配器函数之前执行。
- en: You might be wondering why C++ doesn’t enforce execution order, say from left
    to right, to avoid confusion. The answer is simply that by not arbitrarily constraining
    execution order, the language is allowing compiler writers to find clever optimization
    opportunities.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么C++不强制执行顺序，比如从左到右，以避免混淆。答案很简单：通过不任意限制执行顺序，语言允许编译器开发者发现巧妙的优化机会。
- en: '**NOTE**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information on execution order, see [expr].*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关执行顺序的更多信息，请参见[expr]。*'
- en: '**User-Defined Literals**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户定义字面量**'
- en: '[Chapter 2](ch02.xhtml) covered how to declare literals, constant values that
    you use directly in your programs. These help the compiler to turn embedded values
    into the desired types. Each fundamental type has its own syntax for literals.
    For example, a `char` literal is declared in single quotes like `''J''`, whereas
    a `wchar_t` is declared with an `L` prefix like `L''J''`. You can specify the
    precision of floating-point numbers using either the `F` or `L` suffix.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.xhtml)讲解了如何声明字面量，这是你在程序中直接使用的常量值。它们帮助编译器将嵌入的值转换为所需的类型。每种基本类型都有自己的字面量语法。例如，`char`字面量用单引号声明，如`''J''`，而`wchar_t`则用`L`前缀声明，如`L''J''`。你可以使用`F`或`L`后缀来指定浮点数的精度。'
- en: For convenience, you can also make your own *user-defined literals*. As with
    the baked-in literals, these provide you with some syntactical support for giving
    type information to the compiler. Although you’d rarely ever need to declare a
    user-defined literal, it’s worth mentioning because you might find them in libraries.
    The stdlib `<chrono>` header uses literals extensively to give programmers a clean
    syntax for using time types—for example, `700ms` denotes 700 milliseconds. Because
    user-defined literals are fairly rare, I won’t cover them in any more detail here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，你还可以创建自己的*用户定义字面量*。与内置字面量一样，用户定义字面量为编译器提供了类型信息的语法支持。虽然你几乎不需要声明用户定义字面量，但值得一提的是，你可能会在库中看到它们。标准库`<chrono>`头文件广泛使用字面量，提供给程序员一种简洁的时间类型语法——例如，`700ms`表示700毫秒。由于用户定义字面量相对较少，我不会在这里深入讨论它们。
- en: '**NOTE**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For further reference, see Section 19.2.6 of *The C++ Programming Language*,
    4th Edition, by Bjarne Stroustrup.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*进一步参考，请参阅Bjarne Stroustrup的《C++编程语言》第4版第19.2.6节。*'
- en: '**Type Conversions**'
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类型转换**'
- en: You perform type conversions when you have one type but want to convert it to
    another type. Depending on the situation, type conversions can be explicit or
    implicit. This section treats both sorts of conversions while covering promotions,
    floating-point-to-integer conversions, integer-to-integer conversions, and floating-point-to-floating-point
    conversions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有一种类型但希望将其转换为另一种类型时，你会执行类型转换。根据情况，类型转换可以是显式的或隐式的。本节将讨论这两种类型的转换，并涵盖提升、浮点到整数的转换、整数到整数的转换以及浮点到浮点的转换。
- en: Type conversions are fairly common. For example, you might need to compute the
    mean of some integers given a count and a sum. Because the count and sum are stored
    in variables of integral type (and you don’t want to truncate fractional values),
    you’ll want to compute the mean as a floating-point number. To do this, you’ll
    need to use type conversion.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是相当常见的。例如，给定一个计数和总和，你可能需要计算一些整数的平均值。由于计数和总和是存储在整型变量中的（而且你不想截断小数部分），你会希望将平均值计算为浮点数。为此，你需要使用类型转换。
- en: '***Implicit Type Conversions***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐式类型转换***'
- en: Implicit type conversions can occur anywhere a particular type is called for
    but you provide a different type. These conversions occur in several different
    contexts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型转换可以发生在任何需要特定类型但你提供了不同类型的地方。这些转换发生在几种不同的上下文中。
- en: “Binary Arithmetic Operators” on [page 183](ch07.xhtml#page_183) outlined so-called
    *promotion rules*. In fact, these are a form of implicit conversion. Whenever
    an arithmetic operation occurs, shorter integral types are promoted to `int` types.
    Integral types can also be promoted to floating-point types during arithmetic
    operation. All of this happens in the background. The result is that, in most
    situations, the type system simply gets out of your way so you can focus on programming
    logic.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[“二进制算术运算符”](ch07.xhtml#page_183)在第183页中概述了所谓的*提升规则*。实际上，这些规则是一种隐式转换。每当发生算术操作时，较短的整型会被提升为`int`类型。在算术操作中，整型也可以被提升为浮点型。所有这些操作都发生在后台。结果是，在大多数情况下，类型系统会自动让路，让你专注于编程逻辑。'
- en: 'Unfortunately, in some situations, C++ is a bit overzealous in silently converting
    types. Consider the following implicit conversion from a `double` to a `uint_8`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在某些情况下，C++在默默地进行类型转换时有些过于激进。考虑从`double`转换为`uint_8`的隐式转换：
- en: '[PRE14]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should hope that the compiler will generate a warning here, but technically
    this is valid C++. Because this conversion loses information, it’s a narrowing
    conversion that would be prevented by braced initialization `{}`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该希望编译器在这里生成警告，但从技术上讲，这在C++中是有效的。因为这种转换会丢失信息，所以它是一个窄化转换，使用大括号初始化`{}`可以防止这种转换：
- en: '[PRE15]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Recall that braced initialization doesn’t permit narrowing conversions. Technically,
    the braced initializer is an explicit conversion, so I’ll discuss that in “Explicit
    Type Conversion” on [page 201](ch07.xhtml#page_201).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，大括号初始化不允许窄化转换。从技术上讲，大括号初始化器是一种显式转换，因此我将在第201页的《显式类型转换》中讨论这一点。
- en: '**Floating-Point-to-Integer Conversion**'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点到整数的转换**'
- en: 'Floating-point and integral types can coexist peacefully within arithmetic
    expressions. The reason is implicit type conversion: when the compiler encounters
    mixed types, it performs the necessary promotions so arithmetic proceeds as expected.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型和整型可以在算术表达式中和平共存。原因是隐式类型转换：当编译器遇到混合类型时，它会执行必要的提升，以确保算术操作按预期进行。
- en: '**Integer-to-Integer Conversion**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数到整数的转换**'
- en: Integers can be converted into other integer types. If the destination type
    is `signed`, all is well, as long as the value can be represented. If it cannot,
    the behavior is implementation defined. If the destination type is `unsigned`,
    the result is as many bits as can fit into the type. In other words, the high-order
    bits are lost.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以转换为其他整数类型。如果目标类型是`signed`，那么只要值可以表示，一切正常。如果不能表示，行为由实现定义。如果目标类型是`unsigned`，结果是能容纳在该类型中的位数。换句话说，高位会丢失。
- en: Consider the example in [Listing 7-8](ch07.xhtml#ch07ex08), which demonstrates
    how you can get undefined behavior resulting from signed conversion.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[示例 7-8](ch07.xhtml#ch07ex08)，它演示了如何因符号转换导致未定义行为。
- en: '[PRE16]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-8: Undefined behavior resulting from signed conversion*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-8：由符号转换引起的未定义行为*'
- en: '[Listing 7-8](ch07.xhtml#ch07ex08) implicitly casts an integer that is too
    big to fit in an 8-bit integer (511, or 9 bits of ones) into `x` and `y`, which
    are `unsigned` and `signed`. The value of `x` is guaranteed to be 255 ➊, whereas
    the value of `y` is implementation dependent. On a Windows 10 x64 machine, `y`
    equals `-1` ➋. The assignment of both `x` and `y` involve narrowing conversions
    that could be avoided using the braced initialization syntax.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-8](ch07.xhtml#ch07ex08) 会隐式地将一个过大无法放入 8 位整数中的整数（511，或者 9 个 1）转换为 `x`
    和 `y`，其中 `x` 和 `y` 分别是 `unsigned` 和 `signed`。`x` 的值保证为 255 ➊，而 `y` 的值则依赖于实现。在
    Windows 10 x64 机器上，`y` 等于 `-1` ➋。对 `x` 和 `y` 的赋值都涉及到可能会被花括号初始化语法避免的窄化转换。'
- en: '**Floating-Point-to-Floating-Point Conversions**'
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮动点到浮动点的转换**'
- en: Floating-point numbers can be implicitly cast to and from other floating-point
    numbers. As long as the destination value can fit the source value, all is well.
    When it cannot, you have undefined behavior. Again, braced initialization can
    prevent potentially dangerous conversions. Consider the example in [Listing 7-9](ch07.xhtml#ch07ex09),
    which demonstrates undefined behavior resulting from a narrowing conversion.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动点数可以隐式地转换为其他浮动点数，反之亦然。只要目标值能够容纳源值，一切正常。当无法容纳时，会发生未定义行为。同样，花括号初始化可以防止潜在的危险转换。考虑[列表
    7-9](ch07.xhtml#ch07ex09)中的例子，它展示了因窄化转换导致的未定义行为。
- en: '[PRE17]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-9: Undefined behavior resulting from narrowing conversion*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-9：窄化转换导致的未定义行为*'
- en: You have completely safe implicit conversions from `float` to `double` ➊ and
    `double` to `long double` ➋ respectively. Unfortunately, assigning the maximum
    value of a `long double` to a `float` results in undefined behavior ➌.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地进行从 `float` 到 `double` ➊ 和从 `double` 到 `long double` ➋ 的隐式转换。不幸的是，将一个
    `long double` 的最大值赋给 `float` 会导致未定义行为 ➌。
- en: '**Conversion to bool**'
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转换为 `bool`**'
- en: Pointers, integers, and floating-point numbers can all be implicitly converted
    to `bool` objects. If the value is nonzero, the result of implicit conversion
    is `true`. Otherwise, the result is `false`. For example, the value `int{ 1 }`
    converts to `true`, and the value `int{}` converts to `false`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 指针、整数和浮动点数都可以隐式地转换为 `bool` 对象。如果值非零，隐式转换的结果为 `true`。否则，结果为 `false`。例如，值 `int{
    1 }` 转换为 `true`，而 `int{}` 转换为 `false`。
- en: '**Pointer to void***'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指向 `void` 的指针***'
- en: Pointers can always be implicitly converted to `void*`, as demonstrated in [Listing
    7-10](ch07.xhtml#ch07ex10).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 指针总是可以隐式地转换为 `void*`，如[列表 7-10](ch07.xhtml#ch07ex10)所示。
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-10: Implicit pointer conversion to `void*`. Output is from a Windows
    10 x64 machine.*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-10：指针隐式转换为 `void*`。输出来自 Windows 10 x64 机器。*'
- en: '[Listing 7-10](ch07.xhtml#ch07ex10) compiles thanks to the pointers’ implicit
    conversion to `void*`. The `print_addr` function prints the address of `x` ➊ and
    the value of `nullptr`, `0` ➋.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-10](ch07.xhtml#ch07ex10) 由于指针隐式转换为 `void*`，因此能够编译通过。`print_addr` 函数打印
    `x` 的地址 ➊ 和 `nullptr`、`0` 的值 ➋。'
- en: '***Explicit Type Conversion***'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显式类型转换***'
- en: Explicit type conversions are also called *casts*. The first port of call for
    conducting an explicit type conversion is braced initialization `{}`. This approach
    has the major benefit of being fully type safe and non-narrowing. The use of braced
    initialization ensures at compile time that only safe, well-behaved, non-narrowing
    conversions are allowed. [Listing 7-11](ch07.xhtml#ch07ex11) shows an example.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型转换也称为 *强制类型转换*。进行显式类型转换的首选方法是带花括号的初始化 `{}`。这种方法的主要优点是完全类型安全且无窄化。使用花括号初始化确保在编译时仅允许安全、行为良好且无窄化的转换。[列表
    7-11](ch07.xhtml#ch07ex11) 显示了一个例子。
- en: '[PRE19]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-11: Explicit type conversion for 4- and 8-byte integers*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-11：4 字节和 8 字节整数的显式类型转换*'
- en: This simple example uses braced initialization ➊ to build an `int64_t` from
    an `int32_t`. This is a well-behaved conversion because you’re guaranteed not
    to have lost any information. You can always store 32 bits inside 64 bits. After
    a well-behaved conversion of a fundamental type, the original will always equal
    the result (according to `operator==`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子使用了带花括号的初始化 ➊ 来从 `int32_t` 构建一个 `int64_t`。这是一个行为良好的转换，因为可以确保没有丢失任何信息。你总是可以将
    32 位数据存储在 64 位中。经过基本类型的行为良好的转换后，原值总是等于结果（根据 `operator==`）。
- en: The example attempts a badly behaved (narrowing) conversion ➌. The compiler
    will generate an error. If you hadn’t used the braced initializer `{}`, the compiler
    wouldn’t have complained, as demonstrated in [Listing 7-12](ch07.xhtml#ch07ex12).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子尝试进行一个行为不良（缩小）的转换 ➌。编译器会生成错误。如果你没有使用大括号初始化器`{}`，编译器不会报错，如[列表 7-12](ch07.xhtml#ch07ex12)所示。
- en: '[PRE20]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 7-12: A refactor of [Listing 7-11](ch07.xhtml#ch07ex11) without the
    braced initializer.*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-12：重构后的[列表 7-11](ch07.xhtml#ch07ex11)，没有使用大括号初始化器。*'
- en: You make a narrowing conversion from a 64-bit integer to a 32-bit integer ➊.
    Because this narrows, the expression `c != b` evaluates to `true` ➋. This behavior
    is very dangerous, which is why [Chapter 2](ch02.xhtml#ch02) recommends using
    the braced initializer as much as possible.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你将一个64位整数转换为32位整数 ➊。由于这种转换是缩小的，表达式`c != b`的结果为`true` ➋。这种行为非常危险，这也是[第2章](ch02.xhtml#ch02)建议尽可能使用大括号初始化器的原因。
- en: '***C-Style Casts***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C风格强制转换***'
- en: 'Recall from [Chapter 6](ch06.xhtml#ch06) that the named conversion functions
    allow you to perform dangerous casts that braced initialization won’t permit.
    You can also perform C-style casts, but this is done mainly to maintain some compatibility
    between the languages. Their usage is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](ch06.xhtml#ch06)，命名转换函数允许你执行大括号初始化器不允许的危险类型转换。你也可以进行C风格的强制转换，但这主要是为了保持不同语言之间的一些兼容性。它们的用法如下：
- en: '[PRE21]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For each C-style cast, there exists some incantation of `static_casts, const_casts`,
    and `reinterpret_casts` that would achieve the desired type conversion. C-style
    casts are far more dangerous than the named casts (and this is saying quite a
    bit).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个C风格强制转换，都存在某种`static_casts、const_casts`和`reinterpret_casts`的组合，可以实现所需的类型转换。C风格强制转换比命名的强制转换要危险得多（这已经是说得很严重了）。
- en: The syntax of the C++ explicit casts is intentionally ugly and verbose. This
    calls attention to a point in the code where the rigid rules of the type system
    are being bent or broken. The C-style cast doesn’t do this. In addition, it’s
    not clear from the cast what kind of conversion the programmer is intending. When
    you use finer instruments like the named casts, the compiler can at least enforce
    *some* constraints. For example, it’s all too easy to forget `const` correctness
    when using a C-style cast when you only intended a `reinterpret_cast`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: C++显式类型转换的语法故意丑陋且冗长。这是为了突出代码中的一个点，即类型系统的严格规则在这里被弯曲或打破。C风格的强制转换没有做到这一点。此外，从强制转换中并不清楚程序员打算进行什么样的转换。当你使用命名的转换函数时，编译器至少可以强制执行*一些*约束。例如，当使用C风格强制转换时，如果你只打算进行`reinterpret_cast`，就很容易忘记`const`正确性。
- en: Suppose you wanted to treat a `const char*` array as unsigned within the body
    of a function. It would be too easy to write code like that demonstrated in [Listing
    7-13](ch07.xhtml#ch07ex13).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在一个函数内部将`const char*`数组当作无符号数处理。编写类似于[列表 7-13](ch07.xhtml#ch07ex13)中演示的代码是非常简单的。
- en: '[PRE22]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 7-13: A train wreck of a C-style cast that accidentally gets rid of
    the `const` qualifier on `read_only`. (This program has undefined behavior; output
    is from a Windows 10 x64 machine.)*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-13：一个C风格强制转换的灾难，意外去除了`const`限定符（`read_only`）。 (该程序的行为未定义；输出来自Windows
    10 x64机器。)*'
- en: Modern operating systems enforce memory access patterns. [Listing 7-13](ch07.xhtml#ch07ex13)
    attempts to write into the memory storing the string literal `Ezra` ➊. On Windows
    10 x64, this crashes the program with a memory access violation (it’s read-only
    memory).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统强制执行内存访问模式。[列表 7-13](ch07.xhtml#ch07ex13)尝试写入存储字符串文字`Ezra`的内存 ➊。在Windows
    10 x64上，这会导致程序崩溃并发生内存访问冲突（因为该内存是只读的）。
- en: If you tried this with a `reinterpret_cast`, the compiler would generate an
    error, as [Listing 7-14](ch07.xhtml#ch07ex14) demonstrates.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`reinterpret_cast`尝试这样做，编译器会生成错误，正如[列表 7-14](ch07.xhtml#ch07ex14)所演示的那样。
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-14: A refactor of [Listing 7-13](ch07.xhtml#ch07ex13) using a `reinterpret_cast`.
    (This code does not compile.)*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-14：重构后的[列表 7-13](ch07.xhtml#ch07ex13)，使用了`reinterpret_cast`。 (此代码无法编译。)*'
- en: If you really intended to throw away `const` correctness, you’d need to tack
    on a `const_cast` here ➊. The code would self-document these intentions and make
    such intentional rule breakages easy to find.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的打算放弃`const`正确性，你需要在这里加上`const_cast` ➊。代码会自我记录这些意图，并使这些故意的规则突破易于发现。
- en: '***User-Defined Type Conversions***'
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户定义的类型转换***'
- en: 'In user-defined types, you can provide user-defined conversion functions. These
    functions tell the compiler how your user-defined types behave during implicit
    and explicit type conversion. You can declare these conversion functions using
    the following usage pattern:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户自定义类型中，你可以提供用户自定义的转换函数。这些函数告诉编译器在隐式和显式类型转换过程中，你的用户自定义类型是如何行为的。你可以使用以下模式声明这些转换函数：
- en: '[PRE24]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For example, the `struct` in [Listing 7-15](ch07.xhtml#ch07ex15) can be used
    like a read-only `int`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[Listing 7-15](ch07.xhtml#ch07ex15)中的`struct`可以像只读的`int`一样使用。
- en: '[PRE25]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 7-15: A `ReadOnlyInt` class containing a user-defined type conversion
    to an `int`*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-15: 一个包含用户自定义类型转换到`int`的`ReadOnlyInt`类*'
- en: 'The operator `int` method at ➊ defines the user-defined type conversion *from*
    a `ReadOnlyInt` *to* an `int`. You can now use `ReadOnlyInt` types just like regular
    `int` types thanks to implicit conversion:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符`int`方法在➊定义了用户自定义的类型转换*从* `ReadOnlyInt` *到* `int`。现在，得益于隐式转换，你可以像使用常规的`int`类型一样使用`ReadOnlyInt`类型：
- en: '[PRE26]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Sometimes, implicit conversions can cause surprising behavior. You should always
    try to use explicit conversions, especially with user-defined types. You can achieve
    explicit conversions with the `explicit` keyword. Explicit constructors instruct
    the compiler not to consider the constructor as a means for implicit conversion.
    You can provide the same guidelines for your user-defined conversion functions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，隐式转换可能会导致意外的行为。你应该始终尽量使用显式转换，特别是对于用户自定义类型。你可以通过`explicit`关键字实现显式转换。显式构造函数指示编译器不要将构造函数视为隐式转换的手段。你可以为你的用户自定义转换函数提供相同的指导原则：
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you must explicitly cast a `ReadOnlyInt` to an `int` using `static_cast`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须使用`static_cast`显式地将`ReadOnlyInt`转换为`int`：
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Generally, this approach tends to promote less ambiguous code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种方法倾向于促使代码更少歧义。
- en: '**Constant Expressions**'
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量表达式**'
- en: Constant expressions are expressions that can be evaluated at compile time.
    For performance and safety reasons, whenever a computation can be done at compile
    time rather than runtime, you should do it. Simple mathematical operations involving
    literals are an obvious example of expressions that can be evaluated at compile
    time.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式是可以在编译时求值的表达式。出于性能和安全的考虑，每当计算可以在编译时而非运行时完成时，你应该这么做。涉及字面量的简单数学运算是可以在编译时求值的表达式的一个显著例子。
- en: You can extend the reach of the compiler by using the expression `constexpr`.
    Whenever all the information required to compute an expression is present at compile
    time, the compiler is *compelled to do so* if that expression is marked `constexpr`.
    This simple commitment can enable a surprisingly large impact on code readability
    and runtime performance.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`constexpr`表达式来扩展编译器的能力。每当计算表达式所需的所有信息在编译时就已经具备时，如果该表达式标记为`constexpr`，编译器就*必须这样做*。这种简单的承诺可以对代码的可读性和运行时性能产生意想不到的巨大影响。
- en: Both `const` and `constexpr` are closely related. Whereas `constexpr` enforces
    that an expression is compile time evaluable, `const` enforces that a variable
    cannot change within some scope (at runtime). All `constexpr` expressions are
    `const` because they’re always fixed at runtime.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`和`constexpr`密切相关。`constexpr`强制要求一个表达式可以在编译时求值，而`const`则强制要求一个变量在某个作用域内（运行时）不能更改。所有的`constexpr`表达式都是`const`，因为它们在运行时始终是固定的。'
- en: All `constexpr` expressions begin with one or more fundamental types (`int,
    float, wchar_t`, and so on). You can build on top of these types by using operators
    and `constexpr` functions. Constant expressions are used mainly to replace manually
    computed values in your code. This generally produces code that is more robust
    and easier to understand, because you can eliminate so-called *magic values*—manually
    calculated constants copy and pasted directly into source code.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`constexpr`表达式都以一个或多个基础类型（`int, float, wchar_t`等）开始。你可以通过使用运算符和`constexpr`函数在这些类型之上进行扩展。常量表达式主要用于替代代码中手动计算的值。这通常会产生更强健、易于理解的代码，因为你可以消除所谓的*魔法值*——直接粘贴到源代码中的手动计算常量。
- en: '***A Colorful Example***'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个多彩的例子***'
- en: 'Consider the following example where some library you’re using for your project
    uses `Color` objects that are encoded using the hue-saturation-value (HSV) representation:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子，其中你为项目使用的某个库使用了通过色相-饱和度-明度（HSV）表示法编码的`Color`对象：
- en: '[PRE29]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Very roughly, hue corresponds with a family of colors like red, green, or orange.
    Saturation corresponds with colorfulness or intensity. Value corresponds with
    the color’s brightness.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，色相（hue）对应一系列颜色，如红色、绿色或橙色。饱和度（saturation）对应颜色的鲜艳程度或强度。明度（value）对应颜色的亮度。
- en: Suppose you want to instantiate `Color` objects using red-green-blue (RGB) representations.
    You could use a converter to calculate the RGB to HSV manually, but this is a
    prime example where you can use `constexpr` to eliminate magic values. Before
    you can write the conversion function, you need a few utility functions, namely
    `min, max`, and `modulo`. [Listing 7-16](ch07.xhtml#ch07ex16) implements these
    functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用红绿蓝（RGB）表示法实例化`Color`对象。你可以使用转换器手动计算RGB到HSV的转换，但这是一个典型例子，你可以使用`constexpr`来消除魔法值。在你编写转换函数之前，你需要一些工具函数，即`min`、`max`和`modulo`。[清单7-16](ch07.xhtml#ch07ex16)实现了这些函数。
- en: '[PRE30]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 7-16: Several `constexpr` functions for manipulating `uint8_t` objects*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-16：多个用于操作`uint8_t`对象的`constexpr`函数*'
- en: Each function is marked `constexpr`, which tells the compiler that the function
    must be evaluable at compile time. The `max` function ➊ uses the ternary operator
    to return the value of the argument that is greatest. The three-argument version
    of `max` ➋ uses the transitive property of comparison; by evaluating the two-argument
    `max` for the pairs `a, b` and `a, c`, you can find the max of this intermediate
    result to find the overall max. Because the two-argument version of max is `constexpr`,
    this is totally legal.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都标记为`constexpr`，这告诉编译器该函数必须在编译时进行求值。`max`函数 ➊ 使用三元操作符返回最大的参数值。`max`的三参数版本
    ➋ 使用比较的传递性；通过分别对`a, b`和`a, c`使用二参数`max`，你可以找到这个中间结果的最大值，从而得到总体最大值。由于二参数版本的`max`是`constexpr`，这一做法完全合法。
- en: '**NOTE**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can’t use `fmax` from the `<math.h>` header for the same reason: it’s
    not `constexpr`.*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不能使用`<math.h>`头文件中的`fmax`，原因相同：它不是`constexpr`。*'
- en: The `min` versions ➌ ➍ follow exactly with the obvious modification that the
    comparison is flipped. The `modulo` function ➎ is a quick-and-dirty, `constexpr`
    version of the C function `fmod`, which computes the floating-point remainder
    of dividing the first argument (`dividend`) by the second argument (`divisor`).
    Because `fmod` is *not* `constexpr`, you’ve hand-rolled your own. First, you obtain
    the quotient ➏. Next, you subtract the integral part of quotient using a `static_cast`
    and a subtraction. Multiplying the decimal portion of the quotient by `divisor`
    yields the result.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`版本 ➌ ➍ 完全遵循相同的逻辑，唯一的修改是比较顺序被翻转了。`modulo`函数 ➎ 是一个快速简便的`constexpr`版本的C函数`fmod`，用于计算第一个参数（`被除数`）除以第二个参数（`除数`）后的浮点余数。由于`fmod`*不是*`constexpr`，你需要自己手动实现。首先，你获得商
    ➏。接着，通过`static_cast`和减法得到商的整数部分。将商的小数部分与`除数`相乘，得到结果。'
- en: With a collection of `constexpr` utility functions in your arsenal, you can
    now implement your conversion function `rgb_to_hsv`, as demonstrated in [Listing
    7-17](ch07.xhtml#ch07ex17).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一组`constexpr`工具函数，你现在可以实现你的转换函数`rgb_to_hsv`，如[清单7-17](ch07.xhtml#ch07ex17)所示。
- en: '[PRE31]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 7-17: A `constexpr` conversion function from RGB to HSV*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-17：一个从RGB到HSV的`constexpr`转换函数*'
- en: You’ve declared and initialized `Color c` ➊, which will eventually get returned
    by `rgb_to_hsv`. The value of the `Color, V`, is computed at ➋ by scaling the
    maximum value of `r, g`, and `b`. Next, the saturation `S` is calculated by computing
    the distance between the minimum and maximum RGB values and scaling by `V` ➌.
    If you imagine the HSV values as existing inside a cylinder, *saturation* is the
    distance along the horizontal axis and *value* is the distance along the vertical
    axis. *Hue* is the angle. For brevity, I won’t go into detail about how this angle
    is computed, but the calculation is implemented between ➍ and ➎. Essentially,
    it entails computing the angle as an offset from the dominant color component’s
    angle. This is scaled and modulo-ed to fit on the 0- to 360-degree interval and
    stored into `H`. Finally, `c` is returned.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经声明并初始化了`Color c` ➊，它最终将由`rgb_to_hsv`返回。`Color, V`的值在 ➋ 通过缩放`r`、`g`和`b`的最大值来计算。接下来，饱和度`S`通过计算RGB最小值和最大值之间的距离并按`V`
    ➌进行缩放来计算。如果你将HSV值想象成存在于一个圆柱体内，*饱和度*是沿水平轴的距离，*明度*是沿垂直轴的距离。*色相*则是角度。为了简洁起见，我不会详细介绍如何计算这个角度，但计算在
    ➍ 和 ➎ 之间实现。基本上，它涉及计算色相作为从主色成分角度的偏移量。然后对结果进行缩放和取模，使其适应0到360度的区间，并存储到`H`中。最后，返回`c`。
- en: '**NOTE**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For an explanation of the formula used to convert HSV to RGB, refer to [https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae](https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae).*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s quite a bit going on here, but it’s all computed at compile time. This
    means when you initialize colors, the compiler initializes a `Color` with all
    of the HSV field floats filled in:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ve told the compiler that each of these color values is compile-time evaluable.
    Depending on how you use these values within the rest of the program, the compiler
    can decide whether or not to evaluate them at compile time or runtime. The upshot
    is that the compiler can usually emit instructions with hardcoded *magic numbers*
    corresponding to the correct HSV values for each `Color`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '***The Case for constexpr***'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are some restrictions on what sorts of functions can be `constexpr`, but
    these restrictions have been relaxed with each new C++ version.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In certain contexts, like embedded development, `constexpr` is indispensable.
    In general, if an expression can be declared `constexpr`, you should strongly
    consider doing so. Using `constexpr` rather than manually calculated literals
    can make your code more expressive. Often, it can also seriously boost performance
    and safety at runtime.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Volatile Expressions**'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `volatile` keyword tells the compiler that every access made through this
    expression must be treated as a visible side effect. This means access cannot
    be optimized out or reordered with another visible side effect. This keyword is
    crucial in some settings, like embedded programming, where reads and writes to
    some special portions of memory have effects on the underlying system. The `volatile`
    keyword keeps the compiler from optimizing such accesses away. [Listing 7-18](ch07.xhtml#ch07ex18)
    illustrates why you might need the `volatile` keyword by containing instructions
    that the compiler would normally optimize away.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 7-18: A function containing a dead store and a redundant load*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Because `x` is assigned ➊ but never used before getting reassigned ➋, it’s called
    a *dead store* and is a straightforward candidate for getting optimized away.
    There’s a similar story where `x` is used to set the value of `y` twice without
    any intervening instructions ➌➍. This is called a *redundant load* and is also
    a candidate for optimization.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: You might expect any decent compiler to optimize the preceding function into
    something resembling [Listing 7-19](ch07.xhtml#ch07ex19).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 7-19: A plausible optimization of [Listing 7-18](ch07.xhtml#ch07ex18)*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: In some settings, the redundant reads and dead stores might have visible side
    effects on the system. By adding the `volatile` keyword to the argument of `foo`,
    you can avoid the optimizer getting rid of these important accesses, as demonstrated
    in [Listing 7-20](ch07.xhtml#ch07ex20).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 7-20: A `volatile` modification of [Listing 7-18](ch07.xhtml#ch07ex18)*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Now the compiler will emit instructions to perform each of the reads and writes
    you’ve programmed.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: A common misconception is that `volatile` has to do with concurrent programming.
    It does not. Variables marked `volatile` are not generally thread safe. [Part
    II](part02.xhtml#part02) discusses `std::atomic`, which guarantees certain thread
    safe primitives on types. Too often, `volatile` is confused with `atomic`!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered the major features of operators, which are the fundamental
    units of work in a program. You explored several aspects of type conversions and
    took control of dynamic memory management from the environment. You were also
    introduced to `constexpr`/`volatile` expressions. With these tools in hand, you
    can perform almost any system-programming task.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '**7-1.** Create an `UnsignedBigInteger` class that can handle numbers bigger
    than a `long`. You can use a byte array as the internal representation (for example,
    `uint8_t[]` or `char[]`). Implement operator overloads for `operator+` and `operator-`.
    Perform runtime checks for overflow. For the intrepid, also implement `operator*,
    operator/`, and `operator%`. Make sure that your operator overloads work for both
    `int` types and `UnsignedBigInteger` types. Implement an `operator int` type conversion.
    Perform a runtime check if narrowing would occur.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '**7-2.** Create a `LargeBucket` class that can store up to 1MB of data. Extend
    the `Heap` class so it gives out a `LargeBucket` for allocations greater than
    4096 bytes. Make sure that you still throw `std::bad_alloc` whenever the `Heap`
    is unable to allocate an appropriately sized bucket.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
