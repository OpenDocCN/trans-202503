- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bare-Metal I²C Controller Programming
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: To this point, most of the sample programs in this book have relied on some
    third-party library code to interface with the I²C hardware on the SBC. At the
    hardware level, I²C communication normally consists of reading and writing hardware-dependent
    registers on the microcontroller. Having library code that hides these low-level
    details from you is convenient, but if you’re the one tasked with writing that
    library code in the first place—or if you need better performance or features
    that the library doesn’t provide—you’ll have to learn to program low-level I²C
    operations yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly every real-world MCU does things differently when it comes to low-level
    I²C programming, even if they share some common peripheral hardware. Fortunately,
    the I²C protocol isn’t *that* complex, so the basic programming ideas apply no
    matter what the underlying hardware. If you learn how to program a few different
    MCUs, those concepts should help you figure out how to deal with others. In this
    chapter, I’ll describe how to program I²C communications on a pair of MCUs at
    the register (hardware) level. In particular, this chapter will explore I²C programming
    on the Teensy 4.*x*’s NXP i.MX RT1062 MCU and the ATtiny84 MCU.
  prefs: []
  type: TYPE_NORMAL
- en: For the programming examples in this chapter, I use the Teensy 4.*x* modules
    and the SparkFun Atto84\. The Teensy 4.0 and 4.1 modules share the same MCU IC,
    so their low-level I²C programming is identical; the SparkFun Atto84 is based
    on the ATtiny84 MCU. All are low cost and commonly available, and they are used
    by many makers and hobbyists.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Teensy 4.*x* Controller Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example in this chapter will be I²C controller programming on the
    Teensy 4.*x* modules using a driver written primarily by Richard Gemmell, with
    portions by Paul Stoffregen of PJRC. The discussion begins with a description
    of the Teensy’s hardware registers that support I²C communications, followed by
    the code (based on Gemmell’s driver) that you’ll need to program these registers
    to implement Arduino-like I²C communication functions.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this driver and to download Gemmell’s code, visit his
    GitHub page at [https://github.com/Richard-Gemmell/teensy4_i2c](https://github.com/Richard-Gemmell/teensy4_i2c).
    Gemmell’s package includes both controller and peripheral code, but I’ll focus
    solely on the controller portion. See the online chapters (particularly Chapter
    18 at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com))
    for the corresponding discussion on programming the Teensy 4.*x* as an I²C peripheral
    device.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with low-level hardware on an MCU, the MCU’s reference manual
    becomes an indispensable resource. See “For More Information” at the end of this
    chapter for the link to the NXP reference manual for the i.MX RT1060 MCU (which
    includes the i.MX RT1062) on the PJRC (Teensy) website. Chapter 47 in the manual
    describes the I²C interface.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.1 i.MX RT1062 I²C Registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Teensy 4.0 and 4.1 modules use an NXP i.MX RT1062 MCU with an ARM Cortex
    M7 core. The ARM Cortex M7 core is the CPU, while the i.MX RT1062 is the MCU that
    consists of the CPU plus all the associated peripheral devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the Teensy 4.*x* I²C code, you will need to learn about certain
    i.MX RT1062 registers, beginning with the I²C control register set. The *imx_rt1060.h*
    file that Gemmell’s code uses contains the following declarations (annotations
    mine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `#define` statements at the end of this listing define symbols that map
    this structure to different addresses in memory. Specifically, `LPI2C1` corresponds
    to the registers associated with the Teensy 4’s (SDA0, SCL0) pins, `LPI2C3` corresponds
    to the (SDA1, SCL1) pins, and `LPI2C4` corresponds to the (SCL2, SDA2) pins (note
    that the Teensy 4.*x* has only three I²C ports brought out). You can read about
    these pin definitions in section 47.4 of the NXP manual.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s beyond the scope of this book to describe the uses of all of these
    registers in detail, it is worthwhile to describe several of them to understand
    the code in the sections that follow. See Chapter 47 of the NXP manual for more
    detail on all other registers.
  prefs: []
  type: TYPE_NORMAL
- en: Because the i.MX RT1062 is a 32-bit CPU, the registers are all 32 bits wide.
    Unlike CPU registers, whose addresses the ARM core encodes into the instruction
    opcodes, peripheral registers appear as memory locations to the processor—that
    is, `LPI2C1` through `LPI2C4`. As the ARM supports byte, half-word (16-bit), and
    word (32-bit) memory accesses, you can access individual bytes or half-words in
    these peripheral registers (as well as in the whole 32-bit register, of course).
  prefs: []
  type: TYPE_NORMAL
- en: The Master Control Register (MCR) The MCR is a collection of six flags (bits),
    spread out in the LO 10 bits of the register. Writing to these flags enables (1)
    or disables (0) I²C features. [Table 11-1](#table11-1) describes these flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-1: MCR Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | MEN (master enable): Enables or disables the controller aspects for a
    particular I²C port. Set to 1 to use the I²C port as a controller. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | RST (software reset): A 1 in this bit resets the I²C controller. A 0
    in this bit allows normal operation. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | DOZEN (doze mode enable): A 1 in this bit enables operation in low-power
    doze mode. A 0 in this bit disables controller in doze mode (for normal operation).
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | DBGEN (debug enable): A 1 in this bit enables controller operation in
    debug mode. A 0 puts the I²C port in normal operational mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | RTF (reset transmit FIFO [First-In, First-Out]): Writing a 1 in this
    bit resets the transmission FIFO; writing a 0 has no effect. This bit is write-only
    and always returns 0 when read. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | RRF (reset receive FIFO): Writing a 1 in this bit resets the receive
    FIFO (writing a 0 does nothing). This bit is write-only and always returns 0 when
    read. |'
  prefs: []
  type: TYPE_TB
- en: The Master Status Register (MSR) The MSR is a collection of bits that specifies
    the current status of the I²C port. [Table 11-2](#table11-2) lists the fields
    in this register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-2: MSR Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | TDF (transmit data flag): Set whenever the number of bytes in the transmission
    FIFO is less than or equal to *TxWater*, the transmission low watermark.^([*](#c11-footnote-001))
    TxWater is set in the MFCR. The purpose of this flag (and its corresponding interrupt)
    is to notify the system that the transmission FIFO needs more data. See [Table
    11-6](#table11-6) later in this chapter to set the TxWater value. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | RDF (receive data flag): Set whenever the number of bytes in the receive
    FIFO is greater than *RxWater*, the receive high watermark. RxWater is set in
    the MFCR. The purpose of this flag (and its corresponding interrupt) is to notify
    the system that it needs to remove data from the receive FIFO. See [Table 11-6](#table11-6)
    to set the RxWater value. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | EPF (end packet flag): Set when a controller generates a *repeated* start
    condition or a stop condition (not set on the first start condition). Writing
    a 1 to this bit clears this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | SDF (stop detected flag): Set when the controller generates a stop condition.
    Writing a 1 to this bit clears this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | NDF (NAK detected flag): Set when the controller detects a NAK when
    transmitting an address or data. When this bit is 1, the system will not generate
    a start condition until the flag is cleared. If a NAK is expected after an address
    transmission, the hardware will set this flag if a NAK is not generated. Writing
    a 1 to this bit clears this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | ALF (arbitration lost flag): The controller will set this flag if it
    loses an arbitration battle on the I²C bus. Once set, the system will not initiate
    a new start condition until this flag is cleared. Writing a 1 to this bit clears
    this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | FEF (FIFO error flag): The controller sets this bit if it detects an
    attempt to transmit or receive data without a start, or repeated start, condition.
    Writing a 1 to this bit clears this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | PLTF (pin low timeout flag): Set if the controller detects that an SDA
    or SCL line is stuck low. Writing a 1 to this bit clears this flag, though it
    cannot be cleared as long as the low pin condition persists. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | DMF (data match flag): Set if the controller determines that the received
    data has matched the MATCH0 or MATCH1 values (specified in MCFGR1). Writing a
    1 to this bit clears this flag. |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | MBF (master busy flag): Set while the controller is busy. |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | BBF (bus busy flag): Set while the I²C bus is busy. |'
  prefs: []
  type: TYPE_TB
- en: '| ^([*](#c11-footnoteref-001))A watermark is a point in the buffer where some
    event will occur (such as setting the TDF or RDF). |'
  prefs: []
  type: TYPE_TB
- en: The Master Interrupt Enable Register (MIER) The MIER allows you to enable or
    disable various I²C interrupts for a particular port. This is a collection of
    bits where a 1 indicates that the interrupt is enabled and a 0 indicates that
    the specific interrupt is disabled. [Table 11-3](#table11-3) lists the fields
    in this register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-3: MIER Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | TDIE: transmit data interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | RDIE: receive data interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | EPIE: end packet interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | SDIE: stop detected interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | NDIE: NAK detected interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | ALIE: arbitration lost interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | FEIE: FIFO error interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | PLTIE: pin low timeout interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | DMIE: data match interrupt enable |'
  prefs: []
  type: TYPE_TB
- en: The Master Configuration Register 1 (MCFGR1) The Teensy I²C code uses only the
    LO 3 bits of the MCFGR1\. These 3 bits hold the clock prescaler value that divides
    the system clock by 2^(*n+1*), where *n* is the 3-bit number passed in MCFGR1\.
    For information on the other bits, see the NXP documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Master Configuration Register 2 (MCFGR2) The MCFGR2 contains bus idle timeout
    and glitch filter constants for the I²C bus. [Table 11-4](#table11-4) describes
    the MCFGR2 fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-4: MCFGR2 Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 11 | Bus idle timeout period in clock cycles. A 0 in this field disables
    bus idle checking. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 to 19 | SCL glitch filter. A 0 in this field disables the filter. Otherwise,
    pulses less than or equal to this many clock cycles long will be ignored on the
    SCL line. |'
  prefs: []
  type: TYPE_TB
- en: '| 24 to 27 | SDA glitch filter. A 0 in this field disables the filter. Otherwise,
    pulses less than or equal to this many clock cycles long will be ignored on the
    SDA line. |'
  prefs: []
  type: TYPE_TB
- en: The Master Configuration Register 3 (MCFGR3) The MCFGR3 holds the pin low timeout
    value. Bits 8 to 19 hold the pin low timeout constant (in clock cycles, times
    256). Writing a 0 to these bits disables this feature. All other bits in MCFGR3
    must be 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Master Clock Configuration Register 0 (MCCR0) and 1 (MCCR1) The MCCR0 and
    MCCR1 specify various parameters concerning the I²C signal lines. [Table 11-5](#table11-5)
    lists the fields held within this register. MCCR1 is the same as MCCR0, but it
    is used when operating in I²C high-speed mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-5: MCCR0 and MCCR1 Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 5 | CLKLO: Minimum number of cycles (minus 1) that the SCL clock is
    driven low by the hardware. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 to 13 | CLKHI: Minimum number of cycles (minus 1) that the SCL clock is
    driven high by the hardware. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 to 21 | SETHOLD: Minimum number of cycles (minus 1) used by the controller
    as the hold time for a start condition. It is also used as the setup and hold
    time for a repeated start condition, and as the setup time for a stop condition.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 24 to 29 | DATAVD: Data valid delay. Minimum number of cycles (minus 1) used
    for the SDA data hold time. Must be less than CLKLO. |'
  prefs: []
  type: TYPE_TB
- en: The Master FIFO Control Register (MFCR) The MFCR allows you to set the TxWater
    and RxWater watermarks. These are each 2-bit fields allowing you to set the watermark
    from 0 to 3 (the FIFOs hold 4 words each). The field positions appear in [Table
    11-6](#table11-6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-6: MFCR Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 1 | TxWater |'
  prefs: []
  type: TYPE_TB
- en: '| 16 to 17 | RxWater |'
  prefs: []
  type: TYPE_TB
- en: The Master FIFO Status Register (MFSR) The MFSR holds the current number of
    words in the transmit and receive FIFOs. The fields appear in [Table 11-7](#table11-7).
    Although there are 3 bits associated with these fields, the FIFOs hold only four
    words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-7: MFSR Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 2 | Number of words in transmit buffer |'
  prefs: []
  type: TYPE_TB
- en: '| 16 to 18 | Number of words in receive buffer |'
  prefs: []
  type: TYPE_TB
- en: The Master Transmit Data Register (MTDR) The MTDR accepts commands and data
    bytes to control writing data onto the I²C bus. It has two fields, shown in [Table
    11-8](#table11-8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-8: MTDR Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Field** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 7 | Data |'
  prefs: []
  type: TYPE_TB
- en: '| 8 to 10 | Command |'
  prefs: []
  type: TYPE_TB
- en: Any write to the LO 8 bits, be it by a byte write or a 16-bit (or 32-bit) write
    to this register, will insert the data byte at the end of the transmit FIFO and
    increment the FIFO pointer—assuming, of course, that the FIFO is not full. Also
    note that an 8-bit write to the LO 8 bits will zero-extend the write operation
    and write 0b000 to the command bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command field is a 3-bit command code (see [Table 11-9](#table11-9)). Writing
    a single byte to bits 8 to 15 executes the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Table 11-9: MTDR Command Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command bits** | **Command** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0b000 | Transmit data (found in bits 0 to 7). |'
  prefs: []
  type: TYPE_TB
- en: '| 0b001 | Receive data. Bits 0 to 7 specify the number of bytes to receive
    (plus 1). |'
  prefs: []
  type: TYPE_TB
- en: '| 0b010 | Send stop condition. |'
  prefs: []
  type: TYPE_TB
- en: '| 0b011 | Receive and discard bytes. Bits 0 to 7 specify the number of bytes
    to receive (plus 1). |'
  prefs: []
  type: TYPE_TB
- en: '| 0b100 | Generate (repeated) start condition and transmit address in bits
    0 to 7. |'
  prefs: []
  type: TYPE_TB
- en: '| 0b101 | Generate (repeated) start condition and transmit address in bits
    0 to 7\. This transfer expects a NAK to be returned. |'
  prefs: []
  type: TYPE_TB
- en: '| 0b110 | Generate (repeated) start condition and transmit address in bits
    0 to 7 using high-speed mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 0b111 | Generate (repeated) start condition and transmit address in bits
    0 to 7 using high-speed mode. This transfer expects a NAK to be returned. |'
  prefs: []
  type: TYPE_TB
- en: Generally, the only command you’d write as a single byte (to bits 8 through
    15) would to be to send a stop condition. All other commands have data associated
    with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the FIFO holds commands as well as data. Therefore, the hardware associates
    the particular command it executes with the data as it pulls items from the transmit
    FIFO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Master Receive Data Register (MRDR) Data received by the I²C hardware gets
    added to the receive FIFO. Reading the MRDR retrieves the next available byte
    from the FIFO (in bits 0 through 7). Bit 14 of the MRDR is set if the FIFO is
    empty. Note that you can also check to see if data is available in the FIFO by
    reading bits 16 through 18 in the MFSR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 11.1.2 Teensy 4.*x* Wire Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following sections describe the operations of Gemmell’s Teensy 4 code directly
    associated with the Arduino I²C functions. I won’t provide the usual DAC output
    demonstration program in this section, since you can easily test Gemmell’s code
    by downloading his library, including it in your Teensyduino IDE, and running
    the Arduino example in Listing 8-1 (don’t forget to replace `#include <Wire.h>`
    with `#include <i2c_driver_wire.h>`). The results should prove nearly identical
    with possible slight differences in timing, as Gemmell’s code is running on a
    much faster processor than the Teensy 3.2 I used to produce the oscilloscope output
    in Listing 8-1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gemmell’s library provides drop-in code for the following Arduino I²C functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Wire.begin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wire.beginTransmission()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wire.endTransmission()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wire.write()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wire.requestFrom()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wire.read()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next sections describe the implementation of each of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you study Gemmell’s code, the best approach is to take a top-down look
    starting with the Arduino Wire objects. The *i2c_driver_wire.cpp* file declares
    the following three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Wire` object corresponds to the standard Arduino I²C Wire device and controls
    I²C communication on the Teensy SDA and SCL lines. The `Wire2` and `Wire3` objects
    are extensions of the original Arduino I²C library, supporting communication on
    the Teensy’s (SDA1, SCL1) and (SDA2, SCL2) lines.
  prefs: []
  type: TYPE_NORMAL
- en: The `Wire` objects support both master and slave devices. (Again, I use the
    archaic terms *master* and *slave* in this section only for consistency with ARM
    documentation and Gemmell’s code.) In this chapter I’ll focus just on the master
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.2.1 The begin() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `begin()` function replaces the standard Arduino `Wire.begin()` function.
    It is responsible for initializing the I²C hardware and software before calling
    other I²C functions. It initializes the appropriate Teensy pins for I²C communication,
    resets any existing I²C initialization, sets the I²C clock frequency, sets up
    interrupt vectors, and initializes the iMXRT 1062 registers as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Wire`, `Wire1`, and `Wire2` object declarations (in the *i2c_driver_wire.cpp*
    file) allocate storage but do little else. In the Arduino programming paradigm,
    object initialization does not take place in the constructor; instead, the initialization
    occurs during the call to the `I2CDriverWire::begin()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `begin()` function stops any current activity by calling the `end()` function
    and then punts on the task to the `I2CMaster` class constructor (the `master_frequency`
    parameter is the default I²C speed of 100 kHz). The `I2CMaster` class is just
    an abstract base class, overridden by the `IMX_RT1060_I2CMaster` class, which
    provides the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the overridden `begin()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before I discuss individual statements in this function, note that the identifier
    `port` is a class variable pointing at the register set for the I²C port on which
    this function operates; `config` is also a class variable containing the port
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `stop()` in the `begin()` function in the previous code shuts down
    any activity on the I²C port before this code initializes the system, which could
    happen, for example, if the programmer calls `begin()` twice. Here’s the code
    for `stop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing to the MCR using `port->MCR` ❶ does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LPI2C_MCR_RST` does a software reset of the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LPI2C_MCR_RRF` resets the receive FIFO memory buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LPI2C_MCR_RTF` resets the transmit FIFO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The write to SCR (by storing into `port->SCR`) does the same thing for peripheral
    (slave) mode ❷. Finally, the `stop` function ❶ turns off and disconnects any interrupts
    (and interrupt service routines).
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `initialise_common()` in the `begin` function initializes hardware
    common to the controller (master) and peripheral (slave) modes. Here’s the code
    for that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`IMX_RT1060_I2CBase::Config` ❶ is a structure in the *imx_rt1060_i2c_driver.h*
    file (see the next box for its form). It defines Teensy pins and other information.
    `CCM_CSCDR2` ❷ is a hardware definition on the MCU, the CCM Serial Clock Divider
    Register 2\. The assignment to this hardware register sets up an internal clock
    divider needed to generate the I²C clock. The `PODF` field is the clock divider,
    and the `CCM_CSCDR2_LPI2C_CLK_SEL` constant specifies that the I²C clock gets
    derived from the system oscillator.'
  prefs: []
  type: TYPE_NORMAL
- en: The assignment to `hardware.clock_gate_register` ❸ magically writes data to
    the CCM Clock Gating Register, because this variable overlays that register in
    the MCU’s memory map. Finally, the last two assignment statements in this function
    ❹ initialize the appropriate (depending on the port) SDA and SCL lines so that
    they are used for I²C communications, rather than as, for example, digital I/O
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment `port->MFCR` in the `begin()` function defines when an interrupt
    occurs. This particular statement sets the interrupts to occur when the transmit
    FIFO is completely empty or when the receive FIFO contains at least one word.
    In the Arduino environment, 0 (empty FIFO) is probably a good value to use. In
    a multithreaded environment, you might get better throughput on the I²C bus by
    setting the transmit value to 1 or some other nonzero value to keep the FIFO not
    empty as long as there is data to transmit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `set_clock()` sets the I²C bus to the frequency passed as an argument
    to this code. The parameter should be 100,000, 400,000, or 1,000,000\. You must
    call `set_clock()` before calling the `begin()` function. Here’s the code for
    the `set_clock()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `MCCR0` ❶ contains several bit fields filled in by the macros after the
    assignment. The `CLKLO` field specifies the minimum number of clock cycles the
    system uses for a low clock signal on the I²C bus. The `CLKHI` field is similar
    but specifies how long the clock must be high (this value must be less than `CLKLO`).
    The `DATAVD` field specifies the amount of time the data must remain valid on
    the SDA line. The `SETHOLD` field specifies the time for a start or stop condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `MCFGR1` ❷ controls several fields (see the NXP documentation). The main
    value being set here is the clock divisor. For 100 kHz the divisor is 2; for other
    frequencies the divisor is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MCFGR2` register ❸ determines:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of cycles used for SDA glitch filtering (`LPI2C_MCFGR2_FILTSDA`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of cycles used for SCL glitch filtering (`LPI2C_MCFGR2_FILTSCL`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of cycles to determine when the bus has gone idle (`LPI2C_MCFGR2_BUSIDLE`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MCCR1` register ❹ holds the clock configuration for I²C high-speed mode.
    See the discussion of `MCCR0` a few paragraphs earlier for more details as, other
    than speed, it behaves similarly to `MCCR1``.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
