<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_385"/><strong><span class="big">14</span><br/>MACHINE INTELLIGENCE</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">How many times a day do you submit something like “cats and meetloafs” to a search engine only to have it come back with, “Did you mean <em>cats and meatloaves</em>?” You probably take this for granted, without pausing to consider how the search engine knew not only that there was an error in your input, but also how to fix it. It’s not very likely that someone wrote a program to match all possible errors with corrections. Instead, some sort of <em>machine intelligence</em> must be at work.</p>
<p class="indent">Machine intelligence is an advanced topic that includes the related fields of <em>machine learning</em>, <em>artificial intelligence</em>, and <em>big data</em>. These are all concepts you’ll likely encounter as a programmer, so this chapter gives you a high-level overview.</p>
<p class="indent"><em>Artificial intelligence</em> was first out of the gate when the term was coined at a Dartmouth College workshop in 1956. <em>Machine learning</em> was a close <span epub:type="pagebreak" id="page_386"/>second with the <em>perceptron</em> in 1957, which we’ll discuss shortly. Today, machine learning has a huge lead, thanks in part to two trends. First, technological progress has dramatically increased storage size while reducing the price of it, and it has also led to faster processors and networking. Second, the internet has facilitated the collection of large amounts of data, and people can’t resist poking at all of it. For example, data from one large company’s book-scanning and translation project was used to dramatically improve a separate language translation project. Another example is a mapping project that fed into the development of self-driving cars. The results from these and other projects were so compelling that machine learning now is being applied to a large number of applications. More recently, people have also realized that these same two trends—cheaper storage and more computing power, and the collection of large amounts of data—support revitalizing artificial intelligence, resulting in a lot of new work in that area as well.</p>
<p class="indent">The rush to employ machine intelligence, however, mimics the “What can possibly go wrong?” philosophy that already pervades the computer security world. We don’t yet know enough to avoid producing psychotic systems such as HAL from the 1968 movie <em>2001: A Space Odyssey</em>.</p>
<h3 class="h3" id="ch14lev1sec1"><strong>Overview</strong></h3>
<p class="noindent">You should know by now that programming is the grunt work needed to implement solutions to problems. Defining the problems and their solutions is the interesting and harder part. Many would rather devote their entire careers trying to get computers to do this work instead of doing it themselves (another example of the “peculiar engineering laziness” mentioned in <a href="ch05.xhtml#ch05">Chapter 5</a>).</p>
<p class="indent">As noted earlier, it all started with artificial intelligence; machine learning and big data came later. Though the term wasn’t coined until the 1956 Dartmouth workshop, the notion of artificial intelligence goes all the way back to Greek myths. Many philosophers and mathematicians since have worked to develop formal systems that codify human thought. While this hasn’t yet led to true artificial intelligence, it has laid a lot of groundwork. For example, George Boole, who gave us our algebra in <a href="ch01.xhtml#ch01">Chapter 1</a>, published <em>An Investigation of the Laws of Thought on Which Are Founded the Mathematical Theories of Logic and Probabilities</em> in 1854.</p>
<p class="indent">We’ve accumulated a lot of information about human decision making but still don’t really know how humans think. For example, you and your friends can probably distinguish a cat from a meatloaf. But you might be taking different paths to reach that distinction. Just because the same data yields the same result doesn’t mean that we all processed it the same way. We know the inputs and outputs, we understand parts of the “hardware,” but we don’t know much about the “programming” that transforms one into the other. It follows that the path that a computer uses to recognize cats and meatloaves would also be different.</p>
<p class="indent">One thing that we do think we know about human thought processing is that we’re really good at statistics unconsciously—not the same thing as consciously suffering through “sadistics” class. For example, linguists have <span epub:type="pagebreak" id="page_387"/>studied how humans acquire language. Infants perform a massive amount of statistical analysis as part of learning to tease important sounds out of the environment, separate them into phonemes, and then group them into words and sentences. It’s an ongoing debate as to whether humans have specialized machinery for this sort of thing or whether we’re just using general-purpose processing for it.</p>
<p class="indent">Infant learning via statistical analysis is made possible, at least in part, by the existence of a large amount of data to analyze. Barring exceptional circumstances, infants are constantly exposed to sound. Likewise, there is a constant barrage of visual information and other sensory input. Infants learn by processing a big amount of data, or just <em>big data</em>.</p>
<p class="indent">The massive growth in compute power, storage capacity, and various types of network-connected sensors (including cell phones) has led to the collection of huge amounts of data, and not just by the bad guys from the last chapter. Some of this data is organized and some isn’t. Organized data might be sets of wave height measurements from offshore buoys. Unorganized data might be ambient sound. What do we do with all of it?</p>
<p class="indent">Well, statistics is one of those well-defined branches of mathematics, which means that we can write programs that perform statistical analysis. We can also write programs that can be trained using data. For example, one way to implement spam filters (which we’ll look at in more detail shortly) is to feed lots of collected spam and nonspam into a statistical analyzer while telling the analyzer what is spam and what isn’t. In other words, we’re feeding organized <em>training data</em> into a program and telling the program what that data means (that is, what’s spam and what’s not). We call this <em>machine learning (ML)</em>. Kind of like Huckleberry Finn, we’re “gonna learn that machine” instead of “teaching” it.</p>
<p class="indent">In many respects, machine learning systems are analogous to human autonomic nervous system functions. In humans, the brain isn’t actively involved in a lot of low-level processes, such as breathing; it’s reserved for higher-level functions, such as figuring out what’s for dinner. The low-level functions are handled by the autonomic nervous system, which only bothers the brain when something needs attention. Machine learning is currently good for recognizing, but that’s not the same thing as taking action.</p>
<p class="indent">Unorganized data is a different beast. We’re talking big data, meaning that it’s not something that humans can comprehend without assistance. In this case, various statistical techniques are used to find patterns and relationships. For example, this approach—sometimes known as <em>data mining</em>—could be used to extract music from ambient sound (after all, as French composer Edgard Varèse said, music is organized sound).</p>
<p class="indent">All of this is essentially finding ways to transform complex data into something simpler. For example, one could train a machine learning system to recognize cats and meatloaves. It would transform very complex image data into simple cat and meatloaf bits. It’s a <em>classification</em> process.</p>
<p class="indent">Back in <a href="ch05.xhtml#ch05">Chapter 5</a>, we discussed the separation of instructions and data. In <a href="ch13.xhtml#ch13">Chapter 13</a>, I cautioned against allowing data to be treated as instructions for reasons of security. But there are times when it makes sense, because data-driven classification can only get us so far.</p>
<p class="indent"><span epub:type="pagebreak" id="page_388"/>One can’t, for example, create a self-driving car based on classification alone. A set of complicated programs that acts on classifier outputs must be written to implement behavior such as “Don’t hit cats, but it’s okay and possibly beneficial to society to drive over a meatloaf.” There are many ways in which this behavior could be implemented, including combinations of swerving and changing speed. There are large numbers of variables to consider, such as other traffic, the relative position of obstacles, and so on.</p>
<p class="indent">People don’t learn to drive from complex and detailed instructions such as “Turn the wheel one degree to the left and put one gram of pressure on the brake pedal for three seconds to avoid the cat,” or “Turn three degrees to the right and floor it to hit the meatloaf dead on.” Instead, they work from goals such as “Don’t hit cats.” People “program” themselves, and, as mentioned earlier, we have no way yet to examine that programming to determine how they choose to accomplish goals. If you observe traffic, you’ll see a lot of variation in how people accomplish the same basic tasks.</p>
<p class="indent">People are not just refining their classifiers in cases like this; they’re writing new programs. When computers do this, we call it <em>artificial intelligence (AI)</em>. AI systems write their own programs to accomplish goals. One way to achieve this without damaging any actual cats is to provide an AI system with simulated input. Of course, philosophical thermostellar devices such as Bomb 20 from the 1974 movie <em>Dark Star</em> show that this doesn’t always work out well.</p>
<p class="indent">A big difference between machine learning and artificial intelligence is the ability to examine a system and “understand” the “thought processes.” This is currently impossible in machine learning systems but is possible with AI. It’s not clear if that will continue when AI systems get huge, especially as it’s unlikely that the processes will resemble human thought.</p>
<h3 class="h3" id="ch14lev1sec2"><strong>Machine Learning</strong></h3>
<p class="noindent">Let’s see if we can come up with a way to distinguish a photograph of a cat from a photograph of a meatloaf. This is a lot less information than a human has available with real cats and meatloaves. For example, humans have discovered that cats typically run away when chased, which is not common meatloaf behavior. We’ll try to create a process that, when presented with a photograph, will tell us whether “it sees” a cat, a meatloaf, or neither. <a href="ch14.xhtml#ch14fig01">Figure 14-1</a> shows the original images of a meatloaf-looking Tony Cat on the left and an actual meatloaf on the right.</p>
<div class="image"><a id="ch14fig01"/><img src="../images/14fig01-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-1: Original Tony Cat and meatloaf</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_389"/>There’s a high probability that you’ll encounter statistics at all levels of machine intelligence, so we’ll start by reviewing some of the basics.</p>
<h4 class="h4" id="ch14lev2sec1"><strong><em>Bayes</em></strong></h4>
<p class="noindent">English minister Thomas Bayes (1701–1761) must have been concerned about the chances of his flock getting into heaven because he thought a lot about probability. In particular, Bayes was interested in how the probabilities of different events combined. For example, if you’re a backgammon player, you’re probably well aware of the probability distribution of numbers that result from rolling a pair of six-sided dice. He’s responsible for the eponymous <em>Bayes’</em> theorem.</p>
<p class="indent">The part of his work that’s relevant here is what’s called a <em>naive Bayes classifier</em>. Leaving our meatloaf with the cat for a while, let’s try to separate out messages that are spam from messages that aren’t. Messages are collections of words. Certain words are more likely to occur in spam, from which we can infer that messages without those words might not be spam.</p>
<p class="indent">We’ll start by collecting some simple statistics. Let’s assume that we have a representative sample of messages, 100 that are spam and another 100 that aren’t. We’ll break the messages up into words and count the number of messages in which each word occurs. Since we’re using 100 messages, that magically gives us the percentage. Partial results are shown in <a href="ch14.xhtml#ch14tab01">Table 14-1</a>.</p>
<p class="tabcap" id="ch14tab01"><strong>Table 14-1:</strong> Words in Messages Statistics</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:30%"/>
<col style="width:40%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Word</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Spam percentage</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Nonspam percentage</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">meatloaf</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">80</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">0</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">hamburger</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">75</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">5</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">catnip</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">0</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">70</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">onion</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">68</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">0</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">mousies</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">1</p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac">67</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">the</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">99</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabac">98</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba">and</p></td>
<td style="vertical-align: top;" class="table-va"><p class="tabac">97</p></td>
<td style="vertical-align: top;" class="table-va"><p class="tabac">99</p></td>
</tr>
</tbody>
</table>
<p class="indent">You can see that some words are common to both spam and nonspam. Let’s apply this table to an unknown message that contains “hamburger and onion:” respectively, the spam percentages are 75, 97, and 68, and the nonspam percentages are 5, 97, and 0. What’s the probability that this message is or isn’t spam?</p>
<p class="indent">Bayes’ theorem tells us how to combine probabilities (<em>p</em>) where <em>p</em><sub>0</sub> is the probability that a message containing the word <em>meatloaf</em> is spam, <em>p</em><sub>1</sub> is the probability that a message containing the word <em>hamburger</em> is spam, and so on:</p>
<div class="equ-image"><img src="../images/eq389-01.jpg" alt="Image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_390"/>This can be visualized as shown in <a href="ch14.xhtml#ch14fig02">Figure 14-2</a>. Events and probabilities such as those from <a href="ch14.xhtml#ch14tab01">Table 14-1</a> are fed into the classifier, which yields the probability that the events describe what we want.</p>
<div class="image"><a id="ch14fig02"/><img src="../images/14fig02.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-2: Naive Bayes classifier</em></p>
<p class="indent">We can build a pair of classifiers, one for spam and one for nonspam. Plugging in the numbers from the above example, this gives us a 99.64 percent chance that the message is spam and a 0 percent chance that it’s not.</p>
<p class="indent">You can see that this technique works pretty well. Statistics rules! There are, of course, a lot of other tricks needed to make a decent spam filter. For example, understanding what’s meant by “naive.” It doesn’t mean that Bayes didn’t know what he was doing. It means that just like rolling dice, all of the events are unrelated. We could improve our spam filtering by looking at the relationship between words, such as the fact that “and and” appears only in messages about Boolean algebra. Many spammers try to evade filters by including a large amount of “word salad” in their messages, which is rarely grammatically correct.</p>
<h4 class="h4" id="ch14lev2sec2"><strong><em>Gauss</em></strong></h4>
<p class="noindent">German mathematician Johann Carl Friedrich Gauss (1777–1855) is another statistically important person. You can blame him for the <em>bell curve</em>, also called a <em>normal distribution</em> or <em>Gaussian distribution</em>. It looks like <a href="ch14.xhtml#ch14fig03">Figure 14-3</a>.</p>
<div class="image"><a id="ch14fig03"/><img src="../images/14fig03.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-3: Bell curve</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_391"/>The bell curve is interesting because samples of observed phenomena fit the curve. For example, if we measure the height of basketball players at a park and determine the mean height μ, some players will be taller and some will be shorter. (By the way, μ is pronounced “mew,” making it the preferred Greek letter for cats.) Of the players, 68 percent will be within one <em>standard deviation</em> or σ, 95 percent within two standard deviations, and so on. It’s more accurate to say that the height distribution converges on the bell curve as the number of samples increases, because the height of a single player isn’t going to tell us much. Carefully sampled data from a well-defined population can be used to make assumptions about larger populations.</p>
<p class="indent">While that’s all very interesting, there are plenty of other applications of the bell curve, some of which we can apply to our cat and meatloaf problem. American cartoonist Bernard Kliban (1935–1990) teaches us that a cat is essentially a meatloaf with ears and a tail. It follows that if we could extract features such as ears, tails, and meatloaves from photographs, we could feed them into a classifier that could identify the subject matter for us.</p>
<p class="indent">We can make object features more recognizable by tracing their outlines. Of course, we can’t do this unless we can find their edges. This is difficult because both cats and a fair number of meatloaves are fuzzy. Cats in particular have a lot of distinct hairs that are edges unto themselves, but not the ones we want. While it might seem counterintuitive, our first step is to blur the images slightly to eliminate some of these unwanted aspects. Blurring an image means applying a low-pass filter, like we saw for audio in <a href="ch06.xhtml#ch06">Chapter 6</a>. Fine details in an image are “high frequencies.” It’s intuitive if you think about the fine details changing faster as you scan across the image.</p>
<p class="indent">Let’s see what Gauss can do for us. Let’s take the curve from <a href="ch14.xhtml#ch14fig03">Figure 14-3</a> and spin it around μ to make a three-dimensional version, as shown in <a href="ch14.xhtml#ch14fig04">Figure 14-4</a>.</p>
<div class="image"><a id="ch14fig04"/><img src="../images/14fig04.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-4: Three-dimensional Gaussian distribution</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_392"/>We’ll drag this across the image, centering μ over each pixel in turn. You can imagine that parts of the curve cover other pixels surrounding the center pixel. We’re going to generate a new value for each pixel by multiplying the values of the pixels under the curve by the value of the curve and then adding the results together. This is called a <em>Gaussian blur</em>. You can see how it works in <a href="ch14.xhtml#ch14fig05">Figure 14-5</a>. The image in the middle is a magnified copy of what’s in the square in the image on the left. In the right-hand image, you can see how the Gaussian blur weights a set of pixels from the center image.</p>
<div class="image"><a id="ch14fig05"/><img src="../images/14fig05.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-5: Gaussian blur</em></p>
<p class="indent">The process of combining the value of a pixel with the values of its neighbors might seem convoluted to you, and in fact it’s mathematically known as <em>convolution</em>. The array of weights is called a <em>kernel</em> or <em>convolution kernel</em>. Let’s look at some examples.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig06">Figure 14-6</a> shows a 3×3 and a 5×5 kernel. Note that the weights all add up to 1 to preserve brightness.</p>
<div class="image"><a id="ch14fig06"/><img src="../images/14fig06.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-6: Gaussian convolution kernels</em></p>
<p class="indent"><a href="ch14.xhtml#ch14fig07">Figure 14-7</a> shows an original image on the left. Your eye can trace the outline of the tree trunks even though there are many gaps. The center image shows the results of a 3×3 kernel. While it’s fuzzier, the edges are easier to discern. The right image shows the results of a 5×5 kernel.</p>
<p class="indent">You can think of the image as if it’s a mathematical function of the form <em>brightness</em> = <em>f</em>(<em>x</em>, <em>y</em>). The value of this function is the pixel brightness at each coordinate location. Note that this is a <em>discrete</em> function; the values for <em>x</em> and <em>y</em> must be integers. And, of course, they have to be inside the image boundaries. In a similar fashion, you can think of a convolution kernel as a small image whose value is <em>weight</em> = <em>g</em>(<em>x</em>, <em>y</em>). Thus, the process of performing the convolution involves iterating through the neighboring pixels covered by the kernel, multiplying the pixel values by the weights, and adding them together.</p>
<span epub:type="pagebreak" id="page_393"/>
<div class="image"><a id="ch14fig07"/><img src="../images/14fig07.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-7: Gaussian blur examples</em></p>
<p class="indent"><a href="ch14.xhtml#ch14fig08">Figure 14-8</a> shows our original images blurred using a 5×5 Gaussian kernel.</p>
<div class="image"><a id="ch14fig08"/><img src="../images/14fig08.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-8: Blurred cat and meatloaf</em></p>
<p class="indent">Note that because the convolution kernels are bigger than 1 pixel, they hang off the edges of the image. There are many approaches to dealing with this, such as not going too close to the edge (making the result smaller) and making the image larger by drawing a border around it.</p>
<h4 class="h4" id="ch14lev2sec3"><strong><em>Sobel</em></strong></h4>
<p class="noindent">There’s a lot of information in <a href="ch14.xhtml#ch14fig01">Figure 14-1</a> that isn’t really necessary for us to identify the subject matter, such as color. For example, in his book <em>Understanding Comics: The Invisible Art</em> (Tundra), Scott McCloud shows that we can recognize a face from just a circle, two dots, and a line; the rest of the details are unnecessary and can be ignored. Accordingly, we’re going to simplify our images.</p>
<p class="indent">Let’s try to find the edges now that we’ve made them easier to see by blurring. There are many definitions of <em>edge</em>. Our eyes are most sensitive to changes in brightness, so we’ll use that. The change in brightness is just the difference in brightness between a pixel and its neighbor.</p>
<p class="indent"><span epub:type="pagebreak" id="page_394"/>About half of calculus is about change, so we can apply that here. A <em>derivative</em> of a function is just the slope of the curve generated by the function. If we want the change in brightness from one pixel to the next, then the formula is just <em>brightness</em> = <em>f</em>(<em>x</em> + 1, <em>y</em>) – <em>f</em>(<em>x</em>, <em>y</em>).</p>
<p class="indent">Take a look at the horizontal row of pixels in <a href="ch14.xhtml#ch14fig09">Figure 14-9</a>. The brightness level is plotted underneath, and beneath that is plotted the change in brightness. You can see that it looks spiky. That’s because it only has a nonzero value during a change.</p>
<div class="image"><a id="ch14fig09"/><img src="../images/14fig09.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-9: Edges are changes in brightness</em></p>
<p class="indent">There’s a problem with measuring brightness changes this way—the changes happen in the cracks between the pixels. We want the changes to be in the middle of the pixels. Let’s see if Gauss can help us out here. When we were blurring, we centered μ on a pixel. We’ll take the same approach, but instead of using the bell curve, we’ll use its first derivative, shown in <a href="ch14.xhtml#ch14fig10">Figure 14-10</a>, which plots the slope of the curve from <a href="ch14.xhtml#ch14fig03">Figure 14-3</a>.</p>
<div class="image"><a id="ch14fig10"/><img src="../images/14fig10.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-10: Slope of the Gaussian curve from <a href="ch14.xhtml#ch14fig03">Figure 14-3</a></em></p>
<p class="indent">If we call the positive and negative peaks of the curve +1 and –1 and center those over the neighboring pixels, the change of brightness for a pixel is Δbrightness<sub><em>n</em></sub> = 1 × pixel<sub><em>n</em> – 1</sub> – 1 × pixel<sub><em>n</em> + 1</sub>. You can see how this plays out in <a href="ch14.xhtml#ch14fig11">Figure 14-11</a>.</p>
<div class="image"><a id="ch14fig11"/><img src="../images/14fig11.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-11: Brightness change centered on pixels</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_395"/>Of course, this has the same image edge problem that we saw in the last section, so we don’t have values for the end pixels. At the moment, we don’t care about the direction of change, just the amount, so we calculate the <em>magnitude</em> by taking the absolute value.</p>
<p class="indent">Detecting edges this way works pretty well, but many people have tried to improve on it. One of the winning approaches, the <em>Sobel operator</em>, was announced by American scientist Irwin Sobel along with Gary Feldman in a 1968 paper.</p>
<p class="indent">Similar to what we did with our Gaussian blur kernel, we generate a Sobel edge detection kernel using values from the slope of the Gaussian curve. We saw the two-dimensional version in <a href="ch14.xhtml#ch14fig10">Figure 14-10</a>, and <a href="ch14.xhtml#ch14fig12">Figure 14-12</a> shows the three-dimensional version.</p>
<div class="image"><a id="ch14fig12"/><img src="../images/14fig12.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-12: Three-dimensional slope of Gaussian curve from <a href="ch14.xhtml#ch14fig10">Figure 14-10</a></em></p>
<p class="indent">Since this isn’t symmetrical around both axes, Sobel used two versions—one for the horizontal direction and another for the vertical. <a href="ch14.xhtml#ch14fig13">Figure 14-13</a> shows both kernels.</p>
<div class="image"><a id="ch14fig13"/><img src="../images/14fig13.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-13: Sobel kernels</em></p>
<p class="indent">Applying these kernels produces a pair of <em>gradients</em>, G<em><sub>x</sub></em> and G<em><sub>y</sub></em>, for each pixel; you can think of a gradient as a slope. Since we have a gradient in each Cartesian direction, we can use trigonometry to convert them into polar coordinates, yielding a <em>magnitude G</em> and a <em>direction</em> θ, as shown in <a href="ch14.xhtml#ch14fig14">Figure 14-14</a>.</p>
<span epub:type="pagebreak" id="page_396"/>
<div class="image"><a id="ch14fig14"/><img src="../images/14fig14.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-14: Gradient magnitude and direction</em></p>
<p class="indent">The gradient magnitude tells us how “strong” an edge we have, and the direction gives us its orientation. Keep in mind that direction is perpendicular to the object; a horizontal edge has a vertical gradient.</p>
<p class="indent">You might have noticed that the magnitude and direction calculation is really just the transformation from Cartesian to polar coordinates that we saw in <a href="ch11.xhtml#ch11">Chapter 11</a>. Changing coordinate systems is a handy trick. In this case, once we’re in polar coordinates, we don’t have to worry about division by zero or huge numbers when denominators get small. Most math libraries have a function of the form <code>atan2(y, x)</code> that calculates the arctangent without division.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig15">Figure 14-15</a> shows the gradient magnitudes for both images.</p>
<div class="image"><a id="ch14fig15"/><img src="../images/14fig15.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-15: Sobel magnitudes for blurred cat and meatloaf</em></p>
<p class="indent">There’s an additional issue with the direction, which is that it has more information than we can use. Take a look at <a href="ch14.xhtml#ch14fig16">Figure 14-16</a>.</p>
<div class="image"><a id="ch14fig16"/><img src="../images/14fig16.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-16: Pixel neighbors</em></p>
<p class="indent">As you can see, because a pixel has only eight neighbors, there are really only four directions we care about. <a href="ch14.xhtml#ch14fig17">Figure 14-17</a> shows how the direction is quantized into the four “bins.”</p>
<span epub:type="pagebreak" id="page_397"/>
<div class="image"><a id="ch14fig17"/><img src="../images/14fig17.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-17: Gradient direction bins</em></p>
<p class="indent"><a href="ch14.xhtml#ch14fig18">Figure 14-18</a> shows the binned Sobel directions for the blurred images. You can see the correspondence between the directions and the magnitudes. The top row is the horizontal bin followed by the diagonally up bin, the vertical bin, and the diagonally down bin.</p>
<div class="image"><a id="ch14fig18"/><img src="../images/14fig18.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-18: Sobel directions for blurred cat and meatloaf</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_398"/>As you can see, the Sobel operator is finding edges, but they’re not great edges. They’re fat, which makes it possible to mistake them for object features. Skinny edges would eliminate this problem, and we can use the Sobel directions to help find them.</p>
<h4 class="h4" id="ch14lev2sec4"><strong><em>Canny</em></strong></h4>
<p class="noindent">Australian computer scientist John Canny improved on edge detection in 1986 by adding some additional steps to the Sobel result. The first is <em>nonmaximum suppression</em>. Looking back at <a href="ch14.xhtml#ch14fig15">Figure 14-15</a>, you can see that some of the edges are fat and fuzzy; it’ll be easier later to figure out the features in our image if the edges are skinny. Nonmaximum suppression is a technique for <em>edge thinning</em>.</p>
<p class="indent">Here’s the plan. We compare the gradient magnitude of each pixel with that of its neighbors in the direction of the gradient. If its magnitude is greater than that of the neighbors, the value is preserved; otherwise, it’s suppressed by being set to 0 (see <a href="ch14.xhtml#ch14fig19">Figure 14-19</a>).</p>
<div class="image"><a id="ch14fig19"/><img src="../images/14fig19.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-19: Nonmaximum suppression</em></p>
<p class="indent">You can see in <a href="ch14.xhtml#ch14fig19">Figure 14-19</a> that the center pixel on the left is kept, as it has a greater magnitude (that is, it’s lighter) than its neighbors, while the center pixel on the right is suppressed because its neighbors have greater magnitude.</p>
<p class="indent"><a href="ch14.xhtml#ch14fig20">Figure 14-20</a> shows how nonmaximum suppression thins the edges produced by the Sobel operator.</p>
<div class="image"><a id="ch14fig20"/><img src="../images/14fig20.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-20: Nonmaximum suppression cat and meatloaf results</em></p>
<p class="indent">This is looking pretty good, although it makes a good case for meatloaf avoidance. Nonmaximum suppression found a lot of edges in the images. If you look back at <a href="ch14.xhtml#ch14fig15">Figure 14-15</a>, you’ll see that many of these edges have low gradient magnitudes. The final step in Canny processing is <em>edge tracking with hysteresis</em>, which removes “weak edges,” leaving only “strong edges.”</p>
<p class="indent">Back in <a href="ch02.xhtml#ch02">Chapter 2</a>, you learned that hysteresis involves comparison against a pair of thresholds. We’re going to scan the nonmaximum suppression results looking for edge pixels (white in <a href="ch14.xhtml#ch14fig20">Figure 14-20</a>) whose <span epub:type="pagebreak" id="page_399"/>gradient magnitude is greater than a high threshold. When we find one, we’ll make it a final edge pixel. We’ll then look at its neighbors. Any neighbor whose gradient magnitude is greater than a low threshold is also marked as a final edge pixel. We follow each of these paths using recursion until we hit a gradient magnitude that’s less than the low threshold. You can think of this as starting on a clear edge and tracing its connections until they peter out. You can see the results in <a href="ch14.xhtml#ch14fig21">Figure 14-21</a>. The strong edges are white; the rejected weak edges are gray.</p>
<div class="image"><a id="ch14fig21"/><img src="../images/14fig21.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-21: Edge tracking with hysteresis</em></p>
<p class="indent">You can see that a lot of the edges from nonmaximum suppression are gone and the object edges are fairly visible.</p>
<p class="indent">There is a great open source library for computer vision called <em>OpenCV</em> that you can use to play with all sorts of image processing, including what we’ve covered in this chapter.</p>
<h4 class="h4" id="ch14lev2sec5"><strong><em>Feature Extraction</em></strong></h4>
<p class="noindent">The next step is easy for people but difficult for computers. We want to extract features from the images in <a href="ch14.xhtml#ch14fig21">Figure 14-21</a>. I’m not going to cover feature extraction in detail because it involves a lot of math that you probably haven’t yet encountered, but we’ll touch on the basics.</p>
<p class="indent">There are a large number of feature extraction algorithms. Some, like the <em>Hough transform</em>, are good for extracting geometric shapes such as lines and circles. That’s not very useful for our problem because we’re not looking for geometric shapes. Let’s do something simple. We’ll scan our image for edges and follow them to extract objects. We’ll take the shortest path if we find edges that cross.</p>
<p class="indent">This gives us blobs, ears, cat toys, and squigglies, as shown in <a href="ch14.xhtml#ch14fig22">Figure 14-22</a>. Only a representative sample is shown.</p>
<div class="image"><a id="ch14fig22"/><img src="../images/14fig22.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-22: Extracted features</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_400"/>Now that we have these features, we can do just what we did with our earlier spam detection example: feed them into classifiers (as shown in <a href="ch14.xhtml#ch14fig23">Figure 14-23</a>). The classifier inputs marked + indicate that there’s some chance that the feature is indicative of our desired result, while – means that it’s counterindicative and 0 means that it has no contribution.</p>
<div class="image"><a id="ch14fig23"/><img src="../images/14fig23.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-23: Feature classification</em></p>
<p class="indent">Notice that there’s information in our images that can be used to improve on naive classification, such as the cat toys. They’re commonly found near cats but rarely associated with meatloaves.</p>
<p class="indent">This example isn’t good for much other than showing the steps of feature classification, which are summarized in <a href="ch14.xhtml#ch14fig24">Figure 14-24</a>.</p>
<div class="image"><a id="ch14fig24"/><img src="../images/14fig24.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-24: Image recognition pipeline</em></p>
<p class="indent">While meatloaves are mostly sedentary, cats move around a lot and have a plethora of cute poses. Our example will work only for the objects in our sample images; it’s not going to recognize the image in <a href="ch11.xhtml#ch11fig44">Figure 11-44</a> on <a href="ch11.xhtml#page_323">page 323</a> as a cat. And because of context issues, it has little chance of recognizing that the cat in <a href="ch14.xhtml#ch14fig25">Figure 14-25</a> <em>is</em> Meat Loaf.</p>
<div class="image"><a id="ch14fig25"/><img src="../images/14fig25.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-25: Cat or Meat Loaf?</em></p>
<h4 class="h4" id="ch14lev2sec6"><span epub:type="pagebreak" id="page_401"/><strong><em>Neural Networks</em></strong></h4>
<p class="noindent">At a certain level, it doesn’t really matter what data we use to represent objects. We need to be able to deal with the huge amount of variation in the world. Just like people, computers can’t change the inputs. We need better classifiers to deal with the variety.</p>
<p class="indent">One of the approaches used in artificial intelligence is to mimic human behavior. We’re pretty sure that <em>neurons</em> play a big part. Humans have about 86 billion neurons, although they’re not all in the “brain”—nerve cells are also neurons, which is possibly why some people think with their gut.</p>
<p class="indent">You can think of a neuron as a cross between logic gates from <a href="ch02.xhtml#ch02">Chapter 2</a> and analog comparators from <a href="ch06.xhtml#ch06">Chapter 6</a>. A simplified diagram of a neuron is shown in <a href="ch14.xhtml#ch14fig26">Figure 14-26</a>.</p>
<div class="image"><a id="ch14fig26"/><img src="../images/14fig26.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-26: Neuron</em></p>
<p class="indent">The <em>dendrites</em> are the inputs, and the <em>axon</em> is the output. The <em>axon terminals</em> are just connections from the axon to other neurons; neurons only have a single output. Neurons differ from something like an AND gate in that not all inputs are treated equally. Take a look at <a href="ch14.xhtml#ch14fig27">Figure 14-27</a>.</p>
<div class="image"><a id="ch14fig27"/><img src="../images/14fig27.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-27: Simplified gate model of a neuron</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_402"/>The value of each dendrite input is multiplied by some <em>weight</em>, and then all of the weighted values are added together. This is similar to a Bayes classifier. If these values are less than the <em>action potential</em>, the comparator output is <code>false</code>; otherwise, it’s <code>true</code>, causing the neuron to <em>fire</em> by setting the flip-flop output to <code>true</code>. The axon output is a <em>pulse</em>; as soon as it goes to <code>true</code>, the flip-flop is reset and goes back to <code>false</code>. Or, if you learned neuroscience from Mr. Miyagi: ax-on, ax-off. Neuroscientists might quibble with the depiction of the comparator as having hysteresis; real neurons do, but it’s time-dependent, which this model isn’t.</p>
<p class="indent">Neurons are like gates in that they’re “simple” but can be connected together to make complicated “circuits,” or <em>neural networks</em>. The key takeaway from neurons is that they fire based on their weighted inputs. Multiple combinations of inputs can cause a neuron to fire.</p>
<p class="indent">The first attempt at an artificial neuron was the <em>perceptron</em> invented by American psychologist Frank Rosenblatt (1928–1971). A diagram is shown in <a href="ch14.xhtml#ch14fig28">Figure 14-28</a>. An important aspect of perceptrons is that the inputs and outputs are binary; they can only have values of <code>0</code> or <code>1</code>. The weights and threshold are real numbers.</p>
<div class="image"><a id="ch14fig28"/><img src="../images/14fig28.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-28: Perceptron</em></p>
<p class="indent">Perceptrons created a lot of excitement in the AI world. But then it was discovered that they didn’t work for certain classes of problems. This, among other factors, led to what was called the “AI winter” during which funding dried up.</p>
<p class="indent">It turns out that the problem was in the way that the perceptrons were being used. They were organized as a single “layer,” as shown in <a href="ch14.xhtml#ch14fig29">Figure 14-29</a>, where each circle is a perceptron.</p>
<div class="image"><a id="ch14fig29"/><img src="../images/14fig29.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-29: Single-layer neural network</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_403"/>Inputs can go to multiple perceptrons, each of which makes one decision and produces an output. Many of the issues with perceptrons were solved by the invention of the multilayer neural network, as shown in <a href="ch14.xhtml#ch14fig30">Figure 14-30</a>.</p>
<div class="image"><a id="ch14fig30"/><img src="../images/14fig30.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-30: Multilayer neural network</em></p>
<p class="indent">This is also known as a <em>feedforward network</em> since the outputs produced from each layer are fed forward into the next layer. There can be an arbitrary number of <em>hidden layers</em>, so named because they’re not connected to either the inputs or outputs. Although <a href="ch14.xhtml#ch14fig30">Figure 14-30</a> shows the same number of neurons in each layer, that’s not a requirement. Determining the number of layers and number of neurons per layer for a particular problem is a black art outside the scope of this book. Neural networks like this are much more capable than simple classifiers.</p>
<p class="indent">Neuroscientists don’t yet know how dendrite weights are determined. Computer scientists had to come up with something because otherwise artificial neurons would be useless. The digital nature of perceptrons makes this difficult because small changes in weights don’t result in proportional changes in the output; it’s an all-or-nothing thing. A different neuron design, the <em>sigmoid neuron</em>, addresses this problem by replacing the perceptron comparator with a <em>sigmoid function</em>, which is just a fancy name for a function with an S-shaped curve. <a href="ch14.xhtml#ch14fig31">Figure 14-31</a> shows both the perceptron transfer function and the sigmoid function. Sure looks a lot like our discussion of analog and digital back in <a href="ch02.xhtml#ch02">Chapter 2</a>, doesn’t it?</p>
<div class="image"><a id="ch14fig31"/><img src="../images/14fig31.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-31: Artificial neuron transfer functions</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_404"/>The guts of a sigmoid neuron are shown in <a href="ch14.xhtml#ch14fig32">Figure 14-32</a>.</p>
<div class="image"><a id="ch14fig32"/><img src="../images/14fig32.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-32: Sigmoid neuron</em></p>
<p class="indent">One thing that’s not obvious here is that the sigmoid neuron inputs and outputs are “analog” floating-point numbers. Just for accuracy, there’s also a bias used in a sigmoid neuron, but it’s not essential for our understanding here.</p>
<p class="indent">The weights for neural networks built from sigmoid neurons can be determined using a technique called <em>backpropagation</em> that’s regularly lost and rediscovered, the latter most recently in a 1986 paper by David Rumelhart (1942–2011), Geoffrey Hinton, and Roland Williams. Backpropagation uses wads of linear algebra, so we’re going to gloss over the details. You’ve probably learned how to solve simultaneous equations in algebra; linear algebra comes into play when there are large numbers of equations with large numbers of variables.</p>
<p class="indent">The general idea behind backpropagation is that we provide inputs for something known, such as cat features. The output is examined, and if we know that the inputs represent a cat, we’d expect the output to be <code>1</code> or pretty close to it. We can calculate an <em>error function</em>, which is the actual output subtracted from the desired output. The weights are then adjusted to make the error function value as close to <code>0</code> as possible.</p>
<p class="indent">This is commonly done using an algorithm called <em>gradient descent</em>, which is a lot like Dante’s descent into hell if you don’t like math. Let’s get a handle on it using a simple example. Remember that “gradient” is just another word for “slope.” We’ll try different values for the weights and plot the value of the error function. It might look something like <a href="ch14.xhtml#ch14fig33">Figure 14-33</a>, which resembles one of those relief maps that shows mountains, valleys, and so on.</p>
<p class="indent">All that’s involved in gradient descent is to roll a ball around on the map until it lands in the deepest valley. That’s where the value of the error function is at its minimum. We set the weights to the values that represent the ball’s position. The reason that this algorithm gets a fancy name is that we’re doing this for very large numbers of weights, not just the two in our example. And it’s even more complicated when there are weights in multiple layers, such as we saw in <a href="ch14.xhtml#ch14fig30">Figure 14-30</a>.</p>
<span epub:type="pagebreak" id="page_405"/>
<div class="image"><a id="ch14fig33"/><img src="../images/14fig33.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-33: Gradient topology</em></p>
<p class="indent">You might have noticed the mysterious disappearance of the output pulsing mechanism that we saw in <a href="ch14.xhtml#ch14fig27">Figure 14-27</a>. The neural networks that we’ve seen so far are essentially combinatorial logic, not sequential logic, and are effectively DAGs. There is a sequential logic variation called a <em>recurrent neural network</em>. It’s not a DAG, which means that outputs from neurons in a layer can connect back to the inputs of neurons in an earlier layer. The storing of outputs and clocking of the whole mess is what keeps it from exploding. These types of networks perform well for processing sequences of inputs, such as those found in handwriting and speech recognition.</p>
<p class="indent">There’s yet another neural network variation that’s especially good for image processing: the <em>convolutional neural network</em>. You can visualize it as having inputs that are an array of pixel values similar to the convolution kernels that we saw earlier.</p>
<p class="indent">One big problem with neural networks is that they can be “poisoned” by bad training data. We can’t tell what sort of unusual behavior might occur in adults who watched too much television as kids, and the same is true with machine learning systems. There might be a need for machine psychotherapists in the future, although it’s hard to imagine sitting down next to a machine and saying, “So tell me how you really feel about pictures of cats.”</p>
<p class="indent">The bottom line on neural networks is that they’re very capable classifiers. They can be trained to convert a large amount of input data into a smaller amount of outputs that describe the inputs in a way that we desire. Sophisticates might call this <em>reducing dimensionality</em>. Now we have to figure out what to do with that information.</p>
<h4 class="h4" id="ch14lev2sec7"><span epub:type="pagebreak" id="page_406"/><strong><em>Using Machine Learning Data</em></strong></h4>
<p class="noindent">How would we build something like a self-driving ketchup bottle using classifier outputs? We’ll use the test scenario shown in <a href="ch14.xhtml#ch14fig34">Figure 14-34</a>. We’ll move the ketchup bottle one square at a time as if it’s a king on a chessboard with the goal of hitting the meatloaf while avoiding the cat.</p>
<div class="image"><a id="ch14fig34"/><img src="../images/14fig34.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-34: Test scenario</em></p>
<p class="indent">In this “textbook example,” the classifiers give us the positions of the cat and meatloaf. Since the shortest distance between two points is a straight line, and since we’re on an integer grid, the most efficient way to reach the meatloaf is to use the Bresenham line-drawing algorithm from “<a href="ch11.xhtml#ch11lev2sec4">Straight Lines</a>” on <a href="ch11.xhtml#page_292">page 292</a>. Of course, it’ll have to be modified as shown in <a href="ch14.xhtml#ch14fig35">Figure 14-35</a>, because cats and condiments don’t go well together.</p>
<div class="image"><a id="ch14fig35"/><img src="../images/14fig35.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-35: Autonomous ketchup bottle algorithm</em></p>
<p class="indent">As you can see, it’s pretty simple. We make a beeline for the meatloaf, and if the cat’s in the way, we jog and make another beeline for the meatloaf. Of course, this gets much more complicated in the real world, where the cat can move and there may be other obstacles.</p>
<p class="indent">Now let’s look at one of the other machine intelligence subfields to see a different way to approach this problem.</p>
<h3 class="h3" id="ch14lev1sec3"><span epub:type="pagebreak" id="page_407"/><strong>Artificial Intelligence</strong></h3>
<p class="noindent">Early artificial intelligence results, such as learning to play checkers and solve various logic problems, were exciting and produced a lot of funding. Unfortunately, these early successes didn’t scale to harder problems, and funding dried up.</p>
<p class="indent">One of the attendees at the 1956 Dartmouth workshop where the term was coined was American scientist John McCarthy (1927–2011), who designed the LISP programming language while at the Massachusetts Institute of Technology. This language was used for much of the early AI work, and LISP officially stands for <em>List Processor</em>—but anybody familiar with the language syntax knows it as <em>Lots of Insipid Parentheses</em>.</p>
<p class="indent">LISP introduced several new concepts to high-level programming languages. Of course, that wasn’t hard back in 1958, since only one other high-level language existed at the time (FORTRAN). In particular, LISP included singly linked lists (see <a href="ch07.xhtml#ch07">Chapter 7</a>) as a data type with programs as lists of instructions. This meant that programs could modify themselves, which is an important distinction with machine learning systems. A neural network can adjust weights but can’t change its algorithm. Because LISP can generate code, it can modify or create new algorithms. While it’s not quite as clean, JavaScript also supports <em>self-modifying code</em>, although it’s dangerous to do in the minimally constrained environment of the web.</p>
<p class="indent">Early AI systems quickly became constrained by the available hardware technology. One of the most common machines used for research at the time was the DEC PDP-10, whose address space was initially limited to 256K 36-bit words, and eventually expanded to 4M. This isn’t enough to run the machine learning examples in this chapter. American programmer Richard Greenblatt and computer engineer Tom Knight began work in the early 1970s at MIT to develop <em>Lisp machines</em>, which were computers optimized to run LISP. However, even in their heyday, only a few thousand of these machines were ever built, possibly because general-purpose computers were advancing at a faster pace.</p>
<p class="indent">Artificial intelligence started making a comeback in the 1980s with the introduction of <em>expert systems</em>. These systems assist users, such as medical professionals, by asking questions and guiding them through a knowledge database. This should sound familiar to you; it’s a serious application of our “Guess the Animal” game from <a href="ch10.xhtml#ch10">Chapter 10</a>. Unfortunately, expert systems seem to have matured into annoying phone menus.</p>
<p class="indent">We’re going to attack our self-driving ketchup bottle problem with a <em>genetic algorithm</em>, which is a technique that mimics evolution (see <a href="ch14.xhtml#ch14fig36">Figure 14-36</a>).</p>
<span epub:type="pagebreak" id="page_408"/>
<div class="image"><a id="ch14fig36"/><img src="../images/14fig36.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-36: Genetic algorithm</em></p>
<p class="indent">We randomly create a set of car <em>cells</em> that each have a position and a direction of movement. Each cell is moved one step, and then a “goodness” score is calculated, in this case using the distance formula. We breed the two best-performing cells to create a new one, and we kill off the worst-performing cell. Because it’s evolution, we also randomly mutate one of the cells. We keep stepping until one of the cells reaches the goal. The steps that the cell took to reach the goal are the generated program.</p>
<p class="indent">Let’s look at the results from running the algorithm with 20 cells. We got lucky and found the solution shown in <a href="ch14.xhtml#ch14fig37">Figure 14-37</a> in only 36 iterations.</p>
<div class="image"><a id="ch14fig37"/><img src="../images/14fig37.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-37: Good genetic algorithm results</em></p>
<p class="indent">Our algorithm created the simple program in <a href="ch14.xhtml#ch14list01">Listing 14-1</a> to accomplish the goal. The important point is that a programmer didn’t write this program; our AI did it for us. The variables <code>x</code> and <code>y</code> are the position of the ketchup bottle.</p>
<span epub:type="pagebreak" id="page_409"/>
<pre>x++;<br/>
x++;<br/>
x++; y++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++;<br/>
x++; y--;</pre>
<p class="listing" id="ch14list01"><em>Listing 14-1: Generated code</em></p>
<p class="indent">Of course, being genetics, it’s random and doesn’t always work out so cleanly. Another run of the program took 82 iterations to find the solution in <a href="ch14.xhtml#ch14fig38">Figure 14-38</a>. Might make the case for “intelligent design.”</p>
<div class="image"><a id="ch14fig38"/><img src="../images/14fig38.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 14-38: Strange genetic algorithm results</em></p>
<p class="indent">You can see that AI programs can generate surprising results. But they’re not all that different from what children come up with when exploring the world; it’s just that people are now paying more attention. In fact, many AI results that surprise some people were predicted long ago. For example, there was a lot of press when a company’s AI systems created their own private language to communicate with each other. That’s not a new idea to anybody who has seen the 1970 science fiction film <em>Colossus: The Forbin Project</em>.</p>
<h3 class="h3" id="ch14lev1sec4"><strong>Big Data</strong></h3>
<p class="noindent">If it’s not obvious from the examples so far, we’re processing a lot of data. An HD (1920×1080) video camera produces around a third of a gigabyte of data every second. The Large Hadron Collider generates about 25 GiB/second. It’s estimated that network-connected devices generate about 50 GiB/second, up from about 1 MiB/second a quarter-century ago. Most of this information is garbage; the challenge is to mine the useful parts.</p>
<p class="indent">Big data is a moving target; it refers to data that is too big and complex to process using brute-force techniques in the technology of the day. The <span epub:type="pagebreak" id="page_410"/>amount of data created 25 years ago is fairly trivial to process using current technology, but it wasn’t back then. Data collection is likely to always exceed data analysis capabilities, so cleverness is required.</p>
<p class="indent">The term <em>big data</em> refers not only to analysis but also to the collection, storage, and management of the data. For our purposes, we’re concerned with the analysis portion.</p>
<p class="indent">A lot of the data that’s collected is personal in nature. It’s not a great idea to share your bank account information or medical history with strangers. And data that is collected for one purpose is often used for another. The Nazis used census data to identify and locate Jews for persecution, for example, and American census data was used to locate and round up Japanese Americans for internment, despite a provision in the law keeping personally identifiable portions of that data confidential for 75 years.</p>
<p class="indent">A lot of data is released for research purposes in “anonymized” form, which means that any personally identifying information has been removed. But it’s not that simple. Big data techniques can often reidentify individuals from anonymized data. And many policies designed to make reidentification difficult have actually made it easier.</p>
<p class="indent">In America, the Social Security number (SSN) is regularly misused as a personal identifier. It was never designed for this use. In fact, a Social Security card contains the phrase “not for identification purposes,” which was part of the original law—one that’s rarely enforced and now has a huge number of exceptions.</p>
<p class="indent">An SSN has three fields: a three-digit area number (AN), a two-digit group number (GN), and a four-digit serial number (SN). The area number is assigned based on the postal code of the mailing address on the application form. Group numbers are assigned in a defined but nonconsecutive order. Serial numbers are assigned consecutively.</p>
<p class="indent">A group of Carnegie Mellon researchers published a paper in 2009 that demonstrated a method for successfully guessing SSNs. Two things made it easy. First is the existence of the Death Master File. (That’s “Death” “Master File,” not “Death Master” “File.”) It’s a list of deceased people made available by the Social Security Administration ostensibly for fraud prevention. It conveniently includes names, birth dates, death dates, SSNs, and postal codes. How does a list of dead people help us guess the SSNs of the living?</p>
<p class="indent">Well, it’s not the only data out there. Voter registration lists include birth data, as do many online profiles.</p>
<p class="indent">Statistical analysis of the ANs and postal codes in the Death Master File can be used to link ANs to geographic areas. The rules for assigning GNs and SNs are straightforward. As a result, the Death Master File information can be used to map ANs to postal codes. Separately obtained birth data can also be linked to postal codes. These two sources of information can be interleaved, sorting by birth date. Any gap in the Death Master SSN sequence is a living person whose SSN is between the preceding and following Death Master entries. An example is shown in <a href="ch14.xhtml#ch14tab02">Table 14-2</a>.</p>
<span epub:type="pagebreak" id="page_411"/>
<p class="tabcap" id="ch14tab02"><strong>Table 14-2:</strong> Combining Data from Postal Code 89044</p>
<table class="topbot-d">
<colgroup>
<col style="width:16%"/>
<col style="width:16%"/>
<col style="width:16%"/>
<col style="width:16%"/>
<col style="width:16%"/>
<col style="width:20%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="tablel-h" colspan="3"><p class="tab_thc"><strong>Death Master File</strong></p></td>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_thc"><strong>Guessed SSN</strong></p></td>
<td style="vertical-align: top;" class="table-h" colspan="2"><p class="tab_thc"><strong>Birth records</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_thc"><strong>Name</strong></p></td>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_thc"><strong>DOB</strong></p></td>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_thc"><strong>SSN</strong></p></td>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_th"> </p></td>
<td style="vertical-align: top;" class="tablel-h"><p class="tab_thc"><strong>DOB</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_thc"><strong>Name</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Many Jars</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-01-10</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1234</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba">John Fish</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-02-01</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1235</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Two Horns</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-02-12</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1236</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="tabac"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1237</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-02-14</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Jon Steinhart</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Worfin</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-02-20</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1238</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba">John Bigboote</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-03-15</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1239</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Ya Ya</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-04-19</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1240</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1241</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-04-20</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">John Gilmore</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Fledgling</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-05-21</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1242</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1243</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-05-22</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">John Perry Barlow</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Grim</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-06-02</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1244</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba">John Littlejohn</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-06-03</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1245</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-v"><p class="taba">John Chief Crier</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">1984-06-12</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="tabac">051-51-1246</p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">051-51-1247</p></td>
<td style="vertical-align: top;" class="tablel-b"><p class="tabac">1984-07-05</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">John Jacob Jingleheimer Schmidt</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="tablel-va"><p class="taba">John Small Berries</p></td>
<td style="vertical-align: top;" class="tablel-va"><p class="tabac">1984-08-03</p></td>
<td style="vertical-align: top;" class="tablel-va"><p class="tabac">051-51-1250</p></td>
<td style="vertical-align: top;" class="tablel-va"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="tablel-va"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba"> </p></td>
</tr>
</tbody>
</table>
<p class="indent">Of course, it’s not quite as straightforward as this example, but it’s not much more difficult either. For example, we only know the range for SSN SNs if there’s a gap in the Death Master data, such as the one shown between John Chief Crier and John Small Berries. Many organizations often ask you for the last four digits of your SSN for identification. As you can see from the example, those are the hardest ones to guess, so don’t make it easy by giving these out when asked. Push for some other means of identification.</p>
<p class="indent">Here’s another example. The Massachusetts Group Insurance Commission (GIC) released anonymized hospital data for the purpose of improving health care and controlling costs. Massachusetts governor William Weld assured the public that patient privacy was protected. You can probably see where this is going, with the moral being that he should have kept his mouth shut.</p>
<p class="indent">Governor Weld collapsed during a ceremony on May 18, 1996, and was admitted to the hospital. MIT graduate student Latanya Sweeney knew that the governor resided in Cambridge, and she spent $20 to purchase the complete voter rolls for that city. She combined the GIC data with the voter data, much as we did in <a href="ch14.xhtml#ch14tab02">Table 14-2</a>, and easily deanonymized the governor’s data. She sent his health records, including prescriptions and diagnoses, to his office.</p>
<p class="indent"><span epub:type="pagebreak" id="page_412"/>While this was a fairly easy case since the governor was a public figure, your phone probably has more compute power than was available to Sweeney in 1996. Computing resources today make it possible to tackle much harder cases.</p>
<h3 class="h3" id="ch14lev1sec5"><strong>Summary</strong></h3>
<p class="noindent">We’ve covered a lot of really complicated material in this chapter. You learned that machine learning, big data, and artificial intelligence are interrelated. You’ve also learned that many more math classes are in store if you want to go into this field. No cats were harmed in the creation of this chapter.</p>
</body></html>