<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">12</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">BINARY TREES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">We’ve considered linear structures in previous chapters, and now we’ll start working with more complex structures—in particular, binary trees and some variants. (We’ll explore more general trees in the next chapter.) Binary trees find their way into lots of places, including data compression algorithms, video games, cryptographic techniques, compilers, and more, so they are a structure well worth knowing.</p>&#13;
<p class="TX">A special variety, binary search trees, can be quite efficient for implementing the bags or sets we explored in the previous chapter. However, since those kinds of trees can, on occasion, provide not-so-good performance, we’ll also consider some variants, such as assuredly balanced binary search trees (AVL trees) and probabilistically balanced trees (randomized binary search trees and splay trees).</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-58"/><span class="SANS_Futura_Std_Bold_B_11">What Are Trees?</span></h3>&#13;
<p class="TNI1">Trees allow you to represent hierarchical data structures. They differ from linear structures because a node can be connected to several other nodes, albeit with some restrictions. Organizational charts (or <i>organigrams</i>) are well-known examples of trees where a section of an enterprise can have several subsections, which themselves may have sub-subsections, and so on, in a recursive fashion, such as shown <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-1" src="../images/Figure12-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-1: An organigram from NASA, November 1961. Don’t worry if the text is unreadable; the structure is the important part, not the labels. (From</span> <span class="SANS_Futura_Std_Book_11"><a href="https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg">https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg</a>.</span><span class="SANS_Futura_Std_Book_Oblique_11">)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">HyperText Markup Language (HTML) also has a treelike structure. An HTML element can contain several other elements, which may themselves include further elements. Directories on your computer employ a tree structure as well. A directory has files and more directories, which themselves have files and more directories, and so on. (See question 12.2 at the end of this chapter for an exception.)</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>&#13;
<h4 class="H2" id="sec2"><span id="h2-94"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">General Trees</span></h4>&#13;
<p class="TNI1">A tree can be empty or consist of a node (called the <i>root</i> of the tree) that has several subtrees, each of which may be empty, of course. The root is the <i>parent</i> of its subtrees, and the roots of those subtrees are <i>children</i> of the root. The <i>nodes</i> that form a tree are connected by <i>edges</i> or <i>arcs</i>. Nodes with both parents and children are called <i>internal nodes</i>, and nodes without children are called <i>external nodes</i> or (more appropriately for the tree motif) <i>leaves</i>. Given a node, its children, and the children of those children, and so on are called its <i>descendants</i>. Similarly, the parent of a node, and the parent of that parent, and so on are called the node’s <i>ancestors</i>. The <i>level</i> of the tree’s root is 1, its children are level 2, the children of those children are level 3, and so on. The number of a node’s nonempty children is called its <i>degree</i>. Finally, for any tree or subtree, its <i>size</i> is the number of its nodes, and its <i>height</i> is the number of nodes in the longest path from the root to a leaf.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>From the previous definitions, it follows that there can be at most one path between any two nodes; trees cannot have any cycles or loops anywhere. Another property is that given any two nodes, either one is an ancestor of the other or they both have a common ancestor.</i></p>&#13;
<p class="TX">Trees are usually represented with the root at the top and the leaves at the bottom. Even if this goes against biology, we’ll follow that style. A possible tree could look like <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> (with the root at the top and all links going downward).</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-2" src="../images/Figure12-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-2: Trees are usually shown with the root at the top, branching down to the leaves, despite what biology teaches.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We’ll consider general trees (that is, those with any number of subtrees in any node) in the following chapter, so here we’ll focus on the most common version, binary trees.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-95"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Binary Trees</span></h4>&#13;
<p class="TNI1">A <i>binary tree</i> is either empty or has exactly two subtrees. We’ll see some additional definitions later, so the tree in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a> actually could be a binary tree. A binary tree is <i>full</i> if every node either is a leaf or has two nonempty children. <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> shows a possible case.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-3" src="../images/Figure12-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-3: A full binary tree: all nodes have zero or two children.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Full binary trees aren’t really that interesting unless they also satisfy some other properties. For example, if a tree is full and all leaves are at the same level, it’s called a <i>perfect</i> binary tree, which implies that nodes are packed as tightly as possible, as shown in <a href="chapter12.xhtml#fig12-4">Figure 12-4</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-4" src="../images/Figure12-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-4: A perfect binary tree is full and has all leaves at the same level.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">An interesting property, which a little math easily proves, is that the size of a perfect binary tree of <i>h</i> height is 2<i><sup>h</sup></i> – 1, so adding a new level approximately doubles the tree’s size. Conversely, the height of a perfect tree with <i>n</i> nodes is log <i>n</i>, rounded up. (We are using logarithms in base 2.)</p>&#13;
<p class="TX">Finally, if you have a tree of <i>h</i> height that becomes perfect if you eliminate all nodes at level <i>h</i> (with the allowed exception of the last level), it’s called a <i>complete</i> tree. We’ll look at some of those structures later in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>, when we study heaps. <a href="chapter12.xhtml#fig12-5">Figure 12-5</a> shows a complete tree, because if you were to remove all the nodes at the bottom level, you’d be left with a perfect tree.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-5" src="../images/Figure12-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-5: A complete tree would become a full tree if the bottom leaves were removed.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>With the generic definitions out of the way, let’s get started with binary trees. We’ll include a <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> in each node, and you can add more data attributes if needed. We’ll also have <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> pointers to the subtrees: each may either be <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> or point to another binary tree. Let’s start writing a binary tree module (you’ll reuse some of these methods here for binary tree variants later):</p>&#13;
<pre id="pre-219"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newTree = () =&gt; null;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const newNode = (key, left = null, right = null) =&gt; ({&#13;
  key,&#13;
  left,&#13;
  right&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const isEmpty = (tree) =&gt; tree === null;</code></pre>&#13;
<p class="TX">There’s not much to this code: <span class="SANS_TheSansMonoCd_W5Regular_11">newTree()</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> builds an initially empty tree; <span class="SANS_TheSansMonoCd_W5Regular_11">newNode()</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> creates a new node with a given key and (by default <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>) subtrees; and <span class="SANS_TheSansMonoCd_W5Regular_11">isEmpty()</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> detects whether a tree is empty (no surprise here).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-96"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Binary Search Trees</span></h4>&#13;
<p class="TNI1">For the remainder of this chapter, we’ll use <i>binary search trees</i>, which are a variant of binary trees, to implement the <i>bag</i> or <i>set</i> abstract data type (ADT), because they provide very efficient searching for keys. (Remember, the difference is that bags allow repeated values, but sets don’t.) For these trees, each node will be an object with a <span class="SANS_TheSansMonoCd_W5Regular_11">key</span>, plus some links to point at its children; in practice, you could also include an extra <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> field in a node for other usages. <a href="chapter12.xhtml#tab12-1">Table 12-1</a> describes the ADT.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Sets</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">set</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a set, determine if it is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set | error</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new value, add it to the set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a value, remove it from the set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a value, check if it exists in the set.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">What’s the difference between a binary tree and a binary search tree? Binary search trees satisfy the following property: for all nodes, the left subtree has only smaller keys and the right subtree has only greater keys. If you decide to allow duplicate keys, you need to amend the condition to say that the left subtree has smaller or equal keys and the right subtree has greater or equal keys. In <a href="chapter12.xhtml#fig12-6">Figure 12-6</a>, one of the trees is a binary search tree, but the other is not because of a single unlucky detail. Can you tell which is which?</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-6" src="../images/Figure12-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-6: Two binary trees, but only one is a binary search tree</span><span class="SANS_Futura_Std_Book_Oblique_11">. Which is it?</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The bottom tree isn’t a binary search tree, because the 13 key is to the right of key 22, and it should be to its left. Can you figure out exactly where it should go?</p>&#13;
<p class="TX">This property regarding keys of roots and subtrees is what allows you to use binary search trees as sets.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Finding a Key in a Binary Search Tree</span></h5>&#13;
<p class="TNI1">The recursive property regarding the relation of keys (which also applies to every subtree) provides a simple searching method. If you are looking for a given value in a binary search tree, one of three situations must happen:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">If the value is the key at the root of the tree, you’re done.</li>&#13;
<li class="ListBullet">Otherwise, if the value is smaller than the key at the root, the value (if present) must be in the left subtree.</li>&#13;
<li class="ListBullet">Finally, if the value is greater than the key at the root, the value must be in the right subtree.</li>&#13;
</ul>&#13;
<p class="TX">You can test this. <a href="chapter12.xhtml#fig12-7">Figure 12-7</a> shows a successful search for 12, highlighting the path that was taken and all the visited nodes.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-7" src="../images/Figure12-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-7: A successful search for key 12 in a binary search tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The search starts at the root. Since 12 &lt; 22, it moves to the left subtree. There, since 12 &gt; 9, it proceeds to the right subtree. Then, as 12 &gt; 11, it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>again goes to the right subtree, and the key is found. If you had been looking for 34 instead, the search would have failed, as shown in <a href="chapter12.xhtml#fig12-8">Figure 12-8</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-8" src="../images/Figure12-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-8: A failed search for key 34 in a binary search tree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Since 34 &gt; 22, the search starts down the root’s right subtree; next, as 34 &lt; 56, it goes to the left. Then, as 34 &gt; 24, it tries to go to the right but finds an empty tree (shown with a dotted border), so the search was unsuccessful.</p>&#13;
<p class="TX">You can code this logic straightaway, even before considering how you would do additions or deletions to a tree:</p>&#13;
<pre id="pre-220"><code>const find = (tree, keyToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   return false;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (keyToFind === tree.key) {&#13;
   return true;&#13;
 } else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return find(keyToFind &lt; tree.key ? tree.left : tree.right, keyToFind);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">Since trees are recursive by definition, it should be no surprise that this algorithm (and most others in this chapter) is implemented using recursion. There are two base cases: if the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the key isn’t in the tree, and if the key matches the value you’re looking for <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the search succeeds. But how do you keep searching? If the key you’re looking for is smaller than the key at the root, you recursively search the left subtree, and the right subtree otherwise <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Values to a Binary Search Tree</span></h5>&#13;
<p class="TNI1">How can we add a new key to a tree? Let’s work with a bag, and accept repeated keys; you’ll see how to do a set too. Be careful not to disturb the relationship between the root key and those of its subtrees—using a recursive algorithm is the best way to do this. If the tree is empty, you can simply add a new leaf to it. If the tree isn’t empty, apply recursion to go down the left or right subtree, depending on where the new key should be, until you reach an empty tree where you can insert the new key.</p>&#13;
<p class="TX">The previous section showed a failed search for a 34 key, so now the new key would be added at the place where the search ended, as shown in <a href="chapter12.xhtml#fig12-9">Figure 12-9</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-9" src="../images/Figure12-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-9: Adding a new key to a binary search tree at the place where it should have been found in a search</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code for this is as follows:</p>&#13;
<pre id="pre-221"><code>const add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
    return newNode(keyToAdd);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
    tree[side] = add(tree[side], keyToAdd);&#13;
    return tree;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, create a new node with the key to add, and that will be the root. If the tree isn’t empty, decide which of its subtrees must add the new key <span class="CodeAnnotation" aria-label="annotation2">❷</span> and proceed recursively from there. (If implementing a set instead of a bag, you should check whether <span class="SANS_TheSansMonoCd_W5Regular_11">keyToAdd</span> equals <span class="SANS_TheSansMonoCd_W5Regular_11">tree.key</span>, and in that case reject the addition; see question 12.16.) This example uses a different coding style from the one in <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> just for variety.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing Values from a Binary Search Tree</span></h5>&#13;
<p class="TNI1">Now let’s look at how to remove a key from a binary search tree. Consider the tree shown in <a href="chapter12.xhtml#fig12-10">Figure 12-10</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-10" src="../images/Figure12-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-10: A binary search tree before deleting some keys</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you try to remove a key that you can’t find in the tree, you don’t need to do anything. Easy.</p>&#13;
<p class="TX">Another simple case is removing a leaf: just remove its key, which makes it an empty tree. For instance, removing 10 would result in the following situation, where 11 ends up with an empty left subtree, as shown in <a href="chapter12.xhtml#fig12-11">Figure 12-11</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-11" src="../images/Figure12-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-11: Removing a leaf (key 10, in this case) is straightforward.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, things can get complicated. For example, if you want to remove a node that has at most one child, that’s still easy. Just replace it with its child, as in <a href="chapter12.xhtml#fig12-12">Figure 12-12</a>, where the 24 key was removed by making the 23 key the left child of the 56 key.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-12" src="../images/Figure12-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-12: Removing a key (in this case, 24) with only one child is also straightforward.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A complex problem is dealing with a node that has two nonempty children. The most common solution is to find the key immediately following it, remove it, and put it in place of the node you wanted to remove. For instance, if you want to remove the 9 key in <a href="chapter12.xhtml#fig12-12">Figure 12-12</a>, since that node has two subtrees, you would search for the next higher key (in this particular example, 10), remove it, and put it into the 9 key’s place, as shown in <a href="chapter12.xhtml#fig12-13">Figure 12-13</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-13" src="../images/Figure12-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-13: Removing a key (here, 9) is the hardest case; you have to put another key in its place to maintain the binary search tree structure.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This method of replacing the removed key doesn’t break the search rules. There’s a missing step, though—namely, how to find the next higher key. We’ll get to that in the next section, but first here’s the code to remove a key:</p>&#13;
<pre id="pre-222"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   // nothing to do&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (keyToRemove &lt; tree.key) {&#13;
   tree.left = remove(tree.left, keyToRemove);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (keyToRemove &gt; tree.key) {&#13;
   tree.right = remove(tree.right, keyToRemove);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
   tree = null;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else if (isEmpty(tree.left)) {&#13;
   tree = tree.right;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>} else if (isEmpty(tree.right)) {&#13;
   tree = tree.left;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span>} else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> tree.key = minKey(tree.right);&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> tree.right = remove(tree.right, tree.key);&#13;
 }&#13;
&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">The first three conditions <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> match the <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> method: check for an empty tree; if you haven’t found the key to delete, proceed to a subtree recursively. The next case <span class="CodeAnnotation" aria-label="annotation4">❹</span> deals with removing a leaf: set the tree to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>. The next two conditions <span class="CodeAnnotation" aria-label="annotation5">❺</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span> deal with nodes that have a single child; set the tree to that child. Finally, in the last case <span class="CodeAnnotation" aria-label="annotation7">❼</span> you must find the key <span class="CodeAnnotation" aria-label="annotation8">❽</span> that follows the one you want to delete and use it to replace that key and then finish by recursively deleting that key from the right subtree <span class="CodeAnnotation" aria-label="annotation9">❾</span>. You can complete the algorithm by considering how to find the next higher key.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This is not the only way to do a deletion; we’ll see more in the sections “Removing a Key from a Randomized Tree” on <a href="chapter12.xhtml#pg_267">page 267</a> and “Removing a Key from a Treap” on <a href="chapter14.xhtml#pg_336">page 336</a>.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Finding the Minimum or Maximum Value in a Binary Search Tree</span></h5>&#13;
<p class="TNI1">Because of the relationship between the root and its subtrees, the needed key (the following key) must be the minimum value of the right subtree. (Conversely, the previous key would be the maximum value of the left subtree.) <a href="chapter12.xhtml#fig12-14">Figure 12-14</a> shows how to look for the key following the 9 key. You need to go to its right subtree and then go left until you can’t move in that direction any longer to find the 10 key.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-14" src="../images/Figure12-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-14: Finding the following key; here, you want the minimum key greater than 9.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For a different example, if you wanted to find the <i>previous</i> key to 23, you would go to its <i>left</i> subtree and then move <i>right</i> until reaching the end to find the 22 key. Keep in mind that this logic works only for nodes that have the necessary subtrees. If you want to find the next key of, say, 11, 12, or 22, the logic would fail. Fortunately, this doesn’t apply to cases in which you want to find the next higher key.</p>&#13;
<p class="TX">You can take advantage of similar logic to implement both <span class="SANS_TheSansMonoCd_W5Regular_11">minKey()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">maxKey()</span>:</p>&#13;
<pre id="pre-223"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _minMax = (tree, side, defaultValue) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(tree)) {&#13;
   return defaultValue;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (isEmpty(tree[side])) {&#13;
   return tree.key;&#13;
 } else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return _minMax(tree[side], side, defaultValue);&#13;
 }&#13;
};&#13;
&#13;
const minKey = (tree) =&gt; _minMax(tree, "left", Infinity);&#13;
const maxKey = (tree) =&gt; _minMax(tree, "right", -Infinity);</code></pre>&#13;
<p class="TX">First look at <span class="SANS_TheSansMonoCd_W5Regular_11">minKey()</span>, which is what you wanted in this case; <span class="SANS_TheSansMonoCd_W5Regular_11">maxKey()</span> is analogous. You have an auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_minMax()</span> method that does the actual searching <span class="CodeAnnotation" aria-label="annotation1">❶</span> based on whatever arguments <span class="SANS_TheSansMonoCd_W5Regular_11">minKey()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">maxKey()</span> pass to it. Looking for the minimum requires always going to the left, so that takes care of the second parameter of <span class="SANS_TheSansMonoCd_W5Regular_11">_minMax()</span>, which will go down that side <span class="CodeAnnotation" aria-label="annotation4">❹</span> until an empty tree is found <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Now, if you try to find the minimum of an empty tree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, what value should be returned? You’ll do the same thing the <span class="SANS_TheSansMonoCd_W5Regular_11">Math.min()</span> function does; if you call it without any arguments, it returns <span class="SANS_TheSansMonoCd_W5Regular_11">Infinity</span> (similarly <span class="SANS_TheSansMonoCd_W5Regular_11">Math.max()</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span>), so that’s the third parameter of <span class="SANS_TheSansMonoCd_W5Regular_11">_minMax()</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you analyze the removal algorithm, you may decide that it does more work than needed because it travels down the right subtree once to find the next key and then processes the same subtree again to remove the found key. Why not do both things at once? See question 12.17 for this optimization.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/>&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Traversing a Binary Search Tree</span></h5>&#13;
<p class="TNI1">Many processes involve accessing all nodes of a tree (also called <i>traversing</i> a tree or doing a <i>tree traversal</i>) to do something with each—for example, you could have stored words in a binary search tree and want to produce an alphabetically ordered listing of them. This is called <i>visiting</i> the nodes. If you don’t want to exclude any nodes, three possible scenarios exist for such a general visitation (the pre-, in-, and post- prefixes in these traversal methods are related to when the root is visited):</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Preorder </b>Visit the root of a tree, then traverse its left subtree, and finally traverse its right subtree.</p>&#13;
<p class="RunInPara"><b>Inorder </b>Traverse the left subtree first, then visit the root, and finally traverse the right subtree.</p>&#13;
<p class="RunInPara"><b>Postorder </b>Traverse the left subtree first, then traverse the right subtree, and finish by visiting the root.</p>&#13;
</div>&#13;
<p class="TX">Of course, you traverse an empty tree by doing nothing at all, as visiting applies only to existing keys. Also, note that traversal of subtrees is done by recursively applying the same traversal algorithm.</p>&#13;
<p class="TX">Here’s a basic algorithm where the default <span class="SANS_TheSansMonoCd_W5Regular_11">visit()</span> method just prints the visited key:</p>&#13;
<pre id="pre-224"><code>const preOrder = (tree, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
    visit(tree.key);&#13;
    preOrder(tree.left, visit);&#13;
    preOrder(tree.right, visit);&#13;
  }&#13;
};&#13;
&#13;
const inOrder = (tree, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
    inOrder(tree.left, visit);&#13;
    visit(tree.key);&#13;
    inOrder(tree.right, visit);&#13;
  }&#13;
};&#13;
&#13;
const postOrder = (tree, visit = (x) =&gt; console.log(x)) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
    postOrder(tree.left, visit);&#13;
    postOrder(tree.right, visit);&#13;
    visit(tree.key);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The code follows the description: for example, <span class="SANS_TheSansMonoCd_W5Regular_11">preOrder()</span> first visits the root, then traverses the left subtree, and it finally traverses the right subtree.</p>&#13;
<p class="TX">For debugging purposes, it’s useful to be able to print the list of the tree’s keys in ascending order. If you have a tree and call <span class="SANS_TheSansMonoCd_W5Regular_11">inOrder()</span>, all keys <span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>are listed in order. It starts at the root and processes all the keys less than the root (listing them in order). Next, it prints the root, and then it processes all the keys greater than the root (also listing them in order), providing the desired result.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This algorithm is similar to quicksort from <a href="chapter6.xhtml">Chapter 6</a>. You have a left set of keys, which you order. Then you have the pivot, and then you have a right set of keys, which you also order, and the result is the complete ordered array.</i></p>&#13;
<p class="TX">Getting a list of keys is fine, but seeing the structure is better, so you want to get a printout of it. Consider the tree in <a href="chapter12.xhtml#fig12-15">Figure 12-15</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-15" src="../images/Figure12-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-15: A binary search tree for which we want to print out its structure</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You could use <span class="SANS_TheSansMonoCd_W5Regular_11">console.log()</span> for the printout, but that’s not too user friendly; <span class="SANS_TheSansMonoCd_W5Regular_11">console.dir()</span>is a tad better. You could try something like <span class="SANS_TheSansMonoCd_W5Regular_11">console.log(JSON.stringify(tree))</span>, but that’s really hard to read; you get some very unfriendly output:</p>&#13;
<pre id="pre-225"><code>{"key":22, "left":{"key":9,  "left":{"key":4, "left":null, "right":null}, "rig&#13;
ht":{"key":11, "left":{"key":10, "left":null,"right":null}, "right":{"key":12,&#13;
 "left":null, "right":null}}}, "right":{"key":60, "left":{"key":24, "left":{"k&#13;
ey":23, "left":null, "right":null}, "right":{"key":56, "left":null, "right":nu&#13;
ll}}, "right":null}}</code></pre>&#13;
<p class="TX">To understand the tree’s structure, consider a <span class="SANS_TheSansMonoCd_W5Regular_11">print()</span> method based on the preorder code. It prints the root first, on one line, followed by its left subtree (with an <span class="SANS_TheSansMonoCd_W5Regular_11">L:</span> preceding it to signify the left subtree), and then the right subtree (with an <span class="SANS_TheSansMonoCd_W5Regular_11">R:</span>), indenting children to the right, and children’s children even more, and so forth.</p>&#13;
<p class="TX">The resulting content was similar to the following output:</p>&#13;
<pre id="pre-226"><code> 22&#13;
  L: 9&#13;
  L:  L: 4&#13;
  L:  R: 11&#13;
  L:  R:  L: 10&#13;
  L:  R:  R: 12&#13;
  R: 60&#13;
  R:  L: 24&#13;
  R:  L:  L: 23&#13;
  R:  L:  R: 56</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>The root (<span class="SANS_TheSansMonoCd_W5Regular_11">22</span>) is at the top, followed by <span class="SANS_TheSansMonoCd_W5Regular_11">L: 9</span> (and further below, <span class="SANS_TheSansMonoCd_W5Regular_11">R: 60</span>), showing both of the root’s children. For each new key, you also see its children, further indented, so it’s clear enough for debugging.</p>&#13;
<p class="TX">The code to produce this output is as follows:</p>&#13;
<pre id="pre-227"><code>const print = (tree, s = "") =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
    console.log(s, tree.key);&#13;
    print(tree.left, `${s}  L:`);&#13;
    print(tree.right, `${s}  R:`);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If you compare the logic with the earlier <span class="SANS_TheSansMonoCd_W5Regular_11">preOrder()</span> method, it’s the exact same idea: do something with the key first, and then process its left and right subtrees in order.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Binary Search Trees</span></h5>&#13;
<p class="TNI1">Now that we’ve looked at binary search tree algorithms in detail, what about their performance? Let’s start with the <i>worst</i> possible case. The most dreadful situation you might get after adding several keys to a tree is some kind of linear structure like the one shown in <a href="chapter12.xhtml#fig12-16">Figure 12-16</a>, which in searching terms basically is equivalent to simple linked lists with <i>O</i>(<i>n</i>) performance.</p>&#13;
<figure class="IMG"><img class="img7" id="fig12-16" src="../images/Figure12-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-16: Some worst-case binary search trees</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Going back to the shapes we’ve looked at earlier, it’s obvious that a tree’s shape impacts an algorithm’s performance. The perfect tree is best, which would be <i>O</i>(log <i>n</i>). With linear-like structures, searches would become <i>O</i>(<i>n</i>), and for large trees, that’s a huge difference.</p>&#13;
<p class="TX">In terms of probability, if you take a set of keys in random order, it can be proved that most of the trees will be relatively short in height, and bad cases will be relatively few. While the worst case would still be <i>O</i>(<i>n</i>), on average, we expect <i>O</i>(log <i>n</i>) performance. <a href="chapter12.xhtml#tab12-2">Table 12-2</a> shows average and worst-case performance for the tree.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-2"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-2:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for</span> <span class="SANS_Futura_Std_Book_11">Binary Search Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">What can you do about that? We’ll look at two options in the following sections that attempt to ensure that the tree never reaches a bad shape and stays as short and balanced as possible.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-59"/><span class="SANS_Futura_Std_Bold_B_11">Assured Balanced Binary Search Trees</span></h3>&#13;
<p class="TNI1">As we saw earlier, a tree can become a linear (or almost linear) structure, and its performance will be quite poor. It’s possible to ensure that a tree is kept in balance, however, guaranteeing optimum performance. Here are two different ways of dealing with this problem:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet"><i>Assured balanced trees</i> become efficient because they follow some explicit structural constraint that never lets trees get out of shape, but they imply extra running time and memory usage, needing more complex algorithms—usually <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span>—to ensure that the constraints still apply after modifying the tree. These trees offer a consistent performance in an absolute (neither amortized nor probabilistic) way.</li>&#13;
<li class="ListBullet"><i>Probabilistically balanced trees</i> (or <i>self-adjusting trees</i>) are efficient only in an amortized sense. They do not follow any explicit structure rule, but they can be in any possible shape, depending on methods like <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> to adjust the structure in such a way that it most likely improves over time.</li>&#13;
</ul>&#13;
<p class="TX">Height-balanced <i>AVL trees</i> do not let trees get out of balance by forcing both subtrees of any node to assuredly have approximately the same height. Weight-balanced trees also offer assured balance, by keeping the weights of both subtrees of any node within a given factor of each other; we’ll consider bounded balance (BB[<span class="symbol"><span xml:lang="el" lang="el">α</span></span>]) trees later.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-97"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">AVL Trees</span></h4>&#13;
<p class="TNI1">AVL trees, invented by Adelson-Velsky and Landis in 1962, are well balanced by following a simple rule: <i>for all nodes, the heights of their left and right subtrees must differ at most by one</i>. This automatically rules out all the badly performing shapes of binary trees.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-17">Figure 12-17</a> shows a correctly balanced tree and an unbalanced one. Which is which?</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>&#13;
<figure class="IMG"><img class="img7" id="fig12-17" src="../images/Figure12-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-17: Two binary trees, but only one is balanced. Which is it?</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The rightmost tree is well balanced, and the leftmost tree is not, because the left child of the root is out of balance: its left subtree has a height of 3, and its right subtree has a height of 1. The balance of a node is the difference in heights between its right subtree and left subtree, so the balances in the correct tree in <a href="chapter12.xhtml#fig12-17">Figure 12-17</a> would be as the one shown in <a href="chapter12.xhtml#fig12-18">Figure 12-18</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-18" src="../images/Figure12-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-18: The balanced binary tree showing the balances for all nodes</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that we’ve looked at the desired shape of AVL trees, you can code them.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Defining an AVL Tree</span></h5>&#13;
<p class="TNI1">We’ll base the AVL trees on binary search trees. Several of the operations will still work—for instance, finding a key in an AVL tree is exactly the same, so we won’t see that code again here. There’s a slight difference though: you need to add a <span class="SANS_TheSansMonoCd_W5Regular_11">_height</span> attribute to each node to help check whether it’s in balance, and you need code to access or calculate that attribute. The basic code starts as follows—note that you are reusing some methods of basic binary search trees:</p>&#13;
<pre id="pre-228"><code>const newAvlTree = () =&gt; null;&#13;
&#13;
const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> height: 1&#13;
});&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/><span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const _getHeight = (tree) =&gt; (isEmpty(tree) ? 0 : tree.height);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const _calcHeight = (tree) =&gt;&#13;
  isEmpty(tree)&#13;
    ? 0&#13;
    : 1 + Math.max(_getHeight(tree.left), _getHeight(tree.right));&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const _calcBalance = (tree) =&gt;&#13;
  isEmpty(tree) ? 0 : _getHeight(tree.right) - _getHeight(tree.left);</code></pre>&#13;
<p class="TX">When constructing a new node, add the new <span class="SANS_TheSansMonoCd_W5Regular_11">_</span><span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and then have a <span class="SANS_TheSansMonoCd_W5Regular_11">_getHeight()</span> method to access it; take care so the height of an empty tree is 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The new <span class="SANS_TheSansMonoCd_W5Regular_11">_calcHeight()</span> method <span class="CodeAnnotation" aria-label="annotation3">❸</span> calculates the height of a node; assume both subtrees already have their own heights calculated, and the height of the total tree is one more than the height of its tallest subtree. Finally, calculate the balance of a node <span class="CodeAnnotation" aria-label="annotation4">❹</span> as the difference between the height of its right and left subtrees. That balance can be only –1, 0, or 1; other values imply an unbalanced tree.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Key to an AVL Tree</span></h5>&#13;
<p class="TNI1">To add a new key, the logic is similar to what we already saw, except for a single factor: after deciding where to add the new key, the tree may become out of balance, so you need to move nodes around to restore it. Here’s the additional code:</p>&#13;
<pre id="pre-229"><code>const add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    tree = newNode(keyToAdd);&#13;
  } else {&#13;
    const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
    tree[side] = add(tree[side], keyToAdd);&#13;
  }&#13;
&#13;
<b>  return _fixBalance(tree);</b>&#13;
};</code></pre>&#13;
<p class="TX">This is exactly the same code as for binary search trees, except it adds a final <span class="SANS_TheSansMonoCd_W5Regular_11">_fixBalance()</span> call that takes care of balancing the tree if needed. Before getting to that part, let’s review how to remove keys, which is also quite similar to what you did previously.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Key from an AVL Tree</span></h5>&#13;
<p class="TNI1">After seeing how to add a new key, removing a key will look familiar:</p>&#13;
<pre id="pre-230"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
  } else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
    tree = null;&#13;
  } else if (isEmpty(tree.left)) {&#13;
    tree = tree.right;&#13;
  } else if (isEmpty(tree.right)) {&#13;
    tree = tree.left;&#13;
  } else {&#13;
    tree.key = minKey(tree.right);&#13;
    tree.right = remove(tree.right, tree.key);&#13;
  }&#13;
&#13;
  <b>return _fixBalance(tree);</b>&#13;
};</code></pre>&#13;
<p class="TX">As with adding a key, the only difference with the previous code is at the end where you apply the balance fix.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Rotating Nodes in an AVL Tree</span></h5>&#13;
<p class="TNI1">Adding or removing nodes essentially uses the same logic as for common binary search trees, but without intervention, the trees are likely to fall out of balance. The solution is to apply <i>rotations</i> that won’t affect searching but will restore balance.</p>&#13;
<p class="TX">The two basic tree rotations are symmetrical, as shown in <a href="chapter12.xhtml#fig12-19">Figure 12-19</a>, where the minus sign represents a smaller key value than the plus sign. After any of the rotations, the tree still allows searching, but the height and balance may change, and this allows you to restore an AVL tree.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-19" src="../images/Figure12-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-19: The two symmetrical rotations that can be used to solve balance issues</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Rotating from left to right is a right rotation and from right to left is a left rotation. To remember which rotation is which, notice the direction the old root moves: in a right rotation, the root becomes its own right subtree, and in a left rotation, the root becomes its own left subtree. Another way of looking at it is in a right rotation, the node that was on the left becomes the root (that is, it moved to the right), and the root becomes a subtree, and in a left rotation, the node on the right becomes the root.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you search for more information on tree rotations, you’ll find many inconsistencies, and in some cases, what we call a right rotation, other sources call a left one, so be careful.</i></p>&#13;
<p class="TX">There are two possible cases when rotations are needed: one needs a single rotation, and the other requires two. In the first case (shown in <a href="chapter12.xhtml#fig12-20">Figure 12-20</a>), the tree was balanced, but a new key was added in subtree A, making it taller, which put the whole tree out of balance. (Alternatively, you could have removed a key from subtree C, making it shorter.) In this case, the problem occurs at the left subtree of the left child of the root or, symmetrically, at the right subtree of the right child. These situations are logically called <i>left-left</i> and <i>right-right</i>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig12-20" src="../images/Figure12-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-20: Using a right rotation to fix the unbalanced node with key 60</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The solution is to apply a right rotation to the root of the left subtree (because the imbalance happened at the left subtree), which results in a balanced situation.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#fig12-21">Figure 12-21</a> shows a more complex scenario. A new key was added at the right subtree of the left subtree of the root, throwing the latter out of balance. This <i>left-right</i> case and its mirrored <i>right-left</i> case need two rotations to be fixed.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-21" src="../images/Figure12-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-21: Fixing balance in a harder case needs a left rotation first (at the 9 key node) and then a right rotation (at the 60 key node).</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A first left rotation brings the lowest key (22, in this case) closer to the root, and now a right rotation takes it all the way up, restoring balance. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/><a href="chapter12.xhtml#fig12-21">Figure 12-21</a> shows the scenario where the addition was in B; if it had been in C, the solution still would be the same, and it would also apply if instead of an addition, you had removed a key from D, making it shorter.</p>&#13;
<p class="TX">Now consider the code to rotate a node:</p>&#13;
<pre id="pre-231"><code>const _rotate = (tree, side) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const otherSide = side === "left" ? "right" : "left";&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const auxTree = tree[side];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> tree[side] = auxTree[otherSide];&#13;
  auxTree[otherSide] = tree;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree.height = _calcHeight(tree);&#13;
  auxTree.height = _calcHeight(auxTree);&#13;
  return auxTree;&#13;
};</code></pre>&#13;
<p class="TX">You start by finding the “other” side for the rotation <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and you also get a reference to the node on the side of the root <span class="CodeAnnotation" aria-label="annotation2">❷</span> (the one that will become the root of the tree) to make the code briefer. Then, you exchange some pointers <span class="CodeAnnotation" aria-label="annotation3">❸</span> and finish by recalculating the heights of the two involved nodes; it’s important to do the “lower” node <span class="CodeAnnotation" aria-label="annotation4">❹</span> first.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you call</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">_rotate()</span> <i>with a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">left</span> <i>parameter, it actually does a right rotation, which may be a bit confusing. The idea is you’re saying which node should become root. So for a right rotation, the left child moves up to be the root. In some algorithms, you’ll see that this is more natural.</i></p>&#13;
<p class="TX">Now, let’s finish by providing the missing <span class="SANS_TheSansMonoCd_W5Regular_11">_fixBalance()</span> method:</p>&#13;
<pre id="pre-232"><code>const _fixBalance = (tree) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> tree.height = _calcHeight(tree);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const balance = _calcBalance(tree);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (balance &lt; -1) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (_calcBalance(tree.left) === 1) {&#13;
        tree.left = _rotate(tree.left, "right");&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree = _rotate(tree, "left");&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span>} else if (balance &gt; 1) {&#13;
      if (_calcBalance(tree.right) === -1) {&#13;
        tree.right = _rotate(tree.right, "left");&#13;
      }&#13;
      tree = _rotate(tree, "right");&#13;
    }&#13;
  }&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>If the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, there’s nothing to do. Otherwise, recalculate the root’s height <span class="CodeAnnotation" aria-label="annotation2">❷</span> (since the recent addition or removal may have changed it), and also find the node’s balance <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the node is imbalanced on the left <span class="CodeAnnotation" aria-label="annotation4">❹</span>, check whether an extra rotation is needed <span class="CodeAnnotation" aria-label="annotation5">❺</span> and do it if necessary, ending with a single rotation <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The other <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> is just the symmetrical case <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and it does the same things, but the sides are reversed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for AVL Trees</span></h5>&#13;
<p class="TNI1">Given the assured balance that the structure of AVL trees provides, all the operations (adding, removing, finding) have the same logarithmic performance. There’s no different worst case, as shown in <a href="chapter12.xhtml#tab12-3">Table 12-3</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-3:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for AVL Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">It can be proved that the height of an AVL tree is bounded by 1.44 log <i>n</i>, and that also confirms the performance listed earlier (see question 12.18). In the next chapter, you’ll look at <i>red-black trees</i>, which have similar restrictions and performance but are based on multiway trees. Searches may be a tad slower (because those trees may be taller) and insertions a bit faster (requiring fewer rotations), but overall, the results are the same.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-98"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Weight-Bounded Balanced Trees</span></h4>&#13;
<p class="TNI1">Instead of making sure that the heights of both subtrees of any node are within 1 of each other, <i>weight-bounded balanced (BB[<span xml:lang="el" lang="el">α</span>])</i> trees maintain a different invariant: that the <i>weights</i> (size of the tree plus 1) in the left and right subtrees are in a specific relationship. If a tree has size <i>n</i> and its subtrees have sizes <i>p</i> and <i>q</i>, you then have (<i>p</i> + 1) ≥ <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>(<i>n</i> + 1) and (<i>q</i> + 1) ≥ <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>(<i>n</i> + 1), with 0 &lt; <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> &lt; 0.5.</p>&#13;
<p class="TX">An equivalent way of looking at this is requiring that (<i>p</i> + 1) / (<i>n</i> + 1) ≥ <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> and (<i>q</i> + 1) / (<i>n</i> + 1) ≥ <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>. Since both fractions add up to 1 (see question 12.20), this is the same as saying that both subtrees must satisfy <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> ≤ weight(subtree) / weight(tree) ≤ 1 – <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>. The quotient in the middle is called the <i>balance</i> of the subtree. <a href="chapter12.xhtml#fig12-22">Figure 12-22</a> shows a BB[0.29289] tree where keys from 1 to 12 were inserted in ascending order; the numbers on the edges show the balance of the corresponding subtree.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>&#13;
<figure class="IMG"><img class="img7" id="fig12-22" src="../images/Figure12-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-22: A weight-bounded balanced tree (BB[0.29289] in this case) showing the calculated balance for every node with children</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The value <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> = 0.5 sounds like a perfect balance (for all nodes, the right and left subtrees would be of equal sizes), but it has been proven that it doesn’t really work, and not every value of <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> does. The <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> should be between 0.18182 (= 2/11) and 0.29289 (= 1 – √2/2) for balancing to work.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>When we defined the weight of a node and added 1 to its size, if it weren’t for that additional 1, it would be impossible to have a weight-balanced tree of just two nodes. Can you see why?</i></p>&#13;
<p class="TX">A BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] tree needs to carry the extra data of its size in every node in order to calculate its weight. This is necessary for balancing (so you can check the balance condition given previously), but it’s also useful for other operations, such as finding a key by its rank.</p>&#13;
<p class="TX">When adding to or removing keys from the tree, if balance is not kept, we apply rotations (as in AVL trees) to restore balance. Since BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees are binary search trees, the find operation and traversals work without any changes. You need to consider only additions and removals.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Defining a Weight-Bounded Balanced Tree</span></h5>&#13;
<p class="TNI1">These new trees and AVL trees share a lot of code. The biggest difference is that instead of including the height of a tree in each node, we include a size attribute and fix the balance by considering sizes instead of heights:</p>&#13;
<pre id="pre-233"><code>const {&#13;
  find,&#13;
  inOrder,&#13;
  isEmpty,&#13;
  maxKey,&#13;
  minKey,&#13;
  postOrder,&#13;
  preOrder&#13;
} = require("./binary_search_tree.js");&#13;
const newBBTree = () =&gt; null;&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span><b> size: 1</b>&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const _getSize = (tree) =&gt; (isEmpty(tree) ? 0 : tree.size);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const _calcSize = (tree) =&gt; 1 + _getSize(tree.left) + _getSize(tree.right);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> const _balance = (subtree, tree) =&gt;&#13;
  (1 + _getSize(subtree)) / (1 + _getSize(tree));</code></pre>&#13;
<p class="TX">When creating a new node, set its <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> instead of a <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute. And instead of functions related to getting or calculating heights, you have a function as a getter for the tree’s previously calculated size <span class="CodeAnnotation" aria-label="annotation2">❷</span>, another function to calculate the size of any tree <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and a third one to calculate the balance of a subtree <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which you’ll need for balance fixing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding and Removing Keys to and from a Weight-Bounded Balanced Tree</span></h5>&#13;
<p class="TNI1">I mentioned there would be a surprise, and it’s that adding or removing keys is done in exactly the same way as for AVL trees. Look at the code from the previous section. When adding a new key, you did it in the standard way (that is, the same way as for binary search trees), and you finished by calling a function to fix the balance, if needed. The only difference here is that the latter function will be implemented in another way:</p>&#13;
<pre id="pre-234"><code>const add = (tree, keyToAdd) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    tree = newNode(keyToAdd);&#13;
  } else {&#13;
    const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
    tree[side] = add(tree[side], keyToAdd);&#13;
  }&#13;
&#13;
  <b>return _fixBalance(tree);</b>&#13;
};</code></pre>&#13;
<p class="TX">Deleting a key worked the same way. You first applied the standard binary search tree algorithm and, at the end, called the same function as with additions to restore balance whenever required.</p>&#13;
<p class="TX">You’ll see the exact same process here; the only difference is how you restore balance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Fixing Balance in a Weight-Bounded Balanced Tree</span></h5>&#13;
<p class="TNI1">The original paper that described BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees shows (with math that’s not included here) that there are two possible cases (plus their symmetrical ones) and that simple or double rotations are enough to restore balance. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>Now consider cases where a node has an overweight left subtree; the symmetrical cases are handled the same way.</p>&#13;
<p class="TX">First, a review of some conditions. The balance of a subtree should be <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> ≤ balance(subtree) ≤ 1 – <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>. Several constants will be used when balancing, but we won’t derive the values here:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet"><span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> is the underweight limit; if a subtree’s balance is below <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>, the tree is out of balance.</li>&#13;
<li class="ListBullet"><span class="greek_alt"><span xml:lang="el" lang="el">β</span></span> = 1 – <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> is the overweight limit; if a subtree’s balance is above <span class="greek_alt"><span xml:lang="el" lang="el">β</span></span>, there’s also an imbalance.</li>&#13;
<li class="ListBullet"><span class="greek_alt"><span xml:lang="el" lang="el">γ</span></span> = <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>/<span class="greek_alt"><span xml:lang="el" lang="el">β</span></span> = <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span> / (1 – <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>) is the underweight limit for a subtree’s child.</li>&#13;
<li class="ListBullet"><span class="greek_alt"><span xml:lang="el" lang="el">δ</span></span> = 1 – <span class="greek_alt"><span xml:lang="el" lang="el">γ</span></span> = (1 – 2<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>) / (1– <span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>) is the overweight limit for a subtree’s child.</li>&#13;
</ul>&#13;
<p class="TX">The following code defines the values (the comments show the approximate value of each constant):</p>&#13;
<pre id="pre-235"><code>const ALPHA = 0.29289;&#13;
const BETA = 1 – ALPHA;     // 0.70711&#13;
const GAMMA = ALPHA / BETA; // 0.41421&#13;
const DELTA = 1 – GAMMA;    // 0.58579</code></pre>&#13;
<p class="TX">Now, you will fix unbalanced trees. The first situation is shown in <a href="chapter12.xhtml#fig12-23">Figure 12-23</a>. The left subtree has grown too much (or the right subtree has decreased in size), so the tree is not in balance. You can calculate the balance of the right subtree of the left subtree (B) and find it is below <span class="greek_alt"><span xml:lang="el" lang="el">δ</span></span>, so it’s not overweight. In this case, a single rotation to the right (shoving the B subtree to the right, which must have been underweight) rebalances the tree.</p>&#13;
<figure class="IMG"><img class="img7" id="fig12-23" src="../images/Figure12-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-23: A single rotation fixes balance issues in some cases.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The second situation is a bit more complex. The left subtree is overweight, and the balance of its left subtree’s right subtree exceeds the <span class="greek_alt"><span xml:lang="el" lang="el">δ</span></span> value. A single rotation wouldn’t be enough to restore balance (the tree would still be out of balance), and in this case, a double rotation is needed to bring everything back to normal. Note that part of the overweight subtree is sent to the right (C), and the other part (B) remains on the left, as shown in <a href="chapter12.xhtml#fig12-24">Figure 12-24</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>&#13;
<figure class="IMG"><img class="img7" id="fig12-24" src="../images/Figure12-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-24: Two rotations are needed to fix balance in more complex situations.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">So, the logic for deciding whether rotations are needed (and which) is this: first check both children to see if either is overweight (say it’s the left one) by comparing its balance to <span class="greek_alt"><span xml:lang="el" lang="el">β</span></span>. Then check whether the other side’s grandchild (the right child of the left child) is overweight, but compare its balance to a different limit of <span class="greek_alt"><span xml:lang="el" lang="el">δ</span></span>. Depending on the result of the second check, you’ll do one or two rotations:</p>&#13;
<pre id="pre-236"><code>const _fixBalance = (tree) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> tree.size = _calcSize(tree);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (_balance(tree.left, tree) &gt; BETA) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (_balance(tree.left.right, tree.left) &gt; DELTA) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree.left = _rotate(tree.left, "right");&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> tree = _rotate(tree, "left");&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>} else if (_balance(tree.right, tree) &gt; BETA) {&#13;
      if (_balance(tree.right.left, tree.right) &gt; DELTA) {&#13;
        tree.right = _rotate(tree.right, "left");&#13;
      }&#13;
      tree = _rotate(tree, "right");&#13;
    }&#13;
  }&#13;
&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">If the tree isn’t empty, start by updating its size <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, first check whether the left child is overweight <span class="CodeAnnotation" aria-label="annotation2">❷</span>; if so, do a second check for the right child of the left child <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and if that tree is also overweight, do the first of two rotations <span class="CodeAnnotation" aria-label="annotation4">❹</span>; then do the rotation to the right <span class="CodeAnnotation" aria-label="annotation5">❺</span> that will finish the job. If the left child wasn’t overweight, check the right child <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and the logic is symmetric to the cases noted earlier <span class="CodeAnnotation" aria-label="annotation4">❹</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">You now know how to update the tree by adding or removing keys, but BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees allow other operations as well, including finding by rank, splitting a tree in two, or joining two trees into one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>&#13;
<h5 class="H3" id="sec22"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Finding an Element by Rank in a Weight-Bounded Balanced Tree</span></h5>&#13;
<p class="TNI1">As mentioned previously, having the size of each tree at its root, which is needed by BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees for balancing purposes, provides an extra benefit, because it allows further operations with good performance. Consider one here: finding an element (in this case, the seventh) by rank, as you saw in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. The tree in <a href="chapter12.xhtml#fig12-25">Figure 12-25</a> is the same as <a href="chapter12.xhtml#fig12-22">Figure 12-22</a>, but now the subtrees’ sizes are shown next to each node.</p>&#13;
<figure class="IMG"><img class="img7" id="fig12-25" src="../images/Figure12-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-25: Including the size of each subtree at its root allows you to find an element by rank in an efficient way; here you’re looking for the seventh key.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The left subtree has three elements, so if you were looking for the fourth element, that would be the root itself, and you’d be done! In this case, however, you are looking for the seventh element, so you need to keep searching. First, decide whether to go left or right: the left subtree has only three elements, so the seventh element must be the third element in the right subtree. You need to discount the three elements of the left subtree and also the root, so that removes four from the count, and you move right.</p>&#13;
<p class="TX">Now you are at the 8 key root, which has size 8. Its left subtree has three elements, and as you are looking for the third element of that tree, you keep going down to the left. At the 6 key root, repeat the procedure, and this time go right, as you need to discount one element from the left subtree and one from the root, so now you want the first element of the right subtree. Then you arrive at the 7 key, which is what you wanted.</p>&#13;
<p class="TX">You can easily implement this search with recursion:</p>&#13;
<pre id="pre-237"><code>const findByRank = (tree, rank) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree) || rank &lt; 1 || rank &gt; _getSize(tree)) {&#13;
   return undefined;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (rank &lt;= _getSize(tree.left)) {&#13;
     return findByRank(tree.left, rank);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (rank === _getSize(tree.left) + 1) {&#13;
     return tree.key;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>     return findByRank(tree.right, rank - _getSize(tree.left) - 1);&#13;
   }&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">First, dismiss all the cases in which the search will fail <span class="CodeAnnotation" aria-label="annotation1">❶</span>: an empty tree or asking for a rank outside the size of the tree. If the rank you want isn’t greater than the size of the left subtree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, continue the search there. Otherwise, if the rank you want is exactly one more than the left subtree’s size <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the root is the answer, and you are done. Finally, if none of the preceding conditions hold, go right, and you have to discount the left subtree’s size and the root to continue the search <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Weight-Balanced Binary Trees</span></h5>&#13;
<p class="TNI1">As in the case of AVL trees, ensuring balance in BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees makes for constant performance, with no worst cases. For all operations (adding, removing, and finding), the total cost is logarithmic, so weight-balanced binary trees ensure good performance, as shown in <a href="chapter12.xhtml#tab12-4">Table 12-4</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-4:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Weight-Balanced</span> <span class="SANS_Futura_Std_Book_11">Binary Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find by rank</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Also in comparison with AVL trees, the code isn’t very complex, and in both cases, you just depend on a “balance fix” function to be used after additions or removals.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h1-60"/><span class="SANS_Futura_Std_Bold_B_11">Probabilistic Balance Binary Search Trees</span></h3>&#13;
<p class="TNI1">Assured balance trees make operations more complex to ensure that a well-balanced shape will be kept at all times and thus provide a constant performance for operations. The other approach, <i>probabilistic balanced</i> trees, are simpler in implementation, require no extra memory usage, and can be as efficient (in an amortized sense) as assured balance trees—but you have to cope with the possible disadvantage of some individual slow operations mixed in with a long series of fast ones.</p>&#13;
<p class="TX">So, these trees do not ensure balance, but rather, they promise it in a probabilistic sense, and unless you are really unlucky, they will perform quite well. In this chapter, we’ll consider two versions of these trees: <i>randomized</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/><i>binary search trees</i>, which apply balancing operations in a random manner, and <i>splay trees</i>, which restructure trees to make future searches faster. In <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> we’ll consider one more option: treaps<i>.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-99"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Randomized</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Binary Search Trees</span></h4>&#13;
<p class="TNI1">Balanced trees guarantee performance by enforcing some constraints. This is an advantage in terms of performance, but it adds an extra level of complexity for operations, plus the need for some bookkeeping information at each node to determine whether restructuring is needed. Another way to avoid bad cases is to use randomized algorithms that provide a guarantee of their <i>expected</i> performance in terms of probability for any kind of input data. Depending on the implementation (and also on your particular data), a randomized algorithm may be faster than the corresponding assured balanced version, and it may be better for your needs. For instance, if you add keys in ascending order, balanced trees will have to do frequent balancing operations; if the algorithm works with random-based decisions at some points, fewer balancing operations may be needed; we’ll see this more clearly later.</p>&#13;
<p class="TX">The first such structure we’ll look at uses random numbers to decide whether a new addition should be at the root of the tree or go in its usual place. The insertion and deletion algorithms randomly decide how to either add a key to or remove a key from the tree. Both procedures produce a random structure, as if the input values had been shuffled, as you saw in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. Remember, we won’t need to reconsider how to find a key since we are still dealing with binary search trees and the earlier search logic still applies.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Randomized Binary Search Tree</span></h5>&#13;
<p class="TNI1">Randomized trees will have the same structure as BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] trees, including a <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> attribute, but instead of using it for rebalancing the tree, we’ll use it to help determine randomly what action to take. The basic code is as follows, and again we’ll be reusing some code from standard binary search trees:</p>&#13;
<pre id="pre-238"><code>const newRandomTree = () =&gt; null;&#13;
&#13;
const newNode = (key, <b>left = null, right = null</b>) =&gt; ({&#13;
  key,&#13;
  left,&#13;
  right,&#13;
  size: 1&#13;
});&#13;
&#13;
const _getSize = (tree) =&gt; (isEmpty(tree) ? 0 : tree.size);&#13;
&#13;
const _calcSize = (tree) =&gt; 1 + _getSize(tree.left) + _getSize(tree.right);</code></pre>&#13;
<p class="TX">This is exactly the same way the BB[<span class="greek_alt"><span xml:lang="el" lang="el">α</span></span>] code started, except here the <span class="SANS_TheSansMonoCd_W5Regular_11">newNode()</span> method lets you provide initial values for the <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> pointers, otherwise setting them to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Having a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> <i>attribute means that you’ll also be able to find an element by rank quickly, as in BB[<span xml:lang="el" lang="el">α</span>] trees.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Key to a Randomized Binary Search Tree</span></h5>&#13;
<p class="TNI1">In a standard binary search tree, if you start adding keys to an initially empty tree, the first key you add becomes its root, and it will stay there unless you remove it. This next algorithm acts differently. Each time a key is added, it randomly decides whether it should go at the root or be added as a leaf, wherever that may be, similar to the sampling algorithms described previously. This method ensures that <i>any</i> key can be the root, so the order in which you do additions won’t matter.</p>&#13;
<p class="TX">If the algorithm chooses to place the new key at the root, it splits the tree into two subtrees: one with all keys smaller than the future new root and the other with keys greater than it. Otherwise, if the algorithm didn’t opt for placing the new key as root, a common insertion logic is applied. Take a look at the basic algorithm first; the details will be filled in later:</p>&#13;
<pre id="pre-239"><code>const add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   tree = newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (tree.size * Math.random() &lt; 1) {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const newTrees = _split(tree, keyToAdd);&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> tree = newNode(keyToAdd, newTrees.right, newTrees.left);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
   const side = keyToAdd &lt;= tree.key ? "left" : "right";&#13;
   tree[side] = add(tree[side], keyToAdd);&#13;
 }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree.size = _calcSize(tree);&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">If the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, set the key at the root with empty subtrees and calculate its size before returning. Since you are moving nodes around, you’ll have to recalculate sizes. Just like the sampling algorithm from <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, you may decide that the new value has to go at the root <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In that case, use an auxiliary algorithm to split the tree in two parts <span class="CodeAnnotation" aria-label="annotation3">❸</span>: the key that’s being added becomes the root, and the two split trees become its subtrees <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">As an alternative, if the random test fails, apply the algorithm you know well from binary search trees <span class="CodeAnnotation" aria-label="annotation5">❺</span>. (Remember that to implement a set instead of a bag, you check if <span class="SANS_TheSansMonoCd_W5Regular_11">keyToAdd</span> equals <span class="SANS_TheSansMonoCd_W5Regular_11">tree.key</span> and reject the new key if so.) Note, however, that in each recursive step, you’re also using random numbers to decide whether to split the current tree, so randomness applies not only to the tree’s root but also throughout the structure. The last step of <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> is to calculate the size of the root <span class="CodeAnnotation" aria-label="annotation6">❻</span>, which is done no matter what happens in the earlier steps.</p>&#13;
<p class="TX">Consider a sample case of this algorithm before dealing with the missing splitting code. Suppose you want to add a key of 20 to the tree shown in <a href="chapter12.xhtml#fig12-26">Figure 12-26</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-26" src="../images/Figure12-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-26: A binary search tree before adding a key of 20</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Before comparing 20 to 23, generate a random number. Because the tree’s size is 9, it’s a probability of one in nine that the algorithm will split the tree and set 20 at its root, and in eight out of nine cases, the root will still be 23. Otherwise, you keep working in the usual fashion to add a key in a binary search tree.</p>&#13;
<p class="TX">Suppose the test passes. Split the tree in two parts and set them as subtrees for 20, which becomes the new root, as shown in <a href="chapter12.xhtml#fig12-27">Figure 12-27</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-27" src="../images/Figure12-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-27: If a random test succeeds, the new key becomes the root of the tree.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now, assume the test fails. Leave the original root in place and move to its left to compare 20 to 9. This time, since the size of the current tree is 5, the random test has a one in five probability of success. If the test succeeds this time, 20 goes in place of 9, splitting the tree rooted at 9 and doing the same kind of job as before.</p>&#13;
<p class="TX">A third possibility is if the random test fails the first two times. In that case, compare 20 with 12 and do another random test, now with one in three odds, because the original tree rooted at 12 has three nodes. And if that test fails, you still try again, with one in two odds, before comparing 20 to 22. If and <i>only if</i> every random test fails, you end by placing 20 exactly where you would place it in a normal binary search tree: in this case, to the left of the 22 key.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Splitting the Randomized Binary Search Tree</span></h5>&#13;
<p class="TNI1">The splitting algorithm is reminiscent of the pivoting part of quicksort from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. You have a “pivot” key and want to split the structure into <span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>two trees, so all keys in the first tree are smaller than the pivot and all keys in the second are greater than it.</p>&#13;
<p class="TX">Start with the same tree we used before and see how splitting would work with regard to a 20 key, as shown in <a href="chapter12.xhtml#fig12-28">Figure 12-28</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-28" src="../images/Figure12-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-28: The same tree as shown in <a href="chapter12.xhtml#fig12-26">Figure 12-26</a> before splitting it in two with regard to the 20 value</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First set up two empty trees: one has values less than 20, and the other has values greater than 20. Both start empty. The first step compares 20 with 23. Since 23 is greater, that root and its right subtree go into the tree with greater values. Also, you need to “remember” the left subtree of 23 (now empty), because future values greater than 20 but less than 23 will go there. The two split trees (the one with lesser values, currently empty) would look like the ones shown in <a href="chapter12.xhtml#fig12-29">Figure 12-29</a>, and you’d go on to process the subtree rooted at 9.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-29" src="../images/Figure12-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-29: The first step: 23 is greater than 20, so part of the tree goes to the right. The dotted circles show where new subtrees will be added.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now you have 20, which is greater than 9, so 9 and its left subtree go into the “smaller” tree, and you remember the right subtree of 9, which is where any future values greater than 9 but less than 20 will go. The split trees now look like the ones in <a href="chapter12.xhtml#fig12-30">Figure 12-30</a>, and you can move on to the 12 key.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-30" src="../images/Figure12-30.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-30: The second step: 9 is less than 20, so part of the tree goes to the left.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>This is the same situation: 20 is greater than 12, so connect 12 and its left subtree to the remembered right subtree of the smaller tree, getting the scenario shown in <a href="chapter12.xhtml#fig12-31">Figure 12-31</a>. Now remember the right subtree of 12 as the possible place to add more values.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-31" src="../images/Figure12-31.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-31: The third step: 12 is less than 20, so add to the left tree.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You’re almost finished: 20 is less than 22, so 22 (and its right subtree, if it has one) goes to the remembered place in the “greater” tree, as shown in <a href="chapter12.xhtml#fig12-32">Figure 12-32</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-32" src="../images/Figure12-32.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-32: The fourth step: 22 is greater than 20, so add to the right tree.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Since there are no more nodes to process, finish by setting the final tree’s root to 20, with the “smaller” and “greater” trees as subtrees. The result, shown in <a href="chapter12.xhtml#fig12-33">Figure 12-33</a> is what you saw earlier.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-33" src="../images/Figure12-33.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-33: The fifth step: the tree was split, and now you set 20 at its</span> <span class="SANS_Futura_Std_Book_Oblique_11">root.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now examine the code, which has the tricky issue of how to remember places in split trees:</p>&#13;
<pre id="pre-240"><code>const _split = (&#13;
  tree,&#13;
  keyForSplit,&#13;
  newTrees = {left: null, right: null},&#13;
  lastNodes = {left: newTrees, right: newTrees}&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   return newTrees;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else {&#13;
   const [side, other] =&#13;
      keyForSplit &lt;= tree.key ? ["left", "right"] : ["right", "left"];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const nextTree = tree[side];&#13;
    tree[side] = null;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lastNodes[other][side] = tree;&#13;
    lastNodes[other] = tree;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const newSplit = _split(nextTree, keyForSplit, newTrees, lastNodes);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree.size = _calcSize(tree);&#13;
    return newSplit;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">First create two trees, <span class="SANS_TheSansMonoCd_W5Regular_11">newTrees</span>, as you split the original tree. When you are done with the tree <span class="CodeAnnotation" aria-label="annotation1">❶</span>, just return that pair. Otherwise <span class="CodeAnnotation" aria-label="annotation2">❷</span>, decide which side to split <span class="CodeAnnotation" aria-label="annotation3">❸</span> and join the split part to the correct new tree; you also have to remember where the next joining will be done <span class="CodeAnnotation" aria-label="annotation4">❹</span> before proceeding recursively down the tree <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finish by calculating the tree size <span class="CodeAnnotation" aria-label="annotation6">❻</span>, because you need it for your random tests.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Key from a Randomized Tree</span></h5>&#13;
<p class="TNI1">The algorithm for removing a key is almost the same as before, but with one main difference: what to do if the key to be removed has two children. Here’s the basic code:</p>&#13;
<pre id="pre-241"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> <b>tree.size = _calcSize(tree);</b>&#13;
  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> <b>tree.size = _calcSize(tree);</b>&#13;
  } else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
    tree = null;&#13;
  } else if (isEmpty(tree.left)) {&#13;
    tree = tree.right;&#13;
  } else if (isEmpty(tree.right)) {&#13;
    tree = tree.left;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> <b>tree = _join(tree.left, tree.right);</b>&#13;
  }&#13;
  return tree;&#13;
};</code></pre>&#13;
<p class="TX">The algorithm is pretty standard, and you have seen this code several times now with some small exceptions. When you remove a key from a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>subtree, you need to update the <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> attribute <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, but the interesting difference is when you want to remove a key that has two subtrees, you use a joining procedure <span class="CodeAnnotation" aria-label="annotation3">❸</span> to merge the left and right subtrees into a new tree, which then replaced the removed key. (See question 12.22 for more on the deletion algorithm.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Joining Two Randomized Binary Search Trees</span></h5>&#13;
<p class="TNI1">You can build a new tree out of two separate ones by picking one of the subtrees, using its root as the root for the new subtree, and recursively processing the rest of the trees. Consider the sample case shown in <a href="chapter12.xhtml#fig12-34">Figure 12-34</a> and try to delete the 20 key added earlier.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-34" src="../images/Figure12-34.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-34: Deleting a</span> <span class="SANS_Futura_Std_Book_Oblique_11">root (here, 20) requires joining its subtrees into a single tree.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You need to make a single tree out of both of the root’s left and right subtrees and decide how to do it via random selection, so either 9 or 23 will become the new root. Suppose the random choice picks 9. Set 9 as the root of the new tree, along with its left subtree, and at its right subtree, set the result of joining its right subtree with the other subtree, the one rooted at 23.</p>&#13;
<p class="TX">Now, you have to choose among 12 and 23; suppose you select the latter. You can add 23 and its right subtree to the tree you are building, and then you still have to finish joining the subtrees rooted at 12 and 22. If you randomly pick 12 to be the next root, you’ll get the situation shown in <a href="chapter12.xhtml#fig12-35">Figure 12-35</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-35" src="../images/Figure12-35.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-35: The new tree after randomly selecting 9 for its root and 23 for its right subtree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>As the last step, you need to join an empty subtree (12’s right subtree) and 22’s, so the final tree becomes the one shown in <a href="chapter12.xhtml#fig12-36">Figure 12-36</a> where you’ve removed the 20 key using the new style of algorithm.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-36" src="../images/Figure12-36.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-36: The last step, after joining 12’s right empty subtree and 22’s subtree</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Consider the code. To decide from which tree to pick the root, use the same rule when you considered considered sampling: if the subtrees were of sizes 6 and 4 you’d pick the first tree’s root with a 6/10 probability and the second tree’s root with a 4/10 probability. Here’s the algorithm:</p>&#13;
<pre id="pre-242"><code>const _join = (leftTree, rightTree) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const leftSize = _getSize(leftTree);&#13;
  const rightSize = _getSize(rightTree);&#13;
  const totalSize = leftSize + rightSize;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (totalSize === 0) {&#13;
   return null;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (totalSize * Math.random() &lt; leftSize) {&#13;
   leftTree.right = _join(leftTree.right, rightTree);&#13;
   leftTree.size = _calcSize(leftTree);&#13;
   return leftTree;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
   rightTree.left = _join(leftTree, rightTree.left);&#13;
   rightTree.size = _calcSize(rightTree);&#13;
   return rightTree;&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">First, get the sizes <span class="CodeAnnotation" aria-label="annotation1">❶</span> of the trees to join to make the random choice later. If both trees are empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you’re done. If not, randomly decide (based on the trees’ own sizes) which one will provide the root <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it’s the left one, take its root and its left subtree with no changes and replace its right subtree, with the result of joining it with the other subtree you were working with. Of course, if you picked the right subtree <span class="CodeAnnotation" aria-label="annotation4">❹</span>, the logic would be the same, but mirrored.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3" id="sec31"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Randomized Binary Search Trees</span></h5>&#13;
<p class="TNI1">The effects of the randomized addition procedure make the average performance logarithmic. Even if the structure can become out of shape at <span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>times, continued operations bring it back to a good shape. The worst cases still are linear in time. There is, after all, a possibility that all random numbers may “work against you” to produce a badly shaped tree, but on average, that doesn’t happen; check <a href="chapter12.xhtml#tab12-5">Table 12-5</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-5:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Randomized</span> <span class="SANS_Futura_Std_Book_11">Binary Search Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This structure provides logarithmic performance with high probability: the shape of the search tree will be that of a tree created with a random sequence of keys. Now consider a different structure that will provide amortized logarithmic performance, so a series of operations will have a total time that is logarithmic on average.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-100"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Splay Trees</span></h4>&#13;
<p class="TNI1">As mentioned previously, binary search trees can have <i>O</i>(<i>n</i>) performance, and although this happens only occasionally, it can be a problem. The balanced trees from the previous sections take preventive actions to avoid that issue, but <i>splay trees</i> provide another solution. This version of binary search trees guarantees amortized <i>O</i>(log <i>n</i>) performance, meaning that a sequence of <i>k</i> successive operations will have <i>O</i>(<i>k</i> log <i>n</i>) performance, which isn’t as good as guaranteed <i>O</i>(log <i>n</i>), but it’s almost as good.</p>&#13;
<p class="TX">With splay trees, whenever a node is accessed, it’s moved to the root by a process called <i>splaying</i>, which is a sequence of rotations that brings up the desired node. This doesn’t guarantee a well-balanced tree by any means, but over time, splay trees tend to become reasonably well shaped and provide a good alternative to other binary search tree implementations.</p>&#13;
<p class="TX">Consider the situation in <a href="chapter12.xhtml#fig12-37">Figure 12-37</a> where the 12 key is sought.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-37" src="../images/Figure12-37.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-37: In a splay tree, after a search (here, for key 12), the found node becomes the tree’s new root.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>After finding 12, that key is brought up to the root (you’ll see how later), which also causes other paths to change: 23 is pushed down the root’s right subtree, 10 moves closer to the root, and 22 moves from left to right. Even if it’s possible for the tree to become badly shaped, the sequence of operations usually restructures it for better performance over time. If you frequently require access to a few sets of keys, searches will be quite fast, because those keys will be nearer to the root, which is an advantage for many use cases. An example of this is provided by compilers and their symbol tables: usually when a symbol is defined (say, in a function), there’s a good probability you’ll be accessing it several times in a short period.</p>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h5 class="H3" id="sec33"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Splaying a Tree</span></h5>&#13;
<p class="TNI1">Splay trees have specific rules, with quaint names like <i>zig-zig</i> or <i>zag</i>, and they are based on simple rotations. Consider the different cases. In <a href="chapter12.xhtml#fig12-38">Figures 12-38</a> through <a href="chapter12.xhtml#fig12-40">12-40</a>, the key to be moved up is always 1 (highlighted).</p>&#13;
<p class="ListHead"><b>Case 1: Left Child of the Root</b></p>&#13;
<p class="ListPlainFirst">If the key is the left child of the root, apply a single right rotation to bring the key to the root. This is called a <i>zig</i> case, as shown in <a href="chapter12.xhtml#fig12-38">Figure 12-38</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-38" src="../images/Figure12-38.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-38: A single right rotation moves a left subtree up to the</span> <span class="SANS_Futura_Std_Book_Oblique_11">root.</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody1">The opposite case is if the key were the right child of the root; then you’d do a rotation to the left, which is called a <i>zag</i>.</p>&#13;
<p class="ListHead"><b>Case 2: Right Child of the Left Child of the Root</b></p>&#13;
<p class="ListPlainFirst">In this <i>zag-zig</i> case, first rotate the key to the left and then rotate it to the right to bring it up to the root, as shown in <a href="chapter12.xhtml#fig12-39">Figure 12-39</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-39" src="../images/Figure12-39.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-39: Two rotations are needed for the right child of a left child.</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody1">In the opposite case (<i>zig-zag</i>), first apply a rotation to the right and then to the left.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/><b>Case 3: Left Child of the Left Child of the Root</b></p>&#13;
<p class="ListPlainFirst">This <i>zig-zig</i> case might trip you up, because the order of rotations is altered: first you rotate the <i>parent</i> of the bottom key to the right and <i>then</i> you rotate the key itself, as shown in <a href="chapter12.xhtml#fig12-40">Figure 12-40</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-40" src="../images/Figure12-40.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-40: Two right rotations are needed for the left child of a left child.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You might think an easier algorithm in this case could rotate the key twice, but the result isn’t optimal, and a simple example may convince you of this. Assume you started with a (not very good) tree, as shown in <a href="chapter12.xhtml#fig12-41">Figure 12-41</a>, and splayed up the 1 key.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-41" src="../images/Figure12-41.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-41: Why always rotating the found key isn’t very good</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You could attempt to use rotations to the right to move the 1 up. At each step, the 1 moves up one place, relocating the original root to its right (first 2; then 3 and 2; then 4, 3, and 2; and so on), and by the time 1 gets up to the root, all the other keys (2–5) are still in the same structure they were before, as shown in <a href="chapter12.xhtml#fig12-42">Figure 12-42</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-42" src="../images/Figure12-42.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-42: After all rotations, the tree’s structure becomes worse.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>In this splaying algorithm, two zig-zig rotations could handle this case. First, 1 becomes a root with 2 and 3 to its right, and then 1 moves to the tree’s top, with 4 and 5 at its right; 2 and 3 are relocated to the left of 4, as shown in <a href="chapter12.xhtml#fig12-43">Figure 12-43</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig12-43" src="../images/Figure12-43.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-43: The rotations suggested in the text produce a better structure.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The zig-zig logic produces a better balanced tree, with several shorter paths from the root to nodes, and that serves as a justification for using more complex logic.</p>&#13;
<p class="TX">Now, consider splaying in terms of actual code:</p>&#13;
<pre id="pre-243"><code>const _splay = (tree, keyToUp) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree) || keyToUp === tree.key) {&#13;
    return tree;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const side = keyToUp &lt; tree.key ? "left" : "right";&#13;
    if (isEmpty(tree[side])) {&#13;
     return tree;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (keyToUp === tree[side].key) {&#13;
     return _rotate(tree, side);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
     if (keyToUp &lt;= tree[side].key === keyToUp &lt;= tree.key) {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> tree[side][side] = _splay(tree[side][side], keyToUp);&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree = _rotate(tree, side);&#13;
     } else {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> const other = side === "left" ? "right" : "left";&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> tree[side][other] = _splay(tree[side][other], keyToUp);&#13;
       if (!isEmpty(tree[side][other])) {&#13;
         tree[side] = _rotate(tree[side], other);&#13;
       }&#13;
     }&#13;
   <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return isEmpty(tree[side]) ? tree : _rotate(tree, side);&#13;
   }&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">Splaying continues until an empty tree is reached or the key you’re looking for is found <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As long as those conditions are not met, continue. Decide on which subtree you should find the key <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and if that subtree is empty, you’re also done. (If the tree doesn’t contain the key you’re looking for, the last key you found is the one that moves up, so <i>some</i> restructuring is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>always done.) If you find the key at the root of the subtree <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you have a zig or a zag, and a single rotation suffices. If not, if the key you are searching for is at the same side of the subtree <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you have a zig-zig or zag-zag. First recursively splay the lowest subtree <span class="CodeAnnotation" aria-label="annotation5">❺</span>, then rotate the root <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and finish the last rotation later <span class="CodeAnnotation" aria-label="annotation9">❾</span>. The other possibility is either a zig-zag or a zag-zig: splay the lowest subtree <span class="CodeAnnotation" aria-label="annotation7">❼</span> and finish with the two other rotations <span class="CodeAnnotation" aria-label="annotation8">❽</span> <span class="CodeAnnotation" aria-label="annotation9">❾</span> described earlier.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3" id="sec34"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Finding a Key in a Splayed Tree</span></h5>&#13;
<p class="TNI1">This algorithm is simple. Apply the splaying algorithm first, then check whether the value that got to the root is what you were looking for:</p>&#13;
<pre id="pre-244"><code>const find = (tree, keyToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (!isEmpty(tree)) {&#13;
    tree = _splay(tree, keyToFind);&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return [tree, !isEmpty(tree) &amp;&amp; tree.key === keyToFind];&#13;
};</code></pre>&#13;
<p class="TX">Unless the tree is empty, splay it. Splaying <span class="CodeAnnotation" aria-label="annotation1">❶</span> is <i>always</i> done, whether or not the key exists, so the new key at the root may or may not be what you were looking for, which explains the final test <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h5 class="H3" id="sec35"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Key to a Splayed Tree</span></h5>&#13;
<p class="TNI1">To add a key, first apply splaying to restructure the tree and then add a new root at the top. The tree in <a href="chapter12.xhtml#fig12-44">Figure 12-44</a>, which is the same tree used earlier when showing how splaying worked, shows how to add an 11 key.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-44" src="../images/Figure12-44.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-44: A splay tree into which you’ll insert an 11 key</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first step is to splay using 11 as the splaying value. This key isn’t present in the tree, so the algorithm ends with 10 at the root, as shown in <a href="chapter12.xhtml#fig12-45">Figure 12-45</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-45" src="../images/Figure12-45.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-45: The first step: the tree is splayed with regard to the 11 value.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now it’s easy to finish: 11 should become the root, with 10 (the current root) at its left and 23 at the right, as shown in <a href="chapter12.xhtml#fig12-46">Figure 12-46</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-46" src="../images/Figure12-46.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-46: The final step: the 11 becomes the new root, with the splayed parts as subtrees.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code is as follows:</p>&#13;
<pre id="pre-245"><code>const add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newTree = newNode(keyToAdd);&#13;
  if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> tree = _splay(tree, keyToAdd);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const [side, other] =&#13;
      keyToAdd &lt;= tree.key ? ["left", "right"] : ["right", "left"];&#13;
    newTree[side] = tree[side];&#13;
    newTree[other] = tree;&#13;
    tree[side] = null;&#13;
  }&#13;
  return newTree;&#13;
};</code></pre>&#13;
<p class="TX">First, create the node that will become the new root <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, splay the tree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so the root becomes the nearest key to the one added. Then link the new root properly <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and the new node will be the tree’s root.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h5 class="H3" id="sec36"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Key from a Splayed Tree</span></h5>&#13;
<p class="TNI1">Removing a key starts by splaying the tree, so the root becomes either the key you wanted to remove or a different one, if the key you wanted to remove wasn’t present in the tree. If the key was found, do the usual steps. If it has zero children or just one child, removal is simple; if it has two children, find the next key in its right subtree and set it at the root, but splay it as well.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>You can see how this works by attempting to remove 12 from the tree shown in <a href="chapter12.xhtml#fig12-47">Figure 12-47</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-47" src="../images/Figure12-47.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-47: A splay tree from which you want to delete the 12 key</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first step, as with adding and searching, is to splay the tree using 12 as the key; you already saw this example, and the result was the updated tree shown in <a href="chapter12.xhtml#fig12-48">Figure 12-48</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-48" src="../images/Figure12-48.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-48: The splay tree after splaying, so the 12 becomes the</span> <span class="SANS_Futura_Std_Book_Oblique_11">root</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Since the 12 was found, you can proceed. In this case, you have two subtrees, so you have to find the key that follows 12 (22) and use that value to splay the root’s subtree, getting the new tree shown in <a href="chapter12.xhtml#fig12-49">Figure 12-49</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig12-49" src="../images/Figure12-49.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-49: The tree after splaying the subtree with 22 at its root</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now you can easily remove 12 by placing 22 in its place, and you have finished the algorithm, as shown in <a href="chapter12.xhtml#fig12-50">Figure 12-50</a>. Note that the 22 key cannot have a left subtree, because there’s no value between 12 and 22.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>&#13;
<figure class="IMG"><img class="img5" id="fig12-50" src="../images/Figure12-50.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-50: The final tree after 22 becomes the root</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First look at the code to splay a tree, bringing its minimum value to the top. Remember from earlier algorithms that we find the minimum key going left until we can’t go any further. The idea here is to apply rotations so the minimum key ends up at the top:</p>&#13;
<pre id="pre-246"><code>const _splayMinimum = (tree) =&gt; {&#13;
  if (isEmpty(tree) || isEmpty(tree.left)) {&#13;
    return tree;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> tree.left.left = _splayMinimum(tree.left.left);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> tree = _rotate(tree, "left");&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return isEmpty(tree.left) ? tree : _rotate(tree, "left");&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The algorithm is basically the same as <span class="SANS_TheSansMonoCd_W5Regular_11">_splay()</span>, except you always assume you’re going left <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Compare the code; it’s the same as earlier, except <span class="SANS_TheSansMonoCd_W5Regular_11">side</span> is replaced with <span class="SANS_TheSansMonoCd_W5Regular_11">left</span>. (There’s another way of deriving the <span class="SANS_TheSansMonoCd_W5Regular_11">_splayMinimum()</span> code; see question 12.25.) With that out of the way, the code for removal is as follows:</p>&#13;
<pre id="pre-247"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (!isEmpty(tree)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> tree = _splay(tree, keyToRemove);&#13;
    if (keyToRemove === tree.key) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
       tree = null;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (isEmpty(tree.left)) {&#13;
       tree = tree.right;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (isEmpty(tree.right)) {&#13;
       tree = tree.left;&#13;
     } else {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> const oldLeft = tree.left;&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> tree = _splayMinimum(tree.right);&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> tree.left = oldLeft;&#13;
     }&#13;
   }&#13;
 }&#13;
 return tree;&#13;
};</code></pre>&#13;
<p class="TX">If the tree isn’t empty, start by splaying it <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then check whether the key you want to remove is now at the root. If so, you can easily deal with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>cases where the new root has fewer than two children <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Otherwise, save the left subtree <span class="CodeAnnotation" aria-label="annotation5">❺</span> and then splay the right subtree, bringing its minimum to the top <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and the minimum takes the place of the key you are deleting. You just have to fix its left subtree <span class="CodeAnnotation" aria-label="annotation7">❼</span> and you’re done.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>See question 12.24 to verify that you understand an important detail of this algorithm: Why are you only overriding the splayed subtree’s left tree in the last steps of the removal process?</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h5 class="H3" id="sec37"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Splay Trees</span></h5>&#13;
<p class="TNI1">Splay trees can, in the worst case, produce a linear tree, so performance would be linear in that case and probably would rule them out in a real-time context when you need absolute guarantees as to processing time. However, the amortized cost of a series of operations is logarithmic, meaning that, on average, a sequence of <i>k</i> operations (additions and removals) would have a total cost <i>O</i>(<i>k</i> log <i>n</i>), which works to a logarithmic amortized performance; <a href="chapter12.xhtml#tab12-6">Table 12-6</a> sums up the results.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab12-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 12-6:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Splay Trees</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Amortized performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Traverse</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">One interesting feature is that the structure not only self-reorganizes, but it also provides better performance, because frequently accessed keys end up close to the root. This makes splay trees appropriate for implementing caches, for example. The fact that nodes need no extra bookkeeping data (such as the tree’s height or size) makes it interesting if lack of memory is a problem, and yet another benefit is that performance is, on average, as efficient as other trees.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h3 class="H1" id="sec38"><span id="h1-61"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">This chapter introduced trees, in particular, binary search trees, which provide a good implementation for the bag and set ADTs, with high-performing <i>add</i>, <i>remove</i>, and <i>find</i> methods. You explored the performance of these trees and saw several variants aimed to ensure good, fast algorithms.</p>&#13;
<p class="TX">In the following chapter we’ll explore more general tree-based structures, and we’ll also consider special search-oriented structures that provide quite efficient searches and updates.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>&#13;
<h3 class="H1" id="sec39"><span id="h1-62"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>12.1  A Matter of Levels</b></p>&#13;
<p class="ListPlainFirst">Can you define the height of a tree in terms of levels?</p>&#13;
<p class="ListHead"><b>12.2  Breaking the Rules</b></p>&#13;
<p class="ListPlainFirst">Filesystem directories are often said to have a treelike structure, but that’s not always true. Can you think of a feature that allows directories to be, say, like circular lists (as seen in <span class="listplain_Xref"><a href="chapter10.xhtml">Chapter 10</a></span>) or even possibly like graphs (as you’ll see in <span class="listplain_Xref"><a href="chapter17.xhtml">Chapter 17</a></span>)? A hint: directory entries can be of many types.</p>&#13;
<p class="ListHead"><b>12.3  What’s in a Name?</b></p>&#13;
<p class="ListPlainFirst">Here are some questions regarding full, perfect, and complete trees: Which term implies another? For example, are full trees also complete? And are complete trees full? What happens with full and perfect trees? What about perfect and complete?</p>&#13;
<p class="ListHead"><b>12.4  A</b> <b>find()</b> <b>One-Liner</b></p>&#13;
<p class="ListPlainFirst">It’s certainly less clear, but can you write the <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> method with a single line of code?</p>&#13;
<p class="ListHead"><b>12.5  Sizing a Tree</b></p>&#13;
<p class="ListPlainFirst">Write a <span class="SANS_TheSansMonoCd_W5Regular_11">calcSize()</span> function that will find the size of a binary tree.</p>&#13;
<p class="ListHead"><b>12.6  Tall as a Tree</b></p>&#13;
<p class="ListPlainFirst">Write a <span class="SANS_TheSansMonoCd_W5Regular_11">calcHeight()</span> function to find the height of a binary tree.</p>&#13;
<p class="ListHead"><b>12.7  Copy a Tree</b></p>&#13;
<p class="ListPlainFirst">Given a binary tree, write an algorithm that will produce a copy of it. (Hint: you may want to consider using a preorder traversal for this.)</p>&#13;
<p class="ListHead"><b>12.8  Do the Math</b></p>&#13;
<p class="ListPlainFirst">This problem can pop up if you are writing a compiler or an interpreter. Suppose you have a binary tree whose nodes can have either a number or a mathematical operator (addition, subtraction, multiplication, and division). Such a tree can be used to represent any mathematical expression; for instance, the tree in <a href="chapter12.xhtml#fig12-51">Figure 12-51</a> stands for <span class="SANS_TheSansMonoCd_W5Regular_11">(2</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ 3) * 6.</span></p>&#13;
<figure class="IMG"><img class="img5" id="fig12-51" src="../images/Figure12-51.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 12-51: Do the math.</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody1">Show that you can evaluate such an expression by properly traversing the tree.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/><b>12.9  Making It Bad</b></p>&#13;
<p class="ListPlainFirst">In what order should you insert keys in a common binary search tree to produce a linear list? And if you have <i>n</i> keys, how many ways can you produce a tree with not one single full node? (Hint: Which values could you pick first to add into the tree? Which values could come next?)</p>&#13;
<p class="ListHead"><b>12.10  Rebuild the Tree</b></p>&#13;
<p class="ListPlainFirst">If you are given the preorder and inorder listings of the keys in a binary search tree with no duplicate keys, you can rebuild it; write an algorithm to do this. Your input will be two arrays of values: the first will have the tree’s keys in preorder, and the second will have them in inorder.</p>&#13;
<p class="ListHead"><b>12.11  More Rebuilding?</b></p>&#13;
<p class="ListPlainFirst">For the previous question, would you have been able to rebuild the tree out of the inorder and postorder listings? What about out of the preorder and postorder listings?</p>&#13;
<p class="ListHead"><b>12.12  Equal Traversals</b></p>&#13;
<p class="ListPlainFirst">For which trees are keys visited in the same order with preorder and inorder traversals? What about for inorder and postorder? Or for preorder and postorder?</p>&#13;
<p class="ListHead"><b>12.13  Sorting by Traversing</b></p>&#13;
<p class="ListPlainFirst">Use the <span class="SANS_TheSansMonoCd_W5Regular_11">inOrder()</span> traversal to, given a binary search tree, produce an ordered array of its keys.</p>&#13;
<p class="ListHead"><b>12.14  Generic Order</b></p>&#13;
<p class="ListPlainFirst">Write an <span class="SANS_TheSansMonoCd_W5Regular_11">anyOrder(tree,order,visit)</span> function that will accept an <span class="SANS_TheSansMonoCd_W5Regular_11">order</span> parameter that can be <span class="SANS_TheSansMonoCd_W5Regular_11">"PRE"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"IN"</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">"POST"</span> and will do the corresponding traversal of <span class="SANS_TheSansMonoCd_W5Regular_11">tree</span>, with the given <span class="SANS_TheSansMonoCd_W5Regular_11">visit()</span> function.</p>&#13;
<p class="ListHead"><b>12.15  No Recursion Traversal</b></p>&#13;
<p class="ListPlainFirst">Implement all traversals without using recursion; use a stack instead.</p>&#13;
<p class="ListHead"><b>12.16  No Duplicates Allowed</b></p>&#13;
<p class="ListPlainFirst">Modify the addition logic for binary search trees to reject attempts to add duplicate keys. After such an attempt, the tree should remain unchanged, and an error should be thrown.</p>&#13;
<p class="ListHead"><b>12.17  Get and Delete</b></p>&#13;
<p class="ListPlainFirst">Write a <span class="SANS_TheSansMonoCd_W5Regular_11">_removeMinFromTree(tree)</span> method that will find the least key in a binary search tree, remove it, and return both the key and the updated tree at the same time. Use this new method to optimize <span class="SANS_TheSansMonoCd_W5Regular_11">_remove()</span> by dropping the need for <span class="SANS_TheSansMonoCd_W5Regular_11">_findNext()</span>.</p>&#13;
<p class="ListHead"><b>12.18  AVL Worst</b></p>&#13;
<p class="ListPlainFirst">What’s the smallest number of nodes that an AVL tree can have related to its height? In other words, if an AVL tree has height 1, 2, 3 ..., what’s the smallest number of nodes it may have?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/><b>12.19  Singles Only</b></p>&#13;
<p class="ListPlainFirst">Consider a child node with no siblings called <i>single child</i>. Can you have more than 50 percent single children in an AVL tree?</p>&#13;
<p class="ListHead"><b>12.20  Why One?</b></p>&#13;
<p class="ListPlainFirst">In weight-balanced trees, why is it that the balances of the left subtree and the right subtree (that is, the fractions <i>weight(left subtree) / weight(tree)</i> and <i>weight(right subtree) / weight(tree)</i>) add up to 1?</p>&#13;
<p class="ListHead"><b>12.21  Easier Randomizing?</b></p>&#13;
<p class="ListPlainFirst">A developer had the following thought:</p>&#13;
<p class="Blockquote">Binary search trees behave badly if keys are added in order, but behave well with a random order. What would happen if instead of adding keys to a tree, I hashed them first? The hashed keys are, to all effects, random, and so an ordered sequence of keys would become a totally disordered one, ensuring good performance. Of course, when looking for a key, I’d really need to look for the hashed key, but that’s no big deal. Problem solved; binary trees with hashed keys will <i>always</i> behave well!</p>&#13;
<p class="ListContinued">Is this reasoning correct?</p>&#13;
<p class="ListHead"><b>12.22  Why Not Decrement?</b></p>&#13;
<p class="ListPlainFirst">In the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> logic for randomized binary trees, why did you use <span class="SANS_TheSansMonoCd_W5Regular_11">_calcSize()</span> instead of decrementing as in the following?</p>&#13;
<pre class="pre" id="pre-248"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
  if (isEmpty(tree)) {&#13;
    // nothing to do&#13;
  } else if (keyToRemove &lt; tree.key) {&#13;
    tree.left = remove(tree.left, keyToRemove);&#13;
    <b>tree.size--;</b>&#13;
  } else if (keyToRemove &gt; tree.key) {&#13;
    tree.right = remove(tree.right, keyToRemove);&#13;
    <b>tree.size--;</b>&#13;
    return tree;&#13;
    ... etc. ...&#13;
};</code></pre>&#13;
<p class="ListHead"><b>12.23  Bad Splay?</b></p>&#13;
<p class="ListPlainFirst">You saw earlier that adding keys in ascending or descending order was a bad case for common binary search trees. What happens with splay trees in those cases? And if after those additions you remove a few keys, what tree shape do you get? Is it any better?</p>&#13;
<p class="ListHead"><b>12.24  What Left Subtree?</b></p>&#13;
<p class="ListPlainFirst">At the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> method for splay trees, after splaying the root’s right subtree, what’s the value of <span class="SANS_TheSansMonoCd_W5Regular_11">this.right.left</span> and why?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/><b>12.25  Code Transformation</b></p>&#13;
<p class="ListPlainFirst">Show that you can transform <span class="SANS_TheSansMonoCd_W5Regular_11">_splay()</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">_splayMinimum()</span> by assuming that <span class="SANS_TheSansMonoCd_W5Regular_11">keyToUp</span> equals <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span>. Why should this work?</p>&#13;
<p class="ListHead"><b>12.26  Full Rebalance</b></p>&#13;
<p class="ListPlainFirst">You’ve seen several strategies for rebalancing trees, but you may also want to rebalance a common binary search tree. Can you come up with a <span class="SANS_TheSansMonoCd_W5Regular_11">restructure(tree)</span> function that will balance a binary search tree into as perfect a shape as possible? You should attempt to split nodes as evenly as possible between left and right subtrees, everywhere in the tree.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>