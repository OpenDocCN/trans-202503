<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_217"/><span class="big"><strong>9</strong></span><br/><strong>WEB AND INTERNET ADMINISTRATION</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">If you’re running a web server or are responsible for a website, whether simple or complex, you likely find yourself performing certain tasks with great frequency, notably identifying broken internal and external site links. Using shell scripts, you can automate many of these tasks, as well as some common client/server tasks such as managing access information on a password-protected website directory.</p>&#13;
<h3 class="h3" id="ch09lev1sec01"><strong>#69 Identifying Broken Internal Links</strong></h3>&#13;
<p class="noindenta">A few of the scripts in <a href="ch07.xhtml#ch07">Chapter 7</a> highlighted the capabilities of the <code>lynx</code> text-only web browser, but there’s even more power hidden within this tremendous software application. One capability that’s particularly useful for a <span epub:type="pagebreak" id="page_218"/>web administrator is the <code>traverse</code> function (enabled using <code>-traversal</code>), which causes <code>lynx</code> to try to step through all links on a site to see if any are broken. This feature can be harnessed in a short script, as <a href="ch09.xhtml#ch9ex1">Listing 9-1</a> details.</p>&#13;
<h4 class="h4" id="ch09lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # checklinks--Traverses all internal URLs on a website, reporting&#13;
   #   any errors in the "traverse.errors" file&#13;
&#13;
   # Remove all the lynx traversal output files upon completion.&#13;
   trap "$(which rm) -f traverse.dat traverse2.dat" 0&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     echo "Usage: checklinks URL" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   baseurl="$(echo $1 | cut -d/ -f3 | sed 's/http:\/\///')"&#13;
&#13;
   lynx<span class="ent">➊</span> -traversal -accept_all_cookies<span class="ent">➋</span> -realm "$1" &gt; /dev/null&#13;
&#13;
   if [ -s "traverse.errors" ] ; then&#13;
     /bin/echo -n $(wc -l &lt; traverse.errors) errors encountered.&#13;
<span class="ent">➌</span>   echo Checked $(grep '^http' traverse.dat | wc -l) pages at ${1}:&#13;
     sed "s|$1||g" &lt; traverse.errors&#13;
     mv traverse.errors ${baseurl}.errors&#13;
     echo "A copy of this output has been saved in ${baseurl}.errors"&#13;
   else&#13;
     /bin/echo -n "No errors encountered. ";&#13;
     echo Checked $(grep '^http' traverse.dat | wc -l) pages at ${1}&#13;
   fi&#13;
&#13;
   if [ -s "reject.dat" ]; then&#13;
     mv reject.dat ${baseurl}.rejects&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch9ex1"/><em>Listing 9-1: The</em> <code><em>checklinks</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch09lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The vast majority of the work in this script is done by <code>lynx</code> <span class="ent">➊</span>; the script just fiddles with the resulting <code>lynx</code> output files to summarize and display the data attractively. The <code>lynx</code> output file <em>reject.dat</em> contains a list of links pointing to external URLs (see <a href="ch09.xhtml#ch09lev1sec02">Script #70</a> on <a href="ch09.xhtml#page_220">page 220</a> for how to exploit this data), <em>traverse.errors</em> contains a list of invalid links (the gist of this script), <em>traverse.dat</em> contains a list of all pages checked, and <em>traverse2.dat</em> is identical to <em>traverse.dat</em> except that it also includes the title of every page visited.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_219"/>The <code>lynx</code> command can take a lot of different arguments, and in this case we need to use <code>-accept_all_cookies</code> <span class="ent">➋</span> so that the program doesn’t stall out asking whether we want to accept or reject a cookie from a page. We also use <code>-realm</code> to ensure that the script only checks pages from that point on the site or “lower” in the tree, not every single link it encounters. Without <code>-realm</code>, it can dig up thousands and thousands of pages as it traverses like a madman. When we ran <code>-traversal</code> on <em><a href="http://www.intuitive.com/wicked/">http://www.intuitive.com/wicked/</a></em> without <code>-realm</code>, it found over 6,500 pages after chugging along for over two hours. With the <code>-realm</code> flag, it identified 146 pages to examine in just a few minutes.</p>&#13;
<h4 class="h4" id="ch09lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, simply specify a URL on the command line. You can traverse and check <em>any</em> website you want, but beware: checking something like Google or Yahoo! will take forever and eat up all of your disk space in the process.</p>&#13;
<h4 class="h4" id="ch09lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Let’s check a tiny website that has no errors (<a href="ch09.xhtml#ch9ex2">Listing 9-2</a>).</p>&#13;
<pre class="programs">$ <span class="codestrong">checklinks http://www.404-error-page.com/</span>&#13;
No errors encountered. Checked 1 pages at http://www.404-error-page.com/</pre>&#13;
<p class="listcap"><a id="ch9ex2"/><em>Listing 9-2: Running</em> <code><em>checklinks</em></code> <em>on a website with no errors</em></p>&#13;
<p class="indent">Sure enough, all is well. How about a slightly larger site? <a href="ch09.xhtml#ch9ex3">Listing 9-3</a> shows what <code>checklinks</code> might print for a site with potentially broken links.</p>&#13;
<pre class="programs">$ <span class="codestrong">checklinks http://www.intuitive.com/library/</span>&#13;
5 errors encountered. Checked 62 pages at http://intuitive.com/library/:&#13;
   index/   in BeingEarnest.shtml&#13;
   Archive/f8     in Archive/ArtofWriting.html&#13;
   Archive/f11    in Archive/ArtofWriting.html&#13;
   Archive/f16    in Archive/ArtofWriting.html&#13;
   Archive/f18    in Archive/ArtofWriting.html&#13;
A copy of this output has been saved in intuitive.com.errors</pre>&#13;
<p class="listcap"><a id="ch9ex3"/><em>Listing 9-3: Running</em> <code><em>checklinks</em></code> <em>on a larger website with broken links</em></p>&#13;
<p class="indent">This means that the file <em>BeingEarnest.shtml</em> contains a link to <em>/index/</em> that cannot be resolved: the file <em>/index/</em> does not exist. There are also four weird link errors in the <em>ArtofWriting.html</em> file.</p>&#13;
<p class="indent">Finally, in <a href="ch09.xhtml#ch9ex4">Listing 9-4</a>, let’s check Dave’s film review blog to see what link errors might be lurking.</p>&#13;
<pre class="programs">$ <span class="codestrong">time checklinks http://www.daveonfilm.com/</span>&#13;
No errors encountered. Checked 982 pages at http://www.daveonfilm.com/&#13;
&#13;
real  50m15.069s&#13;
user  0m42.324s&#13;
sys  0m6.801s</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_220"/><a id="ch9ex4"/><em>Listing 9-4: Running the</em> <code><em>checklinks</em></code> <em>script with the</em> <code><em>time</em></code> <em>utility to understand how long it took</em></p>&#13;
<p class="indent">Notice that adding a call to <code>time</code> before a long command is a smart way to see how long running the script takes. Here you can see that checking all 982 pages on <em><a href="http://www.daveonfilm.com/">http://www.daveonfilm.com/</a></em> took 50 minutes of real time, representing 42 seconds of actual processing time. That’s a lot!</p>&#13;
<h4 class="h4" id="ch09lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">The data file <em>traverse.dat</em> contains a list of all URLs encountered, while <em>reject.dat</em> is a list of all URLs encountered but not checked, typically because they’re external links. We’ll address those in the next script. The actual errors are found in the <em>traverse.errors</em> file at <span class="ent">➌</span> in <a href="ch09.xhtml#ch9ex1">Listing 9-1</a>.</p>&#13;
<p class="indent">To have this script report on image reference errors instead, use <code>grep</code> to dig through the <em>traverse.errors</em> file for <em>.gif</em>, <em>.jpeg</em>, or <em>.png</em> filename suffixes before feeding the result to the <code>sed</code> statement (which just cleans up the output to make it attractive).</p>&#13;
<h3 class="h3" id="ch09lev1sec02"><strong>#70 Reporting Broken External Links</strong></h3>&#13;
<p class="noindenta">This partner script (<a href="ch09.xhtml#ch9ex5">Listing 9-5</a>) to <a href="ch09.xhtml#ch09lev1sec01">Script #69</a> builds on the output of that script to identify all external links from a site or site subdirectory analyzed, testing each to ensure that there are no “404 Not Found” errors. To make things easy, it assumes that the previous script has just been run so it can tap into the <em>*.rejects</em> file for the URL list.</p>&#13;
<h4 class="h4" id="ch09lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # checkexternal--Tests all URLs on a website to build a list of external&#13;
   #   references, then check each one to ascertain which might be dead or&#13;
   #   otherwise broken. The -a flag forces the script to list all matches,&#13;
   #   whether they're accessible or not; by default, only unreachable links&#13;
   #   are shown.&#13;
&#13;
   listall=0; errors=0; checked=0&#13;
&#13;
   if [ "$1" = "-a" ] ; then&#13;
     listall=1; shift&#13;
   fi&#13;
&#13;
   if [ -z "$1" ] ; then&#13;
     echo "Usage: $(basename $0) [-a] URL" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   trap "$(which rm) -f traverse*.errors reject*.dat traverse*.dat" 0&#13;
&#13;
   outfile="$(echo "$1" | cut -d/ -f3).errors.ext"&#13;
   URLlist="$(echo $1 | cut -d/ -f3 | sed 's/www\.//').rejects"&#13;
&#13;
   rm -f $outfile     # Ready for new output&#13;
&#13;
   if [ ! -e "$URLlist" ] ; then&#13;
     echo "File $URLlist not found. Please run checklinks first." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -s "$URLlist" ] ; then&#13;
     echo "There don't appear to be any external links ($URLlist is empty)." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   #### Now, finally, we're ready to begin...&#13;
&#13;
   for URL in $(cat $URLlist | sort | uniq)&#13;
   do&#13;
<span class="ent">➊</span>   curl -s "$URL" &gt; /dev/null 2&gt;&amp;1; return=$?&#13;
     if [ $return -eq 0 ] ; then&#13;
       if [ $listall -eq 1 ] ; then&#13;
         echo "$URL is fine."&#13;
       fi&#13;
     else&#13;
       echo "$URL fails with error code $return"&#13;
       errors=$(( $errors + 1 ))&#13;
     fi&#13;
     checked=$(( $checked + 1 ))&#13;
   done&#13;
&#13;
   echo ""&#13;
   echo "Done. Checked $checked URLs and found $errors errors."&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_221"/><a id="ch9ex5"/><em>Listing 9-5: The</em> <code><em>checkexternal</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch09lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This is not the most elegant script in this book. It’s more of a brute-force method of checking external links. For each external link found, the <code>curl</code> command tests the validity of the link by trying to grab the contents of its URL and then discarding them as soon as they’ve arrived, done in the block of code at <span class="ent">➊</span>.</p>&#13;
<p class="indent">The notation <code>2&gt;&amp;1</code> is worth mentioning here: it causes output device #2 to be redirected to whatever output device #1 is set to. With a shell, output #2 is <code>stderr</code> (for error messages) and output #1 is <code>stdout</code> (regular output). Used alone, <code>2&gt;&amp;1</code> will cause <code>stderr</code> to go to <code>stdout</code>. In this instance, however, notice <span epub:type="pagebreak" id="page_222"/>that prior to this redirection, <code>stdout</code> is already redirected to <em>/dev/null</em>. This is a virtual device that can be fed an infinite amount of data without ever getting any bigger. Think of it as a black hole, and you’ll be on the right track. Therefore, this notation ensures that <code>stderr</code> is also redirected to <em>/dev/null</em>. We’re throwing this information away because all we’re really interested in is whether <code>curl</code> returns a zero or nonzero return code from this command. Zero indicates success; nonzero indicates an error.</p>&#13;
<p class="indent">The number of internal pages traversed is just the line count of the file <em>traverse.dat</em>, and the number of external links can be found by looking at <em>reject.dat</em>. If the <code>-a</code> flag is specified, the output lists all external links, whether they’re reachable or not. Otherwise, only failed URLs are displayed.</p>&#13;
<h4 class="h4" id="ch09lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, simply specify the URL of a site to check as an argument to the script.</p>&#13;
<h4 class="h4" id="ch09lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Let’s check <em><a href="http://intuitive.com/">http://intuitive.com/</a></em> for bad links in <a href="ch09.xhtml#ch9ex6">Listing 9-6</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">checkexternal -a http://intuitive.com/</span>&#13;
http://chemgod.slip.umd.edu/~kidwell/weather.html fails with error code 6&#13;
http://epoch.oreilly.com/shop/cart.asp fails with error code 7&#13;
http://ezone.org:1080/ez/ fails with error code 7&#13;
http://fx.crewtags.com/blog/ fails with error code 6&#13;
http://linc.homeunix.org:8080/reviews/wicked.html fails with error code 6&#13;
http://links.browser.org/ fails with error code 6&#13;
http://nell.boulder.lib.co.us/ fails with error code 6&#13;
http://rpms.arvin.dk/slocate/ fails with error code 6&#13;
http://rss.intuitive.com/ fails with error code 6&#13;
http://techweb.cmp.com/cw/webcommerce fails with error code 6&#13;
http://tenbrooks11.lanminds.com/ fails with error code 6&#13;
http://www.101publicrelations.com/blog/ fails with error code 6&#13;
http://www.badlink/somewhere.html fails with error code 6&#13;
http://www.bloghop.com/ fails with error code 6&#13;
http://www.bloghop.com/ratemyblog.htm fails with error code 6&#13;
http://www.blogphiles.com/webring.shtml fails with error code 56&#13;
http://www.blogstreet.com/blogsqlbin/home.cgi fails with error code 56&#13;
http://www.builder.cnet.com/ fails with error code 6&#13;
http://www.buzz.builder.com/ fails with error code 6&#13;
http://www.chem.emory.edu/html/html.html fails with error code 6&#13;
http://www.cogsci.princeton.edu/~wn/ fails with error code 6&#13;
http://www.ourecopass.org/ fails with error code 6&#13;
http://www.portfolio.intuitive.com/portfolio/ fails with error code 6&#13;
&#13;
Done. Checked 156 URLs and found 23 errors.</pre>&#13;
<p class="listcap"><a id="ch9ex6"/><em>Listing 9-6: Running the</em> <code><em>checkexternal</em></code> <em>script on</em> <a href="http://intuitive.com/">http://intuitive.com/</a></p>&#13;
<p class="indent">Looks like it’s time to do some cleanup!</p>&#13;
<h3 class="h3" id="ch09lev1sec03"><span epub:type="pagebreak" id="page_223"/><strong>#71 Managing Apache Passwords</strong></h3>&#13;
<p class="noindenta">One terrific feature of the Apache web server is that it offers built-in support for password-protected directories, even on a shared public server. It’s a great way to have private, secure, and limited-access information on your website, whether you’re running a paid subscription service or you just want to ensure that family pictures are viewed only by family.</p>&#13;
<p class="indent">Standard configurations require that in the password-protected directory you manage a data file called <em>.htaccess</em>. This file specifies the security “zone” name, and more importantly, it points to a separate data file that contains the account name and password pairs that are used to validate access to the directory. Managing this file is not a problem, except that the only tool included with Apache for doing so is the primitive <code>htpasswd</code> program, which is run on the command line. As another option, this script, <code>apm</code>, one of the most complex and sophisticated scripts in this book, offers a password management tool that runs in your browser as a CGI script and lets you easily add new accounts, change the passwords on existing accounts, and delete accounts from the access list.</p>&#13;
<p class="indent">To get started, you will need a properly formatted <em>.htaccess</em> file to control access to the directory it’s located within. For demonstration purposes, this file might look like this:</p>&#13;
<pre class="programs">$ <span class="codestrong">cat .htaccess</span>&#13;
AuthUserFile /usr/lib/cgi-bin/.htpasswd&#13;
AuthGroupFile /dev/null&#13;
AuthName "Members Only Data Area."&#13;
AuthType Basic&#13;
&#13;
&lt;Limit GET&gt;&#13;
require valid-user&#13;
&lt;/Limit&gt;</pre>&#13;
<p class="indent">A separate file, <em>.htpasswd</em>, contains all the account and password pairs. If this file doesn’t yet exist, you’ll need to create it. A blank one is fine: run <code>touch .htpasswd</code> and ensure that it’s writable by the user ID that runs Apache itself (probably user <code>nobody</code>). Then you’re ready for the script in <a href="ch09.xhtml#ch9ex7">Listing 9-7</a>. This does also require, however, the CGI environment set up in “<a href="ch08.xhtml#ch08lev1sec01">Running the Scripts in This Chapter</a>” on <a href="ch08.xhtml#page_201">page 201</a>. Make sure this shell script is saved to your <em>cgi-bin</em> directory.</p>&#13;
<h4 class="h4" id="ch09lev2sec10"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # apm--Apache Password Manager allows the administrator to easily&#13;
   #   add, update, or delete accounts and passwords for a subdirectory&#13;
   #   of a typical Apache configuration (where the config file is called&#13;
   #   .htaccess).&#13;
<span epub:type="pagebreak" id="page_224"/>   echo "Content-type: text/html"&#13;
   echo ""&#13;
   echo "&lt;html&gt;&lt;title&gt;Apache Password Manager Utility&lt;/title&gt;&lt;body&gt;"&#13;
&#13;
   basedir=$(pwd)&#13;
   myname="$(basename $0)"&#13;
   footer="$basedir/apm-footer.html"&#13;
   htaccess="$basedir/.htaccess"&#13;
&#13;
   htpasswd="$(which htpasswd) -b"&#13;
&#13;
   # It's strongly suggested you include the following code for security purposes:&#13;
   #&#13;
   # if [ "$REMOTE_USER" != "admin" -a -s $htpasswd ] ; then&#13;
   #   echo "Error: You must be user &lt;b&gt;admin&lt;/b&gt; to use APM."&#13;
   #   exit 0&#13;
   # fi&#13;
&#13;
   # Now get the password filename from the .htaccess file.&#13;
&#13;
   if [ ! -r "$htaccess" ] ; then&#13;
     echo "Error: cannot read $htaccess file."&#13;
     exit 1&#13;
   fi&#13;
&#13;
   passwdfile="$(grep "AuthUserFile" $htaccess | cut -d\   -f2)"&#13;
   if [ ! -r $passwdfile ] ; then&#13;
     echo "Error: can't read password file: can't make updates."&#13;
     exit 1&#13;
   elif [ ! -w $passwdfile ] ; then&#13;
     echo "Error: can't write to password file: can't update."&#13;
     exit 1&#13;
   fi&#13;
&#13;
   echo "&lt;center&gt;&lt;h1 style='background:#ccf;border-radius:3px;border:1px solid&#13;
   #99c;padding:3px;'&gt;"&#13;
   echo "Apache Password Manager&lt;/h1&gt;"&#13;
&#13;
   action="$(echo $QUERY_STRING | cut -c3)"&#13;
   user="$(echo $QUERY_STRING|cut -d\&amp; -f2|cut -d= -f2|\&#13;
   tr '[:upper:]' '[:lower:]')"&#13;
&#13;
<span class="ent">➊</span> case "$action" in&#13;
     A ) echo "&lt;h3&gt;Adding New User &lt;u&gt;$user&lt;/u&gt;&lt;/h3&gt;"&#13;
           if [ ! -z "$(grep -E "^${user}:" $passwdfile)" ] ; then&#13;
             echo "Error: user &lt;b&gt;$user&lt;/b&gt; already appears in the file."&#13;
           else&#13;
             pass="$(echo $QUERY_STRING|cut -d\&amp; -f3|cut -d= -f2)"&#13;
<span class="ent">➋</span>           if [ ! -z "$(echo $pass|tr -d '[[:upper:][:lower:][:digit:]]')" ];&#13;
             then&#13;
               echo "Error: passwords can only contain a-z A-Z 0-9 ($pass)"&#13;
<span epub:type="pagebreak" id="page_225"/>             else&#13;
<span class="ent">➌</span>             $htpasswd $passwdfile "$user" "$pass"&#13;
               echo "Added!&lt;br&gt;"&#13;
             fi&#13;
           fi&#13;
           ;;&#13;
     U ) echo "&lt;h3&gt;Updating Password for user &lt;u&gt;$user&lt;/u&gt;&lt;/h3&gt;"&#13;
           if [ -z "$(grep -E "^${user}:" $passwdfile)" ] ; then&#13;
             echo "Error: user &lt;b&gt;$user&lt;/b&gt; isn't in the password file?"&#13;
             echo "searched for &amp;quot;^${user}:&amp;quot; in $passwdfile"&#13;
           else&#13;
             pass="$(echo $QUERY_STRING|cut -d\&amp; -f3|cut -d= -f2)"&#13;
             if [ ! -z "$(echo $pass|tr -d '[[:upper:][:lower:][:digit:]]')" ];&#13;
             then&#13;
               echo "Error: passwords can only contain a-z A-Z 0-9 ($pass)"&#13;
             else&#13;
               grep -vE "^${user}:" $passwdfile | tee $passwdfile &gt; /dev/null&#13;
               $htpasswd $passwdfile "$user" "$pass"&#13;
               echo "Updated!&lt;br&gt;"&#13;
             fi&#13;
           fi&#13;
           ;;&#13;
     D ) echo "&lt;h3&gt;Deleting User &lt;u&gt;$user&lt;/u&gt;&lt;/h3&gt;"&#13;
           if [ -z "$(grep -E "^${user}:" $passwdfile)" ] ; then&#13;
             echo "Error: user &lt;b&gt;$user&lt;/b&gt; isn't in the password file?"&#13;
           elif [ "$user" = "admin" ] ; then&#13;
             echo "Error: you can't delete the 'admin' account."&#13;
           else&#13;
             grep -vE "^${user}:" $passwdfile | tee $passwdfile &gt;/dev/null&#13;
             echo "Deleted!&lt;br&gt;"&#13;
           fi&#13;
           ;;&#13;
   esac&#13;
&#13;
   # Always list the current users in the password file...&#13;
&#13;
   echo "&lt;br&gt;&lt;br&gt;&lt;table border='1' cellspacing='0' width='80%' cellpadding='3'&gt;"&#13;
   echo "&lt;tr bgcolor='#cccccc'&gt;&lt;th colspan='3'&gt;List "&#13;
   echo "of all current users&lt;/td&gt;&lt;/tr&gt;"&#13;
<span class="ent">➍</span> oldIFS=$IFS ; IFS=":"   # Change word split delimiter...&#13;
     while read acct pw ; do&#13;
       echo "&lt;tr&gt;&lt;th&gt;$acct&lt;/th&gt;&lt;td align=center&gt;&lt;a href=\"$myname?a=D&amp;u=$acct\"&gt;"&#13;
       echo "[delete]&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;"&#13;
     done &lt; $passwdfile&#13;
     echo "&lt;/table&gt;"&#13;
     IFS=$oldIFS             # ...and restore it.&#13;
&#13;
     # Build selectstring with all accounts included...&#13;
<span class="ent">➎</span> optionstring="$(cut -d: -f1 $passwdfile | sed 's/^/&lt;option&gt;/'|tr '\n' ' ')"&#13;
&#13;
     if [ ! -r $footer ] ; then&#13;
       echo "Warning: can't read $footer"&#13;
   else&#13;
     # ...and output the footer.&#13;
<span class="ent">➏</span>   sed -e "s/--myname--/$myname/g" -e "s/--options--/$optionstring/g" &lt; $footer&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_226"/><a id="ch9ex7"/><em>Listing 9-7: The</em> <code><em>apm</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch09lev2sec11"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s a lot working together for this script to function. Not only do you need to have your Apache web server configuration (or equivalent) correct, but you need to have the correct entries in the <em>.htaccess</em> file, and you need an <em>.htpasswd</em> file with at least an entry for the <code>admin</code> user.</p>&#13;
<p class="indent">The script itself extracts the <code>htpasswd</code> filename from the <em>.htaccess</em> file and does a variety of tests to sidestep common <code>htpasswd</code> error situations, including if the script is unable to write to the file. All of this occurs before the main block of the script, the <code>case</code> statement.</p>&#13;
<h5 class="h5" id="ch09lev3sec01"><strong>Processing Changes to .htpasswd</strong></h5>&#13;
<p class="noindenta">The <code>case</code> statement <span class="ent">➊</span> decides which of three possible actions is requested— <code>A</code> to add a user, <code>U</code> to update a user record, and <code>D</code> to delete a user—and invokes the correct segment of code accordingly. The action and the user account on which to perform the action are specified in the <code>QUERY_STRING</code> variable. This variable is sent by the web browser to the server in the URL as <code>a=<em>X</em>&amp;u=<em>Y</em></code>, where <code><em>X</em></code> is the action letter code and <code><em>Y</em></code> is the specified username. When a password is being changed or a user is being added, a third argument, <code>p</code>, is needed to specify the password value.</p>&#13;
<p class="indent">For example, let’s say we’re adding a new user <code>joe</code> with the password <code>knife</code>. This action results in the following <code>QUERY_STRING</code> being sent to the script from the web server:</p>&#13;
<pre class="programs">a=A&amp;u=joe&amp;p=knife</pre>&#13;
<p class="indent">The script unwraps this, setting the <code>action</code> variable to the value <code>A</code>, <code>user</code> to <code>joe</code>, and <code>pass</code> to <code>knife</code>. Then it uses the test at <span class="ent">➋</span> to ensure that the password contains only valid alphabetic characters.</p>&#13;
<p class="indent">Finally, if all is well, it invokes the <code>htpasswd</code> program to encrypt the password and add it to the <em>.htpasswd</em> file at <span class="ent">➌</span>. In addition to processing changes to the <em>.htpasswd</em> file, this script also produces an HTML table that lists each user in the <em>.htpasswd</em> file, along with a <code>[delete]</code> link.</p>&#13;
<p class="indent">After producing three lines of HTML output for the heading of the table, the script continues at <span class="ent">➍</span>. This <code>while</code> loop reads the name and password pairs from the <em>.htpasswd</em> file by using the trick of changing the <em>input field separator</em> (<em>IFS</em>) to a colon and changing the IFS back when it’s done.</p>&#13;
<h5 class="h5" id="ch09lev3sec02"><span epub:type="pagebreak" id="page_227"/><strong>Adding a Footer of Actions to Take</strong></h5>&#13;
<p class="noindenta">The script also relies on the presence of an HTML file called <em>apm-footer.html</em> containing occurrences of the strings <code>--myname--</code> and <code>--options--</code> <span class="ent">➏</span>, which are replaced by the current name of the CGI script and the list of users, respectively, as the file is output to <code>stdout</code>.</p>&#13;
<p class="indent">The <code>$myname</code> variable is processed by the CGI engine, which replaces the variable with the actual name of the script. The script itself builds the <code>$optionstring</code> variable from the account name and password pairs in the <em>.htpasswd</em> file at <span class="ent">➎</span>.</p>&#13;
<p class="indent">The HTML footer file in <a href="ch09.xhtml#ch9ex8">Listing 9-8</a> provides the ability to add a user, update a user’s password, and delete a user.</p>&#13;
<pre class="programs">&lt;!-- footer information for APM system. --&gt;&#13;
&#13;
&lt;div style='margin-top: 10px;'&gt;&#13;
&lt;table border='1' cellpadding='2' cellspacing='0' width="80%"&#13;
 style="border:2px solid #666;border-radius:5px;" &gt;&#13;
 &lt;tr&gt;&lt;th colspan='4' bgcolor='#cccccc'&gt;Password Manager Actions&lt;/th&gt;&lt;/tr&gt;&#13;
 &lt;tr&gt;&lt;td&gt;&#13;
  &lt;form method="get" action="--myname--"&gt;&#13;
  &lt;table border='0'&gt;&#13;
    &lt;tr&gt;&lt;td&gt;&lt;input type='hidden' name="a" value="A"&gt;&#13;
     add user:&lt;/td&gt;&lt;td&gt;&lt;input type='text' name='u' size='15'&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#13;
     password: &lt;/td&gt;&lt;td&gt; &lt;input type='text' name='p' size='15'&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="center"&gt;&#13;
     &lt;input type='submit' value='add' style="background-color:#ccf;"&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&#13;
  &lt;/table&gt;&lt;/form&gt;&#13;
&lt;/td&gt;&lt;td&gt;&#13;
  &lt;form method="get" action="--myname--"&gt;&#13;
  &lt;table border='0'&gt;&#13;
    &lt;tr&gt;&lt;td&gt;&lt;input type='hidden' name="a" value="U"&gt;&#13;
      update&lt;/td&gt;&lt;td&gt;&lt;select name='u'&gt;--options--&lt;/select&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#13;
      password: &lt;/td&gt;&lt;td&gt;&lt;input type='text' name='p' size='10'&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="center"&gt;&#13;
      &lt;input type='submit' value='update' style="background-color:#ccf;"&gt;&#13;
    &lt;/td&gt;&lt;/tr&gt;&#13;
  &lt;/table&gt;&lt;/form&gt;&#13;
&lt;/td&gt;&lt;td&gt;&#13;
  &lt;form method="get" action="--myname--"&gt;&lt;input type='hidden'&#13;
    name="a" value="D"&gt;delete &lt;select name='u'&gt; --options-- &lt;/select&gt;&#13;
    &lt;br /&gt;&lt;br /&gt;&lt;center&gt;&#13;
    &lt;input type='submit' value='delete' style="background-color:#ccf;"&gt;&lt;/&#13;
center&gt;&lt;/form&gt;&#13;
&lt;/td&gt;&lt;/tr&gt;&#13;
&lt;/table&gt;&#13;
&lt;/div&gt;&#13;
&#13;
&lt;h5 style='background:#ccf;border-radius:3px;border:1px solid&#13;
#99c;padding:3px;'&gt;&#13;
  From the book &lt;a href="http://www.intuitive.com/wicked/"&gt;Wicked Cool Shell&#13;
Scripts&lt;/a&gt;&#13;
&lt;/h5&gt;&#13;
&#13;
&lt;/body&gt;&lt;/html&gt;</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_228"/><a id="ch9ex8"/><em>Listing 9-8: The</em> apm-footer.html <em>file used to add a section for creating new users</em></p>&#13;
<h4 class="h4" id="ch09lev2sec12"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">You’ll most likely want to save this script in the same directory you want to protect with passwords, although you can also put it in your <em>cgi-bin</em> directory as we have done. Either way, make sure you tweak the <code>htpasswd</code> and directory values at the beginning of the script as appropriate. You’ll also need an <em>.htaccess</em> file that defines access permissions and an <em>.htpasswd</em> file that exists and is writable by the user who runs the Apache web server on your system.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>When you use</em> <code><em>apm</em></code><em>, make sure that the first account you create is</em> <code><em>admin</em></code> <em>so you can use the script upon subsequent invocations! There’s a special test in the code that allows you to create the</em> <code><em>admin</em></code> <em>account if</em> .htpasswd <em>is empty.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch09lev2sec13"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The result of running the <code>apm</code> script is shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>. Notice that it not only lists each account with a delete link but also offers options for adding another account, changing the password of an existing account, deleting an account, or listing all the accounts.</p>&#13;
<div class="image"><img src="../images/f09-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig1"/><em>Figure 9-1: A shell script–based Apache password management system</em></p>&#13;
<h4 class="h4" id="ch09lev2sec14"><span epub:type="pagebreak" id="page_229"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">The Apache <code>htpasswd</code> program offers a nice command line interface for appending the new account and encrypted password information to the account database. But only one of the two commonly distributed versions of <code>htpasswd</code> supports batch use for scripts—that is, feeding the script both an account and password from the command line. It’s easy to tell whether your version does: if <code>htpasswd</code> doesn’t complain when you try to use the <code>-b</code> flag, you’ve got the better, more recent version. Chances are you will be good, though.</p>&#13;
<p class="indent">Be warned that if this script is incorrectly installed, anyone who gains knowledge of the URL can then add themselves to the access file and delete everyone else. That’s not good. One solution is to only allow this script to be run if the user is already signed in as <code>admin</code> (as the commented code in the top of the script mentions). Another way to secure the script is to place it in a directory that itself is password protected.</p>&#13;
<h3 class="h3" id="ch09lev1sec04"><strong>#72 Syncing Files with SFTP</strong></h3>&#13;
<p class="noindenta">Though the <code>ftp</code> program is still available on most systems, it’s being replaced more and more by new file transfer protocols such as <code>rsync</code> and <code>ssh</code> (secure shell). There are a few reasons for this. Since the first edition of this book, FTP has begun to show some weaknesses with scaling and securing data in this new world of “big data,” and more efficient protocols for transferring data have become more mainstream. By default, FTP also transmits data in plaintext, which is generally fine for home or corporate networking on trusted networks, but not if you’re doing an FTP transfer from an open network at, for example, the library or Starbucks, where a lot of people are sharing the same network as you.</p>&#13;
<p class="indent">All modern servers should support the considerably more secure <code>ssh</code> package supporting end-to-end encryption. The file transfer element of the encrypted transfer is <code>sftp</code>, and while it’s even more primitive than <code>ftp</code>, we can still work with it. <a href="ch09.xhtml#ch9ex9">Listing 9-9</a> shows how we can utilize <code>sftp</code> to securely sync our files.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If you don’t have</em> <code><em>ssh</em></code> <em>on your system, complain to your vendor and administrative team. There’s no excuse. If you have access rights, you can also obtain the package at</em> <a href="http://www.openssh.com/">http://www.openssh.com/</a> <em>and install it yourself.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch09lev2sec15"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">  #!/bin/bash&#13;
&#13;
   # sftpsync--Given a target directory on an sftp server, makes sure that&#13;
   #   all new or modified files are uploaded to the remote system. Uses&#13;
   #   a timestamp file ingeniously called .timestamp to keep track.&#13;
&#13;
   timestamp=".timestamp"&#13;
   tempfile="/tmp/sftpsync.$$"&#13;
   count=0&#13;
&#13;
   trap "$(which rm) -f $tempfile" 0 1 15      # Zap tempfile on exit&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $0 user@host { remotedir }" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   user="$(echo $1 | cut -d@ -f1)"&#13;
   server="$(echo $1 | cut -d@ -f2)"&#13;
&#13;
   if [ $# -gt 1 ] ; then&#13;
     echo "cd $2" &gt;&gt; $tempfile&#13;
   fi&#13;
&#13;
   if [ ! -f $timestamp ] ; then&#13;
     # If no timestamp file, upload all files.&#13;
     for filename in *&#13;
     do&#13;
       if [ -f "$filename" ] ; then&#13;
         echo "put -P \"$filename\"" &gt;&gt; $tempfile&#13;
         count=$(( $count + 1 ))&#13;
       fi&#13;
     done&#13;
   else&#13;
     for filename in $(find . -newer $timestamp -type f -print)&#13;
     do&#13;
       echo "put -P \"$filename\"" &gt;&gt; $tempfile&#13;
       count=$(( $count + 1 ))&#13;
     done&#13;
   fi&#13;
&#13;
   if [ $count -eq 0 ] ; then&#13;
     echo "$0: No files require uploading to $server" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   echo "quit" &gt;&gt; $tempfile&#13;
&#13;
   echo "Synchronizing: Found $count files in local folder to upload."&#13;
&#13;
<span class="ent">➊</span> if ! sftp -b $tempfile "$user@$server" ; then&#13;
      echo "Done. All files synchronized up with $server"&#13;
      touch $timestamp&#13;
   fi&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_230"/><a id="ch9ex9"/><em>Listing 9-9: The</em> <code><em>sftpsync</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch09lev2sec16"><span epub:type="pagebreak" id="page_231"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>sftp</code> program allows a series of commands to be fed into it as a pipe or input redirect. This feature makes this script rather simple: it focuses almost entirely on building up a sequence of commands to upload any changed files. At the end, these commands are fed to the <code>sftp</code> program for execution.</p>&#13;
<p class="indent">If you have a version of <code>sftp</code> that doesn’t properly return a nonzero failure code to the shell when a transfer fails, simply remove the conditional block at the end of the script <span class="ent">➊</span> and replace it with this:</p>&#13;
<pre class="programs">sftp -b $tempfile "$user@$server"&#13;
touch $timestamp</pre>&#13;
<p class="indent">Because <code>sftp</code> requires the account to be specified as <code>user@host</code>, it’s actually a bit simpler than an equivalent FTP script. Also notice the <code>-P</code> flag added to the <code>put</code> commands: it causes FTP to retain local permissions, as well as creation and modification times, for all files transferred.</p>&#13;
<h4 class="h4" id="ch09lev2sec17"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Move into the local source directory, ensure that the target directory exists, and invoke the script with your username, server name, and remote directory. For simple situations, we have an alias called <code>ssync</code> (source sync) that moves into the directory we need to keep in sync and invokes <code>sftpsync</code> automatically.</p>&#13;
<pre class="programs">alias ssync="sftpsync taylor@intuitive.com /wicked/scripts"</pre>&#13;
<h4 class="h4" id="ch09lev2sec18"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Running <code>sftpsync</code> with a user, host, and the directory to sync as arguments should allow you to sync your directories, as <a href="ch09.xhtml#ch9ex10">Listing 9-10</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">sftpsync taylor@intuitive.com /wicked/scripts</span>&#13;
Synchronizing: Found 2 files in local folder to upload.&#13;
Connecting to intuitive.com...&#13;
taylortaylor@intuitive.com's password:&#13;
sftp&gt; cd /wicked/scripts&#13;
sftp&gt; put -P "./003-normdate.sh"&#13;
Uploading ./003-normdate.sh to /usr/home/taylor/usr/local/etc/httpd/htdocs/&#13;
intuitive/wicked/scripts/003-normdate.sh&#13;
sftp&gt; put -P "./004-nicenumber.sh"&#13;
Uploading ./004-nicenumber.sh to /usr/home/taylor/usr/local/etc/httpd/htdocs/&#13;
intuitive/wicked/scripts/004-nicenumber.sh&#13;
sftp&gt; quit&#13;
Done. All files synchronized up with intuitive.com</pre>&#13;
<p class="listcap"><a id="ch9ex10"/><em>Listing 9-10: Running the</em> <code><em>sftpsync</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch09lev2sec19"><span epub:type="pagebreak" id="page_232"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">The wrapper script that we use to invoke <code>sftpsync</code> is a tremendously useful script, and we’ve used it throughout the development of this book to ensure that the copies of the scripts in the web archive at <em><a href="http://www.intuitive.com/wicked/">http://www.intuitive.com/wicked/</a></em> are exactly in sync with those on our own servers, all the while sidestepping the insecurities of the FTP protocol.</p>&#13;
<p class="indent">This wrapper in <a href="ch09.xhtml#ch9ex11">Listing 9-11</a>, <code>ssync</code>, contains all the necessary logic for moving to the correct local directory (see the variable <code>localsource</code>) and creating a file archive that has the latest versions of all the files in a so-called <em>tarball</em> (named for <code>tar</code>, the command that’s used to build it).</p>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# ssync--If anything has changed, creates a tarball and syncs a remote&#13;
#   directory via sftp using sftpsync&#13;
&#13;
sftpacct="taylor@intuitive.com"&#13;
tarballname="AllFiles.tgz"&#13;
localsource="$HOME/Desktop/Wicked Cool Scripts/scripts"&#13;
remotedir="/wicked/scripts"&#13;
timestamp=".timestamp"&#13;
count=0&#13;
&#13;
&#13;
# First off, let's see if the local directory exists and has files.&#13;
&#13;
if [ ! -d "$localsource" ] ; then&#13;
  echo "$0: Error: directory $localsource doesn't exist?" &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
cd "$localsource"&#13;
&#13;
# Now let's count files to ensure something's changed.&#13;
&#13;
if [ ! -f $timestamp ] ; then&#13;
  for filename in *&#13;
  do&#13;
    if [ -f "$filename" ] ; then&#13;
      count=$(( $count + 1 ))&#13;
    fi&#13;
  done&#13;
else&#13;
  count=$(find . -newer $timestamp -type f -print | wc -l)&#13;
fi&#13;
&#13;
if [ $count -eq 0 ] ; then&#13;
  echo "$(basename $0): No files found in $localsource to sync with remote."&#13;
  exit 0&#13;
fi&#13;
&#13;
echo "Making tarball archive file for upload"&#13;
&#13;
tar -czf $tarballname ./*&#13;
&#13;
# Done! Now let's switch to the sftpsync script.&#13;
&#13;
exec sftpsync $sftpacct $remotedir</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_233"/><a id="ch9ex11"/><em>Listing 9-11: The</em> <code><em>ssync</em></code> <em>wrapper hack script</em></p>&#13;
<p class="indent">If necessary, a new archive file is created, and all files (including the new archive, of course) are uploaded to the server as needed, as shown in <a href="ch09.xhtml#ch9ex12">Listing 9-12</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">ssync</span>&#13;
Making tarball archive file for upload&#13;
Synchronizing: Found 2 files in local folder to upload.&#13;
Connecting to intuitive.com...&#13;
taylor@intuitive.com's password:&#13;
sftp&gt; cd shellhacks/scripts&#13;
sftp&gt; put -P "./AllFiles.tgz"&#13;
Uploading ./AllFiles.tgz to shellhacks/scripts/AllFiles.tgz&#13;
sftp&gt; put -P "./ssync"&#13;
Uploading ./ssync to shellhacks/scripts/ssync&#13;
sftp&gt; quit&#13;
Done. All files synchronized up with intuitive.com</pre>&#13;
<p class="listcap"><a id="ch9ex12"/><em>Listing 9-12: Running the</em> <code><em>ssync</em></code> <em>script</em></p>&#13;
<p class="indent">One further tweak would be to have <code>ssync</code> be invoked from a <code>cron</code> job every few hours during the workday so that the files on a remote backup server are invisibly synchronized to your local files without any human intervention.<span epub:type="pagebreak" id="page_234"/></p>&#13;
</body></html>