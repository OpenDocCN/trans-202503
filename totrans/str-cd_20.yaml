- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GOING FURTHER
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ve reached the end, so let’s make it a good one. I sincerely hope your adventure
    with programming languages continues. To aid you on your quest, I offer micro-vignettes
    of additional esolangs you may wish to investigate, a collection of links to increase
    your programming language prowess, and a brief postlude.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Runners-Up**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are too many excellent esolangs out there to include all of them in a
    single book; choices had to be made. This section presents micro-vignettes of
    the esolangs that didn’t make the cut. Let them inspire you to explore, wonder,
    design, and code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Malbolge***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How difficult can a programming language be to use but still be Turing complete?
    In 1998, Malbolge’s creator, Ben Olmstead, attempted to answer that question.
    The resulting language was so difficult to code in that two years passed before
    Andrew Cooke presented a working “Hello, world!” example. The name, Malbolge,
    is a (purposeful?) misspelling of *Malebolge* the eighth circle of hell from Dante’s
    *Inferno*—the level reserved for swindlers and cheats.
  prefs: []
  type: TYPE_NORMAL
- en: Malbolge runs on a virtual machine using base-3 numbers or *trits* (ternary
    digits). Malbolge’s virtual machine is a von Neumann architecture with memory
    and code sharing the same space, thereby allowing self-modifying code.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with Malbolge, download the original version and associated files
    from *[http://esoteric.sange.fi/orphaned/malbolge/](http://esoteric.sange.fi/orphaned/malbolge/)*,
    placing the files in the *Malbolge* directory of the book’s repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the interpreter is easy. Just compile the C source file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: “Hello, world!” in Malbolge, which was found by an extensive computer search,
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll find it in *hello.mal*. To see that it works, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The virtual machine is described in *malbolge.txt* with an alternative description
    available at *[https://esolangs.org/](https://esolangs.org/)* on the Malbolge
    page. The truly daring can satisfy their lust for adventure by working through
    the “Malbolge Programming” article at *[https://esolangs.org/wiki/Malbolge_programming](https://esolangs.org/wiki/Malbolge_programming)*,
    which is itself a reworking of Lou Scheffer’s original investigations (see *[http://www.com/malbolge.shtml](http://www.com/malbolge.shtml)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s likely Malbolge *is* the most difficult programming language in the world.
    Using the eighth circle of hell as the name is clever, though. Is Malbolge really
    a fraud? To me, it’s a classic example of what an esolang encapsulates: it’s the
    result of a specific, pointed question. It does appear that Malbolge is Turing
    complete, which makes it all the more interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: Dante’s ninth circle is reserved for the treasonous. It might be interesting
    to contemplate a successor to Malbolge, that is, one reflecting the ninth circle,
    a language that breaks trust with the programmer, perhaps by randomly providing
    wrong answers.
  prefs: []
  type: TYPE_NORMAL
- en: '***INTERCAL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: INTERCAL (“Compiler Language With No Pronounceable Acronym”) was developed by
    Don Woods and James Lyon in 1972\. INTERCAL was meant as a joke. For example,
    if the compiler is given a program that does not use the `PLEASE` keyword often
    enough, it is rejected for being impolite. Similarly, if `PLEASE` appears too
    frequently, the compiler will reject the program as overly polite. Perhaps the
    most interesting part of INTERCAL is its humorous documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Humor aside, INTERCAL is Turing complete. To work with it, I suggest using the
    implementation included in Q. P. Liu’s collection of esolang implementations.
    To install it, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Liu’s implementation is in Go, which you can install like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To build INTERCAL, change to the INTERCAL directory and run make.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Liu’s implementation includes a compiler and interpreter plus some examples.
    We’ll use the interpreter. The compiler threw an error on *hello.i* when I tried
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To run the interpreter, use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What’s impressive to me is the INTERCAL implementation of *Adventure*. *Adventure*,
    created in the mid-1970s, was the first interactive fiction text adventure game.
    It’s sometimes known as *The Colossal Cave* and, in parts, became most of Infocom’s
    *Zork* series of games for microcomputers. *Adventure* was written by Will Crowther
    and Don Woods, the same Don Woods who created INTERCAL. Let’s run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In [Chapter 11](ch11.xhtml#ch11), we discussed the Befunge program bridge.bf,
    which included the word xyzzy. If you continue to play* Adventure, *you’ll eventually
    find a use for xyzzy.*'
  prefs: []
  type: TYPE_NORMAL
- en: INTERCAL supports 16-bit and 32-bit integers, which are identified by a prefix
    and a decimal number in the range [1, 65535]. For example, `.123` (“spot”) is
    a 16-bit integer, whereas `:123` (“two-spot”) is a 32-bit integer. INTERCAL also
    supports 16-bit and 32-bit arrays that are prefixed with `,` (“tail”) or `;` (“hybrid”)
    and a number. Constants are prefixed with `#` (“mesh”).
  prefs: []
  type: TYPE_NORMAL
- en: 'INTERCAL has five operators, all of which are bit-oriented. This includes two
    binary, “mingle” and “select,” and three unary logical operators: AND, OR, and
    XOR.'
  prefs: []
  type: TYPE_NORMAL
- en: '“Select” (`~`) picks bits from the first operand based on the bits set in the
    second, building the result bit by bit from right to left. The example from the
    manual is `#179~#201`, which returns `9`. To see it, first write the arguments
    in binary: 10110011[2] = 179 and 11001001[2] = 201\. Then, find all the one bits
    in 201—bits 7, 6, 3, and 0—and build the result from the corresponding bits of
    179, which are 1, 0, 0, and 1, that is, 1001[2] = 9.'
  prefs: []
  type: TYPE_NORMAL
- en: Unary logical operators are atypical. The INTERCAL manual uses the example of
    `#V77` to apply logical-OR to the constant value, 77\. [Figure 16-1](ch16.xhtml#ch016fig1)
    shows the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/16fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Unary OR in INTERCAL*'
  prefs: []
  type: TYPE_NORMAL
- en: The input, a 16-bit integer, 77, is on the top. The arrows show successive pairs
    of bits that are ORed together to produce the marked output bit. Notice that the
    output’s most significant bit is the logical-OR of the last and first bit of the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: INTERCAL’s logical operators map to Wolfram’s 1D cellular automata. A 1D *cellular
    automaton* is a rule that maps an input to an output by examining three bits at
    a time. There are 256 such rules for bytes, one of which, Rule 30, is chaotic
    enough to serve as a good pseudorandom number generator. The rule names correspond
    to the integer value of the output bits.
  prefs: []
  type: TYPE_NORMAL
- en: INTERCAL’s OR operator implements Rule 238\. It may be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To find the output bit value for a given input, examine the center bit and the
    two neighbors on either side. Then, match that bit pattern to the rule table to
    set the output bit as indicated. The output is built bit by bit, that is, it does
    not modify the input in place. For example, if the input bit is 1 and the neighbors
    to the left and right are 0 and 1, respectively, then Rule 238 says 011 → 1, meaning
    the corresponding bit position in the output is set to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Rule 238 table to the input of [Figure 16-1](ch16.xhtml#ch016fig1).
    You’ll see that the output matches. Similarly, INTERCAL’s AND operator (`&`) matches
    Rule 136 and the XOR operator (`?`) implements Rule 102.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about INTERCAL, or to simply appreciate the humor, check out the
    full manual (*[http://www.muppetlabs.com/~breadbox/intercal-man/](http://www.muppetlabs.com/~breadbox/intercal-man/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Whitespace***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'INTERCAL is a joke language that’s powerful enough to do useful things. Whitespace
    is another joke language. And like INTERCAL, it’s also Turing complete: Whitespace
    has sequence, unbounded heap storage, conditional looping, and subroutines.'
  prefs: []
  type: TYPE_NORMAL
- en: In Whitespace, the only valid program characters are space, tab, and newline
    (ASCII 10, linefeed, LF). Everything else is ignored. Therefore, a clever person
    with too much free time might embed a Whitespace program inside code for another
    language, perhaps as super-secret spy code or the like. Or perhaps not.
  prefs: []
  type: TYPE_NORMAL
- en: As a programming language, Whitespace is rather typical. There is a stack, like
    Forth, and a heap for generic storage. Input and output commands work with numbers
    or characters, like Befunge. In reality, the only exciting part of Whitespace
    is its chosen symbol set. All the same, it makes most lists of “Try these bizarre
    programming languages,” so it’s worth a cursory peek at the very least.
  prefs: []
  type: TYPE_NORMAL
- en: 'I experimented with the C implementation by GitHub user Koturn. Clone it and
    build it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several examples in the *t* directory. Kudos for using a short pathname.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The difficult part of Whitespace is writing code in it. You can’t easily use
    a normal text editor because you need to be able to input whitespace and still
    see what you are typing. For example, like Befunge, Whitespace has two input and
    two output commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, visualizing which command is which is problematic. Fortunately, Whitespace
    IDEs do exist; see *[https://vii5ard.github.io/whitespace/](https://vii5ard.github.io/whitespace/)*.
    [Figure 16-2](ch16.xhtml#ch016fig2) shows a typical session with the Whitespace
    code in the middle (shown in gray in print and in color online) and a text version
    of the program on the far right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/16fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: A Whitespace IDE*'
  prefs: []
  type: TYPE_NORMAL
- en: This slick IDE is the work of Henri Lakk. Do review the main GitHub page at
    *[https://github.com/vii5ard/whitespace/](https://github.com/vii5ard/whitespace/)*
    for more information. The IDE includes an embedded BF interpreter written in Whitespace,
    which is simply brilliant.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shakespeare***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: William Shakespeare (1564–1616) is generally regarded as the best English playwright.
    Why mention Shakespeare in a book on programming languages? Enter the Shakespeare
    Programming Language, stage right. Shakespeare, courtesy of Karl Wiberg and Jon
    Åslund, turns text that reads like a Shakespearean play into executable code.
  prefs: []
  type: TYPE_NORMAL
- en: The main Shakespeare page is at *[http://shakespearelang.sourceforge.net/](http://shakespearelang.sourceforge.net/)*.
    From there, download the Shakespeare tarball, *spl-1.2.1.tar.gz*, and install
    it, ignoring build errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'SPL is a compiler from Shakespeare to C. Several examples are included, all
    of which work nicely except *fibonacci.spl*. To run SPL, follow this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A newer project has created an interpreter in Python. This project aims to make
    it easier to develop Shakespeare code. The GitHub site is *[https://github.com/zmbc/shakespearelang/](https://github.com/zmbc/shakespearelang/)*,
    but it’s easiest to install with `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result is *shakespeare*, which is able to run the SPL listed examples above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Shakespeare translates text that looks like a play
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: into C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is then compiled to build a standalone executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shakespeare is fun to read, but even more fun to watch: *[https://www.youtube.com/watch?v=-e8oBF4IrgU](https://www.youtube.com/watch?v=-e8oBF4IrgU)*.
    I imagine this is the first time humans have ever acted out a program, let alone
    with such wonderful insults.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Whirl***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whirl (and Taxi, detailed in the next section) are two innovative esolangs created
    by Sean Heber. We’ll use Mateusz Chudyk’s Python implementation to explore Whirl.
    Grab it from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter runs out of the box, but I recommend two simple tweaks to the
    Python source to make the output look nicer. Do the following, substituting your
    favorite editor if necessary
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: and then change line 194 to read
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, change line 214 to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These changes prevent output from automatically advancing to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate Whirl like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Yay, Whirl works. But what is it? Whirl has only two instructions: 0 and 1\.
    Seriously, that’s it. Whirl consists of two rings with operations and functions
    on them; imagine actual circular rings with operations and instructions spaced
    equally along them. The first ring is the “operations ring” that holds 12 control,
    logic, and I/O operations. The second ring is the “math ring” with 12 math functions.
    Each ring also holds a single data value. Additionally, there is an “infinite”
    memory accessed via a memory pointer, much like the tape of a Turing machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whirl’s two instructions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**  Reverse the direction of the active ring. If the previous instruction
    was 0, and it did not trigger an execution, then the currently selected command
    on the currently active ring is executed and the other ring becomes active.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**  Rotate the current ring in the current direction, either clockwise or
    counterclockwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-1](ch16.xhtml#ch016tab1) shows the operation ring commands running
    clockwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Whirl’s Operations Ring'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Noop` | Do nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `Exit` | Exit |'
  prefs: []
  type: TYPE_TB
- en: '| `One` | Ring value ← 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Zero` | Ring value ← 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Load` | Ring value ← memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Store` | Ring value → memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `PAdd` | PC ← PC + ring value |'
  prefs: []
  type: TYPE_TB
- en: '| `DAdd` | MP ← MP + ring value |'
  prefs: []
  type: TYPE_TB
- en: '| `Logic` | Ring value ← 0 if memory value 0, else ring value ← ring value
    & 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `If` | If memory not equal 0, add ring value to PC |'
  prefs: []
  type: TYPE_TB
- en: '| `IntIO` | If ring value is 0, memory value ← integer read from `stdin`; otherwise,
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | print memory value to `stdout` as an integer |'
  prefs: []
  type: TYPE_TB
- en: '| `AscIO` | If ring value is 0, memory value ← ASCII character read from `stdin`;
    otherwise, print memory value to `stdout` as an ASCII character |'
  prefs: []
  type: TYPE_TB
- en: For the math ring, the commands are shown, again running clockwise, in [Table
    16-2](ch16.xhtml#ch016tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-2:** Whirl’s Math Ring'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Noop` | Do nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `Load` | Ring value ← memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Store` | Ring value → memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Add` | Ring value ← ring value + memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Mult` | Ring value ← ring value × memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Div` | Ring value ← ring value ÷ memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Zero` | Ring value ← 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Ring value ← 1 if ring value < memory value, else 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Ring value ← 1 if ring value > memory value, else 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Ring value ← 1 if ring value = memory value, else 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Not` | Ring value ← 0 if ring value ≠ 0, else 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Neg` | Ring value ← –1 × ring value |'
  prefs: []
  type: TYPE_TB
- en: When the program starts, both rings are at the `Noop` position, both ring values
    are 0, and the operation ring is active. It’s the programmer’s job to track the
    current state of the program. There is no way to query ring alignment or which
    ring is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original Whirl site is gone, but it is accessible via the Wayback Machine:
    *[http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/](http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/)*.
    I’ve taken the liberty of printing this site as a PDF. See *Whirl.pdf* on the
    book’s GitHub page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming in Whirl is not for the faint of heart, but Whirl’s no Malbolge,
    either. For example, this Whirl program from the original website demonstrates
    again that 1 + 1 = 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `00` causes the current command on the current ring to execute,
    but a single `0` only toggles the direction of the current ring. At all times,
    `1` rotates the current ring in the current direction without executing a command.
    These are critical ideas for Whirl programming. Use `1` to set up the proper command
    on the current ring and then use `00` to execute the command and automatically
    toggle to the other ring. Lastly, use `0` to toggle the rotation direction for
    the current ring.
  prefs: []
  type: TYPE_NORMAL
- en: Several other examples gleaned from the original Whirl page are in the *examples*
    directory. There are additional examples in the *whirl-interpreter* directory
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Whirl is clever, and I strongly suspect it’s Turing complete because, in the
    end, it’s another imperative programming language, albeit one with a novel twist
    to it (pun intended). Go ahead, give Whirl a whirl.
  prefs: []
  type: TYPE_NORMAL
- en: '***Taxi***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As if Whirl weren’t clever enough, Sean Heber struck again with Taxi, a programming
    language where the programmer must navigate a taxi with up to three passengers
    around Townsville while maintaining enough gas and the funds to purchase it.
  prefs: []
  type: TYPE_NORMAL
- en: Like Whirl, the original Taxi site is gone but accessible from the Wayback Machine.
    For the URL, take a look at the *README.txt* file in the *Taxi* directory of the
    book’s GitHub repository. Taxi is marked as public domain, so I’m including it
    with the book. I also made a PDF of the archived web page (see *Taxi.pdf* ).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-3](ch16.xhtml#ch016fig3) shows Townsville (*taxi_map.png*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/16fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: A map of Townsville*'
  prefs: []
  type: TYPE_NORMAL
- en: Every location marked on the map is a possible destination, and each destination
    performs a different function. Driving the taxi requires fuel, so the programmer
    must be aware of how far the taxi has traveled and make pit stops when appropriate.
    Of course, this assumes that the taxi has collected enough in fares to cover the
    cost of the fuel. Passengers, either a number or a string, pay a flat rate of
    0.07 credits per mile, but only pay when they have reached their destination.
  prefs: []
  type: TYPE_NORMAL
- en: Destinations implement the operations of the language. Need to add some values?
    Take your passengers to Addition Alley. Want a random integer? Pick one up at
    Heisenberg’s, but be prepared for a certain level of indecision on his part.
  prefs: []
  type: TYPE_NORMAL
- en: Some destinations implement data structures. Want a FIFO data structure? Visit
    Joyless Park or Sunny Skies Park. Prefer LIFO? Then use Narrow Path Park. Running
    low on gas? Better get to Zoom Zoom for the cheapest gas in town. Avoid Fueler
    Up if you can. You’ll pay too much. The complete list of destinations, and associated
    operations, is in *Taxi.pdf* . Enjoy the creative names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taxi code is verbose, almost plaintext, much like the HyperTalk language used
    by HyperCard, an old Macintosh programming environment from Apple. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This prints, well, you know what it prints. The program begins with the taxi
    at the Taxi Garage and ends when the taxi returns to the garage. The first line
    puts a string at the Writer’s Depot, which holds a string constant. To use the
    string, you must first get to the Writer’s Depot from the Taxi Garage. To do that,
    you need to go west, take the first left, then the second right, then the first
    left, and, lastly, the second left. Consult *taxi_map.png*, and you’ll see that
    the directions do take you from the Taxi Garage to the Writer’s Depot.
  prefs: []
  type: TYPE_NORMAL
- en: The following line, `Pickup a passenger going to the Post Office`, gets the
    string with the intended destination. So use directions from the current location
    to get to the Post Office. The Post Office prints passengers to `stdout` (standard
    output). Pick up a passenger at the Post Office to get input from the user. To
    end the program, return to the Taxi Garage.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you don’t return to the garage? The program ends poorly: `The` `boss
    couldn''t find your taxi in the garage. You''re fired!` So return to the garage,
    or else!'
  prefs: []
  type: TYPE_NORMAL
- en: Flow control makes use of labels enclosed in square brackets and the `Switch`
    statement with references to the labels in quotation marks. For example, the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: is an unconditional branch to `[loop]`, while
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: is a conditional branch.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ source code for Taxi is in *taxi.cpp*. I recommend commenting out the
    startup and exit messages at lines 472, 1267, and 1268\. Or not; it’s a matter
    of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: To use Taxi, first build it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that Taxi supports floating-point numbers. Be sure not to miss Nick Turner’s
    RPN calculator in *rpn.taxi*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taxi is an excellent example of the esolang community’s unbounded creativity.
    It’s possible to imagine using Taxi, or something built from it, to introduce
    programming concepts. Of interest at a higher level is the fact that operations
    in Taxi come with a price: literally. Programmers are accustomed to operations
    having no intrinsic cost other than memory and time. In Taxi, the number of operations,
    and their relative relationship to each other, introduce another cost on top of
    the usual memory and time.'
  prefs: []
  type: TYPE_NORMAL
- en: Development on Taxi has stalled, but the source code is in the public domain.
    Perhaps someone will pick it up, refine it, and introduce it again in another
    form. If targeting younger programmers, I suggest leaving out the travel cost
    aspect. What about a new metaphor? Perhaps an airplane flying from city to city,
    or a starship warping from star system to star system?
  prefs: []
  type: TYPE_NORMAL
- en: '***Dathanna***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The original Apple II+ computer from 1979 contained an 8-bit 6502 microprocessor
    running in a system with a 1 MHz clock, half of which was used to refresh RAM.
    By modern standards, the Apple II+ crawled along at continental drift speeds.
    However, modern computers are capable of emulating an Apple II+ at something approaching
    100 times its native speed (84 times on my test system). This fact opens up new
    possibilities for programs written for the Apple II that would be far too slow
    on a native system but are entirely usable on an emulator running at full speed.
  prefs: []
  type: TYPE_NORMAL
- en: Dathanna, Irish for “colors,” is just such a program. Dathanna is an esolang
    using colored blocks, two stacked one on top of the other, to specify commands.
    It echoes both Befunge-93 and Piet in how it operates. However, the most important
    part of Dathanna is that its interpreter is written in Applesoft BASIC and it
    runs off a disk image meant for Apple II emulators.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find Dathanna, along with all necessary files and documentation, on
    the book’s GitHub site. All I’ll present here is a bit of source code to whet
    your appetite: a program to estimate *π* using random numbers, much like we did
    earlier in the book with ABC. See [Figure 16-4](ch16.xhtml#ch016fig4), which should
    really be in color. Review the documentation to learn how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/16fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4: Dathanna code to estimate *π* with random numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Language Resources**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What follows is a prosaic but helpful list of resources to increase your knowledge
    of programming languages. I selected freely available material presented by the
    original authors when possible. Naturally, some of these URLs will fail over time,
    but the internet remembers, for good or ill. If a particular link no longer works,
    searching for the title will likely locate the resource once more.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages tend to evolve slowly. If a few of the resources here
    are a decade or more old, that’s okay. The burning need to stay current is less
    critical in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections divide the resources into three groups. The first is
    a catch-all on programming languages in general. These resources are similar to
    what you typically encounter in an undergraduate course on programming languages.
    The second section covers data structures, which we unfairly neglected in [Chapter
    2](ch02.xhtml#ch02). The third section relates to compilers and interpreters—the
    methods for actualizing a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The links are presented as title and URL with minimal comment. I reviewed all
    the material and found it helpful, though there are definite limits to what you
    can learn simply by reading. At some point, you have to go further and build something.
  prefs: []
  type: TYPE_NORMAL
- en: '***Programming Languages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The material here covers programming languages at an undergraduate level. As
    you read through it, recall the esolangs and other languages we discussed in the
    book to build connections with the more general concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concepts of Programming Languages: A Unified Approach**  by Karl Abrahamson.
    The first five parts of this book introduce programming language concepts. The
    later portions of the book dive into functional programming, though there is a
    chapter on Scheme, which we used in [Chapter 8](ch08.xhtml#ch08) to implement
    FRACTRAN. (*[http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf](http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Programming Language Design**  by Raphael Finkel. I read this book
    in the late 1990s and found it very helpful. Recommended. (*[https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf](https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Languages and Techniques**  by Steve Zdancewic and Stephanie
    Weirich. Use this as a reference and as a review of techniques associated with
    programming languages. However, the use of OCaml, a functional language, might
    make direct translation of techniques to other languages a bit more difficult.
    (*[https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf](https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Languages: Application and Interpretation**  by Shriram Krishnamurthi.
    These notes are an alternative introduction to the elements of programming languages
    using Typed PLAI, a language supported by Racket. Use it in conjunction with the
    references above. (*[http://cs.brown.edu/courses/cs173/2012/book/book.pdf](http://cs.brown.edu/courses/cs173/2012/book/book.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical Foundations for Programming Languages**  by Robert Harper. This
    book, at nearly 600 pages, dives into the mathematics of programming and is more
    theoretical than the references above. (*[https://thelackthereof.org/docs/library/book.pdf](https://thelackthereof.org/docs/library/book.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models of Computation**  by John E. Savage. This is not a programming language
    book, but rather an in-depth, highly theoretical exploration of computation, or,
    as the subtitle says, “exploring the power of computing.” Our discussion of Turing
    machines in [Chapter 3](ch03.xhtml#ch03) serves as a (simple) introduction to
    this material. (*[http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf](http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Structures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data structures are tools used by programming languages to store and manipulate
    information. The form the structures take is a function of the elements provided
    by the programming language. The level of difficulty in implementing a particular
    data structure depends on the language used. Implementing a dictionary in Python
    is trivial because it’s part of the core language. Implementing a stack in Forth
    is trivial for the same reason. Pascal and C/C++ both provide syntactic support
    for records and structures. However, doing the same in Forth, at least in simple
    Forth systems, requires rolling your own data structures and directly managing
    a space of memory, often at the byte level.
  prefs: []
  type: TYPE_NORMAL
- en: '**A First Course on Data Structures in Python**  by Donald R. Sheehy. A basic
    introduction to data structures using Python. I suggest starting with [Chapter
    5](ch05.xhtml#ch05), if not [Chapter 6](ch06.xhtml#ch06). (*[https://donsheehy.github.io/datastructures/fullbook.pdf](https://donsheehy.github.io/datastructures/fullbook.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Structures and Algorithms**  by John Bullinaria. This reference is a
    succinct introduction with pseudocode algorithms and examples in C and Java. If
    the book above is too much, begin with this one. (*[https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf](https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Structures and Algorithm Analysis**  by Clifford A. Shaffer. This book
    covers much the same material as the ones above, in Java, but includes analysis
    of algorithm performance and, in the final chapter, a discussion on the limits
    of computation. (*[https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf](https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Compilers and Interpreters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A programming language remains nothing more than a mental construct until an
    implementation actualizes it. Classically, implementation meant a compiler, as
    computers were generally too slow to make interpreted programming languages anything
    more than curiosities. Of course, this is no longer the case, and even simple
    interpreters are quite fast on modern hardware, to say nothing of the hybrid case
    of compiling a high-level language to code running on a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll find introductory material to help you learn about the
    process of building a compiler or interpreter. The latter is more straightforward,
    of course, but the former is definitely worth the effort, at least to understand
    the parts we discussed in [Chapter 2](ch02.xhtml#ch02) at a deeper level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Crafting Interpreters**  by Robert Nystrom. This website features an online
    book about crafting interpreters. Worth a look. (*[https://craftinginterpreters.com](https://craftinginterpreters.com)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing Programming Languages**  by Aarne Ranta. Use this book as an
    introduction. It appears to be incomplete and, given the 2012 date, will likely
    remain so. However, the early chapters are complete and helpful. (*[https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf](https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basics of Compiler Design**  by Torben Ægidius Mogensen. This book introduces
    compiler design in much the same vein as the famous Dragon Book referenced in
    [Chapter 2](ch02.xhtml#ch02). The treatment is mathematical, so you’ll need to
    know how to read set notation, for instance, but the level isn’t that required
    of a graduate course. (*[http://hjemmesider.diku.dk/~torbenm/](http://hjemmesider.diku.dk/~torbenm/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**An Introduction to Compilers**  by D. Vermeir. Use this book as another reference
    to the main topics of compiler design. The example code is written in C. (*[http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf](http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to Compilers and Language Design**  by Douglas Thain. This book
    serves as an alternative introduction to *Basics of Compiler Design* mentioned
    above. Take a look. (*[https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf](https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiler Construction Using Flex and Bison**  by Anthony A. Aaby. Flex and
    Bison are classic compiler generation tools. While there are more current tools,
    this text includes the full source code for the Simple language. Use it as a case
    study in compiler design. (*[http://www.admb-project.org/tools/flex/compiler.pdf](http://www.admb-project.org/tools/flex/compiler.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Languages and Their Compilers**  by John Cocke and J. T. Schwartz.
    This historical text, from 1970, details compilers as they existed then. Languages
    discussed include FORTRAN, LISP, and, a favorite of this book, SNOBOL. (*[http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf](http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Postlude**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are still here at the end of the book and I thank you. I hope you had fun
    and learned things you didn’t know before. And I hope you’re excited about programming
    languages, especially the strange, weird, unusual, and esoteric kind.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to develop your own programming language, even if you never
    implement it. There is something deeply satisfying about creating a new way to
    express thought. I suspect that for every implemented esolang, there are many
    more existing only as plans, notes, or vague notions. If you do nothing more than
    write it out on paper, and have fun doing it, then the language is worthwhile
    solely for the enjoyment its design brought.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you *do* implement it, let me know. I’d love to write some code
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Quando omni flunkus moritati.*'
  prefs: []
  type: TYPE_NORMAL
