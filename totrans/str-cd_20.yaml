- en: '16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '16'
- en: GOING FURTHER
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步探索
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: We’ve reached the end, so let’s make it a good one. I sincerely hope your adventure
    with programming languages continues. To aid you on your quest, I offer micro-vignettes
    of additional esolangs you may wish to investigate, a collection of links to increase
    your programming language prowess, and a brief postlude.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了最后部分，让我们以精彩的方式结束。我真诚地希望你在编程语言上的冒险继续下去。为了帮助你在这场旅程中，我提供了一些你可能想探索的 esolang
    微型小插曲，一些能提升你编程语言能力的链接集合，以及简短的后记。
- en: '**The Runners-Up**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**入围者**'
- en: There are too many excellent esolangs out there to include all of them in a
    single book; choices had to be made. This section presents micro-vignettes of
    the esolangs that didn’t make the cut. Let them inspire you to explore, wonder,
    design, and code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有太多优秀的 esolang（极客语言）无法在一本书中一一列出，因此做出了选择。本节将展示那些未能入选的 esolang 微型小插曲。让它们激发你去探索、思考、设计和编程。
- en: '***Malbolge***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Malbolge***'
- en: How difficult can a programming language be to use but still be Turing complete?
    In 1998, Malbolge’s creator, Ben Olmstead, attempted to answer that question.
    The resulting language was so difficult to code in that two years passed before
    Andrew Cooke presented a working “Hello, world!” example. The name, Malbolge,
    is a (purposeful?) misspelling of *Malebolge* the eighth circle of hell from Dante’s
    *Inferno*—the level reserved for swindlers and cheats.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程语言能有多难用，但仍然是图灵完备的呢？1998年，Malbolge的创造者本·奥姆斯特德（Ben Olmstead）试图回答这个问题。最终的语言难度极高，以至于两年后，安德鲁·库克（Andrew
    Cooke）才展示了一个可以运行的“Hello, world!”示例。Malbolge 这个名字是 *Malebolge*（但丁《神曲》中的地狱第八圈）的一个（故意的？）拼写错误——这是专门为骗子和欺诈者保留的圈层。
- en: Malbolge runs on a virtual machine using base-3 numbers or *trits* (ternary
    digits). Malbolge’s virtual machine is a von Neumann architecture with memory
    and code sharing the same space, thereby allowing self-modifying code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Malbolge 在一个虚拟机上运行，使用三进制数字或 *三元数字*（trits）。Malbolge 的虚拟机采用冯·诺依曼架构，内存和代码共享同一空间，从而允许自我修改代码。
- en: To experiment with Malbolge, download the original version and associated files
    from *[http://esoteric.sange.fi/orphaned/malbolge/](http://esoteric.sange.fi/orphaned/malbolge/)*,
    placing the files in the *Malbolge* directory of the book’s repo.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 Malbolge，请从 *[http://esoteric.sange.fi/orphaned/malbolge/](http://esoteric.sange.fi/orphaned/malbolge/)*
    下载原始版本及相关文件，并将这些文件放入书籍仓库中的 *Malbolge* 目录。
- en: 'Building the interpreter is easy. Just compile the C source file as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解释器很简单。只需按如下方式编译 C 源文件：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: “Hello, world!” in Malbolge, which was found by an extensive computer search,
    is
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Malbolge 中的 “Hello, world!” 示例是通过广泛的计算机搜索找到的，结果是：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You’ll find it in *hello.mal*. To see that it works, run the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 *hello.mal* 中找到它。为了验证它的正确性，请运行以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The virtual machine is described in *malbolge.txt* with an alternative description
    available at *[https://esolangs.org/](https://esolangs.org/)* on the Malbolge
    page. The truly daring can satisfy their lust for adventure by working through
    the “Malbolge Programming” article at *[https://esolangs.org/wiki/Malbolge_programming](https://esolangs.org/wiki/Malbolge_programming)*,
    which is itself a reworking of Lou Scheffer’s original investigations (see *[http://www.com/malbolge.shtml](http://www.com/malbolge.shtml)*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的描述可以在 *malbolge.txt* 中找到，也可以在 *[https://esolangs.org/](https://esolangs.org/)*
    上的 Malbolge 页面找到另一种描述。真正敢于冒险的人可以通过阅读 *[https://esolangs.org/wiki/Malbolge_programming](https://esolangs.org/wiki/Malbolge_programming)*
    上的 “Malbolge 编程” 文章来满足他们对冒险的渴望，这篇文章本身是 Lou Scheffer 最初研究的改编（请参见 *[http://www.com/malbolge.shtml](http://www.com/malbolge.shtml)*）。
- en: 'It’s likely Malbolge *is* the most difficult programming language in the world.
    Using the eighth circle of hell as the name is clever, though. Is Malbolge really
    a fraud? To me, it’s a classic example of what an esolang encapsulates: it’s the
    result of a specific, pointed question. It does appear that Malbolge is Turing
    complete, which makes it all the more interesting.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，Malbolge *确实*是世界上最难使用的编程语言。以地狱第八圈为名字，真是别出心裁。不过，Malbolge 真的是一种欺骗语言吗？对我来说，它是
    esolang 的经典例子：它是一个特定、尖锐问题的产物。看起来 Malbolge 确实是图灵完备的，这也让它更具趣味性。
- en: Dante’s ninth circle is reserved for the treasonous. It might be interesting
    to contemplate a successor to Malbolge, that is, one reflecting the ninth circle,
    a language that breaks trust with the programmer, perhaps by randomly providing
    wrong answers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但丁的第九圈地狱是为叛徒准备的。或许可以想象 Malbolge 的继任者，即一个反映第九圈的语言，这种语言可能通过随机提供错误答案来背叛程序员的信任。
- en: '***INTERCAL***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***INTERCAL***'
- en: INTERCAL (“Compiler Language With No Pronounceable Acronym”) was developed by
    Don Woods and James Lyon in 1972\. INTERCAL was meant as a joke. For example,
    if the compiler is given a program that does not use the `PLEASE` keyword often
    enough, it is rejected for being impolite. Similarly, if `PLEASE` appears too
    frequently, the compiler will reject the program as overly polite. Perhaps the
    most interesting part of INTERCAL is its humorous documentation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL（“没有可发音缩写的编译语言”）由 Don Woods 和 James Lyon 于 1972 年开发。INTERCAL 原本是作为一个笑话开发的。例如，如果编译器遇到一个程序，其中
    `PLEASE` 关键字使用得不够频繁，它会因为不礼貌而被拒绝。类似地，如果 `PLEASE` 使用得过于频繁，编译器会拒绝这个程序，认为它过于礼貌。INTERCAL
    最有趣的部分可能是它那幽默的文档。
- en: Humor aside, INTERCAL is Turing complete. To work with it, I suggest using the
    implementation included in Q. P. Liu’s collection of esolang implementations.
    To install it, use
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 说到幽默，INTERCAL 是图灵完备的。为了使用它，我建议使用 Q. P. Liu 提供的 esolang 实现合集中的实现版本。安装方法如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Liu’s implementation is in Go, which you can install like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 刘的实现使用 Go 语言，你可以通过如下方式安装：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To build INTERCAL, change to the INTERCAL directory and run make.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 INTERCAL，进入 INTERCAL 目录并运行 make。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Liu’s implementation includes a compiler and interpreter plus some examples.
    We’ll use the interpreter. The compiler threw an error on *hello.i* when I tried
    it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 刘的实现包括一个编译器和解释器，以及一些示例。我们将使用解释器。编译器在我尝试运行 *hello.i* 时抛出了一个错误。
- en: To run the interpreter, use
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行解释器，使用
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What’s impressive to me is the INTERCAL implementation of *Adventure*. *Adventure*,
    created in the mid-1970s, was the first interactive fiction text adventure game.
    It’s sometimes known as *The Colossal Cave* and, in parts, became most of Infocom’s
    *Zork* series of games for microcomputers. *Adventure* was written by Will Crowther
    and Don Woods, the same Don Woods who created INTERCAL. Let’s run it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 给我留下深刻印象的是 INTERCAL 中的 *Adventure* 实现。*Adventure*，创建于 1970 年代中期，是第一个互动文字冒险游戏。它有时被称为
    *The Colossal Cave*，并且在某些部分成为了 Infocom 的 *Zork* 系列微型计算机游戏的基础。*Adventure* 是由 Will
    Crowther 和 Don Woods 编写的，而 Don Woods 也是创建 INTERCAL 的人。让我们来运行它。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In [Chapter 11](ch11.xhtml#ch11), we discussed the Befunge program bridge.bf,
    which included the word xyzzy. If you continue to play* Adventure, *you’ll eventually
    find a use for xyzzy.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[第 11 章](ch11.xhtml#ch11)中，我们讨论了 Befunge 程序 bridge.bf，其中包括了单词 xyzzy。如果你继续玩*
    Adventure，*你最终会发现 xyzzy 有用。*'
- en: INTERCAL supports 16-bit and 32-bit integers, which are identified by a prefix
    and a decimal number in the range [1, 65535]. For example, `.123` (“spot”) is
    a 16-bit integer, whereas `:123` (“two-spot”) is a 32-bit integer. INTERCAL also
    supports 16-bit and 32-bit arrays that are prefixed with `,` (“tail”) or `;` (“hybrid”)
    and a number. Constants are prefixed with `#` (“mesh”).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL 支持 16 位和 32 位整数，这些整数通过前缀和范围为 [1, 65535] 的十进制数字来标识。例如，`.123`（“点”）是一个
    16 位整数，而 `:123`（“双点”）是一个 32 位整数。INTERCAL 还支持 16 位和 32 位数组，这些数组以 `,`（“尾部”）或 `;`（“混合”）作为前缀，并带有一个数字。常量以
    `#`（“网格”）为前缀。
- en: 'INTERCAL has five operators, all of which are bit-oriented. This includes two
    binary, “mingle” and “select,” and three unary logical operators: AND, OR, and
    XOR.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL 有五个操作符，所有操作符都是位操作。包括两个二元操作符：“mingle”和“select”，以及三个一元逻辑操作符：AND、OR 和
    XOR。
- en: '“Select” (`~`) picks bits from the first operand based on the bits set in the
    second, building the result bit by bit from right to left. The example from the
    manual is `#179~#201`, which returns `9`. To see it, first write the arguments
    in binary: 10110011[2] = 179 and 11001001[2] = 201\. Then, find all the one bits
    in 201—bits 7, 6, 3, and 0—and build the result from the corresponding bits of
    179, which are 1, 0, 0, and 1, that is, 1001[2] = 9.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “选择”（`~`）根据第二个操作数中设置的位，从第一个操作数中选择比特，逐位从右到左构建结果。手册中的示例是 `#179~#201`，结果为 `9`。为了查看，首先将参数写成二进制：10110011[2]
    = 179 和 11001001[2] = 201。然后，找到 201 中的所有 1 位——位 7、6、3 和 0——并从 179 中相应的比特中构建结果，它们分别是
    1、0、0 和 1，也就是 1001[2] = 9。
- en: Unary logical operators are atypical. The INTERCAL manual uses the example of
    `#V77` to apply logical-OR to the constant value, 77\. [Figure 16-1](ch16.xhtml#ch016fig1)
    shows the operation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一元逻辑操作符很不寻常。INTERCAL 手册使用了 `#V77` 的例子来对常量值 77 应用逻辑 OR。 [图 16-1](ch16.xhtml#ch016fig1)
    显示了该操作。
- en: '![Image](Images/16fig01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/16fig01.jpg)'
- en: '*Figure 16-1: Unary OR in INTERCAL*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-1：INTERCAL 中的一元 OR 操作*'
- en: The input, a 16-bit integer, 77, is on the top. The arrows show successive pairs
    of bits that are ORed together to produce the marked output bit. Notice that the
    output’s most significant bit is the logical-OR of the last and first bit of the
    input.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一个16位整数77，位于顶部。箭头显示了逐对的位被或运算（OR）合并在一起，从而产生标记的输出位。注意，输出的最高有效位是输入最后一位和第一位的逻辑或（OR）结果。
- en: INTERCAL’s logical operators map to Wolfram’s 1D cellular automata. A 1D *cellular
    automaton* is a rule that maps an input to an output by examining three bits at
    a time. There are 256 such rules for bytes, one of which, Rule 30, is chaotic
    enough to serve as a good pseudorandom number generator. The rule names correspond
    to the integer value of the output bits.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL的逻辑运算符映射到Wolfram的1D元胞自动机。1D *元胞自动机* 是一种规则，通过一次检查三个位来将输入映射到输出。对于字节来说，共有256种这样的规则，其中规则30足够混乱，可以作为一个很好的伪随机数生成器。这些规则的名称对应输出位的整数值。
- en: INTERCAL’s OR operator implements Rule 238\. It may be written as
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL的OR运算符实现了规则238。它可以写作：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To find the output bit value for a given input, examine the center bit and the
    two neighbors on either side. Then, match that bit pattern to the rule table to
    set the output bit as indicated. The output is built bit by bit, that is, it does
    not modify the input in place. For example, if the input bit is 1 and the neighbors
    to the left and right are 0 and 1, respectively, then Rule 238 says 011 → 1, meaning
    the corresponding bit position in the output is set to 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到给定输入的输出位值，请检查中心位及其两侧的两个相邻位。然后，将该位模式与规则表匹配，按指示设置输出位。输出是逐位构建的，也就是说，它不会就地修改输入。例如，如果输入位是1，左右相邻位分别是0和1，则规则238表示011
    → 1，意味着输出中对应的位被设置为1。
- en: Apply the Rule 238 table to the input of [Figure 16-1](ch16.xhtml#ch016fig1).
    You’ll see that the output matches. Similarly, INTERCAL’s AND operator (`&`) matches
    Rule 136 and the XOR operator (`?`) implements Rule 102.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将规则238表应用于[图16-1](ch16.xhtml#ch016fig1)中的输入。你会发现输出匹配。类似地，INTERCAL的AND运算符（`&`）匹配规则136，XOR运算符（`?`）实现规则102。
- en: To learn more about INTERCAL, or to simply appreciate the humor, check out the
    full manual (*[http://www.muppetlabs.com/~breadbox/intercal-man/](http://www.muppetlabs.com/~breadbox/intercal-man/)*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于INTERCAL的信息，或者仅仅是欣赏其幽默，可以查看完整手册 (*[http://www.muppetlabs.com/~breadbox/intercal-man/](http://www.muppetlabs.com/~breadbox/intercal-man/)*).
- en: '***Whitespace***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Whitespace***'
- en: 'INTERCAL is a joke language that’s powerful enough to do useful things. Whitespace
    is another joke language. And like INTERCAL, it’s also Turing complete: Whitespace
    has sequence, unbounded heap storage, conditional looping, and subroutines.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL是一个笑话编程语言，但它足够强大，能够做有用的事情。Whitespace也是另一个笑话编程语言。而且像INTERCAL一样，它也是图灵完备的：Whitespace具有序列、无界堆存储、条件循环和子程序。
- en: In Whitespace, the only valid program characters are space, tab, and newline
    (ASCII 10, linefeed, LF). Everything else is ignored. Therefore, a clever person
    with too much free time might embed a Whitespace program inside code for another
    language, perhaps as super-secret spy code or the like. Or perhaps not.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Whitespace中，唯一有效的程序字符是空格、制表符和换行符（ASCII 10，换行符，LF）。其他所有内容都会被忽略。因此，一个有着过多空闲时间的聪明人可能会将Whitespace程序嵌入到另一种语言的代码中，也许是作为超级机密的间谍代码之类的东西。或者也许不是。
- en: As a programming language, Whitespace is rather typical. There is a stack, like
    Forth, and a heap for generic storage. Input and output commands work with numbers
    or characters, like Befunge. In reality, the only exciting part of Whitespace
    is its chosen symbol set. All the same, it makes most lists of “Try these bizarre
    programming languages,” so it’s worth a cursory peek at the very least.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程语言，Whitespace相当典型。它有一个栈，类似于Forth，并且有一个堆用于通用存储。输入和输出命令可以处理数字或字符，类似于Befunge。实际上，Whitespace唯一令人兴奋的部分是它选择的符号集。尽管如此，它仍然出现在大多数“尝试这些奇异的编程语言”列表中，所以至少值得快速浏览一下。
- en: 'I experimented with the C implementation by GitHub user Koturn. Clone it and
    build it like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我在GitHub用户Koturn的C语言实现中做了一些实验。克隆它并按如下方式构建：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are several examples in the *t* directory. Kudos for using a short pathname.
    For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*t* 目录中有几个示例。使用短路径名值得称赞。例如：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The difficult part of Whitespace is writing code in it. You can’t easily use
    a normal text editor because you need to be able to input whitespace and still
    see what you are typing. For example, like Befunge, Whitespace has two input and
    two output commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Whitespace的难点在于编写代码。你不能轻易使用普通文本编辑器，因为你需要能够输入空格并仍然看到你所输入的内容。例如，像Befunge一样，Whitespace有两个输入命令和两个输出命令：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, visualizing which command is which is problematic. Fortunately, Whitespace
    IDEs do exist; see *[https://vii5ard.github.io/whitespace/](https://vii5ard.github.io/whitespace/)*.
    [Figure 16-2](ch16.xhtml#ch016fig2) shows a typical session with the Whitespace
    code in the middle (shown in gray in print and in color online) and a text version
    of the program on the far right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，查看每个命令的可视化效果是有问题的。幸运的是，Whitespaces IDE 确实存在；见 *[https://vii5ard.github.io/whitespace/](https://vii5ard.github.io/whitespace/)*。[图
    16-2](ch16.xhtml#ch016fig2) 显示了一个典型的会话，其中 Whitespace 代码位于中间（打印时为灰色，在线为彩色），程序的文本版本位于最右侧。
- en: '![Image](Images/16fig02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/16fig02.jpg)'
- en: '*Figure 16-2: A Whitespace IDE*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2：一个 Whitespace IDE*'
- en: This slick IDE is the work of Henri Lakk. Do review the main GitHub page at
    *[https://github.com/vii5ard/whitespace/](https://github.com/vii5ard/whitespace/)*
    for more information. The IDE includes an embedded BF interpreter written in Whitespace,
    which is simply brilliant.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的 IDE 是 Henri Lakk 的作品。请查看主 GitHub 页面 *[https://github.com/vii5ard/whitespace/](https://github.com/vii5ard/whitespace/)*，以获取更多信息。该
    IDE 包含一个用 Whitespace 编写的嵌入式 BF 解释器，简直是天才之作。
- en: '***Shakespeare***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shakespeare***'
- en: William Shakespeare (1564–1616) is generally regarded as the best English playwright.
    Why mention Shakespeare in a book on programming languages? Enter the Shakespeare
    Programming Language, stage right. Shakespeare, courtesy of Karl Wiberg and Jon
    Åslund, turns text that reads like a Shakespearean play into executable code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 威廉·莎士比亚（1564-1616）通常被认为是最伟大的英语剧作家。为什么在一本关于编程语言的书中提到莎士比亚？莎士比亚编程语言登场，舞台右侧。莎士比亚编程语言由
    Karl Wiberg 和 Jon Åslund 创造，它将看起来像莎士比亚戏剧的文本转换为可执行代码。
- en: The main Shakespeare page is at *[http://shakespearelang.sourceforge.net/](http://shakespearelang.sourceforge.net/)*.
    From there, download the Shakespeare tarball, *spl-1.2.1.tar.gz*, and install
    it, ignoring build errors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的莎士比亚页面位于*[http://shakespearelang.sourceforge.net/](http://shakespearelang.sourceforge.net/)*。在那里，下载莎士比亚的
    tarball，*spl-1.2.1.tar.gz*，并安装它，忽略构建错误。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'SPL is a compiler from Shakespeare to C. Several examples are included, all
    of which work nicely except *fibonacci.spl*. To run SPL, follow this pattern:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SPL 是从莎士比亚编译到 C 的编译器。包括了几个示例，除了*fibonacci.spl*之外，所有示例都能很好地工作。要运行 SPL，请遵循以下模式：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A newer project has created an interpreter in Python. This project aims to make
    it easier to develop Shakespeare code. The GitHub site is *[https://github.com/zmbc/shakespearelang/](https://github.com/zmbc/shakespearelang/)*,
    but it’s easiest to install with `pip`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的项目已经创建了一个 Python 解释器。该项目旨在简化莎士比亚代码的开发。GitHub 网站是 *[https://github.com/zmbc/shakespearelang/](https://github.com/zmbc/shakespearelang/)*，但最简单的安装方法是通过
    `pip`。
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result is *shakespeare*, which is able to run the SPL listed examples above.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是*shakespeare*，能够运行上述 SPL 示例。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Shakespeare translates text that looks like a play
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 莎士比亚将看起来像戏剧的文本
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: into C code
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 C 代码
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is then compiled to build a standalone executable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其编译以构建一个独立的可执行文件。
- en: 'Shakespeare is fun to read, but even more fun to watch: *[https://www.youtube.com/watch?v=-e8oBF4IrgU](https://www.youtube.com/watch?v=-e8oBF4IrgU)*.
    I imagine this is the first time humans have ever acted out a program, let alone
    with such wonderful insults.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 莎士比亚的作品很有趣，阅读它很有趣，观看它更有趣：*[https://www.youtube.com/watch?v=-e8oBF4IrgU](https://www.youtube.com/watch?v=-e8oBF4IrgU)*。我想这可能是人类第一次将程序表演出来，更别提还带有如此精彩的侮辱了。
- en: '***Whirl***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Whirl***'
- en: Whirl (and Taxi, detailed in the next section) are two innovative esolangs created
    by Sean Heber. We’ll use Mateusz Chudyk’s Python implementation to explore Whirl.
    Grab it from GitHub.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Whirl（以及下节中详细介绍的 Taxi）是 Sean Heber 创建的两种创新的 esolangs。我们将使用 Mateusz Chudyk 的
    Python 实现来探索 Whirl。可以从 GitHub 获取它。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The interpreter runs out of the box, but I recommend two simple tweaks to the
    Python source to make the output look nicer. Do the following, substituting your
    favorite editor if necessary
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器开箱即用，但我推荐对 Python 源代码做两个简单的调整，使输出看起来更漂亮。根据需要，使用你喜欢的编辑器进行以下操作：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: and then change line 194 to read
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将第 194 行更改为：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Likewise, change line 214 to
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将第 214 行改为
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These changes prevent output from automatically advancing to the next line.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改防止输出自动跳转到下一行。
- en: 'Validate Whirl like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示验证 Whirl：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Yay, Whirl works. But what is it? Whirl has only two instructions: 0 and 1\.
    Seriously, that’s it. Whirl consists of two rings with operations and functions
    on them; imagine actual circular rings with operations and instructions spaced
    equally along them. The first ring is the “operations ring” that holds 12 control,
    logic, and I/O operations. The second ring is the “math ring” with 12 math functions.
    Each ring also holds a single data value. Additionally, there is an “infinite”
    memory accessed via a memory pointer, much like the tape of a Turing machine.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 耶，Whirl 可用了。但它到底是什么？Whirl 只有两个指令：0 和 1。说真的，就只有这两个。Whirl 由两个环组成，每个环上有操作和功能；可以想象这些环是实际的圆形环，上面均匀地分布着操作和指令。第一个环是“操作环”，包含
    12 种控制、逻辑和 I/O 操作。第二个环是“数学环”，包含 12 种数学函数。每个环还保存一个数据值。此外，还有一个通过内存指针访问的“无限”内存，就像图灵机的磁带一样。
- en: 'Whirl’s two instructions are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Whirl 的两个指令是：
- en: '**0**  Reverse the direction of the active ring. If the previous instruction
    was 0, and it did not trigger an execution, then the currently selected command
    on the currently active ring is executed and the other ring becomes active.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**0**  反转活动环的方向。如果上一个指令是 0，并且没有触发执行，则当前选中的命令在当前活动环上执行，另一个环变为活动状态。'
- en: '**1**  Rotate the current ring in the current direction, either clockwise or
    counterclockwise.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**  旋转当前环，旋转方向可以是顺时针或逆时针。'
- en: '[Table 16-1](ch16.xhtml#ch016tab1) shows the operation ring commands running
    clockwise.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16.xhtml#ch016tab1) 显示了操作环的命令，顺时针运行。'
- en: '**Table 16-1:** Whirl’s Operations Ring'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-1：** Whirl 的操作环'
- en: '| **Instruction** | **Effect** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Noop` | Do nothing |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Noop` | 不做任何操作 |'
- en: '| `Exit` | Exit |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Exit` | 退出 |'
- en: '| `One` | Ring value ← 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `One` | 环值 ← 1 |'
- en: '| `Zero` | Ring value ← 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Zero` | 环值 ← 0 |'
- en: '| `Load` | Ring value ← memory value |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Load` | 环值 ← 内存值 |'
- en: '| `Store` | Ring value → memory value |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Store` | 环值 → 内存值 |'
- en: '| `PAdd` | PC ← PC + ring value |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `PAdd` | PC ← PC + 环值 |'
- en: '| `DAdd` | MP ← MP + ring value |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `DAdd` | MP ← MP + 环值 |'
- en: '| `Logic` | Ring value ← 0 if memory value 0, else ring value ← ring value
    & 1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Logic` | 如果内存值为 0，则环值 ← 0；否则，环值 ← 环值 & 1 |'
- en: '| `If` | If memory not equal 0, add ring value to PC |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `If` | 如果内存值不等于 0，则将环值加到 PC |'
- en: '| `IntIO` | If ring value is 0, memory value ← integer read from `stdin`; otherwise,
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `IntIO` | 如果环值为 0，则从 `stdin` 读取整数并赋给内存值；否则， |'
- en: '|  | print memory value to `stdout` as an integer |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  | 将内存值作为整数打印到 `stdout` |'
- en: '| `AscIO` | If ring value is 0, memory value ← ASCII character read from `stdin`;
    otherwise, print memory value to `stdout` as an ASCII character |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `AscIO` | 如果环值为 0，则从 `stdin` 读取 ASCII 字符并赋给内存值；否则，将内存值作为 ASCII 字符打印到 `stdout`
    |'
- en: For the math ring, the commands are shown, again running clockwise, in [Table
    16-2](ch16.xhtml#ch016tab2).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学环，命令如下所示，同样是顺时针运行，详见 [表 16-2](ch16.xhtml#ch016tab2)。
- en: '**Table 16-2:** Whirl’s Math Ring'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-2：** Whirl 的数学环'
- en: '| **Instruction** | **Effect** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Noop` | Do nothing |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Noop` | 不做任何操作 |'
- en: '| `Load` | Ring value ← memory value |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Load` | 环值 ← 内存值 |'
- en: '| `Store` | Ring value → memory value |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Store` | 环值 → 内存值 |'
- en: '| `Add` | Ring value ← ring value + memory value |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Add` | 环值 ← 环值 + 内存值 |'
- en: '| `Mult` | Ring value ← ring value × memory value |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Mult` | 环值 ← 环值 × 内存值 |'
- en: '| `Div` | Ring value ← ring value ÷ memory value |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Div` | 环值 ← 环值 ÷ 内存值 |'
- en: '| `Zero` | Ring value ← 0 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Zero` | 环值 ← 0 |'
- en: '| `<` | Ring value ← 1 if ring value < memory value, else 0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果环值 < 内存值，则环值 ← 1，否则环值 ← 0 |'
- en: '| `>` | Ring value ← 1 if ring value > memory value, else 0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果环值 > 内存值，则环值 ← 1，否则环值 ← 0 |'
- en: '| `=` | Ring value ← 1 if ring value = memory value, else 0 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 如果环值 = 内存值，则环值 ← 1，否则环值 ← 0 |'
- en: '| `Not` | Ring value ← 0 if ring value ≠ 0, else 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Not` | 如果环值 ≠ 0，则环值 ← 0；否则，环值 ← 1 |'
- en: '| `Neg` | Ring value ← –1 × ring value |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Neg` | 环值 ← –1 × 环值 |'
- en: When the program starts, both rings are at the `Noop` position, both ring values
    are 0, and the operation ring is active. It’s the programmer’s job to track the
    current state of the program. There is no way to query ring alignment or which
    ring is active.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序开始时，两个环都处于 `Noop` 位置，两个环值都为 0，且操作环处于激活状态。程序员需要跟踪程序当前的状态。无法查询环的对齐状态或哪个环是激活的。
- en: 'The original Whirl site is gone, but it is accessible via the Wayback Machine:
    *[http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/](http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/)*.
    I’ve taken the liberty of printing this site as a PDF. See *Whirl.pdf* on the
    book’s GitHub page.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Whirl网站已经消失，但可以通过Wayback Machine访问：*[http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/](http://web.archive.org/web/20130116204525/bigzaphod.org/whirl/)*。我已冒昧将该网站打印为PDF。请参阅本书GitHub页面上的*Whirl.pdf*。
- en: 'Programming in Whirl is not for the faint of heart, but Whirl’s no Malbolge,
    either. For example, this Whirl program from the original website demonstrates
    again that 1 + 1 = 2:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Whirl中编程并非心脏脆弱者的工作，但Whirl并非Malbolge。例如，来自原始网站的这个Whirl程序再次演示了1 + 1 = 2：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that `00` causes the current command on the current ring to execute,
    but a single `0` only toggles the direction of the current ring. At all times,
    `1` rotates the current ring in the current direction without executing a command.
    These are critical ideas for Whirl programming. Use `1` to set up the proper command
    on the current ring and then use `00` to execute the command and automatically
    toggle to the other ring. Lastly, use `0` to toggle the rotation direction for
    the current ring.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`00`会导致当前环上的当前命令执行，而单个`0`只会切换当前环的方向。在任何时候，`1`都会让当前环按照当前方向旋转，但不会执行命令。这些是Whirl编程中的关键概念。使用`1`在当前环上设置正确的命令，然后使用`00`来执行命令并自动切换到另一个环。最后，使用`0`切换当前环的旋转方向。
- en: Several other examples gleaned from the original Whirl page are in the *examples*
    directory. There are additional examples in the *whirl-interpreter* directory
    as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始Whirl页面收集的其他示例位于*examples*目录中。*whirl-interpreter*目录中也有其他示例。
- en: Whirl is clever, and I strongly suspect it’s Turing complete because, in the
    end, it’s another imperative programming language, albeit one with a novel twist
    to it (pun intended). Go ahead, give Whirl a whirl.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Whirl很聪明，我强烈怀疑它是图灵完备的，因为，归根结底，它是另一种命令式编程语言，尽管它在某些方面有着新颖的变化（双关语）。去吧，试试Whirl。
- en: '***Taxi***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***出租车***'
- en: As if Whirl weren’t clever enough, Sean Heber struck again with Taxi, a programming
    language where the programmer must navigate a taxi with up to three passengers
    around Townsville while maintaining enough gas and the funds to purchase it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仿佛Whirl不够聪明一样，Sean Heber再次出击，创造了Taxi，一种编程语言，程序员必须在汤斯维尔中驾驶一辆载有最多三名乘客的出租车，同时保持足够的油量和购买油的资金。
- en: Like Whirl, the original Taxi site is gone but accessible from the Wayback Machine.
    For the URL, take a look at the *README.txt* file in the *Taxi* directory of the
    book’s GitHub repository. Taxi is marked as public domain, so I’m including it
    with the book. I also made a PDF of the archived web page (see *Taxi.pdf* ).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 和Whirl一样，原始的Taxi网站已经消失，但可以通过Wayback Machine访问。查看URL，请查阅本书GitHub仓库中*Taxi*目录下的*README.txt*文件。Taxi被标记为公共领域，因此我将其包含在书中。我还制作了一个归档网页的PDF（见*Taxi.pdf*）。
- en: '[Figure 16-3](ch16.xhtml#ch016fig3) shows Townsville (*taxi_map.png*).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-3](ch16.xhtml#ch016fig3)展示了汤斯维尔（*taxi_map.png*）。'
- en: '![Image](Images/16fig03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig03.jpg)'
- en: '*Figure 16-3: A map of Townsville*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：汤斯维尔地图*'
- en: Every location marked on the map is a possible destination, and each destination
    performs a different function. Driving the taxi requires fuel, so the programmer
    must be aware of how far the taxi has traveled and make pit stops when appropriate.
    Of course, this assumes that the taxi has collected enough in fares to cover the
    cost of the fuel. Passengers, either a number or a string, pay a flat rate of
    0.07 credits per mile, but only pay when they have reached their destination.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 地图上标记的每个位置都是一个可能的目的地，每个目的地执行不同的功能。驾驶出租车需要燃料，因此程序员必须意识到出租车已经行驶了多远，并在适当的时候进行加油站停靠。当然，这假设出租车已经收取了足够的费用来支付燃料成本。乘客，无论是数字还是字符串，都按每英里0.07个信用单位的固定费用支付，但只有在到达目的地时才会支付。
- en: Destinations implement the operations of the language. Need to add some values?
    Take your passengers to Addition Alley. Want a random integer? Pick one up at
    Heisenberg’s, but be prepared for a certain level of indecision on his part.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地实现了语言的操作。需要加值吗？把乘客带到加法巷。想要一个随机整数？去海森堡那里，但要准备好应对他可能的犹豫。
- en: Some destinations implement data structures. Want a FIFO data structure? Visit
    Joyless Park or Sunny Skies Park. Prefer LIFO? Then use Narrow Path Park. Running
    low on gas? Better get to Zoom Zoom for the cheapest gas in town. Avoid Fueler
    Up if you can. You’ll pay too much. The complete list of destinations, and associated
    operations, is in *Taxi.pdf* . Enjoy the creative names.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些目的地实现了数据结构。想要一个 FIFO 数据结构？可以访问 Joyless Park 或 Sunny Skies Park。更喜欢 LIFO？那就去
    Narrow Path Park。油快用完了？最好去 Zoom Zoom，加最便宜的油。尽量避开 Fueler Up，那里油价太贵。目的地和相关操作的完整列表在
    *Taxi.pdf* 中。享受这些富有创意的名字吧。
- en: 'Taxi code is verbose, almost plaintext, much like the HyperTalk language used
    by HyperCard, an old Macintosh programming environment from Apple. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Taxi 代码冗长，几乎像纯文本，类似于 HyperCard 使用的 HyperTalk 语言，这是苹果公司早期的一个 Macintosh 编程环境。例如：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This prints, well, you know what it prints. The program begins with the taxi
    at the Taxi Garage and ends when the taxi returns to the garage. The first line
    puts a string at the Writer’s Depot, which holds a string constant. To use the
    string, you must first get to the Writer’s Depot from the Taxi Garage. To do that,
    you need to go west, take the first left, then the second right, then the first
    left, and, lastly, the second left. Consult *taxi_map.png*, and you’ll see that
    the directions do take you from the Taxi Garage to the Writer’s Depot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出，嗯，你知道它会输出什么。程序从 Taxi Garage 开始，最后在出租车返回车库时结束。第一行将一个字符串放入 Writer’s Depot，这里存放一个字符串常量。要使用这个字符串，你必须首先从
    Taxi Garage 到达 Writer’s Depot。为此，你需要向西走，先左转，再右转，再左转，最后第二次左转。查看 *taxi_map.png*，你会看到这些路线确实能从
    Taxi Garage 到达 Writer’s Depot。
- en: The following line, `Pickup a passenger going to the Post Office`, gets the
    string with the intended destination. So use directions from the current location
    to get to the Post Office. The Post Office prints passengers to `stdout` (standard
    output). Pick up a passenger at the Post Office to get input from the user. To
    end the program, return to the Taxi Garage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的这一行，`Pickup a passenger going to the Post Office`，获取了预定目的地的字符串。所以使用从当前位置到达邮局的路线。邮局会将乘客打印到
    `stdout`（标准输出）。从邮局接乘客以获得用户的输入。要结束程序，回到 Taxi Garage。
- en: 'What if you don’t return to the garage? The program ends poorly: `The` `boss
    couldn''t find your taxi in the garage. You''re fired!` So return to the garage,
    or else!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有返回车库怎么办？程序会以一种糟糕的方式结束：`老板找不到你的出租车在车库里。你被解雇了！` 所以一定要回到车库，否则后果自负！
- en: Flow control makes use of labels enclosed in square brackets and the `Switch`
    statement with references to the labels in quotation marks. For example, the line
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制使用方括号括起来的标签和带有引用标签的 `Switch` 语句。例如，下面这行
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: is an unconditional branch to `[loop]`, while
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个无条件跳转到 `[loop]`，而
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: is a conditional branch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个条件分支。
- en: The C++ source code for Taxi is in *taxi.cpp*. I recommend commenting out the
    startup and exit messages at lines 472, 1267, and 1268\. Or not; it’s a matter
    of personal preference.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Taxi 的 C++ 源代码在 *taxi.cpp* 中。我建议注释掉第 472、1267 和 1268 行的启动和退出消息。或者也可以不注释，这完全是个人偏好。
- en: To use Taxi, first build it with
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Taxi 时，首先用下面的命令构建它
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and then run it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行它：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that Taxi supports floating-point numbers. Be sure not to miss Nick Turner’s
    RPN calculator in *rpn.taxi*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Taxi 支持浮动小数点数。一定不要错过 Nick Turner 的 RPN 计算器，位于 *rpn.taxi* 中。
- en: 'Taxi is an excellent example of the esolang community’s unbounded creativity.
    It’s possible to imagine using Taxi, or something built from it, to introduce
    programming concepts. Of interest at a higher level is the fact that operations
    in Taxi come with a price: literally. Programmers are accustomed to operations
    having no intrinsic cost other than memory and time. In Taxi, the number of operations,
    and their relative relationship to each other, introduce another cost on top of
    the usual memory and time.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Taxi 是计算语言社区无限创造力的一个优秀例子。可以想象，使用 Taxi 或基于它构建的东西来介绍编程概念。从更高层次看，Taxi 中的操作是有代价的：字面意义上。程序员习惯于操作除了内存和时间外没有固有的成本。而在
    Taxi 中，操作的数量以及它们之间的相对关系，给传统的内存和时间之外引入了额外的成本。
- en: Development on Taxi has stalled, but the source code is in the public domain.
    Perhaps someone will pick it up, refine it, and introduce it again in another
    form. If targeting younger programmers, I suggest leaving out the travel cost
    aspect. What about a new metaphor? Perhaps an airplane flying from city to city,
    or a starship warping from star system to star system?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Taxi 的开发已陷入停滞，但源代码是公开的。也许有人会接手，完善它，并以另一种形式重新推出。如果面向年轻程序员，我建议省略掉旅行费用这一部分。那新比喻如何？或许可以是飞机从城市到城市，或者是星际飞船在星系之间跳跃？
- en: '***Dathanna***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Dathanna***'
- en: The original Apple II+ computer from 1979 contained an 8-bit 6502 microprocessor
    running in a system with a 1 MHz clock, half of which was used to refresh RAM.
    By modern standards, the Apple II+ crawled along at continental drift speeds.
    However, modern computers are capable of emulating an Apple II+ at something approaching
    100 times its native speed (84 times on my test system). This fact opens up new
    possibilities for programs written for the Apple II that would be far too slow
    on a native system but are entirely usable on an emulator running at full speed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 1979 年的原版 Apple II+ 计算机内置了一颗 8 位 6502 微处理器，运行在一个 1 MHz 时钟的系统中，其中一半用于刷新 RAM。按现代标准，Apple
    II+ 的速度简直是大陆漂移的速度。然而，现代计算机能够以接近原生速度的 100 倍来模拟 Apple II+（在我的测试系统上是 84 倍）。这一事实为针对
    Apple II 编写的程序打开了新的可能性，这些程序在原生系统上会太慢，但在全速运行的模拟器上却完全可用。
- en: Dathanna, Irish for “colors,” is just such a program. Dathanna is an esolang
    using colored blocks, two stacked one on top of the other, to specify commands.
    It echoes both Befunge-93 and Piet in how it operates. However, the most important
    part of Dathanna is that its interpreter is written in Applesoft BASIC and it
    runs off a disk image meant for Apple II emulators.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Dathanna，爱尔兰语中为“颜色”，就是这样的一个程序。Dathanna 是一种使用彩色块的诞生语言，这些块一个叠在另一个上面，用以指定命令。它的运作方式既像
    Befunge-93，也像 Piet。然而，Dathanna 最重要的部分是其解释器是用 Applesoft BASIC 编写的，并且它在一个为 Apple
    II 模拟器设计的磁盘镜像上运行。
- en: 'You’ll find Dathanna, along with all necessary files and documentation, on
    the book’s GitHub site. All I’ll present here is a bit of source code to whet
    your appetite: a program to estimate *π* using random numbers, much like we did
    earlier in the book with ABC. See [Figure 16-4](ch16.xhtml#ch016fig4), which should
    really be in color. Review the documentation to learn how it works.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 网站上找到 Dathanna 及所有必要的文件和文档。我在这里展示的仅是一小段源代码，激起你对它的兴趣：一个用随机数估算
    *π* 的程序，就像我们在本书早些时候用 ABC 做的一样。见[图 16-4](ch16.xhtml#ch016fig4)，它本应是彩色的。请查看文档，了解它是如何工作的。
- en: '![Image](Images/16fig04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/16fig04.jpg)'
- en: '*Figure 16-4: Dathanna code to estimate *π* with random numbers*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-4：使用随机数估算 *π* 的 Dathanna 代码*'
- en: '**Programming Language Resources**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程语言资源**'
- en: What follows is a prosaic but helpful list of resources to increase your knowledge
    of programming languages. I selected freely available material presented by the
    original authors when possible. Naturally, some of these URLs will fail over time,
    but the internet remembers, for good or ill. If a particular link no longer works,
    searching for the title will likely locate the resource once more.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个平实但有用的资源列表，帮助你增加对编程语言的了解。我尽量选择原作者提供的免费公开材料。自然，随着时间的推移，部分链接可能会失效，但互联网记得它们，无论好坏。如果某个链接不再有效，搜索标题很可能会再次找到该资源。
- en: Programming languages tend to evolve slowly. If a few of the resources here
    are a decade or more old, that’s okay. The burning need to stay current is less
    critical in this case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言通常演变缓慢。如果这里的一些资源已经有十年以上的历史，那也没关系。保持最新的需求在这种情况下并不是那么关键。
- en: The following sections divide the resources into three groups. The first is
    a catch-all on programming languages in general. These resources are similar to
    what you typically encounter in an undergraduate course on programming languages.
    The second section covers data structures, which we unfairly neglected in [Chapter
    2](ch02.xhtml#ch02). The third section relates to compilers and interpreters—the
    methods for actualizing a programming language.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将资源分为三组。第一组是关于编程语言的一般资源。这些资源类似于你在本科编程语言课程中通常会遇到的内容。第二部分涵盖数据结构，这是我们在[第二章](ch02.xhtml#ch02)中不公平忽视的内容。第三部分与编译器和解释器相关——这些是实现编程语言的方法。
- en: The links are presented as title and URL with minimal comment. I reviewed all
    the material and found it helpful, though there are definite limits to what you
    can learn simply by reading. At some point, you have to go further and build something.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些链接以标题和网址的形式呈现，并附有简短的评论。我审阅了所有材料，认为它们很有帮助，尽管仅通过阅读学习是有一定局限性的。在某个时刻，你必须进一步深入并实际构建一些东西。
- en: '***Programming Languages***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编程语言***'
- en: The material here covers programming languages at an undergraduate level. As
    you read through it, recall the esolangs and other languages we discussed in the
    book to build connections with the more general concepts.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的材料涵盖了本科水平的编程语言。当你阅读它时，回想一下我们在书中讨论的esolangs和其他语言，将它们与更一般的概念建立联系。
- en: '**Concepts of Programming Languages: A Unified Approach**  by Karl Abrahamson.
    The first five parts of this book introduce programming language concepts. The
    later portions of the book dive into functional programming, though there is a
    chapter on Scheme, which we used in [Chapter 8](ch08.xhtml#ch08) to implement
    FRACTRAN. (*[http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf](http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf)*)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言的概念：统一方法**  由卡尔·亚伯拉罕森（Karl Abrahamson）著。书中的前五个部分介绍了编程语言的概念。书的后半部分深入探讨了函数式编程，尽管有一章讨论了我们在[第8章](ch08.xhtml#ch08)中用来实现FRACTRAN的Scheme语言。(*[http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf](http://www.cs.ecu.edu/~karl/3675/fall11/book.pdf)*)'
- en: '**Advanced Programming Language Design**  by Raphael Finkel. I read this book
    in the late 1990s and found it very helpful. Recommended. (*[https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf](https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf)*)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级编程语言设计**  由拉斐尔·芬克尔（Raphael Finkel）著。我在1990年代末阅读了这本书，发现它非常有帮助。推荐。(*[https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf](https://www.cs.uky.edu/~raphael/courses/CS655/Advanced_programming_language_design.pdf)*)'
- en: '**Programming Languages and Techniques**  by Steve Zdancewic and Stephanie
    Weirich. Use this as a reference and as a review of techniques associated with
    programming languages. However, the use of OCaml, a functional language, might
    make direct translation of techniques to other languages a bit more difficult.
    (*[https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf](https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf)*)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言与技术**  由史蒂夫·兹丹切维奇（Steve Zdancewic）和斯蒂芬妮·韦里奇（Stephanie Weirich）著。将这本书作为参考书，并回顾与编程语言相关的技术。然而，OCaml（一种函数式语言）的使用可能会使得技术直接迁移到其他语言时变得有些困难。(*[https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf](https://www.seas.upenn.edu/~cis120/archive/20sp/notes/120notes.pdf)*)'
- en: '**Programming Languages: Application and Interpretation**  by Shriram Krishnamurthi.
    These notes are an alternative introduction to the elements of programming languages
    using Typed PLAI, a language supported by Racket. Use it in conjunction with the
    references above. (*[http://cs.brown.edu/courses/cs173/2012/book/book.pdf](http://cs.brown.edu/courses/cs173/2012/book/book.pdf)*)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言：应用与解释**  由施里拉姆·克里希纳穆尔蒂（Shriram Krishnamurthi）著。这些笔记是使用类型化PLAI（Racket支持的一种语言）对编程语言元素的另一种介绍。将其与上面的参考书结合使用。(*[http://cs.brown.edu/courses/cs173/2012/book/book.pdf](http://cs.brown.edu/courses/cs173/2012/book/book.pdf)*)'
- en: '**Practical Foundations for Programming Languages**  by Robert Harper. This
    book, at nearly 600 pages, dives into the mathematics of programming and is more
    theoretical than the references above. (*[https://thelackthereof.org/docs/library/book.pdf](https://thelackthereof.org/docs/library/book.pdf)*)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言的实用基础**  由罗伯特·哈珀（Robert Harper）著。这本书有近600页，深入探讨了编程的数学原理，比上述参考书更加理论化。(*[https://thelackthereof.org/docs/library/book.pdf](https://thelackthereof.org/docs/library/book.pdf)*)'
- en: '**Models of Computation**  by John E. Savage. This is not a programming language
    book, but rather an in-depth, highly theoretical exploration of computation, or,
    as the subtitle says, “exploring the power of computing.” Our discussion of Turing
    machines in [Chapter 3](ch03.xhtml#ch03) serves as a (simple) introduction to
    this material. (*[http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf](http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf)*)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算模型**  由约翰·E·萨维奇（John E. Savage）著。这不是一本关于编程语言的书，而是一本深入且高度理论化的计算探索，或者正如副标题所说，“探索计算的力量”。我们在[第3章](ch03.xhtml#ch03)中对图灵机的讨论，作为对这本书内容的（简单）介绍。(*[http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf](http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf)*)'
- en: '***Data Structures***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据结构***'
- en: Data structures are tools used by programming languages to store and manipulate
    information. The form the structures take is a function of the elements provided
    by the programming language. The level of difficulty in implementing a particular
    data structure depends on the language used. Implementing a dictionary in Python
    is trivial because it’s part of the core language. Implementing a stack in Forth
    is trivial for the same reason. Pascal and C/C++ both provide syntactic support
    for records and structures. However, doing the same in Forth, at least in simple
    Forth systems, requires rolling your own data structures and directly managing
    a space of memory, often at the byte level.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是编程语言用来存储和操作信息的工具。结构的形式是编程语言提供的元素的函数。实现特定数据结构的难易程度取决于所使用的语言。在 Python 中实现字典很简单，因为它是核心语言的一部分。在
    Forth 中实现栈也很简单，原因相同。Pascal 和 C/C++ 都提供了对记录和结构的语法支持。然而，在 Forth 中实现相同功能，至少在简单的 Forth
    系统中，要求自己设计数据结构并直接管理内存空间，通常是在字节级别上操作。
- en: '**A First Course on Data Structures in Python**  by Donald R. Sheehy. A basic
    introduction to data structures using Python. I suggest starting with [Chapter
    5](ch05.xhtml#ch05), if not [Chapter 6](ch06.xhtml#ch06). (*[https://donsheehy.github.io/datastructures/fullbook.pdf](https://donsheehy.github.io/datastructures/fullbook.pdf)*)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 数据结构入门课程**  由 Donald R. Sheehy 编写。这是一本使用 Python 介绍数据结构的基础书籍。我建议从 [第
    5 章](ch05.xhtml#ch05)开始，如果不行，就从 [第 6 章](ch06.xhtml#ch06)开始。 (*[https://donsheehy.github.io/datastructures/fullbook.pdf](https://donsheehy.github.io/datastructures/fullbook.pdf)*)'
- en: '**Data Structures and Algorithms**  by John Bullinaria. This reference is a
    succinct introduction with pseudocode algorithms and examples in C and Java. If
    the book above is too much, begin with this one. (*[https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf](https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf)*)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构与算法**  由 John Bullinaria 编写。这本参考书简洁地介绍了伪代码算法，并提供了 C 和 Java 的示例。如果上面的书籍太复杂，可以从这本书开始。
    (*[https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf](https://www.cs.bham.ac.uk/~jxb/DSA/dsa.pdf)*)'
- en: '**Data Structures and Algorithm Analysis**  by Clifford A. Shaffer. This book
    covers much the same material as the ones above, in Java, but includes analysis
    of algorithm performance and, in the final chapter, a discussion on the limits
    of computation. (*[https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf](https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf)*)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构与算法分析**  由 Clifford A. Shaffer 编写。本书涵盖了与上述书籍相同的内容，只不过使用的是 Java，并且包括了算法性能分析，并在最后一章讨论了计算的极限。
    (*[https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf](https://people.cs.vt.edu/shaffer/Book/Java3e20120102.pdf)*)'
- en: '***Compilers and Interpreters***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译器与解释器***'
- en: A programming language remains nothing more than a mental construct until an
    implementation actualizes it. Classically, implementation meant a compiler, as
    computers were generally too slow to make interpreted programming languages anything
    more than curiosities. Of course, this is no longer the case, and even simple
    interpreters are quite fast on modern hardware, to say nothing of the hybrid case
    of compiling a high-level language to code running on a virtual machine.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言实现之前，它仅仅是一个心理构想。传统上，实现意味着编译器，因为当时计算机的速度通常太慢，使得解释型编程语言不过是一些奇特的存在。当然，现在情况已经不同，即便是简单的解释器在现代硬件上也非常快速，更不用说将高级语言编译成虚拟机上运行的代码的混合方式了。
- en: In this section, you’ll find introductory material to help you learn about the
    process of building a compiler or interpreter. The latter is more straightforward,
    of course, but the former is definitely worth the effort, at least to understand
    the parts we discussed in [Chapter 2](ch02.xhtml#ch02) at a deeper level.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将找到帮助您了解构建编译器或解释器过程的入门材料。当然，解释器更为直接，但构建编译器绝对值得努力，至少可以帮助您更深入地理解我们在 [第 2
    章](ch02.xhtml#ch02)中讨论的部分。
- en: '**Crafting Interpreters**  by Robert Nystrom. This website features an online
    book about crafting interpreters. Worth a look. (*[https://craftinginterpreters.com](https://craftinginterpreters.com)*)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**打造解释器**  由 Robert Nystrom 编写。这个网站提供了一本关于打造解释器的在线书籍，值得一看。 (*[https://craftinginterpreters.com](https://craftinginterpreters.com)*)'
- en: '**Implementing Programming Languages**  by Aarne Ranta. Use this book as an
    introduction. It appears to be incomplete and, given the 2012 date, will likely
    remain so. However, the early chapters are complete and helpful. (*[https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf](https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf)*)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言的实现** 由Aarne Ranta编写。将这本书作为入门书籍使用。它似乎是不完整的，而且鉴于2012年的出版日期，可能会一直保持如此。然而，前几章是完整的，并且非常有帮助。
    (*[https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf](https://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf)*)'
- en: '**Basics of Compiler Design**  by Torben Ægidius Mogensen. This book introduces
    compiler design in much the same vein as the famous Dragon Book referenced in
    [Chapter 2](ch02.xhtml#ch02). The treatment is mathematical, so you’ll need to
    know how to read set notation, for instance, but the level isn’t that required
    of a graduate course. (*[http://hjemmesider.diku.dk/~torbenm/](http://hjemmesider.diku.dk/~torbenm/)*)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器设计基础** 由Torben Ægidius Mogensen编写。这本书介绍了编译器设计，其方式与著名的《龙书》相似，后者在[第2章](ch02.xhtml#ch02)中有提及。处理是数学化的，所以你需要知道如何阅读集合符号，但这个层次不要求像研究生课程那样复杂。
    (*[http://hjemmesider.diku.dk/~torbenm/](http://hjemmesider.diku.dk/~torbenm/)*)'
- en: '**An Introduction to Compilers**  by D. Vermeir. Use this book as another reference
    to the main topics of compiler design. The example code is written in C. (*[http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf](http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf)*)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器简介** 由D. Vermeir编写。将这本书作为编译器设计主题的另一本参考书。示例代码是用C语言编写的。 (*[http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf](http://tinf2.vub.ac.be/~dvermeir/courses/compilers/compilers.pdf)*)'
- en: '**Introduction to Compilers and Language Design**  by Douglas Thain. This book
    serves as an alternative introduction to *Basics of Compiler Design* mentioned
    above. Take a look. (*[https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf](https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf)*)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器与语言设计简介** 由Douglas Thain编写。这本书是**编译器设计基础**的替代性入门书籍。请看一下。 (*[https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf](https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf)*)'
- en: '**Compiler Construction Using Flex and Bison**  by Anthony A. Aaby. Flex and
    Bison are classic compiler generation tools. While there are more current tools,
    this text includes the full source code for the Simple language. Use it as a case
    study in compiler design. (*[http://www.admb-project.org/tools/flex/compiler.pdf](http://www.admb-project.org/tools/flex/compiler.pdf)*)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Flex和Bison构建编译器** 由Anthony A. Aaby编写。Flex和Bison是经典的编译器生成工具。虽然现在有更多的现代工具，但这本书包含了Simple语言的完整源代码。将其作为编译器设计的案例研究。
    (*[http://www.admb-project.org/tools/flex/compiler.pdf](http://www.admb-project.org/tools/flex/compiler.pdf)*)'
- en: '**Programming Languages and Their Compilers**  by John Cocke and J. T. Schwartz.
    This historical text, from 1970, details compilers as they existed then. Languages
    discussed include FORTRAN, LISP, and, a favorite of this book, SNOBOL. (*[http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf](http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf)*)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程语言及其编译器** 由John Cocke和J. T. Schwartz编写。这本历史性的文本，发表于1970年，详细介绍了当时的编译器。讨论的语言包括FORTRAN、LISP以及这本书非常喜欢的SNOBOL。
    (*[http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf](http://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf)*)'
- en: '**Postlude**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**后记**'
- en: You are still here at the end of the book and I thank you. I hope you had fun
    and learned things you didn’t know before. And I hope you’re excited about programming
    languages, especially the strange, weird, unusual, and esoteric kind.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经读到了本书的结尾，非常感谢。我希望你玩得开心，并学到了之前不知道的东西。也希望你对编程语言，尤其是那些奇怪、古怪、不寻常和深奥的语言感到兴奋。
- en: I encourage you to develop your own programming language, even if you never
    implement it. There is something deeply satisfying about creating a new way to
    express thought. I suspect that for every implemented esolang, there are many
    more existing only as plans, notes, or vague notions. If you do nothing more than
    write it out on paper, and have fun doing it, then the language is worthwhile
    solely for the enjoyment its design brought.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你开发自己的编程语言，即使你永远不实现它。创造一种全新的表达思维方式是非常令人满足的。我怀疑，每一种实现过的**另类语言**背后，可能有更多仅以计划、笔记或模糊概念存在的语言。如果你仅仅是把它写在纸上，并且享受这个过程，那么这个语言仅仅为了它的设计带来的乐趣，就是值得的。
- en: However, if you *do* implement it, let me know. I’d love to write some code
    for it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你*确实*实现了它，告诉我一声。我很乐意为它编写一些代码。
- en: '*Quando omni flunkus moritati.*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*Quando omni flunkus moritati.*'
