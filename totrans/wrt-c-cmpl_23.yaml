- en: '![](../images/pg612.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-63.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REGISTER
    ALLOCATION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Up until now, you’ve allocated space for every pseudoregister on the stack.
    This strategy is simple but painfully inefficient. Because instructions can’t
    always operate on values in memory directly, you sometimes need to generate extra
    instructions to copy values between these stack locations and registers. Even
    worse, the assembly code you generate has to access memory constantly, even though
    registers are faster. Now you’ll solve those problems. You’ll finish up your compiler
    by adding a *register allocation* pass, bolded in the diagram at the start of
    the chapter, to assign pseudoregisters to hard registers instead of locations
    in memory. You’ll use graph coloring, a classic register allocation technique,
    to come up with this assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the initial version of the register allocator is up and running, you’ll
    give it one more job: to clean up some of the unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions produced during assembly generation. The final version of your allocator
    will perform *register coalescing* before assigning pseudoregisters to hard registers.
    The register coalescing step will look for <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions whose source and destination can be merged, or coalesced, into a
    single operand, which allows you to delete the instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register allocation has a little bit of everything: high-level theory, low-level
    details, brand-new concepts, and familiar techniques from earlier chapters. And
    the payoff is very satisfying: at the end of the chapter, you’ll be generating
    dramatically more efficient code. I think it’s a good note to end the book on.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let’s look at an example that illustrates why register allocation
    is such a powerful optimization.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Allocation in Action</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the tiny C function in [Listing 20-1](chapter20.xhtml#list20-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-1: A tiny C function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, our compiler will turn this into the tiny TACKY function in [Listing
    20-2](chapter20.xhtml#list20-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-2: The TACKY code
    for [Listing 20-1](chapter20.xhtml#list20-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This listing gives the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    after the optimization stage. (In particular, we’ve optimized out the extra <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp> that we add to the end
    of each TACKY function as a backstop for missing <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert [Listing 20-2](chapter20.xhtml#list20-2) to the assembly
    code in [Listing 20-3](chapter20.xhtml#list20-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-3: The assembly
    code for [Listing 20-2](chapter20.xhtml#list20-2)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We set up the function’s parameters ❶, then we calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    ❷. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    ❸. The operands <samp class="SANS_TheSansMonoCd_W5Regular_11">%x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2</samp>
    in this listing refer to the corresponding pseudoregisters; I’ll use this notation
    throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll walk through three approaches to replacing these pseudoregisters
    with real operands. First, we’ll replace them with stack addresses, which is what
    our compiler does right now. On our next attempt, we’ll replace them with hard
    registers, without performing register coalescing first; this is what the initial
    version of our register allocator will do. The third time around, we’ll perform
    register coalescing before replacing the pseudoregisters with hard registers.
    That’s how our finished allocator will handle this program. (A quick note on terminology:
    throughout this chapter, I’ll use the word *register* to refer to pseudoregisters
    and hard registers collectively.)'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take One: Put Everything
    on the Stack</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In its current form, our compiler will replace each pseudoregister with a stack
    slot according to [Table 20-1](chapter20.xhtml#tab20-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-1:</samp> <samp class="SANS_Futura_Std_Book_11">Replacing
    Pseudoregisters with Stack Addresses</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Real
    location</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-20(%rbp)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: This will give us the assembly code in [Listing 20-4](chapter20.xhtml#list20-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-4: [Listing 20-3](chapter20.xhtml#list20-3)
    after replacing pseudoregisters with stack addresses</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once we replace every pseudoregister with a memory address, instructions ❶,
    ❷, ❸, and ❹ are invalid, so the instruction fix-up pass will need to repair them.
    It will insert an extra instruction before ❶ to load its destination into a hard
    register, and it will add another to store the result back to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>
    afterward. It will also insert instructions to load the source operands of ❷,
    ❸, and ❹ into hard registers. In the context of register allocation, we say a
    pseudoregister is *spilled* to memory if we store its contents on the stack instead
    of in a hard register. The extra instructions we insert to move spilled values
    between registers and memory are called *spill code*.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll ultimately end up with the assembly code in [Listing 20-5](chapter20.xhtml#list20-5).
    I’ve bolded the spill code to make it easier to spot. (I’ve also snipped out the
    instructions to set up and tear down the stack frame, which aren’t relevant here.
    These are snipped out of assembly programs later in the chapter too.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-5: [Listing 20-4](chapter20.xhtml#list20-4)
    with spill code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code is incredibly inefficient. Almost every instruction accesses memory,
    and we waste a huge amount of time copying data from one place to another. To
    take one particularly egregious example, we store the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>,
    then immediately copy it into <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>—which
    takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions—and
    never use <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp> again.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Two: Register
    Allocation</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s try a more reasonable strategy. This time, we’ll replace each pseudoregister
    with a hard register instead of a stack address, as shown in [Table 20-2](chapter20.xhtml#tab20-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-2:</samp> <samp class="SANS_Futura_Std_Book_11">Replacing
    Pseudoregisters with Hard Registers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Real
    location</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ecx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> with registers that
    don’t appear at all in the original assembly program. We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    with EDI, which *is* used in the original program. This is fine, since we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> only once we’re done
    using EDI for anything else. Later in the chapter, we’ll see how to reason more
    systematically about which mappings from pseudoregisters to hard registers are
    safe and which ones might cause conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no spill code this time, so I won’t include separate listings from before
    and after the instruction fix-up pass. Instead, we’ll skip right to the final
    assembly code, shown in [Listing 20-6](chapter20.xhtml#list20-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-6: The final assembly
    code for [Listing 20-3](chapter20.xhtml#list20-3) after register allocation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a major improvement; we don’t access memory, and we have fewer instructions
    overall. If we wanted to, we could even omit the instructions to set up and tear
    down the stack frame, since we never use the stack. But we’re still moving data
    around more than we need to. For instance, we copy our function parameters from
    EDI and ESI to new locations, instead of leaving them where they are. We also
    copy <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>),
    when we could just as easily use <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    for two calculations in a row. This isn’t the register allocator’s fault; it’s
    just that we generated inefficient TACKY and assembly code in earlier passes.
    But if we’re thoughtful about how we allocate registers, we can clean up after
    those earlier passes. That’s why our register allocator will include one more
    step: register coalescing.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Three:
    Register Allocation with Coalescing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last approach has two steps. First, we’ll coalesce registers: we’ll look
    at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in
    the function and decide whether its operands can be merged together. Then, we’ll
    replace any remaining pseudoregisters with hard registers, like we did in our
    previous attempt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the original assembly program from [Listing 20-3](chapter20.xhtml#list20-3).
    This program includes four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions whose source and destination are both registers, which are bolded
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, copying values from one register to another is genuinely necessary.
    For example, we might need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    out of EDI if we were going to pass another function argument in EDI later. But
    in this case, it’s safe to merge <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into EDI, since we don’t need EDI for anything else after that first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. The same logic applies to each of the other three <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions. We won’t need to store different values in the source and destination
    operands at the same time, so it’s safe to merge them together. We’ll merge <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into EDI, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    into ESI, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EAX.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 20-3](chapter20.xhtml#tab20-3) summarizes which pairs of registers we’ll
    coalesce and shows which member of each pair will remain in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-3:</samp> <samp class="SANS_Futura_Std_Book_11">Coalescing
    Registers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Coalesced pair</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remaining
    register</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi, %x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi, %y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0, %tmp1</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> |'
  prefs: []
  type: TYPE_TB
- en: We’ll also delete all four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions, since they no longer serve any purpose. [Listing 20-7](chapter20.xhtml#list20-7)
    gives the resulting assembly code, with the updated operands bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-7: [Listing 20-3](chapter20.xhtml#list20-3)
    after register coalescing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This looks a lot more reasonable! We leave <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in EDI and ESI, where
    they were passed to begin with, instead of copying them to new locations. When
    we calculate the return value, we store the result in EAX right away, instead
    of copying it into EAX after we’ve calculated it. And we no longer use two separate
    temporary registers to calculate the intermediate and final results in <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>;
    we stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> the whole
    time.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not quite done; we still need to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    with a hard register. Any register besides ESI, EDI, or EAX will do—let’s go with
    ECX. [Listing 20-8](chapter20.xhtml#list20-8) shows the assembly code we’ll ultimately
    wind up with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-8: The final assembly
    code for [Listing 20-3](chapter20.xhtml#list20-3) after register allocation with
    coalescing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register allocation without coalescing improved our code in two ways: it reduced
    the number of memory accesses and the amount of spill code in our program. With
    register coalescing, we improve our code even further by removing the many unnecessary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions generated
    by earlier passes.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a sense of what we want to accomplish, let’s look at how register
    allocation fits into the whole compiler pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Updating the Compiler Pipeline</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Register allocators work best when there are lots of hard registers available,
    so the very first thing we’ll do is add every remaining hard register to the assembly
    AST, including the callee-saved registers that we’ve avoided so far. We’ll also
    make one small change to the conversion from TACKY to assembly: during this pass,
    we’ll store extra information in the backend symbol table about which hard registers
    each function uses to pass parameters and return values.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll implement the register allocator itself. The register allocator
    will run just after we convert the program from TACKY to assembly, before any
    of the other backend compiler passes. Much like the optimizations we implemented
    in [Chapter 19](chapter19.xhtml), this pass will process each assembly function
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Even after register allocation, there may still be some pseudoregisters left
    in the program. This could happen for a couple of reasons. First, if a function
    uses lots of pseudoregisters at once, there might not be enough hard registers
    to accommodate all of them. When that happens, we’ll have to spill some pseudoregisters
    to memory. Our register allocator won’t replace spilled pseudoregisters; it will
    just leave them in the program for the next pass to deal with. Second, some pseudoregisters
    represent variables with static storage duration. These must live in memory instead
    of registers. If you completed [Part II](part2.xhtml), you’ll encounter a few
    other objects that must live in memory, including aliased variables, structures,
    and arrays. The register allocator won’t touch these either.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with all these stragglers, we’ll run our old pseudo-operand replacement
    pass immediately after the register allocator. We won’t make any changes to this
    pass. It will handle any pseudo-operands it finds exactly the same way it did
    before; it will just find a lot fewer of them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update the instruction fix-up pass to take care of saving and restoring
    callee-saved registers. All our existing rewrite rules—including the rules to
    generate spill code—will stay the same. Since we still replace some pseudoregisters
    with locations in memory, we’ll still have to generate spill code some of the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll extend the code emission stage to support the new hard registers
    we introduce in this chapter. You might want to stub out the new register allocation
    stage at this point. Then, we’ll update the assembly AST one last time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Extending the Assembly AST</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, the assembly AST has included only the registers that we used for a
    particular purpose, such as passing parameters or rewriting instructions. It doesn’t
    include any of the callee-saved registers: RBX, R12, R13, R14, and R15\. Now we’ll
    add these five registers so the register allocator can use them. We’ll also add
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction, which
    we’ll use to restore callee-saved registers at the end of a function. If you completed
    [Part II](part2.xhtml), you should also add the remaining XMM registers, XMM8
    through XMM13\. These registers are not callee-saved.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 20-9](chapter20.xhtml#list20-9) shows the complete assembly AST that
    includes everything we covered in [Parts I](part1.xhtml), [II](part2.xhtml), and
    [III](part3.xhtml), with this chapter’s additions bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-9: The complete
    assembly AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pop</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction and additional registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> accepts only
    registers, not other operands. Now that we’ve updated the AST, let’s move on to
    the conversion from TACKY to assembly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Converting TACKY to Assembly</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll make just one change to this pass. We aren’t changing what assembly we
    generate; we’re just recording extra information in the backend symbol table.
    Specifically, we’ll record which registers are used to pass each function’s parameters.
    As you’ll see in the next section, the register allocator needs this information
    to figure out which hard registers and pseudoregisters conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have the following function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s
    parameters are passed in the first two parameter passing registers, RDI and RSI.
    We’ll track this information even if <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    is defined in a different translation unit, because we’ll need it to allocate
    registers in functions that call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If you completed [Part II](part2.xhtml), you should also track which registers
    are used to pass each function’s return value. Given the function declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: we’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s
    parameters are passed in RDI and XMM0 and that its return value is also passed
    in XMM0\. To figure out which registers a function uses to pass parameters and
    return values, we’ll use the same logic we implemented in the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    helper functions in [Chapter 18](chapter18.xhtml). Note that we might run into
    function declarations with incomplete return types or parameter types. It doesn’t
    matter what information we record about these functions, since it would be illegal
    to either define or call them in the current translation unit; we just need to
    handle them without crashing. It’s easiest to simply record that they don’t pass
    any values in registers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll build the register allocator itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Allocation by Graph Coloring</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our compiler will model register allocation as a *graph coloring* problem. Coloring
    a graph means assigning every node a label (traditionally called a “color”) so
    that each node has a different color from all its neighbors. A graph is *k-colorable*
    if you can color it with *k* or fewer colors. [Figure 20-1](#fig20-1) illustrates
    a 3-colored graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: A 3-colored graph
    [Description](description-64.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Graph coloring is an important area of research in its own right; mathematicians
    have been investigating how to color graphs since the 19th century! It’s relevant
    to register allocation because it captures two fundamental constraints on how
    we can assign pseudoregisters to hard registers: we have a limited number of hard
    registers to work with, and some registers will *interfere* with each other, meaning
    they can’t occupy the same physical location. If two pseudoregisters interfere,
    we need to assign them to two different hard registers. A pseudoregister might
    also interfere with a hard register, which means we can’t assign it to that hard
    register.'
  prefs: []
  type: TYPE_NORMAL
- en: Graph coloring lets us express both kinds of interference and handle them in
    a uniform way. To turn register allocation into a graph coloring problem, we’ll
    first build a *register interference graph* with nodes representing pseudoregisters
    and hard registers and with edges between any registers that interfere. Then,
    we’ll color the graph, using one color per hard register. Finally, we’ll assign
    each pseudoregister to a hard register according to its color. Because each register
    gets a different color from all of its neighbors, we’ll never assign two pseudoregisters
    that interfere to the same hard register or assign a pseudoregister to a hard
    register that it interferes with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out this technique on the assembly function in [Listing 20-10](chapter20.xhtml#list20-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-10: A small assembly
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes two parameters, which it copies into the pseudoregisters
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    It calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b - b</samp> and
    stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>.
    Finally, it returns the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    in EAX. We need to figure out which registers in this function interfere so we
    can build the interference graph. To start off, it’s easy to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interfere. If we map
    them to the same hard register, we’ll clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> ❷. This
    is a problem because <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is
    still live at this point. You learned in [Chapter 19](chapter19.xhtml) that a
    variable is live if its current value might be used later in the program, and
    otherwise it’s dead. This definition applies to registers too. When a register
    is live, we need to preserve its value, so we can’t store a different value in
    the same location. When it’s dead, we’re free to overwrite its value with something
    else. This gives us an easy rule for detecting interference: two registers interfere
    if we update one while the other is live.'
  prefs: []
  type: TYPE_NORMAL
- en: This rule also tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is live when we define
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> ❹. But <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> don’t interfere;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is already dead by the
    time we define <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, so it’s
    fine to map them to the same hard register.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s think through which hard registers interfere with pseudoregisters.
    ESI interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> because
    ESI is live when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    ❶. If we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to ESI,
    we’d clobber the function’s second parameter before we had a chance to copy it
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. EAX interferes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> because <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is live when we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to
    EAX to prepare for division. The last source of interference is less obvious.
    Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction
    sign extends the value from EAX into EDX ❸. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    implicitly updates EDX while <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is live, it makes EDX interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>;
    if we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to EDX, this
    instruction would clobber it. (Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction updates EAX and EDX implicitly, so it would make both of these registers
    interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> if they
    didn’t already.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the hard registers all interfere with each other. This is sort of tautological;
    they can’t occupy the same physical location because they represent different
    physical locations to begin with. Still, we need to capture this in the interference
    graph to make sure that each hard register gets its own color.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve figured out which registers interfere, we’ll construct the graph.
    To keep this graph relatively small and readable, we’ll pretend that the only
    hard registers are EDI, ESI, EAX, and EDX. Our real register interference graphs
    will include every hard register we can assign pseudoregisters to, even if the
    assembly program doesn’t use them. However, they’ll exclude RSP, RBP, and the
    scratch registers that we use during instruction fix-up.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-2](#fig20-2) illustrates the interference graph for the function
    in [Listing 20-10](chapter20.xhtml#list20-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: The register interference
    graph for divide_and_subtract [Description](description-65.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This graph encodes all the interferences we just identified: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    interferes with ESI and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    EAX, and EDX as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    and all four hard registers interfere with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll try to *k*-color this graph, where *k* is the number of hard registers
    in the graph. In this small example, *k* is 4\. There are several possible 4-colorings
    of [Figure 20-2](#fig20-2). [Figure 20-3](#fig20-3) shows a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Three valid 4-colorings
    of the register interference graph for divide_and_subtract [Description](description-66.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Any one of these colorings—or any other 4-coloring we can come up with—will
    give us a valid register assignment. Each register will receive a different color
    from any of its neighbors. And because the *k* hard registers all interfere with
    each other, we’ll assign each color to exactly one hard register, which creates
    a 1:1 mapping from colors to hard registers.
  prefs: []
  type: TYPE_NORMAL
- en: After we color the graph, we’ll replace each pseudoregister with the hard register
    that received the same color. If we use the first coloring from [Figure 20-3](#fig20-3),
    we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with EDX,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> with EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    with EAX, which gives us the assembly code in [Listing 20-11](chapter20.xhtml#list20-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-11: Replacing registers
    in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">divide_and_subtract</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">based on the first coloring in
    [Figure 20-3](#fig20-3)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you like, you can work through this listing and confirm that it produces
    the same result as the original code for <samp class="SANS_TheSansMonoCd_W5Regular_11">divide_and_subtract</samp>
    in [Listing 20-10](chapter20.xhtml#list20-10). You can also try this out with
    the other colorings in [Figure 20-3](#fig20-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that coloring the graph produces two different mappings: one from all
    registers to colors and one from colors to hard registers. Conceptually, each
    color represents a hard register, but we don’t know *which* hard register until
    after we’ve colored the graph. If instead we used the names of the hard registers
    themselves as colors, or associated each hard register with a color ahead of time,
    then we would have to *precolor* each hard register with the corresponding color
    before we tried to color the rest of the graph. Precoloring adds more constraints
    to the graph coloring problem, which makes it harder to find a valid coloring.
    Some graph coloring implementations require precolored nodes; luckily, ours isn’t
    one of them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Interference</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, I said that two registers interfered if we updated one while the other
    was live. We used this rule to figure out which registers interfered in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">divide _and_subtract</samp>; it helped
    us identify both interference between pseudoregisters and interference between
    pseudoregisters and hard registers. But there are a couple of important points
    about this rule that we still need to cover.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first point is that two registers interfere only if one is live *immediately
    after* we update the other. Here’s a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, RDI holds some memory address—presumably the address of
    a structure or array. The first instruction in this snippet takes the value stored
    in memory at RDI + 4 and copies it into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Before this instruction, RDI is live; afterward, it’s dead. RDI and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    don’t interfere. If we map <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    to RDI, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    will overwrite the address in RDI. But that’s okay, because we won’t use that
    address again.
  prefs: []
  type: TYPE_NORMAL
- en: The second point is that two registers interfere only if they have different
    values. Concretely, this means the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    src, dst</samp> won’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere, even if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> is still live afterward.
    In [Listing 20-12](chapter20.xhtml#list20-12), for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> don’t interfere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-12: A snippet of
    assembly where the source operand of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction is still live after
    that instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to the same hard register, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction won’t
    clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a new value.
    Instead, it will have no effect at all. When we perform register coalescing, we’ll
    even go out of our way to put <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register
    so that we can delete this instruction entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Two registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction could still interfere for other reasons, as [Listing 20-13](chapter20.xhtml#list20-13)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-13: A snippet of
    assembly where a later instruction makes the operands of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction interfere</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this snippet, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction doesn’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> interfere, but the
    subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instruction
    does, because it updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live. In this
    case, putting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register would be
    unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Spilling Registers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can’t always *k*-color the interference graph. Consider the assembly function
    in [Listing 20-14](chapter20.xhtml#list20-14), which calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10
    / arg1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1
    / arg2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-14: Calculating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">10 / arg1 + arg1 / arg2</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this example, we’ll pretend that we have four hardware registers:
    ESI, EDI, EDX, and EAX. [Figure 20-4](#fig20-4) shows the interference graph for
    the listing. I won’t walk you through how to construct the graph, but you can
    verify it on your own if you like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: The interference
    graph for [Listing 20-14](chapter20.xhtml#list20-14) [Description](description-67.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It’s impossible to 4-color this graph. Note that EAX, EDX, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    all interfere with each other. That means each of them must receive a different
    color than the other four, which would require five distinct colors. We’ll solve
    this problem by spilling a register—in other words, removing it from the graph
    instead of coloring it. Spilling any one of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    will make the graph colorable. If we spill <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    for example, we can use the coloring shown in [Figure 20-5](#fig20-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: Coloring the interference
    graph after spilling tmp [Description](description-68.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can replace the two pseudoregisters that we colored, but not <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>.
    [Listing 20-15](chapter20.xhtml#list20-15) gives the resulting assembly code,
    with changes from [Listing 20-14](chapter20.xhtml#list20-14) bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-15: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    after register allocation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’ve made the first two instructions in this listing redundant. We
    could optimize the code further by deleting them, but we won’t worry about this
    optimization for now.
  prefs: []
  type: TYPE_NORMAL
- en: After the register allocator has assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp> to hard registers,
    the pseudo-operand replacement pass will put <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    on the stack. [Listing 20-16](chapter20.xhtml#list20-16) gives the final assembly
    code for this function, with the changes from [Listing 20-15](chapter20.xhtml#list20-15)
    bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-16: The final assembly
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Spilling one pseudoregister made it possible to replace all the others with
    hard registers. But *which* registers we decide to spill matters a lot! As a general
    rule, the more frequently a pseudoregister is accessed, the more it will hurt
    performance to spill that pseudoregister. Our allocator will calculate a *spill
    cost* for each register in the interference graph. This is an estimate of how
    much spilling that register will hurt performance. Then, when we color the graph,
    we’ll use that information to minimize the overall performance impact of spills.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Basic Register Allocator</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have some idea of how our register allocator will work, let’s implement
    it! [Listing 20-17](chapter20.xhtml#list20-17) describes how to allocate registers
    for a single function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-17: The top-level
    register allocation algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by building the interference graph. Then, we calculate a spill cost
    for each register based on how frequently it’s used and annotate the graph with
    that information. Next, we color the graph, annotating each node with its color.
    If we can’t color every node, we’ll use the spill costs we calculated in the previous
    step to decide what to spill. To spill a node, we’ll just leave it uncolored.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is replacing all the pseudoregisters we colored. In <samp class="SANS_TheSansMonoCd_W5Regular_11">create
    _register_map</samp>, we construct a map from colored pseudoregisters to hard
    registers with the same color. Finally, we rewrite the body of the function, replacing
    each pseudoregister with the corresponding hard register from the map.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and stub out <samp class="SANS_TheSansMonoCd_W5Regular_11">allocate_registers</samp>.
    Then, we’ll walk through how to implement each of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Multiple
    Types During Register Allocation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you completed [Part II](part2.xhtml), then you’ll need to run the whole
    algorithm in [Listing 20-17](chapter20.xhtml#list20-17) twice: once to allocate
    general-purpose registers and once to allocate XMM registers. On each run, you’ll
    include only registers of the appropriate type in the interference graph. The
    new features we added in [Part II](part2.xhtml) will change a few other details
    about how we build the interference graph too. We’ll take a closer look at these
    changes when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The individual steps after building the interference graph—including calculating
    spill costs, coloring the graph, and replacing pseudoregisters—look exactly the
    same whether we’re dealing with floating-point or general-purpose registers. The
    other features we added in [Part II](part2.xhtml) won’t impact these steps either.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Interference
    Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get started, we’ll define the data structure for the interference graph.
    [Listing 20-18](chapter20.xhtml#list20-18) presents one possible representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-18: The definition
    of the register interference graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the graph corresponds to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> operand from
    the assembly AST. We’ll track each node’s neighbors, spill cost, and color. We’ll
    represent colors with the integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, where
    *k* is the number of available hard registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field is optional because we may not be able to color every node. We’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> flag when we color
    the graph; you can ignore it until then. When you create a new node, you should
    initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">spill_cost</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: This definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>
    is a bit more permissive than it needs to be; the <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    type includes constants and memory locations, which we’ll never add to the interference
    graph. Alternatively, you could replace <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    with a dedicated <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>
    type that can represent only registers. I’m using a more permissive definition
    so that we don’t have to constantly convert back and forth between <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp> throughout the
    allocator.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Interference
    Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re finally ready to build the interference graph! First, we’ll walk through
    an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>
    that supports the assembly AST from [Part I](part1.xhtml). Then, we’ll discuss
    how to modify it to support the assembly AST from [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Since building this graph is a fairly involved process, we’ll break it down
    into several steps. [Listing 20-19](chapter20.xhtml#list20-19) illustrates these
    steps in pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-19: Building the
    interference graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a graph that includes every hard register ❶. (As far as I know,
    there’s no standard term for this graph, so I’ll call it the *base graph*.) Next,
    we’ll insert a node for each pseudoregister that appears in the function ❷. Finally,
    we’ll figure out which registers interfere with each other. Since this depends
    on which registers are live at each point, we’ll need to run liveness analysis
    on our assembly code. Just like in [Chapter 19](chapter19.xhtml), this analysis
    will take a control-flow graph (which is different from the interference graph!)
    and annotate it with liveness information ❸. Finally, we’ll use that information
    to figure out which edges to add to the interference graph ❹. Let’s take a closer
    look at each of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Base Graph</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The base graph, shown in [Figure 20-6](#fig20-6), includes 12 registers: RAX,
    RBX, RCX, RDX, RDI, RSI, R8, R9, R12, R13, R14, and R15.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: The base register
    interference graph [Description](description-69.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t include RSP or RBP in the graph because we’re already using them to
    manage the stack frame, and we won’t include R10 or R11 because we’ll need them
    in the instruction fix-up pass. Since the hard registers all interfere with each
    other, the base graph includes an edge between each pair of nodes. In graph theory
    jargon, this makes the base graph a *complete graph*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Because the example programs in this chapter deal with 4-byte pseudoregisters,
    most of the diagrams of interference graphs use 4-byte aliases for hard registers.
    I’ve used 8-byte aliases in [Figure 20-6](#fig20-6), since it represents the base
    graph you’ll use for all programs rather than the interference graph for any specific
    program. The interference graphs we actually construct will represent hard registers
    using reg assembly AST nodes, which don’t specify a size.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Pseudoregisters to
    the Graph</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This bit is straightforward: we just loop over every operand in every instruction
    and decide whether to add it to the graph. Every pseudoregister that appears in
    the assembly function should go in the graph, unless it has static storage duration.
    I’ll skip the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>
    because there’s not a lot to it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Liveness Analysis</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already know how liveness analysis works, since we implemented it back in
    [Chapter 19](chapter19.xhtml). Now we’ll need a new implementation that analyzes
    assembly instead of TACKY and tracks registers instead of variables. Luckily,
    the basic logic is the same. We can even reuse some of our existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll construct a control-flow graph. This works just like building
    a control-flow graph from a TACKY function; only the specific instructions at
    the boundaries between basic blocks are different. Instead of looking for TACKY
    control-flow instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>,
    we’ll look for their assembly equivalents: the assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp>. You’ve already
    written code to convert TACKY into a control-flow graph; ideally, you’ll be able
    to refactor it to handle assembly too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at the three components of liveness analysis itself: the iterative
    algorithm, the meet operator, and the transfer function. The iterative algorithm
    is exactly the same as in [Chapter 19](chapter19.xhtml), so you should be able
    to use the implementation of this algorithm that you already wrote.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use set union as our meet operator, just like we did before. However,
    we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> node
    in the control-flow graph differently. Our original meet operator assumed that
    static variables were live when a function exited. Now we don’t care about static
    variables, because they’re not in the interference graph. Instead, we have to
    worry about hard registers: specifically EAX, which holds the function’s return
    value. [Listing 20-20](chapter20.xhtml#list20-20) defines our new meet operator,
    with the one change from the original meet operator defined in [Listing 19-24](chapter19.xhtml#list19-24)
    in bold.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-20: The meet operator
    for liveness analysis of assembly code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’re ignoring the fact that the callee-saved registers are *also* live at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. We can get away with this
    because the instruction fix-up pass will spill these registers if we end up using
    them; that is, it will save their values onto the stack at the start of the function
    and restore them before we return. Assuming that these registers are dead at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> makes it possible to actually
    use them. If we added them to the set of live registers here, we’d conclude that
    they were live throughout the whole function and interfered with every single
    pseudoregister.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transfer function is the one part of liveness analysis that differs significantly
    from the previous chapter. The basic idea is the same: we add registers to the
    live set when they’re used and remove them when they’re updated. But the specifics
    are different because we’re working with a different set of instructions than
    we were before.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>,
    that tells us which operands each instruction uses and updates. Both the transfer
    function and the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>
    function that we’ll implement next will use this helper function. [Listing 20-21](chapter20.xhtml#list20-21)
    gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-21: Identifying
    the operands used and updated by each instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that this listing covers only the assembly instructions from [Part
    I](part1.xhtml). <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> is the
    most straightforward case: it uses its source and updates its destination ❶. A
    binary instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">add src,
    dst</samp> uses its source and destination and updates its destination ❷. It’s
    also easy to see which operands the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions read
    and update.'
  prefs: []
  type: TYPE_NORMAL
- en: Some instructions use registers that they don’t mention explicitly. <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>
    divides the value stored in the EAX and EDX registers by its source operand, so
    it uses all three values. It stores its results in EAX and EDX, so it updates
    those two registers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>
    sign extends EAX into EDX, which means it uses EAX and updates EDX.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> uses the registers
    that hold the callee’s parameters; we can look these up in the backend symbol
    table, where we recorded them during the assembly generation pass ❸. It updates
    all the caller-saved registers—whether we’re passing the callee’s parameters in
    them or not—since these may be clobbered by the callee. This makes all the caller-saved
    registers interfere with any pseudoregisters that are live when we call this function,
    so our graph coloring algorithm will assign these pseudoregisters to callee-saved
    registers instead.
  prefs: []
  type: TYPE_NORMAL
- en: If an instruction both uses and updates the same register—like a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction both uses and updates its destination, for example—it’s important
    to include that register in both the <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp> lists. In the
    transfer function, we’ll only care that the register is used, since that will
    make it live. But when we use this helper function again in <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>,
    we’ll only care that the register is updated, since that will make it interfere
    with any other registers that are live at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write the transfer function, which is defined in [Listing 20-22](chapter20.xhtml#list20-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-22: The transfer
    function for liveness analysis in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a backward analysis, we analyze the assembly instructions in reverse
    order. To process an instruction, we first record which registers are live immediately
    after it ❶. Then, we calculate which registers are live just before it. We call
    the helper function we just wrote to figure out what operands it uses and updates
    ❷. We then remove any registers it updates from the set of current live registers,
    and we add any registers it uses. (If an instruction uses and updates the same
    register, we’ll remove that register from the set of live registers and then immediately
    add it again.) Once we’ve processed every instruction, we record which registers
    are live at the start of the block ❸.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t track constants and memory operands, but our set of live registers
    might still include some operands that we don’t care about (specifically, pseudoregisters
    with static storage duration). There’s no harm in including them in our liveness
    results; we’ll just ignore them when we use those results in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Edges</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With liveness information in hand, we can finally figure out which edges to
    add to the graph. [Listing 20-23](chapter20.xhtml#list20-23) gives the pseudocode
    for this step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-23: Adding edges
    to the interference graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We learned earlier that two registers interfere if one is updated while the
    other is live. Now we’ll look at each instruction and figure out which interferences
    it creates. To process a single instruction, we’ll first call <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    to look up what operands it updates. (We’ll ignore the first list this function
    returns, <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>, because don’t
    care what operands the instruction uses.) Next, we’ll look up which registers
    are live immediately after the instruction ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We then add an edge between each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">live_registers</samp>
    and each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction is a
    special case. If the current instruction is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>,
    we’ll skip over its source as we iterate over the set of live registers so that
    we don’t add an edge between its source and destination ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add an edge between two nodes, we’ll make sure that both nodes are
    already in the interference graph. We’ll also make sure that they’re different,
    since we don’t want to add an edge from a node to itself ❸.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Other Types While
    Constructing the Graph</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we’ll deal with all the features we added in [Part II](part2.xhtml). Since
    we allocate XMM and general-purpose registers separately, we’ll build two interference
    graphs. We’ll start with a separate base graph for each register class. The base
    graph for XMM registers should have 14 nodes; it will include XMM0 through XMM13,
    but not the scratch registers XMM14 and XMM15\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>,
    we’ll check that a pseudoregister has the correct type before adding it to the
    graph. When we allocate XMM registers, we’ll add only pseudoregisters of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type to the graph. When
    we allocate general-purpose registers, we’ll exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    pseudoregisters and include all the other scalar types: <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point registers aside, there are a few other details we need to change.
    We’ll exclude aliased pseudoregisters from the graph, since they shouldn’t be
    assigned to registers. You can reuse the previous chapter’s address-taken analysis
    here; just rerun the analysis immediately before converting the program from TACKY
    to assembly. If a variable was aliased in the TACKY program, it will still be
    aliased in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness analysis should reflect the new calling conventions we implemented
    in [Part II](part2.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    function can’t assume that EAX is live when the function exits; it should check
    the backend symbol table to learn which registers the function uses to pass its
    return value. These registers will all be live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also update the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    helper function. First, this function needs to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operands correctly.
    These operands designate locations in memory, but they use registers in their
    address calculations. When we use one of these operands, we *read* any registers
    it refers to, even if we *write* to the memory location it designates. For example,
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, 4(%rax)</samp>
    uses RAX instead of updating it, and the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">leaq
    (%rax, %rcx, 4), %rdi</samp> uses both RAX and RCX but updates RDI. Second, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> must recognize
    that all the XMM registers are caller-saved and therefore updated by <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp>
    instructions. Finally, this function will need to handle all the new assembly
    instructions we added in [Part II](part2.xhtml), but there’s nothing particularly
    tricky about them.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating
    Spill Costs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After constructing the graph, we annotate each register with a spill cost. If
    we can’t color every node in the graph, these costs will help us decide which
    node (or nodes) to spill. We’ll try to color the graph in a way that minimizes
    the total cost of all spilled nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can’t spill hard registers, we assign each of them an infinite spill
    cost. To estimate the spill cost of each pseudoregister, we just count up the
    number of times it appears in our assembly code. For example, if we encounter
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, %x</samp>,
    we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s spill cost
    by one. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addl
    %x, %x</samp>, we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    spill cost by two. The rationale here is that the more often a pseudoregister
    is used, the more memory accesses and new instructions we’ll introduce if we spill
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Frankly, this is a lousy way to calculate spill cost. It ignores the basic fact
    that some instructions are executed more frequently than others. Clearly, using
    a pseudoregister inside a loop that executes a million times should increase its
    spill cost a lot more than using it in an instruction that runs just once. It’s
    hard to predict exactly how many times a particular instruction will execute,
    but one approach is to use loop nesting depth as a rough proxy for execution frequency.
    When compilers that take this approach calculate spill costs, they give more weight
    to instructions in more deeply nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we have no idea where the loops in our program are. Discovering
    loops would require us to implement a whole new type of analysis, and this chapter
    is long enough. I’ve included a couple of references about identifying loops in
    “Additional Resources” on [page 669](#pg_669) in case you want to implement this
    analysis on your own.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring the Interference
    Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s time to color the graph! Our goal is to minimize the total spill cost of
    the nodes we leave uncolored (ideally by coloring every node so that the total
    spill cost is zero). But exact graph coloring algorithms, which find the best
    possible coloring, are too slow to use in practice. Instead, we’ll use an approximate
    algorithm. This algorithm may not find the best coloring, but it can usually find
    a pretty good one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our graph coloring algorithm is based on a simple observation: you can always
    color a node with fewer than *k* neighbors, because there’s always at least one
    color that none of its neighbors uses. This observation is called the *degree
    <* k *rule*. (The number of neighbors a node has is called its *degree*; we say
    that a node has *significant degree* if it has *k* or more neighbors.) The degree
    < *k* rule gives us a way to break down the problem. First, we’ll temporarily
    remove any node with fewer than *k* neighbors. This is called *pruning* the graph.
    Then, we’ll color the rest of the graph somehow (we won’t worry about how to do
    this just yet). Finally, we’ll put back the nodes that we pruned, one at a time.
    When we put back a node, we’ll assign it some color that doesn’t conflict with
    any neighbors that we’ve already colored. There will always be at least one available
    color, since each node has fewer than *k* neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to 3-color the graph shown in [Figure 20-7](#fig20-7) using this approach
    and see how far we get.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: A graph that hasn’t
    been colored yet [Description](description-70.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This graph has four nodes with fewer than three neighbors: *B*, *C*, *F*, and
    *H*. We’ll prune these nodes from the graph and then figure out how to color the
    smaller graph. We’ll also define a stack to keep track of the pruned nodes that
    we’ll eventually need to put back in the graph. [Figure 20-8](#fig20-8) shows
    the pruned graph and the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The graph from
    [Figure 20-7](#fig20-7) with low-degree nodes removed [Description](description-71.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this pruned graph, *A* and *G* both have fewer than three neighbors. That
    means we can apply the same trick to prune the graph again! We’ll push *A* and
    *G* onto the top of the stack; later on, we’ll pop them off and color them before
    we color *B*, *C*, *F*, and *H*. When we pop *A* and *G* off the stack and put
    them back in the graph, they’ll have the same degree they do now, so we know we’ll
    be able to find a color for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-9](#fig20-9) shows how the graph and stack look after we prune *A*
    and *G*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: The graph from
    [Figure 20-7](#fig20-7) after two rounds of pruning [Description](description-72.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our two remaining nodes each have fewer than three neighbors, so we could just
    color them. But we’ll take a slightly different approach to accomplish the same
    thing: we’ll prune them from the graph, then put them back. After we prune them,
    the graph is empty. [Figure 20-10](#fig20-10) shows how things look after we’ve
    pruned every node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: The graph from
    [Figure 20-7](#fig20-7) after pruning every node [Description](description-73.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our original plan was to prune the graph, color the remaining nodes, then put
    back the nodes we had pruned. Now that we’re done pruning, we don’t have to do
    anything for the second step: there are no nodes left to color! We won’t get this
    lucky with every graph; sometimes we’ll end up with nodes we can’t prune. We’ll
    talk about how to handle that situation in a moment. For now, let’s finish coloring
    this graph.'
  prefs: []
  type: TYPE_NORMAL
- en: As the last step in our plan, we’ll take each of the nodes we pruned earlier,
    assign it a color, and put it back in the graph. We’ll start with the last node
    we removed, which is at the top of the stack, then repeat this process until the
    stack is empty. The sequence of diagrams in [Figure 20-11](#fig20-11) illustrates
    how we’ll rebuild the graph in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-11: Adding nodes
    back to the graph and assigning colors [Description](description-74.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we add *E* back to the graph, it has no neighbors, so we can assign it
    any color. Let’s color it white. Then, when we add *D*, its only neighbor is *E*,
    so we can assign it either black or gray. When we add *G*, we find that it has
    a white neighbor and a gray neighbor, so we must color it black. We continue until
    the stack is empty and every node in the graph has been assigned a color.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Spills</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many interference graphs, we can prune every node using the approach we
    took in the previous section. We can color those graphs without any spills. But
    there are other graphs where we’ll get stuck: we’ll hit a point where every node
    has *k* or more neighbors. Suppose we want to 3-color the graph shown in [Figure
    20-12](#fig20-12).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-12: A graph where
    every node has three or more neighbors [Description](description-75.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to prune this graph, we’ll immediately get stuck: every node has
    at least three neighbors! To get unstuck, we’ll choose a node to prune anyway.
    We’ll put this node on the stack, then continue with the algorithm as usual. This
    node is a *spill candidate* because we might not be able to color it when we put
    it back in the graph. If we’re lucky, its neighbors won’t use up every color,
    so we’ll be able to color it. If we’re unlucky, its neighbors will use all *k*
    colors, so we’ll have to spill it.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to choose a spill candidate with a low spill cost. But we also want
    to choose a spill candidate with lots of neighbors that haven’t been pruned yet,
    because pruning our spill candidate lowers its neighbors’ degrees and helps us
    avoid spilling them later on. To balance these two priorities, we’ll choose the
    node with the smallest value of *spill cost / degree*, where degree is the number
    of neighbors that haven’t been pruned yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’ll never choose a hard register as a spill candidate, because *spill
    cost / degree* for each of these registers is always infinity. If there are any
    pseudoregisters left in the graph, we’ll always choose one of them as a spill
    candidate instead of choosing a hard register. If there are no pseudoregisters
    left, the total number of registers must be *k* or fewer, so we’ll be able to
    prune every register.
  prefs: []
  type: TYPE_NORMAL
- en: Some graphs have no valid *k*-colorings, which makes spilling unavoidable. For
    other graphs, a valid coloring exists, but whether we find it is a matter of chance;
    it depends on the exact order in which we remove nodes from the graph and how
    we happen to color them when we put them back.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the element of chance in this approach, we’ll make a couple of
    attempts to color the graph in [Figure 20-12](#fig20-12). This graph is 3-colorable,
    but only one of our attempts will find a spill-free coloring. In both cases, we’ll
    choose *C* as our spill candidate, then prune *A* and *B*, leaving *D*, *E*, and
    *F*. And in both cases, we’ll use the same strategy to color nodes as we add them
    back into the graph: we’ll choose the first available color from the list *[white,
    gray, black]*. The only difference will be the order in which we prune the remaining
    three nodes. In the first case, we’ll prune *D*, then *E*, then *F*. [Figure 20-13](#fig20-13)
    shows what will happen when we try to add the nodes back in.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-13: A first attempt
    to color [Figure 20-12](#fig20-12) [Description](description-76.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we reach *C*, we’ll see that its neighbors are already using all three
    colors, so we’ll be forced to spill it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s repeat this process; on this attempt, we’ll prune *F*, then *E*, then
    *D*. [Figure 20-14](#fig20-14) shows what will happen when we put the nodes back
    in the graph this time around.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-14: A more successful
    attempt to color [Figure 20-12](#fig20-12) [Description](description-77.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This time, we assigned *A* and *E* the same color, which allowed us to assign
    *C* a color instead of spilling it. In a small example like this one, it’s easy
    to see that assigning these nodes the same color is the better choice. But there’s
    no general rule that lets us avoid unnecessary spills like the one in [Figure
    20-13](#fig20-13); that’s what makes this algorithm approximate. We *could* avoid
    unnecessary spills if we used an exact algorithm instead, but as I mentioned earlier,
    exact algorithms are too expensive to be practical.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Graph Coloring
    Algorithm</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve worked through a few examples using this algorithm, let’s look
    at the pseudocode, which is shown in [Listing 20-24](chapter20.xhtml#list20-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-24: The graph coloring
    algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll color the graph recursively. At each step, we’ll prune a node, then make
    a recursive call to color the rest of the graph, then put the node back and assign
    it a color. In the base case, we’ve already pruned every node, so we have nothing
    left to do ❶.
  prefs: []
  type: TYPE_NORMAL
- en: In the recursive case, we’ll start by choosing a node to prune, which this listing
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>. We’ll
    pick the first node we find with fewer than *k* unpruned neighbors ❷. (If you’re
    allocating general-purpose registers, *k* is 12; if you’re allocating XMM registers,
    it’s 14.) If that search comes up empty, we’ll pick the node with the minimum
    value of *spill cost / degree* ❸. To prune a node, we’ll just set its <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>
    attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Then,
    we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">color_graph</samp> recursively
    to color the remaining nodes in the graph ❹.
  prefs: []
  type: TYPE_NORMAL
- en: After we return from this recursive call, we’ll try to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>
    a color. We’ll take the list of integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, which
    represent every possible color, and remove any color that we’ve already assigned
    to one of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp>’s
    neighbors. Some of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>’s
    neighbors may not have a color, either because we spilled them or because we pruned
    them before <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp>
    and will therefore color them later. We can simply ignore these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are any colors left in the list, we’ll assign one of them to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp> ❺. If there’s more
    than one color available, the algorithm isn’t fussy about which one we choose.
    Although the color we choose here might impact how many nodes we ultimately spill,
    the effect is unpredictable; there’s no color selection strategy that minimizes
    spills across the board. So, we’ll choose a color with a different goal in mind:
    assigning pseudoregisters to caller-saved rather than callee-saved hard registers.
    (We’d like to use as few callee-saved registers as possible, to avoid the cost
    of saving and restoring them.) When <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>
    represents a callee-saved hard register, we’ll assign it the available color with
    the highest number. Otherwise, we assign it the lowest-numbered available color.
    Using this strategy, the coloring algorithm will tend to assign higher-numbered
    colors to callee-saved registers and lower-numbered colors to caller-saved registers
    and pseudoregisters. A pseudoregister will end up with a higher-numbered color
    only when there are no lower-numbered colors available (for example, because it
    conflicts with every caller-saved register). Once we’ve picked a color, we set
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute back
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. This isn’t strictly
    necessary, because we won’t use this attribute again, but it marks that we’ve
    put the node back in the graph.'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no colors left in the list, we’ll have to spill <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>.
    Concretely, this just means we won’t assign it a color. We also won’t update its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute, since we
    aren’t putting this node back in the graph. Note that we don’t explicitly push
    nodes onto a stack or pop them off afterward. Our recursive algorithm naturally
    colors nodes in the correct order, starting with the last node we pruned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Register
    Map and Rewriting the Function Body</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve colored the graph, the rest of the register allocator is pretty simple.
    We’ll build a map from pseudoregisters to hard registers, which we’ll use to replace
    the pseudoregisters in our assembly code. As we build this map, we’ll also keep
    track of which callee-saved registers we’ve allocated so that we can save and
    restore them in the instruction fix-up pass. [Listing 20-25](chapter20.xhtml#list20-25)
    demonstrates how to construct the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-25: Building a map
    from pseudoregisters to hard registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll iterate through the hard registers in the graph, building up a
    map from colors to hard registers. Remember that we’ll have a 1:1 mapping between
    colors and hard registers because each of the *k* hard registers must be assigned
    a different one of the *k* possible colors. Next, we’ll iterate through all the
    pseudoregisters. If a pseudoregister was assigned a color, we’ll map it to the
    hard register with the same color, which we can find in <samp class="SANS_TheSansMonoCd_W5Regular_11">color_map</samp>
    ❶. If a pseudoregister wasn’t assigned a color, we won’t add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: As we build up <samp class="SANS_TheSansMonoCd_W5Regular_11">register_map</samp>,
    we also track the set of callee-saved registers this function will use. Whenever
    we add a mapping from a pseudoregister to a callee-saved hard register, we’ll
    add the hard register to this set ❷. We’ll record each function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_regs</samp>
    set so that we can pass that information on to the instruction fix-up phase ❸.
    (This listing doesn’t specify *where* to record that information; you can add
    it to the function definition itself, the backend symbol table, or some other
    data structure, depending on what’s most convenient.) We can skip this step when
    we allocate XMM registers, because none of the XMM registers are callee-saved.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll rewrite the assembly code. We’ll replace each pseudoregister
    in each instruction with the corresponding hard register from the register map.
    If a pseudoregister is missing from the map, we won’t replace it. While we’re
    at it, we’ll remove any <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction whose source and destination ended up in the same hard register. For
    instance, if we’ve mapped both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> to EAX, we can rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Both ❶ and ❷ would be rewritten as <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    %eax, %eax</samp>, which doesn’t do anything, so we can drop them both from the
    final assembly program.
  prefs: []
  type: TYPE_NORMAL
- en: This bit of cleanup where we delete unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions is related to register coalescing, which we’ll implement later in
    this chapter. But there are some important differences. The register coalescing
    step will deliberately merge together registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>,
    then delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    between them. This whole process will happen before we color the rest of the graph.
    What we’re doing here is much simpler; we’re not trying to merge registers, but
    if we happen to assign both operands of a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction the same color, we’ll take advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Even once we implement register coalescing, this post-coloring cleanup will
    still be useful. As we’ll see, the register coalescing pass isn’t perfect; sometimes
    it will miss a pair of registers that it would have been helpful to coalesce.
    If we get lucky and assign that pair of registers the same color, this final step
    will still be able to delete <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions between them.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a working register allocator! We just need to update
    the instruction fix-up and code emission passes before we test it out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Instruction Fix-Up with Callee-Saved
    Registers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a function uses any callee-saved registers, we need to save their values
    at the start of the function and restore them at the end. We’ll save them by pushing
    them onto the stack on top of the rest of the current stack frame. For example,
    if a function needs 16 bytes of stack space for local variables and uses R12 and
    R13, we’ll insert the following three instructions at the very beginning of the
    function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp> instruction
    allocates the current stack frame, just like in earlier chapters. The new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions come immediately
    after it. (If you skipped [Part II](part2.xhtml), the first instruction will be
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> rather than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp>.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we return, we’ll restore the values of these registers by popping them
    off the stack. That is, we’ll rewrite each <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction in this function as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can push callee-saved registers onto the stack in any order, but we’ll always
    need to pop them back off in the reverse order so that each register ends up with
    its original value. Since we add the rest of the function epilogue during code
    emission, we’ll end up deallocating the stack frame just after restoring the callee-saved
    registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to ensure that the entire stack frame, including the values of
    any callee-saved registers that we save to the stack, is 16-byte aligned. Suppose
    the pseudo-operand replacement pass has allocated 20 bytes of stack space to store
    local variables in a particular function. We’d normally subtract 32 bytes from
    RSP to maintain the proper stack alignment. But if the function uses a single
    callee-saved register, we should initially subtract 24 bytes instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we subtract 24 bytes from RSP explicitly and subtract another 8 bytes by
    pushing RBX, we still end up subtracting a total of 32 bytes, so the stack will
    be properly aligned. [Listing 20-26](chapter20.xhtml#list20-26) demonstrates one
    way to perform this tricky calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-26: The stack space
    calculation that accounts for callee-saved registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp>
    is the number of bytes of stack space we allocated during pseudo-operand replacement,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_count</samp> is
    the number of callee-saved registers the function uses. We start by calculating
    how many bytes the callee-saved values will occupy. Then, we add this to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp> and round up to
    the nearest multiple of 16 to get the total size of the stack frame ❶. Working
    backward from this value, we subtract the number of bytes the callee-saved values
    will occupy to find the number of bytes we need to explicitly subtract from RSP
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we’ll update the code emission pass to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    instruction and all the new registers we added in this chapter. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> will always use the 8-byte
    names for registers. [Tables 20-4](chapter20.xhtml#tab20-4) and [20-5](chapter20.xhtml#tab20-5)
    describe how to print out these constructs. (I haven’t bolded new and changed
    constructs like I did in most code emission tables in earlier chapters, because
    all of these constructs are new.) For a summary of the complete code emission
    pass at the end of this chapter, see [Appendix B](appendix-B.xhtml), which includes
    two sets of code emission tables for [Part III](part3.xhtml): one with the features
    from [Part II](part2.xhtml) and one without them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Pop(reg)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">popq</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BX)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbx</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ebx</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%bl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R12)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R13)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R14)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R15)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15d</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM8)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm8</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM9)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm9</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM10)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm10</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM11)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm11</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM12)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm12</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM13)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm13</samp> |'
  prefs: []
  type: TYPE_TB
- en: Now you’re ready to try out your register allocator on some real programs!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Coalescing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our register allocator already works correctly. But as we saw in the example
    at the start of the chapter, it will produce even more efficient code if we include
    a coalescing step. That early example also gave us a general sense of how this
    process works: we look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction that copies a value from one register to another and decide whether
    to coalesce its source and destination. Once we’ve made these decisions, we rewrite
    the assembly code, replacing the registers we coalesced and deleting any <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions that we no longer
    need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide which registers to coalesce, we’ll consult the interference graph.
    We’ll coalesce a pair of registers when two conditions are met. The first condition
    is obvious: the registers can’t interfere with each other. The example from [Listing
    20-13](chapter20.xhtml#list20-13), reproduced here, illustrates why this condition
    is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since we update <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> while
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live, these two registers
    interfere. If we coalesced them, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    instruction would clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and we’d end up calculating 2 + 2 instead of 1 + 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second condition is subtler: we’ll coalesce a pair of registers only if
    that won’t force us to spill more registers. To understand why coalescing can
    lead to spills, let’s look at [Listing 20-27](chapter20.xhtml#list20-27).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-27: An assembly
    function where coalescing would cause a spill</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This assembly function calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10
    - (arg</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)
    * arg</samp>. For this example, we’ll pretend that EDI and EAX are the only available
    hard registers, so *k* is 2\. [Figure 20-15](#fig20-15) shows this listing’s interference
    graph, which is clearly 2-colorable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-15: The interference
    graph for [Listing 20-27](chapter20.xhtml#list20-27) [Description](description-78.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    in [Listing 20-27](chapter20.xhtml#list20-27) looks like a possible candidate
    for coalescing. (The second instruction isn’t, since <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> interfere.) But if
    we try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into
    EDI, we’ll run into trouble. We’ll end up with the assembly code in [Listing 20-28](chapter20.xhtml#list20-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-28: [Listing 20-27](chapter20.xhtml#list20-27)
    after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arg</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-16](#fig20-16) shows the interference graph for this coalesced code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-16: The interference
    graph for [Listing 20-28](chapter20.xhtml#list20-28) [Description](description-79.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can’t 2-color the graph anymore. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    interferes with both hard registers, we’ll have to spill it. Instead of improving
    performance, we’ve made it worse! The cost of spilling <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    to memory outweighs the benefit of removing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. To avoid this situation, we’ll use a strategy called *conservative
    coalescing*: we’ll coalesce two registers only when we can tell in advance that
    it won’t make the interference graph harder to color. But before we dig into conservative
    coalescing, we need to learn how to keep the graph up to date.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Interference
    Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever we decide to coalesce a pair of registers, we need to update the interference
    graph. Otherwise, we’ll make later coalescing decisions based on bad information.
    There are two ways to perform this update. The first is to rewrite the assembly
    code immediately and rebuild the graph from scratch. The problem with this approach
    is that building the interference graph is slow. We might coalesce dozens or even
    hundreds of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    in a single function, but we can’t afford to rebuild the interference graph hundreds
    of times.
  prefs: []
  type: TYPE_NORMAL
- en: A much quicker approach is to merge the two nodes together in the existing interference
    graph, without referring back to the assembly code. In [Figure 20-17](#fig20-17),
    we use this approach to coalesce the pseudoregister <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EAX.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-17: Updating the
    interference graph to reflect coalescing decisions [Description](description-80.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that any register that originally interfered with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    now interferes with EAX. To make the interference graph reflect this change, we
    just add an edge from each of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>’s
    neighbors to EAX and then remove <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this way of updating the graph has a problem too: it’s not always accurate!
    It might include some extra edges between registers that don’t really interfere.
    [Listing 20-29](chapter20.xhtml#list20-29) gives a slightly contrived example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-29: A function that
    copies its first argument into two different pseudoregisters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> interfere: the second <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> is still live.
    Let’s try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    into EDI and use our speedy, simple method to update the graph accordingly. [Figure
    20-18](#fig20-18) shows how the graph will change.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-18: Updating the
    interference graph for [Listing 20-29](chapter20.xhtml#list20-29) [Description](description-81.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: But when we actually replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    with EDI, we’ll find that the interference with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    goes away! [Listing 20-30](chapter20.xhtml#list20-30) shows the updated assembly
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-30: [Listing 20-29](chapter20.xhtml#list20-29)
    after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tmp1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We learned earlier that the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    src, dst</samp> will never make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere. Initially,
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl %edi, %tmp2</samp>
    caused an interference between <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>. Now that we’ve
    merged <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into EDI, it
    doesn’t cause an interference anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it isn’t completely accurate, our quick update method is still useful.
    It produces a conservative approximation of the true interference graph; it has
    all the nodes and edges that should be in the graph, but it might have a few extra
    edges too. If this graph tells us that two registers are safe to coalesce, we
    can be sure they really are. But if we rely solely on this method, we’ll leave
    some coalescing opportunities on the table. If, for instance, we only look at
    the graph in [Figure 20-18](#fig20-18), we won’t realize that we can coalesce
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI. Worse, if
    we attempted to color this graph, we might end up spilling registers unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ll use *both* approaches to update the graph. Each time we decide to
    coalesce a pair of registers, we’ll perform a quick update by merging their nodes
    together. Then, after we’ve looked at every <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction and rewritten the assembly code, we’ll rebuild the graph from scratch.
    We’ll repeat this build-coalesce loop until we can’t find any more registers to
    coalesce. Combining a speedy, approximate inner loop with a slow, precise outer
    loop gives us the best of both worlds. We’ll catch every coalescing opportunity
    and send an accurate interference graph on to the coloring stage, but we won’t
    waste time rebuilding the graph after every single coalescing decision.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conservative Coalescing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we understand how coalescing changes the graph, we can reason about
    when it might lead to spills. The basic issue is that when we coalesce two nodes,
    the merged node will have a higher degree than either of them, which could make
    it more difficult to prune. It’s also likely to have a higher spill cost than
    either of the original nodes, since it’s used more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use two conservative coalescing tests to ensure that a merged node doesn’t
    cause problems when we color the graph. The *Briggs test* guarantees that we won’t
    spill the merged node. The *George test* guarantees that we won’t spill any other
    nodes unless they were already potential spill candidates in the original graph.
    We’ll only coalesce two pseudoregisters if they pass the Briggs test. We’ll coalesce
    a pseudoregister into a hard register if the two registers pass either test; we
    can be more permissive in this case because we already know that the hard register
    won’t spill. Both tests are named after the people who invented them; you can
    find links to the papers that first proposed them in “Additional Resources” on
    [page 669](#pg_669).
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth clarifying exactly what the conservative coalescing tests guarantee,
    because it’s a little unintuitive. If you could completely prune the original
    graph without ever having to choose a spill candidate, these tests guarantee that
    the same will be true for the coalesced graph. In this case, we can say for sure
    that coalescing won’t cause any spills.
  prefs: []
  type: TYPE_NORMAL
- en: But if you couldn’t totally prune the original graph, it’s harder to predict
    the impact of coalescing, because a lot of what happens after you pick a spill
    candidate comes down to chance. We saw an example of this earlier in the chapter,
    when we tried to color the graph in [Figure 20-12](#fig20-12); pruning nodes in
    a different order made the difference between being able to color a spill candidate
    and actually spilling it. Coalescing registers can have similar ripple effects.
    If we’re unlucky, these effects might lead to a spill that we otherwise would
    have avoided.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if coloring the original graph required us to choose a spill
    candidate, coloring the coalesced graph might too—and at that point, it’s impossible
    to say with any certainty what’s going to happen. In this case, the conservative
    coalescing tests still give us two valuable guarantees. First, the coalesced node
    itself won’t spill. Second, at the point where we get stuck and have to choose
    our first spill candidate, every node’s degree will be the same or lower than
    it would have been when we got stuck if we hadn’t performed coalescing. This means
    that, on balance, we’re likely to successfully prune more nodes and spill fewer
    than we would have without coalescing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll take a closer look at the Briggs and George tests. We’ll define both
    of them and walk through some examples that demonstrate why they work.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Briggs Test</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a node has significant degree if it has *k* or more neighbors.
    The Briggs test allows us to merge two nodes if the merged node will have fewer
    than *k* neighbors with significant degree. When we color the graph, we’ll be
    able to prune every neighbor with insignificant degree. The merged node itself
    will then have insignificant degree—it will have fewer than *k* neighbors left—so
    we’ll be able to prune that node too.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example. Consider the interference graph in [Figure 20-19](#fig20-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-19: An interference
    graph before coalescing [Description](description-82.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our coloring algorithm can prune this entire graph without any difficulty. Now
    let’s apply the Briggs test to see if we can coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. [Figure 20-20](#fig20-20)
    shows how the graph will look once we merge these two nodes together.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-20: The graph in
    [Figure 20-19](#fig20-19) after merging x into y [Description](description-83.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'After coalescing, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will
    have four neighbors: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, ESI, and EDI. Only two of these
    nodes, ESI and EDI, have significant degree. Since *k* is 3, this example passes
    the Briggs test. And in fact, we’ll be able to prune <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    after we’ve pruned <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, then finish pruning the
    rest of the graph like we did before.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at a case that fails the Briggs test. The graph in [Figure
    20-21](#fig20-21) is almost identical to the one in [Figure 20-19](#fig20-19),
    except for an extra edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to EDI.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-21: A variation on
    the graph in [Figure 20-19](#fig20-19) where x and y can no longer be coalesced
    [Description](description-84.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Even with this extra edge, our coloring algorithm can still prune the whole
    graph. But [Figure 20-22](#fig20-22) shows what happens when we coalesce <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    this time around.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-22: The graph in
    [Figure 20-21](#fig20-21) after merging x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">into
    y [Description](description-85.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> has three neighbors
    with significant degree: ESI, EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    This example fails the Briggs test, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    really is impossible to prune. After we prune <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    and EAX we’ll get stuck, and we’ll be forced to choose <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> as a spill candidate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As these examples show us, the Briggs test stops us from transforming a colorable
    graph into an uncolorable one. It also gives us another guarantee: we’ll never
    coalesce two nodes if the resulting node might spill. Take a look at [Figure 20-23](#fig20-23).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig20-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-23: An interference
    graph where we can’t coalesce tmp1 and tmp2 [Description](description-86.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>. This clearly won’t
    make the graph harder to color; it will have the same effect on the interference
    graph as removing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> entirely.
    But coalescing these nodes is a bad idea for another reason. We won’t be able
    to color <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> whether we
    coalesce it with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> or
    not, so coalescing will just make things worse by increasing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>’s
    spill cost.
  prefs: []
  type: TYPE_NORMAL
- en: This example fails the Briggs test, since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    will have three neighbors with significant degree after coalescing (just like
    it did before coalescing). If we might not be able to color it, the Briggs test
    won’t let us coalesce it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s tweak this example to illustrate one of the limits of the Briggs
    test. Imagine that we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>.
    Like in our previous example, this won’t make the graph harder to color. And this
    also fails the Briggs test, because EDI will have three neighbors with significant
    degree. But there’s one important difference: as a hard register, EDI can’t spill.
    This means that there’s no downside to coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI; it won’t force us to spill EDI, and it won’t make other nodes harder
    to color either. In cases like this, we’ll use the George test to find coalescing
    opportunities that the Briggs test misses.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The George Test</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we coalesce a pseudoregister with a hard register, we know the coalesced
    register can’t spill. Instead, we’re worried about a slightly different outcome:
    if the hard register becomes more difficult to prune, its neighbors could become
    harder to prune too. Ultimately, this change could force us to spill nodes that
    we were able to color before. In cases that involve a hard register, we’ll use
    both the Briggs test and the George test to identify as many coalescing opportunities
    as possible. The Briggs test proves that we can prune the merged node, so it won’t
    interfere with attempts to color other nodes. The George test proves that we won’t
    make the merged node’s neighbors harder to prune (and therefore won’t make those
    nodes or the rest of the graph more difficult to color), even if we can’t prune
    the merged node itself. We can coalesce a pair of nodes that passes either of
    these tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The George test says that you can coalesce a pseudoregister *p* into a hard
    register *h* if each of *p*’s neighbors meets either of two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: It has fewer than *k* neighbors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It already interferes with *h*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a neighbor meets the first condition, we’ll definitely be able to prune it
    when we color the graph. If it meets the second condition, it will have exactly
    the same neighbors as before (except for *p*) after coalescing, so we won’t have
    made it any harder to prune; if anything, we might have made it easier.
  prefs: []
  type: TYPE_NORMAL
- en: Coalescing *h* and *p* won’t make any of *h*’s neighbors harder to prune, either.
    The only way it could do that would be by preventing us from pruning *h* itself,
    but any new neighbors that *h* acquires through coalescing will have insignificant
    degree, so they won’t affect our ability to prune it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the graph from [Figure 20-23](#fig20-23) to see
    why this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg660-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earlier, we decided that coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI was safe, because EDI couldn’t spill and this change wouldn’t make any
    of the other nodes harder to color. But we also saw that this case failed the
    Briggs test, since EDI would then have three neighbors with significant degree.
    Now we’ll try the George test instead. This test will pass, since both neighbors
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> already interfere
    with EDI. Our allocator will coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI, since it coalesces moves that pass either of our two tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our last example, let’s revisit the graph from [Figure 20-15](#fig20-15):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg660-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last time we looked at this graph, we were considering whether to coalesce
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into EDI. Now we know
    that we shouldn’t coalesce them, because this case doesn’t pass either of our
    two tests. It fails the Briggs test because the coalesced node would have two
    neighbors with significant degree, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    and EAX. It also fails the George test; <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>’s
    one neighbor, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, has significant
    degree and doesn’t interfere with EDI. The George test tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    *might* become harder to color if we made this change; we’d be making it interfere
    with an additional register, and we don’t know what impact that would have. In
    this small example, we can tell by looking at the graph that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    actually would be harder to color if we coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    into EDI, since it would interfere with both hard registers.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one ugly detail about the George test that I want to mention. Remember
    that we’re using a quick, approximate method to update the graph after each coalescing
    decision. This approximate method might leave edges in the graph between registers
    that do not, in fact, interfere. As a result, when applying the George test to
    registers *p* and *h*, we might think that some neighbor *n* of *p* also interferes
    with *h* when it actually doesn’t. We might then incorrectly conclude that *p*
    and *h* pass the George test and coalesce them.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds pretty bad, but it only slightly weakens the guarantee that the
    George test provides. Earlier, I claimed that the George test guarantees that
    we won’t make the merged node’s neighbors harder to prune. It actually guarantees
    that we won’t make them harder to prune than they were *before we started the
    current round of coalescing*—that is, the last time we rebuilt the interference
    graph from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: This weaker guarantee still holds because our approximate graph will include
    an edge between *n* and *h* only if *n* did interfere with *h* when we built the
    interference graph, but some earlier coalescing decision removed that interference.
    Essentially, if an earlier coalescing decision made *n* or *h* easier to prune
    by removing the edge between them, we might accidentally make them more difficult
    to prune again by putting that edge back. However, we’ll never make things worse
    than they were before the current round of coalescing. (It’s also worth keeping
    in mind that the purpose of the Briggs and George tests is to improve performance,
    *not* to guarantee correctness; even a “bad” coalescing decision that fails both
    tests won’t change the program’s observable behavior.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ve looked at both conservative coalescing tests, what guarantees they provide,
    and why they work. Now we just have to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Register
    Coalescing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first task is to add the build-coalesce loop to the top-level register allocation
    algorithm. [Listing 20-31](chapter20.xhtml#list20-31) gives the updated algorithm,
    with this addition bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-31: Adding register
    coalescing to the top-level register allocation algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Within this loop, we build the interference graph, then look for registers to
    coalesce. If we find any, we rewrite the assembly code and start the whole process
    again. Otherwise, we exit the loop and run the rest of the allocator as usual.
  prefs: []
  type: TYPE_NORMAL
- en: We record which registers we’ve coalesced together in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>,
    which is a *disjoint-set* data structure. Let’s write a simple implementation
    of this data structure; then we’ll define the <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_coalesced</samp> functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disjoint Sets</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the name suggests, a disjoint-set data structure represents multiple disjoint
    sets of values. Each set is identified by one representative member. Disjoint
    sets support two operations: <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    merges two sets, and <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    looks up the representative member of a set. In our case, the values in each set
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands. Initially, each register is in a set by itself. As we coalesce registers,
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> operation
    to merge these sets together. When we rewrite the assembly code, we’ll use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to replace each register with
    the representative member of its set.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different ways to implement disjoint sets. We’ll use a simple
    implementation that’s easy to understand. [Listing 20-32](chapter20.xhtml#list20-32)
    defines our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-32: A basic implementation
    of disjoint sets</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use a map to track which sets have been merged together. At first, this map
    is empty ❶. To merge two sets whose representative members are <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    operation inserts a mapping from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> ❷. This makes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> the representative member of
    the new set. When we coalesce a pseudoregister into a hard register, it’s important
    to make the hard register the set’s representative member; we don’t want to replace
    hard registers with pseudoregisters when we rewrite the code later on.
  prefs: []
  type: TYPE_NORMAL
- en: To look up the representative member of the set that contains the register <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    operation first checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    maps to some other register ❸. If it doesn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    itself is the representative member of its set, so we return it. Otherwise, looking
    it up in the map will give us <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>,
    which is the register we merged <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    into previously. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    recursively ❹, which leads us up the chain of mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    to its representative member. For example, if we’ve merged <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and then merged <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>,
    we’ll follow the mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to determine that <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is the
    representative member for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The last operation we define in this listing is <samp class="SANS_TheSansMonoCd_W5Regular_11">nothing_was_coalesced</samp>,
    which just checks whether the map is empty ❺.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The coalesce Function</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> function will
    look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    in the assembly code, deciding which registers to coalesce and keeping track of
    those decisions in the disjoint-set structure we just defined. Let’s walk through
    [Listing 20-33](chapter20.xhtml#list20-33), which gives the pseudocode for this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-33: Deciding which
    registers to coalesce</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing a new disjoint-set structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>,
    to track which registers we’ve coalesced. Then, we iterate through the instruction
    list. When we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to look up its
    current source and destination ❶, since we might have coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> into other registers
    already. Note that these operands might be constants or memory addresses instead
    of registers. This is fine; if there’s no mapping for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find(x, coalesced_regs)</samp> just returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, regardless of whether
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a register or some other
    kind of operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we decide whether to coalesce the instruction’s source and destination
    ❷. First, we check whether they’re both in the interference graph. (This stops
    us from trying to coalesce constants or memory operands.) We then make sure they’re
    two different registers, since there’s no reason to coalesce a register with itself.
    If these checks pass, we test the two conditions we learned about earlier: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    must not interfere ❸, and coalescing them must not make the graph harder to color
    ❹. We check the second of these conditions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>
    function, which we’ll come back to in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    meet all these conditions, we’ll coalesce them! Now we have to figure out which
    one to keep in the assembly code and which one to replace. If either operand is
    a hard register, we’ll keep that one and replace the other one. If they’re both
    pseudoregisters, we’ll arbitrarily choose to keep <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
    We call <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> to actually
    coalesce these registers ❺, then we update the interference graph. [Listing 20-34](chapter20.xhtml#list20-34)
    defines the function that performs this update.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-34: Updating the
    interference graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This function takes each of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    neighbors, removes its edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and adds an edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> instead.
    Then, it removes <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The conservative_coalesceable
    Function</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that the rest of <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>
    is in place, let’s take a look at [Listing 20-35](chapter20.xhtml#list20-35),
    which defines the conservative coalescing tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-35: The conservative
    coalescing tests</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>,
    we try the Briggs test first ❶. Then, if the Briggs test fails and either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is a hard register, we try the George test ❷. When we use the George test, we’ll
    make sure to pass the hard register as its first argument and the pseudoregister
    as its second, since it doesn’t treat these registers interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the Briggs test, we first construct <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>,
    which is the set of nodes that interfere with either <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. We then iterate through
    this set, looking up each neighbor’s degree ❸. If a node interferes with both
    of them, coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would decrease its degree
    by one, so we adjust <samp class="SANS_TheSansMonoCd_W5Regular_11">degree</samp>
    accordingly ❹. We’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if fewer than *k* of the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>
    have significant degree ❺.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the George test, we iterate through the pseudoregister’s neighbors,
    making sure each one either interferes with the hard register ❻ or has insignificant
    degree ❼. If we find a neighbor that doesn’t satisfy either condition, we’ll return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If every neighbor
    meets both conditions, we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The rewrite_coalesced Function</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll wrap up by rewriting the assembly code. [Listing 20-36](chapter20.xhtml#list20-36)
    gives the pseudocode for this step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-36: Rewriting instructions
    after deciding which registers to coalesce</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> operation
    to replace each operand in each instruction. (Here, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>,
    we rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to handle
    non-registers correctly.) If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction’s updated source and destination are the same, we’ll omit the instruction
    from the rewritten code ❶. As a side benefit, this will also remove any <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions that were redundant
    before we coalesced registers.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, you’ve finished your register allocator! We don’t need to change
    any other passes, so you can go ahead and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you built a register allocator. You used everything you’d already
    learned about liveness analysis to build an interference graph, and then you implemented
    a classic graph coloring algorithm to color it. You introduced callee-saved registers
    and learned how to save and restore them. Then, you used register coalescing to
    clean up the mess that earlier stages of the compiler left behind. You’ve written
    your last optimization and completed the project!
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this book, you’ve built an impressive piece of software:
    an optimizing compiler for a substantial chunk of the C language. You’ve covered
    a lot of ground, from the intricacies of the C standard to the gory details of
    the System V calling convention to the fundamentals of data-flow analysis. But
    if you want to push your compiler even further, you have plenty of options. I’ll
    close out this part of the book with a few ideas for what to work on next.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The register allocator you built in this chapter uses a simplified version of
    the classic *Chaitin-Briggs algorithm*. This section tells you where to find the
    original papers about this algorithm, a couple of textbook chapters that present
    them in a more approachable way, and some other useful references on more specific
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key papers**'
  prefs: []
  type: TYPE_NORMAL
- en: “Register Allocation via Coloring,” a 1981 paper by Gregory Chaitin et al.,
    described the original graph coloring register allocator (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1016<wbr>/0096<wbr>-0551(81)90048<wbr>-5](https://doi.org/10.1016/0096-0551(81)90048-5)*).
    It introduced most of the fundamental concepts in this chapter, including how
    to build and color an interference graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaitin published an updated description of the same allocator, “Register Allocation
    & Spilling via Graph Coloring,” in 1982 (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/872726<wbr>.806984](https://doi.org/10.1145/872726.806984)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Improvements to Graph Coloring Register Allocation,” a 1994 paper by Preston
    Briggs, Keith Cooper, and Linda Torczon, describes an improved version of Chaitin’s
    design (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/177492<wbr>.177575](https://doi.org/10.1145/177492.177575)*).
    The name *Chaitin-Briggs* refers to this improved algorithm. This paper presented
    the technique of putting spill candidates on the stack and trying to color them
    later instead of spilling them immediately. (Briggs et al. call this technique
    *optimistic coloring*.) It also introduced the Briggs test and the general concept
    of conservative coalescing; Chaitin’s original design coalesced aggressively,
    even when it made the graph harder to color. This paper described some techniques
    that we didn’t cover in this chapter, like rematerialization, as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Textbook chapters**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 16](chapter16.xhtml) of Steven Muchnick’s *Advanced Compiler Design
    and Implementation* (Morgan Kaufmann, 1997) presents a register allocator that
    uses an algorithm similar to Chaitin-Briggs. The most notable difference is that
    it doesn’t use conservative coalescing; like Chaitin’s original allocator, it
    coalesces aggressively. I found Muchnick’s explanations of how to include hard
    registers in the interference graph, how to detect interference, and the overall
    structure of the allocator especially useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 13](chapter13.xhtml) of Keith Cooper and Linda Torczon’s *Engineering
    a Compiler*, 2nd edition (Morgan Kaufmann, 2011), provides an excellent overview
    of a wide range of approaches to register allocation, including the Chaitin-Briggs
    algorithm and several others that we didn’t discuss here. I’ve drawn on their
    definition of interference and their discussion of how to update the interference
    graph while coalescing; they provide a particularly helpful explanation of why
    both fast, imprecise updates and slow, complete updates are needed. (You can also
    consult the third edition of this book, published in 2022.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*These are both good resources if you want to implement the parts of Chaitin-Briggs
    that we skipped. The chapter by Muchnick is particularly useful if you want to
    integrate spill code generation into your register allocator. Both books discuss
    how to use live ranges (which Muchnick calls* webs*) instead of pseudoregisters
    as the nodes in your interference graph, and both provide better spill cost metrics
    than the one we used.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conservative coalescing**'
  prefs: []
  type: TYPE_NORMAL
- en: The George test comes from “Iterated Register Coalescing,” by Lal George and
    Andrew Appel (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/229542<wbr>.229546](https://doi.org/10.1145/229542.229546)*).
    The main point of the paper is that you can coalesce more registers if you alternate
    between coalescing and pruning; the George test is presented as a minor implementation
    detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an informal discussion of the George and Briggs tests with lots of examples,
    see the slides from Phillip Gibbons’s course on compiler optimizations at Carnegie
    Mellon (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s19<wbr>/www<wbr>/lectures<wbr>/L23<wbr>-Register<wbr>-Coalescing<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L23-Register-Coalescing.pdf)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Comparing Conservative Coalescing Criteria” by Max Hailperin rigorously defines
    what the Briggs and George tests actually prove, which is something that the authors
    of the original papers never bothered to do (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/1065887<wbr>.1065894](https://doi.org/10.1145/1065887.1065894)*).
    My discussion of what these tests guarantee at the start of “Conservative Coalescing”
    on [page 656](#pg_656) relies heavily on Hailperin’s paper. Note that some of
    his claims don’t apply to our graph coloring implementation because he uses precoloring
    and we don’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying loops**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate more accurate spill costs, you need to detect the loops in your
    program. These resources talk about how to identify loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](chapter9.xhtml), section 6, of *Compilers: Principles, Techniques,
    and Tools*, 2nd edition, by Alfred Aho et al. (Addison-Wesley, 2006).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phillip Gibbons’s lecture slides on induction variable optimizations, from his
    Carnegie Mellon compiler optimizations course (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s19<wbr>/www<wbr>/lectures<wbr>/L8<wbr>-Induction<wbr>-Variables<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L8-Induction-Variables.pdf)*).
    This is a great starting point, but the slides aren’t detailed enough to use as
    a stand-alone guide to loop analysis. You might want to use them alongside the
    previous reference or another textbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
