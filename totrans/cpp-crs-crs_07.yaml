- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: RUNTIME POLYMORPHISM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时多态性
- en: '*One day Trurl the constructor put together a machine that could create anything
    starting with* n.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一天，构造师Trurl组装了一台能够从n开始创造任何东西的机器。*'
- en: —*Stanislaw Lem*, The Cyberiad
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —*斯坦尼斯瓦夫·莱姆*，《赛博利亚》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In this chapter, you’ll learn what polymorphism is and the problems it solves.
    You’ll then learn how to achieve runtime polymorphism, which allows you to change
    the behavior of your programs by swapping out components during program execution.
    The chapter starts with a discussion of several crucial concepts in runtime polymorphic
    code, including interfaces, object composition, and inheritance. Next, you’ll
    develop an ongoing example of logging bank transactions with multiple kinds of
    loggers. You’ll finish the chapter by refactoring this initial, naive solution
    with a more elegant, interface-based solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习什么是多态性以及它解决了哪些问题。接着，你将学习如何实现运行时多态性，这使你能够通过在程序执行期间替换组件来改变程序的行为。章初将讨论运行时多态性代码中的几个关键概念，包括接口、对象组合和继承。然后，你将开发一个持续的示例，展示如何使用多种类型的日志记录器记录银行交易。最后，你将通过使用更优雅的基于接口的解决方案来重构这个初始的、幼稚的解决方案。
- en: Polymorphism
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态性
- en: '*Polymorphic code* is code you write once and can reuse with different types.
    Ultimately, this flexibility yields loosely coupled and highly reusable code.
    It eliminates tedious copying and pasting, making your code more maintainable
    and readable.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*多态代码*是你只需编写一次，便可与不同类型一起重用的代码。最终，这种灵活性带来了松耦合和高度可重用的代码。它消除了繁琐的复制和粘贴，使代码更加易于维护和可读。'
- en: C++ offers two polymorphic approaches. *Compile-time polymorphic code* incorporates
    polymorphic types you can determine at compile time. The other approach is *runtime
    polymorphism*, which instead incorporates types determined at runtime. Which approach
    you choose depends on whether you know the types you want to use with your polymorphic
    code at compile time or at runtime. Because these closely related topics are fairly
    involved, they’re separated into two chapters. [Chapter 6](ch06.xhtml#ch06) will
    focus on compile-time polymorphism.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了两种多态方法。*编译时多态代码*包含了可以在编译时确定的多态类型。另一种方法是*运行时多态性*，它则包含了在运行时确定的类型。你选择哪种方法取决于你是否知道要在编译时还是运行时使用的多态类型。由于这些紧密相关的主题涉及较多内容，因此被分为两章进行讲解。[第6章](ch06.xhtml#ch06)将重点讨论编译时多态性。
- en: A Motivating Example
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个激励示例
- en: Suppose you’re in charge of implementing a `Bank` class that transfers money
    between accounts. Auditing is very important for the `Bank` class’s transactions,
    so you provide support for logging with a `ConsoleLogger` class, as shown in [Listing
    5-1](ch05.xhtml#ch05ex01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责实现一个`Bank`类，该类用于在账户之间转账。审计对`Bank`类的交易非常重要，因此你提供了通过`ConsoleLogger`类支持日志记录，如[示例
    5-1](ch05.xhtml#ch05ex01)所示。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: A `ConsoleLogger` and a `Bank` class that uses it*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-1：一个使用`ConsoleLogger`的`Bank`类*'
- en: First, you implement `ConsoleLogger` with a `log_transfer` method ➊, which accepts
    the details of a transaction (sender, recipient, amount) and prints them ➋. The
    `Bank` class has the `make_transfer` method ➌, which (notionally) processes the
    transaction ➍ and then uses the `logger` member ➎ to log the transaction. The
    `Bank` and the `ConsoleLogger` have separate concerns—the `Bank` deals with bank
    logic, and the `ConsoleLogger` deals with logging.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你实现了一个`ConsoleLogger`，其中包含一个`log_transfer`方法➊，该方法接受交易的详细信息（发送者、接收者、金额）并打印出来➋。`Bank`类有一个`make_transfer`方法➌，该方法（概念上）处理交易➍，然后使用`logger`成员➎记录交易。`Bank`和`ConsoleLogger`有各自不同的关注点——`Bank`处理银行逻辑，`ConsoleLogger`处理日志记录。
- en: Suppose you have a requirement to implement different kinds of loggers. For
    example, you might require a remote server logger, a local file logger, or even
    a logger that sends jobs to a printer. In addition, you must be able to change
    how the program logs at runtime (for example, an administrator might need to switch
    from logging over the network to logging to the local filesystem because of some
    server maintenance).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要实现不同类型的日志记录器。例如，你可能需要一个远程服务器日志记录器，一个本地文件日志记录器，或者甚至一个将作业发送到打印机的日志记录器。此外，你还必须能够在运行时更改程序的日志记录方式（例如，管理员可能需要将日志记录从网络日志切换到本地文件系统日志，因为某些服务器维护）。
- en: How can you accomplish such a task?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何完成这样的任务？
- en: A simple approach is to use an `enum` `class` to switch between the various
    loggers. [Listing 5-2](ch05.xhtml#ch05ex02) adds a `FileLogger` to [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是使用`enum` `class`在各种日志记录器之间切换。[清单 5-2](ch05.xhtml#ch05ex02)为[清单 5-1](ch05.xhtml#ch05ex01)添加了一个`FileLogger`。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: An updated [Listing 5-1](ch05.xhtml#ch05ex01) with a runtime
    polymorphic logger*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：一个更新后的[清单 5-1](ch05.xhtml#ch05ex01)，具有运行时多态的日志记录器*'
- en: You (notionally) add the ability to log to a file ➊ by implementing a `FileLogger`.
    You also create an `enum class LoggerType` ➋ so you can switch logging behavior
    at runtime. You initialize the type field to `Console` within the `Bank` constructor
    ➌. Within the updated `Bank` class, you add a `set_logger` function ➍ to perform
    the desired logging behavior. You use the `type` within `make_transfer` to `switch`
    on the correct logger ➎. To alter a `Bank` class’s logging behavior, you use the
    `set_logger` method ➏, and the object handles dispatching internally.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你（理论上）通过实现一个`FileLogger`来添加日志到文件的能力 ➊。你还创建了一个`enum class LoggerType` ➋，这样你就可以在运行时切换日志记录行为。你在`Bank`构造函数中将类型字段初始化为`Console`
    ➌。在更新后的`Bank`类中，你添加了一个`set_logger`函数 ➍来执行所需的日志记录行为。你在`make_transfer`中使用`type`来`switch`到正确的日志记录器
    ➎。要更改`Bank`类的日志记录行为，你可以使用`set_logger`方法 ➏，对象会在内部处理分派。
- en: '***Adding New Loggers***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加新的日志记录器***'
- en: '[Listing 5-2](ch05.xhtml#ch05ex02) works, but this approach suffers from several
    design problems. Adding a new kind of logging requires you to make several updates
    throughout the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-2](ch05.xhtml#ch05ex02)是有效的，但这种方法存在一些设计问题。添加新的日志记录类型需要你在代码中进行多次更新：'
- en: You need to write a new logger type.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要编写一个新的日志记录器类型。
- en: You need to add a new `enum` value to the `enum class LoggerType`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要向`enum class LoggerType`添加一个新的`enum`值。
- en: You must add a new case in the `switch` statement ➎.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须在`switch`语句中添加一个新的案例 ➎。
- en: You must add the new logging class as a member to `Bank`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须将新的日志记录类作为成员添加到`Bank`中。
- en: That’s a lot of work for a simple change!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的更改来说，这可真是很多工作！
- en: 'Consider an alternative approach where `Bank` holds a pointer to a logger.
    This way, you can set the pointer directly and get rid of `LoggerType` entirely.
    You exploit the fact that your loggers have the same function prototype. This
    is the idea behind an interface: the `Bank` class doesn’t need to know the implementation
    details of the `Logger` reference it holds, just how to invoke its methods.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种替代方法，让`Bank`持有一个指向日志记录器的指针。这样，你可以直接设置指针，完全去除`LoggerType`。你利用了所有日志记录器具有相同函数原型的事实。这就是接口的思想：`Bank`类不需要知道它持有的`Logger`引用的实现细节，只需要知道如何调用其方法。
- en: Wouldn’t it be nice if we could swap out the `ConsoleLogger` for another type
    that supports the same operations? Say, a `FileLogger`?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以将`ConsoleLogger`替换为另一个支持相同操作的类型，岂不是很好吗？比如一个`FileLogger`？
- en: Allow me to introduce you to the *interface*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我向你介绍*接口*。
- en: '***Interfaces***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***接口***'
- en: In software engineering, an *interface* is a shared boundary that contains no
    data or code. It defines function signatures that all implementations of the interface
    agree to support. An *implementation* is code or data that declares support for
    an interface. You can think of an interface as a contract between classes that
    implement the interface and users (also called *consumers*) of that class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，*接口*是一个不包含数据或代码的共享边界。它定义了所有接口实现都同意支持的函数签名。*实现*是声明支持接口的代码或数据。你可以把接口看作是实现接口的类与该类的用户（也叫*消费者*）之间的契约。
- en: Consumers know how to use implementations because they know the contract. In
    fact, the consumer never needs to know the underlying implementation type. For
    example, in [Listing 5-1](ch05.xhtml#ch05ex01) `Bank` is a consumer of `ConsoleLogger`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者知道如何使用实现，因为他们知道契约。实际上，消费者从不需要知道底层实现类型。例如，在[清单 5-1](ch05.xhtml#ch05ex01)中，`Bank`是`ConsoleLogger`的消费者。
- en: Interfaces impose stringent requirements. A consumer of an interface can use
    only the methods explicitly defined in the interface. The `Bank` class doesn’t
    need to know anything about how `ConsoleLogger` performs its function. All it
    needs to know is how to call the `log_transfer` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接口强加了严格的要求。接口的消费者只能使用接口中明确定义的方法。`Bank`类不需要知道`ConsoleLogger`是如何执行其功能的。它只需要知道如何调用`log_transfer`方法。
- en: Interfaces promote highly reusable and loosely coupled code. You can understand
    the notation for specifying an interface, but you’ll need to know a bit about
    object composition and implementation inheritance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接口促进了高度可重用且松耦合的代码。你可以理解指定接口的符号，但你需要了解一些关于对象组合和实现继承的知识。
- en: '***Object Composition and Implementation Inheritance***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***对象组合与实现继承***'
- en: '*Object composition* is a design pattern where a class contains members of
    other class types. An alternate, antiquated design pattern called *implementation
    inheritance* achieves runtime polymorphism. Implementation inheritance allows
    you to build hierarchies of classes; each child inherits functionality from its
    parents. Over the years, accumulated experience with implementation inheritance
    has convinced many that it’s an anti-pattern. For example, Go and Rust—two new
    and increasingly popular system-programming languages—have zero support for implementation
    inheritance. A brief discussion of implementation inheritance is warranted for
    two reasons:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象组合*是一种设计模式，其中一个类包含其他类类型的成员。另一种过时的设计模式叫做 *实现继承*，它实现了运行时多态性。实现继承允许你构建类的层次结构，每个子类从其父类继承功能。多年来，积累的实现继承经验使得许多人认为它是一种反模式。例如，Go
    和 Rust——两种新兴且越来越受欢迎的系统编程语言——完全不支持实现继承。由于两个原因，简要讨论实现继承是必要的：'
- en: You might encounter it infecting legacy code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会在遗留代码中遇到它。
- en: The quirky way you define C++ interfaces has a shared lineage with implementation
    inheritance, so you’ll be familiar with the mechanics anyway.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你定义 C++ 接口的独特方式与实现继承有共同的血脉，因此你会熟悉这些机制。
- en: '**NOTE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re dealing with implementation inheritance–laden C++ code, see [Chapters
    20](ch20.xhtml#ch20) and [21](ch21.xhtml#ch21) of* The C++ Programming Language,
    *4th Edition, by Bjarne Stroustrup*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在处理充满实现继承的 C++ 代码，请参阅* 《C++程序设计语言》第四版，Bjarne Stroustrup 著，第[20章](ch20.xhtml#ch20)和[21章](ch21.xhtml#ch21)。'
- en: '**Defining Interfaces**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义接口**'
- en: Unfortunately, there’s no `interface` keyword in C++. You have to define interfaces
    using antiquated inheritance mechanisms. This is just one of those archaisms you
    have to deal with when programming in a 40+ year-old language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++ 中没有 `interface` 关键字。你必须使用过时的继承机制来定义接口。这只是你在编程这个已有40多年历史的语言时必须应对的一个古老遗留问题。
- en: '[Listing 5-3](ch05.xhtml#ch05ex03) illustrates a fully specified `Logger` interface
    and a corresponding `ConsoleLogger` that implements the interface. At least four
    constructions in [Listing 5-3](ch05.xhtml#ch05ex03) will be unfamiliar to you,
    and this section covers each of them.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-3](ch05.xhtml#ch05ex03) 展示了一个完全指定的 `Logger` 接口以及一个实现该接口的相应 `ConsoleLogger`。在
    [列表 5-3](ch05.xhtml#ch05ex03) 中至少有四种构造方式对你来说是陌生的，本节将逐一讲解这些内容。'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: A `Logger` interface and a refactored `ConsoleLogger`*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：一个 `Logger` 接口和一个重构的 `ConsoleLogger`*'
- en: To parse [Listing 5-3](ch05.xhtml#ch05ex03), you’ll need to understand the `virtual`
    keyword ➊, the virtual destructor ➋, the `=0` suffix and pure-virtual methods
    ➌, base class inheritance ➍, and the `override` keyword ➎. Once you understand
    these, you’ll know how to define an interface. The sections that follow discuss
    these concepts in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析 [列表 5-3](ch05.xhtml#ch05ex03)，你需要了解 `virtual` 关键字 ➊、虚拟析构函数 ➋、`=0` 后缀和纯虚方法
    ➌、基类继承 ➍，以及 `override` 关键字 ➎。理解这些后，你将知道如何定义一个接口。接下来的章节将详细讨论这些概念。
- en: '***Base Class Inheritance***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基类继承***'
- en: '[Chapter 4](ch04.xhtml) delved into how the `exception` class is the base class
    for all other stdlib exceptions and how the `logic_error` and `runtime_error`
    classes derived from `exception`. These two classes, in turn, form the base classes
    for other derived classes that describe error conditions in even greater detail,
    such as `invalid_argument` and `system_error`. Nested exception classes form an
    example of a class hierarchy and represent an implementation inheritance design.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.xhtml)深入探讨了 `exception` 类是所有其他标准库异常的基类，以及 `logic_error` 和 `runtime_error`
    类是如何从 `exception` 类派生出来的。这两个类反过来又成为描述更详细错误条件的其他派生类的基类，例如 `invalid_argument` 和
    `system_error`。嵌套的异常类形成了一个类层次结构的示例，并代表了一种实现继承设计。'
- en: 'You declare derived classes using the following syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用以下语法声明派生类：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To define an inheritance relationship for `DerivedClass`, you use a colon (`:`)
    followed by the name of the base class, `BaseClass`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `DerivedClass` 定义继承关系，你使用冒号（`:`）后跟基类的名称 `BaseClass`。
- en: Derived classes are declared just like any other class. The benefit is that
    you can treat derived class references as if they were of base class reference
    type. [Listing 5-4](ch05.xhtml#ch05ex04) uses a `DerivedClass` reference in place
    of a `BaseClass` reference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类的声明方式与其他类相同。其好处在于你可以将派生类的引用当作基类引用类型来使用。[列表 5-4](ch05.xhtml#ch05ex04)中用`DerivedClass`引用替代了`BaseClass`引用。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-4: A program using a derived class in place of a base class*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：用派生类替代基类的程序*'
- en: The `DerivedClass` ➋ derives from `BaseClass` ➊. The `are_belong_to_us` function
    takes a reference-to-`BaseClass` argument `base` ➌. You can invoke it with an
    instance of a `DerivedClass` because `DerivedClass` derives from `BaseClass` ➍.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`DerivedClass` ➋继承自`BaseClass` ➊。`are_belong_to_us`函数接受一个指向`BaseClass`的引用参数`base`
    ➌。由于`DerivedClass`继承自`BaseClass` ➍，因此你可以用`DerivedClass`的实例来调用它。'
- en: The opposite is not true. [Listing 5-5](ch05.xhtml#ch05ex05) attempts to use
    a base class in place of a derived class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的情况并不成立。[列表 5-5](ch05.xhtml#ch05ex05)尝试用基类替代派生类。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-5: This program attempts to use a base class in place of a derived
    class. (This listing won’t compile.)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：该程序尝试用基类替代派生类。（此列表无法编译。）*'
- en: Here, `BaseClass` ➊ doesn’t derive from `DerivedClass` ➋. (The inheritance relationship
    is the other way around.) The `all_about_that` function takes a `DerivedClass`
    argument ➌. When you attempt to invoke `all_about_that` with a `BaseClass` ➍,
    the compiler yields an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BaseClass` ➊并没有继承自`DerivedClass` ➋。（继承关系是相反的。）`all_about_that`函数接受一个`DerivedClass`类型的参数
    ➌。当你尝试用`BaseClass` ➍来调用`all_about_that`时，编译器会报错。
- en: The main reason you’d want to derive from a class is to inherit its members.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望从类中派生的主要原因是为了继承其成员。
- en: '***Member Inheritance***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员继承***'
- en: Derived classes inherit non-private members from their base classes. Classes
    can use inherited members just like normal members. The supposed benefit of member
    inheritance is that you can define functionality once in a base class and not
    have to repeat it in the derived classes. Unfortunately, experience has convinced
    many in the programming community to avoid member inheritance because it can easily
    yield brittle, hard-to-reason-about code compared to composition-based polymorphism.
    (This is why so many modern programming languages exclude it.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类继承自基类的非私有成员。类可以像使用普通成员一样使用继承的成员。成员继承的预期好处是，你可以在基类中定义功能，而不必在派生类中重复它。不幸的是，经验使得许多程序员社区的人避免使用成员继承，因为它相比基于组合的多态性，更容易导致脆弱、难以理解的代码。（这也是为什么许多现代编程语言排除了成员继承。）
- en: The class in [Listing 5-6](ch05.xhtml#ch05ex06) illustrates member inheritance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-6](ch05.xhtml#ch05ex06)中的类展示了成员继承。'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-6: A program using inherited members*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：使用继承成员的程序*'
- en: Here, `BaseClass` has a public method ➊, a public field ➋, and a private field
    ➌. You declare a `DerivedClass` deriving from `BaseClass` ➍ and then use it in
    `main`. Because they’re inherited as public members, `the_answer` ➏ and `member`
    ➐ are available on the `DerivedClass x`. However, uncommenting ➎ yields a compiler
    error because `holistic_detective` is private and thus not inherited by derived
    classes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BaseClass`有一个公共方法 ➊，一个公共字段 ➋，以及一个私有字段 ➌。你声明一个`DerivedClass`继承自`BaseClass`
    ➍，然后在`main`中使用它。由于它们作为公共成员被继承，`the_answer` ➏和`member` ➐可以在`DerivedClass x`上访问。然而，取消注释
    ➎ 会导致编译错误，因为`holistic_detective`是私有的，因此不会被派生类继承。
- en: '***virtual Methods***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚方法***'
- en: If you want to permit a derived class to override a base class’s methods, you
    use the `virtual` keyword. By adding `virtual` to a method’s definition, you declare
    that a derived class’s implementation should be used if one is supplied. Within
    the implementation, you add the `override` keyword to the method’s declaration,
    as demonstrated in [Listing 5-7](ch05.xhtml#ch05ex07).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望允许派生类重写基类的方法，可以使用`virtual`关键字。通过在方法定义中添加`virtual`，你声明如果派生类提供了实现，则使用派生类的实现。在实现中，你需要在方法声明中添加`override`关键字，如[列表
    5-7](ch05.xhtml#ch05ex07)所示。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-7: A program using virtual members*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：使用虚拟成员的程序*'
- en: The `BaseClass` contains a virtual member ➊. In the `DerivedClass` ➋, you override
    the inherited member and use the `override` keyword ➌. The implementation of `BaseClass`
    is used only when a `BaseClass` instance is at hand ➍. The implementation of `DerivedClass`
    is used when a `DerivedClass` instance is at hand ➎, even if you’re interacting
    with it through a `BaseClass` reference ➏.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseClass`包含一个虚拟成员 ➊。在`DerivedClass`中 ➋，你重写了继承的成员，并使用了`override`关键字 ➌。当手头是`BaseClass`实例时，使用的是`BaseClass`的实现
    ➍。当手头是`DerivedClass`实例时，即使你通过`BaseClass`引用来操作，它依然使用的是`DerivedClass`的实现 ➎。'
- en: If you want to *require* a derived class to implement the method, you can append
    the `=0` suffix to a method definition. You call methods with both the `virtual`
    keyword and `=0` suffix pure virtual methods. You can’t instantiate a class containing
    any pure virtual methods. In [Listing 5-8](ch05.xhtml#ch05ex08), consider the
    refactor of [Listing 5-7](ch05.xhtml#ch05ex07) that uses a pure virtual method
    in the base class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想*要求*派生类实现某个方法，可以在方法定义后加上`=0`后缀。你用`virtual`关键字和`=0`后缀来标记纯虚方法。含有任何纯虚方法的类无法被实例化。在[Listing
    5-8](ch05.xhtml#ch05ex08)中，考虑基类使用纯虚方法的重构，这与[Listing 5-7](ch05.xhtml#ch05ex07)相似。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-8: A refactor of [Listing 5-7](ch05.xhtml#ch05ex07) using a pure
    virtual method*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-8: 使用纯虚方法重构[Listing 5-7](ch05.xhtml#ch05ex07)的示例*'
- en: The `=0` suffix specifies a pure virtual method ➊, meaning you can’t instantiate
    a `BaseClass`—only derive from it. `DerivedClass` still derives from `BaseClass`
    ➋, and you provide the requisite `final_message` ➌. Attempting to instantiate
    a `BaseClass` would result in a compiler error ➍. Both `DerivedClass` and the
    `BaseClass` reference behave as before ➎➏.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`=0`后缀指定了一个纯虚方法 ➊，这意味着你不能实例化`BaseClass`——只能从它派生。`DerivedClass`仍然继承自`BaseClass`
    ➋，并且你提供了必需的`final_message` ➌。试图实例化`BaseClass`会导致编译错误 ➍。`DerivedClass`和`BaseClass`引用的行为和之前一样
    ➎➏。'
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Virtual functions can incur runtime overhead, although the cost is typically
    low (within 25 percent of a regular function call). The compiler generates* virtual
    function tables (vtables) *that contain function pointers. At runtime, a consumer
    of an interface doesn’t generally know its underlying type, but it knows how to
    invoke the interface’s methods (thanks to the vtable). In some circumstances,
    the linker can detect all uses of an interface and* devirtualize *a function call.
    This removes the function call from the vtable and thus eliminates associated
    runtime cost*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚函数可能会带来运行时开销，尽管成本通常较低（通常在常规函数调用的25%以内）。编译器会生成* 虚函数表（vtables）*，其中包含函数指针。在运行时，接口的消费者通常并不知道其底层类型，但它知道如何调用接口的方法（这要归功于vtable）。在某些情况下，链接器可以检测到所有接口的使用并*
    去虚拟化*函数调用。这会将函数调用从vtable中移除，从而消除相关的运行时开销*。'
- en: '***Pure-Virtual Classes and Virtual Destructors***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***纯虚类和虚析构函数***'
- en: You achieve interface inheritance through deriving from base classes that contain
    only pure-virtual methods. Such classes are referred to as *pure-virtual classes*.
    In C++, interfaces are always pure-virtual classes. Usually, you add virtual destructors
    to interfaces. In some rare circumstances, it’s possible to leak resources if
    you fail to mark destructors as virtual. Consider [Listing 5-9](ch05.xhtml#ch05ex09),
    which illustrates the danger of not adding a virtual destructor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从只包含纯虚方法的基类派生来实现接口继承。这类类被称为*纯虚类*。在C++中，接口总是纯虚类。通常，你会为接口添加虚拟析构函数。在一些罕见的情况下，如果没有将析构函数标记为虚拟函数，可能会导致资源泄漏。参见[Listing
    5-9](ch05.xhtml#ch05ex09)，该示例说明了未添加虚拟析构函数的危险。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-9: An example illustrating the dangers of non-virtual destructors
    in base classes*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9: 说明基类中非虚析构函数危险性的示例*'
- en: Here you see a `DerivedClass` deriving from `BaseClass` ➊. This class has a
    constructor ➋ and destructor ➌ that print when they’re invoked. Within `main`,
    you allocate and initialize a `DerivedClass` with `new` and set the result to
    a `BaseClass` pointer ➍. When you `delete` the pointer ➎, the `BaseClass` destructor
    gets invoked, but the `DerivedClass` destructor doesn’t!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你看到一个`DerivedClass`类继承自`BaseClass` ➊。这个类有一个构造函数 ➋ 和析构函数 ➌，它们在被调用时会打印信息。在`main`函数中，你通过`new`分配并初始化一个`DerivedClass`，并将结果赋值给一个`BaseClass`指针
    ➍。当你`delete`这个指针 ➎时，`BaseClass`的析构函数会被调用，但`DerivedClass`的析构函数不会被调用！
- en: Adding virtual to the `BaseClass` destructor solves the problem, as demonstrated
    in [Listing 5-10](ch05.xhtml#ch05ex10).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为`BaseClass`的析构函数添加虚拟关键字可以解决这个问题，正如[Listing 5-10](ch05.xhtml#ch05ex10)所示。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-10: A refactor of [Listing 5-9](ch05.xhtml#ch05ex09) with a virtual
    destructor*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：对[列表 5-9](ch05.xhtml#ch05ex09)的重构，带虚拟析构函数*'
- en: Adding the virtual destructor ➊ causes the `DerivedClass` destructor to get
    invoked when you delete the `BaseClass` pointer ➌, which results in the `DerivedClass`
    destructor printing the message ➋.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 添加虚拟析构函数➊会导致在删除`BaseClass`指针➌时调用`DerivedClass`的析构函数，从而导致`DerivedClass`的析构函数打印消息➋。
- en: Declaring a virtual destructor is optional when declaring an interface, but
    beware. If you forget that you haven’t implemented a virtual destructor in the
    interface and accidentally do something like [Listing 5-9](ch05.xhtml#ch05ex09),
    you can leak resources, and the compiler won’t warn you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明接口时声明虚拟析构函数是可选的，但要小心。如果你忘记在接口中实现虚拟析构函数，并不小心做了类似[列表 5-9](ch05.xhtml#ch05ex09)的操作，你可能会泄漏资源，并且编译器不会警告你。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Declaring a protected non-virtual destructor is a good alternative to declaring
    a public virtual destructor because it will cause a compilation error when writing
    code that deletes a base class pointer. Some don’t like this approach because
    you eventually have to make a class with a public destructor, and if you derive
    from that class, you run into the same issues.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明一个受保护的非虚拟析构函数是声明一个公共虚拟析构函数的一个不错替代方案，因为它会在编写删除基类指针的代码时导致编译错误。有些人不喜欢这种方法，因为最终你必须创建一个具有公共析构函数的类，如果你从这个类派生，就会遇到相同的问题。*'
- en: '***Implementing Interfaces***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现接口***'
- en: To declare an interface, declare a pure virtual class. To implement an interface,
    derive from it. Because the interface is pure virtual, an implementation must
    implement all of the interface’s methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个接口，声明一个纯虚类。要实现一个接口，必须从它派生。因为接口是纯虚的，所有实现都必须实现接口的所有方法。
- en: It’s good practice to mark these methods with the `override` keyword. This communicates
    that you intend to override a virtual function, allowing the compiler to save
    you from simple mistakes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 标记这些方法时使用`override`关键字是一个好习惯。这表明你打算重写一个虚拟函数，让编译器帮助你避免一些简单的错误。
- en: '***Using Interfaces***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用接口***'
- en: 'As a consumer, you can only deal in references or pointers to interfaces. The
    compiler cannot know ahead of time how much memory to allocate for the underlying
    type: if the compiler could know the underlying type, you would be better off
    using templates.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为消费者，你只能处理接口的引用或指针。编译器无法预先知道为底层类型分配多少内存：如果编译器能够知道底层类型，你最好使用模板。
- en: 'There are two options for how to set the member:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 设置成员有两种选择：
- en: '**Constructor injection** With constructor injection, you typically use an
    interface reference. Because references cannot be reseated, they won’t change
    for the lifetime of the object.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数注入** 使用构造函数注入时，通常使用接口引用。因为引用不能重新绑定，它们在对象的生命周期内不会改变。'
- en: '**Property injection** With property injection, you use a method to set a pointer
    member. This allows you to change the object to which the member points.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性注入** 使用属性注入时，你通过一个方法来设置指针成员。这样可以改变该成员指向的对象。'
- en: You can combine these approaches by accepting an interface pointer in a constructor
    while also providing a method to set the pointer to something else.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在构造函数中接受一个接口指针，同时提供一个方法来将指针设置为其他对象，从而结合这些方法。
- en: Typically, you’ll use constructor injection when the injected field won’t change
    throughout the lifetime of the object. If you need the flexibility of modifying
    the field, you’ll provide methods to perform property injection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当注入的字段在对象的生命周期内不会改变时，你会使用构造函数注入。如果你需要更改该字段的灵活性，你将提供方法来执行属性注入。
- en: '**Updating the Bank Logger**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更新银行日志记录器**'
- en: The `Logger` interface allows you to provide multiple logger implementations.
    This allows a `Logger` consumer to log transfers with the `log_transfer` method
    without having to know the logger’s implementation details. You’ve already implemented
    a `ConsoleLogger` in [Listing 5-2](ch05.xhtml#ch05ex02), so let’s consider how
    you can add another implementation called `FileLogger`. For simplicity, in this
    code you’ll only modify the log output’s prefix, but you can imagine how you might
    implement some more complicated behavior.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`接口允许你提供多个日志记录实现。这允许`Logger`消费者使用`log_transfer`方法记录转账日志，而不需要知道日志记录的实现细节。你已经在[列表
    5-2](ch05.xhtml#ch05ex02)中实现了`ConsoleLogger`，接下来让我们看看如何添加另一个名为`FileLogger`的实现。为了简便起见，在这个代码中，你只修改了日志输出的前缀，但你可以想象如何实现一些更复杂的行为。'
- en: '[Listing 5-11](ch05.xhtml#ch05ex11) defines a `FileLogger`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](ch05.xhtml#ch05ex11) 定义了一个 `FileLogger`。'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-11: `Logger`, `ConsoleLogger`, and `FileLogger`*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：`Logger`，`ConsoleLogger` 和 `FileLogger`*'
- en: '`Logger` is a pure virtual class (interface) with a default virtual destructor
    ➊ and a single method `log_transfer` ➋. `ConsoleLogger` and `FileLogger` are `Logger`
    implementations, because they derive from the interface ➌➎. You’ve implemented
    `log_transfer` and placed the `override` keyword on both ➍➏.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger` 是一个纯虚类（接口），具有默认的虚析构函数 ➊ 和一个方法 `log_transfer` ➋。`ConsoleLogger` 和 `FileLogger`
    是 `Logger` 的实现，因为它们从该接口派生 ➌➎。你已经实现了 `log_transfer` 并在两者上放置了 `override` 关键字 ➍➏。'
- en: Now we’ll look at how you could use either constructor injection or property
    injection to update `Bank`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何使用构造函数注入或属性注入来更新 `Bank`。
- en: '***Constructor Injection***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造函数注入***'
- en: Using constructor injection, you have a `Logger` reference that you pass into
    the `Bank` class’s constructor. [Listing 5-12](ch05.xhtml#ch05ex12) adds to [Listing
    5-11](ch05.xhtml#ch05ex11) by incorporating the appropriate `Bank` constructor.
    This way, you establish the kind of logging that a particular `Bank` instantiation
    will perform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数注入，你有一个 `Logger` 引用，并将其传入 `Bank` 类的构造函数。[列表 5-12](ch05.xhtml#ch05ex12)
    在 [列表 5-11](ch05.xhtml#ch05ex11) 的基础上，添加了适当的 `Bank` 构造函数。这样，你可以确定特定 `Bank` 实例化时将执行的日志记录类型。
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-12: Refactoring [Listing 5-2](ch05.xhtml#ch05ex02) using constructor
    injection, interfaces, and object composition to replace the clunky `enum class`
    approach*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：使用构造函数注入、接口和对象组合重构[列表 5-2](ch05.xhtml#ch05ex02)，以取代笨重的 `enum class`
    方法*'
- en: The `Bank` class’s constructor sets the value of `logger` using a member initializer
    ➊. References can’t be reseated, so the object that `logger` points to doesn’t
    change for the lifetime of `Bank`. You fix your logger choice upon `Bank` construction
    ➋.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bank` 类的构造函数使用成员初始化器 ➊ 设置 `logger` 的值。引用不能重新赋值，因此 `logger` 所指向的对象在 `Bank`
    生命周期内不会改变。你在 `Bank` 构造时就确定了日志记录器的选择 ➋。'
- en: '***Property Injection***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***属性注入***'
- en: Instead of using constructor injection to insert a `Logger` into a `Bank`, you
    could use property injection. This approach uses a pointer instead of a reference.
    Because pointers can be reseated (unlike references), you can change the behavior
    of `Bank` whenever you like. [Listing 5-13](ch05.xhtml#ch05ex13) is a property-injected
    variant of [Listing 5-12](ch05.xhtml#ch05ex12).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择使用属性注入来将 `Logger` 插入到 `Bank` 中，而不是使用构造函数注入。这种方法使用指针而不是引用。因为指针可以重新赋值（与引用不同），你可以随时更改
    `Bank` 的行为。[列表 5-13](ch05.xhtml#ch05ex13) 是 [列表 5-12](ch05.xhtml#ch05ex12) 的属性注入变体。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-13: Refactoring [Listing 5-12](ch05.xhtml#ch05ex12) using property
    injection*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：使用属性注入重构[列表 5-12](ch05.xhtml#ch05ex12)*'
- en: The `set_logger` method enables you to inject a new logger into a `Bank` object
    at any point during the life cycle. When you set the logger to a `ConsoleLogger`
    instance ➊, you get a `[cons]` prefix on the logging output ➋. When you set the
    logger to a `FileLogger` instance ➌, you get a `[file]` prefix ➍.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_logger` 方法使你能够在 `Bank` 对象的生命周期中的任何时刻注入新的日志记录器。当你将日志记录器设置为 `ConsoleLogger`
    实例 ➊ 时，你会在日志输出中得到一个 `[cons]` 前缀 ➋。当你将日志记录器设置为 `FileLogger` 实例 ➌ 时，你会得到一个 `[file]`
    前缀 ➍。'
- en: '***Choosing Constructor or Property Injection***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择构造函数注入或属性注入***'
- en: 'Whether you choose constructor or property injection depends on design requirements.
    If you need to be able to modify underlying types of an object’s members throughout
    the object''s life cycle, you should choose pointers and the property injector
    method. But the flexibility of using pointers and property injection comes at
    a cost. In the `Bank` example in this chapter, you must make sure that you either
    don’t set `logger` to `nullptr` or that you check for this condition before using
    `logger`. There’s also the question of what the default behavior is: what is the
    initial value of `logger`?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择构造函数注入还是属性注入，取决于设计需求。如果你需要能够在对象生命周期内修改对象成员的基础类型，你应该选择指针和属性注入方法。但使用指针和属性注入的灵活性是有代价的。在本章中的
    `Bank` 示例中，你必须确保不要将 `logger` 设置为 `nullptr`，或者在使用 `logger` 之前检查这个条件。还有一个问题是默认行为是什么：`logger`
    的初始值是多少？
- en: One possibility is to provide constructor and property injection. This encourages
    anyone who uses your class to think about initializing it. [Listing 5-14](ch05.xhtml#ch05ex14)
    illustrates one way to implement this strategy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的做法是提供构造函数注入和属性注入。这鼓励任何使用你的类的人考虑如何初始化它。[列表 5-14](ch05.xhtml#ch05ex14) 说明了实现这种策略的一种方式。
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-14: A refactor of the `Bank` to include constructor and property
    injection*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 5-14：对 `Bank` 的重构，包含构造函数和属性注入*'
- en: As you can see, you can include a constructor ➊ and a setter ➋. This requires
    the user of a `Bank` to initialize logger with a value, even if it’s just `nullptr`.
    Later on, the user can easily swap out this value using property injection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以包括一个构造函数 ➊ 和一个 setter ➋。这要求 `Bank` 的用户初始化日志记录器，哪怕是 `nullptr`。之后，用户可以通过属性注入轻松更换这个值。
- en: '**Summary**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to define interfaces, the central role that
    virtual functions play in making inheritance work, and some general rules for
    using constructor and property injectors. Whichever approach you choose, the combination
    of interface inheritance and composition provides sufficient flexibility for most
    runtime polymorphic applications. You can achieve type-safe runtime polymorphism
    with little or no overhead. Interfaces encourage encapsulation and loosely coupled
    design. With simple, focused interfaces, you can encourage code reuse by making
    your code portable across projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何定义接口、虚函数在使继承有效方面扮演的核心角色，以及一些使用构造函数和属性注入器的通用规则。无论你选择哪种方法，接口继承与组合的结合为大多数运行时多态应用提供了足够的灵活性。你可以以几乎没有开销的方式实现类型安全的运行时多态性。接口鼓励封装和松耦合设计。通过简单、专注的接口，你可以通过使代码跨项目可移植，来促进代码重用。
- en: '**EXERCISES**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**5-1.** You didn’t implement an accounting system in your `Bank`. Design an
    interface called `AccountDatabase` that can retrieve and set amounts in bank accounts
    (identified by a `long` id).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**5-1.** 你没有在你的 `Bank` 中实现一个会计系统。设计一个名为 `AccountDatabase` 的接口，能够在银行账户中获取和设置金额（通过
    `long` 类型的 id 来标识账户）。'
- en: '**5-2.** Generate an `InMemoryAccountDatabase` that implements `AccountDatabase`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**5-2.** 生成一个实现了 `AccountDatabase` 的 `InMemoryAccountDatabase`。'
- en: '**5-3.** Add an `AccountDatabase` reference member to `Bank`. Use constructor
    injection to add an `InMemoryAccountDatabase` to the `Bank`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**5-3.** 在 `Bank` 中添加一个 `AccountDatabase` 引用成员。使用构造函数注入将 `InMemoryAccountDatabase`
    添加到 `Bank`。'
- en: '**5-4.** Modify `ConsoleLogger` to accept a `const char*` at construction.
    When `ConsoleLogger` logs, prepend this string to the logging output. Notice that
    you can modify logging behavior without having to modify `Bank`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**5-4.** 修改 `ConsoleLogger` 以接受一个 `const char*` 类型的参数进行构造。当 `ConsoleLogger`
    进行日志记录时，将该字符串添加到日志输出的前面。注意，你可以在不修改 `Bank` 的情况下修改日志记录行为。'
- en: '**FURTHER READING**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*API Design for C++* by Martin Reddy (Elsevier, 2011)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ API 设计* 作者：Martin Reddy（Elsevier，2011）'
