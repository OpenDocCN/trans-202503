- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE REACTION-TIME MACHINE**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I will show you how to build a time machine—that is, a Reaction-Time
    Machine. I’d love to say that this project will bring you “back to the future,”
    but alas, it won’t. The “time” it’s looking at is the time it takes you to react
    to a stimulus, which makes for a fun game. This project is designed to accurately
    measure an individual’s reaction time and provide an area for comments on the
    level of the individual’s performance (see [Figure 1-1](ch01.xhtml#ch01fig1)).
    There is also plenty of room to personalize the game to make it even more fun
    for you, your friends, and your family.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Completed Reaction-Time Machine*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Soldering iron and solder
  prefs: []
  type: TYPE_NORMAL
- en: Drill and drill bits
  prefs: []
  type: TYPE_NORMAL
- en: Mounting tape
  prefs: []
  type: TYPE_NORMAL
- en: Wire cutters
  prefs: []
  type: TYPE_NORMAL
- en: '**Parts List**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project has one of the smallest parts counts of all the projects in this
    book, but don’t let that attenuate its value for you. My family and friends have
    enjoyed playing the game repeatedly, and it’s portable, so you can take it with
    you to get-togethers and other events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Nano or clone
  prefs: []
  type: TYPE_NORMAL
- en: Two SPST momentary switches (preferably one with a red button and one with a
    button of a different color)
  prefs: []
  type: TYPE_NORMAL
- en: One SPST toggle switch
  prefs: []
  type: TYPE_NORMAL
- en: One red LED
  prefs: []
  type: TYPE_NORMAL
- en: Two 10-kilohm resistors
  prefs: []
  type: TYPE_NORMAL
- en: One 470-ohm resistor
  prefs: []
  type: TYPE_NORMAL
- en: (Optional) One audible annunciator, Mallory Sonalert or similar
  prefs: []
  type: TYPE_NORMAL
- en: One 4×20 LCD
  prefs: []
  type: TYPE_NORMAL
- en: One I²C adapter, if not included with the LCD (see “[Affixing the I²C Board
    to the LCD](ch00.xhtml#ch00lev1sec2)” on [page 3](ch00.xhtml#page_3))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I purchased a 16×2 LCD and its external I²C board separately and soldered
    the two together. However, many online vendors offer the same display and I²C
    adapter already soldered for about the same price or less than the two boards
    separately. Check eBay in particular*.'
  prefs: []
  type: TYPE_NORMAL
- en: One 9V battery
  prefs: []
  type: TYPE_NORMAL
- en: One 9V battery clip
  prefs: []
  type: TYPE_NORMAL
- en: One 3.5 mm jack (if remote switch is used)
  prefs: []
  type: TYPE_NORMAL
- en: One Hammond 1591 BTCL enclosure
  prefs: []
  type: TYPE_NORMAL
- en: 28-or 30-gauge hookup wire
  prefs: []
  type: TYPE_NORMAL
- en: 22-gauge solid conductor wire
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloads**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start this project, check the following resource files for this
    book at *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sketch file** *Reaction.ino*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drilling template for case** *ReactionEnclosure.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reaction vs. Reflex**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People often confuse reactions and reflexes, so I will start by defining both.
    *Reflexes* are involuntary, automatic responses to a stimulus. In a reflex action,
    the stimulus bypasses the brain and travels from the source of the stimulus to
    the spinal cord and back to the receptor that controls the response, without any
    cognitive acknowledgment. (Though I know many people for whom almost all stimuli—and
    information—seem to bypass the brain, often just getting lost instead.) Think
    of the doctor hitting your knee with a patellar hammer to trigger your knee-jerk
    reflex.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactions*, on the other hand, take the stimulus to the brain to be processed,
    and then a return reaction travels to a receptor to result in some motor action.
    This process takes somewhat longer than a typical reflex, though some athletes
    are said to have reaction times so fast that it’s possible their response is more
    similar to a reflex than a reaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Sports Illustrated *has done interesting work in this area, with eye-opening
    articles on baseball players and other athletes who have what appear to be exceptional
    reaction times*.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Does the Game Work?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Reaction-Time Machine game measures how long it takes an individual to
    press a button in response to a visual stimulus—in this case an LED. With a minor
    modification, you can add an auditory stimulus to the game: simply replace the
    LED with an audible annunciator, such as a Mallory Sonalert. Reaction time is
    measured in milliseconds or seconds (your choice), and it is the time between
    the moment the stimulus is activated and the moment the participant presses the
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HISTORY OF REACTION-TIME DEVICES**'
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, there have been many devices to measure reaction time. One of
    the simplest I remember from years ago required you to keep your fingers on either
    side of a ruler held by another person in mid-air. When the ruler was dropped,
    you would see how far it traveled before you could grasp it. The distance was
    translated to time using the algebraic equation
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0028-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *S* is the distance traveled, *A* is the acceleration due to gravity,
    and *T* is the reaction time. After you build this project, try both the ruler
    test and the Reaction-Time Machine to see how close your times are between devices.
  prefs: []
  type: TYPE_NORMAL
- en: '***Measuring Time with the Arduino Nano***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While there are many ways to measure elapsed time, this project takes advantage
    of the Arduino Nano’s ability to keep accurate time. Microcontrollers keep time
    exceptionally well, and they measure the time that elapses between one input and
    another with a minimum latency. In addition to timing your reactions, the Nano
    shows the result on an LCD.
  prefs: []
  type: TYPE_NORMAL
- en: The Nano does almost all of the work in this project; the other components are
    basically passive. After testing some early builds, I added features to the sketch
    to make the game more interesting and accurate. For example, I initially used
    a simple pushbutton to reset the Nano and start a counter. The participant would
    press the red stop button as soon as the LCD indicated so, and the Nano measured
    the time between pressing the reset and stop buttons. I found, however, that the
    player could anticipate the reset button being pushed and come up with some amazing
    reaction times.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the player from anticipating when the stimulus is about to occur,
    I had the Nano start the timer on a delay instead. The version in this book generates
    a random delay from when the reset button is depressed, activates the stimulus
    after the random delay, and counts the time from the stimulus to the moment the
    participant responds by depressing the stop button. That solved one problem.
  prefs: []
  type: TYPE_NORMAL
- en: Then, one of the participants tried to jump the gun and get an early start by
    holding down the stop button. I solved this problem by setting a minimum reaction
    time in the sketch. Any time under that minimum throws an error, and the LCD displays
    “Jumped the Gun” to indicate that the player pressed the button too soon.
  prefs: []
  type: TYPE_NORMAL
- en: I used a relatively large display—4 lines with 20 characters each—so there would
    be enough room to display the reflex time and some commentary on the relative
    prowess of the player. You can make your commentary as funny or serious as you
    want, but it must not exceed 60 characters in length—that is, three lines of 20
    characters each. While I leave the commentary up to you, the sketch for this project
    includes some ideas that I used when putting it together. You can always edit
    the commentary and reload the sketch to show comments specific to a set of users,
    like friends or relatives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Expected Speed Ranges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most individuals’ reaction times seem to vary greatly, based on the small sample
    I tested. Interestingly, age doesn’t seem to be a factor. The average reaction
    time was around 200 milliseconds, and that is the average reaction time identified
    by many researchers.
  prefs: []
  type: TYPE_NORMAL
- en: The fastest response of anyone I sampled was 105 milliseconds; however, the
    individual was not able to repeat that performance. Several individuals scored
    between 105 and 125 milliseconds, but not consistently. Significantly lower reaction
    times may well be anomalous or the result of an individual actually anticipating
    the stimulus. My players’ failure to repeat extremely fast reaction times would
    tend to bolster that idea. (I wouldn’t want to accuse anyone of successfully pre-guessing
    the release moment.)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Schematic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the display could have been wired directly, using the I²C interconnect
    made it a lot simpler and reduced the interface to only four wires: positive,
    ground, data, and clock (see [Figure 1-2](ch01.xhtml#ch01fig2)).'
  prefs: []
  type: TYPE_NORMAL
- en: The only components needed are the Nano, three switches (one toggle switch for
    power and two momentary pushbutton switches for activate and reset), an LED, the
    display, and three resistors. Despite the relatively sparse parts count, the project
    performs elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Schematic diagram of the Reaction-Time Machine*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Breadboard**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As is the case for most of my Arduino projects, the first step is to prepare
    a breadboard to prove the concept and test the sketch. Here’s how to wire up the
    breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the red positive rails on the breadboard together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the blue negative rails on the breadboard together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the Arduino Nano (or clone) in the breadboard, leaving two rows on one
    side and three on the other. (If the Nano does not come with stakes soldered in,
    see “[Preparing the Arduino Board](ch00.xhtml#ch00lev1sec1)” on [page 2](ch00.xhtml#page_2).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 5V terminal on the Nano to the red positive rail on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal on the Nano to the blue negative rail on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative wire from the battery connector to the blue negative rail.
    Remember that the breadboard has no switch, so you must disconnect the battery
    to turn it off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive lead from the battery connector to VIN on the Nano. (Do
    not connect the positive terminal of the battery to the red positive rail—it could
    permanently damage the Nano.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach 5-inch wires to two normally open momentary pushbutton switches. (I use
    22-gauge solid conductor wire so it can plug in to the breadboard directly.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a wire harness for the LCD (see “[Affixing the I²C Board to the LCD](ch00.xhtml#ch00lev1sec2)”
    on [page 3](ch00.xhtml#page_3)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the red wire from the LCD to the red positive rail on the breadboard
    (5V) and the black wire from the LCD to the blue negative rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the yellow wire from the display (SDA) to pin A4 on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the green wire from the display (SCL) to pin A5 on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of each pushbutton switch to the blue negative rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other side of the red reaction switch (SW2) to pin D7 on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other side of the yellow reset switch (SW1) to pin D2 on the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 10-kilohm resistor from pin D7 on the Nano to the red positive rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 10-kilohm resistor from pin D2 on the Nano to the red positive rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode side of the LED (the longer leg) to the red positive rail
    and the cathode side to an empty row on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 470-ohm resistor from the cathode side of the LED to pin D4 on the
    Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the *Reaction.ino* sketch to the Arduino Nano (see “[Uploading Sketches
    to Your Arduino](ch00.xhtml#ch00lev1sec3)” on [page 5](ch00.xhtml#page_5)), and
    you should now be ready to go. [Figure 1-3](ch01.xhtml#ch01fig3) shows the breadboard
    laid out with the switches dangling from their wires.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The breadboard setup for the Reaction-Time Machine. Because there
    is no on/off switch, you have to disconnect the battery to shut it off*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sketch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch is the actual computer program that tells the Arduino what to do
    and when to do it. It is written in a language of its own that comprises structures,
    variables, arrays, functions, and so on, which represent a recipe for the microcontroller
    to follow. This language is converted into a sequence of zeros and ones that are
    routed to various parts of the controller and can perform storage, timing, comparison,
    arithmetic functions, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting a computer language to a sequence of zeros and ones
    is called *compiling*. The compiling routine in the Arduino Integrated Development
    Environment (IDE) is activated when you click the Verify and Compile buttons in
    the upper-left side of the Sketch window.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch gets pretty long because of all the messages that can be inserted
    when it checks the score; however, the basic operation uses only a handful of
    code lines. You can use the scoring function as is, modify it, or copy and paste
    it to make a new scoring function. As you’ll see in my messages options, I’ve
    had fun with it.
  prefs: []
  type: TYPE_NORMAL
- en: The following code has been truncated to minimize the number of lines. However,
    you can simply go to *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*
    to download the entire sketch, which includes a number of messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#include` lines initiate the libraries: the I²C library, *Wire.h*, establishes
    the rules for I²C communications, and the LiquidCrystal library allows the Arduino
    to control LCDs. Then, we define the seven variables used to calculate reaction
    time. Next, `setup()` sets up the serial communication—in case you want to adjust
    the code and view it on the serial monitor—and defines various pins as inputs
    and outputs. Inputs are required for the reset and stop buttons, and an output
    pin is defined for the LED that tells the player when to press the stop button.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Customized Reaction Commentary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most entertaining aspects of this project is the chance to get creative
    when displaying the player’s reaction time. After `setup()`, the sketch shows
    a function called `score()`, which lists different comments that could be displayed
    on the LCD based on the participant’s response speed. A function may not necessarily
    be the most efficient approach (a look-up table or other approach could also have
    been used), but it works well enough. I used only a single scoring function in
    this iteration; however, you could easily define as many as you like and change
    your sketch to select one. For example, you might write a second function called
    `score1()` that could include a different set of comments and timing. Then, to
    switch from one function to the other, you’d have to change only the line that
    calls `score()` to call `score1()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: To customize the sketch to include comments that could refer to your own friends
    or family members, you can simply enter your comments in place of the ones that
    are in my sketch. Don’t forget to keep the text you want to print to the LCD in
    quotes so the Arduino recognizes the printable characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word on the reaction time itself: each comment is for a range of reaction
    times of either 5 or 10 milliseconds. I selected these ranges arbitrarily. After
    you play with the Reaction-Time Machine for a bit, you may wish to change these
    ranges based on the fact that users’ responses may cluster around a particular
    area, such as from 195 to 225 milliseconds. I found that many reaction times were
    in the 190 to 250 milliseconds range, but your friends and family may be different.
    In that case, you can separate the comments by as little as 1 or 2 milliseconds
    so players don’t keep getting the same comment.'
  prefs: []
  type: TYPE_NORMAL
- en: You can add as many comments as you wish, up to one comment per millisecond.
    If you accidentally overlap the times, the sketch may not compile.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can find reaction-time measurement tools on the web if you want to see
    how your game’s measurements compare. However, their accuracy is suspect because
    of the latency in the PC itself*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ON WRITING CODE TO SET UP LCDS**'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few points to note about the setup of the LCD. The sketch uses a
    LiquidCrystal library, *LiquidCrystal_I2C.h*. If this library is not included
    in your Arduino IDE, you can easily download it using the instructions provided
    in the reference section on the Arduino website (*[http://www.arduino.cc/reference/](http://www.arduino.cc/reference/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each I²C device comes with its own I²C address. This allows several
    I²C devices to be used on a single serial line. Usually the device documentation
    provides the address—in the case of the I²C LCD I used, the address was 0x3F.
    Thus, when the sketch initiates the LCD, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, different displays come with different addresses. If you have an I²C
    device that you do not have an address for, you can easily find the address by
    hooking up the device to an Arduino, downloading a scanner sketch from *[http://playground.arduino.cc/Main/i2cScanner/](http://playground.arduino.cc/Main/i2cScanner/)*,
    and running the sketch. The scanner sketch should display the I²C address on the
    serial monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Many projects in this book use similar code to work with an LCD, so refer to
    this box any time you need a refresher on how that code works.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Happens in the Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s look at the sketch’s loop. After `void loop()` initiates the start
    of the program, the program calls `digitalWrite(4, HIGH)` to turn off the active
    light. Then, the LCD screen is cleared, and text is written to the LCD to indicate
    that the system is armed and ready for a player to push the reaction button as
    soon as the red LED illuminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, a random number between 5 and 25 is generated, and the program calls
    `delay(5000)` to count every five seconds from zero to the random number. As soon
    as the random number is reached, three things happen: first, the annunciator lamp
    illuminates; second, an internal timer is started in the Nano; and third, the
    display then changes to read “Mash the React Button.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A wider range of random numbers might make this game even more interesting
    for players. You can easily experiment by changing the random number count, the
    delay, or both*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Nano is then instructed by `while(digitalRead(7) == 1);` to wait until the
    reaction button is depressed. After the button is depressed, the Nano calculates
    the reaction time with `reacttime = stop_time - start_time`. This time will be
    displayed on the LCD and used to select the appropriate comment in the `score()`
    function. Also, if the player’s reaction time is less than 70 milliseconds at
    this point, then the conditional statement looking for a participant to be “jumping
    the gun” displays appropriate wording for the LCD. The system is then halted and
    ready to be reset.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the serial print block is included in case you want to adjust the
    code and view it on a serial monitor. It also helps for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `score()` function is invoked, followed by the `Halt` command,
    and the system is ready to have the reset button depressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building the Reaction-Time Machine can be as simple or as complex as you want.
    Initially, I placed all the components in the vinyl package that a flexible wrist
    brace came in. I cut a hole for the display connectors with an X-ACTO knife and
    punched the holes for the switches and LED with a paper punch, followed by a tapered
    reamer. The result was somewhat crude, as shown in [Figure 1-4](ch01.xhtml#ch01fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: This was the Reaction-Time Machine’s original, primitive package,
    which worked but turned out to be too flimsy. The vinyl was only 0.018 inches
    thick*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Preparing a Sturdy Case***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of course, a real case makes the game much sturdier, which is important when
    you have competitive players mashing those buttons. To keep things as simple as
    possible, I employed one of the clear ABS plastic cases from Hammond (1591 BTCL).
    The clear top of the case allowed me to place the display behind the cover rather
    than machining out a hole for the display to protrude through. To mount the components,
    I simply drilled holes in the cover according to the drawing in [Figure 1-5](ch01.xhtml#ch01fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Drilling template for the Reaction-Time Machine*'
  prefs: []
  type: TYPE_NORMAL
- en: Quarter-inch holes work well for the momentary pushbutton switches, as well
    as for the toggle switch and 3.5 mm jack. For the 10 mm LED, I used a 3/8-inch
    drill and then reamed the hole out to make a tight fit. No other mounting hardware
    for the LED was necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The 3.5 mm jack is wired in parallel to the execute switch. If you want to
    use an external stand-alone switch, it can simply plug in to the jack. I abandoned
    the effort, however, as most participants preferred to hold the box in their hands*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Mounting the Hardware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To mount the display to the case, I used two-sided 3M Indoor/Outdoor Super Heavy
    Duty mounting tape. I cut two sections the size of the LCD display’s end bezel
    sections and bonded the display directly to the cover. The tape is difficult to
    remove, so make sure to place it right the first time. I used the same tape to
    mount the Nano and the battery holder to the back of the display. When mounting
    the display, I also used wire cutters to carefully cut off the corners of the
    display circuit board so it would fit far enough into the case without hitting
    the cover mounting pylons. See [Figure 1-6](ch01.xhtml#ch01fig6) for the finished
    product, viewed from the underside.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the components are in place, all that remains is to solder the components
    together, inserting the resistors where required. Take particular note of the
    I²C adapter, which is the black paddleboard just below the switches and LED. While
    I could have bent the connectors and used a header to wire that up, the case may
    not have closed, depending on how carefully I crimped the connectors. Instead,
    I elected to solder the wires directly. It was only four wires, and it worked
    without much trouble. Finally, I printed out and attached labels from a Brother
    label maker. [Figure 1-7](ch01.xhtml#ch01fig7) shows the completed unit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: This is the rear of the unit mounted in the ABS plastic enclosure.
    Notice that the corners of the display (lower left and right) have been clipped
    off to fit around the top mounting pylons. The 3.5 mm jack is not wired, as I
    decided not to use it in this implementation*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The completed Reaction-Time Machine mounted in the Hammond 1591
    BTCL clear plastic enclosure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ideas for Customization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many variations you could implement to increase the versatility and
    enjoyment of the Reaction-Time Machine. For example, as I developed it, I connected
    a Hall effect switch to one of the analog inputs and modified the sketch to automatically
    decrease the reaction time by a percentage when the Hall effect switch is activated.
    Then, I taped a small magnet to my finger that sat opposite the Hall effect switch
    so as I grabbed the box, it activated the switch. When I played, my reaction time
    was reduced by around 20 percent, while others had an actual reading. Far be it
    from me to suggest that readers try to hoodwink their adversaries, of course!
  prefs: []
  type: TYPE_NORMAL
- en: There are other modifications that can be made, such as incorporating a tone
    sound, or beep, as the sketch counts up to the random number. This can easily
    be accomplished with the addition of an annunciator and a few lines of code. If
    you’re ingenious, there are other sound effects you could add, such as a vulgar
    sound that plays when poor scores are achieved.
  prefs: []
  type: TYPE_NORMAL
- en: You can also exercise your brain and add code to the sketch that will average
    scores after, for example, three tries before you reset it. I experimented with
    many variations as I played with the device, but I would caution that you can
    spend a great deal of time for minimal advantage. Put the game together and enjoy.
  prefs: []
  type: TYPE_NORMAL
