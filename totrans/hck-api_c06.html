<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 6: Discovery</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_123" title="123"/>6</span><br/>
<span class="ChapterTitle">Discovery</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Before you can attack a target’s APIs, you must locate those APIs and validate whether they are operational. In the process, you’ll also want to find credential information (such as keys, secrets, usernames, and passwords), version information, API documentation, and information about the API’s business purpose. The more information you gather about a target, the better your odds of discovering and exploiting API-related vulnerabilities. This chapter describes passive and active reconnaissance processes and the tools to get the job done.</p>
<p>When it comes to recognizing an API in the first place, it helps to consider its purpose. APIs are meant to be used either internally, by partners and customers, or publicly. If an API is intended for public or partner use, it’s likely to have developer-friendly documentation that describes the API <span epub:type="pagebreak" id="Page_124" title="124"/>endpoints and instructions for using it. Use this documentation to recognize the API.</p>
<p>If the API is for select customers or internal use, you’ll have to rely on other clues: naming conventions, HTTP response header information such as <code>Content-Type: application/json</code>, HTTP responses containing JSON/XML, and information about the JavaScript source files that power the application.</p>
<h2 id="h1-502444c06-0001">Passive Recon</h2>
<p class="BodyFirst"><em>Passive reconnaissance</em> is the act of obtaining information about a target without directly interacting with the target’s devices. When you take this approach, your goal is to find and document your target’s attack surface without making the target aware of your investigation. In this case, the <em>attack surface</em> is the total set of systems exposed over a network from which it may be possible to extract data, through which you could gain entry to other systems, or to which you could cause an interruption in the availability of systems.</p>
<p>Typically, passive reconnaissance leverages <em>open-source intelligence (OSINT)</em>, which is data collected from publicly available sources. You will be on the hunt for API endpoints, credential information, version information, API documentation, and information about the API’s business purpose. Any discovered API endpoints will become your targets later, during active reconnaissance. Credential-related information will help you test as an authenticated user or, better, as an administrator. Version information will help inform you about potential improper assets and other past vulnerabilities. API documentation will tell you exactly how to test the target API. Finally, discovering the API’s business purpose can provide you with insight about potential business logic flaws.</p>
<p>As you are collecting OSINT, it is entirely possible you will stumble upon a critical data exposure, such as API keys, credentials, JSON Web Tokens (JWT), and other secrets that would lead to an instant win. Other high-risk findings would include leaked PII or sensitive user data such as Social Security numbers, full names, email addresses, and credit card information. These sorts of findings should be documented and reported immediately because they present a valid critical weakness.</p>
<h3 id="h2-502444c06-0001">The Passive Recon Process</h3>
<p class="BodyFirst">When you begin passive recon, you’ll probably know little to nothing about your target. Once you’ve gathered some basic information, you can focus your OSINT efforts on the different facets of an organization and build a profile of the target’s attack surface. API usage will vary between industries and business purposes, so you’ll need to adapt as you learn new information. Start by casting a wide net using an array of tools to collect data. Then perform more tailored searches based on the collected data to obtain more <span epub:type="pagebreak" id="Page_125" title="125"/>refined information. Repeat this process until you’ve mapped out the target’s attack surface.</p>
<h4 id="h3-502444c06-0001">Phase One: Cast a Wide Net</h4>
<p class="BodyFirst">Search the internet for very general terms to learn some fundamental information about your target. Search engines such as Google, Shodan, and ProgrammableWeb can help you find general information about the API, such as its usage, design and architecture, documentation, and business purpose, as well as industry-related information and many other potentially significant items.</p>
<p>Additionally, you need to investigate your target’s attack surface. This can be done with tools such as DNS Dumpster and OWASP Amass. DNS Dumpster performs DNS mapping by showing all the hosts related to the target’s domain name and how they connect to each other. (You may want to attack these hosts later!) We covered the use of OWASP Amass in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.</p>
<h4 id="h3-502444c06-0002">Phase Two: Adapt and Focus</h4>
<p class="BodyFirst">Next, take your findings from phase one and adapt your OSINT efforts to the information gathered. This might mean increasing the specificity of your search queries or combining the information gathered from separate tools to gain new insights. In addition to using search engines, you might search GitHub for repositories related to your target and use a tool such as Pastehunter to find exposed sensitive information.</p>
<h4 id="h3-502444c06-0003">Phase Three: Document the Attack Surface</h4>
<p class="BodyFirst">Taking notes is crucial to performing an effective attack. Document and take screen captures of all interesting findings. Create a task list of the passive reconnaissance findings that could prove useful throughout the rest of the attack. Later, while you’re actively attempting to exploit the API’s vulnerabilities, return to the task list to see if you’ve missed anything.</p>
<p>The following sections go deeper into the tools you’ll use throughout this process. Once you begin experimenting with these tools, you’ll notice some crossover between the information they return. However, I encourage you to use multiple tools to confirm your results. You wouldn’t want to fail to find privileged API keys posted on GitHub, for example, especially if a criminal later stumbled upon that low-hanging fruit and breached your client.</p>
<h3 id="h2-502444c06-0002">Google Hacking</h3>
<p class="BodyFirst"><em>Google hacking</em> (also known as <em>Google dorking</em>) involves the clever use of advanced search parameters and can reveal all sorts of public API-related information about your target, including vulnerabilities, API keys, and usernames, that you can leverage during an engagement. In addition, you’ll <span epub:type="pagebreak" id="Page_126" title="126"/>find information about the target organization’s industry and how it leverages its APIs. <a href="#table6-1" id="tableanchor6-1">Table 6-1</a> lists a selection of useful query parameters (see the “Google Hacking” Wikipedia page for a complete list).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Google Query Parameters</p></figcaption>
<table border="1" id="table-502444c06-0001">
<thead>
<tr>
<td><b>Query operator</b></td>
<td><b>Purpose</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>intitle</code></td>
<td>Searches page titles</td>
</tr>
<tr>
<td><code>inurl</code></td>
<td>Searches for words in the URL</td>
</tr>
<tr>
<td><code>filetype</code></td>
<td>Searches for desired file types</td>
</tr>
<tr>
<td><code>site</code></td>
<td>Limits a search to specific sites</td>
</tr>
</tbody>
</table>
</figure>
<p>Start with a broad search to see what information is available; then add parameters specific to your target to focus the results. For example, a generic search for <code>inurl: /api/</code> will return over 2,150,000 results—too many to do much of anything with. To narrow the search results, include your target’s domain name. A query like <code>intitle:"</code><var>&lt;targetname&gt;</var><code> api key"</code> returns fewer and more relevant results.</p>
<p>In addition to your own carefully crafted Google search queries, you can use Offensive Security’s Google Hacking Database (GHDB, <a class="LinkURL" href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a>). The GHDB is a repository of queries that reveal publicly exposed vulnerable systems and sensitive information. <a href="#table6-2" id="tableanchor6-2">Table 6-2</a> lists some useful API queries from the GHDB.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-2">Table 6-2</a>: GHDB Queries</p></figcaption>
<table border="1" id="table-502444c06-0002">
<thead>
<tr>
<td><b>Google hacking query</b></td>
<td><b>Expected results</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>inurl:"/wp-json/wp/v2/users"</code></td>
<td>Finds all publicly available WordPress API user directories.</td>
</tr>
<tr>
<td><code>intitle:"index.of" intext:"api.txt"</code></td>
<td>Finds publicly available API key files.</td>
</tr>
<tr>
<td><code>inurl:"/includes/api/" intext:"index of /"</code></td>
<td>Finds potentially interesting API directories.</td>
</tr>
<tr>
<td><code>ext:php inurl:"api.php?action="</code></td>
<td>Finds all sites with a XenAPI SQL injection vulnerability. (This query was posted in 2016; four years later, there were 141,000 results.)</td>
</tr>
<tr>
<td><code>intitle:"index of" api_key OR "api key" OR apiKey -pool</code></td>
<td>Lists potentially exposed API keys. (This is one of my favorite queries.)</td>
</tr>
</tbody>
</table>
</figure>
<p>As you can see in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>, the final query returns 2,760 search results for websites where API keys are publicly exposed.</p>
<span epub:type="pagebreak" id="Page_127" title="127"/><figure>
<img alt="Screenshot of Google search results with the keyword “apikey” highlighted in the endpoints of the returned websites" class="keyline" src="image_fi/502444c06/F06001.png"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: The results of a Google hack for APIs, including several web pages with exposed API keys</p></figcaption>
</figure>
<h3 id="h2-502444c06-0003">ProgrammableWeb’s API Search Directory</h3>
<p class="BodyFirst">ProgrammableWeb (<a class="LinkURL" href="https://www.programmableweb.com">https://www.programmableweb.com</a>) is the go-to source for API-related information. To learn about APIs, you can use its API University. To gather information about your target, use the API directory, a searchable database of over 23,000 APIs (see <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>). Expect to find API endpoints, version information, business logic information, the status of the API, source code, SDKs, articles, API documentation, and a changelog.</p>
<figure>
<img alt="Screenshot of the ProgrammableWeb API directory displaying information about the Google Maps and Twitter APIs" class="keyline" src="image_fi/502444c06/F06002.png"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: The ProgrammableWeb API directory</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_128" title="128"/><h2><span class="NoteHead">Note</span></h2>
<p>	SDK stands for <em>software development kit</em>. If an SDK is available, you should be able to download the software behind the target’s API. For example, ProgrammableWeb has a link to the GitHub repository of the Twitter Ads SDK, where you can review the source code or download the SDK and test it out.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Suppose you discover, using a Google query, that your target is using the Medici Bank API. You could search the ProgrammableWeb API directory and find the listing in <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>.</p>
<figure>
<img alt="Screenshot of the Medici Bank API page on ProgrammableWeb, which contains information about the API’s structure and the various tasks for which it can be used" class="keyline" src="image_fi/502444c06/F06003.png"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: ProgrammableWeb’s API directory listing for the Medici Bank API</p></figcaption>
</figure>
<p>The listing shows that the Medici Bank API interacts with customer data and facilitates financial transactions, making it a high-risk API. When you discover a sensitive target like this one, you’ll want to find any information that could help you attack it, including API documentation, the location of its endpoint and portal, its source code, its changelog, and the authentication model it uses.</p>
<p>Click through the various tabs in the directory listing and note the information you find. To see the API endpoint location, portal location, and authentication model, shown in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>, click a specific version under the Versions tab. In this case, both the portal and endpoint links lead to API documentation as well.</p>
<span epub:type="pagebreak" id="Page_129" title="129"/><figure>
<img alt="Screenshot of the ProgrammableWeb Versions tab for the Medici Bank API, which provides links to relevant resources" class="keyline" src="image_fi/502444c06/F06004.png"/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: The Medici Bank API Specs section provides the API endpoint location, the API portal location, and the API authentication model.</p></figcaption>
</figure>
<p>The Changelog tab will inform you of past vulnerabilities, previous API versions, and notable updates to the latest API version, if available. ProgrammableWeb describes the Libraries tab as “a platform-specific software tool that, when installed, results in provisioning a specific API.” You can use this tab to discover the type of software used to support the API, which could include vulnerable software libraries.</p>
<p>Depending on the API, you may discover source code, tutorials (the How To tab), mashups, and news articles, all of which may provide useful OSINT. Other sites with API repositories include <a class="LinkURL" href="https://rapidapi.com">https://rapidapi.com</a> and <a class="LinkURL" href="https://apis.guru/browse-apis">https://apis.guru/browse-apis</a>.</p>
<h3 id="h2-502444c06-0004">Shodan</h3>
<p class="BodyFirst">Shodan is the go-to search engine for devices accessible from the internet. Shodan regularly scans the entire IPv4 address space for systems with open ports and makes their collected information public at <a class="LinkURL" href="https://shodan.io">https://shodan.io</a>. You can use Shodan to discover external-facing APIs and get information about your target’s open ports, making it useful if you have only an IP address or organization’s name to work from.</p>
<p>Like with Google dorks, you can search Shodan casually by entering your target’s domain name or IP addresses; alternatively, you can use search parameters as you would when writing Google queries. <a href="#table6-3" id="tableanchor6-3">Table 6-3</a> shows some useful Shodan queries.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-3">Table 6-3</a>: Shodan Query Parameters<span epub:type="pagebreak" id="Page_130" title="130"/></p></figcaption>
<table border="1" id="table-502444c06-0003">
<thead>
<tr>
<td><b>Shodan queries</b></td>
<td><b>Purpose</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>hostname:"targetname.com"</code></td>
<td>Using <code>hostname</code> will perform a basic Shodan search for your target’s domain name. This should be combined with the following queries to get results specific to your target.</td>
</tr>
<tr>
<td><code>"content-type: application/json"</code></td>
<td>APIs should have their <code>content-type</code> set to JSON or XML. This query will filter results that respond with JSON.</td>
</tr>
<tr>
<td><code>"content-type: application/xml"</code></td>
<td>This query will filter results that respond with XML.</td>
</tr>
<tr>
<td><code>"200 OK"</code></td>
<td>You can add <code>"200 OK"</code> to your search queries to get results that have had successful requests. However, if an API does not accept the format of Shodan’s request, it will likely issue a 300 or 400 response.</td>
</tr>
<tr>
<td><code>"wp-json"</code></td>
<td>This will search for web applications using the WordPress API.</td>
</tr>
</tbody>
</table>
</figure>
<p>You can put together Shodan queries to discover API endpoints, even if the APIs do not have standard naming conventions. If, as shown in <a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>, we were targeting eWise (<a class="LinkURL" href="https://www.ewise.com">https://www.ewise.com</a>), a money management company, we could use the following query to see if it had API endpoints that had been scanned by Shodan:</p>
<pre><code>"ewise.com" "content-type: application/json"</code></pre>
<figure>
<img alt="Screenshot of Shodan’s interface displaying an IP address corresponding to the query entered" class="keyline" src="image_fi/502444c06/F06005.png"/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Shodan search results</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_131" title="131"/>In <a href="#figure6-5">Figure 6-5</a>, we see that Shodan has provided us with a potential target endpoint. Investigating this result further reveals SSL certificate information related to eWise—namely, that the web server is Nginx and that the response includes an <code>application/json</code> header. The server issued a 401 JSON response code commonly used in REST APIs. We were able to discover an API endpoint without any API-related naming conventions.</p>
<p>Shodan also has browser extensions that let you conveniently check Shodan scan results as you visit sites with your browser.</p>
<h3 id="h2-502444c06-0005">OWASP Amass</h3>
<p class="BodyFirst">Introduced in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, OWASP Amass is a command line tool that can map a target’s external network by collecting OSINT from over 55 different sources. You can set it to perform passive or active scans. If you choose the active option, Amass will collect information directly from the target by requesting its certificate information. Otherwise, it collects data from search engines (such as Google, Bing, and HackerOne), SSL certificate sources (such as GoogleCT, Censys, and FacebookCT), search APIs (such as Shodan, AlienVault, Cloudflare, and GitHub), and the web archive Wayback.</p>
<p>Visit <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> for instructions on setting up Amass and adding API keys. The following is a passive scan of <em>twitter.com</em>, with grep used to show only API-related results:</p>
<pre><code>$ <b>amass enum -passive -d twitter.com |grep api</b>
legacy-api.twitter.com
api1-backup.twitter.com
api3-backup.twitter.com
tdapi.twitter.com
failover-urls.api.twitter.com
cdn.api.twitter.com
pulseone-api.smfc.twitter.com
urls.api.twitter.com
api2.twitter.com
apistatus.twitter.com
apiwiki.twtter.com</code></pre>
<p>This scan revealed 86 unique API subdomains, including <em>legacy-api.twitter.com</em>. As we know from the OWASP API Security Top 10, an API named <em>legacy</em> could be of particular interest because it seems to indicate an improper asset management vulnerability.</p>
<p>Amass has several useful command line options. Use the <code>intel</code> command to collect SSL certificates, search reverse Whois records, and find ASN IDs associated with your target. Start by providing the command with target IP addresses:</p>
<pre><code>$ <b>amass intel -addr </b><var class="bold">&lt;target IP addresses&gt;</var></code></pre>
<p>If this scan is successful, it will provide you with domain names. These domains can then be passed to <code>intel</code> with the <code>whois</code> option to perform a reverse Whois lookup:</p>
<pre><code>$ <b>amass intel -d </b><var class="bold">&lt;target domain&gt; </var><b>–whois</b></code></pre>
<p><span epub:type="pagebreak" id="Page_132" title="132"/>This could give you a ton of results. Focus on the interesting results that relate to your target organization. Once you have a list of interesting domains, upgrade to the <code>enum</code> subcommand to begin enumerating subdomains. If you specify the <code>-passive</code> option, Amass will refrain from directly interacting with your target:</p>
<pre><code>$ <b>amass enum -passive -d </b><var class="bold">&lt;target domain&gt;</var></code></pre>
<p>The active <code>enum</code> scan will perform much of the same scan as the passive one, but it will add domain name resolution, attempt DNS zone transfers, and grab SSL certificate information:</p>
<pre><code>$ <b>amass enum -active -d </b><var class="bold">&lt;target domain&gt;</var></code></pre>
<p>To up your game, add the <code>-brute</code> option to brute-force subdomains, <code>-w</code> to specify the API_superlist wordlist, and then the <code>-dir</code> option to send the output to the directory of your choice:</p>
<pre><code>$ <b>amass enum -active -brute -w /usr/share/wordlists/API_superlist -d </b><var class="bold">&lt;target domain&gt;</var><b> -dir </b><var class="bold">&lt;directory name&gt;</var></code></pre>
<p>If you’d like to visualize relationships between the data Amass returns, use the <code>viz</code> subcommand, as shown next, to make a cool-looking web page (see <a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>). This page allows you to zoom in and check out the various related domains and hopefully some API endpoints.</p>
<pre><code>$ <b>amass viz -enum -d3 -dir </b><var class="bold">&lt;directory name&gt;</var></code></pre>
<figure>
<img alt="Screenshot of a visualization of related domains generated by Amass" class="keyline" src="image_fi/502444c06/F06006.png"/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: OWASP Amass visualization using <span class="LiteralInCaption"><code>-d3</code></span> to make an HTML export of Amass findings for <em>t</em><em>witter</em><em>.com</em></p></figcaption>
</figure>
<p>You can use this visualization to see the types of DNS records, dependencies between different hosts, and the relationships between different nodes. In <a href="#figure6-6">Figure 6-6</a>, all the nodes on the left are API subdomains, while the large circle represents <em>twitter.com</em>.</p>
<h3 id="h2-502444c06-0006"><span epub:type="pagebreak" id="Page_133" title="133"/>Exposed Information on GitHub</h3>
<p class="BodyFirst">Regardless of whether your target performs its own development, it’s worth checking GitHub (<a class="LinkURL" href="https://github.com">https://github.com</a>) for sensitive information disclosure. Developers use GitHub to collaborate on software projects. Searching GitHub for OSINT could reveal your target’s API capabilities, documentation, and secrets, such as admin-level API keys, passwords, and tokens, which could be useful during an attack.</p>
<p>Begin by searching GitHub for your target organization’s name paired with potentially sensitive types of information, such as “api-key,” “password,” or “token.” Then investigate the various GitHub repository tabs to discover API endpoints and potential weaknesses. Analyze the source code in the Code tab, find software bugs in the Issues tab, and review proposed changes in the Pull requests tab.</p>
<h4 id="h3-502444c06-0004">Code</h4>
<p class="BodyFirst">Code contains the current source code, <span class="Caps">readme</span> files, and other files (see <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>). This tab will provide you with the name of the last developer who committed to the given file, when that commit happened, contributors, and the actual source code.</p>
<figure>
<img alt="Screenshot of source code in the GitHub code tab" class="keyline" src="image_fi/502444c06/F06007.png"/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: An example of the GitHub Code tab where you can review the source code of different files</p></figcaption>
</figure>
<p>Using the Code tab, you can review the code in its current form or use <span class="KeyCaps">ctrl</span>-F to search for terms that may interest you (such as “API,” “key,” and “secret”). Additionally, view historical commits to the code by using the History button found at the top-right corner of <a href="#figure6-7">Figure 6-7</a>. If you came across an issue or comment that led you to believe there were once vulnerabilities associated with the code, you can look for historical commits to see if the vulnerabilities are still viewable.</p>
<p><span epub:type="pagebreak" id="Page_134" title="134"/>When looking at a commit, use the Split button to see a side-by-side comparison of the file versions to find the exact place where a change to the code was made (see <a href="#figure6-8" id="figureanchor6-8">Figure 6-8</a>).</p>
<figure>
<img alt="Screenshot of a split window in the GitHub interface that highlights changes between two versions of a program" class="keyline" src="image_fi/502444c06/F06008.png"/>
<figcaption><p><a id="figure6-8">Figure 6-8</a>: The Split button allows you to separate the previous code (left) from the updated code (right).</p></figcaption>
</figure>
<p>Here, you can see a commit to a financial application that removed the SonarQube private API key from the code, revealing both the key and the API endpoint it was used for.</p>
<h4 id="h3-502444c06-0005">Issues</h4>
<p class="BodyFirst">The Issues tab is a space where developers can track bugs, tasks, and feature requests. If an issue is open, there is a good chance that the vulnerability is still live within the code (see <a href="#figure6-9" id="figureanchor6-9">Figure 6-9</a>).</p>
<figure>
<img alt="Screenshot of a GitHub issues tab that reads “API key is public.” Contains a comment recommending that an API key be removed." class="keyline" src="image_fi/502444c06/F06009.png"/>
<figcaption><p><a id="figure6-9">Figure 6-9</a>: An open GitHub issue that provides the exact location of an exposed API key in the code of an application</p></figcaption>
</figure>
<p>If the issue is closed, note the date of the issue and then search the commit history for any changes around that time.</p>
<h4 id="h3-502444c06-0006"><span epub:type="pagebreak" id="Page_135" title="135"/>Pull Requests</h4>
<p class="BodyFirst">The Pull requests tab is a place that allows developers to collaborate on changes to the code. If you review these proposed changes, you might sometimes get lucky and find an API exposure that is in the process of being resolved. For example, in <a href="#figure6-10" id="figureanchor6-10">Figure 6-10</a>, the developer has performed a pull request to remove an exposed API key from the source code.</p>
<figure>
<img alt="Screenshot of a GitHub pull request titled “Removed Exposed API_KEY”" class="keyline" src="image_fi/502444c06/F06010.png"/>
<figcaption><p><a id="figure6-10">Figure 6-10</a>: A developer’s comments in the pull request conversation can reveal private API keys.</p></figcaption>
</figure>
<p>As this change has not yet been merged with the code, we can easily see that the API key is still exposed under the Files Changed tab (see <a href="#figure6-11" id="figureanchor6-11">Figure 6-11</a>).</p>
<figure>
<img alt="Screenshot of the GitHub Files changed tab showing code containing the exposed API key" class="keyline" src="image_fi/502444c06/F06011.png"/>
<figcaption><p><a id="figure6-11">Figure 6-11</a>: The Files Changed tab demonstrates proposed change to the code.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_136" title="136"/>The Files Changed tab reveals the section of code the developer is attempting to change. As you can see, the API key is on line 25; the following line is the proposed change to have the key removed.</p>
<p>If you don’t find weaknesses in a GitHub repository, use it instead to develop your profile of your target. Take note of programming languages in use, API endpoint information, and usage documentation, all of which will prove useful moving forward.</p>
<h2 id="h1-502444c06-0002">Active Recon</h2>
<p class="BodyFirst">One shortcoming of performing passive reconnaissance is that you’re collecting information from secondhand sources. As an API hacker, the best way to validate this information is to obtain information directly from a target by port or vulnerability scanning, pinging, sending HTTP requests, making API calls, and other forms of interaction with a target’s environment.</p>
<p>This section will focus on discovering an organization’s APIs using detection scanning, hands-on analysis, and targeted scanning. The lab at the end of the chapter will show these techniques in action.</p>
<h3 id="h2-502444c06-0007">The Active Recon Process</h3>
<p class="BodyFirst">The active recon process discussed in this section should lead to an efficient yet thorough investigation of the target and reveal any weaknesses you can use to access the system. Each phase narrows your focus using information from the previous phase: phase one, detection scanning, uses automated scans to find services running HTTP or HTTPS; phase two, hands-on analysis, looks at those services from the end user and hacker perspectives to find points of interest; phase three uses findings from phase two to increase the focus of scans to thoroughly explore the discovered ports and services. This process is time-efficient because it keeps you engaging with the target while automated scans are running in the background. Whenever you’ve hit a dead end in your analysis, return to your automated scans to check for new findings.</p>
<p>The process is not linear: after each phase of increasingly targeted scanning, you’ll analyze the results and then use your findings for further scanning. At any point, you might find a vulnerability and attempt to exploit it. If you successfully exploit the vulnerability, you can move on to post-exploitation. If you don’t, you return to your scans and analysis.</p>
<h4 id="h3-502444c06-0007">Phase Zero: Opportunistic Exploitation</h4>
<p class="BodyFirst">If you discover a vulnerability at any point in the active recon process, you should take the opportunity to attempt exploitation. You might discover the vulnerability in the first few seconds of scanning, after stumbling upon a comment left in a partially developed web page, or after months of research. As soon as you do, dive into exploitation and then return to the <span epub:type="pagebreak" id="Page_137" title="137"/>phased process as needed. With experience, you’ll learn when to avoid getting lost in a potential rabbit hole and when to go all in on an exploit.</p>
<h4 id="h3-502444c06-0008">Phase One: Detection Scanning</h4>
<p class="BodyFirst">The goal of detection scanning is to reveal potential starting points for your investigation. Begin with general scans meant to detect hosts, open ports, services running, and operating systems currently in use, as described in the <span class="xref" itemid="xref_target_“Baseline Scanning with Nmap”">“Baseline Scanning with Nmap”</span> section of this chapter. APIs use HTTP or HTTPS, so as soon as your scan detects these services, let the scan continue to run and move into phase two.</p>
<h4 id="h3-502444c06-0009">Phase Two: Hands-on Analysis</h4>
<p class="BodyFirst">Hands-on analysis is the act of exploring the web application using a browser and API client. Aim to learn about all the potential levers you can interact with and test them out. Practically speaking, you’ll examine the web page, intercept requests, look for API links and documentation, and develop an understanding of the business logic involved.</p>
<p>You should usually consider the application from three perspectives: guests, authenticated users, and site administrators. <em>Guests</em> are anonymous users likely visiting a site for the first time. If the site hosts public information and does not need to authenticate users, it may only have guest users. <em>Authenticated users</em> have gone through some registration process and have been granted a certain level of access. <em>Administrators</em> have the privileges to manage and maintain the API.</p>
<p>Your first step is to visit the website in a browser, explore the site, and consider it from these perspectives. Here are some considerations for each user group:</p>
<ol class="none">
<li><span class="RunInHead">Guest</span>  How would a new user use this site? Can new users interact with the API? Is API documentation public? What actions can this group perform?</li>
<li><span class="RunInHead">Authenticated User</span>  What can you do when authenticated that you couldn’t do as a guest? Can you upload files? Can you explore new sections of the web application? Can you use the API? How does the web application recognize that a user is authenticated?</li>
<li><span class="RunInHead">Administrator</span>  Where would site administrators log in to manage the web app? What is in the page source? What comments have been left around various pages? What programming languages are in use? What sections of the website are under development or experimental?</li>
</ol>
<p>Next, it’s time to analyze the app as a hacker by intercepting the HTTP traffic with Burp Suite. When you use the web app’s search bar or attempt to authenticate, the app might be using API requests to perform the requested action, and you’ll see those requests in Burp Suite.</p>
<p>When you run into roadblocks, it’s time to review new results from the phase one scans running in the background and kick off phase three: targeted scans.</p>
<h4 id="h3-502444c06-0010"><span epub:type="pagebreak" id="Page_138" title="138"/>Phase Three: Targeted Scanning</h4>
<p class="BodyFirst">In the targeted scanning phase, refine your scans and use tools that are specific to your target. Whereas detection scanning casts a wide net, targeted scanning should focus on the specific type of API, its version, the web application type, any service versions discovered, whether the app is on HTTP or HTTPS, any active TCP ports, and other information gleaned from understanding the business logic. For example, if you discover that an API is running over a nonstandard TCP port, you can set your scanners to take a closer look at that port. If you find out that the web application was made with WordPress, check whether the WordPress API is accessible by visiting <em>/wp-json/wp/v2</em>. At this point, you should know the URLs of the web application and can begin brute-forcing uniform resource identifiers to find hidden directories and files (see <span class="xref" itemid="xref_target_“Brute-Forcing URIs with Gobuster”">“Brute-Forcing URIs with Gobuster”</span> later in this chapter). Once these tools are up and running, review results as they flow in to perform a more targeted hands-on analysis.</p>
<p>The following sections describe the tools and techniques you’ll use throughout the phases of active reconnaissance, including detection scanning with Nmap, hands-on analysis using DevTools, and targeted scanning with Burp Suite and OWASP ZAP.</p>
<h3 id="h2-502444c06-0008">Baseline Scanning with Nmap</h3>
<p class="BodyFirst">Nmap is a powerful tool for scanning ports, searching for vulnerabilities, enumerating services, and discovering live hosts. It’s my preferred tool for phase one detection scanning, but I also return to it for targeted scanning. You’ll find books and websites dedicated to the power of Nmap, so I won’t dive too deeply into it here.</p>
<p>For API discovery, you should run two Nmap scans in particular: general detection and all port. The Nmap general detection scan uses default scripts and service enumeration against a target and then saves the output in three formats for later review (<code>-oX</code> for XML, <code>-oN</code> for Nmap, <code>-oG</code> for greppable, or <code>-oA</code> for all three formats):</p>
<pre><code>$ <b>nmap -sC -sV </b><var class="bold">&lt;target address or network range&gt;</var><b> -oA nameofoutput</b></code></pre>
<p>The Nmap all-port scan will quickly check all 65,535 TCP ports for running services, application versions, and host operating system in use:</p>
<pre><code>$ <b>nmap -p- </b><var class="bold">&lt;target address&gt;</var><b> -oA allportscan</b></code></pre>
<p>As soon as the general detection scan begins returning results, kick off the all-port scan. Then begin your hands-on analysis of the results. You’ll most likely discover APIs by looking at the results related to HTTP traffic and other indications of web servers. Typically, you’ll find these running on ports 80 and 443, but an API can be hosted on all sorts of different ports. Once you discover a web server, open a browser and begin analysis.</p>
<h3 id="h2-502444c06-0009"><span epub:type="pagebreak" id="Page_139" title="139"/>Finding Hidden Paths in Robots.txt</h3>
<p class="BodyFirst"><em>Robots.txt</em> is a common text file that tells web crawlers to omit results from the search engine findings. Ironically, it also serves to tell us which paths the target wants to keep secret. You can find the <em>robots.txt</em> file by navigating to the target’s <em>/robots.txt</em> directory (for example, <a class="LinkURL" href="https://www.twitter.com/robots.txt">https://www.twitter.com/robots.txt</a>).</p>
<p>The following is an actual <em>robots.txt</em> file from an active web server, complete with a disallowed <em>/api/</em> path:</p>
<pre><code>User-agent: *
Disallow: /appliance/
Disallow: /login/
Disallow: /api/
Disallow: /files/</code></pre>
<h3 id="h2-502444c06-0010">Finding Sensitive Information with Chrome DevTools</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, I said that Chrome DevTools contains some highly underrated web application hacking tools. The following steps will help you easily and systematically filter through thousands of lines of code in order to find sensitive information in page sources.</p>
<p>Begin by opening your target page and then open Chrome DevTools with F12 or <span class="KeyCaps">ctrl</span>-<span class="KeyCaps">shift</span>-I. Adjust the Chrome DevTools window until you have enough space to work with. Select the Network tab and then refresh the page.</p>
<p>Now look for interesting files (you may even find one titled “API”). Right-click any JavaScript files that interest you and click <b>Open in Sources Panel</b> (see <a href="#figure6-12" id="figureanchor6-12">Figure 6-12</a>) to view their source code. Alternatively, click XHR to find see the Ajax requests being made.</p>
<figure>
<img alt="Screenshot of the DevTools Network panel, which shows a list of the files that compose the web page" class="keyline" src="image_fi/502444c06/F06012.png"/>
<figcaption><p><a id="figure6-12">Figure 6-12</a>: The Open in Sources panel option from the DevTools Network tab</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_140" title="140"/>Search for potentially interesting lines of JavaScript. Some key terms to search for include “API,” “APIkey,” “secret,” and “password.” For example, <a href="#figure6-13" id="figureanchor6-13">Figure 6-13</a> illustrates how you could discover an API that is nearly 4,200 lines deep within a script.</p>
<figure>
<img alt="Screenshot of a highlighted API endpoint found within a source code file in the DevTools interface" class="keyline" src="image_fi/502444c06/F06013.png"/>
<figcaption><p><a id="figure6-13">Figure 6-13</a>: On line 4,197 of this page source, an API is in use.</p></figcaption>
</figure>
<p>You can also make use of the DevTools Memory tab, which allows you to take a snapshot of the memory heap distribution. Sometimes the static JavaScript files include all sorts of information and thousands of lines of code. In other words, it may not be entirely clear exactly how the web app leverages an API. Instead, you could use the Memory panel to record how the web application is using resources to interact with an API.</p>
<p>With DevTools open, click the <b>Memory</b> tab. Under Select Profiling Type, choose <b>Heap Snapshot</b>. Then, under Select JavaScript VM Instance, choose the target to review. Next, click the <b>Take Snapshot</b> button (see <a href="#figure6-14" id="figureanchor6-14">Figure 6-14</a>).</p>
<figure>
<img alt="Screenshot of the DevTools Memory panel with “Heap snapshot” checked and twitter.com selected as the target" class="" src="image_fi/502444c06/F06014.png"/>
<figcaption><p><a id="figure6-14">Figure 6-14</a>: The Memory panel within DevTools</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_141" title="141"/>Once the file has been compiled under the Heap Snapshots section on the left, select the new snapshot and use <span class="KeyCaps">ctrl</span>-F to search for potential API paths. Try searching for terms using the common API path terms, like “api,” “v1,” “v2,” “swagger,” “rest,” and “dev.” If you need additional inspiration, check out the Assetnote API wordlists (<a class="LinkURL" href="http://wordlists.assetnote.io">http://wordlists.assetnote.io</a>). If you’ve built your attack machine according to <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, these wordlists should be available to you under <em>/api/wordlists</em>. <a href="#figure6-15" id="figureanchor6-15">Figure 6-15</a> indicates the results you would expect to see when using the Memory panel in DevTools to search a snapshot for “api”.</p>
<figure>
<img alt="Screenshot of API paths returned in DevTools after a search for the “api” keyword" class="" src="image_fi/502444c06/F06015.png"/>
<figcaption><p><a id="figure6-15">Figure 6-15</a>: The search results from a memory snapshot</p></figcaption>
</figure>
<p>As you can see, the Memory module can help you discover the existence of APIs and their paths. Additionally, you can use it to compare different memory snapshots. This can help you see the API paths used in authenticated and unauthenticated states, in different parts of a web application, and in its different features.</p>
<p>Finally, use the Chrome DevTools Performance tab to record certain actions (such as clicking a button) and review them over a timeline broken down into milliseconds. This lets you see if any event you initiate on a given web page is making API requests in the background. Simply click the circular record button, perform actions on a web page, and stop the recording. Then you can review the triggered events and investigate the initiated actions. <a href="#figure6-16" id="figureanchor6-16">Figure 6-16</a> shows a recording of clicking the login button of a web page.</p>
<span epub:type="pagebreak" id="Page_142" title="142"/><figure>
<img alt="Screenshot of a timeline in the DevTools performance tab highlighting the number of milliseconds elapsed after a click of a login button" class="" src="image_fi/502444c06/F06016.png"/>
<figcaption><p><a id="figure6-16">Figure 6-16</a>: A performance recording within DevTools</p></figcaption>
</figure>
<p>Under “Main,” you can see that a click event occurred, initiating a POST request to the URL <em>/identity/api/auth/login</em>, a clear indication that you’ve discovered an API. To help you spot activity on the timeline, consult the peaks and valleys on the graph located near the top. A peak represents an event, such as a click. Navigate to a peak and investigate the events by clicking the timeline.</p>
<p>As you can see, DevTools is filled with powerful tools that can help you discover APIs. Do not underestimate the usefulness of its various modules.</p>
<h3 id="h2-502444c06-0011">Validating APIs with Burp Suite</h3>
<p class="BodyFirst">Not only will Burp Suite help you find APIs, but it can also be your primary mode of validating your discoveries. To validate APIs using Burp, intercept an HTTP request sent from your browser and then use the Forward button to send it to the server. Next, send the request to the Repeater module, where you can view the raw web server response (see <a href="#figure6-17" id="figureanchor6-17">Figure 6-17</a>).</p>
<p>As you can see in this example,<b> </b>the server returns a 401 Unauthorized status code, which means that I am not authorized to use the API. Compare this request to one that is for a nonexistent resource, and you will see that your target typically responds to nonexistent resources in a certain way. (To request a nonexistent resource, simply add various gibberish to the URL <span epub:type="pagebreak" id="Page_143" title="143"/>path in Repeater, like <em>GET /user/test098765</em>. Send the request in Repeater and see how the web server responds. Typically, you should get a 404 or similar response.)</p>
<figure>
<img alt="Screenshot of an HTTP response in Burp Suite" class="keyline" src="image_fi/502444c06/F06017.png"/>
<figcaption><p><a id="figure6-17">Figure 6-17</a>: The web server returns an HTTP 401 Unauthorized error.</p></figcaption>
</figure>
<p>The verbose error message found under the <code>WWW-Authenticate</code> header reveals the path <em>/api/auth</em>, validating the existence of the API. Return to <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> for a crash course on using Burp.</p>
<h3 id="h2-502444c06-0012">Crawling URIs with OWASP ZAP</h3>
<p class="BodyFirst">One of the objectives of active reconnaissance is to discover all of a web page’s directories and files, also known as <em>URIs</em>, or <em>uniform resource identifiers</em>. There are two approaches to discovering a site’s URIs: crawling and brute force. OWASP ZAP crawls web pages to discover content by scanning each page for references and links to other web pages.</p>
<p>To use ZAP, open it and click past the session pop-up. If it isn’t already selected, click the <b>Quick Start</b> tab, shown in <a href="#figure6-18" id="figureanchor6-18">Figure 6-18</a>. Enter the target URL and click <b>Attack</b>.</p>
<figure>
<img alt="Screenshot of the ZAP Quick Start interface, which accepts a URL to attack and has “Use traditional spider” checked" class="keyline" src="image_fi/502444c06/F06018.png"/>
<figcaption><p><a id="figure6-18">Figure 6-18</a>: An automated scan set up to scan a target with OWASP ZAP</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_144" title="144"/>After the automated scan commences, you can watch the live results using the Spider or Sites tab. You may discover API endpoints in these tabs. If you do not find any obvious APIs, use the Search tab, shown in <a href="#figure6-19" id="figureanchor6-19">Figure 6-19</a>, and look for terms like “API,” “GraphQL,” “JSON,” “RPC,” and “XML” to find potential API endpoints.</p>
<figure>
<img alt="Screenshot of a ZAP interface listing discovered API endpoints and showing the code in which they were found" class="keyline" src="image_fi/502444c06/F06019.png"/>
<figcaption><p><a id="figure6-19">Figure 6-19</a>: The power of searching the ZAP automated scan results for APIs</p></figcaption>
</figure>
<p>Once you’ve found a section of the site you want to investigate more thoroughly, begin manual exploration using the ZAP HUD to interact with the web application’s buttons and user input fields. While you do this, ZAP will perform additional scans for vulnerabilities. Navigate to the <b>Quick Start</b> tab and select <b>Manual Explore</b> (you may need to click the back arrow to exit the automated scan). On the Manual Explore screen, shown in <a href="#figure6-20" id="figureanchor6-20">Figure 6-20</a>, select your desired browser and then click <b>Launch Browser</b>.</p>
<figure>
<img alt="Screenshot of the ZAP Manual Explore page, which accepts a URL to test and has “Enable HUD” selected" class="keyline" src="image_fi/502444c06/F06020.png"/>
<figcaption><p><a id="figure6-20">Figure 6-20</a>: Launching the Manual Explore option of Burp Suite</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_145" title="145"/>The ZAP HUD should now be enabled. Click <b>Continue to Your Target</b> in the ZAP HUD welcome screen (see <a href="#figure6-21" id="figureanchor6-21">Figure 6-21</a>).</p>
<figure>
<img alt="Screenshot of the ZAP HUD interface showing a welcome message, as well as “Continue to your target” and “Take the HUD tutorial” buttons" class="keyline" src="image_fi/502444c06/F06021.png"/>
<figcaption><p><a id="figure6-21">Figure 6-21</a>: This is the first screen you will see when you launch the ZAP HUD.</p></figcaption>
</figure>
<p>Now you can manually explore the target web application, and ZAP will work in the background to automatically scan for vulnerabilities. In addition, ZAP will continue to search for additional paths while you navigate around the site. Several buttons should now line the left and right borders of the browser. The colored flags represent page alerts, which could be vulnerability findings or interesting anomalies. These flagged alerts will be updated as you browse around the site.</p>
<h3 id="h2-502444c06-0013">Brute-Forcing URIs with Gobuster</h3>
<p class="BodyFirst">Gobuster can be used to brute-force URIs and DNS subdomains from the command line. (If you prefer a graphical user interface, check out OWASP’s Dirbuster.) In Gobuster, you can use wordlists for common directories and subdomains to automatically request every item in the wordlist, send the items to a web server, and filter the interesting server responses. The results generated from Gobuster will provide you with the URL path and the HTTP status response codes. (While you can brute-force URIs with Burp Suite’s Intruder, Burp Community Edition is much slower than Gobuster.)</p>
<p>Whenever you’re using a brute-force tool, you’ll have to balance the size of the wordlist and the length of time needed to achieve results. Kali has directory wordlists stored under <em>/usr/share/wordlists/dirbuster</em> that are thorough but will take some time to complete. Instead, you can use the <em>~/api/wordlists</em> we set up in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, which will speed up your Gobuster scans since the wordlist is relatively short and contains only directories related to APIs.</p>
<p><span epub:type="pagebreak" id="Page_146" title="146"/>The following example uses an API-specific wordlist to find the directories on an IP address:</p>
<pre><code>$ <b>gobuster dir -u http://192.168.195.132:8000 -w /home/hapihacker/api/wordlists/common_apis_160</b>
========================================================
Gobuster
by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)
========================================================
[+] Url:                     http://192.168.195.132:8000
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /home/hapihacker/api/wordlists/common_apis_160
[+] Negative Status codes:   404
[+] User Agent:              gobuster
[+] Timeout:                 10s
========================================================
09:40:11 Starting gobuster in directory enumeration mode
========================================================
/api                  (Status: 200) [Size: 253]
/admin                (Status: 500) [Size: 1179]
/admins               (Status: 500) [Size: 1179]
/login                (Status: 200) [Size: 2833]
/register             (Status: 200) [Size: 2846]</code></pre>
<p>Once you find API directories like the <em>/api</em> directory shown in this output, either by crawling or brute force, you can use Burp to investigate them further. Gobuster has additional options, and you can list them using the <code>-h</code> option:</p>
<pre><code>$ <b>gobuster dir -h</b></code></pre>
<p>If you would like to ignore certain response status codes, use the option <code>-b</code>. If you would like to see additional status codes, use <code>-x</code>. You could enhance a Gobuster search with the following:</p>
<pre><code>$ <b>gobuster dir -u http://targetaddress/ -w /usr/share/wordlists/api_list/common_apis_160 -x 200,202,301 -b 302</b></code></pre>
<p>Gobuster provides a quick way to enumerate active URLs and find API paths.</p>
<h3 id="h2-502444c06-0014">Discovering API Content with Kiterunner</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, I covered the amazing accomplishments of Assetnote’s Kiterunner, the best tool available for discovering API endpoints and resources. Now it’s time to put this tool to use.</p>
<p>While Gobuster works well for a quick scan of a web application to discover URL paths, it typically relies on standard HTTP GET requests. Kiterunner will not only use all HTTP request methods common with APIs (GET, POST, PUT, and DELETE) but also mimic common API path structures. In other words, instead of requesting GET <em>/api/v1/user/create</em>, <span epub:type="pagebreak" id="Page_147" title="147"/>Kiterunner will try POST <em>POST /api/v1/user/create</em>, mimicking a more realistic request.</p>
<p>You can perform a quick scan of your target’s URL or IP address like this:</p>
<pre><code>$ <b>kr scan http://192.168.195.132:8090 -w ~/api/wordlists/data/kiterunner/routes-large.kite</b>

+----------------------+------------------------------------------------------------------------------------------+-------------------------------------------------------------------
| SETTING              | VALUE                                                                |
+----------------------+------------------------------------------------------------------------------------------+-------------------------------------------------------------------
| delay                | 0s                                                                   |
| full-scan            | false                                                                |
| full-scan-requests   | 1451872                                                              |
| headers              | [x-forwarded-for:127.0.0.1]                                          |
| kitebuilder-apis     | [/home/hapihacker/api/wordlists/data/kiterunner/routes-large.kite]   |
| max-conn-per-host    | 3                                                                    |
| max-parallel-host    | 50                                                                   |
| max-redirects        | 3                                                                    |
| max-timeout          | 3s                                                                   |
| preflight-routes     | 11                                                                   |
| quarantine-threshold | 10                                                                   |
| quick-scan-requests  | 103427                                                               |
| read-body            | false                                                                |
| read-headers         | false                                                                |
| scan-depth           | 1                                                                    |
| skip-preflight       | false                                                                |
| target               | http://192.168.195.132:8090                                          |
| total-routes         | 957191                                                               |
| user-agent           | Chrome. Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36                      |
+----------------------+-----------------------------------------------------------------------

POST    400 [    941,   46,  11] http://192.168.195.132:8090/trade/queryTransationRecords 0cf689f783e6dab12b6940616f005ecfcb3074c4
POST    400 [    941,   46,  11] http://192.168.195.132:8090/event 0cf6890acb41b42f316e86efad29ad69f54408e6
GET     301 [    243,    7,  10] http://192.168.195.132:8090/api-docs -&gt; /api-docs/?group=63578528&amp;route=33616912 0cf681b5cf6c877f2e620a8668a4abc7ad07e2db</code></pre>
<p>As you can see, Kiterunner will provide you with a list of interesting paths. The fact that the server is responding uniquely to requests to certain <em>/api/</em> paths indicates that the API exists.</p>
<p>Note that we conducted this scan without any authorization headers, which the target API likely requires. I will demonstrate how to use Kiterunner with authorization headers in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<p>If you want to use a text wordlist rather than a <em>.kite </em>file, use the <code>brute</code> option with the text file of your choice:</p>
<pre><code>$ <b>kr brute </b><var class="bold">&lt;target&gt;</var><b> -w ~/api/wordlists/data/automated/nameofwordlist.txt</b></code></pre>
<p><span epub:type="pagebreak" id="Page_148" title="148"/>If you have many targets, you can save a list of line-separated targets as a text file and use that file as the target. You can use any of the following line-separated URI formats as input:</p>
<ol class="none">
<li><em>Test.com</em></li>
<li><em>Test2.com:443</em></li>
<li><em>http://test3.com</em></li>
<li><em>http://test4.com</em></li>
<li><em>http://test5.com:8888/api</em></li>
</ol>
<p>One of the coolest Kiterunner features is the ability to replay requests. Thus, not only will you have an interesting result to investigate, you will also be able to dissect exactly why that request is interesting. In order to replay a request, copy the entire line of content into Kiterunner, paste it using the <code>kb replay</code> option, and include the wordlist you used:</p>
<pre><code>$ <b>kr kb replay "GET     414 [    183,    7,   8] http://192.168.50.35:8888/api/privatisations/count 0cf6841b1e7ac8badc6e237ab300a90ca873d571" -w ~/api/wordlists/data/kiterunner/routes-large.kite</b></code></pre>
<p>Running this will replay the request and provide you with the HTTP response. You can then review the contents to see if there is anything worthy of investigation. I normally review interesting results and then pivot to testing them using Postman and Burp Suite.</p>
<h2 id="h1-502444c06-0003">Summary</h2>
<p class="BodyFirst">In this chapter, we took a practical dive into discovering APIs using passive and active reconnaissance. Information gathering is arguably the most important part of hacking APIs for a few reasons. First, you cannot attack an API if you cannot find it. Passive reconnaissance will provide you with insight into an organization’s public exposure and attack surface. You may be able to find some easy wins such as passwords, API keys, API tokens, and other information disclosure vulnerabilities.</p>
<p>Next, actively engaging with your client’s environment will uncover the current operational context of their API, such as the operating system of the server hosting it, the API version, the type of API, what supporting software versions are in use, whether the API is vulnerable to known exploits, the intended use of the systems, and how they work together.</p>
<p>In the next chapter, you’ll begin manipulating and fuzzing APIs to discover vulnerabilities.</p>
<h2 class="HeadProject" id="h1-502444c06-0004"><span>Lab #3: Performing Active Recon for a Black Box Test</span></h2>
<p class="BodyFirst">Your company has been approached by a well-known auto services business, crAPI Car Services. The company wants you to perform an API penetration test. In some engagements, the customer will provide you with details such <span epub:type="pagebreak" id="Page_149" title="149"/>as their IP address, port number, and maybe API documentation. However, crAPI wants this to be a black box test. The company is counting on you to find its API and eventually test whether it has any vulnerabilities.</p>
<p>Make sure you have your crAPI lab instance up and running before you proceed. Using your Kali API hacking machine, start by discovering the API’s IP address. My crAPI instance is located at <em>192.168.50.35</em>. To discover the IP address of your locally deployed instance, run <code>netdiscover</code> and then confirm your findings by entering the IP address in a browser. Once you have your target address, use Nmap for general detection scanning.</p>
<p>Begin with a general Nmap scan to find out what you are working with. As discussed earlier, <code>nmap -sC -sV 192.168.50.35 -oA crapi_scan</code> scans the provided target by using service enumeration and default Nmap scripts, and then it saves the results in multiple formats for later review.</p>
<pre><code>Nmap scan report for 192.168.50.35
Host is up (0.00043s latency).
Not shown: 994 closed ports
PORT     STATE SERVICE    VERSION
1025/tcp open  smtp       Postfix smtpd
|_smtp-commands: Hello nmap.scanme.org, PIPELINING, AUTH PLAIN,
5432/tcp open  postgresql PostgreSQL DB 9.6.0 or later
| fingerprint-strings:
|   SMBProgNeg:
|     SFATAL
|     VFATAL
|     C0A000
|     Munsupported frontend protocol 65363.19778: server supports 2.0 to 3.0
|     Fpostmaster.c
|     L2109
|_    RProcessStartupPacket
8000/tcp open  http-alt   WSGIServer/0.2 CPython/3.8.7
| fingerprint-strings:
|   FourOhFourRequest:
|     HTTP/1.1 404 Not Found
|     Date: Tue, 25 May 2021 19:04:36 GMT
|     Server: WSGIServer/0.2 CPython/3.8.7
|     Content-Type: text/html
|     Content-Length: 77
|     Vary: Origin
|     X-Frame-Options: SAMEORIGIN
|     &lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested resource was not found on this server.&lt;/p&gt;
|   GetRequest:
|     HTTP/1.1 404 Not Found
|     Date: Tue, 25 May 2021 19:04:31 GMT
|     Server: WSGIServer/0.2 CPython/3.8.7
|     Content-Type: text/html
|     Content-Length: 77
|     Vary: Origin
|     X-Frame-Options: SAMEORIGIN
|     &lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested resource was not found on this server.&lt;/p&gt;</code></pre>
<p><span epub:type="pagebreak" id="Page_150" title="150"/>This Nmap scan result shows that the target has several open ports, including 1025, 5432, 8000, 8080, 8087, and 8888. Nmap has provided enough information for you to know that port 1025 is running an SMTP mail service, port 5432 is a PostgreSQL database, and the remaining ports received HTTP responses. The Nmap scans also reveal that the HTTP services are using CPython, WSGIServer, and OpenResty web app servers.</p>
<p>Notice the response from port 8080, whose headers suggest an API:</p>
<pre><code>Content-Type: application/json and "error": "Invalid Token" }.</code></pre>
<p>Follow up the general Nmap scan with an all-port scan to see if anything is hiding on an uncommon port:</p>
<pre><code>$ <b>nmap -p- 192.168.50.35</b>

Nmap scan report for 192.168.50.35
Host is up (0.00068s latency).
Not shown: 65527 closed ports
PORT      STATE SERVICE
1025/tcp  open  NFS-or-IIS
5432/tcp  open  postgresql
8000/tcp  open  http-alt
8025/tcp  open  ca-audit-da
8080/tcp  open  http-proxy
8087/tcp  open  simplifymedia
8888/tcp  open  sun-answerbook
27017/tcp open  mongod</code></pre>
<p>The all-port scan discovers a MailHog web server running on 8025 and MongoDB on the uncommon port 27017. These could prove useful when we attempt to exploit the API in later labs.</p>
<p>The results of your initial Nmap scans reveal a web application running on port 8080, which should lead to the next logical step: a hands-on analysis of the web app. Visit all ports that sent HTTP responses to Nmap (namely, ports 8000, 8025, 8080, 8087, and 8888).</p>
<p>For me, this would mean entering the following addresses in a browser:</p>
<ol class="none">
<li><em>http://192.168.50.35:8000</em></li>
<li><em>http://192.168.50.35:8025</em></li>
<li><em>http://192.168.50.35:8080</em></li>
<li><em>http://192.168.50.35:8087</em></li>
<li><em>http://192.168.50.35:8888</em></li>
</ol>
<p>Port 8000 issues a blank web page with the message “The requested resource was not found on this server.”</p>
<p>Port 8025 reveals the MailHog web server with a “welcome to crAPI” email. We will return to this later in the labs.</p>
<p><span epub:type="pagebreak" id="Page_151" title="151"/>Port 8080 returns the <code>{ "error": "Invalid Token" }</code> we received in the first Nmap scan.</p>
<p>Port 8087 shows a “404 page not found” error.</p>
<p>Finally, port 8888 reveals the crAPI login page, as seen in <a href="#figure6-22" id="figureanchor6-22">Figure 6-22</a>.</p>
<p>Due to the errors and information related to authorization, the open ports will likely be of more use to you as an authenticated user.</p>
<figure>
<img alt="Screenshot of the crAPI login interface with a username and password field" class="keyline" src="image_fi/502444c06/F06022.png"/>
<figcaption><p><a id="figure6-22">Figure 6-22</a>: The landing page for crAPI</p></figcaption>
</figure>
<p>Now use DevTools to investigate the JavaScript source files on this page. Visit the Network tab and refresh the page so the source files populate. Select a source file that interests you, right-click it, and send it to the Sources panel.</p>
<p>You should uncover the <em>/static/js/main.f6a58523.chunk.js</em> source file. Search for “API” within this file, and you’ll find references to crAPI API endpoints (see <a href="#figure6-23" id="figureanchor6-23">Figure 6-23</a>).</p>
<p>Congratulations! You’ve discovered your first API using Chrome DevTools for active reconnaissance. By simply searching through a source file, you found many unique API endpoints.</p>
<p>Now, if you review the source file, you should notice APIs involved in the signup process. As a next step, it would be a good idea to intercept the requests for this process to see the API in action. On the crAPI web page, click the <b>Signup</b> button. Fill in the name, email, phone, and password fields. Then, before clicking the Signup button at the bottom of the page, start Burp Suite and use the FoxyProxy Hackz proxy to intercept your browser traffic. Once Burp Suite and the Hackz proxy are running, click the <b>Signup</b> button.</p>
<span epub:type="pagebreak" id="Page_152" title="152"/><figure>
<img alt="Screenshot of a file in DevTools showing a list of API endpoints" class="keyline" src="image_fi/502444c06/F06023.png"/>
<figcaption><p><a id="figure6-23">Figure 6-23</a>: The crAPI main JavaScript source file</p></figcaption>
</figure>
<p>In <a href="#figure6-24" id="figureanchor6-24">Figure 6-24</a>, you can see that the crAPI signup page issues a POST request to <em>/identity/api/auth/signup</em> when you register for a new account. This request, captured in Burp, validates that you have discovered the existence of the crAPI API and confirmed firsthand one of the functions of the identified endpoint.</p>
<figure>
<img alt="Screenshot of a POST request in Burp Suite" class="keyline" src="image_fi/502444c06/F06024.png"/>
<figcaption><p><a id="figure6-24">Figure 6-24</a>: The crAPI registration request intercepted using Burp Suite</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_153" title="153"/>Great job! Not only did you discover an API, but you also found a way to interact with it. In our next lab, you’ll interact with this API’s functions and identify its weaknesses. I encourage you to continue testing other tools against this target. Can you discover APIs in any other ways?</p>
</section>
</body>
</html>