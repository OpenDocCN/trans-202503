<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SELECTING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In the previous chapter, we looked at the sorting problem, and here we’ll consider a related problem with many similar algorithms: <i>selection</i>. The basic situation is given a number <i>k</i> and an array with <i>n</i> items, we want to find the value at the array’s <i>k</i>th place if we ordered the array. But we don’t actually need the array to be sorted; we just need to know its <i>k</i>th element. Unlike the sorting problem, JavaScript doesn’t provide a “ready-made” solution for selection, so if you’re in need of this kind of function, you’ll have to use some of the algorithms in this chapter.</p>&#13;
<p class="TX">The way this problem relates to sorting is simple: if you just sort the list of values (using any of the algorithms in the previous chapter), you can quickly produce the <i>k</i>th value of the sorted list for all possible values of <i>k</i>; you just look at the <i>k</i>th place in the sorted array. That would be a good <span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>solution if you actually needed to make many selections from the same array; an <i>O</i>(<i>n</i> log <i>n</i>) sort followed by many <i>O</i>(1) selections. However, there’s no requirement to actually sort the list, and we’ll try to avoid doing that. The selection algorithms that we’ll explore in this chapter perform better than sorting algorithms because they don’t need to sort everything.</p>&#13;
<p class="TX">In the selection problem, if you ask for <i>k</i> = 1, you’re asking for the minimum of the list; <i>k</i> = <i>n</i> asks for the maximum, and <i>k</i> = <i>n</i>/2 asks for the median. Keep in mind that in “real life” <i>k</i> goes from 1 to <i>n</i>, but because of JavaScript’s 0-based arrays, <i>k</i> goes from 0 to one less than the array’s length.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Formally, if the list of values is of even length, the definition of median would ask for the average of the two center values of the sorted array, but we’re not doing that. In order for your selection code to produce the median of arrays with even length, you’d need to call the selection algorithm twice to get the two center values and only then calculate their mean. We’ll just deal with the problem of finding the value at any given position.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-31"/><span class="SANS_Futura_Std_Bold_B_11">Selection Without Comparisons</span></h3>&#13;
<p class="TNI1">In the same way you could implement sorting without comparisons (meaning you never have to compare one key with another), you can use variations of the bitmap and counting sorting methods to find the <i>k</i>th value of a list quickly, without even attempting a partial sort of the data. Remember that these algorithms are limited; they work only for numbers (not key + data of any kind) and preferably numbers in a not very extensive range.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-62"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Bitmap Selection</span></h4>&#13;
<p class="TNI1">The bitmap sort worked by reading all data and setting bits on in a bitmap; after that, outputting the sorted numbers just required walking through the bitmap. You’ll do the same here, except you won’t output all numbers; you need only the <i>k</i>th value in the bitmap. <a href="chapter7.xhtml#fig7-1">Figure 7-1</a> shows the method; assume you want to find the 4th element in the same array used as an example in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig7-1" src="../images/Figure7-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-1: A variation of bitmap sort allows a fast selection algorithm.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First generate the bitmap and then traverse it looking for the 4th set bit, which in this case corresponds to 27.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>The code is as follows:</p>&#13;
<pre id="pre-105"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const bitmapSelect = (arr, k, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const copy = arr.slice(from, to + 1);&#13;
  const minKey = Math.min(...copy);&#13;
  const maxKey = Math.max(...copy);&#13;
&#13;
  const bitmap = new Array(maxKey - minKey + 1).fill(false);&#13;
  copy.forEach((v) =&gt; {&#13;
    if (bitmap[v - minKey]) {&#13;
      throw new Error("Cannot select... duplicate values");&#13;
    } else {&#13;
      bitmap[v - minKey] = true;&#13;
    }&#13;
  });&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> for (let i = minKey, j = from; i &lt;= maxKey; i++) {</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> if (bitmap[i - minKey]) {</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span><b> if (j === k) {</b>&#13;
<b>      </b><span class="Code_CodeAnnotation" aria-label="annotation6">❻</span><b> return i;</b>&#13;
<b>      }</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation7">❼</span><b> j++;</b>&#13;
<b>    }</b>&#13;
<b>  }</b>&#13;
};</code></pre>&#13;
<p class="TX">The parameters for this algorithm are the same as when sorting <span class="CodeAnnotation" aria-label="annotation1">❶</span> with the addition of <span class="SANS_TheSansMonoCd_W5Regular_11">k</span>, the place of interest. The logic to create the bitmap <span class="CodeAnnotation" aria-label="annotation2">❷</span> is exactly the same as for sorting; the only difference comes in the final output <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Set a counter <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> to the first position in the array, and every time you find a set bit <span class="CodeAnnotation" aria-label="annotation4">❹</span>, test whether <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> reached the desired place at <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>; if so, you’re done <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Otherwise, keep looping, after counting one more found number <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">This algorithm is obviously <i>O</i>(<i>n</i>), and if it weren’t for the limitations mentioned earlier, it would be one of the best for solving the selection problem.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-63"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Counting Selection</span></h4>&#13;
<p class="TNI1">Under the same circumstances as for bitmap sort, in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> we considered the counting sort, which didn’t have issues if numbers were repeated in the input. This situation, however, was a problem when using a bitmap.</p>&#13;
<p class="TX">You can apply the same kind of solution here: go through the array, generate the list of counts, and finish by going through the counts from left to right until you find what value is at the <i>k</i>th place.</p>&#13;
<p class="TX">Consider an example using the same numbers from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> (see <a href="chapter7.xhtml#fig7-2">Figure 7-2</a>); you want to find the value at the 4th place in the array.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>&#13;
<figure class="IMG"><img class="img5" id="fig7-2" src="../images/Figure7-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-2: Counting sort also provides a simple selection algorithm.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First find all the counts and then sum through them, from left to right, until the sum equals or exceeds 4; in this case, that happens at value 50 when the accumulated sum goes from 3 to 5. (Keep in mind the case where the sum exceeds <i>k</i> because of repeated values in the input array.)</p>&#13;
<p class="TX">Here’s the logic:</p>&#13;
<pre id="pre-106"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const countingSelect = (arr, k, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const copy = arr.slice(from, to + 1);&#13;
  const minKey = Math.min(...copy);&#13;
  const maxKey = Math.max(...copy);&#13;
&#13;
  const count = new Array(maxKey - minKey + 1).fill(0);&#13;
  copy.forEach((v) =&gt; count[v - minKey]++);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> <b>for (let i = minKey, j = from; i &lt;= maxKey; i++) {</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> if (count[i - minKey]) {</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span><b> j += count[i – minKey];</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation6">❻</span><b> if (j &gt; k) {</b>&#13;
<b>        return i;</b>&#13;
<b>      }</b>&#13;
<b>    }</b>&#13;
<b>  }</b>&#13;
};</code></pre>&#13;
<p class="TX">The parameters are the same as earlier <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and all the logic to generate the counts <span class="CodeAnnotation" aria-label="annotation2">❷</span> is the same as in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. The changes appear when preparing output. First initialize a counter <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> at the first position of the input array <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and every time you find a nonzero count <span class="CodeAnnotation" aria-label="annotation4">❹</span>, update the counter <span class="CodeAnnotation" aria-label="annotation5">❺</span> and see whether you reached or passed <i>k</i> with that sum. If so, return the corresponding value <span class="CodeAnnotation" aria-label="annotation6">❻</span>; otherwise, just keep looping.</p>&#13;
<p class="TX">Again, we have an <i>O</i>(<i>n</i>) algorithm, but we want to be able to handle more general conditions, so let’s move on to selection algorithms based on key-to-key comparisons that will work in every case.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-32"/><span class="SANS_Futura_Std_Bold_B_11">Selecting with Comparisons</span></h3>&#13;
<p class="TNI1">Most algorithms for the selection problem are based on sorting algorithms. The first one we’ll explore is based on selection sort, but we won’t sort the whole array—just its first <i>k</i> values. Selection sort works by finding the minimum of the array and exchanging it with the value at the first place; then it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>looks for the minimum of the remaining values and exchanges it with the value at the second place, and so on, until the whole array is sorted. We’ll do the same, but stop after finding the <i>k</i>th minimum:</p>&#13;
<pre id="pre-107"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const sortingSelect = (arr, k, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = from; i &lt;= k; i++) {&#13;
    let m = i;&#13;
    for (let j = i + 1; j &lt;= to; j++) {&#13;
      if (arr[m] &gt; arr[j]) {&#13;
        m = j;&#13;
      }&#13;
    }&#13;
    if (m !== i) {&#13;
      [arr[i], arr[m]] = [arr[m], arr[i]];&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return arr[k];&#13;
};</code></pre>&#13;
<p class="TX">The parameters for this algorithm are the same as before <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We made a small change in the loop. When sorting, you went through the entire array, but now you’ll stop after having reached the <i>k</i>th place <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The rest of the logic is exactly the same as for the sorting algorithm, except that you return the desired value instead of the sorted array <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">The performance of this algorithm is <i>O</i>(<i>kn</i>), which is an efficient result for low values of <i>k</i> and an asymptotically bad one if <i>k</i> grows and is proportional to <i>n</i>. (See question 7.3 for a unique case.) In particular, if you want to find the middle element of the array, then <i>k</i> = <i>n</i> / 2 and performance becomes <i>O</i>(<i>n</i><sup>2</sup>); you’ll do better with different algorithms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-33"/><span class="SANS_Futura_Std_Bold_B_11">The</span> <span class="SANS_Futura_Std_Bold_B_11">Quickselect Family</span></h3>&#13;
<p class="TNI1">Many selection algorithms are derived from the quicksort code, in particular, the way it partitions an array in relation to a pivot, moving values around so that the array ends up consisting of values lower than the pivot on one side, then the pivot itself, and values greater than the pivot on the other side. In the case of quicksort, after partitioning the array this way, the algorithm continues recursively by sorting each of the two parts; in this case you’ll continue the search in only one of the parts. See <a href="chapter7.xhtml#fig7-3">Figure 7-3</a> for an example where you want to find the 6th element of the array.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>&#13;
<figure class="IMG"><img class="img5" id="fig7-3" src="../images/Figure7-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-3: The pivot technique used in quicksort provides a selection algorithm.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You’ll use the same first pivot scheme as for quicksort and choose the rightmost value (14) as the pivot. After repartitioning the array around 14, the pivot ends at the 4th place in the array. You want the 6th element, so continue searching on the right side of the pivot. There you choose 56 as the pivot, and after repartitioning, 56 ends at the 7th place in the array. That comes after the place you want, so continue searching the left part. You then choose 22 as the pivot. It ends in the 5th place, and you continue searching the right side, which now consists of a single element, so you know for sure 34 is the 6th value in the array. To the left of 34 there are lower values (but not necessarily ordered), and to the right there are greater values.</p>&#13;
<p class="TX">As mentioned in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, the performance of quicksort on average is <i>O</i>(<i>n</i> log <i>n</i>), but in the worst case, it becomes <i>O</i>(<i>n</i><sup>2</sup>). Quickselect’s average performance has been proven to be <i>O</i>(<i>n</i>), but it could become <i>O</i>(<i>n</i><sup>2</sup>) if you generally make unlucky pivot selections, so rather than study a single algorithm, we’ll consider a whole family of them by varying how we choose the pivot.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-64"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Quickselect</span></h4>&#13;
<p class="TNI1">Let’s start with the basic logic. As in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, assume single-field keys that can be compared with the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> operators. Always write tests as <span class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</span>, so adapting the code for a more generic comparison would just require writing <span class="SANS_TheSansMonoCd_W5Regular_11">compare(a,b) &gt; 0</span>, assuming a user-provided <span class="SANS_TheSansMonoCd_W5Regular_11">compare(x,y)</span> function that returns a positive value if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>.</p>&#13;
<p class="TX">The following code implements the basic structure of the quickselect family; the pivot selection part is in bold, and we’ll make changes to that section to get other, enhanced versions of the selection function:</p>&#13;
<pre id="pre-108"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const quickSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
<b>    const pick = left + Math.floor((right + 1 - left) * Math.random());</b>&#13;
<b>    if (pick !== right) {</b>&#13;
<b>      [arr[pick], arr[right]] = [arr[right], arr[pick]];</b>&#13;
<b>    }</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
        p++;&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (p === k) {&#13;
     return;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (p &gt; k) {&#13;
     return quickSelect(arr, k, left, p - 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
     return quickSelect(arr, k, p + 1, right);&#13;
   }&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">The parameters for quickselect <span class="CodeAnnotation" aria-label="annotation1">❶</span> are the same as for selection sort and all the algorithms in this chapter. The start of this algorithm is exactly like quicksort’s, with the option of using a random choice for the pivot, up to and including how you split the array, having the chosen pivot end at position <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The only difference is how to proceed after that. If the pivot ends in the <i>k</i>th position <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you’re done, because that’s the value you want. Otherwise, use recursion to examine the left <span class="CodeAnnotation" aria-label="annotation4">❹</span> or right <span class="CodeAnnotation" aria-label="annotation5">❺</span> partition, whichever includes the <i>k</i>th position. (Actually, you don’t need to use recursion; see question 7.4.)</p>&#13;
<p class="TX">As is, quickselect reorders (partitions) the input array to ensure the element in the <i>k</i>th place isn’t lower than any element before it or greater than any element after it. You can easily get the value itself by writing an auxiliary function:</p>&#13;
<pre id="pre-109"><code>const qSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> quickSelect(arr, k, left, right);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return arr[k];&#13;
};</code></pre>&#13;
<p class="TX">Use quickselect to repartition the array <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and then return the value at the desired position <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (See question 7.5 for a simple modification.) On average, this algorithm can be shown to be linear, but if it happens to choose the worst pivot every time, it becomes quadratic instead. Now consider some alternative pivot-choosing strategies.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-65"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Median of Medians</span></h4>&#13;
<p class="TNI1">The previous version of quickselect could become slow, but you can split the array better. For example, you don’t want either of the two possible partitions to be small in case you have to recurse on the large one.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/>One strategy you can apply is called <i>median of medians</i>, and the idea is as follows:</p>&#13;
<p class="ListNumberF">	1.	Divide the array in groups of up to five elements.</p>&#13;
<p class="ListNumber">	2.	Find the median of each group.</p>&#13;
<p class="ListNumber">	3.	Find the median of the medians found in the previous step.</p>&#13;
<p class="ListNumberL">	4.	Use that value to split the array.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-4">Figure 7-4</a> illustrates this concept; each rectangle is a set of five values in order from low to high from bottom to top (as the vertical arrow shows) with the median in the middle. The medians themselves grow from left (lowest median) to right (highest median) according to the horizontal arrow. The pivot you’ll choose is the median of the set of medians—the center value in the diagram.</p>&#13;
<figure class="IMG"><img class="img1" id="fig7-4" src="../images/Figure7-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-4: The middle element in each column is its median; medians are sorted from left to right, and the center value is not less than the shaded values, a third of the array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter7.xhtml#fig7-4">Figure 7-4</a>, all the gray values (15 out of 45, a third of the complete set) are <i>guaranteed</i> not to be greater than the chosen pivot. Similarly, the chosen pivot is also guaranteed not to be greater than the other third of array values (see <a href="chapter7.xhtml#fig7-5">Figure 7-5</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig7-5" src="../images/Figure7-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-5: In the same situation as <a href="chapter7.xhtml#fig7-4">Figure 7-4</a>, the center value is also not greater than the shaded values, a third of the array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>This means the chosen pivot will be such that it splits the array somehow between 33/66 percent and 50/50 percent. At worst, you’ll have to apply recursion in a new array that is two-thirds the size of the original array (and, at best, one that’s only one-third the size) and that can be shown to produce <i>O</i>(<i>n</i>) performance.</p>&#13;
<p class="TX">The following code implements this method (the bold indicates the parts that changed):</p>&#13;
<pre id="pre-110"><code>const quickSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
<b>    let mom;</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span><b> if (right - left &lt; 5) {</b>&#13;
<b>      mom = simpleMedian(arr, left, right);</b>&#13;
<b>    } else {</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> let j = left – 1;</b>&#13;
<b>    for (let i = left; i &lt;= right; i += 5) {</b>&#13;
<b>      </b><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> const med = simpleMedian(arr, i, Math.min(i + 4, right));</b>&#13;
<b>        j++;</b>&#13;
<b>      </b><span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> [arr[j], arr[med]] = [arr[med], arr[j]];</b>&#13;
<b>      }</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span><b> mom = Math.floor((left + j) / 2);</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation6">❻</span><b> quickSelect(arr, mom, left, j);</b>&#13;
<b>    }</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation7">❼</span><b> [arr[right], arr[mom]] = [arr[mom], arr[right]];</b>&#13;
&#13;
    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
        p++;&#13;
      }&#13;
    }&#13;
    [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
    if (p === k) {&#13;
      return;&#13;
    } else if (p &gt; k) {&#13;
      return quickSelect(arr, k, left, p - 1);&#13;
    } else {&#13;
      return quickSelect(arr, k, p + 1, right);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the array is short enough (five elements or fewer) <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you can use another algorithm to find the median of medians (<span class="SANS_TheSansMonoCd_W5Regular_11">mom</span>). If the array has more than five elements <span class="CodeAnnotation" aria-label="annotation2">❷</span>, consider sets of five elements at a time. You find the median of the set <span class="CodeAnnotation" aria-label="annotation3">❸</span> and move it to the left of the original array <span class="CodeAnnotation" aria-label="annotation4">❹</span> by swapping, so all medians end up together starting at position <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> of the array. You now want the median of this (smaller) set, so you calculate <span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>its position <span class="CodeAnnotation" aria-label="annotation5">❺</span> and use recursion <span class="CodeAnnotation" aria-label="annotation6">❻</span> to find the desired pivot. Once you’ve found it, swap it with the value at the right of the array <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and from that point onward, it’s the same pivoting logic as shown earlier.</p>&#13;
<p class="TX">Now complete the code. You need a fast <span class="SANS_TheSansMonoCd_W5Regular_11">simpleMedian(...)</span> algorithm to find the median of an array of up to five elements, and an insertion sort does the job (you also could use the <span class="SANS_TheSansMonoCd_W5Regular_11">sortingSelect(...)</span> code from the section “<span class="Xref">Selecting with Comparisons</span>” on page <span class="Xref">124</span>):</p>&#13;
<pre id="pre-111"><code>const simpleMedian = (arr, left, right) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> insertionSort(arr, left, right);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return Math.floor((left + right) / 2);&#13;
};</code></pre>&#13;
<p class="TX">Sort the whole array <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which isn’t very slow because an insertion sort is quite speedy for such a small set of values, and then choose the middle element of the sorted array <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">This logic works well and has guaranteed results, unlike the original quickselect that had a worst case different from the average case.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-66"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Repeated Step</span></h4>&#13;
<p class="TNI1">Another variation on how to select the pivot is called <i>repeated step</i>. This algorithm seemingly does a worse job of partitioning an array, but it has advantages in terms of speed. Choosing the median of three elements is quite quick using the “ninther” technique (as described in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>): first go through the array, generating a set by choosing the median out of every trio of values; then, go through that set of medians to create a second set by choosing the median out of every trio of medians. <a href="chapter7.xhtml#fig7-6">Figure 7-6</a> shows how this would work for an array with 18 elements. The idea is exactly the same for larger arrays, but there’s not enough space to show it here.</p>&#13;
<figure class="IMG"><img class="img1" id="fig7-6" src="../images/Figure7-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-6: Repeatedly applying the “median of three” process reduces the original array to one-ninth of its size.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>The repeated step of choosing the median of three reduces the original array to one-ninth of its size and makes recursion go very quickly. (In a sense, you are choosing the median of medians of medians.) The implementation is as follows:</p>&#13;
<pre id="pre-112"><code>const simpleMedian = (arr, left, right) =&gt; {&#13;
  insertionSort(arr, left, right);&#13;
  return Math.floor((left + right) / 2);&#13;
};&#13;
&#13;
const quickSelect = (arr, k, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span><b> let mom;</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> if (right - left &lt; 9) {</b>&#13;
<b>      mom = simpleMedian(arr, left, right);</b>&#13;
<b>    } else {</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> let j1 = left - 1;</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation4">❹</span><b> for (let i = left; i &lt;= right; i += 3) {</b>&#13;
<b>        const med = simpleMedian(arr, i, Math.min(i + 2, right));</b>&#13;
<b>        j1++;</b>&#13;
<b>        [arr[j1], arr[med]] = [arr[med], arr[j1]];</b>&#13;
<b>      }</b>&#13;
&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span><b> let j2 = left - 1;</b>&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation6">❻</span><b> for (let i = left; i &lt;= j1; i += 3) {</b>&#13;
<b>        const med = simpleMedian(arr, i, Math.min(i + 2, j1));</b>&#13;
<b>        j2++;</b>&#13;
<b>        [arr[j2], arr[med]] = [arr[med], arr[j2]];</b>&#13;
<b>      }</b>&#13;
&#13;
<b>    </b><span class="Code_CodeAnnotation" aria-label="annotation7">❼</span><b> mom = Math.floor((left + j2) / 2);</b>&#13;
<b>      quickSelect(arr, mom, left, j2);</b>&#13;
<b>    }</b>&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation8">❽</span><b> [arr[right], arr[mom]] = [arr[mom], arr[right]];</b>&#13;
&#13;
    const pivot = arr[right];&#13;
&#13;
    let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
        p++;&#13;
      }&#13;
    }&#13;
    [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
    if (p === k) {&#13;
      return;&#13;
    } else if (p &gt; k) {&#13;
      quickSelect(arr, k, left, p - 1);&#13;
    } else {&#13;
      quickSelect(arr, k, p + 1, right);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">mom</span> variable ends up with the median of medians position in the array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the array is less than nine elements long <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you don’t need to do any fancy work; just use a sort-based algorithm to find the desired median. Variable <span class="SANS_TheSansMonoCd_W5Regular_11">j1</span> keeps track of the medians you’ve swapped to the left of the array <span class="CodeAnnotation" aria-label="annotation3">❸</span>. A simple loop goes through the array’s elements, three at a time, finding the median of that trio and swapping it to the left <span class="CodeAnnotation" aria-label="annotation4">❹</span>. You then perform the same logic again, using a new <span class="SANS_TheSansMonoCd_W5Regular_11">j2</span> variable <span class="CodeAnnotation" aria-label="annotation5">❺</span> and another loop <span class="CodeAnnotation" aria-label="annotation6">❻</span>. After these loops, positions from <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">j2</span> have the medians of medians <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and you apply the algorithm recursively to find its median, which you swap with the element at right <span class="CodeAnnotation" aria-label="annotation8">❽</span>, so you can proceed with the rest of the otherwise unchanged quickselect algorithm.</p>&#13;
<p class="TX">This algorithm can also be proved to have <i>O</i>(<i>n</i>) performance, so it’s a good option. Why use recursion after two rounds of finding the medians of medians and not go on? (See question 7.6.)</p>&#13;
<p class="TX">So far you’ve explored algorithms that find the <i>k</i>th element for any value of <i>k</i>; this chapter finishes by explicitly considering the problem of finding the center element of an array.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-34"/><span class="SANS_Futura_Std_Bold_B_11">Finding the Median with Lazy Select</span></h3>&#13;
<p class="TNI1">If you want to find the median (remember the working definition isn’t the one used in statistics; you just choose the element closest to the center of the array without any particular considerations for arrays of even length), you could obviously use any of the algorithms in this chapter, letting <i>k</i> be half the length of the input array. However, there are some other ways to find the center value, and in this section, we’ll consider an interesting one that’s based on random sampling (you’ll study sampling algorithms in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>) and probability calculations. The lazy select algorithm uses sampling and may find the right value with a single pass with an <i>O</i>(<i>n</i><sup>–1/4</sup>) probability of failure, looping again and again as needed until it succeeds.</p>&#13;
<p class="TX">The algorithm to find the median of set <i>S</i> of size <i>n</i> works as follows:</p>&#13;
<p class="ListNumberF">	1.	Choose a random sample <i>R</i> of <i>n</i><sup>3/4</sup> values from <i>S</i>.</p>&#13;
<p class="ListNumber">	2.	Sort <i>R</i> using any algorithm.</p>&#13;
<p class="ListNumber">	3.	Choose two values, <i>d</i> and <i>u</i>, in <i>R</i> that will satisfy <i>d</i> &lt; <i>median</i> &lt; <i>u with high probability (</i>you’ll see how to do this shortly).</p>&#13;
<p class="ListNumber">	4.	Let <i>dSize</i> be how many values of <i>R</i> are &lt; <i>d</i>; if <i>dSize</i> &gt; <i>n</i>/2, you failed and must try again.</p>&#13;
<p class="ListNumber">	5.	Let <i>uSize</i> be how many values of <i>R</i> are &gt; <i>u</i>; if <i>uSize</i> &gt; <i>n</i>/2, you must try again.</p>&#13;
<p class="ListNumber">	6.	Let <i>m</i> be the set of values <i>x</i> of <i>S</i> that are <i>d</i> &lt; <i>x</i> &lt; <i>u</i>; if the count exceeds 4<i>n</i><sup>3/4</sup> you must try again.</p>&#13;
<p class="ListNumberL">	7.	Sort <i>m</i> and return the value at its <i>n</i>/2 – <i>dSize</i> position.</p>&#13;
<p class="TX">The proof of performance for this algorithm depends highly on probabilistic arguments, and you won’t see those here. The key concept is that a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>random choice of values <i>R</i>—but not too many, so sorting <i>R</i> is <i>O</i>(<i>n</i>)—should usually be good enough to find lower and upper limits to the median (<i>d</i> and <i>u</i> in the previous list) and that the set of values between <i>d</i> and <i>u</i> should be small enough so that, again, sorting doesn’t go above <i>O</i>(<i>n</i>) in performance. This algorithm may fail, but the probability is low <i>O</i>(<i>n</i><i><sup>–</sup></i><sup>1/4</sup>), meaning that in the worst case, a few new attempts should succeed. As an example, if the odds of failure were 10 percent (which means the algorithm may succeed at first 90 percent of the times), the odds of two failures in a row would be 1 percent (10 percent of 10 percent, resulting in 99 percent odds of success), and three successive failures would happen once every 1,000 times, and so on.</p>&#13;
<p class="TX">The implementation is straightforward, but with lots of math:</p>&#13;
<pre id="pre-113"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const sort = require("../sorting/mergesort");&#13;
&#13;
const lazySelectMedian = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const len = right - left + 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const sR = Math.floor(len ** 0.75);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const dIndex = Math.max(0, Math.floor(sR / 2 – Math.sqrt(len)));&#13;
  const uIndex = Math.min(sR - 1, Math.ceil(sR / 2 + Math.sqrt(len)));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> let dSize, uSize, m;&#13;
  do {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const r = [];&#13;
    for (let i = 0; i &lt; sR; i++) {&#13;
      r.push(arr[left + Math.floor((right - left) * Math.random())]);&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> sort(r);&#13;
&#13;
    dSize = uSize = 0;&#13;
    m = [];&#13;
    for (let i = left; i &lt;= right; i++) {&#13;
      if (r[dIndex] &gt; arr[i]) {&#13;
        dSize++;&#13;
      } else if (arr[i] &gt; r[uIndex]) {&#13;
        uSize++;&#13;
      } else {&#13;
        m.push(arr[i]);&#13;
      }&#13;
    }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span>} while (dSize &gt; len / 2 || uSize &gt; len / 2 || m.length &gt; 4 * sR);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> sort(m);&#13;
  return m[Math.floor(len / 2) - dSize];&#13;
};</code></pre>&#13;
<p class="TX">You use merge sort <span class="CodeAnnotation" aria-label="annotation1">❶</span> to sort arrays when needed; it’s important to choose an <i>O</i>(<i>n</i> log <i>n</i>) algorithm, because you’ll use it with arrays that are at most 4<i>n</i><sup>3/4</sup> size, so the performance becomes <i>O</i>(4<i>n</i><sup>3/4</sup> log 4<i>n</i><sup>3/4</sup>) &lt; <i>O</i>(<i>n</i>). Then you define several variables for the rest of the code: <span class="SANS_TheSansMonoCd_W5Regular_11">len</span> is the size of the input array <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sR</span> is the size of the sample <span class="CodeAnnotation" aria-label="annotation3">❸</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">dIndex</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">uIndex</span> are the positions of <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">u</span> in the sorted <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> array <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">dSize</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">uSize</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span> correspond with the description listed earlier in this section.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/>Use a “sampling with repetition” algorithm <span class="CodeAnnotation" aria-label="annotation6">❻</span> to choose <span class="SANS_TheSansMonoCd_W5Regular_11">sR</span> random values from the input array into the <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> array; making sure no repeated values are sampled would work as well, but the logic would be more complex, as you’ll see in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. After having chosen and sorted <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="CodeAnnotation" aria-label="annotation7">❼</span>, calculate <span class="SANS_TheSansMonoCd_W5Regular_11">dSize</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">uSize</span> (how many values in the input array are smaller than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> or greater than <span class="SANS_TheSansMonoCd_W5Regular_11">u</span>; note that you never actually define <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">u</span>; you just refer to them by their indices) and <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> (with values between <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">u</span>).</p>&#13;
<p class="TX">Finally, you want to know whether the results are as expected <span class="CodeAnnotation" aria-label="annotation8">❽</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">dSize</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">uSize</span> includes more than half the input array, the median isn’t in <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>, as was expected; you failed. Likewise, if <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> is too large, you also failed. If all tests pass, <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> has a proper size that allows you to sort it and choose the median from it <span class="CodeAnnotation" aria-label="annotation9">❾</span>. Note that you account for the <span class="SANS_TheSansMonoCd_W5Regular_11">dSize</span> values lower than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, which precede the array <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>.</p>&#13;
<p class="TX">This algorithm is quite different from most of what you’ve considered in this book, because it depends on probabilistic properties to work, but performance is usually quite good, and it finds the median with few iterations, if any.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-35"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter you studied several algorithms for selection, most of which are closely related to the sorting algorithms examined in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. The selection problem isn’t as common as sorting, so it’s no surprise that JavaScript doesn’t provide a ready-made method for it, so the implementations in this chapter cannot be avoided if you need this functionality. Most of the algorithms covered here have <i>O</i>(<i>n</i>) performance, which is optimum, but the proofs of their behaviors are often complex, so they were omitted.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-36"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>7.1  Tennis Sudden Death</b></p>&#13;
<p class="ListPlainFirst">Suppose 111 tennis players enter a knockout tournament to find the champion. In each round, random pairs of players play each other, and the loser is out of the tournament, while the winner passes to the next round. If there’s an odd number of players, one player gets a free pass to the next round. How many matches will be necessary to find the champion? How many extra matches will you need to find the second-best player? (And no, whoever lost to the champion in the last game isn’t necessarily the second-best player.) Can you generalize your answer for <i>n</i> players?</p>&#13;
<p class="ListHead"><b>7.2  Take Five</b></p>&#13;
<p class="ListPlainFirst">“Take Five” is the name of a jazz piece that Dave Brubeck made famous, but in this case you want to take the median of five elements. What’s the absolute minimum number of comparisons that guarantees finding that median? Can you provide an appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">medianOf5(a,b,c,d,e)</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>function that will return the median of its five arguments? You could be achieving a better <span class="SANS_TheSansMonoCd_W5Regular_11">simpleMedian()</span> function with this!</p>&#13;
<p class="ListHead"><b>7.3  Top to Bottom</b></p>&#13;
<p class="ListPlainFirst">If <i>k</i> is close to <i>n</i>, the length of the input array, your selection sort–based algorithm would have a bad quadratic performance, but you can make it quite better with a simple trick; can you see how?</p>&#13;
<p class="ListHead"><b>7.4  Just Iterate</b></p>&#13;
<p class="ListPlainFirst">Quickselect does a single tail recursive call and may be rewritten to avoid all recursion; can you do it?</p>&#13;
<p class="ListHead"><b>7.5  Select Without Changing</b></p>&#13;
<p class="ListPlainFirst">As is, <span class="SANS_TheSansMonoCd_W5Regular_11">qSelect</span> returns the desired <i>k</i>th value, but it has a side effect: the input array will be changed. Can you modify <span class="SANS_TheSansMonoCd_W5Regular_11">qSelect</span> to avoid this secondary effect?</p>&#13;
<p class="ListHead"><b>7.6  The Sicilian Way</b></p>&#13;
<p class="ListPlainFirst">The repeated step selection algorithm does two rounds of choosing medians of three, and finally, it uses recursion to find the median of the resulting array of medians of medians. Implement the following variation: instead of recursion, keep applying the same method (grouping by three, choosing the median, and so on) until the resulting array is less than 3 in length, and then choose the pivot from that small array without any recursion.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>