- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust Ecosystem
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Programming rarely happens in a vacuum these days—nearly every Rust crate you
    build is likely to take dependencies on *some* code that wasn’t written by you.
    Whether this trend is good, bad, or a little of both is a subject of heavy debate,
    but either way, it’s a reality of today’s developer experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this brave new interdependent world, it’s more important than ever to have
    a solid grasp of what libraries and tools are available and to stay up to date
    on the latest and greatest of what the Rust community has to offer. This chapter
    is dedicated to how you can leverage, track, understand, and contribute back to
    the Rust ecosystem. Since this is the final chapter, in the closing section I’ll
    also provide some suggestions of additional resources you can explore to continue
    developing your Rust skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What’s Out There?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite its relative youth, Rust already has an ecosystem large enough that
    it’s hard to keep track of everything that’s available. If you know what you want,
    you may be able to search your way to a set of appropriate crates and then use
    download statistics and superficial vibe-checks on each crate’s repository to
    determine which may make for reasonable dependencies. However, there’s also a
    plethora of tools, crates, and general language features that you might not necessarily
    know to look for that could potentially save you countless hours and difficult
    design decisions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll go through some of the tools, libraries, and Rust features
    I have found helpful over the years in the hopes that they may come in useful
    for you at some point too!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First off, here are some Rust tools I find myself using regularly that you
    should add to your toolbelt:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**`cargo-deny`**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Provides a way to lint your dependency graph. At the time of writing, you can
    use `cargo-deny` to allow only certain licenses, deny-list crates or specific
    crate versions, detect dependencies with known vulnerabilities or that use Git
    sources, and detect crates that appear multiple times with different versions
    in the dependency graph. By the time you’re reading this, there may be even more
    handy lints in place.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-expand`**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Expands macros in a given crate and lets you inspect the output, which makes
    it much easier to spot mistakes deep down in macro transcribers or procedural
    macros. `cargo-expand` is an invaluable tool when you’re writing your own macros.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-hack`**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Helps you check that your crate works with any combination of features enabled.
    The tool presents an interface similar to that of Cargo itself (like `cargo check`,
    `build`, and `test`) but gives you the ability to run a given command with all
    possible combinations (the *powerset*) of the crate’s features.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-llvm-lines`**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Analyzes the mapping from Rust code to the intermediate representation (IR)
    that’s passed to the part of the Rust compiler that actually generates machine
    code (LLVM), and tells you which bits of Rust code produce the largest IR. This
    is useful because a larger IR means longer compile times, so identifying what
    Rust code generates a bigger IR (due to, for example, monomorphization) can highlight
    opportunities for reducing compile times.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-outdated`**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether any of your dependencies, either direct or transitive, have newer
    versions available. Crucially, unlike `cargo update`, it even tells you about
    new major versions, so it’s an essential tool for checking if you’re missing out
    on newer versions due to an outdated major version specifier. Just keep in mind
    that bumping the major version of a dependency may be a breaking change for your
    crate if you expose that dependency’s types in your interface!
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-udeps`**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Identifies any dependencies listed in your *Cargo.toml* that are never actually
    used. Maybe you used them in the past but they’ve since become redundant, or maybe
    they should be moved to `dev-dependencies`; whatever the case, this tool helps
    you trim down bloat in your dependency closure.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While they’re not specifically tools for developing Rust, I highly recommend
    `fd` and `ripgrep` too—they’re excellent improvements over their predecessors
    `find` and `grep` and also happen to be written in Rust themselves. I use both
    every day.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next up are some useful but lesser-known crates that I reach for regularly,
    and that I suspect I will continue to depend on for a long time:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**`bytes`**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Provides an efficient mechanism for passing around subslices of a single piece
    of contiguous memory without having to copy or deal with lifetimes. This is great
    in low-level networking code where you may need multiple views into a single chunk
    of bytes, and copying is a no-no.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`criterion`**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: A statistics-driven benchmarking library that uses math to eliminate noise from
    benchmark measurements and reliably detect changes in performance over time. You
    should almost certainly be using it if you’re including micro-benchmarks in your
    crate.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cxx`**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Provides a safe and ergonomic mechanism for calling C++ code from Rust and Rust
    code from C++. If you’re willing to invest some time into declaring your interfaces
    more thoroughly in advance in exchange for much nicer cross-language compatibility,
    this library is well worth your attention.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`flume`**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Implements a multi-producer, multi-consumer channel that is faster, more flexible,
    and simpler than the one included with the Rust standard library. It also supports
    both asynchronous and synchronous operation and so is a great bridge between those
    two worlds.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`hdrhistogram`**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A Rust port of the High Dynamic Range (HDR) histogram data structure, which
    provides a compact representation of histograms across a wide range of values.
    Anywhere you currently track averages or min/max values, you should most likely
    be using an HDR histogram instead; it can give you much better insight into the
    distribution of your metrics.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`heapless`**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Supplies data structures that do not use the heap. Instead, `heapless`’s data
    structures are all backed by static memory, which makes them perfect for embedded
    contexts or other situations in which allocation is undesirable.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`itertools`**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Extends the `Iterator` trait from the standard library with lots of new convenient
    methods for deduplication, grouping, and computing powersets. These extension
    methods can significantly reduce boilerplate in code, such as where you manually
    implement some common algorithm over a sequence of values, like finding the min
    and max at the same time (`Itertools::minmax`), or where you use a common pattern
    like checking that an iterator has exactly one item (`Itertools::exactly_one`).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`nix`**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Provides idiomatic bindings to system calls on Unix-like systems, which allows
    for a much better experience than trying to cobble together the C-compatible FFI
    types yourself when working with something like `libc` directly.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`pin-project`**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Provides macros that enforce the pinning safety invariants for annotated types,
    which in turn provide a safe pinning interface to those types. This allows you
    to avoid most of the hassle of getting `Pin` and `Unpin` right for your own types.
    There’s also `pin-project-lite`, which avoids the (currently) somewhat heavy dependency
    on the procedural macro machinery at the cost of slightly worse ergonomics.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`ring`**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Takes the good parts from the cryptography library BoringSSL, written in C,
    and brings them to Rust through a fast, simple, and hard-to-misuse interface.
    It’s a great starting point if you need to use cryptography in your crate. You’ve
    already most likely come across this in the `rustls` library, which uses `ring`
    to provide a modern, secure-by-default TLS stack.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`slab`**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Implements an efficient data structure to use in place of `HashMap<Token, T>`,
    where `Token` is an opaque type used only to differentiate between entries in
    the map. This kind of pattern comes up a lot when managing resources, where the
    set of current resources must be managed centrally but individual resources must
    also be accessible somehow.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`static_assertions`**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Provides static assertions—that is, assertions that are evaluated at, and thus
    may fail at, compile time. You can use it to assert things like that a type implements
    a given trait (like `Send`) or is of a given size. I highly recommend adding these
    kinds of assertions for code where those guarantees are likely to be important.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`structopt`**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Wraps the well-known argument parsing library `clap` and provides a way to describe
    your application’s command line interface entirely using the Rust type system
    (plus macro annotations). When you parse your application’s arguments, you get
    a value of the type you defined, and you thus get all the type checking benefits,
    like exhaustive matching and IDE auto-complete.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`thiserror`**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Makes writing custom enumerated error types, like the ones we discussed in Chapter
    4, a joy. It takes care of implementing the recommended traits and following the
    established conventions and leaves you to define just the critical bits that are
    unique to your application.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`tower`**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Effectively takes the function signature `async fn(Request) -> Response` and
    implements an entire ecosystem on top of it. At its core is the `Service` trait,
    which represents a type that can turn a request into a response (something I suspect
    may make its way into the standard library one day). This is a great abstraction
    to build anything that looks like a service on top of.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`tracing`**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Provides all the plumbing needed to efficiently trace the execution of your
    applications. Crucially, it is agnostic to the types of events you’re tracing
    and what you want to do with those events. This library can be used for logging,
    metrics collection, debugging, profiling, and obviously tracing, all with the
    same machinery and interfaces.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust Tooling
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rust toolchain has a few features up its sleeve that you may not know to
    look for. These are usually for very specific use cases, but if they match yours,
    they can be lifesavers!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Rustup
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Rustup, the Rust toolchain installer, does its job so efficiently that it tends
    to fade into the background and get forgotten about. You’ll occasionally use it
    to update your toolchain, set a directory override, or install a component, but
    that’s about it. However, Rustup supports one very handy trick that it’s worthwhile
    to know about: the toolchain override shorthand. You can pass `+toolchain` as
    the first argument to any Rustup-managed binary, and the binary will work as if
    you’d set an override for the given toolchain, run the command, and then reset
    the override back to what it was previously. So, `cargo +nightly miri` will run
    Miri using the nightly toolchain, and `cargo +1.53.0 check` will check if the
    code compiles with Rust 1.53.0\. The latter comes in particularly handy for checking
    that you haven’t broken your minimum supported Rust version contract.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Rustup also has a neat subcommand, `doc`, that opens a local copy of the Rust
    standard library documentation for the current version of the Rust compiler in
    your browser. This is invaluable if you’re developing on the go without an internet
    connection!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Cargo
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cargo also has some handy features that aren’t always easy to discover. The
    first of these is `cargo tree`, a Cargo subcommand built right into Cargo itself
    for inspecting a crate’s dependency graph. This command’s primary purpose is to
    print the dependency graph as a tree. This can be useful on its own, but where
    `cargo tree` really shines is through the `--invert` option: it takes a crate
    identifier and produces an inverted tree showing all the dependency paths from
    the current crate that bring in that dependency. So, for example, `cargo tree
    -i rand` will print all of the ways in which the current crate depends on any
    version of `rand`, including through transitive dependencies. This is invaluable
    if you want to eliminate a dependency, or a particular version of a dependency,
    and wonder why it still keeps being pulled in. You can also pass the `-e features`
    option to include information about why each Cargo feature of the crate in question
    is enabled.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of Cargo subcommands, it’s really easy to write your own, whether for
    sharing with other people or just for your own local development. When Cargo is
    invoked with a subcommand it doesn’t recognize, it checks whether a program by
    the name `cargo-$subcommand` exists. If it does, Cargo invokes that program and
    passes it any arguments that were passed on the command line—so, `cargo foo bar`
    will invoke `cargo-foo` with the argument `bar`. Cargo will even integrate this
    command with `cargo help` by translating `cargo help foo` into a call to `cargo-foo
    --help`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'As you work on more Rust projects, you may notice that Cargo (and Rust more
    generally) isn’t exactly forgiving when it comes to disk space. Each project gets
    its own target directory for its compilation artifacts, and over time you end
    up accumulating several identical copies of compiled artifacts for common dependencies.
    Keeping artifacts for each project separate is a sensible choice, as they aren’t
    necessarily compatible across projects (say, if one project uses different compiler
    flags than another). But in most developer environments, sharing build artifacts
    is entirely reasonable and can save a fair amount of compilation time when switching
    between projects. Luckily, configuring Cargo to share build artifacts is simple:
    just set `[build] target` in your *~/.cargo/config.toml* file to the directory
    you want those shared artifacts to go in, and Cargo will take care of the rest.
    No more target directories in sight! Just make sure you clean out that directory
    every now and again too, and be aware that `cargo clean` will now clean *all*
    of your projects’ build artifacts.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you ever feel like Cargo is taking a suspiciously long time to build
    your crate, you can reach for the currently unstable Cargo `-Ztimings` flag. Running
    Cargo with that flag outputs information about how long it took to process each
    crate, how long build scripts took to run, what crates had to wait for what other
    crates to finish compiling, and tons of other useful metrics. This might highlight
    a particularly slow dependency chain that you can then work to eliminate, or reveal
    a build script that compiles a native dependency from scratch that you can make
    use system libraries instead. If you want to dive even deeper, there’s also `rustc
    -Ztime-passes`, which emits information about where time is spent inside of the
    compiler for each crate—though that information is likely only useful if you’re
    looking to contribute to the compiler itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你觉得 Cargo 构建你的 crate 的时间异常长，你可以尝试当前不稳定的 Cargo `-Ztimings`标志。使用该标志运行 Cargo
    会输出关于每个 crate 处理所花时间的信息、构建脚本运行时间、哪些 crate 需要等待其他 crate 编译完成的时间，以及大量其他有用的度量信息。这可能会突出一个特别慢的依赖链，你可以着手消除它，或者揭示出一个构建脚本，它从头开始编译一个本地依赖库，你可以改为使用系统库。如果你想深入挖掘，还可以使用`rustc
    -Ztime-passes`，它会输出关于每个 crate 在编译器内部花费时间的相关信息——不过这些信息可能只有在你打算为编译器本身做贡献时才有用。
- en: rustc
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: rustc
- en: The Rust compiler also has some lesser-known features that can prove useful
    to enterprising developers. The first is the currently unstable `-Zprint-type-sizes`
    argument, which prints the sizes of all the types in the current crate. This produces
    a lot of information for all but the tiniest crates but is immensely valuable
    when trying to determine the source of unexpected time spent in calls to `memcpy`
    or to find ways to reduce memory use when allocating lots of objects of a particular
    type. The `-Zprint-type-sizes` argument also displays the computed alignment and
    layout for each type, which may point you to places where turning, say, a `usize`
    into a `u32` could have a significant impact on a type’s in-memory representation.
    After you debug a particular type’s size, alignment, and layout, I recommend adding
    static assertions to make sure that they don’t regress over time. You may also
    be interested in the `variant_size_differences` lint, which issues a warning if
    a crate contains `enum` types whose variants significantly differ in size.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器还有一些不太为人所知的功能，对于有创新精神的开发者来说，这些功能可能非常有用。第一个是当前不稳定的`-Zprint-type-sizes`参数，它打印当前
    crate 中所有类型的大小。对于除最小的 crate 外，这会产生大量的信息，但当你试图确定调用`memcpy`时意外的时间消耗来源，或者寻找减少内存使用的方法，尤其是当分配大量特定类型的对象时，它非常有价值。`-Zprint-type-sizes`参数还会显示每种类型的计算对齐方式和布局，这可能会引导你发现，比如将一个`usize`类型转换为`u32`可能会对类型在内存中的表示产生重大影响。在调试完某个特定类型的大小、对齐和布局后，我建议你添加静态断言，确保它们不会随着时间的推移而发生回归。你也许会对`variant_size_differences`
    lint感兴趣，如果一个 crate 包含大小差异显著的`enum`类型的变体，它会发出警告。
- en: If your profiling samples look weird, with stack frames reordered or entirely
    missing, you could also try `-Cforce-frame-pointers = yes`. Frame pointers provide
    a more reliable way to unwind the stack—which is done a lot during profiling—at
    the cost of an extra register being used for function calls. Even though stack
    unwinding *should* work fine with just regular debug symbols enabled (remember
    to set `debug = true` when using the release profile), that’s not always the case,
    and frame pointers may take care of any issues you do encounter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的性能分析样本看起来很奇怪，堆栈帧被重新排序或完全缺失，你也可以尝试`-Cforce-frame-pointers = yes`。帧指针提供了一种更可靠的方式来展开堆栈——在性能分析中，这个操作会被频繁执行——代价是每次函数调用时会使用一个额外的寄存器。即使堆栈展开*应该*在只启用常规调试符号的情况下正常工作（记得在使用发布配置时设置`debug
    = true`），但这并非总是如此，帧指针可能解决你遇到的任何问题。
- en: The Standard Library
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库
- en: The Rust standard library is generally considered to be small compared to those
    of other programming languages, but what it lacks in breadth, it makes up for
    in depth; you won’t find a web server implementation or an X.509 certificate parser
    in Rust’s standard library, but you will find more than 40 different methods on
    the `Option` type alongside over 20 trait implementations. For the types it does
    include, Rust does its best to make available any relevant functionality that
    meaningfully improves ergonomics, so you avoid all that verbose boilerplate that
    can so easily arise otherwise. In this section, I’ll present some types, macros,
    functions, and methods from the standard library that you may not have come across
    before, but that can often simplify or improve (or both) your code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库通常被认为比其他编程语言的标准库要小，但它在深度上弥补了广度的不足；你不会在 Rust 的标准库中找到一个 Web 服务器实现或 X.509
    证书解析器，但你会找到超过 40 种与 `Option` 类型相关的方法，以及 20 多个特征实现。对于包含的类型，Rust 尽力提供所有相关功能，以显著改善可用性，避免了那些容易出现的冗长模板代码。在本节中，我将介绍一些你可能之前没有遇到过的标准库类型、宏、函数和方法，它们往往能简化或改进（或两者兼而有之）你的代码。
- en: Macros and Functions
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 宏和函数
- en: Let’s start off with a few free-standing utilities. First up is the `write!`
    macro, which lets you use format strings to write into a file, a network socket,
    or anything else that implements `Write`. You may already be familiar with it—but
    one little-known feature of `write!` is that it works with both `std::io::Write`
    and `std::fmt::Write`, which means you can use it to write formatted text directly
    into a `String`. That is, you can write `use std::fmt::Write; write!(&mut s, "{}+1={}",
    x, x + 1);` to append the formatted text to the `String s`!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几个独立的实用工具开始。第一个是 `write!` 宏，它允许你使用格式化字符串写入文件、网络套接字或任何其他实现了 `Write` 的对象。你可能已经熟悉它了——但
    `write!` 有一个鲜为人知的特性，那就是它可以同时与 `std::io::Write` 和 `std::fmt::Write` 一起使用，这意味着你可以直接将格式化文本写入
    `String` 中。也就是说，你可以写 `use std::fmt::Write; write!(&mut s, "{}+1={}", x, x + 1);`
    将格式化的文本附加到 `String s` 中！
- en: The `iter::once` function takes any value and produces an iterator that yields
    that value once. This comes in handy when calling functions that take iterators
    if you don’t want to allocate, or when combined with `Iterator::chain` to append
    a single item to an existing iterator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter::once` 函数接受一个值并生成一个迭代器，该迭代器只会返回该值一次。当调用需要迭代器的函数时，如果你不想分配额外的内存，或者与 `Iterator::chain`
    结合使用时，它特别有用，能够将单个元素附加到现有的迭代器上。'
- en: 'We briefly talked about `mem::replace` in Chapter 1, but it’s worth bringing
    up again in case you missed it. This function takes an exclusive reference to
    a `T` and an owned `T`, swaps the two so that the referent is now the owned `T`,
    and returns ownership of the previous referent. This is useful when you need to
    take ownership of a value in a situation where you have only an exclusive reference,
    such as in implementations of `Drop`. See also `mem::take` for when `T: Default`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在第一章简要提到了 `mem::replace`，但值得再提一次，以防你错过了它。这个函数接受对 `T` 的独占引用和一个拥有的 `T`，交换这两者，使得引用对象现在变为拥有的
    `T`，并返回先前引用对象的所有权。当你需要在仅有独占引用的情况下获取一个值的所有权时，这个函数非常有用，比如在 `Drop` 的实现中。对于 `T: Default`，还可以参考
    `mem::take`。'
- en: Types
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型
- en: Next, let’s look at some handy standard library types. The `BufReader` and `BufWriter`
    types are a must for I/O operations that issue many small read or write calls
    to the underlying I/O resource. These types wrap the respective underlying `Read`
    or `Write` and implement `Read` and `Write` themselves, but they additionally
    buffer the operations to the I/O resource such that many small reads do only one
    large read, and many small writes do only one large write. This can significantly
    improve performance as you don’t have to cross the system call barrier into the
    operating system as often.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一些方便的标准库类型。`BufReader` 和 `BufWriter` 类型是进行 I/O 操作时必不可少的，它们会对底层 I/O
    资源发出许多小的读写请求。这些类型包装了各自底层的 `Read` 或 `Write`，并实现了 `Read` 和 `Write` 接口，但它们额外对操作进行缓冲，使得许多小的读取操作合并为一次大的读取，许多小的写入操作合并为一次大的写入。这可以显著提高性能，因为你不需要频繁地跨越系统调用边界进入操作系统。
- en: The `Cow` type, mentioned in Chapter 3, is useful when you want flexibility
    in what types you hold or need flexibility in what you return. You’ll rarely use
    `Cow` as a function argument (recall that you should let the caller allocate if
    necessary), but it’s invaluable as a return type as it allows you to accurately
    represent the return types of functions that may or may not allocate. It’s also
    a perfect fit for types that can be used as inputs *or* outputs, such as core
    types in RPC-like APIs. Say we have a type `EntityIdentifier` like in [Listing
    13-1](#listing13-1) that is used in an RPC service interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cow` 类型，如第3章所述，在你需要对持有的类型或返回的类型有灵活性时非常有用。你很少会将 `Cow` 用作函数参数（回想一下，如果有必要的话，你应该让调用者分配），但作为返回类型时它是无价的，因为它可以精确地表示那些可能会或可能不会分配内存的函数的返回类型。它也非常适合那些既可以作为输入
    *也* 可以作为输出的类型，比如类似 RPC 的 API 中的核心类型。假设我们有一个类型 `EntityIdentifier`，如[示例 13-1](#listing13-1)所示，它用于
    RPC 服务接口中。'
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: A representation of a combined input/output type that requires
    allocation'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-1：一个需要分配的组合输入/输出类型的表示
- en: 'Now imagine two methods: `get_entity` takes an `EntityIdentifier` as an argument,
    and `find_by` returns an `EntityIdentifier` based on some search parameters. The
    `get_entity` method requires only a reference since the identifier will (presumably)
    be serialized before being sent to the server. But for `find_by`, the entity will
    be deserialized from the server response and must therefore be represented as
    an owned value. If we make `get_entity` take `&EntityIdentifier`, it will mean
    callers must still allocate owned `String`s to call `get_entity` even though that’s
    not required by the interface, since it’s required to construct an `EntityIdentifier`
    in the first place! We could instead introduce a separate type for `get_entity`,
    `EntityIdenifierRef`, that holds only `&str` types, but then we’d have two types
    to represent one thing. `Cow` to the rescue! [Listing 13-2](#listing13-2) shows
    an `EntityIdentifier` that instead holds `Cow`s internally.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有两个方法：`get_entity` 以 `EntityIdentifier` 作为参数，`find_by` 根据一些搜索参数返回一个 `EntityIdentifier`。`get_entity`
    方法只需要一个引用，因为标识符将（假设）在发送到服务器之前被序列化。但对于 `find_by`，实体将从服务器响应中反序列化，因此必须作为拥有的值来表示。如果我们让
    `get_entity` 接受 `&EntityIdentifier`，那就意味着调用者仍然必须分配拥有的 `String` 来调用 `get_entity`，即使接口并不要求这么做，因为它在构造
    `EntityIdentifier` 时是必要的！我们可以为 `get_entity` 引入一个单独的类型 `EntityIdenifierRef`，它只持有
    `&str` 类型，但那样的话我们就得用两种类型来表示同一件事。`Cow` 来拯救我们！[示例 13-2](#listing13-2) 展示了一个 `EntityIdentifier`，它内部持有
    `Cow`。
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: A representation of a combined input/output type that does not
    require allocation'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2：一个不需要分配的组合输入/输出类型的表示
- en: With this construction, `get_entity` can take any `EntityIdentifier<'_>`, which
    allows the caller to use just references to call the method. And `find_by` can
    return `EntityIdentifier<'static>`, where all the fields are `Cow::Owned`. One
    type shared across both interfaces, with no unnecessary allocation requirements!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种构造，`get_entity` 可以接受任何 `EntityIdentifier<'_>`，这使得调用者仅需使用引用即可调用该方法。而 `find_by`
    可以返回 `EntityIdentifier<'static>`，其中所有字段都是 `Cow::Owned`。两个接口共享同一个类型，无需不必要的分配！
- en: The `std::sync::Once` type is a synchronization primitive that lets you run
    a given piece of code exactly once, at initialization time. This is great for
    initialization that’s part of an FFI where the library on the other side of the
    FFI boundary requires that the initialization is performed only once.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sync::Once` 类型是一个同步原语，它允许你在初始化时只运行某段代码一次。这对于 FFI 中的初始化非常有用，尤其是当 FFI 边界另一边的库要求初始化只执行一次时。'
- en: The `VecDeque` type is an oft-neglected member of `std::collections` that I
    find myself reaching for surprisingly often—basically, whenever I need a stack
    or a queue. Its interface is similar to that of a `Vec`, and like `Vec` its in-memory
    representation is a single chunk of memory. The difference is that `VecDeque`
    keeps track of both the start and end of the actual data in that single allocation.
    This allows constant-time push and pop from *either* side of the `VecDeque`, meaning
    it can be used as a stack, as a queue, or even both at the same time. The cost
    you pay is that the values are no longer necessarily contiguous in memory (they
    may have wrapped around), which means that `VecDeque<T>` does not implement `AsRef<[T]>`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s round off with a rapid-fire look at some neat methods. First up is `Arc::make_mut`,
    which takes a `&mut Arc<T>` and gives you a `&mut T`. If the `Arc` is the last
    one in existence, it gives you the `T` that was behind the `Arc`; otherwise, it
    allocates a new `Arc<T>` that holds a clone of the `T`, swaps that in for the
    currently referenced `Arc`, and then gives `&mut` to the `T` in the new singleton
    `Arc`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Clone::clone_from` method is an alternative form of `.clone()` that lets
    you reuse an instance of the type you clone rather than allocate a new one. In
    other words, if you already have an `x: T`, you can do `x.clone_from(y)` rather
    than `x = y.clone()`, and you might save yourself some allocations.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fmt::Formatter::debug_*` is by far the easiest way to implement `Debug`
    yourself if `#[derive(Debug)]` won’t work for your use case, such as if you want
    to include only some fields or expose information that isn’t exposed by the ``Debug
    implementations of your type’s fields. When implementing the `fmt` method of `Debug`,
    simply call the appropriate `debug_` method on the `Formatter` that’s passed in
    (`debug_struct` or `debug_map`, for example), call the included methods on the
    resulting type to fill in details about the type (like `field` to add a field
    or `entries` to add a key/value entry), and then call `finish`.``'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
