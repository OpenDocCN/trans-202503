- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust Ecosystem
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Programming rarely happens in a vacuum these days—nearly every Rust crate you
    build is likely to take dependencies on *some* code that wasn’t written by you.
    Whether this trend is good, bad, or a little of both is a subject of heavy debate,
    but either way, it’s a reality of today’s developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this brave new interdependent world, it’s more important than ever to have
    a solid grasp of what libraries and tools are available and to stay up to date
    on the latest and greatest of what the Rust community has to offer. This chapter
    is dedicated to how you can leverage, track, understand, and contribute back to
    the Rust ecosystem. Since this is the final chapter, in the closing section I’ll
    also provide some suggestions of additional resources you can explore to continue
    developing your Rust skills.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Out There?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite its relative youth, Rust already has an ecosystem large enough that
    it’s hard to keep track of everything that’s available. If you know what you want,
    you may be able to search your way to a set of appropriate crates and then use
    download statistics and superficial vibe-checks on each crate’s repository to
    determine which may make for reasonable dependencies. However, there’s also a
    plethora of tools, crates, and general language features that you might not necessarily
    know to look for that could potentially save you countless hours and difficult
    design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll go through some of the tools, libraries, and Rust features
    I have found helpful over the years in the hopes that they may come in useful
    for you at some point too!
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First off, here are some Rust tools I find myself using regularly that you
    should add to your toolbelt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`cargo-deny`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a way to lint your dependency graph. At the time of writing, you can
    use `cargo-deny` to allow only certain licenses, deny-list crates or specific
    crate versions, detect dependencies with known vulnerabilities or that use Git
    sources, and detect crates that appear multiple times with different versions
    in the dependency graph. By the time you’re reading this, there may be even more
    handy lints in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-expand`**'
  prefs: []
  type: TYPE_NORMAL
- en: Expands macros in a given crate and lets you inspect the output, which makes
    it much easier to spot mistakes deep down in macro transcribers or procedural
    macros. `cargo-expand` is an invaluable tool when you’re writing your own macros.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-hack`**'
  prefs: []
  type: TYPE_NORMAL
- en: Helps you check that your crate works with any combination of features enabled.
    The tool presents an interface similar to that of Cargo itself (like `cargo check`,
    `build`, and `test`) but gives you the ability to run a given command with all
    possible combinations (the *powerset*) of the crate’s features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-llvm-lines`**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzes the mapping from Rust code to the intermediate representation (IR)
    that’s passed to the part of the Rust compiler that actually generates machine
    code (LLVM), and tells you which bits of Rust code produce the largest IR. This
    is useful because a larger IR means longer compile times, so identifying what
    Rust code generates a bigger IR (due to, for example, monomorphization) can highlight
    opportunities for reducing compile times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-outdated`**'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether any of your dependencies, either direct or transitive, have newer
    versions available. Crucially, unlike `cargo update`, it even tells you about
    new major versions, so it’s an essential tool for checking if you’re missing out
    on newer versions due to an outdated major version specifier. Just keep in mind
    that bumping the major version of a dependency may be a breaking change for your
    crate if you expose that dependency’s types in your interface!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cargo-udeps`**'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies any dependencies listed in your *Cargo.toml* that are never actually
    used. Maybe you used them in the past but they’ve since become redundant, or maybe
    they should be moved to `dev-dependencies`; whatever the case, this tool helps
    you trim down bloat in your dependency closure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While they’re not specifically tools for developing Rust, I highly recommend
    `fd` and `ripgrep` too—they’re excellent improvements over their predecessors
    `find` and `grep` and also happen to be written in Rust themselves. I use both
    every day.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next up are some useful but lesser-known crates that I reach for regularly,
    and that I suspect I will continue to depend on for a long time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`bytes`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides an efficient mechanism for passing around subslices of a single piece
    of contiguous memory without having to copy or deal with lifetimes. This is great
    in low-level networking code where you may need multiple views into a single chunk
    of bytes, and copying is a no-no.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`criterion`**'
  prefs: []
  type: TYPE_NORMAL
- en: A statistics-driven benchmarking library that uses math to eliminate noise from
    benchmark measurements and reliably detect changes in performance over time. You
    should almost certainly be using it if you’re including micro-benchmarks in your
    crate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`cxx`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a safe and ergonomic mechanism for calling C++ code from Rust and Rust
    code from C++. If you’re willing to invest some time into declaring your interfaces
    more thoroughly in advance in exchange for much nicer cross-language compatibility,
    this library is well worth your attention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`flume`**'
  prefs: []
  type: TYPE_NORMAL
- en: Implements a multi-producer, multi-consumer channel that is faster, more flexible,
    and simpler than the one included with the Rust standard library. It also supports
    both asynchronous and synchronous operation and so is a great bridge between those
    two worlds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`hdrhistogram`**'
  prefs: []
  type: TYPE_NORMAL
- en: A Rust port of the High Dynamic Range (HDR) histogram data structure, which
    provides a compact representation of histograms across a wide range of values.
    Anywhere you currently track averages or min/max values, you should most likely
    be using an HDR histogram instead; it can give you much better insight into the
    distribution of your metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`heapless`**'
  prefs: []
  type: TYPE_NORMAL
- en: Supplies data structures that do not use the heap. Instead, `heapless`’s data
    structures are all backed by static memory, which makes them perfect for embedded
    contexts or other situations in which allocation is undesirable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`itertools`**'
  prefs: []
  type: TYPE_NORMAL
- en: Extends the `Iterator` trait from the standard library with lots of new convenient
    methods for deduplication, grouping, and computing powersets. These extension
    methods can significantly reduce boilerplate in code, such as where you manually
    implement some common algorithm over a sequence of values, like finding the min
    and max at the same time (`Itertools::minmax`), or where you use a common pattern
    like checking that an iterator has exactly one item (`Itertools::exactly_one`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`nix`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides idiomatic bindings to system calls on Unix-like systems, which allows
    for a much better experience than trying to cobble together the C-compatible FFI
    types yourself when working with something like `libc` directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`pin-project`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides macros that enforce the pinning safety invariants for annotated types,
    which in turn provide a safe pinning interface to those types. This allows you
    to avoid most of the hassle of getting `Pin` and `Unpin` right for your own types.
    There’s also `pin-project-lite`, which avoids the (currently) somewhat heavy dependency
    on the procedural macro machinery at the cost of slightly worse ergonomics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`ring`**'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the good parts from the cryptography library BoringSSL, written in C,
    and brings them to Rust through a fast, simple, and hard-to-misuse interface.
    It’s a great starting point if you need to use cryptography in your crate. You’ve
    already most likely come across this in the `rustls` library, which uses `ring`
    to provide a modern, secure-by-default TLS stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`slab`**'
  prefs: []
  type: TYPE_NORMAL
- en: Implements an efficient data structure to use in place of `HashMap<Token, T>`,
    where `Token` is an opaque type used only to differentiate between entries in
    the map. This kind of pattern comes up a lot when managing resources, where the
    set of current resources must be managed centrally but individual resources must
    also be accessible somehow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`static_assertions`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides static assertions—that is, assertions that are evaluated at, and thus
    may fail at, compile time. You can use it to assert things like that a type implements
    a given trait (like `Send`) or is of a given size. I highly recommend adding these
    kinds of assertions for code where those guarantees are likely to be important.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`structopt`**'
  prefs: []
  type: TYPE_NORMAL
- en: Wraps the well-known argument parsing library `clap` and provides a way to describe
    your application’s command line interface entirely using the Rust type system
    (plus macro annotations). When you parse your application’s arguments, you get
    a value of the type you defined, and you thus get all the type checking benefits,
    like exhaustive matching and IDE auto-complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`thiserror`**'
  prefs: []
  type: TYPE_NORMAL
- en: Makes writing custom enumerated error types, like the ones we discussed in Chapter
    4, a joy. It takes care of implementing the recommended traits and following the
    established conventions and leaves you to define just the critical bits that are
    unique to your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`tower`**'
  prefs: []
  type: TYPE_NORMAL
- en: Effectively takes the function signature `async fn(Request) -> Response` and
    implements an entire ecosystem on top of it. At its core is the `Service` trait,
    which represents a type that can turn a request into a response (something I suspect
    may make its way into the standard library one day). This is a great abstraction
    to build anything that looks like a service on top of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`tracing`**'
  prefs: []
  type: TYPE_NORMAL
- en: Provides all the plumbing needed to efficiently trace the execution of your
    applications. Crucially, it is agnostic to the types of events you’re tracing
    and what you want to do with those events. This library can be used for logging,
    metrics collection, debugging, profiling, and obviously tracing, all with the
    same machinery and interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust Tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rust toolchain has a few features up its sleeve that you may not know to
    look for. These are usually for very specific use cases, but if they match yours,
    they can be lifesavers!
  prefs: []
  type: TYPE_NORMAL
- en: Rustup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Rustup, the Rust toolchain installer, does its job so efficiently that it tends
    to fade into the background and get forgotten about. You’ll occasionally use it
    to update your toolchain, set a directory override, or install a component, but
    that’s about it. However, Rustup supports one very handy trick that it’s worthwhile
    to know about: the toolchain override shorthand. You can pass `+toolchain` as
    the first argument to any Rustup-managed binary, and the binary will work as if
    you’d set an override for the given toolchain, run the command, and then reset
    the override back to what it was previously. So, `cargo +nightly miri` will run
    Miri using the nightly toolchain, and `cargo +1.53.0 check` will check if the
    code compiles with Rust 1.53.0\. The latter comes in particularly handy for checking
    that you haven’t broken your minimum supported Rust version contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Rustup also has a neat subcommand, `doc`, that opens a local copy of the Rust
    standard library documentation for the current version of the Rust compiler in
    your browser. This is invaluable if you’re developing on the go without an internet
    connection!
  prefs: []
  type: TYPE_NORMAL
- en: Cargo
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cargo also has some handy features that aren’t always easy to discover. The
    first of these is `cargo tree`, a Cargo subcommand built right into Cargo itself
    for inspecting a crate’s dependency graph. This command’s primary purpose is to
    print the dependency graph as a tree. This can be useful on its own, but where
    `cargo tree` really shines is through the `--invert` option: it takes a crate
    identifier and produces an inverted tree showing all the dependency paths from
    the current crate that bring in that dependency. So, for example, `cargo tree
    -i rand` will print all of the ways in which the current crate depends on any
    version of `rand`, including through transitive dependencies. This is invaluable
    if you want to eliminate a dependency, or a particular version of a dependency,
    and wonder why it still keeps being pulled in. You can also pass the `-e features`
    option to include information about why each Cargo feature of the crate in question
    is enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of Cargo subcommands, it’s really easy to write your own, whether for
    sharing with other people or just for your own local development. When Cargo is
    invoked with a subcommand it doesn’t recognize, it checks whether a program by
    the name `cargo-$subcommand` exists. If it does, Cargo invokes that program and
    passes it any arguments that were passed on the command line—so, `cargo foo bar`
    will invoke `cargo-foo` with the argument `bar`. Cargo will even integrate this
    command with `cargo help` by translating `cargo help foo` into a call to `cargo-foo
    --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you work on more Rust projects, you may notice that Cargo (and Rust more
    generally) isn’t exactly forgiving when it comes to disk space. Each project gets
    its own target directory for its compilation artifacts, and over time you end
    up accumulating several identical copies of compiled artifacts for common dependencies.
    Keeping artifacts for each project separate is a sensible choice, as they aren’t
    necessarily compatible across projects (say, if one project uses different compiler
    flags than another). But in most developer environments, sharing build artifacts
    is entirely reasonable and can save a fair amount of compilation time when switching
    between projects. Luckily, configuring Cargo to share build artifacts is simple:
    just set `[build] target` in your *~/.cargo/config.toml* file to the directory
    you want those shared artifacts to go in, and Cargo will take care of the rest.
    No more target directories in sight! Just make sure you clean out that directory
    every now and again too, and be aware that `cargo clean` will now clean *all*
    of your projects’ build artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you ever feel like Cargo is taking a suspiciously long time to build
    your crate, you can reach for the currently unstable Cargo `-Ztimings` flag. Running
    Cargo with that flag outputs information about how long it took to process each
    crate, how long build scripts took to run, what crates had to wait for what other
    crates to finish compiling, and tons of other useful metrics. This might highlight
    a particularly slow dependency chain that you can then work to eliminate, or reveal
    a build script that compiles a native dependency from scratch that you can make
    use system libraries instead. If you want to dive even deeper, there’s also `rustc
    -Ztime-passes`, which emits information about where time is spent inside of the
    compiler for each crate—though that information is likely only useful if you’re
    looking to contribute to the compiler itself.
  prefs: []
  type: TYPE_NORMAL
- en: rustc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Rust compiler also has some lesser-known features that can prove useful
    to enterprising developers. The first is the currently unstable `-Zprint-type-sizes`
    argument, which prints the sizes of all the types in the current crate. This produces
    a lot of information for all but the tiniest crates but is immensely valuable
    when trying to determine the source of unexpected time spent in calls to `memcpy`
    or to find ways to reduce memory use when allocating lots of objects of a particular
    type. The `-Zprint-type-sizes` argument also displays the computed alignment and
    layout for each type, which may point you to places where turning, say, a `usize`
    into a `u32` could have a significant impact on a type’s in-memory representation.
    After you debug a particular type’s size, alignment, and layout, I recommend adding
    static assertions to make sure that they don’t regress over time. You may also
    be interested in the `variant_size_differences` lint, which issues a warning if
    a crate contains `enum` types whose variants significantly differ in size.
  prefs: []
  type: TYPE_NORMAL
- en: If your profiling samples look weird, with stack frames reordered or entirely
    missing, you could also try `-Cforce-frame-pointers = yes`. Frame pointers provide
    a more reliable way to unwind the stack—which is done a lot during profiling—at
    the cost of an extra register being used for function calls. Even though stack
    unwinding *should* work fine with just regular debug symbols enabled (remember
    to set `debug = true` when using the release profile), that’s not always the case,
    and frame pointers may take care of any issues you do encounter.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rust standard library is generally considered to be small compared to those
    of other programming languages, but what it lacks in breadth, it makes up for
    in depth; you won’t find a web server implementation or an X.509 certificate parser
    in Rust’s standard library, but you will find more than 40 different methods on
    the `Option` type alongside over 20 trait implementations. For the types it does
    include, Rust does its best to make available any relevant functionality that
    meaningfully improves ergonomics, so you avoid all that verbose boilerplate that
    can so easily arise otherwise. In this section, I’ll present some types, macros,
    functions, and methods from the standard library that you may not have come across
    before, but that can often simplify or improve (or both) your code.
  prefs: []
  type: TYPE_NORMAL
- en: Macros and Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start off with a few free-standing utilities. First up is the `write!`
    macro, which lets you use format strings to write into a file, a network socket,
    or anything else that implements `Write`. You may already be familiar with it—but
    one little-known feature of `write!` is that it works with both `std::io::Write`
    and `std::fmt::Write`, which means you can use it to write formatted text directly
    into a `String`. That is, you can write `use std::fmt::Write; write!(&mut s, "{}+1={}",
    x, x + 1);` to append the formatted text to the `String s`!
  prefs: []
  type: TYPE_NORMAL
- en: The `iter::once` function takes any value and produces an iterator that yields
    that value once. This comes in handy when calling functions that take iterators
    if you don’t want to allocate, or when combined with `Iterator::chain` to append
    a single item to an existing iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly talked about `mem::replace` in Chapter 1, but it’s worth bringing
    up again in case you missed it. This function takes an exclusive reference to
    a `T` and an owned `T`, swaps the two so that the referent is now the owned `T`,
    and returns ownership of the previous referent. This is useful when you need to
    take ownership of a value in a situation where you have only an exclusive reference,
    such as in implementations of `Drop`. See also `mem::take` for when `T: Default`.'
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s look at some handy standard library types. The `BufReader` and `BufWriter`
    types are a must for I/O operations that issue many small read or write calls
    to the underlying I/O resource. These types wrap the respective underlying `Read`
    or `Write` and implement `Read` and `Write` themselves, but they additionally
    buffer the operations to the I/O resource such that many small reads do only one
    large read, and many small writes do only one large write. This can significantly
    improve performance as you don’t have to cross the system call barrier into the
    operating system as often.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cow` type, mentioned in Chapter 3, is useful when you want flexibility
    in what types you hold or need flexibility in what you return. You’ll rarely use
    `Cow` as a function argument (recall that you should let the caller allocate if
    necessary), but it’s invaluable as a return type as it allows you to accurately
    represent the return types of functions that may or may not allocate. It’s also
    a perfect fit for types that can be used as inputs *or* outputs, such as core
    types in RPC-like APIs. Say we have a type `EntityIdentifier` like in [Listing
    13-1](#listing13-1) that is used in an RPC service interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: A representation of a combined input/output type that requires
    allocation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine two methods: `get_entity` takes an `EntityIdentifier` as an argument,
    and `find_by` returns an `EntityIdentifier` based on some search parameters. The
    `get_entity` method requires only a reference since the identifier will (presumably)
    be serialized before being sent to the server. But for `find_by`, the entity will
    be deserialized from the server response and must therefore be represented as
    an owned value. If we make `get_entity` take `&EntityIdentifier`, it will mean
    callers must still allocate owned `String`s to call `get_entity` even though that’s
    not required by the interface, since it’s required to construct an `EntityIdentifier`
    in the first place! We could instead introduce a separate type for `get_entity`,
    `EntityIdenifierRef`, that holds only `&str` types, but then we’d have two types
    to represent one thing. `Cow` to the rescue! [Listing 13-2](#listing13-2) shows
    an `EntityIdentifier` that instead holds `Cow`s internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: A representation of a combined input/output type that does not
    require allocation'
  prefs: []
  type: TYPE_NORMAL
- en: With this construction, `get_entity` can take any `EntityIdentifier<'_>`, which
    allows the caller to use just references to call the method. And `find_by` can
    return `EntityIdentifier<'static>`, where all the fields are `Cow::Owned`. One
    type shared across both interfaces, with no unnecessary allocation requirements!
  prefs: []
  type: TYPE_NORMAL
- en: The `std::sync::Once` type is a synchronization primitive that lets you run
    a given piece of code exactly once, at initialization time. This is great for
    initialization that’s part of an FFI where the library on the other side of the
    FFI boundary requires that the initialization is performed only once.
  prefs: []
  type: TYPE_NORMAL
- en: The `VecDeque` type is an oft-neglected member of `std::collections` that I
    find myself reaching for surprisingly often—basically, whenever I need a stack
    or a queue. Its interface is similar to that of a `Vec`, and like `Vec` its in-memory
    representation is a single chunk of memory. The difference is that `VecDeque`
    keeps track of both the start and end of the actual data in that single allocation.
    This allows constant-time push and pop from *either* side of the `VecDeque`, meaning
    it can be used as a stack, as a queue, or even both at the same time. The cost
    you pay is that the values are no longer necessarily contiguous in memory (they
    may have wrapped around), which means that `VecDeque<T>` does not implement `AsRef<[T]>`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s round off with a rapid-fire look at some neat methods. First up is `Arc::make_mut`,
    which takes a `&mut Arc<T>` and gives you a `&mut T`. If the `Arc` is the last
    one in existence, it gives you the `T` that was behind the `Arc`; otherwise, it
    allocates a new `Arc<T>` that holds a clone of the `T`, swaps that in for the
    currently referenced `Arc`, and then gives `&mut` to the `T` in the new singleton
    `Arc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Clone::clone_from` method is an alternative form of `.clone()` that lets
    you reuse an instance of the type you clone rather than allocate a new one. In
    other words, if you already have an `x: T`, you can do `x.clone_from(y)` rather
    than `x = y.clone()`, and you might save yourself some allocations.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fmt::Formatter::debug_*` is by far the easiest way to implement `Debug`
    yourself if `#[derive(Debug)]` won’t work for your use case, such as if you want
    to include only some fields or expose information that isn’t exposed by the ``Debug
    implementations of your type’s fields. When implementing the `fmt` method of `Debug`,
    simply call the appropriate `debug_` method on the `Formatter` that’s passed in
    (`debug_struct` or `debug_map`, for example), call the included methods on the
    resulting type to fill in details about the type (like `field` to add a field
    or `entries` to add a key/value entry), and then call `finish`.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
