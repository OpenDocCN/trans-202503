["```\nif (character >= 'a') and (character <= 'z') then \n      character := chr(ord(character) - 32);\n```", "```\n mov al, character\n        cmp al, 'a'\n        jb  notLower\n        cmp al, 'z'\n        ja  notLower\n\n        and al, 5fh  ; Same as sub(32, al) in this code\n        mov character, al\nnotLower:\n```", "```\nmov   al, character\nlea   rbx, CnvrtLower\nxlat\nmov   character, al\n```", "```\nmov al, [rbx + al * 1]\n```", "```\n mov al, character\n        cmp al, 'a'\n        jb  notLower\n        cmp al, 'z'\n        ja  allDone\n\n        and al, 5fh\n        jmp allDone\n\nnotLower:\n        cmp al, 'A'\n        jb  allDone\n        cmp al, 'Z'\n        ja  allDone\n\n        or  al, 20h\nallDone:\n        mov character, al\n```", "```\nmov   al, character\nlea   rbx, SwapUL\nxlat\nmov   character, al\n```", "```\nB := Func(X); \n```", "```\nfunction Func(X:dword):byte; \n```", "```\nmov edx, X    ; Zero-extends into RDX!\nlea rbx, FuncTable\nmov al, [rbx][rdx * 1]\nmov B, al\n```", "```\nX = Posn % 80;\n```", "```\nY = Posn / 80;\n```", "```\nmov ax, Posn\nmov cl, 80\ndiv cl\n\n; X is now in AH, Y is now in AL.\n```", "```\nlea   rbx, yCoord\nmovzx ecx, Posn           ; Use a plain mov instr if Posn \nmov   al, [rbx][rcx * 1]  ; is uns32 rather than an \nlea   rbx, xCoord         ; uns16 value\nmov   ah, [rbx][rcx * 1]\n```", "```\nmovzx ecx, Posn           ; Use a plain mov instr if Posn\nmov   al, yCoord[rcx * 1] ; is uns32 rather than an\nmov   ah, xCoord[rcx * 1] ; uns16 value\n```", "```\n`element_address` *=* `Base` *+* `index`*`element_size`\n```", "```\nfunction F(`x`:dword):word;\n```", "```\nmovzx ebx, `x`\nlea   r8, F\nmov   ax, [r8][rbx * 2]\n```", "```\nmovzx ebx, `x`\nmov   ax, F[rbx * 2]\n```", "```\nsin `x` = sin `x`|(x∈[–2π,2π])\n```", "```\n–2π <= `x` <= 2π\n```", "```\nfunction val(`x`:word):word; begin\n    case `x` of\n        0: val := 1;\n        1: val := 1;\n        2: val := 4;\n        3: val := 27;\n        4: val := 256;\n        otherwise val := 0;\n    end;\nend; \n```", "```\n mov   ax, 0      ; AX = 0, assume `x` > 4\n        movzx ebx, `x`     ; Note that HO bits of RBX must be 0!\n        lea   r8, val\n        cmp   bx, 4\n        ja    defaultResult\n\n mov   ax, [r8][rbx * 2]\n\ndefaultResult:\n```", "````### 10.1.2 Generating Tables    One big problem with using table lookups is creating the table in the first place. This is particularly true if the table has many entries. Figuring out the data to place in the table, then laboriously entering the data and, finally, checking that data to make sure it is valid, is very time-consuming and boring. For many tables, there is no way around this process. For other tables, there is a better way: using the computer to generate the table for you.    An example is probably the best way to describe this. Consider the following modification to the sine function:  ![eq1001](image_fi/501089c10/eq1001.png)  This states that *x* is an integer in the range 0 to 359 and *r* must be an integer. The computer can easily compute this with the following code:    ``` Thousand dword 1000     .     .     . lea   r8, Sines movzx ebx, x mov   eax, [r8][rbx * 2] ; Get sin(`x`) * 1000 imul  r                  ; Note that this extends EAX into EDX idiv  Thousand           ; Compute (`r` *(sin(`x`) * 1000)) / 1000 ```    (This provides the usual improvement if you can live with the limitations of `LARGEADDRESSAWARE:NO`.)    Note that integer multiplication and division are not associative. You cannot remove the multiplication by 1000 and the division by 1000 because they appear to cancel each other out. Furthermore, this code must compute this function in exactly this order.    All that we need to complete this function is `Sines`, a table containing 360 different values corresponding to the sine of the angle (in degrees) times 1000\\. The C/C++ program in [Listing 10-1](#listing10-1) generates this table for you.    ``` // Listing 10-1: GenerateSines   // A C program that generates a table of sine values for // an assembly language lookup table.  #include <stdlib.h> #include <stdio.h> #include <math.h>  int main(int argc, char **argv) {     FILE *outFile;     int angle;     int r;      // Open the file:          outFile = fopen(\"sines.asm\", \"w\");      // Emit the initial part of the declaration to      // the output file:      fprintf     (          outFile,          \"Sines:\"  // sin(0) = 0     );      // Emit the sines table:          for(angle = 0; angle <= 359; ++angle)     {         // Convert angle in degrees to an angle in          // radians using:                  // radians = angle * 2.0 * pi / 360.0;                  // Multiply by 1000 and store the rounded          // result into the integer variable r.          double theSine =              sin             (                  angle * 2.0 *                  3.14159265358979323846 /                  360.0              );         r = (int) (theSine * 1000.0);           // Write out the integers eight per line to the          // source file.         // Note: If (angle AND %111) is 0, then angle          // is divisible by 8 and we should output a          // newline first.          if((angle & 7) == 0)         {             fprintf(outFile, \"\\n\\tword\\t\");         }         fprintf(outFile, \"%5d\", r);  if ((angle & 7) != 7)         {             fprintf(outFile, \",\");         }      } // endfor     fprintf(outFile, \"\\n\");      fclose(outFile);     return 0;  } // end main ```    Listing 10-1: A C program that generates a table of sines    This program produces the following output (truncated for brevity):    ``` Sines:       word        0,   17,   34,   52,   69,   87,  104,  121       word      139,  156,  173,  190,  207,  224,  241,  258       word      275,  292,  309,  325,  342,  358,  374,  390       word      406,  422,  438,  453,  469,  484,  499,  515       word      529,  544,  559,  573,  587,  601,  615,  629       word      642,  656,  669,  681,  694,  707,  719,  731       word      743,  754,  766,  777,  788,  798,  809,  819       word      829,  838,  848,  857,  866,  874,  882,  891       word      898,  906,  913,  920,  927,  933,  939,  945       word      951,  956,  961,  965,  970,  974,  978,  981       word      984,  987,  990,  992,  994,  996,  997,  998       word      999,  999, 1000,  999,  999,  998,  997,  996       word      994,  992,  990,  987,  984,  981,  978,  974       word      970,  965,  961,  956,  951,  945,  939,  933       word      927,  920,  913,  906,  898,  891,  882,  874                                       .                                       .                                       .       word     -898, -891, -882, -874, -866, -857, -848, -838       word     -829, -819, -809, -798, -788, -777, -766, -754       word     -743, -731, -719, -707, -694, -681, -669, -656       word     -642, -629, -615, -601, -587, -573, -559, -544       word     -529, -515, -500, -484, -469, -453, -438, -422       word     -406, -390, -374, -358, -342, -325, -309, -292       word     -275, -258, -241, -224, -207, -190, -173, -156       word     -139, -121, -104,  -87,  -69,  -52,  -34,  -17 ```    Obviously, it’s much easier to write the C program that generated this data than to enter (and verify) this data by hand. Of course, you don’t even have to write the table-generation program in C (or Pascal/Delphi, Java, C#, Swift, or another high-level language). Because the program will execute only once, the performance of the table-generation program is not an issue.    Once you run your table-generation program, all that remains to be done is to cut and paste the table from the file (*sines.asm* in this example) into the program that will actually use the table.    ### 10.1.3 Table-Lookup Performance    In the early days of PCs, table lookups were a preferred way to do high-performance computations. Today, it is not uncommon for a CPU to be 10 to 100 times faster than main memory. As a result, using a table lookup may not be faster than doing the same calculation with machine instructions. However, the on-chip CPU cache memory subsystems operate at near CPU speeds. Therefore, table lookups can be cost-effective if your table resides in cache memory on the CPU. This means that the way to get good performance using table lookups is to use small tables (because there’s only so much room on the cache) and use tables whose entries you reference frequently (so the tables stay in the cache).    See *Write Great Code*, Volume 1 (No Starch Press, 2020) or the electronic version of *The Art of Assembly Language* at [https://www.randallhyde.com/](https://www.randallhyde.com/) for details concerning the operation of cache memory and how you can optimize your use of cache memory.    ## 10.2 For More Information    Donald Knuth’s *The Art of Computer Programming*, Volume 3: *Searching and Sorting* (Addison-Wesley Professional, 1998) contains a lot of useful information about searching for data in tables. Searching for data is an alternative when a straight array access won’t work in a given situation.    ## 10.3 Test Yourself    1.  What is the domain of a function? 2.  What is the range of a function? 3.  What does the `xlat` instruction do? 4.  Which domain and range values allow you to use the `xlat` instruction? 5.  Provide the code that implements the following functions (using pseudo-C prototypes and `f` as the table name):     1.  `byte f(byte input)`     2.  `word f(byte input)`     3.  `byte f(word input)`     4.  `word f(word input)` 6.  What is domain conditioning? 7.  Why might table lookups not be effective on modern processors?````"]