<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch09">
  <div id="header0901" class="chapter">
   <h1 class="cn">
    <span class="page" id="p189">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch09">
     9
    </a>
   </h1>
   <h1 class="ctfm">
    Using the Internal EEPROM
   </h1>
  </div>
  <div class="figure" id="ct09">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   When you define and use a variable in your AVR code, the stored data only lasts until the hardware is reset or the power is turned off. But what if you need to keep some values for future use? That’s where we turn to the microcontroller’s
   <i class="calibre5">
    electrically erasable programmable read-only memory (EEPROM)
   </i>
   , a special type of memory that holds information even when power is disconnected.
  </p>
  <p class="calibre8">
   In this chapter, you will:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Learn how to store byte, word, and floating-point variables in the microcontroller’s EEPROM, and retrieve them.
   </li>
   <li class="bl">
    • Build an ATtiny85 EEPROM storage and retrieval unit and a simple EEPROM datalogger with an ATmega328P-PU.
   </li>
   <li class="bl">
    • Create a program to log temperatures to the ATmega328P-PU EEPROM for later retrieval.
   </li>
  </ul>
  <div class="chapter">
   <h2 class="ah" id="ah1101">
    <span class="page" id="p190">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1101">
     Storing Bytes in EEPROM
    </a>
   </h2>
   <p class="paft">
    An EEPROM is a microcontroller component that doesn’t need electricity to retain the contents of its memory. The concept originates from read-only memory (ROM) ICs, such as those found in gaming console cartridges, where the game code stays in the IC even when it’s not connected to the console. Taking this concept further, an EEPROM lets the host controller write over old information with new information, which the EEPROM can still remember when the power is disconnected—that’s what “electrically erasable” signifies.
   </p>
   <p class="calibre8">
    Different AVR microcontrollers have EEPROMs of various sizes. For example, our ATtiny85 can store 512 bytes of data, while the ATmega328P-PU can store 1,024 bytes. In this chapter I’ll show you how to store and retrieve data in both microcontrollers’ EEPROMs so you can do so for your own projects. There are several different methods of storing data in the EEPROM, depending on the type of data. We’ll begin by discussing how to store bytes.
   </p>
   <p class="calibre8">
    Before we go any further, however, there are two things you’ll need to keep in mind. First, the EEPROM has a lifespan of around 100,000 read/write cycles. Tests have shown that they may last longer, but be aware of the approximate lifespan when building your own projects. Second, remember that when you upload new code to your AVR, the data in the EEPROM is erased.
   </p>
   <p class="calibre8">
    To use the EEPROM in our code for either microcontroller, we first include the EEPROM library:
   </p>
   <pre>
    <p class="cls">
     #include &lt;avr/eeprom.h&gt;
    </p>
   </pre>
   <p class="calibre8">
    Then, to write a byte of data (for example, a number between 0 and 255), we use the following function:
   </p>
   <pre>
    <p class="cls">
     eeprom_write_byte((uint8_t*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="pcon">
    where
    <code class="i1">
     a
    </code>
    is the location inside the EEPROM—between 0 and 511 for the ATtiny85, and between 0 and 1023 for the ATmega328P-PU—and
    <code class="i1">
     b
    </code>
    is the byte of data to store, between 0 and 255. We prefix the location variable
    <code class="i1">
     a
    </code>
    with
    <code class="calibre23">
     (uint8_t*)
    </code>
    as the EEPROM functions require the parameter to be an 8-bit integer.
   </p>
   <p class="calibre8">
    You can also
    <i class="calibre5">
     update
    </i>
    an EEPROM location to change the value stored in it, as follows:
   </p>
   <pre>
    <p class="cls">
     eeprom_update_byte((uint8_t*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="pcon">
    where again
    <code class="i1">
     a
    </code>
    is the location inside the EEPROM—between 0 and 511 for the ATtiny85, and between 0 and 1023 for the ATmega328P-PU—and
    <code class="i1">
     b
    </code>
    is the byte of data to store, between 0 and 255. Before writing a byte of data to a location, an update command first checks the value currently at that
    <span id="p191">
    </span>
    location. If the value to be written is the same as the current value, no write occurs. Though this check adds processing time, it saves unnecessarily writing to the EEPROM, thus extending its lifespan.
   </p>
   <p class="calibre8">
    To retrieve the byte of data stored in a location, use the following:
   </p>
   <pre>
    <p class="cls">
     uint8_t
     <code class="i1">
      i
     </code>
     = eeprom_read_byte((uint8_t*)
     <code class="i1">
      a
     </code>
     );
    </p>
   </pre>
   <p class="calibre8">
    This allocates the value stored in EEPROM location
    <code class="i1">
     a
    </code>
    to the variable
    <code class="i1">
     i
    </code>
    . You’ll test a few of these functions out in the
    <a class="url" href="nsp-boxall502581-0019.xhtml#pro38">
     next project
    </a>
    .
   </p>
   <p class="hd" id="pro38">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro38">
     <span class="ccust1">
      Project 38: Experimenting with the ATtiny85’s EEPROM
     </span>
    </a>
   </p>
   <p class="paft">
    This project will demonstrate writing and retrieving bytes of data from the ATtiny85’s EEPROM. It uses four LEDs as a quick way to display the numbers 0 to 15 in binary form, with diode D1 being the least significant bit (for 0) and diode D4 being the most significant bit (for 15).
   </p>
   <p class="calibre8">
    You will need the following hardware:
   </p>
   <ul class="calibre10">
    <li class="blf">
     • USBasp programmer
    </li>
    <li class="bl">
     • Solderless breadboard
    </li>
    <li class="bl">
     • ATtiny85–20PU microcontroller
    </li>
    <li class="bl">
     • Four LEDs
    </li>
    <li class="bl">
     • Four 560
     <span lang="el" xml:lang="el">
      Ω
     </span>
     resistors
    </li>
    <li class="bll">
     • Jumper wires
    </li>
   </ul>
   <p class="calibre8">
    Assemble the circuit as shown in
    <a class="url" href="nsp-boxall502581-0019.xhtml#f09001">
     Figure 9-1
    </a>
    .
   </p>
   <div class="figure" id="f09001">
    <p class="fig">
     <img alt="Schematic diagram for Project 38" height="696" src="images/nsp-boxall502581-f09001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 9-1:
      </span>
      Schematic for
      <a class="url" href="nsp-boxall502581-0019.xhtml#pro38">
       Project 38
      </a>
     </p>
    </div>
   </div>
   <p class="calibre8">
    Open a terminal window, navigate to the
    <i class="calibre5">
     Project 38
    </i>
    subfolder of this book’s
    <i class="calibre5">
     Chapter 9
    </i>
    folder, and enter the command
    <code class="b">
     make flash
    </code>
    . After a moment, the LEDs should display the numbers 0 to 15 in binary and then repeat.
   </p>
   <p class="calibre8">
    To see how this works, take a look at the
    <i class="calibre5">
     main.c
    </i>
    file for
    <a class="url" href="nsp-boxall502581-0019.xhtml#pro38">
     Project 38
    </a>
    .
   </p>
   <pre>
    <p class="clf">
     <span id="p192">
     </span>
     // Project 38 - Experimenting with the ATtiny85's EEPROM
    </p>
    <p class="clf">
     #include &lt;avr/io.h&gt;
    </p>
    <p class="cl">
     #include &lt;util/delay.h&gt;
    </p>
    <p class="cl2">
     <!--<ccust1>1</ccust1>-->
     ❶ #include &lt;avr/eeprom.h&gt;
    </p>
    <p class="clf">
     int main(void)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     DDRB = 0b00001111; // Set PORTB3–0 to output for LEDs
    </p>
    <p class="cl">
     int a;
    </p>
    <p class="cl">
     while (1)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Write 0–15 to locations 0-15
    </p>
    <p class="cl">
     for (a=0; a&lt;16; a++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>2</ccust1>-->
     ❷ eeprom_update_byte((uint8_t*)a, a);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     // Read locations 0-15, display data on LEDs
    </p>
    <p class="cl">
     for (a=0; a&lt;16; a++)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     <!--<ccust1>3</ccust1>-->
     ❸ PORTB = eeprom_read_byte((uint8_t*)a);
    </p>
    <p class="cl">
     _delay_ms(250);
    </p>
    <p class="cl">
     }
    </p>
    <p class="cl">
     // Turn off LEDs
    </p>
    <p class="cl">
     PORTB = 0b00000000;
    </p>
    <p class="cl">
     }
    </p>
    <p class="cll">
     }
    </p>
   </pre>
   <p class="calibre8">
    As mentioned earlier, we need to include the EEPROM library
    <!--<ccust1>1</ccust1>-->
    ❶ to take advantage of the functions to update and read bytes in the EEPROM. The first
    <code class="calibre23">
     for
    </code>
    loop repeats 16 times, updating the values in EEPROM locations 0 . . . 15 to 0 . . . 15
    <!--<ccust1>2</ccust1>-->
    ❷. The second loop retrieves the data from EEPROM locations 0 . . . 15 and sets the PORTB register to the number retrieved from the EEPROM
    <!--<ccust1>3</ccust1>-->
    ❸. This activates the LEDs connected to the matching pins of PORTB, thus displaying each value in binary.
   </p>
   <p class="calibre8">
    Now that you know how to store small numbers in the microcontroller’s EEPROM, I’ll show you how to store larger numbers using words of data.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1102">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1102">
     Storing Words
    </a>
   </h2>
   <p class="paft">
    A
    <i class="calibre5">
     word
    </i>
    of data uses 16 bits, or 2 bytes, to represent 16-bit signed or unsigned integers. As you learned in
    <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
     Chapter 2
    </a>
    , these can be in the range of −32,768 to 32,767 for signed integers or 0 to 65,535 for unsigned integers. For example, a word could represent 12,345 or −23,567. To write words, we again use functions from the EEPROM library, which we include as follows:
   </p>
   <pre>
    <p class="cls">
     #include &lt;avr/eeprom.h&gt;
    </p>
   </pre>
   <p class="calibre8">
    To write a word of data, we use the following function:
   </p>
   <pre>
    <p class="cls">
     <span id="p193">
     </span>
     eeprom_write_word((uint16_t*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="pcon">
    where
    <code class="i1">
     a
    </code>
    is the location inside the EEPROM and
    <code class="i1">
     b
    </code>
    is the word of data to store. While a word of data is 2 bytes in size, an EEPROM location is 1 byte in size. This means that when you write a word of data it will fill two EEPROM locations. Consequently, if you want to write two words of data at the start of the EEPROM, you’ll need to write the first word to location 0 and the second word to location 2.
   </p>
   <p class="calibre8">
    As with bytes, you can also update words. You do this with the following function:
   </p>
   <pre>
    <p class="cls">
     eeprom_update_word((uint16_t*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="calibre8">
    To retrieve the word of data stored in a location, use one of the following:
   </p>
   <pre>
    <p class="clf">
     uint16_t
     <code class="i1">
      i
     </code>
     = eeprom_read_word((uint16_t*)
     <code class="i1">
      a
     </code>
     );
    </p>
    <p class="cl">
     // For values between 0 and 65535
    </p>
    <p class="clf">
     int16_t
     <code class="i1">
      i
     </code>
     = eeprom_read_word((int16_t*)
     <code class="i1">
      a
     </code>
     );
    </p>
    <p class="cll">
     // For values between -32768 and 32767
    </p>
   </pre>
   <p class="calibre8">
    This allocates the value stored in EEPROM location
    <code class="i1">
     a
    </code>
    to the variable
    <code class="i1">
     i
    </code>
    . Note that
    <code class="i1">
     a
    </code>
    should be the first of the two locations where the word is stored, not the second (so, 0 or 2 in our previous example). You’ll test these functions out in the
    <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
     next project
    </a>
    .
   </p>
   <p class="hd" id="pro39">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro39">
     <span class="ccust1">
      Project 39: A Simple EEPROM Datalogger
     </span>
    </a>
   </p>
   <p class="paft">
    In this project, you’ll create a basic data-logging device. It not only demonstrates writing words of data to and reading them from the ATmega328P-PU’s EEPROM but also incorporates the USART and custom functions. Instead of writing arbitrary numbers to the EEPROM, this project repeatedly reads the status of digital input pin PORTB0, writing a 0 or 1 to the specified EEPROM location (for low or high, respectively). We’ll use the USART to create a basic text-based interface control system to log, retrieve, and erase EEPROM data.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1101">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1101">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • USB-to-serial converter
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     <span id="p194">
     </span>
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0019.xhtml#f09002">
      Figure 9-2
     </a>
     .
    </p>
    <div class="figure" id="f09002">
     <p class="fig">
      <img alt="Schematic diagram for Project 39" height="1200" src="images/nsp-boxall502581-f09002.jpg" width="1110" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 9-2:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
        Project 39
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Don’t forget to connect the USB-to-serial converter as demonstrated in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     . The positive and negative points shown in the schematic are used to log the low and high signals. To experiment, you could run tests connecting only the positive to 5 V or GND (the negative must always go to GND).
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1102">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1102">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 39
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 9
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Then open the terminal software you installed in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     . After a moment you will be prompted to “Enter 1 to start, 2 to dump, 3 to erase.” Press
     <b class="calibre4">
      1
     </b>
     on your computer’s keyboard to run the data-logging function,
     <b class="calibre4">
      2
     </b>
     for the microcontroller to read the EEPROM and send the data back to the terminal window, or
     <b class="calibre4">
      3
     </b>
     to erase the data by writing all the EEPROM locations back to 0.
    </p>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0019.xhtml#f09003">
      Figure 9-3
     </a>
     shows an example of this sequence. (In the interest of saving space, I’ve altered the code that produced this figure to use only the first 10 EEPROM locations. When you run the code, your sequences will be much longer.)
    </p>
    <div class="figure" id="f09003">
     <p class="fig">
      <span id="p195">
      </span>
      <img alt="A screenshot of the terminal software showing Project 39 in operation (capture and playback of logged data)" height="1200" src="images/nsp-boxall502581-f09003.jpg" width="1050" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 9-3:
       </span>
       Example output for
       <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
        Project 39
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Let’s see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 39 - A Simple EEPROM Datalogger
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/eeprom.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdio.h&gt;
     </p>
     <p class="cl">
      #include &lt;stlib.h&gt;
     </p>
     <p class="clf">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ #define logDelay 1000
     </p>
     <p class="clf">
      char newline[4] = "\r\n";
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      <span id="p196">
      </span>
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="cl">
      // Set data type to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="cl">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void USARTSendByte(unsigned char u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ uint8_t USARTReceiveByte()
     </p>
     <p class="cl">
      // Receives a byte of data from the computer into the USART register
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait for byte from computer
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;RXC0))){};
     </p>
     <p class="cl">
      // Return byte
     </p>
     <p class="cl">
      return UDR0;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>5</ccust1>-->
      ❺ void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>6</ccust1>-->
      ❻ void logData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint16_t portData = 0;
     </p>
     <p class="cl">
      uint16_t location = 0;
     </p>
     <p class="cl">
      char z1[] =  "Logging data . . .";
     </p>
     <p class="cl">
      sendString(z1);
     </p>
     <p class="cl">
      for (location=0; location&lt;1024; location++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (PINB == 0b0000001) // If PORTB0 is HIGH
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      eeprom_update_word((uint16_t*)location, 1);
     </p>
     <p class="cl">
      } else
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      eeprom_update_word((uint16_t*)location, 0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      location++;            // Skip an EEPROM location as we're using words
     </p>
     <p class="cl">
      USARTSendByte(‘.’);
     </p>
     <p class="cl">
      _delay_ms(logDelay);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <span id="p197">
      </span>
      <!--<ccust1>7</ccust1>-->
      ❼ void dumpData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t portData = 0;
     </p>
     <p class="cl">
      uint16_t location = 0;
     </p>
     <p class="cl">
      char t[10] = "";         // For our dtostrf
     </p>
     <p class="cl">
      char z1[] = "Dumping data . . .";
     </p>
     <p class="cl">
      sendString(z1);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      for (location=0; location&lt;1024; location++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Retrieve data from EEPROM location
     </p>
     <p class="cl">
      portData=eeprom_read_word((uint16_t*)location);
     </p>
     <p class="cl">
      dtostrf((float)portData,12,0,t);
     </p>
     <p class="cl">
      sendString(t);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      location++;        // Skip an EEPROM location as we're using words
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>8</ccust1>-->
      ❽ void eraseData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint16_t location = 0;
     </p>
     <p class="cl">
      char msg2[] = "Erasing data . . .";
     </p>
     <p class="cl">
      char msg3[] = " finished.";
     </p>
     <p class="cl">
      sendString(msg2);
     </p>
     <p class="cl">
      for (location=0; location&lt;1024; location++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      eeprom_write_byte((uint16_t*)location, 0); // Write 0 to EEPROM location
     </p>
     <p class="cl">
      USARTSendByte(‘*’);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(msg3);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;        // Set PORTB0 as input
     </p>
     <p class="cl">
      char msg1[44] = "Enter 1 to start, 2 to dump, 3 to erase: ";
     </p>
     <p class="cl">
      uint8_t option;
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ sendString(msg1);
     </p>
     <p class="cl">
      option = USARTReceiveByte();
     </p>
     <p class="cl">
      USARTSendByte(option);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      switch (option)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 49 : logData(); break;
     </p>
     <p class="cl">
      case 50 : dumpData(); break;
     </p>
     <p class="cl">
      case 51 : eraseData(); break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p198">
     </span>
     First we import all the required libraries and set the data speed for the USART, as usual. We also set
     <code class="calibre23">
      logDelay
     </code>
     to 1,000
     <!--<ccust1>1</ccust1>-->
     ❶, specifying the delay in milliseconds between each logging event (you can change this value to suit your own needs).
    </p>
    <p class="calibre8">
     Next, we declare the functions required to initialize the USART
     <!--<ccust1>2</ccust1>-->
     ❷, send bytes from the USART to the computer
     <!--<ccust1>3</ccust1>-->
     ❸ and receive bytes coming in the other direction
     <!--<ccust1>4</ccust1>-->
     ❹, and send strings to the terminal emulator
     <!--<ccust1>5</ccust1>-->
     ❺. When needed, the user can call the data-logging function
     <code class="calibre23">
      logData()
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻. This function reads the value of PORTB0 and writes a 1 for high or 0 for low to the EEPROM locations from 0 to 1,022 in turn. The function skips writing to every second location, as we need two locations per byte. If you want to increase the time between logging events, you can adjust the speed, as mentioned earlier, by altering the value of
     <code class="calibre23">
      logDelay
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶.
    </p>
    <p class="calibre8">
     The function
     <code class="calibre23">
      dumpData()
     </code>
     <!--<ccust1>7</ccust1>-->
     ❼ sends the value of each EEPROM location to the USART and thus the PC for viewing. As with the
     <code class="calibre23">
      logData()
     </code>
     function, it skips every second location, since we use two locations per word. Before running this function, you can set the terminal software to capture output for further analysis with a spreadsheet, as demonstrated in
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
      Project 19
     </a>
     in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     .
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      eraseData()
     </code>
     function
     <!--<ccust1>8</ccust1>-->
     ❽ writes a 0 in every EEPROM location, thus writing over any previously stored data. While not really necessary here, this function might be useful in your own future projects that require erasing data in the EEPROM.
    </p>
    <p class="calibre8">
     The main code loop provides a user interface of sorts, by prompting the user for their selection
     <!--<ccust1>9</ccust1>-->
     ❾ and then calling the required function using the
     <code class="calibre23">
      switch...case
     </code>
     statement, following the displayed menu options.
    </p>
    <p class="calibre8">
     Now that you can store and retrieve bytes and words of data in the EEPROM, we’ll move on to our final type of data: floating-point variables.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1103">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1103">
     Storing Floating-Point Variables
    </a>
   </h2>
   <p class="paft">
    A
    <i class="calibre5">
     floating-point variable
    </i>
    represents a floating-point number (as described in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    ) that falls in the range of −3.39 × 10
    <sup class="calibre6">
     38
    </sup>
    to 3.39 × 10
    <sup class="calibre6">
     38
    </sup>
    . These variables require 32 bits of storage, or 4 bytes. To write a floating-point (float) variable, we again need to include the EEPROM library:
   </p>
   <pre>
    <p class="cls">
     #include &lt;avr/eeprom.h&gt;
    </p>
   </pre>
   <p class="calibre8">
    We then use the following function to write a word of data (for example, a number between 0 and 65,535):
   </p>
   <pre>
    <p class="cls">
     eeprom_write_float((float*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="pcon">
    where
    <code class="i1">
     a
    </code>
    is the location inside the EEPROM and
    <code class="i1">
     b
    </code>
    is the float of data to store.
   </p>
   <p class="calibre8">
    <span id="p199">
    </span>
    To update a float stored in the EEPROM, we use this function:
   </p>
   <pre>
    <p class="cls">
     eeprom_update_float((float*)
     <code class="i1">
      a, b
     </code>
     );
    </p>
   </pre>
   <p class="calibre8">
    As a float takes up 4 bytes and an EEPROM location can contain only 1 byte, you’ll need to allocate four EEPROM locations when storing a float. For example, if you were writing two floats of data at the start of the EEPROM, you’d write the first one to location 0 and the second to location 4.
   </p>
   <p class="calibre8">
    To retrieve a float stored in a given location, use the following function:
   </p>
   <pre>
    <p class="cls">
     float
     <code class="i1">
      i
     </code>
     = eeprom_read_float((float*)
     <code class="i1">
      a
     </code>
     );
    </p>
   </pre>
   <p class="calibre8">
    This allocates the value stored in EEPROM location
    <code class="i1">
     a
    </code>
    to the variable
    <code class="i1">
     i
    </code>
    . Remember that you always need to use the first location when using words. In the
    <a class="url" href="nsp-boxall502581-0019.xhtml#pro40">
     next project
    </a>
    , you’ll put the ability to store floats in EEPROM to use.
   </p>
   <p class="hd" id="pro40">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro40">
     <span class="ccust1">
      Project 40: Temperature Logger with EEPROM
     </span>
    </a>
   </p>
   <p class="paft">
    This project combines your knowledge of capturing data with a TMP36 temperature sensor (introduced in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    ) and writing floating-point variable data to and reading it from the EEPROM, again using the USART and custom functions. The project code samples and stores the temperature in the EEPROM 256 times, so you can retrieve and view the readings with your terminal software or capture the data for spreadsheet analysis.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1103">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1103">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bll">
      • USB-to-serial converter
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0019.xhtml#f09004">
      Figure 9-4
     </a>
     , using the external power supply and wiring up the USB-to-serial converter.
    </p>
    <div class="figure" id="f09004">
     <p class="fig">
      <span id="p200">
      </span>
      <img alt="Schematic diagram for Project 40" height="1105" src="images/nsp-boxall502581-f09004.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 9-4:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0019.xhtml#pro40">
        Project 40
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 40
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 9
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Next, open the terminal application, just as you did for the
     <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
      previous project
     </a>
     . After a moment you should be presented with the option to enter 1 to start, 2 to dump, or 3 to erase. Pressing 1 on your computer’s keyboard should run the temperature data logging function; pressing 2 tells the microcontroller to read the EEPROM and send the temperature data back to the terminal software for display, and pressing 3 should erase the data by writing all the EEPROM locations back to 0.
    </p>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0019.xhtml#f09005">
      Figure 9-5
     </a>
     shows an example of this sequence. (Again, to save space, I’ve altered the code to use only the first six EEPROM locations.)
    </p>
    <div class="figure" id="f09005">
     <p class="fig">
      <span id="p201">
      </span>
      <img alt="A screenshot of the terminal software showing Project 40 in operation (capture and playback of logged temperatures)" height="952" src="images/nsp-boxall502581-f09005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 9-5:
       </span>
       Example output for
       <a class="url" href="nsp-boxall502581-0019.xhtml#pro40">
        Project 40
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Let’s look at the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 40 - Temperature Logger with EEPROM
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/eeprom.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdio.h&gt;
     </p>
     <p class="clf">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="cl2">
      <!--<ccust1>1</ccust1>-->
      ❶ #define logDelay 1000
     </p>
     <p class="clf">
      char newline[4] = "\r\n";
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void startADC()
     </p>
     <p class="cl">
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);                 // Use AVcc pin with ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);    // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); // Prescaler for 1MHz (/8)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);                 // Enable ADC
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="cl">
      <span id="p202">
      </span>
      // Set data type to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="cl">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(unsigned char u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t USARTReceiveByte()
     </p>
     <p class="cl">
      // Receives a byte of data from the computer into the USART register
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait for byte from computer
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;RXC0))){};
     </p>
     <p class="cl">
      // Return byte
     </p>
     <p class="cl">
      return UDR0;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ float readTemperature()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      float temperature;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      uint8_t ADCvalue;
     </p>
     <p class="cl">
      // Get reading from TMP36 via ADC
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADSC);         // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) ); // Wait until conversion is complete
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="clf">
      // Get value from ADC register, place in ADCvalue
     </p>
     <p class="cl">
      ADCvalue = ADC;
     </p>
     <p class="clf">
      // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      voltage = (ADCvalue * 5);
     </p>
     <p class="cl">
      voltage = voltage / 1024;
     </p>
     <p class="cl">
      temperature = ((voltage - 0.5) * 100);
     </p>
     <p class="cl">
      return temperature;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>5</ccust1>-->
      ❺ void logData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p203">
      </span>
      float portData = 0;
     </p>
     <p class="cl">
      uint16_t location = 0;
     </p>
     <p class="cl">
      char z1[] =  "Logging data . . .";
     </p>
     <p class="cl">
      sendString(z1);
     </p>
     <p class="cl">
      for (location=0; location&lt;1021; location=location+4)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      portData=readTemperature();
     </p>
     <p class="cl">
      eeprom_update_float((float*)location,portData);
     </p>
     <p class="cl">
      USARTSendByte(‘.’);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(logDelay);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>6</ccust1>-->
      ❻ void dumpData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      float portData = 0;
     </p>
     <p class="cl">
      uint16_t location = 0;
     </p>
     <p class="cl">
      char t[10] = "";                 // For our dtostrf
     </p>
     <p class="cl">
      char msg1[14] = "Temperature: "; // Make sure you have " instead of "
     </p>
     <p class="cl">
      char msg2[12] = " degrees C ";
     </p>
     <p class="cl">
      char msg3[] = "Dumping data . . .";
     </p>
     <p class="cl">
      char msg4[] = ". . . finished.";
     </p>
     <p class="cl">
      sendString(msg3);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      for (location=0; location&lt;1021; location=location+4)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      sendString(msg1);
     </p>
     <p class="cl">
      portData=eeprom_read_float((float*)location); // HERE
     </p>
     <p class="cl">
      dtostrf(portData,8,4,t);
     </p>
     <p class="cl">
      sendString(t);
     </p>
     <p class="cl">
      sendString(msg2);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(msg4);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>7</ccust1>-->
      ❼ void eraseData()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      int16_t location = 0;
     </p>
     <p class="cl">
      char msg1[] = "Erasing data . . .";
     </p>
     <p class="cl">
      char msg2[] = " finished.";
     </p>
     <p class="cl">
      sendString(msg1);
     </p>
     <p class="cl">
      for (location=0; location&lt;1024; location++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      eeprom_write_byte((uint8_t*)location, 0);
     </p>
     <p class="cl">
      USARTSendByte(‘*’);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      sendString(msg2);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p204">
      </span>
      <!--<ccust1>8</ccust1>-->
      ❽ char msg1[44] = "Enter 1 to start, 2 to dump, 3 to erase: ";
     </p>
     <p class="cl">
      uint8_t option;
     </p>
     <p class="cl">
      DDRD = 0b00000000;               // Set PORTD to inputs
     </p>
     <p class="cl">
      startADC();
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      sendString(msg1);
     </p>
     <p class="cl">
      option = USARTReceiveByte();
     </p>
     <p class="cl">
      USARTSendByte(option);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      switch (option)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 49 : logData(); break;
     </p>
     <p class="cl">
      case 50 : dumpData(); break;
     </p>
     <p class="cl">
      case 51 : eraseData(); break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This project again pulls together knowledge from previous chapters to bring a new idea to life. First we import all the required libraries and set the data speed for the USART, as usual. I’ve again set the delay in milliseconds between each logging event to 1,000, but you can adjust the speed by altering the
     <code class="calibre23">
      logDelay
     </code>
     value
     <!--<ccust1>1</ccust1>-->
     ❶. Next, we provide the functions required to initialize and operate the ADC
     <!--<ccust1>2</ccust1>-->
     ❷ and the USART
     <!--<ccust1>3</ccust1>-->
     ❸, as in the
     <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
      previous project
     </a>
     .
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      readTemperature()
     </code>
     function
     <!--<ccust1>4</ccust1>-->
     ❹ takes the temperature readings from the TMP36; we’ll call this from the
     <code class="calibre23">
      logData()
     </code>
     function
     <!--<ccust1>5</ccust1>-->
     ❺, which stores these readings in the EEPROM locations from 0 to 1020 in turn, skipping three each time as we need four locations per float variable.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      dumpData()
     </code>
     function
     <!--<ccust1>6</ccust1>-->
     ❻ sends the value of each EEPROM location to the USART and thus to the PC for viewing. Like
     <code class="calibre23">
      logData()
     </code>
     , this function skips to every fourth EEPROM location so that we have space to store our float variables. Before running this function, you can set the terminal software to capture the output in a text file, which you can open in a spreadsheet; see
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
      Project 19
     </a>
     in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     if you need a refresher on this.
    </p>
    <p class="calibre8">
     The
     <code class="calibre23">
      eraseData()
     </code>
     function
     <!--<ccust1>7</ccust1>-->
     ❼ writes a 0 in every EEPROM location, thus erasing any previously stored data. As mentioned in
     <a class="url" href="nsp-boxall502581-0019.xhtml#pro39">
      Project 39
     </a>
     , you may find it useful in your own projects.
    </p>
    <p class="calibre8">
     The main code loop provides a user interface of sorts, prompting the user to choose whether to log, dump, or erase the data
     <!--<ccust1>8</ccust1>-->
     ❽ and then calling the required function using the
     <code class="calibre23">
      switch...case
     </code>
     statement, following the displayed menu options.
    </p>
    <p class="calibre8">
     Along with learning these EEPROM functions, in this chapter you’ve taken one step further toward developing complex projects that could inspire your own projects later in your microcontroller journey. In the
     <a class="url" href="nsp-boxall502581-0020.xhtml#ch10">
      next chapter
     </a>
     , you’ll learn how to make your own libraries to save time and write more useful code.
    </p>
   </div>
  </div>
 </div>
</div></body></html>