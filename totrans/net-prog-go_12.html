<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_187" title="187"/>9</span><br/>&#13;
<span class="ChapterTitle">Building HTTP Services</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Now that you’ve written client code to send HTTP requests, let’s build a server that can process these requests and send resources to the client. The <code>net/http</code> package handles most of the implementation details for you, so you can focus on instantiating and configuring a server, creating resources, and handling each client request. </p>&#13;
<p>In Go, an HTTP server relies on several interacting components: handlers, middleware, and a multiplexer. When it includes all these parts, we call this server a <em>web service</em>. We’ll begin by looking at a simple HTTP web service and then explore each of its components over the course of the chapter. The big picture should help you understand topics that beginners often find abstract.</p>&#13;
<p>You’ll also learn more advanced uses of the <code>net/http</code> package, such as adding TLS support and pushing data to HTTP/2 clients. By the end, you should feel comfortable configuring a Go-based HTTP server, writing middleware, and responding to requests with handlers.</p>&#13;
<h2 id="h1-500884c09-0001"><span epub:type="pagebreak" id="Page_188" title="188"/>The Anatomy of a Go HTTP Server</h2>&#13;
<p class="BodyFirst"><a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a> illustrates the path a request takes in a typical <code>net/http</code>-based server.</p>&#13;
<figure>&#13;
<img alt="f09001" src="image_fi/500884c09/f09001.png"/>&#13;
<figcaption><p><a id="figure9-1">Figure 9-1</a>: Client request culminating in a server response in the handler</p></figcaption>&#13;
</figure>&#13;
<p>First, the server’s <em>multiplexer</em> (<em>router</em>, in computer-networking parlance) receives the client’s request. The multiplexer determines the destination for the request, then passes it along to the object capable of handling it. We call this object a <em>handler</em>. (The multiplexer itself is a handler that routes requests to the most appropriate handler.) Before the handler receives the request, the request may pass through one or more functions called <em>middleware</em>. Middleware changes the handlers’ behavior or performs auxiliary tasks, such as logging, authentication, or access control. </p>&#13;
<p><a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> creates an HTTP server that follows this basic structure. If you have trouble following along, don’t worry; you’ll spend the rest of the chapter learning how these parts work.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "fmt"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "net"&#13;
    "net/http"&#13;
    "testing"&#13;
    "time"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch09/handlers"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_189" title="189"/>func TestSimpleHTTPServer(t *testing.T) {&#13;
    srv := &amp;http.Server{&#13;
        Addr: "127.0.0.1:8081",&#13;
        Handler: <span class="CodeAnnotation">1</span>http.TimeoutHandler(&#13;
            handlers.DefaultHandler(), 2*time.Minute, ""),&#13;
        IdleTimeout:       5 * time.Minute,&#13;
        ReadHeaderTimeout: time.Minute,&#13;
    }&#13;
&#13;
    l, err := <span class="CodeAnnotation">2</span>net.Listen("tcp", srv.Addr)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
        err := <span class="CodeAnnotation">3</span>srv.Serve(l)&#13;
        if err != http.ErrServerClosed {&#13;
            t.Error(err)&#13;
        }&#13;
    }()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: Instantiating a multiplexer and an HTTP server (<em>server_test.go</em>)</p>&#13;
<p>Requests sent to the server’s handler first pass through middleware named <code>http.TimeoutHandler</code><span class="CodeAnnotation">1</span>, then to the handler returned by the <code>handlers.DefaultHandler</code> function. In this very simple example, you specify only a single handler for all requests instead of relying on a multiplexer. </p>&#13;
<p>The server has a few fields. The <code>Handler</code> field accepts a multiplexer or other object capable of handling client requests. The <code>Address</code> field should look familiar to you by now. In this example, you want the server to listen to port 8081 on IP address 127.0.0.1. I’ll explain the <code>IdleTimeout</code> and <code>ReadHeaderTimeout</code> fields in the next section. Suffice it to say now, you should always define these two fields. </p>&#13;
<p>Finally, you create a new <code>net.Listener</code> bound to the server’s address <span class="CodeAnnotation">2</span> and instruct the server to <code>Serve</code><span class="CodeAnnotation">3</span> requests from this listener. The <code>Serve</code> method returns <code>http.ErrServerClosed</code> when it closes normally.</p>&#13;
<p>Now let’s test this server. <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a> picks up where <a href="#listing9-1">Listing 9-1</a> leaves off. It details a few test requests and their expected results.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    testCases := []struct {&#13;
        method   string&#13;
        body     io.Reader&#13;
        code     int&#13;
        response string&#13;
    }{&#13;
      <span class="CodeAnnotation">1</span>{http.MethodGet, nil, http.StatusOK, "Hello, friend!"},&#13;
      <span class="CodeAnnotation">2</span>{http.MethodPost, bytes.NewBufferString("&lt;world&gt;"), http.StatusOK,&#13;
            "Hello, &amp;lt;world&amp;gt;!"},&#13;
      <span class="CodeAnnotation">3</span>{http.MethodHead, nil, http.StatusMethodNotAllowed, ""},&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_190" title="190"/>    client := new(http.Client)&#13;
    path := fmt.Sprintf("http://%s/", srv.Addr)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: Request test cases for the HTTP server (<em>server_test.go</em>)</p>&#13;
<p>First, you send a <code>GET</code> request <span class="CodeAnnotation">1</span>, which results in a 200 OK status code. The response body has the <code>Hello, friend!</code> string.</p>&#13;
<p>In the second test case <span class="CodeAnnotation">2</span>, you send a <code>POST</code> request with the string <code>&lt;world&gt;</code> in its body. The angle brackets are intentional, and they show an often-overlooked aspect of handling client input in the handler: always escape client input. You’ll learn about escaping client input in <span class="xref" itemid="xref_target_“Handlers” on page 193">“Handlers” on page 193</span>. This test case results in the string <code>Hello, &amp;lt;world&amp;gt;!</code> in the response body. The response looks a bit silly, but your web browser renders it as <code>Hello, &lt;world&gt;!</code>.</p>&#13;
<p>The third test case <span class="CodeAnnotation">3</span> a sends a <code>HEAD</code> request to the HTTP server. The handler returned by the <code>handlers.DefaultHandler</code> function, which you’ll explore shortly, does not handle the <code>HEAD</code> method. Therefore, it returns a 405 Method Not Allowed status code and an empty response body.</p>&#13;
<p><a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a> continues the code in <a href="#listing9-2">Listing 9-2</a> and runs through each test case.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    for i, c := range testCases {&#13;
        r, err := <span class="CodeAnnotation">1</span>http.NewRequest(c.method, path, c.body)&#13;
        if err != nil {&#13;
            t.Errorf("%d: %v", i, err)&#13;
            continue&#13;
        }&#13;
&#13;
        resp, err := <span class="CodeAnnotation">2</span>client.Do(r)&#13;
        if err != nil {&#13;
            t.Errorf("%d: %v", i, err)&#13;
            continue&#13;
        }&#13;
&#13;
        if resp.StatusCode != c.code {&#13;
            t.Errorf("%d: unexpected status code: %q", i, resp.Status)&#13;
        }&#13;
&#13;
        b, err := <span class="CodeAnnotation">3</span>ioutil.ReadAll(resp.Body)&#13;
        if err != nil {&#13;
            t.Errorf("%d: %v", i, err)&#13;
            continue&#13;
        }&#13;
        _ = <span class="CodeAnnotation">4</span>resp.Body.Close()&#13;
&#13;
        if c.response != string(b) {&#13;
            t.Errorf("%d: expected %q; actual %q", i, c.response, b)&#13;
        }&#13;
    }&#13;
&#13;
<span epub:type="pagebreak" id="Page_191" title="191"/>    if err := <span class="CodeAnnotation">5</span>srv.Close(); err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: Sending test requests to the HTTP server (<em>server_test.go</em>)</p>&#13;
<p>First, you create a new request, passing the parameters from the test case <span class="CodeAnnotation">1</span>. Next, you pass the request to the client’s <code>Do</code> method <span class="CodeAnnotation">2</span>, which returns the server’s response. You then check the status code and read in the entire response body <span class="CodeAnnotation">3</span>. You should be in the habit of consistently closing the response body if the client did not return an error <span class="CodeAnnotation">4</span>, even if the response body is empty or you ignore it entirely. Failure to do so may prevent the client from reusing the underlying TCP connection.</p>&#13;
<p>Once all tests complete, you call the server’s <code>Close</code> method <span class="CodeAnnotation">5</span>. This causes its <code>Serve</code> method in <a href="#listing9-1">Listing 9-1</a> to return, stopping the server. The <code>Close</code> method abruptly closes client connections. You’ll see an example of the HTTP server’s graceful shutdown support when we discuss HTTP/2 pushes later in this chapter.</p>&#13;
<p>Go’s HTTP server supports a few other features, which we’ll explore in the following sections. It can proactively serve, or push, resources to clients. It also offers graceful shutdown support. Abruptly shutting down your web server may leave some clients in an awkward state if they were waiting for a response when you stopped the server, because those clients will never receive a response. Graceful shutdowns allow for all pending responses to reach each client before the server is stopped.</p>&#13;
<h3 id="h2-500884c09-0001">Clients Don’t Respect Your Time</h3>&#13;
<p class="BodyFirst">Just as I recommended setting the client’s time-out values, I recommend that you manage the various server time-out values, for the simple reason that clients won’t otherwise respect your server’s time. A client can take its sweet time sending a request to your server. Meanwhile, your server uses resources waiting to receive the request in its entirety. Likewise, your server is at the client’s mercy when it sends the response because it can send data only as fast as the client reads it (or can send only as much as there is TCP buffer space available). Avoid letting the client dictate the duration of a request-response life cycle.</p>&#13;
<p><a href="#listing9-1">Listing 9-1</a> includes a server instance with two of its time-out values specified: the length of time clients can remain idle between requests and how long the server should wait to read a request header:</p>&#13;
<pre><code>srv := &amp;http.Server{&#13;
    Addr:              "127.0.0.1:8081",&#13;
    Handler:           mux,&#13;
    IdleTimeout:       5 * time.Minute,&#13;
    ReadHeaderTimeout: time.Minute,&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_192" title="192"/>Although several time-out fields on the <code>http.Server</code> are available to you, I recommend setting only the <code>IdleTimeout</code> and <code>ReadHeaderTimeout</code> fields. The <code>IdleTimeout</code> field dictates how long the server will keep its side of the TCP socket open while waiting for the next client request when the communication uses keepalives. The <code>ReadHeaderTimeout</code> value determines how long the server will wait to finish reading the request headers. Keep in mind that this duration has no bearing on the time it takes to read the request body.</p>&#13;
<p>If you want to enforce a time limit for reading an incoming request across all handlers, you could manage the request deadline by using the <code>ReadTimeout</code> field. If the client hasn’t sent the complete request (the headers and body) by the time the <code>ReadTimeout</code> duration elapses, the server ends the TCP connection. Likewise, you could give the client a finite duration in which to send the request and read the response by using the <code>WriteTimeout</code> field. The <code>ReadTimeout</code> and <code>WriteTimeout</code> values apply to all requests and responses because they dictate the <code>ReadDeadline</code> and <code>WriteDeadline</code> values of the TCP socket, as discussed in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>. </p>&#13;
<p>These blanket time-out values may be inappropriate for handlers that expect clients to send large files in a request body or handlers that indefinitely stream data to the client. In these two examples, the request or response may abruptly time out even if everything went ahead as expected. Instead, a good practice is to rely on the <code>ReadHeaderTimeout</code> value. You can separately manage the time it takes to read the request body and send the response using middleware or handlers. This gives you the greatest control over request and response durations per resource. You’ll learn how to manage the request-response duration by using middleware in <span class="xref" itemid="xref_target_“Middleware” on page 202">“Middleware” on page 202</span>.</p>&#13;
<h3 id="h2-500884c09-0002">Adding TLS Support</h3>&#13;
<p class="BodyFirst">HTTP traffic is plaintext by default, but web clients and servers can use HTTP over an encrypted TLS connection, a combination known as <em>HTTPS</em>. Go’s HTTP server enables HTTP/2 support over TLS connections only, but enabling TLS is a simple matter. You need to modify only two lines from <a href="#listing9-1">Listing 9-1</a>’s server implementation: the port number and the <code>Serve</code> method:</p>&#13;
<pre><code>    srv := &amp;http.Server{&#13;
        Addr:            <span class="CodeAnnotation">1</span>"127.0.0.1:8443",&#13;
        Handler:           mux,&#13;
        IdleTimeout:       5 * time.Minute,&#13;
        ReadHeaderTimeout: time.Minute,&#13;
    }&#13;
&#13;
    l, err := net.Listen("tcp", srv.Addr)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
     <span class="CodeAnnotation">2</span> err := srv.ServeTLS(l, "cert.pem", "key.pem")&#13;
        if err != http.ErrServerClosed {&#13;
<span epub:type="pagebreak" id="Page_193" title="193"/>            t.Error(err)&#13;
        }&#13;
    }()</code></pre>&#13;
<p>Technically, you don’t need to change the port number <span class="CodeAnnotation">1</span>, but the convention is to serve HTTPS over port 443, or an augmentation of port 443, like 8443. Using the server’s <code>ServeTLS</code> method, you instruct the server to use TLS over HTTP <span class="CodeAnnotation">2</span>. The <code>ServeTLS</code> method requires the path to both a certificate and a corresponding private key. I recommend you check out the mkcert project at <a class="LinkURL" href="https://github.com/FiloSottile/mkcert/">https://github.com/FiloSottile/mkcert/</a> to get a key pair. You can use mkcert to create locally trusted key pairs for development purposes only. For production use, you should consider using and supporting Let’s Encrypt at <a class="LinkURL" href="https://letsencrypt.org/">https://letsencrypt.org/</a>.</p>&#13;
<h2 id="h1-500884c09-0002">Handlers</h2>&#13;
<p class="BodyFirst">When a client sends a request to an HTTP server, the server needs to figure out what to do with it. The server may need to retrieve various resources or perform an action, depending on what the client requests. A common design pattern is to specify bits of code to handle these requests, known as <em>handlers</em>. You may have a handler that knows how to retrieve an image and another handler that knows how to retrieve information from a database. We’ll discuss how the server figures out which handler is most apt for each request in <span class="xref" itemid="xref_target_“Multiplexers” on page 207">“Multiplexers” on page 207</span>.</p>&#13;
<p>In Go, handlers are objects that implement the <code>http.Handler</code> interface. They read client requests and write responses. The <code>http.Handler</code> interface consists of a single method to receive both the response and the request:</p>&#13;
<pre><code>type Handler interface {&#13;
    ServeHTTP(http.ResponseWriter, *http.Request)&#13;
}</code></pre>&#13;
<p>Any object that implements the <code>http.Handler</code> interface may handle client requests, as far as the Go HTTP server is concerned. We often define handlers as functions, as in this common pattern:</p>&#13;
<pre><code>handler := http.HandlerFunc(&#13;
    func(w http.ResponseWriter, r *http.Request) {&#13;
        _, _ = w.Write([]byte("Hello, world!"))&#13;
    },&#13;
)</code></pre>&#13;
<p>Here, you wrap a function that accepts an <code>http.ResponseWriter</code> and an <code>http.Request</code> pointer in the <code>http.HandlerFunc</code> type, which implements the <code>Handler</code> interface. This results in an <code>http.HandlerFunc</code> object that calls the wrapped <code>func(w http.ResponseWriter, r *http.Request)</code> function when the server calls its <code>ServeHTTP</code> method. This handler responds to the client with the string <code>Hello, world!</code> in the response body.</p>&#13;
<p>Notice that you ignore the number of written bytes and any potential write error. In the wild, writes to a client can fail for any number of reasons. <span epub:type="pagebreak" id="Page_194" title="194"/>It isn’t worth logging these errors. Instead, one option is to keep track of the write error frequency and have your server send you an alert should the number of errors exceed an appropriate threshold. You’ll learn about instrumenting your code in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>&#13;
<p>Now that you’re familiar with the structure of a handler, let’s have a look at the handler returned by the <code>handlers.DefaultHandler</code> function in <a href="#listing9-4" id="listinganchor9-4">Listing 9-4</a>.</p>&#13;
<pre><code>package handlers&#13;
&#13;
import (&#13;
    "html/template"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "net/http"&#13;
)&#13;
&#13;
var t = <span class="CodeAnnotation">1</span>template.Must(template.New("hello").Parse("Hello, {{.}}!"))&#13;
&#13;
func DefaultHandler() http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
         <span class="CodeAnnotation">2</span> defer func(r io.ReadCloser) {&#13;
                _, _ = io.Copy(ioutil.Discard, r)&#13;
                _ = r.Close()&#13;
            }(r.Body)&#13;
&#13;
            var b []byte&#13;
&#13;
         <span class="CodeAnnotation">3</span> switch r.Method {&#13;
            case http.MethodGet:&#13;
                b = []byte("friend")&#13;
            case http.MethodPost:&#13;
                var err error&#13;
                b, err = ioutil.ReadAll(r.Body)&#13;
                if err != nil {&#13;
             <span class="CodeAnnotation">4</span> http.Error(w, "Internal server error",&#13;
                    http.StatusInternalServerError)&#13;
                return&#13;
                }&#13;
            default:&#13;
                // not RFC-compliant due to lack of "Allow" header&#13;
             <span class="CodeAnnotation">5</span> http.Error(w, "Method not allowed", &#13;
                    http.StatusMethodNotAllowed)&#13;
                return&#13;
            }&#13;
&#13;
            _ = <span class="CodeAnnotation">6</span>t.Execute(w, string(b))&#13;
        },&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: The default handler implementation (<em>handlers/default.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_195" title="195"/>The <code>handlers.DefaultHandler</code> function returns a function converted to the <code>http.HandlerFunc</code> type. The <code>http.HandlerFunc</code> type implements the <code>http.Handler</code> interface. Go programmers commonly convert a function with the signature <code>func(w http.ResponseWriter, r *http.Request)</code> to the <code>http.HandlerFunc</code> type so the function implements the <code>http.Handler</code> interface.</p>&#13;
<p>The first bit of code you see is a deferred function that drains and closes the request body <span class="CodeAnnotation">2</span>. Just as it’s important for the client to drain and close the response body to reuse the TCP session, it’s important for the server to do the same with the request body. But unlike the Go HTTP client, closing the request body does not implicitly drain it. Granted, the <code>http.Server</code> will close the request body for you, but it won’t drain it. To make sure you can reuse the TCP session, I recommend you drain the request body at a minimum. Closing it is optional.</p>&#13;
<p>The handler responds differently depending on the request method <span class="CodeAnnotation">3</span>. If the client sent a <code>GET</code> request, the handler writes <code>Hello, friend!</code> to the response writer. If the request method is a <code>POST</code>, the handler first reads the entire request body. If an error occurs while reading the request body, the handler uses the <code>http.Error</code> function <span class="CodeAnnotation">4</span> to succinctly write the message <code>Internal server error</code> to the response body and set the response status code to 500. Otherwise, the handler returns a greeting using the request body contents. If the handler receives any other request method, it responds with a 405 Method Not Allowed status <span class="CodeAnnotation">5</span>. The 405 response is technically not RFC-compliant without an Allow header showing which methods the handler accepts. We’ll shore up this deficiency in <span class="xref" itemid="xref_target_“Any Type Can Be a Handler” on page 198">“Any Type Can Be a Handler” on page 198</span>. Finally, the handler writes the response body.</p>&#13;
<p>This code could have a security vulnerability since part of the response body might come from the request body. A malicious client can send a request payload that includes JavaScript, which could run on a client’s computer. This behavior can lead to an XSS attack. To prevent these attacks, you must properly escape all client-supplied content before sending it in a response. Here, you use the <code>html/template</code> package to create a simple template <span class="CodeAnnotation">1</span> that reads <code>Hello, {{.}}!</code>, where <code>{{.}}</code> is a placeholder for part of your response. Templates derived from the <code>html/template</code> package automatically escape HTML characters when you populate them and write the results to the response writer <span class="CodeAnnotation">6</span>. HTML-escaping explains the funky characters in <a href="#listing9-2">Listing 9-2</a>’s second test case. The client’s browser will properly display the characters instead of interpreting them as part of the HTML and JavaScript in the response body. The bottom line is to always use the <code>html/template</code> package when writing untrusted data to a response writer.</p>&#13;
<h3 id="h2-500884c09-0003">Test Your Handlers with httptest</h3>&#13;
<p class="BodyFirst">Saying “make sure you test your code” is the developer’s equivalent of my mother telling me to clean my bedroom. It’s good advice, but I’d much rather continue hacking away than write test code. But my mother was correct, and writing test code now will serve me well in the future. The Go standard library architects—motivated by clean bedrooms, no doubt—made sure to give us the <code>net/http/httptest</code> package. This package makes unit-testing handlers painless.</p>&#13;
<p><span epub:type="pagebreak" id="Page_196" title="196"/>The <code>net/http/httptest</code> package exports a <code>NewRequest</code> function that accepts an HTTP method, a target resource, and a request body <code>io.Reader</code>. It returns a pointer to an <code>http.Request</code> ready for use in an <code>http.Handler</code>:</p>&#13;
<pre><code>func NewRequest(method, target string, body io.Reader) *http.Request</code></pre>&#13;
<p>Unlike its <code>http.NewRequest</code> equivalent, <code>httptest.NewRequest</code> will panic instead of returning an error. This is preferable in tests but not in production code.</p>&#13;
<p>The <code>httptest.NewRecorder</code> function returns a pointer to an <code>httptest.ResponseRecorder</code>, which implements the <code>http.ResponseWriter</code> interface. Although the <code>httptest.ResponseRecorder</code> exports fields that look tempting to use (I don’t want to tempt you by mentioning them), I recommend you call its <code>Result</code> method instead. The <code>Result</code> method returns a pointer to an <code>http.Response</code> object, just like the one we used in the last chapter. As the method’s name implies, it waits until the handler returns before retrieving the <code>httptest.ResponseRecorder</code>‘s results.</p>&#13;
<p>If you’re interested in performing integration tests, the <code>net/http/httptest</code> package includes a test server implementation. For the purposes of this chapter, we’ll use <code>httptest.NewRequest</code> and <code>httptest.NewRecorder</code>.</p>&#13;
<h3 id="h2-500884c09-0004">How You Write the Response Matters</h3>&#13;
<p class="BodyFirst">Here’s one potential pitfall: the order in which you write to the response body and set the response status code matters. The client receives the response status code first, followed by the response body from the server. If you write the response body first, Go infers that the response status code is 200 OK and sends it along to the client before sending the response body. To see this in action, look at <a href="#listing9-5" id="listinganchor9-5">Listing 9-5</a>.</p>&#13;
<pre><code>package handlers&#13;
&#13;
import (&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestHandlerWriteHeader(t *testing.T) {&#13;
    handler := func(w http.ResponseWriter, r *http.Request) {&#13;
        _, _ = <span class="CodeAnnotation">1</span>w.Write([]byte("Bad request"))&#13;
      <span class="CodeAnnotation">2</span>w.WriteHeader(http.StatusBadRequest)&#13;
    }&#13;
    r := httptest.NewRequest(http.MethodGet, "http://test", nil)&#13;
    w := httptest.NewRecorder()&#13;
    handler(w, r)&#13;
    t.Logf("Response status: %q", <span class="CodeAnnotation">3</span>w.Result().Status)&#13;
&#13;
    handler = func(w http.ResponseWriter, r *http.Request) {&#13;
      <span class="CodeAnnotation">4</span>w.WriteHeader(http.StatusB)&#13;
        _, _ = <span class="CodeAnnotation">5</span>w.Write([]byte("Bad request"))&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_197" title="197"/>    r = httptest.NewRequest(http.MethodGet, "http://test", nil)&#13;
    w = httptest.NewRecorder()&#13;
    handler(w, r)&#13;
    t.Logf("Response status: %q", <span class="CodeAnnotation">6</span>w.Result().Status)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: Writing the status first and the response body second for expected results (<em>handlers/pitfall_test.go</em>)</p>&#13;
<p>At first glance, it may seem like the first handler function generates a response status code of 400 Bad Request and the string <code>Bad request</code> in the response body. But this isn’t what happens. Calling the <code>ResponseWriter</code>’s <code>Write</code> method causes Go to make an implicit call to the response’s <code>WriteHeader</code> method with <code>http.StatusOK</code> for you. Once the response’s status code is set with an explicit or implicit call to <code>WriteHeader</code>, you cannot change it.</p>&#13;
<p>The Go authors made this design choice because they reasoned you’d need to call <code>WriteHeader</code> only for adverse conditions, and in that case, you should do so before you write anything to the response body. Remember, the server sends the response status code before the response body. Once the response’s status code is set with an explicit or implicit call to <code>WriteHeader</code>, you cannot change it because it’s likely on its way to the client.</p>&#13;
<p>In this example, however, you make a call to the <code>Write</code> method <span class="CodeAnnotation">1</span>, which implicitly calls <code>WriteHeader(http.StatusOK)</code>. Since the status code is not yet set, the response code is now 200 OK. The next call to <code>WriteHeader</code><span class="CodeAnnotation">2</span> is effectively a no-op because the status code is already set. The response code 200 OK persists <span class="CodeAnnotation">3</span>. </p>&#13;
<p>Now, if you switch the order of the calls so you set the status code <span class="CodeAnnotation">4</span> before you write to the response body <span class="CodeAnnotation">5</span>, the response has the proper status code <span class="CodeAnnotation">6</span>.</p>&#13;
<p>Let’s have a look at the test output to confirm that this is the case:</p>&#13;
<pre><code>=== RUN   TestHandlerWriteHeader&#13;
    TestHandlerWriteHeader: pitfall_test.go:17: Response status: "200 OK"&#13;
    TestHandlerWriteHeader: pitfall_test.go:26: Response status: "400 Bad Request"&#13;
--- PASS: TestHandlerWriteHeader (0.00s)&#13;
PASS</code></pre>&#13;
<p>As you can see from the test output, any writes to the response body before you call the <code>WriteHeader</code> method result in a 200 OK status code. The only way to dictate the response status code is to call the <code>WriteHeader</code> method before any writes to the response body.</p>&#13;
<p>You can improve this code even further by using the <code>http.Error</code> function, which simplifies the process of writing a response status code and response body. For example, you could replace your handlers with this single line of code:</p>&#13;
<pre><code>http.Error(w, "Bad request", http.StatusBadRequest)</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_198" title="198"/>This function sets the content type to <em>text/plain</em>, sets the status code to 400 Bad Request, and writes the error message to the response body.</p>&#13;
<h3 id="h2-500884c09-0005">Any Type Can Be a Handler</h3>&#13;
<p class="BodyFirst">Because <code>http.Handler</code> is an interface, you can use it to write powerful constructs for handling client requests. Let’s improve upon the default handler from <a href="#listing9-4">Listing 9-4</a> by defining a new type that implements the <code>http.Handler</code> interface in <a href="#listing9-6" id="listinganchor9-6">Listing 9-6</a>. This type will allow you to appropriately respond to specific HTTP methods and will automatically implement the <code>OPTIONS</code> method for you.</p>&#13;
<pre><code>package handlers&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "html"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "net/http"&#13;
    "sort"&#13;
    "strings"&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">1</span> type Methods map[string]http.Handler&#13;
&#13;
func (h Methods) <span class="CodeAnnotation">2</span>ServeHTTP(w http.ResponseWriter, r *http.Request) {&#13;
 <span class="CodeAnnotation">3</span> defer func(r io.ReadCloser) {&#13;
        _, _ = io.Copy(ioutil.Discard, r)&#13;
        _ = r.Close()&#13;
    }(r.Body)&#13;
&#13;
    if handler, ok := h[r.Method]; ok {&#13;
        if handler == nil {&#13;
     <span class="CodeAnnotation">4</span> http.Error(w, "Internal server error",&#13;
                http.StatusInternalServerError)&#13;
        } else {&#13;
     <span class="CodeAnnotation">5</span> handler.ServeHTTP(w, r)&#13;
        }&#13;
&#13;
        return&#13;
    }&#13;
&#13;
 <span class="CodeAnnotation">6</span> w.Header().Add("Allow", h.allowedMethods())&#13;
    if r.Method != <span class="CodeAnnotation">7</span>http.MethodOptions {&#13;
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)&#13;
    }&#13;
}&#13;
&#13;
func (h Methods) allowedMethods() string {&#13;
    a := make([]string, 0, len(h))&#13;
&#13;
    for k := range h {&#13;
        a = append(a, k)&#13;
<span epub:type="pagebreak" id="Page_199" title="199"/>    }&#13;
    sort.Strings(a)&#13;
&#13;
    return strings.Join(a, ", ")&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: Methods map that dynamically routes requests to the right handler (<em>handlers/methods.go</em>)</p>&#13;
<p>The new type, named <code>Methods</code>, is a map <span class="CodeAnnotation">1</span> whose key is an HTTP method and whose value is an <code>http.Handler</code>. It has a <code>ServeHTTP</code> method <span class="CodeAnnotation">2</span> to implement the <code>http.Handler</code> interface, so you can use <code>Methods</code> as a handler itself. The <code>ServeHTTP</code> method first defers a function to drain and close the request body <span class="CodeAnnotation">3</span>, saving the map’s handlers from having to do so.</p>&#13;
<p>The <code>ServeHTTP</code> method looks up the request method in the map and retrieves the handler. To protect us from panics, the <code>ServeHTTP</code> method makes sure the corresponding handler is not <code>nil</code>, responding with 500 Internal Server Error <span class="CodeAnnotation">4</span> if it is. Otherwise, you call the corresponding handler’s <code>ServeHTTP</code> method <span class="CodeAnnotation">5</span>. The <code>Methods</code> type is a multiplexer (router) since it routes requests to the appropriate handler.</p>&#13;
<p>If the request method isn’t in the map, <code>ServeHTTP</code> responds with the Allow header <span class="CodeAnnotation">6</span> and a list of supported methods in the map. All that’s left do now is determine whether the client explicitly requested the <code>OPTIONS</code><span class="CodeAnnotation">7</span> method. If so, the <code>ServeHTTP</code> method returns, resulting in a 200 OK response to the client. If not, the client receives a 405 Method Not Allowed response.</p>&#13;
<p><a href="#listing9-7" id="listinganchor9-7">Listing 9-7</a> uses the <code>Methods</code> handler to implement a better default handler than the one found in <a href="#listing9-4">Listing 9-4</a>. The old default handler did not automatically add the Allow header and support the <code>OPTIONS</code> method. This one will, which makes your job a bit easier. All you need to determine is which methods your <code>Methods</code> handler should support, then implement them.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func DefaultMethodsHandler() http.Handler {&#13;
    return Methods{&#13;
     <span class="CodeAnnotation">1</span> http.MethodGet: http.HandlerFunc(&#13;
            func(w http.ResponseWriter, r *http.Request) {&#13;
                _, _ = w.Write([]byte("Hello, friend!"))&#13;
            },&#13;
        ),&#13;
     <span class="CodeAnnotation">2</span> http.MethodPost: http.HandlerFunc(&#13;
            func(w http.ResponseWriter, r *http.Request) {&#13;
                b, err := ioutil.ReadAll(r.Body)&#13;
                if err != nil {&#13;
                    http.Error(w, "Internal server error",&#13;
                        http.StatusInternalServerError)&#13;
                    return&#13;
                }&#13;
&#13;
                _, _ = fmt.Fprintf(w, "Hello, %s!",&#13;
                    html.EscapeString(string(b)))&#13;
<span epub:type="pagebreak" id="Page_200" title="200"/>            },&#13;
        ),&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: Default implementation of the <var>Methods</var> handler (<em>methods.go</em>)</p>&#13;
<p>Now, the handler returned by the <code>handlers.DefaultMethodsHandler</code> function supports the <code>GET</code>, <code>POST</code>, and <code>OPTIONS</code> methods. The <code>GET</code> method simply writes the <code>Hello, friend!</code> message to the response body <span class="CodeAnnotation">1</span>. The <code>POST</code> method greets the client with the HTML-escaped request body contents <span class="CodeAnnotation">2</span>. The remaining functionality to support the <code>OPTIONS</code> method and properly set the Allow header are inherent to the <code>Methods</code> type’s <code>ServeHTTP</code> method.</p>&#13;
<p>The handler returned by the <code>handlers.DefaultMethodsHandler</code> function is a drop-in replacement for the handler returned by the <code>handlers.DefaultHandler</code> function. You can exchange the following snippet of code from <a href="#listing9-1">Listing 9-1</a>:</p>&#13;
<pre><code>Handler: http.TimeoutHandler(handlers.DefaultHandler(), 2*time.Minute, ""),</code></pre>&#13;
<p class="BodyContinued">for this code:</p>&#13;
<pre><code>Handler: http.TimeoutHandler(handlers.DefaultMethodsHandler(), 2*time.Minute, ""),</code></pre>&#13;
<p class="BodyContinued">to take advantage of the added functionality provided by the <code>Methods</code> handler.</p>&#13;
<h3 id="h2-500884c09-0006">Injecting Dependencies into Handlers</h3>&#13;
<p class="BodyFirst">The <code>http.Handler</code> interface gives you access to the request and response objects. But it’s likely you’ll require access to additional functionality like a logger, metrics, cache, or database to handle a request. For example, you may want to inject a logger to record request errors or inject a database object to retrieve data used to create the response. The easiest way to inject an object into a handler is by using a closure.</p>&#13;
<p><a href="#listing9-8" id="listinganchor9-8">Listing 9-8</a> demonstrates how to inject a SQL database object into an <code>http.Handler</code>.</p>&#13;
<pre><code>dbHandler := func(<span class="CodeAnnotation">1</span>db *sql.DB) http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
            err := <span class="CodeAnnotation">2</span>db.Ping()&#13;
            // do something with the database here…&#13;
        },&#13;
    )&#13;
}&#13;
&#13;
http.Handle("/three", <span class="CodeAnnotation">3</span>dbHandler(db))</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: Injecting a dependency into a handler using a closure</p>&#13;
<p>You create a function that accepts a pointer to a SQL database object <span class="CodeAnnotation">1</span> and returns a handler, then assign it to a variable named <code>dbHandler</code>. Since <span epub:type="pagebreak" id="Page_201" title="201"/>this function closes over the returned handler, you have access to the <code>db</code> variable in the handler’s scope <span class="CodeAnnotation">2</span>. Instantiating the handler is as simple as calling <code>dbHandler</code> and passing in a pointer to a SQL database object <span class="CodeAnnotation">3</span>.</p>&#13;
<p>This approach can get a bit cumbersome if you have multiple handlers that require access to the same database object or your design is evolving and you’re likely to require access to additional objects in the future. A more extensible approach is to use a struct whose fields represent objects and data you want to access in your handler and to define your handlers as struct methods (see <a href="#listing9-9" id="listinganchor9-9">Listing 9-9</a>). Injecting dependencies involves adding struct fields instead of modifying a bunch of closure definitions.</p>&#13;
<pre><code>type Handlers struct {&#13;
    db *sql.DB&#13;
  <span class="CodeAnnotation">1</span>log *log.Logger&#13;
}&#13;
&#13;
func (h *Handlers) Handler1() http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
            err := h.db.Ping()&#13;
            if err != nil {&#13;
              <span class="CodeAnnotation">2</span>h.log.Printf("db ping: %v", err)&#13;
            }&#13;
            // do something with the database here&#13;
        },&#13;
    )&#13;
}&#13;
&#13;
func (h *Handlers) Handler2() http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
            // ...&#13;
        },&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-9">Listing 9-9</a>: Injecting dependencies into multiple handlers defined as struct methods</p>&#13;
<p>You define a struct that contains pointers to a database object and a logger <span class="CodeAnnotation">1</span>. Any method you define on the handler now has access to these objects <span class="CodeAnnotation">2</span>. If your handlers require access to additional resources, you simply add fields to the struct.</p>&#13;
<p><a href="#listing9-10" id="listinganchor9-10">Listing 9-10</a> illustrates how to use the <code>Handlers</code> struct.</p>&#13;
<pre><code>h := &amp;Handlers{&#13;
    db: <span class="CodeAnnotation">1</span>db,&#13;
    log: log.New(os.Stderr, "handlers: ", log.Lshortfile),&#13;
}&#13;
http.Handle("/one", h.Handler1())&#13;
http.Handle("/two", h.Handler2())</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-10">Listing 9-10</a>: Initializing the <var>Handlers</var> struct and using its handlers</p>&#13;
<p><span epub:type="pagebreak" id="Page_202" title="202"/>Assuming <code>db</code><span class="CodeAnnotation">1</span> is a pointer to a <code>sql.DB</code> object, you initialize a <code>Handlers</code> object and use its methods with <code>http.Handle</code>, for example.</p>&#13;
<h2 id="h1-500884c09-0003">Middleware</h2>&#13;
<p class="BodyFirst">Middleware comprises reusable functions that accept an <code>http.Handler</code> and return an <code>http.Handler</code>:</p>&#13;
<pre><code>func(http.Handler) http.Handler</code></pre>&#13;
<p>You can use middleware to inspect the request and make decisions based on its content before passing it along to the next handler. Or you might use the request content to set headers in the response. For example, the middleware could respond to the client with an error if the handler requires authentication and an unauthenticated client sent the request. Middleware can also collect metrics, log requests, or control access to resources, to name a few uses. Best of all, you can reuse them on multiple handlers. If you find yourself writing the same handler code over and over, ask yourself if you can put the functionality into middleware and reuse it across your handlers. </p>&#13;
<p><a href="#listing9-11" id="listinganchor9-11">Listing 9-11</a> shows just a few uses of middleware, such as enforcing which methods the handler allows, adding headers to the response, or performing ancillary functions like logging.</p>&#13;
<pre><code>func Middleware(next http.Handler) http.Handler {&#13;
    return <span class="CodeAnnotation">1</span>http.HandlerFunc(&#13;
     <span class="CodeAnnotation">2</span> func(w http.ResponseWriter, r *http.Request) {&#13;
            if r.Method == http.MethodTrace {&#13;
              <span class="CodeAnnotation">3</span>http.Error(w, "Method not allowed",&#13;
                    http.StatusMethodNotAllowed)&#13;
            }&#13;
&#13;
          <span class="CodeAnnotation">4</span>w.Header().Set("X-Content-Type-Options", "nosniff")&#13;
&#13;
            start := time.Now()&#13;
          <span class="CodeAnnotation">5</span>next.ServeHTTP(w, r)&#13;
          <span class="CodeAnnotation">6</span>log.Printf("Next handler duration %v", time.Now().Sub(start))&#13;
        },&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-11">Listing 9-11</a>: Example middleware function</p>&#13;
<p>The <code>Middleware</code> function uses a common pattern you first saw in <a href="#listing9-4">Listing 9-4</a>: it defines a function that accepts an <code>http.ResponseWriter</code> and a pointer to an <code>http.Request</code><span class="CodeAnnotation">2</span> and wraps it with an <code>http.HandlerFunc</code><span class="CodeAnnotation">1</span>.</p>&#13;
<p>In most cases, middleware calls the given handler <span class="CodeAnnotation">5</span>. But in some cases that may not be proper, and the middleware should block the next handler and respond to the client itself <span class="CodeAnnotation">3</span>. Likewise, you may want to use middleware to collect metrics, ensure specific headers are set on the response <span class="CodeAnnotation">4</span>, or write to a log file <span class="CodeAnnotation">6</span>. </p>&#13;
<p><span epub:type="pagebreak" id="Page_203" title="203"/><a href="#listing9-11">Listing 9-11</a> is a contrived example. I don’t recommend performing so many tasks in a single middleware function. Instead, it’s best to follow the Unix philosophy and write minimalist middleware, with each function doing one thing very well. Ideally, you would split the middleware in <a href="#listing9-11">Listing 9-11</a> into three middleware functions to check the request method and respond to the client <span class="CodeAnnotation">3</span>, enforce response headers <span class="CodeAnnotation">4</span>, and collect metrics <span class="CodeAnnotation">6</span>.</p>&#13;
<p>The <code>net/http</code> package includes useful middleware to serve static files, redirect requests, and manage request time-outs. Let’s dig into their source code to see how you might use them. In addition to these standard library functions, check out the middleware at <a class="LinkURL" href="https://go.dev/">https://go.dev/</a>.</p>&#13;
<h3 id="h2-500884c09-0007">Timing Out Slow Clients</h3>&#13;
<p class="BodyFirst">As I mentioned earlier, it’s important not to let clients dictate the duration of a request-response life cycle. Malicious clients could use this leniency to their ends and exhaust your server’s resources, effectively denying service to legit clients. Yet at the same time, setting read and write time-outs server-wide makes it hard for the server to stream data or use different time-out durations for each handler. </p>&#13;
<p>Instead, you should manage time-outs in middleware or individual handlers. The <code>net/http</code> package includes a middleware function that allows you to control the duration of a request and response on a per-handler basis. The <code>http.TimeoutHandler</code> accepts an <code>http.Handler</code>, a duration, and a string to write to the response body. It sets an internal timer to the given duration. If the <code>http.Handler</code> does not return before the timer expires, the <code>http.TimeoutHandler</code> blocks the <code>http.Handler</code> and responds to the client with a 503 Service Unavailable status.</p>&#13;
<p><a href="#listing9-12" id="listinganchor9-12">Listing 9-12</a> uses the <code>http.TimeoutHandler</code> to wrap an <code>http.Handler</code> that mimics a slow client. </p>&#13;
<pre><code>package middleware&#13;
&#13;
import (&#13;
    "io/ioutil"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestTimeoutMiddleware(t *testing.T) {&#13;
    handler := <span class="CodeAnnotation">1</span>http.TimeoutHandler(&#13;
        http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {&#13;
            w.WriteHeader(http.StatusNoContent)&#13;
          <span class="CodeAnnotation">2</span>time.Sleep(time.Minute)&#13;
        }),&#13;
        time.Second,&#13;
        "Timed out while reading response",&#13;
    )&#13;
&#13;
    r := httptest.NewRequest(http.MethodGet, "http://test/", nil)&#13;
    w := httptest.NewRecorder()&#13;
<span epub:type="pagebreak" id="Page_204" title="204"/>    handler.ServeHTTP(w, r)&#13;
&#13;
    resp := w.Result()&#13;
    if resp.StatusCode != <span class="CodeAnnotation">3</span>http.StatusServiceUnavailable {&#13;
        t.Fatalf("unexpected status code: %q", resp.Status)&#13;
    }&#13;
&#13;
    b, err := <span class="CodeAnnotation">4</span>ioutil.ReadAll(resp.Body)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    _ = resp.Body.Close()&#13;
&#13;
 <span class="CodeAnnotation">5</span> if actual := string(b); actual != "Timed out while reading response" {&#13;
        t.Logf("unexpected body: %q", actual)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-12">Listing 9-12</a>: Giving clients a finite time to read the response (<em>middleware/timeout_test.go</em>)</p>&#13;
<p>Despite its name, <code>http.TimeoutHandler</code> is middleware that accepts an <code>http.Handler</code> and returns an <code>http.Handler</code><span class="CodeAnnotation">1</span>. The wrapped <code>http.Handler</code> purposefully sleeps for a minute <span class="CodeAnnotation">2</span> to simulate a client’s taking its time to read the response, preventing the <code>http.Handler</code> from returning. When the handler doesn’t return within one second, <code>http.TimeoutHandler</code> sets the response status code to 503 Service Unavailable <span class="CodeAnnotation">3</span>. The test reads the entire response body <span class="CodeAnnotation">4</span>, properly closes it, and makes sure the response body has the string written by the middleware <span class="CodeAnnotation">5</span>.</p>&#13;
<h3 id="h2-500884c09-0008">Protecting Sensitive Files</h3>&#13;
<p class="BodyFirst">Middleware can also keep clients from accessing information you’d like to keep private. For example, the <code>http.FileServer</code> function simplifies the process of serving static files to clients, accepting an <code>http.FileSystem</code> interface, and returning an <code>http.Handler</code>. The problem is, it won’t protect against serving up potentially sensitive files. Any file in the target directory is fair game. By convention, many operating systems store configuration files or other sensitive information in files and directories prefixed with a period and then hide these dot-prefixed files and directories by default. (This is particularly true in Unix-compatible systems.) But the <code>http.FileServer</code> will gladly serve dot-prefixed files or traverse dot-prefixed directories. </p>&#13;
<p>The <code>net/http</code> package documentation includes an example of an <code>http.FileSystem</code> that prevents the <code>http.FileServer</code> from serving dot-prefixed files and directories. <a href="#listing9-13" id="listinganchor9-13">Listing 9-13</a> takes a different approach by using middleware to offer the same protection.</p>&#13;
<pre><code>package middleware&#13;
&#13;
import (&#13;
    "net/http"&#13;
    "path"&#13;
<span epub:type="pagebreak" id="Page_205" title="205"/>    "strings"&#13;
)&#13;
&#13;
func RestrictPrefix(prefix string, next http.Handler) http.Handler {&#13;
    return <span class="CodeAnnotation">1</span>http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
         <span class="CodeAnnotation">2</span> for _, p := range strings.Split(path.Clean(r.URL.Path), "/") {&#13;
                if strings.HasPrefix(p, prefix) {&#13;
                 <span class="CodeAnnotation">3</span> http.Error(w, "Not Found", http.StatusNotFound)&#13;
                    return&#13;
                }&#13;
            }&#13;
          next.ServeHTTP(w, r)&#13;
        },&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-13">Listing 9-13</a>: Protecting any file or directory with a given prefix (<em>middleware/restrict_prefix.go</em>).</p>&#13;
<p>The <code>RestrictPrefix</code> middleware <span class="CodeAnnotation">1</span> examines the URL path <span class="CodeAnnotation">2</span> to look for any elements that start with a given prefix. If the middleware finds an element in the URL path with the given prefix, it preempts the <code>http.Handler</code> and responds with a 404 Not Found status <span class="CodeAnnotation">3</span>.</p>&#13;
<p><a href="#listing9-14" id="listinganchor9-14">Listing 9-14</a> uses the <code>RestrictPrefix</code> middleware with a series of test cases.</p>&#13;
<pre><code>package middleware&#13;
&#13;
import (&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestRestrictPrefix(t *testing.T) {&#13;
    handler := <span class="CodeAnnotation">1</span>http.StripPrefix("/static/",&#13;
      <span class="CodeAnnotation">2</span>RestrictPrefix(".", <span class="CodeAnnotation">3</span>http.FileServer(http.Dir("../files/"))),&#13;
    )&#13;
&#13;
    testCases := []struct {&#13;
        path string&#13;
        code int&#13;
    }{&#13;
      <span class="CodeAnnotation">4</span>{"http://test/static/sage.svg", http.StatusOK},&#13;
        {"http://test/static/.secret", http.StatusNotFound},&#13;
        {"http://test/static/.dir/secret", http.StatusNotFound},&#13;
    }&#13;
&#13;
    for i, c := range testCases {&#13;
        r := httptest.NewRequest(http.MethodGet, c.path, nil)&#13;
        w := httptest.NewRecorder()&#13;
        handler.ServeHTTP(w, r)&#13;
&#13;
<span epub:type="pagebreak" id="Page_206" title="206"/>        actual := w.Result().StatusCode&#13;
        if c.code != actual {&#13;
            t.Errorf("%d: expected %d; actual %d", i, c.code, actual)&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-14">Listing 9-14</a>: Using the <var>RestrictPrefix</var> middleware (<em>middleware/restrict_prefix_test.go</em>)</p>&#13;
<p>It’s important to realize the server first passes the request to the <code>http.StripPrefix</code> middleware <span class="CodeAnnotation">1</span>, then the <code>RestrictPrefix</code> middleware <span class="CodeAnnotation">2</span>, and if the <code>RestrictPrefix</code> middleware approves the resource path, the <code>http.FileServer</code><span class="CodeAnnotation">3</span>. The <code>RestrictPrefix</code> middleware evaluates the request’s resource path to determine whether the client is requesting a restricted path, no matter whether the path exists or not. If so, the <code>RestrictPrefix</code> middleware responds to the client with an error without ever passing the request onto the <code>http.FileServer</code>.</p>&#13;
<p>The static files served by this test’s <code>http.FileServer</code> exist in a directory named <em>files</em> in the <em>restrict_prefix_test.go</em> file’s parent directory. Files in the <em>../files</em> directory are in the root of the filesystem passed to the <code>http.FileServer</code>. For example, the <em>../files/sage.svg</em> file on the operating system’s filesystem is at <em>/sage.svg</em> in the <code>http.FileSystem</code> passed to the <code>http.FileServer</code>. If a client wanted to retrieve the <em>sage.svg</em> file from the <code>http.FileServer</code>, the request path should be <em>/sage.svg</em>.</p>&#13;
<p>But the URL path for each of our test cases <span class="CodeAnnotation">4</span> includes the <em>/static/</em> prefix followed by the static filename. This means that the test requests <em>static/sage.svg</em> from the <code>http.FileServer</code>, which doesn’t exist. The test uses another bit of middleware from the <code>net/http</code> package to solve this path discrepancy. The <code>http.StripPrefix</code> middleware strips the given prefix from the URL path before passing along the request to the <code>http.Handler</code>, the <code>http.FileServer</code> in this test.</p>&#13;
<p>Next, you block access to sensitive files by wrapping the <code>http.FileServer</code> with the <code>RestrictPrefix</code> middleware to prevent the handler from serving any file or directory prefixed with a period. The first test case results in a 200 OK status, because no element in the URL path has a period prefix. The <code>http.StripPrefix</code> middleware removes the <em>/static/</em> prefix from the test case’s URL, changing it from <em>/static/sage.svg </em>to <em>sage.svg</em>. It then passes this path to the <code>http.FileServer</code>, which finds the corresponding file in its <code>http.FileSystem</code>. The <code>http.FileServer</code> writes the file contents to the response body. </p>&#13;
<p>The second test case results in a 404 Not Found status because the <em>.secret</em> filename has a period as its first character. The third case also results in a 404 Not Found status due to the <em>.dir</em> element in the URL path, because your <code>RestrictPrefix</code> middleware considers the prefix of each segment in the path, not just the file.</p>&#13;
<p>A better approach to restricting access to resources would be to block all resources by default and explicitly allow select resources. As an exercise, try implementing the inverse of the <code>RestrictPrefix</code> middleware by creating middleware that permits requests for only an allowed list of resources.</p>&#13;
<h2 id="h1-500884c09-0004"><span epub:type="pagebreak" id="Page_207" title="207"/>Multiplexers</h2>&#13;
<p class="BodyFirst">One afternoon, I walked into the University of Michigan’s library, the fourth largest library in the United States. I was looking for a well-worn copy of Kurt Vonnegut’s <em>Cat’s Cradle</em> and had no idea where to start my search. I found the nearest librarian and asked for help finding the book. When we arrived at the correct location, the book was 404 Not Found.</p>&#13;
<p>A <em>multiplexer</em>, like the friendly librarian routing me to the proper bookshelf, is a general handler that routes a request to a specific handler. The <code>http.ServeMux</code> multiplexer is an <code>http.Handler</code> that routes an incoming request to the proper handler for the requested resource. By default, <code>http.ServeMux</code> responds with a 404 Not Found status for all incoming requests, but you can use it to register your own patterns and corresponding handlers. It will then compare the request’s URL path with its registered patterns, passing the request and response writer to the handler that corresponds to the longest matching pattern.</p>&#13;
<p><a href="#listing9-1">Listing 9-1</a> used a multiplexer to send all requests to a single endpoint. <a href="#listing9-15" id="listinganchor9-15">Listing 9-15</a> introduces a slightly more complex multiplexer that has three endpoints. This one evaluates the requested resource and routes the request to the right endpoint. </p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "testing"&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">1</span> func drainAndClose(next http.Handler) http.Handler {&#13;
    return http.HandlerFunc(&#13;
        func(w http.ResponseWriter, r *http.Request) {&#13;
          <span class="CodeAnnotation">2</span>next.ServeHTTP(w, r)&#13;
            _, _ = io.Copy(ioutil.Discard, r.Body)&#13;
            _ = r.Body.Close()&#13;
        },&#13;
    )&#13;
}&#13;
&#13;
func TestSimpleMux(t *testing.T) {&#13;
    serveMux := http.NewServeMux()&#13;
 <span class="CodeAnnotation">3</span> serveMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {&#13;
        w.WriteHeader(http.StatusNoContent)&#13;
    })&#13;
    serveMux.HandleFunc(<span class="CodeAnnotation">4</span>"/hello", func(w http.ResponseWriter,&#13;
        r *http.Request) {&#13;
        _, _ = fmt.Fprint(w, "Hello friend.")&#13;
    })&#13;
    serveMux.HandleFunc(<span class="CodeAnnotation">5</span>"/hello/there/", func(w http.ResponseWriter,&#13;
<span epub:type="pagebreak" id="Page_208" title="208"/>        r *http.Request) {&#13;
        _, _ = fmt.Fprint(w, "Why, hello there.")&#13;
    })&#13;
    mux := drainAndClose(serveMux)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-15">Listing 9-15</a>: Registering patterns to a multiplexer and wrapping the entire multiplexer with middleware (<em>mux_test.go</em>).</p>&#13;
<p>The test creates a new multiplexer and registers three routes using the multiplexer’s <code>HandleFunc</code> method <span class="CodeAnnotation">3</span>. The first route is simply a forward slash, showing the default or empty URL path, and a function that sets the 204 No Content status in the response. This route will match all URL paths if no other route matches. The second is <em>/hello</em><span class="CodeAnnotation">4</span>, which writes the string <code>Hello friend.</code> to the response. The final path is <em>/hello/there/</em><span class="CodeAnnotation">5</span>, which writes the string <code>Why, hello there.</code> to the response. </p>&#13;
<p>Notice that the third route ends in a forward slash, making it a subtree, while the earlier route <span class="CodeAnnotation">4</span> did not end in a forward slash, making it an absolute path. This distinction tends to be a bit confusing for unaccustomed users. Go’s multiplexer treats absolute paths as exact matches: either the request’s URL path matches, or it doesn’t. By contrast, it treats subtrees as prefix matches. In other words, the multiplexer will look for the longest registered pattern that comes at the beginning of the request’s URL path. For example, <em>/hello/there/</em> is a prefix of <em>/hello/there/you</em> but not of <em>/hello/you</em>. </p>&#13;
<p>Go’s multiplexer can also redirect a URL path that doesn’t end in a forward slash, such as <em>/hello/there</em>. In those cases, the <code>http.ServeMux</code> first attempts to find a matching absolute path. If that fails, the multiplexer appends a forward slash, making the path <em>/hello/there/</em>, for example, and responds to the client with it. This new path becomes a permanent redirect. You’ll see an example of this in <a href="#listing9-16" id="listinganchor9-16">Listing 9-16</a>.</p>&#13;
<p>Now that you’ve defined routes for the multiplexer, it’s ready to use. But there’s one issue with the handlers: none of them drain and close the request body. This isn’t a big concern in a test like this, but you should stick to best practices, nonetheless. If you don’t do so in a real scenario, you may cause increased overhead and potential memory leaks. Here, you use middleware <span class="CodeAnnotation">1</span> to drain and close the request body. In the <code>drainAndClose</code> middleware, you call the <code>next</code> handler first <span class="CodeAnnotation">2</span> and then drain and close the request body. There is no harm in draining and closing a previously drained and closed request body. </p>&#13;
<p><a href="#listing9-16">Listing 9-16</a> tests a series of requests against <a href="#listing9-15">Listing 9-15</a>’s multiplexer.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    testCases := []struct {&#13;
        path     string&#13;
        response string&#13;
        code     int&#13;
    }{&#13;
     <span class="CodeAnnotation">1</span> {"http://test/", "", http.StatusNoContent},&#13;
        {"http://test/hello", "Hello friend.", http.StatusOK},&#13;
        {"http://test/hello/there/", "Why, hello there.", http.StatusOK},&#13;
     <span class="CodeAnnotation">2</span> {"http://test/hello/there",&#13;
<span epub:type="pagebreak" id="Page_209" title="209"/>            "&lt;a href=\"/hello/there/\"&gt;Moved Permanently&lt;/a&gt;.\n\n",&#13;
            http.StatusMovedPermanently},&#13;
     <span class="CodeAnnotation">3</span> {"http://test/hello/there/you", "Why, hello there.", http.StatusOK},&#13;
     <span class="CodeAnnotation">4</span> {"http://test/hello/and/goodbye", "", http.StatusNoContent},&#13;
        {"http://test/something/else/entirely", "", http.StatusNoContent},&#13;
        {"http://test/hello/you", "", http.StatusNoContent},&#13;
    }&#13;
&#13;
    for i, c := range testCases {&#13;
        r := httptest.NewRequest(http.MethodGet, c.path, nil)&#13;
        w := httptest.NewRecorder()&#13;
        mux.ServeHTTP(w, r)&#13;
        resp := w.Result()&#13;
&#13;
        if actual := resp.StatusCode; c.code != actual {&#13;
            t.Errorf("%d: expected code %d; actual %d", i, c.code, actual)&#13;
        }&#13;
&#13;
        b, err := <span class="CodeAnnotation">5</span>ioutil.ReadAll(resp.Body)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
        _ = <span class="CodeAnnotation">6</span>resp.Body.Close()&#13;
&#13;
        if actual := string(b); c.response != actual {&#13;
            t.Errorf("%d: expected response %q; actual %q", i,&#13;
                c.response, actual)&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-16">Listing 9-16</a>: Running through a series of test cases and verifying the response status code and body (<em>mux_test.go</em>).</p>&#13;
<p>The first three test cases <span class="CodeAnnotation">1</span>, including the request for the <em>/hello/there/</em> path, match exact patterns registered with the multiplexer. But the fourth test case <span class="CodeAnnotation">2</span> is different. It doesn’t have an exact match. When the multiplexer appends a forward slash to it, however, it discovers that it exactly matches a registered pattern. Therefore, the multiplexer responds with a 301 Moved Permanently status and a link to the new path in the response body. The fifth test case <span class="CodeAnnotation">3</span> matches the <em>/hello/there/</em> subtree and receives the <code>Why, hello there.</code> response. The last three test cases <span class="CodeAnnotation">4</span> match the default path of <em>/</em> and receive the 204 No Content status.</p>&#13;
<p>Just as the test relies on middleware to drain and close the request body, it drains <span class="CodeAnnotation">5</span> and closes <span class="CodeAnnotation">6</span> the response body.</p>&#13;
<h2 id="h1-500884c09-0005">HTTP/2 Server Pushes</h2>&#13;
<p class="BodyFirst">The Go HTTP server can push resources to clients over HTTP/2, a feature that has the potential to improve efficiency. For example, a client may request the home page from a web server, but the client won’t know it needs the associated style sheet and images to properly render the home <span epub:type="pagebreak" id="Page_210" title="210"/>page until it receives the HTML in the response. An HTTP/2 server can proactively send the style sheet and images along with the HTML in the response, saving the client from having to make subsequent calls for those resources. But server pushes have the potential for abuse. This section shows you how to use server pushes and then discusses cases when you should avoid doing so. </p>&#13;
<h3 id="h2-500884c09-0009">Pushing Resources to the Client</h3>&#13;
<p class="BodyFirst">Let’s retrieve the HTML page in <a href="#listing9-17" id="listinganchor9-17">Listing 9-17</a> over HTTP/1.1, then retrieve the same page over HTTP/2 and compare the differences.</p>&#13;
<pre><code>&lt;!DOCTYPE html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
    &lt;meta charset="UTF-8"&gt;&#13;
    &lt;title&gt;H2 Server Push&lt;/title&gt;&#13;
 <span class="CodeAnnotation">1</span> &lt;link href="/static/style.css" rel="stylesheet"&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
 <span class="CodeAnnotation">2</span> &lt;img src="/static/hiking.svg" alt="hiking gopher"&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-17">Listing 9-17</a>: Simple index file having links to two resources (<em>files/index.html</em>)</p>&#13;
<p>This HTML file requires the browser to retrieve two more resources, a style sheet <span class="CodeAnnotation">1</span> and an SVG image <span class="CodeAnnotation">2</span>, to properly show the entire page. <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a> shows Google Chrome’s request accounting for the HTML when served using HTTP/1.1.</p>&#13;
<figure>&#13;
<img alt="f09002" src="image_fi/500884c09/f09002.png"/>&#13;
<figcaption><p><a id="figure9-2">Figure 9-2</a>: Downloaded index page and associated resources over HTTP/1.1</p></figcaption>&#13;
</figure>&#13;
<p>Aside from the <em>favicon.ico</em> file, which Chrome retrieves on its own, the browser made three requests to retrieve all required resources—one for the HTML file, one for the style sheet, and one for the SVG image. Any web browser requesting the <em>index.html</em> file (<em>localhost</em> in <a href="#figure9-2">Figure 9-2</a>) will also request the <em>style.css</em> and <em>hiking.svg</em> files to properly render the <em>index.html</em> file. The web server could improve efficiency and proactively push these two files to the web browser, since it knows the web browser will inevitably request them. This proactive approach by the web server would save the web browser from the overhead of having to make two more requests.</p>&#13;
<p><span epub:type="pagebreak" id="Page_211" title="211"/><a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a> shows the same retrieval using HTTP/2. In this case, the server pushes the <em>style.css</em> and <em>hiking.svg</em> files.</p>&#13;
<figure>&#13;
<img alt="f09003" src="image_fi/500884c09/f09003.png"/>&#13;
<figcaption><p><a id="figure9-3">Figure 9-3</a>: Downloaded index page with resources pushed by the server side</p></figcaption>&#13;
</figure>&#13;
<p>The client receives all three resources after a single request to the server for the <em>index.html</em> file. The Initiator column in <a href="#figure9-3">Figure 9-3</a> shows that Chrome retrieved the resources from its dedicated push cache. </p>&#13;
<p>Let’s write a command line executable that can push resources to clients. <a href="#listing9-18" id="listinganchor9-18">Listing 9-18</a> shows the first part of the program.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "context"&#13;
    "flag"&#13;
    "log"&#13;
    "net/http"&#13;
    "os"&#13;
    "os/signal"&#13;
    "path/filepath"&#13;
    "time"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch09/handlers"&#13;
    "github.com/awoodbeck/gnp/ch09/middleware"&#13;
)&#13;
&#13;
var (&#13;
    addr  = flag.String("listen", "127.0.0.1:8080", "listen address")&#13;
 <span class="CodeAnnotation">1</span> cert  = flag.String("cert", "", "certificate")&#13;
 <span class="CodeAnnotation">2</span> pkey  = flag.String("key", "", "private key")&#13;
    files = flag.String("files", "./files", "static file directory")&#13;
)&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    err := <span class="CodeAnnotation">3</span>run(*addr, *files, *cert, *pkey)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    log.Println("Server gracefully shutdown")&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-18">Listing 9-18</a>: Command line arguments for the HTTP/2 server (<em>server.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_212" title="212"/>The server needs the path to a certificate <span class="CodeAnnotation">1</span> and a corresponding private key <span class="CodeAnnotation">2</span> to enable TLS support and allow clients to negotiate HTTP/2 with the server. If either value is empty, the server will listen for plain HTTP connections. Next, pass the command line flag values to a <code>run</code> function <span class="CodeAnnotation">3</span>. </p>&#13;
<p>The <code>run</code> function, defined in <a href="#listing9-19" id="listinganchor9-19">Listing 9-19</a>, has the bulk of your server’s logic and ultimately runs the web server. Breaking this functionality into a separate function eases unit testing later.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func run(addr, files, cert, pkey string) error {&#13;
    mux := http.NewServeMux()&#13;
 <span class="CodeAnnotation">1</span> mux.Handle("/static/",&#13;
        http.StripPrefix("/static/",&#13;
            middleware.RestrictPrefix(&#13;
                ".", http.FileServer(http.Dir(files)),&#13;
            ),&#13;
        ),&#13;
    )&#13;
 <span class="CodeAnnotation">2</span> mux.Handle("/",&#13;
        handlers.Methods{&#13;
            http.MethodGet: http.HandlerFunc(&#13;
                func(w http.ResponseWriter, r *http.Request) {&#13;
                 <span class="CodeAnnotation">3</span> if pusher, ok := w.(http.Pusher); ok {&#13;
                        targets := []string{&#13;
                          <span class="CodeAnnotation">4</span>"/static/style.css",&#13;
                            "/static/hiking.svg",&#13;
                        }&#13;
                        for _, target := range targets {&#13;
                            if err := <span class="CodeAnnotation">5</span>pusher.Push(target, nil); err != nil {&#13;
                                log.Printf("%s push failed: %v", target, err)&#13;
                            }&#13;
                        }&#13;
                    }&#13;
&#13;
                 <span class="CodeAnnotation">6</span> http.ServeFile(w, r, filepath.Join(files, "index.html"))&#13;
                },&#13;
            ),&#13;
        },&#13;
    )&#13;
 <span class="CodeAnnotation">7</span> mux.Handle("/2",&#13;
        handlers.Methods{&#13;
            http.MethodGet: http.HandlerFunc(&#13;
                func(w http.ResponseWriter, r *http.Request) {&#13;
                    http.ServeFile(w, r, filepath.Join(files, "index2.html"))&#13;
                },&#13;
            ),&#13;
        },&#13;
    )</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-19">Listing 9-19</a>: Multiplexer, middleware, and handlers for the HTTP/2 server (<em>server.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_213" title="213"/>The server’s multiplexer has three routes: one for static files <span class="CodeAnnotation">1</span>, one for the default route <span class="CodeAnnotation">2</span>, and one for the <em>/2</em> absolute path <span class="CodeAnnotation">7</span>. If the <code>http.ResponseWriter</code> is an <code>http.Pusher</code><span class="CodeAnnotation">3</span>, it can push resources to the client <span class="CodeAnnotation">5</span> without a corresponding request. You specify the path to the resource from the client’s perspective <span class="CodeAnnotation">4</span>, not the file path on the server’s filesystem because the server treats the request as if the client originated it to facilitate the server push. After you’ve pushed the resources, you serve the response for the handler <span class="CodeAnnotation">6</span>. If, instead, you sent the <em>index.html</em> file before pushing the associated resources, the client’s browser may send requests for the associated resources before it handles the pushes.</p>&#13;
<p>Web browsers cache HTTP/2-pushed resources for the life of the connection and make it available across routes. Therefore, if the <em>index2.html</em> file served by the <em>/2</em> route <span class="CodeAnnotation">7</span> references the same resources pushed by the default route, and the client first visits the default route, the client’s web browser may use the pushed resources when rendering the <em>/2</em> route.</p>&#13;
<p>You have one more task to complete: instantiate an HTTP server to serve your resources. <a href="#listing9-20" id="listinganchor9-20">Listing 9-20</a> does this by making use of the multiplexer.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    srv := &amp;http.Server{&#13;
        Addr:              addr,&#13;
        Handler:           mux,&#13;
        IdleTimeout:       time.Minute,&#13;
        ReadHeaderTimeout: 30 * time.Second,&#13;
    }&#13;
&#13;
    done := make(chan struct{})&#13;
    go func() {&#13;
        c := make(chan os.Signal, 1)&#13;
        signal.Notify(c, os.Interrupt)&#13;
&#13;
        for {&#13;
         <span class="CodeAnnotation">1</span> if &lt;-c == os.Interrupt {&#13;
             <span class="CodeAnnotation">2</span> if err := srv.Shutdown(context.Background()); err != nil {&#13;
                    log.Printf("shutdown: %v", err)&#13;
                }&#13;
                close(done)&#13;
                return&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
    log.Printf("Serving files in %q over %s\n", files, srv.Addr)&#13;
&#13;
    var err error&#13;
    if cert != "" &amp;&amp; pkey != "" {&#13;
        log.Println("TLS enabled")&#13;
     <span class="CodeAnnotation">3</span> err = srv.ListenAndServeTLS(cert, pkey)&#13;
<span epub:type="pagebreak" id="Page_214" title="214"/>    } else {&#13;
     <span class="CodeAnnotation">4</span> err = srv.ListenAndServe()&#13;
    }&#13;
&#13;
    if err == http.ErrServerClosed {&#13;
        err = nil&#13;
    }&#13;
&#13;
    &lt;-done&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing9-20">Listing 9-20</a>: HTTP/2-capable server implementation (<em>server.go</em>)</p>&#13;
<p>When the server receives an <code>os.Interrupt</code> signal <span class="CodeAnnotation">1</span>, it triggers a call to the server’s <code>Shutdown</code> method <span class="CodeAnnotation">2</span>. Unlike the server’s <code>Close</code> method, which abruptly closes the server’s listener and all active connections, <code>Shutdown</code> gracefully shuts down the server. It instructs the server to stop listening for incoming connections and blocks until all client connections end. This gives the server the opportunity to finish sending responses before stopping the server.</p>&#13;
<p>If the server receives a path to both a certificate and a corresponding private key, the server will enable TLS support by calling its <code>ListenAndServeTLS</code> method <span class="CodeAnnotation">3</span>. If it cannot find or parse either the certificate or private key, this method returns an error. In the absence of these paths, the server uses its <code>ListenAndServe</code> method <span class="CodeAnnotation">4</span>. </p>&#13;
<p>Go ahead and test this server. As mentioned in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, Go doesn’t include the support needed to test the server’s push functionality with code, but you can interact with this program by using your web browser.</p>&#13;
<h3 id="h2-500884c09-0010">Don’t Be Too Pushy</h3>&#13;
<p class="BodyFirst">Although HTTP/2 server pushing can improve the efficiency of your communications, it can do just the opposite if you aren’t careful. Remember that web browsers store pushed resources in a separate cache for the lifetime of the connection. If you’re serving resources that don’t change often, the web browser will likely already have them in its regular cache, so you shouldn’t push them. Once it caches them, the browser can use them for future requests spanning many connections. You probably shouldn’t push the resources in <a href="#listing9-19">Listing 9-19</a>, for instance, because they’re unlikely to change often.</p>&#13;
<p>My advice is to be conservative with server pushes. Use your handlers and rely on metrics to figure out when you should push a resource. If you do push resources, do so before writing the response. </p>&#13;
<h2 id="h1-500884c09-0006"><span epub:type="pagebreak" id="Page_215" title="215"/>What You’ve Learned</h2>&#13;
<p class="BodyFirst">Go’s <code>net/http</code> package includes a capable server implementation. In this chapter, you used its handlers, middleware, multiplexer, and HTTP/2 support to process client requests intelligently and efficiently. </p>&#13;
<p>Go’s <code>http.Handler</code> is an interface that describes an object capable of accepting a request and responding with a status code and payload. A special handler, known as a <em>multiplexer</em>, can parse a request and pass it along to the most proper handler, effectively functioning as a request router. <em>Middleware</em> is code that augments the behavior of handlers or performs auxiliary tasks. It might change the request, add headers to the response, collect metrics, or preempt the handler, to name a few use cases. Finally, Go’s server supports HTTP/2 over TLS. When it uses HTTP/2, the server can push resources to clients, potentially making the communication more efficient.</p>&#13;
<p>By putting these features together, you can build comprehensive, useful HTTP-based applications with surprisingly little code.</p>&#13;
</section>&#13;
</body></html>