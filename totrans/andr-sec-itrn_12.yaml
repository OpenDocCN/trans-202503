- en: Chapter 12. Selinux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While previous chapters mentioned Security-Enhanced Linux (SELinux) and its
    Android integration, our discussion of Android’s security model up until now has
    focused on Android’s “traditional” sandbox implementation, which relies heavily
    on Linux’s default discretionary access control (DAC). The Linux DAC is lightweight
    and well understood, but it has certain disadvantages, most notably the coarse
    granularity of DAC permissions, the potential for misconfigured programs to leak
    data, and the inability to apply fine-grained privilege constraints to processes
    that run as the root user. (While POSIX capabilities, which are implemented as
    an extension to the traditional DAC in Linux, offer a way to grant only certain
    privileges to root processes, the granularity of POSIX capabilities is fairly
    coarse and the granted privileges extend to all objects accessed by the process.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Mandatory access control (MAC)*, as implemented by SELinux, seeks to overcome
    these limitations of Linux’s DAC by enforcing a systemwide, more finely grained
    security policy that can be changed only by the system administrator, and not
    by unprivileged users and programs. This chapter first gives a brief overview
    of the architecture and concepts used in SELinux and then describes the major
    modifications made to SELinux in order to support Android. Finally, we give an
    overview of the SELinux policy that’s deployed in the current version of Android.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: SELinux Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux is a mandatory access control mechanism for the Linux kernel, implemented
    as a Linux security module. The Linux Security Modules (LSM) framework allows
    third-party access control mechanisms to be linked into the kernel and to modify
    the default DAC implementation. LSM is implemented as a series of security function
    hooks (upcalls) and related data structures that are integrated into the various
    modules of the Linux kernel responsible for access control.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Some of the main kernel services that have LSM hooks inserted are program execution,
    file and inode operations, netlink messaging, and socket operations. If no security
    module is installed, Linux uses its built-in DAC mechanism to regulate access
    to kernel objects managed by these services. If a security module is installed,
    Linux consults it in addition to the DAC in order to reach a final security decision
    when access to a kernel object is requested.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Besides providing hooks into major kernel services, the LSM framework also extends
    the procfs virtual filesystem (*/proc*) to include per-process and per-task (thread)
    security attributes, and adds support for using filesystem extended attributes
    as persistent security attribute storage. SELinux was the first LSM module integrated
    into the Linux kernel and has been officially available since version 2.6 (previous
    SELinux implementations were distributed as a set of patches). Since the integration
    of SELinux, other security modules have also been accepted into the mainline kernel,
    which as of this writing includes AppArmor, Smack, and TOMOYO Linux as well. These
    modules provide alternative MAC implementations and are based on different security
    models than those of SELinux.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为主要内核服务提供钩子外，LSM框架还扩展了procfs虚拟文件系统（*/proc*），以包含每个进程和每个任务（线程）的安全属性，并增加了支持使用文件系统扩展属性作为持久化安全属性存储的功能。SELinux是第一个集成到Linux内核中的LSM模块，并从2.6版本开始正式提供（之前的SELinux实现是作为一组补丁发布的）。自SELinux集成以来，其他安全模块也已被接受到主线内核中，截至本文写作时，包括AppArmor、Smack和TOMOYO
    Linux等。这些模块提供了替代的MAC实现，并基于与SELinux不同的安全模型。
- en: We’ll explore the SELinux security model and architecture in the next sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探索SELinux的安全模型和架构。
- en: SELinux Architecture
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELinux架构
- en: 'While the SELinux architecture is quite complex, at a high level it consists
    of four main components: object managers (OM), an access vector cache (AVC), a
    security server, and a security policy, as shown in [Figure 12-1](ch12.html#selinux_components
    "Figure 12-1. SELinux components").'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SELinux架构相当复杂，但从高层次看，它由四个主要组件组成：对象管理器（OM）、访问向量缓存（AVC）、安全服务器和安全策略，如[图12-1](ch12.html#selinux_components
    "图12-1. SELinux组件")所示。
- en: When a subject asks to perform an action on an SELinux object (for example,
    when a process tries to read a file), the associated object manager queries the
    AVC to see if the attempted action is allowed. If the AVC contains a cached security
    decision for the request, the AVC returns it to the OM, which enforces the decision
    by allowing or denying the action (steps 1, 2, and 5 in [Figure 12-1](ch12.html#selinux_components
    "Figure 12-1. SELinux components")). If the cache does not contain a matching
    security decision, the AVC contacts the security server, which makes a security
    decision based on the currently loaded policy and returns it to the AVC, which
    caches it. The AVC in turn returns it to the OM, which ultimately enforces the
    decision (steps 1, 2, 3, 4, and 5 in [Figure 12-1](ch12.html#selinux_components
    "Figure 12-1. SELinux components")). The security server is part of the kernel,
    while the policy is loaded from userspace via a series of functions contained
    in the supporting userspace library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当主体请求对SELinux对象执行操作（例如，当一个进程尝试读取一个文件）时，相关的对象管理器会查询AVC，看看是否允许该操作。如果AVC中已经缓存了此请求的安全决策，AVC会将其返回给OM，OM根据该决策执行操作，允许或拒绝（如[图12-1](ch12.html#selinux_components
    "图12-1. SELinux组件")中的步骤1、2和5所示）。如果缓存中没有匹配的安全决策，AVC会联系安全服务器，安全服务器基于当前加载的策略做出安全决策，并将其返回给AVC，AVC将其缓存。然后AVC将决策返回给OM，OM最终执行该决策（如[图12-1](ch12.html#selinux_components
    "图12-1. SELinux组件")中的步骤1、2、3、4和5所示）。安全服务器是内核的一部分，而策略则通过一系列函数从用户空间加载，这些函数包含在支持的用户空间库中。
- en: '![SELinux components](figs/web/12fig01.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![SELinux组件](figs/web/12fig01.png.jpg)'
- en: Figure 12-1. SELinux components
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1. SELinux组件
- en: The OM and AVC can reside either in kernel space (when the OM is managing kernel-level
    objects) or userspace (when the OM is part of a so-called SELinux-aware application,
    which has built-in MAC support).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OM和AVC可以驻留在内核空间（当OM管理内核级对象时）或用户空间（当OM是所谓的SELinux感知应用程序的一部分时，该应用程序具有内置的MAC支持）。
- en: Mandatory Access Control
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制访问控制
- en: 'SELinux’s MAC model is based on three main concepts: subjects, objects, and
    actions. In this model, subjects are the active actors that perform actions on
    objects, and the action is carried out only if the security policy allows it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux的MAC模型基于三个主要概念：主体、对象和操作。在这个模型中，主体是执行操作的主动角色，对象是操作的目标，只有在安全策略允许的情况下，操作才会执行。
- en: In practice, subjects are usually running processes (a process can also be an
    object), and objects are OS-level resources managed by the kernel, such as files
    and sockets. Both subjects and objects have a set of security attributes (collectively
    known as the *security context*, discussed in the next section), which the OS
    queries in order to decide whether the requested action should be allowed or not.
    When SELinux is enabled, subjects cannot bypass or influence policy rules; therefore,
    the policy is mandatory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，主体通常是正在运行的进程（进程也可以是对象），而对象是由内核管理的操作系统级资源，例如文件和套接字。主体和对象都有一组安全属性（统称为 *安全上下文*，将在下一节讨论），操作系统查询这些属性来决定是否允许所请求的操作。当
    SELinux 启用时，主体不能绕过或影响策略规则；因此，策略是强制性的。  '
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意事项  '
- en: '*The MAC policy is only consulted if the DAC allows access to a resource. If
    the DAC denies access (for example, based on file permissions), the denial is
    taken as the final security decision.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*只有在 DAC 允许访问资源的情况下，才会咨询 MAC 策略。如果 DAC 拒绝访问（例如，基于文件权限），拒绝将作为最终安全决策。*'
- en: 'SELinux supports two forms of MAC: *type enforcement (TE)* and *multilevel
    security (MLS)*. MLS is typically used to enforce different levels of access to
    restricted information and is not used in Android. The type enforcement implemented
    in SELinux requires that all subjects and objects have an associated type and
    SELinux uses this type to enforce the rules of its security policy.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'SELinux 支持两种形式的 MAC：*类型强制（TE）* 和 *多级安全（MLS）*。MLS 通常用于强制对受限信息的不同访问级别，并且在 Android
    中不使用。SELinux 实现的类型强制要求所有主体和对象都有一个关联的类型，SELinux 使用此类型来执行其安全策略的规则。  '
- en: In SELinux, a *type* is simply a string that’s defined in the policy and associated
    with objects or subjects. Subject types reference processes or groups of processes
    and are also referred to as *domains*. Types referring to objects usually specify
    the role an object plays within the policy, such as system file, application data
    file, and so on. The type (or domain) is an integral part of the security context,
    as discussed in “[Security Contexts](ch12.html#security_contexts "Security Contexts")”
    below.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在 SELinux 中，*类型* 只是一个在策略中定义的字符串，与对象或主体相关联。主体类型指代进程或进程组，也称为 *域*。指代对象的类型通常指定对象在策略中的角色，例如系统文件、应用数据文件等。类型（或域）是安全上下文的重要组成部分，如下面的“[安全上下文](ch12.html#security_contexts
    "安全上下文")”所述。  '
- en: SELinux Modes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SELinux 模式  '
- en: 'SELinux has three modes of operation: disabled, permissive, and enforcing.
    When SELinux is disabled, no policy is loaded and only the default DAC security
    is enforced. In permissive mode, the policy is loaded and object access is checked,
    but access denial is only logged—not enforced. Finally, in enforcing mode, the
    security policy is both loaded and enforced, with violations logged.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'SELinux 有三种操作模式：禁用、宽容和强制。当 SELinux 被禁用时，未加载任何策略，仅执行默认的 DAC 安全性。在宽容模式下，策略被加载并检查对象访问，但拒绝访问仅被记录，而不执行。在强制模式下，安全策略既被加载又被强制执行，并且违规行为会被记录。  '
- en: In Android, the SELinux mode can be checked and changed with the `getenforce`
    and `setenforce` commands, as shown in [Example 12-1](ch12.html#using_the_getenforceandsetenforcecommand
    "Example 12-1. Using the getenforce and setenforce commands"). However, the mode
    set with `setenforce` is not persistent and will be reset to the default mode
    when the device reboots.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Android 中，可以使用 `getenforce` 和 `setenforce` 命令检查和更改 SELinux 模式，如 [示例 12-1](ch12.html#using_the_getenforceandsetenforcecommand
    "示例 12-1. 使用 getenforce 和 setenforce 命令") 所示。但是，使用 `setenforce` 设置的模式不是持久的，设备重启时会恢复为默认模式。  '
- en: Example 12-1. Using the *getenforce and setenforce commands*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 12-1. 使用 *getenforce 和 setenforce 命令*  '
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Additionally, even when SELinux is in enforcing mode, the policy can specify
    permissive mode per domain (process) using the `permissive` statement. (See “[Object
    Class and Permission Statements](ch12.html#object_class_and_permission_statements
    "Object Class and Permission Statements")” for an example.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，即使 SELinux 处于强制模式，策略仍可以使用 `permissive` 语句为每个域（进程）指定宽容模式。（参见“[对象类和权限语句](ch12.html#object_class_and_permission_statements
    "对象类和权限语句")”了解示例。）  '
- en: Security Contexts
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '安全上下文  '
- en: 'In SELinux, a *security context* (also referred to as a *security label*, or
    just *label*) is a string with four fields delimited with colons: username, role,
    type, and an optional MLS security range. An SELinux username is typically associated
    with a group or class of users; for example, *user_u* for unprivileged users and
    *admin_u* for administrators.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 中，*安全上下文*（也称为 *安全标签*，或简称 *标签*）是一个由四个字段组成的字符串，用冒号分隔：用户名、角色、类型和一个可选的
    MLS 安全范围。SELinux 用户名通常与用户组或用户类别相关联；例如，*user_u* 表示非特权用户，*admin_u* 表示管理员。
- en: Users can be associated with one or more roles in order to implement role-based
    access control, where each role is associated with one or more domain types. The
    type is used to group processes in a domain or to specify an object logical type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以与一个或多个角色关联，以实现基于角色的访问控制，每个角色都与一个或多个域类型关联。该类型用于将进程分组到某个域中，或者指定对象的逻辑类型。
- en: The security range (or level) is used to implement MLS and specifies the security
    levels a subject is allowed to access. As of this writing, Android only uses the
    type field of the security context, and the user and security range are always
    set to *u* and *s0*. The role is set to either *r* for domains (processes) or
    to the built-in *object_r* role for objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安全范围（或级别）用于实现 MLS，并指定主体允许访问的安全级别。截至目前，Android 只使用安全上下文的类型字段，而用户和安全范围始终设置为 *u*
    和 *s0*。角色设置为 *r*（用于域，即进程）或内置的 *object_r* 角色（用于对象）。
- en: The security context of processes can be displayed by specifying the `-Z` option
    to the `ps` command, as shown in [Example 12-2](ch12.html#process_security_contexts_in_android
    "Example 12-2. Process security contexts in Android") (in the `LABEL` column).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 `ps` 命令指定 `-Z` 选项，可以显示进程的安全上下文，如在[示例 12-2](ch12.html#process_security_contexts_in_android
    "示例 12-2. 进程安全上下文")中所示（在 `LABEL` 列中）。
- en: Example 12-2. Process security contexts in Android
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-2. 在 Android 中处理进程安全上下文
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly, the context of files can be viewed by passing the `-Z` to the `ls`
    command, as shown in [Example 12-3](ch12.html#file_and_directory_security_contexts_in
    "Example 12-3. File and directory security contexts in Android").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以通过将 `-Z` 参数传递给 `ls` 命令来查看文件的上下文，如在[示例 12-3](ch12.html#file_and_directory_security_contexts_in
    "示例 12-3. 文件和目录安全上下文")中所示。
- en: Example 12-3. File and directory security contexts in Android
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-3. 文件和目录安全上下文在 Android 中的应用
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Security Context Assignment and Persistence
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全上下文分配与持久化
- en: We’ve established that all subject and objects have a security context, but
    how is the context assigned and persisted? For objects (which are usually associated
    with a file on the filesystem), the security context is persistent and is usually
    stored as an extended attribute in the file’s metadata.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定所有的主体和对象都有一个安全上下文，那么这个上下文是如何分配和持久化的呢？对于对象（通常与文件系统中的文件关联），安全上下文是持久的，通常存储为文件元数据中的扩展属性。
- en: Extended attributes are not interpreted by the filesystem and can contain arbitrary
    data (though any such data is usually limited in size). The *ext4* filesystem,
    the default in most Linux distributions and current versions of Android, supports
    extended attributes in the form of name-value pairs, where the name is a null-terminated
    string. SELinux uses the *security.selinux* name to store the security context
    of file objects. The security context of objects can be set explicitly as part
    of a filesystem initialization (also called *labeling*), or be implicitly assigned
    when an object is created. Objects typically inherit the type label of their parent
    (for example, newly created files in a directory inherit the label of the directory).
    However, if the security policy allows, objects can receive a label that’s different
    from that of their parent, a process referred to as *type transition*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性不由文件系统解释，可以包含任意数据（尽管这些数据的大小通常是有限制的）。*ext4* 文件系统（大多数 Linux 发行版和当前版本的 Android
    的默认文件系统）支持以名称-值对形式的扩展属性，其中名称是一个以空字符结尾的字符串。SELinux 使用 *security.selinux* 名称来存储文件对象的安全上下文。对象的安全上下文可以作为文件系统初始化的一部分显式设置（也称为
    *标签化*），或者在对象创建时隐式分配。对象通常继承其父对象的类型标签（例如，目录中新创建的文件继承目录的标签）。但是，如果安全策略允许，对象可以获得与其父对象不同的标签，这一过程被称为
    *类型转换*。
- en: Like objects, subjects (processes) inherit the security context of their parent
    process, or they can change their context via *domain transition*, if allowed
    by the security policy. The policy can specify automatic domain transition as
    well, which automatically sets the domain of newly started processes based on
    the domain of their parent and the type of the executed binary. For example, because
    all system daemons are started by the *init* process, which has the *u:r:init:s0*
    security context (➊ in [Example 12-2](ch12.html#process_security_contexts_in_android
    "Example 12-2. Process security contexts in Android")), they would normally inherit
    this context, but Android’s SELinux policy uses automatic domain transitions to
    set a dedicated domain to each daemon as needed (➋, ➌, and ➍ in [Example 12-2](ch12.html#process_security_contexts_in_android
    "Example 12-2. Process security contexts in Android")).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象一样，主体（进程）会继承其父进程的安全上下文，或者如果安全策略允许的话，它们可以通过 *域转换* 来改变自己的上下文。策略还可以指定自动域转换，这会根据父进程的域和已执行二进制文件的类型自动设置新启动进程的域。例如，由于所有系统守护进程都是由
    *init* 进程启动的，而 *init* 进程的安全上下文是 *u:r:init:s0*（➊ 在 [示例 12-2](ch12.html#process_security_contexts_in_android
    "示例 12-2. Android 中的进程安全上下文") 中），这些进程通常会继承此上下文，但 Android 的 SELinux 策略使用自动域转换，根据需要为每个守护进程设置专用域（➋、➌
    和 ➍ 在 [示例 12-2](ch12.html#process_security_contexts_in_android "示例 12-2. Android
    中的进程安全上下文") 中）。
- en: Security Policy
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全策略
- en: The SELinux security policy is used by the security server in the kernel to
    allow or disallow access to kernel objects at runtime. For performance reasons,
    the policy is typically in a binary form generated by compiling a number of policy
    source files. The policy source files are written in a dedicated policy language,
    which consists of statements and rules. *Statements* define policy entities such
    as types, users, and roles. *Rules* allow or deny access to objects (access vector
    rules); specify the type of transitions allowed (type enforcement rules); and
    designate how default users, roles, and types are assigned (default rules). A
    thorough discussion of SELinux’s policy grammar is beyond the scope of this book,
    but the following sections will introduce some of the most widely used statements
    and rules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 安全策略由内核中的安全服务器使用，用于在运行时允许或拒绝访问内核对象。为了提高性能，策略通常以二进制形式存在，这是通过编译多个策略源文件生成的。策略源文件使用专门的策略语言编写，该语言由语句和规则组成。*语句*定义了策略实体，如类型、用户和角色。*规则*允许或拒绝访问对象（访问向量规则）；指定允许的类型转换（类型强制规则）；并指定如何分配默认用户、角色和类型（默认规则）。对
    SELinux 策略语法的详细讨论超出了本书的范围，但以下部分将介绍一些最常用的语句和规则。
- en: Policy Statements
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略语句
- en: The SELinux policy language supports various types of statements, but type,
    attribute, and permission statements make up the bulk of a security policy. We
    introduce these three types of statements in the following sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略语言支持各种类型的语句，但类型、属性和权限语句构成了安全策略的主要部分。我们将在以下部分介绍这三种类型的语句。
- en: Type and Attribute Statements
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型和属性语句
- en: '`type` and `attribute` statements declare types and their attributes, as shown
    in [Example 12-4](ch12.html#type_and_attribute_statements-id00028 "Example 12-4. type
    and attribute statements").'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 和 `attribute` 语句声明了类型及其属性，如 [示例 12-4](ch12.html#type_and_attribute_statements-id00028
    "示例 12-4. 类型和属性语句") 所示。'
- en: Example 12-4. `type` and `attribute statements`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-4. `type` 和 `attribute` 语句
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the first ➊ and second ➋ statements declare the `file_type` and `domain`
    attributes, and the next statement ➌ declares the `system_data_file` type and
    associates it with the `file_type` and `data_file_type` attributes. The code at
    ➍ declares the `untrusted_app` type and associates it with the `domain` attribute
    (which marks all types used for processes).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一条 ➊ 和第二条 ➋ 声明了 `file_type` 和 `domain` 属性，接下来的语句 ➌ 声明了 `system_data_file`
    类型，并将其与 `file_type` 和 `data_file_type` 属性关联。第四行代码 ➍ 声明了 `untrusted_app` 类型，并将其与
    `domain` 属性关联（该属性标记了所有用于进程的类型）。
- en: Depending on its granularity, an SELinux policy can have dozens or even hundreds
    of type and attribute declarations spread across multiple source files. However,
    because access to all kernel objects needs to be checked against the policy at
    runtime, a large policy can have a negative impact on performance. The effect
    on performance is especially apparent when running on devices with limited computing
    resources, and that is why Android strives to keep its SELinux policy relatively
    small.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据粒度的不同，SELinux 策略可能包含数十个甚至数百个类型和属性声明，这些声明分布在多个源文件中。然而，由于需要在运行时对所有内核对象进行策略检查，大型策略可能会对性能产生负面影响。特别是在计算资源有限的设备上运行时，性能影响尤为明显，这也是
    Android 力求保持 SELinux 策略相对简小的原因。
- en: User and Role Statements
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户和角色声明
- en: The `user` statement declares an SELinux user identifier, associates it with
    its role(s), and optionally specifies its default security level and the range
    of security levels that the user can access. [Example 12-5](ch12.html#declarations_of_the_default_selinux_user
    "Example 12-5. Declarations of the default SELinux user identifier in Android")
    shows the declarations of the default and only user identifier in Android.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 声明定义了一个 SELinux 用户标识符，将其与角色关联，并可选地指定其默认安全级别和用户可以访问的安全级别范围。[示例 12-5](ch12.html#declarations_of_the_default_selinux_user
    "Example 12-5. Declarations of the default SELinux user identifier in Android")
    显示了 Android 中默认的唯一用户标识符声明。'
- en: Example 12-5. Declarations of the default SELinux user identifier in Android
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-5. Android 中默认 SELinux 用户标识符的声明
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in [Example 12-5](ch12.html#declarations_of_the_default_selinux_user
    "Example 12-5. Declarations of the default SELinux user identifier in Android"),
    the *u* user is associated with the *r* role (inside the braces), which in turn
    is declared using the `role` statement ➊ as shown in [Example 12-6](ch12.html#declaration_of_the_default_selinux_role
    "Example 12-6. Declaration of the default SELinux role in Android").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[示例 12-5](ch12.html#declarations_of_the_default_selinux_user "Example 12-5.
    Declarations of the default SELinux user identifier in Android")中看到的，*u* 用户与 *r*
    角色（大括号内）关联，后者通过 `role` 声明 ➊ 进行声明，如[示例 12-6](ch12.html#declaration_of_the_default_selinux_role
    "Example 12-6. Declaration of the default SELinux role in Android")所示。
- en: Example 12-6. Declaration of the default SELinux role in Android
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-6. Android 中默认 SELinux 角色的声明
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second statement ➋ associates the *r* role with the `domain` attribute,
    which marks it as a role assigned to processes (domains).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个声明 ➋ 将 *r* 角色与 `domain` 属性关联，这标记它为分配给进程（域）的角色。
- en: Object Class and Permission Statements
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象类和权限声明
- en: The `permissive` statement allows a named domain to run in permissive mode (a
    mode that only logs MAC policy violations but doesn’t actually enforce the policy,
    as discussed next), even if SELinux is running in enforcing mode. As we will see
    in “[Enforcing Domains](ch12.html#enforcing_domains "Enforcing Domains")”, most
    domains in Android’s current base policy are permissive. For example, processes
    in the *adbd* domain (in practice *adbd* daemon processes) run in permissive mode,
    as shown in [Example 12-7](ch12.html#setting_a_named_domain_to_permissive_mod
    "Example 12-7. Setting a named domain to permissive mode") ➊.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`permissive` 声明允许一个命名域以宽松模式运行（该模式仅记录 MAC 策略违规，但不实际强制执行该策略，后续将讨论），即使 SELinux
    正在强制模式下运行。如我们将在“[强制域](ch12.html#enforcing_domains "Enforcing Domains")”中看到的那样，Android
    当前基础策略中的大多数域都是宽松模式。例如，*adbd* 域中的进程（实际上是 *adbd* 守护进程）以宽松模式运行，如[示例 12-7](ch12.html#setting_a_named_domain_to_permissive_mod
    "Example 12-7. Setting a named domain to permissive mode") ➊ 所示。'
- en: Example 12-7. Setting a named domain to permissive mode
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-7. 将命名域设置为宽松模式
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `class` statement defines an SELinux object class, as shown in [Example 12-8](ch12.html#object_class_declarations_in_the_securit
    "Example 12-8. Object class declarations in the security_classes file"). Object
    classes and their associated permissions are determined by the respective object
    manager implementations in the Linux kernel, and are static within a policy. Object
    classes are usually defined in the *security_classes* policy source file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 声明定义了一个 SELinux 对象类，如[示例 12-8](ch12.html#object_class_declarations_in_the_securit
    "Example 12-8. Object class declarations in the security_classes file") 所示。对象类及其相关权限由
    Linux 内核中各自的对象管理器实现来确定，并在策略中保持静态。对象类通常定义在 *security_classes* 策略源文件中。'
- en: Example 12-8. Object class declarations in the security_classes *file*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-8. 安全类 *文件* 中的对象类声明
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: SELinux permissions (also referred to as *access vectors*) are usually defined
    and associated with object classes in a policy source file called *access_vectors*.
    Permissions can be either class-specific (defined with the `class` keyword) or
    inheritable by one or more object classes, in which case they’re defined with
    the `common` keyword. [Example 12-9](ch12.html#permission_definitions_in_the_accessunde
    "Example 12-9. Permission definitions in the access_vectors file") shows the definition
    of the set of permissions common to all file objects ➊, and the association of
    the `dir` class (which represents directories) with all common file permissions
    (using the `inherits` keyword), and a set of directory-specific permissions (*add_name*,
    *remove_name*, and so on) ➋.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 权限（也称为 *访问向量*）通常在名为 *access_vectors* 的策略源文件中定义并与对象类关联。权限可以是特定类的（使用 `class`
    关键字定义）或可被一个或多个对象类继承的，在这种情况下，它们使用 `common` 关键字定义。[示例 12-9](ch12.html#permission_definitions_in_the_accessunde
    "Example 12-9. Permission definitions in the access_vectors file") 显示了所有文件对象共享的权限集的定义
    ➊，以及 `dir` 类（表示目录）与所有通用文件权限的关联（使用 `inherits` 关键字），以及一组特定于目录的权限（*add_name*、*remove_name*
    等） ➋。
- en: Example 12-9. Permission definitions in the access_vectors file
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-9. 访问向量文件中的权限定义
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Type Transition Rules
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型过渡规则
- en: 'Type enforcement rules and access vector rules (discussed in “[Domain Transition
    Rules](ch12.html#domain_transition_rules "Domain Transition Rules")” and “[Access
    Vector Rules](ch12.html#access_vector_rules "Access Vector Rules")”) typically
    make the bulk of an SELinux policy. In turn, the most commonly used type of enforcement
    rule is the `type_transition` rule, which specifies when domain and type transitions
    are allowed. For example, the *wpa_supplicant* daemon, which manages Wi-Fi connections
    in Android, uses the type transition rule shown in [Example 12-10](ch12.html#type_transitions_in_the_wpa_domain_left
    "Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)")
    at ➍ in order to associate the control sockets it creates in the */data/misc/wifi/*
    directory with the `wpa_socket` type. In the absence of this rule, the sockets
    would inherit the type of their parent directory: `wifi_data_file`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类型强制规则和访问向量规则（在“[域过渡规则](ch12.html#domain_transition_rules "Domain Transition
    Rules")”和“[访问向量规则](ch12.html#access_vector_rules "Access Vector Rules")”中讨论）通常构成
    SELinux 策略的主要部分。反过来，最常用的类型强制规则是`type_transition`规则，它指定了何时允许域和类型的过渡。例如，管理 Android
    中 Wi-Fi 连接的 *wpa_supplicant* 守护进程，使用了在 [示例 12-10](ch12.html#type_transitions_in_the_wpa_domain_left
    "Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)")
    中显示的类型过渡规则 ➍，该规则将它在 */data/misc/wifi/* 目录中创建的控制套接字与 `wpa_socket` 类型关联起来。如果没有这个规则，这些套接字将继承它们父目录的类型：`wifi_data_file`。
- en: Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-10. wpa 域中的类型过渡（来自 wpa_supplicant.te）
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `wpa`, `wifi_data_file:sock_file`, and `wpa_socket` are the source type
    (in this case, the domain of the *wpa_supplicant* process), the target type and
    class (the type and class of the object before the transition), and the type of
    the object after the transition, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`wpa`、`wifi_data_file:sock_file` 和 `wpa_socket` 分别是源类型（在此案例中是 *wpa_supplicant*
    进程的域）、目标类型和类（过渡前对象的类型和类）以及过渡后的对象类型。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In order to be able to create the socket file and change its label, the `wpa`
    domain needs additional permissions on the parent directory and the socket file
    itself—the `type_transition` rule alone is not sufficient. However, because the
    `wpa` domain is both permissive* ➊ *and unconfined (granted most permissions by
    default)* ➌*, the transition is allowed without explicitly allowing each required
    permission.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了能够创建套接字文件并更改其标签，`wpa` 域需要在父目录和套接字文件本身上拥有额外的权限——仅有 `type_transition` 规则是不够的。然而，由于
    `wpa` 域既是宽松的* ➊ *又是不受限制的（默认授予大多数权限）* ➌*，因此可以在不显式允许每个所需权限的情况下完成过渡。*'
- en: Domain Transition Rules
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域过渡规则
- en: In Android, native system daemons like *wpa_supplicant* are started by the *init*
    process, and therefore inherit its security context by default. However, most
    daemons are associated with a dedicated domain and use domain transitions to switch
    their domain when started. This is typically accomplished using the `init_daemon_domain()`
    macro (➋ in [Example 12-10](ch12.html#type_transitions_in_the_wpa_domain_left
    "Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)")),
    which under the hood is implemented using the `type_transition` keyword, just
    like type transitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，像 *wpa_supplicant* 这样的本地系统守护进程由 *init* 进程启动，因此默认情况下继承其安全上下文。然而，大多数守护进程都与一个专用域相关联，并使用域转换在启动时切换其域。这通常通过使用
    `init_daemon_domain()` 宏（[示例 12-10](ch12.html#type_transitions_in_the_wpa_domain_left
    "示例 12-10. 在 wpa 域中的类型转换（来自 wpa_supplicant.te）") 中的 ➋）来实现，其内部通过使用 `type_transition`
    关键字实现，就像类型转换一样。
- en: 'The binary SELinux policy build process uses the `m4` macro preprocessor^([[132](#ftn.ch12fn01)])
    to expand macros before merging all source files in order to create the binary
    policy file. The `init_daemon_domain()` macro takes one parameter (the new domain
    of the process) and is defined in the *te_macros* file using two other macros:
    `domain_trans()` and `domain_auto_trans()`, which are used to allow transition
    to a new domain and to execute the transition automatically, respectively. [Example 12-11](ch12.html#domain_transition_macros_definition_in_t
    "Example 12-11. Domain transition macros definition in the te_macros file") shows
    the definitions of these three macros (➊, ➋, and ➌). The lines beginning with
    the `allow` keyword are access vector (AV) rules, which we discuss in the next
    section.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制 SELinux 策略构建过程使用 `m4` 宏预处理器^([[132](#ftn.ch12fn01)]) 在合并所有源文件之前展开宏，以创建二进制策略文件。`init_daemon_domain()`
    宏接受一个参数（进程的新域），并在 *te_macros* 文件中使用两个其他宏定义：`domain_trans()` 和 `domain_auto_trans()`，分别用于允许转换到新域和自动执行转换。[示例
    12-11](ch12.html#domain_transition_macros_definition_in_t "示例 12-11. 在 te_macros
    文件中定义的域转换宏")展示了这三个宏的定义（➊、➋ 和 ➌）。以 `allow` 关键字开头的行是访问向量（AV）规则，我们将在下一节中讨论。
- en: Example 12-11. Domain transition macros definition in the te_macros `file`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-11. 在 te_macros `文件` 中定义的域转换宏
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Access Vector Rules
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问向量规则
- en: AV rules define what privileges processes have at runtime by specifying the
    set of permissions they have over their target objects. [Example 12-12](ch12.html#format_of_av_rules
    "Example 12-12. Format of AV rules") shows the general format of an AV rule.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: AV 规则通过指定进程在运行时对其目标对象的权限集，定义了进程所具有的特权。[示例 12-12](ch12.html#format_of_av_rules
    "示例 12-12. AV 规则的格式")展示了 AV 规则的一般格式。
- en: Example 12-12. Format of AV rules
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-12. AV 规则的格式
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `rule_name` can be `allow`, `dontaudit`, `auditallow`, or `neverallow`.
    To form a rule, the `source_type` and `target_type` elements are replaced with
    one or more previously defined `type` or `attribute` identifiers, where `source_type`
    is the identifier of a subject (process), and `target_type` is the identifier
    of an object the process is trying to access. The `class` element is replaced
    with the object class of the target, and `perm_set` specifies the set of permissions
    that the source process has over the target object. You can specify multiple types,
    classes, and permissions by enclosing them in braces (`{}`). In addition, some
    rules support use of the wildcard (`*`) and complement (`~`) operators, which
    allow you to specify that all types should be included or that all types except
    those explicitly listed should be included, respectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`rule_name` 可以是 `allow`、`dontaudit`、`auditallow` 或 `neverallow`。要形成一个规则，`source_type`
    和 `target_type` 元素会被一个或多个先前定义的 `type` 或 `attribute` 标识符替换，其中 `source_type` 是主体（进程）的标识符，`target_type`
    是进程尝试访问的目标对象的标识符。`class` 元素会被目标的对象类别替换，`perm_set` 指定了源进程对目标对象拥有的权限集。你可以通过将它们包围在大括号（`{}`）中来指定多个类型、类别和权限。此外，一些规则支持使用通配符（`*`）和补集（`~`）运算符，分别允许你指定应包含所有类型或应包含所有类型，除了那些明确列出的类型。'
- en: allow Rules
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: allow 规则
- en: The most commonly used rule is `allow`, which specifies the operations that
    a subject (process) of the specified source type is allowed to perform on an object
    of the target type and class specified in the rule. Let’s take the SELinux policy
    for the *vold* daemon (see [Example 12-13](ch12.html#allow_rules_for_the_vold_domain_left_par
    "Example 12-13. allow rules for the vold domain (from vold.te)")) as an example
    to illustrate how to use the `allow` rule.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的规则是 `allow`，它指定了指定源类型的主体（进程）可以对目标类型和类的对象执行的操作。以 *vold* 守护进程的 SELinux 策略为例（参见
    [示例 12-13](ch12.html#allow_rules_for_the_vold_domain_left_par "示例 12-13. `allow`
    规则用于 `vold` 域（来自 vold.te）")），我们来说明如何使用 `allow` 规则。
- en: Example 12-13. `allow` rules for the `vold` domain (from vold.te)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-13. `allow` 规则用于 `vold` 域（来自 vold.te）
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this listing, rule ➊ allows the *vold* daemon (which runs in the `vold` domain)
    to mount, unmount, and remount filesystems of type `sdcard_type`. Rule ➋ allows
    the daemon to use the `CAP_SYS_PTRACE` (which allows `ptrace()` to be called on
    any process) and `CAP_KILL` (which allows signals to be sent to any process) Linux
    capabilities, which correspond to the permission set specified in the rule (inside
    the `{}`). In rule ➋, the `self` keyword means that the target domain is the same
    as the source, which in this case is `vold`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列出规则的示例中，规则 ➊ 允许 *vold* 守护进程（在 `vold` 域中运行）挂载、卸载和重新挂载类型为 `sdcard_type` 的文件系统。规则
    ➋ 允许该守护进程使用 `CAP_SYS_PTRACE`（允许对任何进程调用 `ptrace()`）和 `CAP_KILL`（允许向任何进程发送信号）Linux
    能力，这些能力与规则中指定的权限集（位于 `{}` 内）相对应。在规则 ➋ 中，`self` 关键字表示目标域与源域相同，在此例中是 `vold`。
- en: auditallow Rules
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: auditallow 规则
- en: The `auditallow` rule is used with `allow` to record audit events when an operation
    is allowed. This is useful because by default, SELinux logs only access denied
    events. However, `auditallow` itself doesn’t grant access, and therefore a matching
    `allow` rule must be used in order to grant the necessary permissions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`auditallow` 规则与 `allow` 配合使用，以便在操作被允许时记录审计事件。这很有用，因为默认情况下，SELinux 仅记录访问被拒绝的事件。然而，`auditallow`
    本身并不授予访问权限，因此必须使用匹配的 `allow` 规则来授予必要的权限。'
- en: dontaudit Rules
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dontaudit 规则
- en: The `dontaudit` rule is used to suppress the auditing of denial messages when
    a specified event is known to be safe. For example, the rule at ➊ in [Example 12-14](ch12.html#dontaudit_rule_for_the_installd_domain_l
    "Example 12-14. dontaudit rule for the installd domain (from installd.te)") specifies
    that no audit log be created if the *installd* daemon is denied the `CAP_SYS_ADMIN`
    capability. However, `dontaudit` rules can mask program errors and the use of
    `dontaudit` is discouraged.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`dontaudit` 规则用于抑制当已知某个事件是安全时，拒绝消息的审计。例如，[示例 12-14](ch12.html#dontaudit_rule_for_the_installd_domain_l
    "示例 12-14. `dontaudit` 规则用于 installd 域（来自 installd.te）") 中的规则 ➊ 指定如果 *installd*
    守护进程被拒绝 `CAP_SYS_ADMIN` 能力，则不创建审计日志。然而，`dontaudit` 规则可能会掩盖程序错误，因此不建议使用 `dontaudit`。'
- en: Example 12-14. `dontaudit` rule for the installd domain (from installd.te)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-14. `dontaudit` 规则用于 installd 域（来自 installd.te）
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: neverallow Rules
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: neverallow 规则
- en: The `neverallow` rule says that the declared operation should never be allowed,
    even if an explicit `allow` rule that allows it exists. For example, the rule
    shown in [Example 12-15](ch12.html#neverallow_rule_that_forbids_domains_oth "Example 12-15. neverallow
    rule that forbids domains other than init from loading the SELinux policy (from
    domain.te)") forbids all domains but the `init` domain to load the SELinux policy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`neverallow` 规则表示即使存在显式的 `allow` 规则允许某个操作，也永远不允许执行该操作。例如，[示例 12-15](ch12.html#neverallow_rule_that_forbids_domains_oth
    "示例 12-15. `neverallow` 规则禁止除 init 以外的所有域加载 SELinux 策略（来自 domain.te）") 中的规则禁止了除
    `init` 域外的所有域加载 SELinux 策略。'
- en: Example 12-15. `neverallow` rule that forbids domains other than init from loading
    the SELinux policy (from domain.te)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-15. `neverallow` 规则禁止除 init 以外的所有域加载 SELinux 策略（来自 domain.te）
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This section provides only a brief overview of SELinux, focusing on the features
    used in Android. For a more detailed discussion of the architecture and implementation
    of SELinux, as well its policy language, see the* SELinux Notebook.^([[133](#ftn.ch12fn02)])'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节仅简要概述了 SELinux，重点讨论了在 Android 中使用的功能。如需更详细的 SELinux 架构和实现讨论，以及其策略语言，请参见*
    SELinux Notebook.^([[133](#ftn.ch12fn02)])'
- en: Android Implementation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 实现
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model")
    and [Chapter 2](ch02.html "Chapter 2. Permissions"), Android’s sandboxing security
    model relies heavily on the use of separate Linux UIDs for system daemons and
    applications. Process isolation and access control is ultimately enforced by the
    Linux kernel based on process UID and GIDs. Because SELinux is also part of the
    Linux kernel, SELinux is a natural candidate for hardening the Android sandboxing
    model using a MAC policy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html "第 1 章. Android 的安全模型") 和 [第 2 章](ch02.html "第 2 章. 权限")
    中所讨论的，Android 的沙箱安全模型在很大程度上依赖于为系统守护进程和应用程序使用不同的 Linux UID。进程隔离和访问控制最终由 Linux 内核基于进程的
    UID 和 GID 强制执行。由于 SELinux 也是 Linux 内核的一部分，因此 SELinux 是使用 MAC 策略加强 Android 沙箱模型的自然候选者。
- en: 'As SELinux is integrated into the mainline Linux kernel, it would seem that
    enabling it in Android should be a simple matter of configuring the kernel and
    designing an appropriate MAC policy. However, because Android introduces some
    unique extensions to the Linux kernel and its userspace structure is quite different
    from that of desktop and server Linux distributions, several changes in both kernel
    and userspace were needed in order to integrate and enable SELinux into Android.
    While the initial work required to integrate SELinux was started by Google, most
    of the required changes were implemented in the Security Enhancements for Android
    project (formally Security-Enhanced Android, or SEAndroid),^([[134](#ftn.ch12fn03)])
    and were later integrated into the mainline Android source tree. The following
    sections survey these major changes. For a comprehensive list of changes and the
    rationale behind them, see the *Security Enhanced (SE) Android: Bringing Flexible
    MAC to Android* paper by the original authors of the SEAndroid project.^([[135](#ftn.ch12fn04)])'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 SELinux 已集成到主线 Linux 内核中，看起来在 Android 中启用它应该只是配置内核和设计适当的 MAC 策略的简单问题。然而，由于
    Android 对 Linux 内核引入了一些独特的扩展，并且其用户空间结构与桌面和服务器 Linux 发行版的结构大不相同，因此需要对内核和用户空间进行多次修改，以便将
    SELinux 集成并启用到 Android 中。虽然将 SELinux 集成的初步工作由 Google 启动，但大多数所需的更改是在 Android 安全增强项目（正式名称为安全增强
    Android，或 SEAndroid）中实现的，并且后来被集成到主线 Android 源代码树中。以下部分将概述这些主要更改。有关更改的详细列表及其背后的理由，请参见
    SEAndroid 项目原作者所撰写的论文 *Security Enhanced (SE) Android: Bringing Flexible MAC to
    Android*。'
- en: Kernel Changes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核更改
- en: Recall from earlier that SELinux is a security module that implements the various
    LSM hooks inserted in kernel services related to object access control. Android’s
    Binder IPC mechanism is also implemented as a kernel driver, but because its implementation
    originally did not contain any LSM hooks, its runtime behavior could not be controlled
    by an SELinux policy. In order to add SELinux support to Binder, LSM hooks were
    inserted into the Binder driver, and support for the `binder` object class and
    related permissions was added to SELinux code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，SELinux 是一个安全模块，实现在与对象访问控制相关的内核服务中插入的各种 LSM 钩子。Android 的 Binder IPC 机制也作为内核驱动实现，但由于其最初的实现并未包含任何
    LSM 钩子，其运行时行为无法通过 SELinux 策略进行控制。为了将 SELinux 支持添加到 Binder 中，LSM 钩子被插入到 Binder
    驱动程序中，并且 `binder` 对象类及相关权限的支持被添加到 SELinux 代码中。
- en: SELinux security hooks are declared in *include/linux/security.h*, and [Example 12-16](ch12.html#binder_security_hooks_declarations_in_in
    "Example 12-16. Binder security hooks declarations in include/linux/security.h")
    shows the Binder-related declarations added to support Android.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 安全钩子在 *include/linux/security.h* 中声明，[示例 12-16](ch12.html#binder_security_hooks_declarations_in_in
    "示例 12-16. 在 include/linux/security.h 中声明的 Binder 安全钩子") 显示了为支持 Android 而添加的与
    Binder 相关的声明。
- en: Example 12-16. Binder security hooks declarations in include/linux/security.h
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-16. 在 include/linux/security.h 中声明的 Binder 安全钩子
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first hook ➊ controls what process can become the binder context manager,
    and the second one ➋ controls the ability of a process to invoke a binder transaction.
    The next two functions are used to regulate who can transfer a Binder reference
    to another process ➌, and transfer an open file to another process ➍ using Binder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个钩子 ➊ 控制哪个进程可以成为 Binder 上下文管理器，第二个钩子 ➋ 控制一个进程调用 Binder 事务的能力。接下来的两个函数用于调节谁可以将
    Binder 引用传递给另一个进程 ➌，以及通过 Binder 将打开的文件传递给另一个进程 ➍。
- en: In order to allow the SELinux policy to set restrictions for Binder, support
    for the `binder` object class and its permissions (`impersonate`, `call`, `set_context_mgr`,
    and `transfer`) was also added to the kernel, as shown in [Example 12-17](ch12.html#binder_object_class_and_permission_decla
    "Example 12-17. Binder object class and permission declaration in selinux/include/classmap.h").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许 SELinux 策略为 Binder 设置限制，内核中还添加了对 `binder` 对象类及其权限（`impersonate`、`call`、`set_context_mgr`
    和 `transfer`）的支持，具体如 [示例 12-17](ch12.html#binder_object_class_and_permission_decla
    "示例 12-17. Binder 对象类和权限声明在 selinux/include/classmap.h") 所示。
- en: Example 12-17. Binder object class and permission declaration in selinux/include/classmap.h
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-17。selinux/include/classmap.h 中的 Binder 对象类和权限声明
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Userspace Changes
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户空间更改
- en: In addition to kernel changes, a number of userspace modifications and extensions
    were also required in order to integrate SELinux into Android. Among these, the
    most important ones are support for filesystem labeling in the core C library
    (bionic); extensions to *init* and the core native daemons and executables; framework-level
    SELinux APIs; and modifications to core framework services to make them SELinux-aware.
    This section describes each change and how it’s integrated into the Android runtime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内核更改外，还需要进行许多用户空间修改和扩展，才能将 SELinux 集成到 Android 中。其中最重要的更改包括：核心 C 库（bionic）对文件系统标签的支持；*init*
    以及核心本地守护进程和可执行文件的扩展；框架级别的 SELinux API；以及对核心框架服务的修改，使其能够识别 SELinux。本节将描述每个更改以及它是如何集成到
    Android 运行时中的。
- en: Libraries and Tools
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库和工具
- en: Because SELinux uses extended attributes to store the security contexts of filesystem
    objects, wrapper functions for the system calls used to manage extended attributes
    (`listxattr()`, `getxattr()`, `setxattr()`, and so on) were first added to Android’s
    C library in order to be able to get and set the security labels of files and
    directories.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 SELinux 使用扩展属性来存储文件系统对象的安全上下文，所以首先将用于管理扩展属性（`listxattr()`、`getxattr()`、`setxattr()`
    等）的系统调用的包装函数添加到了 Android 的 C 库中，以便能够获取和设置文件和目录的安全标签。
- en: In order to be able to take advantage of SELinux features from user-space, SEAndroid
    added an Android-compatible port of the *libselinux* library, as well as a set
    of utility commands to manage labeling, the security policy, and to switch the
    SELinux mode between enforcing and permissive. Like most Android command-line
    utilities, SELinux tools are implemented in the `toolbox` binary and are installed
    as symbolic links to it. [Table 12-1](ch12.html#selinux_command-line_utilities
    "Table 12-1. SELinux Command-Line Utilities") summarizes the added or modified
    command-line tools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从用户空间利用 SELinux 的功能，SEAndroid 添加了一个兼容 Android 的 *libselinux* 库移植版本，以及一组用于管理标签、安全策略，并在强制模式和宽松模式之间切换的实用命令。像大多数
    Android 命令行工具一样，SELinux 工具实现于 `toolbox` 二进制文件中，并作为其符号链接进行安装。[表 12-1](ch12.html#selinux_command-line_utilities
    "表 12-1. SELinux 命令行工具") 总结了添加或修改的命令行工具。
- en: Table 12-1. SELinux Command-Line Utilities
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1。SELinux 命令行工具
- en: '| Command | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `chcon` | Changes a file’s security context |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `chcon` | 更改文件的安全上下文 |'
- en: '| `getenforce` | Gets the current SELinux mode |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `getenforce` | 获取当前的 SELinux 模式 |'
- en: '| `getsebool` | Gets policy Boolean values |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `getsebool` | 获取策略布尔值 |'
- en: '| `id` | Displays a process’s security context |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 显示进程的安全上下文 |'
- en: '| `load_policy` | Loads a policy file |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `load_policy` | 加载策略文件 |'
- en: '| `ls -Z` | Displays the security context of a file |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `ls -Z` | 显示文件的安全上下文 |'
- en: '| `ps -Z` | Displays the security context of running processes |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `ps -Z` | 显示正在运行的进程的安全上下文 |'
- en: '| `restorecon` | Restores the security context of a file(s) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `restorecon` | 恢复文件的安全上下文 |'
- en: '| `runcon` | Runs a program in the specified security context |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `runcon` | 在指定的安全上下文中运行程序 |'
- en: '| `setenforce` | Sets the enforcing mode |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `setenforce` | 设置强制模式 |'
- en: '| `setsebool` | Sets the value of a policy Boolean |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `setsebool` | 设置策略布尔值 |'
- en: System Initialization
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统初始化
- en: As in traditional Linux systems, in Android all userspace daemons and programs
    are started by the *init* process, the first process the kernel starts (PID=1).
    However, unlike other Linux-based systems, Android’s initialization scripts (*init.rc*
    and its variants) are not interpreted by a general-purpose shell, but by *init*
    itself. Each initialization script contains built-in commands that are executed
    by *init* as it reads the script. SEAndroid extends Android’s *init* language
    with a number of new commands required to initialize SELinux and set the security
    contexts of services and files, as summarized in [Table 12-2](ch12.html#init_built-in_commands_for_selinux_suppo
    "Table 12-2. init Built-in Commands for SELinux Support").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 Linux 系统一样，在 Android 中，所有用户空间守护进程和程序都是由 *init* 进程启动的，这是内核启动的第一个进程（PID=1）。然而，不像其他基于
    Linux 的系统，Android 的初始化脚本（*init.rc* 及其变体）不是由通用 shell 解释的，而是由 *init* 本身解释执行。每个初始化脚本都包含
    *init* 执行时所需的内置命令。SEAndroid 扩展了 Android 的 *init* 语言，添加了许多新的命令，用于初始化 SELinux 和设置服务及文件的安全上下文，这些命令在[表
    12-2](ch12.html#init_built-in_commands_for_selinux_suppo "表 12-2. init 内置命令用于
    SELinux 支持")中进行了总结。
- en: Table 12-2. init Built-in Commands for SELinux Support
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-2. init 内置命令用于 SELinux 支持
- en: '| init Built-In Command | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| init 内置命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `seclabel` | Sets the security context of a service |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `seclabel` | 设置服务的安全上下文 |'
- en: '| `restorecon` | Restores the security context of a file or directory |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `restorecon` | 恢复文件或目录的安全上下文 |'
- en: '| `setcon` | Set the security context of the *init* process |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `setcon` | 设置 *init* 进程的安全上下文 |'
- en: '| `setenforce` | Sets the enforcing mode |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `setenforce` | 设置强制模式 |'
- en: '| `setsebool` | Sets the value of a policy Boolean |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `setsebool` | 设置策略布尔值 |'
- en: When *init* starts, it loads the SELinux policy from the */sepolicy* binary
    policy file, and then sets the enforcing mode based on the value of the *ro.boot.selinux*
    system property (which *init* sets based on the value of the *androidboot.selinux*
    kernel command-line parameter). When the property value is *permissive*, SELinux
    goes into permissive mode; when set to any other value or not set at all, the
    mode is set to enforcing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *init* 启动时，它从 */sepolicy* 二进制策略文件加载 SELinux 策略，然后根据 *ro.boot.selinux* 系统属性的值设置强制模式（*init*
    根据 *androidboot.selinux* 内核命令行参数的值来设置该属性）。当属性值为 *permissive* 时，SELinux 进入宽松模式；当设置为其他任何值或未设置时，模式则设置为强制模式。
- en: Next, *init* loads and parses the *init.rc* file and executes the commands specified
    there. [Example 12-18](ch12.html#selinux_initialization_in_initdotrc "Example 12-18. SELinux
    initialization in init.rc") shows an excerpt of *init.rc*, focusing on the parts
    responsible for SELinux initialization.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*init* 加载并解析 *init.rc* 文件，并执行文件中指定的命令。[示例 12-18](ch12.html#selinux_initialization_in_initdotrc
    "示例 12-18. SELinux 在 init.rc 中的初始化") 显示了 *init.rc* 的一部分，重点展示了负责 SELinux 初始化的部分。
- en: Example 12-18. SELinux initialization in init.rc
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-18. SELinux 在 init.rc 中的初始化
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, *init* sets its own security context using the `setcon` command
    ➊ before starting the core system daemons. Because a child process inherits the
    security context of its parent, *init* explicitly sets the security context of
    the *ueventd* daemon (the first daemon to be started) to *u:r:ueventd:s0* ➌ using
    the `seclabel` command. Most other native services have their domain set automatically
    by type transition rules defined in the policy (as in [Example 12-10](ch12.html#type_transitions_in_the_wpa_domain_left
    "Example 12-10. Type transitions in the wpa domain (from wpa_supplicant.te)")).
    (The `seclabel` command is only used to set the security contexts of processes
    that start very early in the system initialization process.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，*init* 在启动核心系统守护进程之前，使用 `setcon` 命令➊设置其自身的安全上下文。由于子进程会继承其父进程的安全上下文，*init*
    显式地将 *ueventd* 守护进程（第一个启动的守护进程）的安全上下文设置为 *u:r:ueventd:s0* ➌，通过 `seclabel` 命令来实现。其他大多数本地服务会根据策略中定义的类型转换规则自动设置其域（如在[示例
    12-10](ch12.html#type_transitions_in_the_wpa_domain_left "示例 12-10. 在 wpa 域中的类型转换（来自
    wpa_supplicant.te）")中所示）。(`seclabel` 命令仅用于设置在系统初始化过程中非常早期启动的进程的安全上下文。)
- en: When writable filesystems are mounted, *init* uses the `restorecon` command
    to restore the default labels of their mount points, because a factory reset could
    have cleared their labels. [Example 12-18](ch12.html#selinux_initialization_in_initdotrc
    "Example 12-18. SELinux initialization in init.rc") shows the command ➋ that labels
    the *userdata* partition’s mount point—*/data*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当可写文件系统被挂载时，*init* 使用 `restorecon` 命令恢复其挂载点的默认标签，因为出厂重置可能会清除它们的标签。[示例 12-18](ch12.html#selinux_initialization_in_initdotrc
    "示例 12-18. SELinux 在 init.rc 中的初始化") 展示了该命令 ➋，它给 *userdata* 分区的挂载点（*/data*）打上标签。
- en: Finally, because a policy reload can be triggered by setting the *selinux.reload_policy*
    system property to 1 ➍, *init* restarts the *ueventd* and *installd* daemons when
    this property is set so that the new policy can take effect.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为通过将 *selinux.reload_policy* 系统属性设置为 1 ➍ 可以触发策略重载，*init* 在该属性设置时会重启 *ueventd*
    和 *installd* 守护进程，以便新策略生效。
- en: Labeling Files
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签文件
- en: Recall that persistent SELinux objects, such as files, have a persistent security
    context that is typically saved in a file’s extended attribute. In Android, the
    initial security context of all files is defined in a text file called *file_contexts*,
    which might look like [Example 12-19](ch12.html#contents_of_the_fileunderscorecontexts_f
    "Example 12-19. Contents of the file_contexts file").
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，持久化 SELinux 对象，如文件，具有持久的安全上下文，该上下文通常保存在文件的扩展属性中。在 Android 中，所有文件的初始安全上下文在一个名为
    *file_contexts* 的文本文件中定义，其内容可能如下所示：[示例 12-19](ch12.html#contents_of_the_fileunderscorecontexts_f
    "示例 12-19. *file_contexts* 文件内容").
- en: Example 12-19. Contents of the file_contexts file
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-19. *file_contexts* 文件内容
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the file contains a list of paths (sometimes using wildcard
    characters) and their associated security contexts, each on a new line. The *file_contexts*
    file is consulted at various times during Android’s build and bootup process.
    For example, because on-memory filesystems such as Android’s root filesystem (mounted
    at */*) and the device filesystem (mounted at */dev*) are not persistent, all
    files are usually associated with the same security context as specified in the
    *genfs_contexts* file, or assigned using the `context=` mount option. In order
    to assign individual security contexts to specific files in such filesystems,
    *init* uses the `restorecon` command to look up the security context of each file
    in *file_contexts* (➊ for the root file-system, and ➋ as the default for the device
    filesystem) and sets it accordingly. When building Android from source, the `make_ext4fs`
    command also consults *file_contexts* in order to set the initial contexts of
    files on the *system* (mounted at */system* ➌) and *userdata* partition (mounted
    at */data* ➍) images. The security contexts of data partitions’ mount points are
    also restored on each boot (as shown in [Example 12-18](ch12.html#selinux_initialization_in_initdotrc
    "Example 12-18. SELinux initialization in init.rc")) in order to make sure they’re
    in a consistent state. Finally, Android’s recovery OS also includes a copy of
    *file_contexts*, which is used to set the correct labels of files created by the
    recovery during system updates. This guarantees that the system remains in a securely
    labeled stated across updates and avoids the need for full relabeling after each
    update.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，文件包含了一系列路径（有时使用通配符）及其关联的安全上下文，每个路径占一行。*file_contexts* 文件会在 Android 的构建和启动过程中多次被查阅。例如，因为像
    Android 根文件系统（挂载于 */*）和设备文件系统（挂载于 */dev*）这样的内存文件系统是非持久的，所有文件通常都会与 *genfs_contexts*
    文件中指定的相同安全上下文相关联，或者通过 `context=` 挂载选项进行分配。为了将特定文件分配给这些文件系统中的独立安全上下文，*init* 使用
    `restorecon` 命令在 *file_contexts* 中查找每个文件的安全上下文（➊ 对于根文件系统，➋ 作为设备文件系统的默认值），并根据查找到的内容进行设置。在从源代码构建
    Android 时，`make_ext4fs` 命令也会查阅 *file_contexts*，以设置 *system*（挂载于 */system* ➌）和
    *userdata* 分区（挂载于 */data* ➍）映像中文件的初始上下文。数据分区挂载点的安全上下文也会在每次启动时恢复（如 [示例 12-18](ch12.html#selinux_initialization_in_initdotrc
    "示例 12-18. SELinux 在 init.rc 中的初始化") 所示），以确保它们保持一致的状态。最后，Android 的恢复操作系统也包含一个
    *file_contexts* 文件的副本，用于在系统更新过程中设置恢复创建的文件的正确标签。这确保了系统在每次更新后都保持安全标签状态，并避免了每次更新后都需要重新标记。
- en: Labeling System Properties
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签系统属性
- en: Android uses global system properties that are visible to all processes for
    various purposes such as communicating hardware state, starting or stopping system
    services, triggering disk encryption, and even reloading the SELinux policy. Access
    to read-only system properties isn’t restricted, but because changing the values
    of key read-write properties alters the behavior of the system, write access to
    these properties is restricted and allowed only to system processes running under
    privileged UIDs, such as *system* and *radio*. SEAndroid augments this UID-based
    access control by adding MAC rules that regulate write access to system properties
    based on the domain of the process attempting property modification. In order
    for this to work, system properties (which are not native SELinux objects) must
    be associated with security contexts. This is accomplished by listing the security
    contexts of properties in a *property_contexts* file, much the same way that *file_contexts*
    specifies the security labels of files. The file is loaded into memory by the
    *property_service* (part of *init*), and the resulting security context lookup
    table is used to determine whether a process should be allowed access to a specific
    property based on the security contexts of both the process (subject) and the
    property (object). The SELinux policy defines a new `property_service` object
    class, with a single permission, `set`, which is used to specify access rules,
    as shown in [Example 12-20](ch12.html#system_property_access_rules_in_volddott
    "Example 12-20. System property access rules in vold.te").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用全局系统属性，这些属性对所有进程可见，用于各种目的，如传达硬件状态、启动或停止系统服务、触发磁盘加密，甚至重新加载 SELinux
    策略。只读系统属性的访问没有限制，但由于更改关键读写属性的值会改变系统行为，因此对这些属性的写访问受到限制，仅允许在特权 UID 下运行的系统进程访问，例如
    *system* 和 *radio*。SEAndroid 通过添加 MAC 规则来增强这种基于 UID 的访问控制，规定了基于进程域的系统属性写访问权限，允许进程修改属性。为了使其正常工作，系统属性（这些属性不是原生的
    SELinux 对象）必须与安全上下文关联。这是通过在 *property_contexts* 文件中列出属性的安全上下文来完成的，方式与 *file_contexts*
    指定文件的安全标签类似。该文件由 *property_service*（*init* 的一部分）加载到内存中，生成的安全上下文查找表将用于根据进程（主体）和属性（对象）的安全上下文判断是否允许进程访问特定属性。SELinux
    策略定义了一个新的 `property_service` 对象类，具有一个权限 `set`，用于指定访问规则，如 [示例 12-20](ch12.html#system_property_access_rules_in_volddott
    "示例 12-20. vold.te 中的系统属性访问规则") 所示。
- en: Example 12-20. System property access rules in vold.te
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-20. vold.te 中的系统属性访问规则
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this listing, the `vold` domain is allowed to set system properties of type
    `vold_prop` ➊, `powerctl_prop` ➋, and `ctl_default_prop` ➌.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，`vold` 域被允许设置类型为 `vold_prop` ➊、`powerctl_prop` ➋ 和 `ctl_default_prop`
    ➌ 的系统属性。
- en: These types are associated with actual properties based on the property name
    in *property_contexts*, as shown in [Example 12-21](ch12.html#association_of_property_names_with_their
    "Example 12-21. Association of property names with their security contexts in
    property_contexts").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型与实际属性相关联，依据属性名称在 *property_contexts* 中进行匹配，如 [示例 12-21](ch12.html#association_of_property_names_with_their
    "示例 12-21. 属性名称与其安全上下文在 property_contexts 中的关联") 所示。
- en: Example 12-21. Association of property names with their security contexts in
    property_contexts
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-21. 属性名称与其安全上下文在 property_contexts 中的关联
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The effect of this policy is that *vold* can set the values of all properties
    whose name starts with `vold.` ➊, `sys.powerctl` ➋, or `ctl.` ➌.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略的效果是，*vold* 可以设置所有属性值，这些属性的名称以 `vold.` ➊、`sys.powerctl` ➋ 或 `ctl.` ➌ 开头。
- en: Labeling Application Processes
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记应用程序进程
- en: Recall from [Chapter 2](ch02.html "Chapter 2. Permissions") that all app processes
    in Android are forked from the *zygote* process in order to reduce memory usage
    and improve application startup time. The *system_server* process, which runs
    as the *system* user and hosts most system services, is also forked from *zygote*,
    albeit via a slightly different interface.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第二章](ch02.html "第二章. 权限") 中提到的，Android 中所有的应用程序进程都是从 *zygote* 进程派生的，以减少内存使用并提高应用启动速度。*system_server*
    进程也从 *zygote* 派生，尽管是通过稍有不同的接口，但它以 *system* 用户身份运行，并托管大多数系统服务。
- en: The *zygote* process, which runs as root, is responsible for setting each app
    process’s DAC credentials (UID, GID, and supplementary GIDs), as well as its capabilities
    and resource limits. In order to support SELinux, *zygote* has been extended to
    check the security context of its clients (implemented in the `ZygoteConnection`
    class) and set the security context of each app process that it forks. The security
    context is determined according to the assignment rules specified in the *seapp_contexts*
    configuration file, according to the app’s UID, its package name, a flag that
    marks the system server process, and an SELinux-specific string attribute called
    `seinfo`. The *seapp_contexts* configuration file contains security context assignment
    rules (one per line) that consist of input selector attributes and output attributes.
    In order for a rule to be matched, all input selectors should match (logical AND).
    [Example 12-22](ch12.html#contents_of_the_seappunderscorecontexts "Example 12-22. Contents
    of the seapp_contexts file") shows the contents of the *seapp_contexts* file in
    the reference Android SELinux policy as of version 4.4.3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*合子*过程以根用户身份运行，负责设置每个应用程序进程的DAC凭证（UID、GID和附加GID），以及其能力和资源限制。为了支持SELinux，*合子*被扩展为检查其客户端的安全上下文（在`ZygoteConnection`类中实现），并设置每个由其分叉的应用程序进程的安全上下文。安全上下文根据*seapp_contexts*配置文件中指定的分配规则确定，该规则依据应用程序的UID、包名、标记系统服务器进程的标志以及一个名为`seinfo`的SELinux特定字符串属性来进行确定。*seapp_contexts*配置文件包含安全上下文分配规则（每行一个），这些规则由输入选择器属性和输出属性组成。为了匹配规则，所有输入选择器必须匹配（逻辑与）。[示例12-22](ch12.html#contents_of_the_seappunderscorecontexts
    "示例12-22. seapp_contexts文件的内容")显示了截至版本4.4.3的参考Android SELinux策略中的*seapp_contexts*文件内容。'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* seapp_contexts*, like all files in the reference policy, can be found
    in the* external/sepolicy/ *directory of Android’s source tree. See the file’s
    comments for the full list of input selectors, the selector matching precedence
    rules, and outputs.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*seapp_contexts*文件与参考策略中的所有文件一样，可以在Android源代码树的*external/sepolicy/*目录中找到。查看文件中的注释以获取输入选择器的完整列表、选择器匹配优先级规则和输出。'
- en: Example 12-22. Contents of the seapp_contexts file
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-22. seapp_contexts文件的内容
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line ➊ in this listing specifies the domain of the system server (`system`),
    because the `isSystemServer` selector (which can be used only once) is set to
    `true`. Because Android uses a fixed SELinux user identifier, role and security
    level, the resulting security context becomes *u:r:system:s0*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的第一行➊指定了系统服务器的域（`system`），因为`isSystemServer`选择器（只能使用一次）被设置为`true`。由于Android使用固定的SELinux用户标识符、角色和安全级别，结果安全上下文变为*u:r:system:s0*。
- en: The second assignment rule ➋ matches the `user` selector against the target
    process’s username, which is derived from its UID. If a process runs as one of
    the built-in Android Linux users (*system*, *radio*, *nfc*, and so on, as defined
    in *android_filesystem_config.h*), the associated name is used when matching the
    `user` selector. Isolated services are given the *_isolated* user-name string,
    and any other process is given the *_app* username string. Thus, system apps that
    match this selector are assigned the `system_app` domain.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个分配规则➋将`user`选择器与目标进程的用户名进行匹配，用户名来源于其UID。如果进程以内建的Android Linux用户之一运行（*system*、*radio*、*nfc*等，定义在*android_filesystem_config.h*中），则在匹配`user`选择器时使用关联的名称。孤立服务会分配一个`*_isolated*`用户名字符串，其他任何进程则分配`*_app*`用户名字符串。因此，匹配此选择器的系统应用程序会被分配`system_app`域。
- en: The `type` attribute specifies the object type that’s assigned to files owned
    by the target process. Because in this case the type is `system_data_file`, the
    security context of system files becomes *u:object_r:system_data_file:s0*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性指定分配给目标进程所拥有的文件的对象类型。由于在此情况下类型为`system_data_file`，因此系统文件的安全上下文变为*u:object_r:system_data_file:s0*。'
- en: Rule ➌ matches all apps that execute under a non-system UID and assigns their
    processes to the `untrusted_app` domain. The private app data directory of each
    untrusted app is recursively assigned the `app_data_file` object type, which results
    in the *u:object_r:app_data_file:s0* security context. The security context of
    the data directory is set by the *installd* daemon when it creates it as part
    of the app install process (see [Chapter 3](ch03.html "Chapter 3. Package Management")).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 ➌ 匹配所有在非系统 UID 下执行的应用，并将其进程分配到 `untrusted_app` 域。每个不受信任应用的私有应用数据目录递归地被分配为
    `app_data_file` 对象类型，从而形成 *u:object_r:app_data_file:s0* 安全上下文。数据目录的安全上下文由 *installd*
    守护进程在创建应用安装过程中的一部分时设置（参见 [第 3 章](ch03.html "第 3 章 包管理")）。
- en: 'Rules ➍ and ➎ use the `seinfo` selector to differentiate between non-system
    apps and assign them to different domains: apps processes that match `seinfo=platform`
    are assigned the `platform_app` domain, and those matching `seinfo=shared` are
    assigned the `shared_app` domain. (As we’ll see in the next section, an app’s
    `seinfo` attribute is determined by its signing certificate, so in effect, rules
    ➍ and ➎ use each app’s signing certificate as a process domain selector.)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 ➍ 和 ➎ 使用 `seinfo` 选择器区分非系统应用并将其分配到不同的域：匹配 `seinfo=platform` 的应用进程被分配到 `platform_app`
    域，匹配 `seinfo=shared` 的进程则分配到 `shared_app` 域。（正如我们将在下一节中看到的，应用的 `seinfo` 属性由其签名证书决定，因此实际上，规则
    ➍ 和 ➎ 将每个应用的签名证书用作进程域选择器。）
- en: Finally, rule ➏ assigns the `isolated_app` domain to all isolated services.
    (Isolated services run under a UID separate from their hosting app’s UID and cannot
    access any system services.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，规则 ➏ 将 `isolated_app` 域分配给所有隔离服务。（隔离服务在与其托管应用的 UID 分离的 UID 下运行，不能访问任何系统服务。）
- en: Middleware MAC
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件 MAC
- en: The `seinfo` attribute introduced in the previous section is part of an SEAndroid
    feature called *middleware MAC (MMAC)*, which is a higher-level access control
    scheme, separate from the kernel-level MAC (implemented in the SELinux LSM module).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中介绍的 `seinfo` 属性是 SEAndroid 的一项功能，称为 *中间件 MAC (MMAC)*，这是一种更高级别的访问控制方案，独立于内核级的
    MAC（该功能由 SELinux LSM 模块实现）。
- en: The MMAC was designed to provide MAC restrictions over Android’s permission
    model, which works at the framework level and cannot be easily mapped to the default
    kernel-level MAC. The original implementation includes an install-time MAC feature,
    which restricts the permissions that can be granted to each package based on its
    package name and signing certificate, regardless of a user’s permission grant
    decision. That is, even if a user decides to grant an app all the permissions
    it requests, the install can still be blocked by the MMAC if the policy doesn’t
    allow certain permissions to be granted.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: MMAC 的设计目的是对 Android 的权限模型提供 MAC 限制，该模型在框架级别工作，无法轻易映射到默认的内核级 MAC。原始实现包括一项安装时
    MAC 功能，根据应用包名和签名证书限制可以授予每个包的权限，而不管用户的权限授予决定。也就是说，即使用户决定授予应用所有请求的权限，只要策略不允许授予某些权限，安装过程仍然可能被
    MMAC 阻止。
- en: SEAndroid’s MMAC implementation also includes an intent MMAC feature that uses
    a policy to control which intents can be exchanged between applications. Another
    SEAndroid feature is the content provider MMAC, which defines a policy for content
    provider data access. However, the original SEAndroid MMAC implementation has
    been merged in mainline Android only partially, and the only supported feature
    is `seinfo` assignment based on the app signing certificate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SEAndroid 的 MMAC 实现还包括一项意图 MMAC 功能，该功能使用策略来控制应用之间可以交换的意图。另一个 SEAndroid 功能是内容提供者
    MMAC，它定义了内容提供者数据访问的策略。然而，原始的 SEAndroid MMAC 实现仅部分地合并到主线 Android 中，目前唯一支持的功能是基于应用签名证书的
    `seinfo` 分配。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As of version 4.3, Android has an experimental* intent firewall *feature that
    restricts what intents can be sent and received using “firewall”-style rules.
    This feature is similar to SEAndroid’s intent MMAC but is not integrated with
    the SELinux implementation.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*从版本 4.3 开始，Android 引入了一项实验性的*意图防火墙*功能，该功能通过“防火墙”样式的规则限制可以发送和接收的意图。这项功能类似于
    SEAndroid 的意图 MMAC，但并未与 SELinux 实现集成。*'
- en: The MMAC configuration file is called *mac_permission.xml* and resides in the
    */system/etc/security/* directory on the device. [Example 12-23](ch12.html#template_for_the_macunderscorepermission
    "Example 12-23. Template for the mac_permission.xml file") shows the template
    used to generate this file, typically stored as *external/sepolicy/ mac_permission.xml*
    in Android’s source tree.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-23. Template for the mac_permission.xml file
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the *@PLATFORM* ➊, *@MEDIA* ➋, *@SHARED* ➌, and *@RELEASE* ➍ macros represent
    the four platform signing certificates used in Android (*platform*, *media*, *shared*,
    and *release*) and are replaced with their respective certificates, encoded as
    hexadecimal strings, when building the SELinux policy.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: When scanning each installed package, the system `PackageManagerService` matches
    its signing certificate against the contents of the *mac_permission.xml* file
    and assigns the specified `seinfo` value to the package if it finds a match. If
    no match is found, it assigns the *default* `seinfo` value as specified by the
    `<default>` tag ➎.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Device Policy Files
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s SELinux policy consists of a binary policy file and four supporting
    configuration files, which are used for process, app, system property, and file
    labeling, as well as for MMAC initialization. [Table 12-3](ch12.html#android_selinux_policy_files
    "Table 12-3. Android SELinux Policy Files") shows where each of these files is
    located on a device and provides a brief description of the file’s purpose and
    contents.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-3. Android SELinux Policy Files
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| Policy File | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| */sepolicy* | Binary kernel policy |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| */file_contexts* | File security contexts, used for labeling filesystems
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| */property_contexts* | System property security contexts |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| */seapp_contexts* | Used to derive security contexts of app processes and
    files |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| */system/etc/security/mac_permissions.xml* | Maps app signing certificates
    to `seinfo` values |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SELinux-enabled Android releases before version 4.4.3 supported overriding
    the default policy files shown in [Table 12-3](ch12.html#android_selinux_policy_files
    "Table 12-3. Android SELinux Policy Files") with their counterparts stored in
    the* /data/ security/current/ *and* /data/system/ *(for the MMAC configuration
    file) directories in order to enable online policy updates without a full OTA
    update. However, Android 4.4.3 removed this feature because it could create discrepancies
    between the security labels set on the filesystem and the labels referenced from
    the new policy. Policy files are now loaded only from the default, read-only locations
    shown in [Table 12-3](ch12.html#android_selinux_policy_files "Table 12-3. Android
    SELinux Policy Files").*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Policy Event Logging
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access denial and access grants that have matching `auditallow` rules are logged
    to the kernel log buffer and can be viewed using `dmesg`, as shown in [Example 12-24](ch12.html#selinux_access_denials_logged_in_the_ker
    "Example 12-24. SELinux access denials logged in the kernel log buffer").
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-24. SELinux access denials logged in the kernel log buffer
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the audit log shows that a third-party application (source security context
    *u:r:untrusted_app:s0*) was denied access to the *getattr* permission on the *zygote*
    Unix domain socket (target context *u:r:zygote:s0*, object class `unix_stream_socket`).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.4 SELinux Policy
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android 4.2 was the first release to contain SELinux code, but SELinux was disabled
    at compile time in release builds. Android 4.3 enabled SELinux in all builds,
    but its default mode was set to permissive. Additionally, all domains were also
    individually set to permissive and were based on the `unconfined` domain, essentially
    allowing them full access (within the confines of DAC), even if the global SELinux
    mode was set to enforcing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.4 was the first version to ship with SELinux in enforcing mode, and
    it included enforcing domains for core system daemons. This section gives an overview
    of Android’s SELinux policy, as deployed in version 4.4, and introduces some of
    the major domains that make up the policy.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Policy Overview
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code of Android’s base SELinux policy is hosted in the *external/
    sepolicy/* directory of the Android source tree. Besides the files introduced
    in this chapter so far (*access_vectors*, *file_contexts*, *mac_permissions.xml*,
    and so on), the policy source consists mostly of type enforcement (TE) statements
    and rules split into multiple *.te* files, typically one for each defined domain.
    These files are combined to produce the binary policy file *sepolicy*, which is
    included in the root of the boot image as */sepolicy*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: You can examine the binary policy file using standard SELinux tools such as
    `seinfo`, `sesearch`, `sedispol`, and so on. For example, we can use the `seinfo`
    command to get a summary of the number of policy objects and rules, as shown in
    [Example 12-25](ch12.html#querying_a_binary_policy_file_using_the "Example 12-25. Querying
    a binary policy file using the seinfo command").
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-25. Querying a binary policy file using the `seinfo` command
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, the policy is fairly complex: it defines 84 classes, 267 types,
    and 1,140 allow rules.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You can get additional information about policy objects by specifying filtering
    options to the `seinfo` command. For example, because all domains are associated
    with the `domain` attribute, the command shown in [Example 12-26](ch12.html#getting_a_list_of_all_defined_domains_us
    "Example 12-26. Getting a list of all defined domains using the seinfo command")
    lists all domains defined in the policy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-26. Getting a list of all defined domains using the `seinfo` command
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can search for policy rules using the `sesearch` command. For example, all
    `allow` rules that have the `zygote` domain as their source can be displayed using
    the command shown in [Example 12-27](ch12.html#searching_for_policy_rules_using_the_ses
    "Example 12-27. Searching for policy rules using the sesearch commands").
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-27. Searching for policy rules using the `sesearch` commands
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For details about building and customizing the SELinux policy, see the* Validating
    Security-Enhanced Linux in Android *document.*^([[136](#ftn.ch12fn05)])'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Domains
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though SELinux is deployed in enforcing mode in Android 4.4, only the
    domains assigned to a few core daemons are currently enforcing, namely: *installd*
    (responsible for creating application data directories), *netd* (responsible for
    managing network connections and routes), *vold* (responsible for mounting external
    storage and secure containers), and *zygote*. All of these daemons run as root
    or are granted special capabilities because they need to perform administrative
    operations such as changing directory ownership (*installd*), manipulating packet
    filtering and routing rules (*netd*), mounting filesystems (*vold*), and changing
    process credentials (*zygote*) on behalf of other processes.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Because they have elevated privileges, these daemons have been the target of
    various privilege escalation exploits, which have allowed non-privileged processes
    to obtain root access on a device. Therefore, specifying a restrictive MAC policy
    for the domains associated with these system daemons is an important step towards
    strengthening Android’s sandboxing security model and preventing similar exploits
    in the future.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the type enforcement rules defined for the `installd` domain (in
    *instald.te*) to see how SELinux restricts what system daemons can access (see
    [Example 12-28](ch12.html#installd_type_enforcement_policy_left_pa "Example 12-28. installd
    type enforcement policy (from installd.te)")).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-28. installd type enforcement policy (from installd.te)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this listing, the *installd* daemon is first automatically transitioned to
    a dedicated domain (also named `installd`) when started ➊ using the `init_daemon_domain()`
    macro. It is then granted the `relabelto` permission so that it can set the security
    labels of the files and directories it creates ➋. Next, the domain is associated
    with the `mlstrustedsubject` attribute ➌, which allows it to bypass MLS access
    rules. Because *installd* needs to set the owner of the files and directories
    it creates to that of their owner application, it’s granted the `chown`, `dac_override`,
    and other capabilities pertaining to file ownership ➍.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: As part of the app install process, *installd* also triggers the DEX optimization
    process, which creates ODEX files in the */data/dalvik-cache/* directory (security
    context *u:object_r:dalvikcache_data_file:s0*), which is why the installer daemon
    is granted permission to create files in that directory ➎. Next, because *installd*
    creates private data directories for applications in the */data/* directory, it
    is given permission to create and relabel directories (➏ and ➐), as well as get
    the attributes and delete files ➑ under */data/* (which is associated with the
    `data_file_type` attribute). Because *installd* also needs to read downloaded
    APK files in order to perform DEX optimization, it’s granted access to APK files
    stored under */data/app/* ➒, a directory associated with the `apk_data_file` type
    (security context *u:object_r:apk_data_file:s0*).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用安装过程的一部分，*installd* 还触发 DEX 优化过程，该过程会在 */data/dalvik-cache/* 目录中创建 ODEX
    文件（安全上下文 *u:object_r:dalvikcache_data_file:s0*），这也是为什么安装守护进程被授予在该目录中创建文件的权限 ➎。接下来，由于
    *installd* 在 */data/* 目录下为应用程序创建私有数据目录，它被授予创建和重新标记目录的权限（➏ 和 ➐），以及获取属性和删除 */data/*
    下文件的权限 ➑（该目录与 `data_file_type` 属性相关联）。由于 *installd* 还需要读取下载的 APK 文件以进行 DEX 优化，因此它被授予访问存储在
    */data/app/* 目录下的 APK 文件的权限 ➒，该目录与 `apk_data_file` 类型（安全上下文 *u:object_r:apk_data_file:s0*）相关联。
- en: 'Finally, *installd* is allowed to execute system commands (security context
    *u:object_r:system_file:s0*) ➓ in order to start the DEX optimization process.
    [Example 12-28](ch12.html#installd_type_enforcement_policy_left_pa "Example 12-28. installd
    type enforcement policy (from installd.te)") omits a few of them, but the remaining
    policy rules follow the same principle: allow *installd* the least amount of privileges
    it needs to complete package installation. As a result, even if the daemon is
    compromised and a malicious program is executed under *installd*’s privileges,
    it would only have access to a limited number of files and directories, and would
    be denied any permissions not explicitly allowed by the MAC policy.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*installd* 被允许执行系统命令（安全上下文 *u:object_r:system_file:s0*） ➓ 以启动 DEX 优化过程。[示例
    12-28](ch12.html#installd_type_enforcement_policy_left_pa "示例 12-28. installd
    类型强制策略（来自 installd.te）") 忽略了其中的一些，但剩余的策略规则遵循相同的原则：只允许 *installd* 完成软件包安装所需的最少权限。因此，即使守护进程被攻破，恶意程序在
    *installd* 的权限下执行，它也只能访问有限数量的文件和目录，并且任何未被 MAC 策略明确允许的权限都会被拒绝。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While Android 4.4 has only four enforcing domains, as the platform evolves
    and the base SELinux policy is refined, eventually all domains are likely to be
    deployed in enforcing mode. For example, as of this writing, in the base policy
    in the master branch of the Android Open Source Project (AOSP), all domains are
    set to enforcing mode in release builds and the permissive domains are only used
    in development builds.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 Android 4.4 只有四个强制执行的域，但随着平台的发展和基础 SELinux 策略的完善，最终所有域可能都会以强制模式部署。例如，截至目前，在
    Android 开源项目（AOSP）主分支的基础策略中，所有域都被设置为在发布版本中强制模式，而宽容域仅用于开发版本。*'
- en: Even if a domain is in enforcing mode, it can be allowed effectively unrestricted
    access if it’s derived from a base domain that is granted all or most access permissions.
    In Android’s SELinux policy, such a domain is the `unconfineddomain` domain, which
    we discuss next.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个域处于强制模式，它仍然可以通过从一个授予了所有或大多数访问权限的基础域派生而被有效地允许完全无限制的访问。在 Android 的 SELinux
    策略中，这样的域就是 `unconfineddomain` 域，接下来我们将讨论这个域。
- en: Unconfined Domains
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无约束域
- en: Android’s SELinux policy contains a base (also referred to as template) domain
    called `unconfineddomain`, which is allowed almost all system privileges and is
    used as a parent for other policy domains. As of Android 4.4, the `unconfineddomain`
    is defined as shown in [Example 12-29](ch12.html#unconfineddomain_domain_definition_in_an
    "Example 12-29. unconfineddomain domain definition in Android 4.4").
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 SELinux 策略包含一个名为 `unconfineddomain` 的基础（也称为模板）域，该域几乎被授予所有系统特权，并且作为其他策略域的父域。自
    Android 4.4 以来，`unconfineddomain` 已按 [示例 12-29](ch12.html#unconfineddomain_domain_definition_in_an
    "示例 12-29. Android 4.4 中的 unconfineddomain 域定义") 中所示的方式进行定义。
- en: Example 12-29. `unconfineddomain` domain definition in Android 4.4
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-29. `unconfineddomain` 域定义（Android 4.4 中）
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `unconfineddomain` domain is allowed all kernel capabilities
    ➊, full access to the SELinux security server ➋ (except for loading the MAC policy),
    all process-related permissions ➌, and so on. Other domains “inherit” the permissions
    of this domain via the `unconfined_domain()` macro, which assigns the `unconfineddomain`
    attribute to the domain passed as an argument. In Android 4.4’s SELinux policy,
    all permissive domains are also unconfined, and thus are granted practically unrestricted
    access (within the limits of the DAC).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While the `unconfineddomain` still exists in AOSP’s master branch, it has
    been considerably restricted and is no longer used as an unrestricted domain,
    but as the base policy for system daemons and other privileged Android components.
    As more domains are switched to enforcing mode and their policies are fine-tuned,
    `unconfineddomain` is expected to be removed.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: App Domains
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that SEAndroid assigns several different domains to application processes
    based on their process UID or signing certificate. These application domains are
    assigned common permissions by inheriting the base `appdomain` using the `app_domain()`
    macro which, as defined in *app.te*, includes rules that allow the common operations
    all Android apps require. [Example 12-30](ch12.html#appdomain_policy_excerpt_left_parenthesi
    "Example 12-30. appdomain policy excerpt (from app.te)") shows an excerpt from
    the *app.te* file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-30. `appdomain` policy excerpt (from app.te)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This policy allows the `appdomain` to receive and use file descriptors from
    *zygote* ➊; read system properties managed by *zygote* ➋; communicate with the
    *system_server* via pipes, local sockets, or Binder ➌; communicate with the *surfaceflinger*
    daemon (responsible for drawing on screen) ➍; and create files and directories
    in its sandbox data directory ➎. The rest of the policy defines rules that allow
    other required permissions, such as network access, access to downloaded files,
    and Binder access to core system services. Operations that apps do not typically
    require, such as raw block device access, kernel memory access, and SELinux domain
    transitions, are explicitly prohibited using `neverallow` rules.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Concrete app domains such as `untrusted_app` (which is assigned to all non-system
    applications according to the assignment rules in *seapp_contexts* shown in [Example 12-22](ch12.html#contents_of_the_seappunderscorecontexts
    "Example 12-22. Contents of the seapp_contexts file")) extend `appdomain` and
    add additional access rules, as required by the target application(s). [Example 12-31](ch12.html#untrustedunderscoreapp_domain_policy_exc
    "Example 12-31. untrusted_app domain policy excerpt (from untrusted_app.te)")
    shows an excerpt from *untrusted_app.te*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-31. `untrusted_app` domain policy excerpt (from untrusted_app.te)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this policy file, the `untrusted_app` domain is set to permissive mode ➊,
    after which it inherits the policies of `appdomain` ➋, `netdomain` ➌, and `bluetoothdomain`
    ➍ via the respective macros. The domain is then allowed access to tunnel devices
    (used for VPNs) ➎, external storage (SD cards, ➏ and ➐), and encrypted application
    containers ➑. The rest of the rules (not shown) grant access to sockets, pseudoterminals,
    and a few other needed OS resources.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: All other app domains (`isolated_app`, `media_app`, `platform_app`, `release_app`,
    and `shared_app` in version 4.4) also inherit from `appdomain` and add additional
    `allow` rules, either directly or by extending additional domains. In Android
    4.4, all app domains are set to permissive mode.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The SELinux policy in AOSP’s mater branch simplifies the app domain hierarchy
    by removing the dedicated `media_app`, `shared_app`, and `release_app` domains
    and merging them into the `untrusted_app` domain. Additionally, only the `system_app`
    domain is unconfined.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of version 4.3, Android has integrated SELinux in order to reinforce the
    default sandbox model using the mandatory access control (MAC) available in the
    Linux kernel. Unlike the default discretionary access control (DAC), MAC offers
    a fine-grained object and permission model and a flexible security policy that
    cannot be overridden or changed by malicious processes (as long as the kernel
    itself isn’t compromised).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.4 is the first version to switch SELinux to enforcing mode in release
    builds, but all domains other than a few highly privileged core daemons are set
    to permissive mode in order to maintain compatibility with existing applications.
    Android’s base SELinux policy continues to be refined with each release, and future
    releases will likely switch most domains to enforcing mode and remove the supporting
    unconfined domain, which is currently inherited by the majority of domains associated
    with privileged services.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: ^([[132](#ch12fn01)]) Free Software Foundation, Inc., “GNU M4 - GNU Project
    - Free Software Foundation (FSF),” *[https://www.gnu.org/software/m4/](https://www.gnu.org/software/m4/)*
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '^([[133](#ch12fn02)]) Richard Haines, *The SELinux Notebook: The Foundations*,
    3rd edition, 2012, *[http://www.freetechbooks.com/efiles/selinuxnotebook/The_SELinux_Notebook_The_Foundations_3rd_Edition.pdf](http://www.freetechbooks.com/efiles/selinuxnotebook/The_SELinux_Notebook_The_Foundations_3rd_Edition.pdf)*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: ^([[134](#ch12fn03)]) Security Enhancements for Android, *[https://bitbucket.org/seandroid/manifests/](https://bitbucket.org/seandroid/manifests/)*
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '^([[135](#ch12fn04)]) Craig Smalley, *Security Enhanced (SE) Android: Bringing
    Flexible MAC to Android*, *[http://www.internetsociety.org/sites/default/files/02_4.pdf](http://www.internetsociety.org/sites/default/files/02_4.pdf)*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ^([[136](#ch12fn05)]) Google, “Validating Security-Enhanced Linux in Android,”
    *[http://source.android.com/devices/tech/security/se-linux.html](http://source.android.com/devices/tech/security/se-linux.html)*
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[136](#ch12fn05)]) Google, “在 Android 中验证安全增强型 Linux，” *[http://source.android.com/devices/tech/security/se-linux.html](http://source.android.com/devices/tech/security/se-linux.html)*
