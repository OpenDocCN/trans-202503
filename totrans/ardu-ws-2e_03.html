<html><head></head><body>
		<section>&#13;
			<header>&#13;
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_45" title="45"/>4</span><br/><span class="ChapterTitle">Building Blocks</span></h1>&#13;
			</header>&#13;
			<p class="ChapterIntro">In this chapter you will</p>&#13;
			<ul>&#13;
				<li>Learn how to read schematic diagrams, the language of electronic circuits</li>&#13;
				<li>Be introduced to the capacitor</li>&#13;
				<li>Work with input pins</li>&#13;
				<li>Use arithmetic and test values</li>&#13;
				<li>&#13;
					Make decisions with <code>if</code> statements</li>&#13;
				<li>Learn the difference between analog and digital</li>&#13;
				<li>Measure analog voltage sources at different levels of precision</li>&#13;
				<li>Be introduced to variable resistors, piezoelectric buzzers, and temperature sensors</li>&#13;
				<li>Consolidate your knowledge by creating traffic lights, a battery tester, and a thermometer</li>&#13;
			</ul>&#13;
			<p><span epub:type="pagebreak" id="Page_46" title="46"/>The information in this chapter will help you understand an Arduino’s potential. We’ll continue to learn about electronics, including how to read schematic diagrams (the “road maps” of electronic circuits). We’ll also explore some new components and the types of signals that we can measure. Then we’ll discuss additional Arduino functions, such as storing values, performing mathematical operations, and making decisions. Finally, we’ll examine a few more components and put them to use in some useful projects.</p>&#13;
			<h2 id="h1-500587c04-0001">Using Schematic Diagrams</h2>&#13;
			<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> described how to build a circuit using physical layout diagrams to represent the breadboard and components mounted on it. Although such physical layout diagrams may seem like the easiest way to diagram a circuit, you’ll find that as more components are added, diagrams that are direct representations can become a real mess. Because our circuits are about to get more complicated, we’ll start using <em>schematic diagrams</em> (also known as <em>circuit diagrams</em>) to illustrate them, such as the one shown in <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04001" src="image_fi/500587c04/f04001.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-1">Figure 4-1</a>: Example of a schematic diagram</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Schematics are simply circuit road maps that show the path of the electrical current flowing through various components. Instead of showing components and wires, a schematic uses symbols and lines.</p>&#13;
			<h3 id="h2-500587c04-0001">Identifying Components</h3>&#13;
			<p class="BodyFirst">Once you know what the symbols mean, reading a schematic is easy. To begin, let’s examine the symbols for the components we’ve already used.</p>&#13;
			<h4 id="h3-500587c04-0001">The Arduino</h4>&#13;
			<p class="BodyFirst"><a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a> shows a symbol for the Arduino itself. As you can see, all of the Arduino’s connections are displayed and neatly labeled.</p>&#13;
			<span epub:type="pagebreak" id="Page_47" title="47"/>&#13;
			<figure>&#13;
				<img alt="f04002" src="image_fi/500587c04/f04002.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-2">Figure 4-2</a>: Arduino Uno symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h4 id="h3-500587c04-0002">The Resistor</h4>&#13;
			<p class="BodyFirst">The resistor symbol is shown in <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04003" src="image_fi/500587c04/f04003.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-3">Figure 4-3</a>: Resistor symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				It’s good practice to display the resistor value and part designator along with the resistor symbol (220 Ω and R1 in this case). This makes life a lot easier for everyone trying to make sense of the schematic (including you). Often you may see ohms written as <em>R</em> instead—for example, 220 R.</p>&#13;
			<h4 id="h3-500587c04-0003">The Rectifier Diode</h4>&#13;
			<p class="BodyFirst">The rectifier diode symbol is shown in <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04004" src="image_fi/500587c04/f04004.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-4">Figure 4-4</a>: Rectifier diode symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Recall from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> that rectifier diodes are polarized and current flows from the anode to the cathode. In the symbol shown in <a href="#figure4-4">Figure 4-4</a>, the anode is on the left and the cathode is on the right. An easy way to remember this is to think of current flowing toward the point of the triangle only. Current cannot flow the other way because the vertical bar “stops” it.</p>&#13;
			<h4 id="h3-500587c04-0004"><span epub:type="pagebreak" id="Page_48" title="48"/>The LED</h4>&#13;
			<p class="BodyFirst">The LED symbol is shown in <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04005" src="image_fi/500587c04/f04005.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-5">Figure 4-5</a>: LED symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>All members of the diode family share a common symbol: the triangle and vertical line. However, LED symbols show two parallel arrows pointing away from the triangle to indicate that light is being emitted.</p>&#13;
			<h4 id="h3-500587c04-0005">The Transistor</h4>&#13;
			<p class="BodyFirst">The transistor symbol is shown in <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>. We’ll use this to represent our BC548.</p>&#13;
			<figure>&#13;
				<img alt="f04006" src="image_fi/500587c04/f04006.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-6">Figure 4-6</a>: Transistor symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				The vertical line at the top of the symbol (labeled <em>C</em>) represents the collector, the horizontal line at the left represents the base (labeled <em>B</em>), and the bottom line represents the emitter (labeled <em>E</em>). The arrow inside the symbol, pointing down and to the right, tells us that this is an <em>NPN</em>-type transistor, because NPN transistors allow current to flow from the collector to the emitter. (<em>PNP</em>-type transistors allow current to flow from the emitter to the collector.)</p>&#13;
			<p>&#13;
				When numbering transistors we use the letter <em>Q</em>, just as we use <em>R</em> to number resistors.</p>&#13;
			<h4 id="h3-500587c04-0006">The Relay</h4>&#13;
			<p class="BodyFirst">The relay symbol is shown in <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04007" src="image_fi/500587c04/f04007.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-7">Figure 4-7</a>: Relay symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Relay symbols can vary in many ways and may have more than one set of contacts, but all relay symbols share certain elements in common. The first is the <em>coil</em>, which is the curvy vertical line at the left. The second element is the relay <em>contacts</em>. The <em>COM</em> (for common) contact is often used as an input, and the contacts marked <em>NO</em> (normally open) and <em>NC</em> (normally closed) are often used as outputs.</p>&#13;
			<p>&#13;
				The relay symbol is always shown with the relay in the off state and the coil not <em>energized</em>—that is, with the COM and NC pins connected. When the relay coil is energized, the COM and NO pins will be connected in the symbol.</p>&#13;
			<h3 id="h2-500587c04-0002">Wires in Schematics</h3>&#13;
			<p class="BodyFirst">When wires cross or connect in schematics, they are drawn in particular ways, as shown in the following examples.</p>&#13;
			<h4 id="h3-500587c04-0007"><span epub:type="pagebreak" id="Page_49" title="49"/>Crossing but Not Connected Wires</h4>&#13;
			<p class="BodyFirst">When two wires cross but are not connected, the crossing can be represented in one of two ways, as shown in <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a>. There is no one right way; it’s a matter of preference.</p>&#13;
			<figure>&#13;
				<img alt="f04008" src="image_fi/500587c04/f04008.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-8">Figure 4-8</a>: Non-connecting crossed wires</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h4 id="h3-500587c04-0008">Connected Wires</h4>&#13;
			<p class="BodyFirst">When wires are meant to be physically connected, a <em>junction dot</em> is drawn at the point of connection, as shown in <a href="#figure4-9" id="figureanchor4-9">Figure 4-9</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04009" src="image_fi/500587c04/f04009.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-9">Figure 4-9</a>: Two wires that are connected</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h4 id="h3-500587c04-0009">Wire Connected to Ground</h4>&#13;
			<p class="BodyFirst">When a wire is connected back to ground (GND), the standard method is to use the symbol shown in <a href="#figure4-10" id="figureanchor4-10">Figure 4-10</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04010" src="image_fi/500587c04/f04010.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-10">Figure 4-10</a>: The GND symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>The GND symbol at the end of a line in a schematic in this book tells you that the wire is physically connected to the Arduino GND pin.</p>&#13;
			<h3 id="h2-500587c04-0003">Dissecting a Schematic</h3>&#13;
			<p class="BodyFirst">Now that you know the symbols for various components and their connections, let’s dissect the schematic we would draw for Project 1, <span class="xref" itemid="xref_target_on page 33 in Chapter 3">on page 33 in Chapter 3</span>. Recall that you made five LEDs blink backward and forward.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_50" title="50"/>Compare the schematic shown in <a href="#figure4-11" id="figureanchor4-11">Figure 4-11</a> with Figure 3-13 on <span class="xref" itemid="xref_target_page 34">page 34</span>, and you’ll see that using a schematic is a much easier way to describe a circuit.</p>&#13;
			<figure>&#13;
				<img alt="f04011" src="image_fi/500587c04/f04011.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-11">Figure 4-11</a>: Schematic for Project 1</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>From now on, we’ll use schematics to describe circuits, and I’ll show you the symbols for new components as they’re introduced.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							If you’d like to create your own computer-drawn schematics, try the Fritzing application, available at minimal cost from <a class="LinkURL" href="http://www.fritzing.org/">http://www.fritzing.org/</a>.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h2 id="h1-500587c04-0002">The Capacitor</h2>&#13;
			<p class="BodyFirst">A <em>capacitor</em> is a device that holds an electric charge. It consists of two conductive plates sandwiching an insulating layer that allows an electric charge to build up between the plates. When the current is stopped, the charge remains and can flow out of the capacitor (called <em>discharging</em> the capacitor) as soon as the charge voltage stored in the capacitor is presented with a new path for the current to take.</p>&#13;
			<h3 id="h2-500587c04-0004"><span epub:type="pagebreak" id="Page_51" title="51"/>Measuring the Capacity of a Capacitor</h3>&#13;
			<p class="BodyFirst">The amount of charge that a capacitor can store is measured in <em>farads</em>, and one farad is actually a very large amount. Therefore, you will generally find capacitors with values measured in picofarads or microfarads. One <em>picofarad </em>(pF) is 0.000000000001 of a farad, and one <em>microfarad</em> (μF) is 0.000001 of a farad. Capacitors are also manufactured to accept certain voltage maximums. In this book we’ll be working with low voltages only, so we won’t be using capacitors rated at greater than 10 V or so; it’s generally fine, however, to use higher-voltage capacitors in lower-voltage circuits. Common voltage ratings are 10, 16, 25, and 50 V.</p>&#13;
			<h3 id="h2-500587c04-0005">Reading Capacitor Values</h3>&#13;
			<p class="BodyFirst">Reading the value of a ceramic capacitor takes some practice, because the value is printed in a sort of code. The first two digits represent the value in picofarads, and the third digit is the multiplier in tens. For example, the capacitor shown in <a href="#figure4-12" id="figureanchor4-12">Figure 4-12</a> is labeled <em>104</em>. This equates to 10 followed by four zeros, or 100,000 pF (which is 100 nanofarads [nF] or 0.1 μF).</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							The conversions between units of measure can be a little confusing, but you can print an excellent conversion chart from <a class="LinkURL" href="http://www.justradios.com/uFnFpF.html">http://www.justradios.com/uFnFpF.html</a>.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h3 id="h2-500587c04-0006">Types of Capacitors</h3>&#13;
			<p class="BodyFirst">Our projects will use two types of capacitors: ceramic and electrolytic.</p>&#13;
			<h4 id="h3-500587c04-0010">Ceramic Capacitors</h4>&#13;
			<p class="BodyFirst"><em>Ceramic capacitors</em>, such as the one shown in <a href="#figure4-12">Figure 4-12</a>, are very small and therefore hold a small amount of charge. They are not polarized and can be used for current flowing in either direction. The schematic symbol for a non-polarized capacitor is shown in <a href="#figure4-13" id="figureanchor4-13">Figure 4-13</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04012" src="image_fi/500587c04/f04012.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-12">Figure 4-12</a>: A 0.1 µF ceramic capacitor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<figure>&#13;
				<img alt="f04013" src="image_fi/500587c04/f04013.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-13">Figure 4-13</a>: Non-polarized capacitor schematic symbol, with the capacitor’s value shown at the upper right</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Ceramic capacitors work beautifully in high-frequency circuits because they can charge and discharge very quickly due to their small capacitance.</p>&#13;
			<h4 id="h3-500587c04-0011"><span epub:type="pagebreak" id="Page_52" title="52"/>Electrolytic Capacitors</h4>&#13;
			<p class="BodyFirst"><em>Electrolytic capacitors</em>, like the one shown in <a href="#figure4-14" id="figureanchor4-14">Figure 4-14</a>, are physically larger than ceramic types, offer increased capacitance, and are polarized. A marking on the cover shows either the positive (+) side or the negative (–) side. In <a href="#figure4-14">Figure 4-14</a>, you can see the stripe and the small negative (–) symbol that identifies the negative side. Like resistors, capacitors also have a level of tolerance with their values. The capacitor in <a href="#figure4-14">Figure 4-14</a> has a tolerance of 20 percent and a capacitance of 100 μF.</p>&#13;
			<figure>&#13;
				<img alt="f04014" src="image_fi/500587c04/f04014.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-14">Figure 4-14</a>: An electrolytic capacitor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				The schematic symbol for electrolytic capacitors, shown in <a href="#figure4-15" id="figureanchor4-15">Figure 4-15</a>, includes the + symbol to indicate the capacitor’s polarity.</p>&#13;
			<figure>&#13;
				<img alt="f04015" src="image_fi/500587c04/f04015.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-15">Figure 4-15</a>: Polarized capacitor schematic symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Electrolytic capacitors are often used to store larger electric charges and to smooth power supply voltages. Like a small temporary battery, they can smooth out the power supply and provide stability near circuits or parts that draw high currents quickly from the supply. This prevents unwanted dropouts and noise in your circuits. Luckily, the values of the electrolytic capacitor are printed clearly on the outside and don’t require decoding or interpretation.</p>&#13;
			<p>You already have some experience generating basic forms of output using LEDs with your Arduino. Now it’s time to learn how to send input from the outside world into your Arduino using digital inputs, and to make decisions based on that input.</p>&#13;
			<h2 id="h1-500587c04-0003"><span epub:type="pagebreak" id="Page_53" title="53"/>Digital Inputs</h2>&#13;
			<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, we used digital I/O pins as outputs to turn LEDs on and off. We can use these same pins to accept input from users—as long as we limit our information to two states, high and low.</p>&#13;
			<p>&#13;
				The simplest form of digital input is a <em>push button</em>; several push buttons are shown in <a href="#figure4-16" id="figureanchor4-16">Figure 4-16</a>. You can insert one of these directly into your solderless breadboard and wire it to an Arduino pin. When the button is pressed, current flows through the switch and into the digital input pin, which detects the presence of the voltage.</p>&#13;
			<figure>&#13;
				<img alt="f04016" src="image_fi/500587c04/f04016.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-16">Figure 4-16</a>: Basic push buttons on a breadboard</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Notice that the button at the bottom of the figure is inserted into the breadboard, bridging rows 23 and 25. When the button is pressed, it connects the two rows. The schematic symbol for this push button is shown in <a href="#figure4-17" id="figureanchor4-17">Figure 4-17</a>. The symbol represents the two sides of the button, which are numbered with the prefix <em>S</em>. When the button is pressed, the line bridges the two halves and allows voltage or current through.</p>&#13;
			<figure>&#13;
				<img alt="f04017" src="image_fi/500587c04/f04017.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-17">Figure 4-17</a>: Push button schematic symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="box">&#13;
					<h2><span epub:type="pagebreak" id="Page_54" title="54"/>Measuring Switch Bounce with a Digital Storage Oscilloscope</h2>&#13;
					<p class="BoxBodyFirst">Push buttons exhibit a phenomenon called <em>switch bounce</em>, or <em>bouncing</em>, which refers to a button’s tendency to turn on and off several times after being pressed only once by the user. This phenomenon occurs because the metal contacts inside a push button are so small that they can vibrate after the button has been released, thereby switching on and off again very quickly.</p>&#13;
					<p>&#13;
						Switch bounce can be demonstrated with a <em>digital storage oscilloscope (DSO)</em>, a device that displays the change in a voltage over a period of time. For example, consider <a href="#figure4-18" id="figureanchor4-18">Figure 4-18</a>, a DSO displaying a switch bounce.</p>&#13;
					<figure>&#13;
						<img alt="f04018" src="image_fi/500587c04/f04018.png"/>&#13;
						<figcaption>&#13;
							<p><a id="figure4-18">Figure 4-18</a>: Measuring switch bounce</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					<p>&#13;
						The top half of the display in <a href="#figure4-18">Figure 4-18</a> shows the results of pressing a button several times. When the voltage line indicated by the arrow is at the higher horizontal position (5 V), the button is in the <em>on</em> state, and the voltage is connected through it. Underneath the word <em>Stop</em> is a slice of time just after the button was switched off, as shown by two gray vertical lines.</p>&#13;
					<p>The button voltage during this interval is magnified in the bottom half of the screen. At point A, the button is released by the user, and the line drops to 0 V. However, due to physical vibration, the button returns almost immediately to the higher 5 V position until point B, where it vibrates off and then on again until point C, where it settles in the low (off) state. In effect, instead of relaying one button press to our Arduino, we have unwittingly sent three.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h2 class="HeadProject" id="h1-500587c04-0004"><span><span epub:type="pagebreak" id="Page_55" title="55"/>Project #4: Demonstrating a Digital Input</span></h2>&#13;
			<p class="BodyFirst">Our goal in this project is to create a button that turns on an LED for half a second when pressed.</p>&#13;
			<h3 id="h2-500587c04-0007">The Algorithm</h3>&#13;
			<p class="BodyFirst">Here is our algorithm:</p>&#13;
			<ol class="decimal">&#13;
				<li value="1">Test whether the button has been pressed.</li>&#13;
				<li value="2">If the button has been pressed, turn on the LED for half a second and then turn it off.</li>&#13;
				<li value="3">If the button has not been pressed, do nothing.</li>&#13;
				<li value="4">Repeat indefinitely.</li>&#13;
			</ol>&#13;
			<h3 id="h2-500587c04-0008">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>One push button</li>&#13;
				<li>One LED</li>&#13;
				<li>One 560 Ω resistor</li>&#13;
				<li>One 10 kΩ resistor</li>&#13;
				<li>One 100 nF capacitor</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>One breadboard</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c04-0009">The Schematic</h3>&#13;
			<p class="BodyFirst">First, we create the circuit on the breadboard with the schematic shown in <a href="#figure4-19" id="figureanchor4-19">Figure 4-19</a>. Notice that the 10 kΩ resistor is connected between GND and digital pin 7. We call this a <em>pull-down resistor, </em>because it pulls the voltage at the digital pin almost to zero. Furthermore, by adding a 100 nF capacitor across the 10 kΩ resistor, we create a simple <em>debounce</em> circuit to help filter out the switch bounce. When the button is pressed, the digital pin goes immediately to high. But when the button is released, digital pin 7 is pulled down to GND via the 10 kΩ resistor, and the 100 nF capacitor creates a small delay. This effectively covers up the bouncing pulses by slowing the drop of the voltage to GND, thereby eliminating most of the false readings due to floating voltage and erratic button behavior.</p>&#13;
			<span epub:type="pagebreak" id="Page_56" title="56"/>&#13;
			<figure>&#13;
				<img alt="f04019" src="image_fi/500587c04/f04019.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-19">Figure 4-19</a>: Schematic for Project 4</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Because this is the first time you’re building a circuit with a schematic, follow these step-by-step instructions as you walk through the schematic; this should help you understand how the components connect:</p>&#13;
			<ol class="decimal">&#13;
				<li value="1">Insert the push button into the breadboard, as shown in <a href="#figure4-20" id="figureanchor4-20">Figure 4-20</a>.&#13;
					<figure>&#13;
						<img alt="f04020" src="image_fi/500587c04/f04020.png"/>&#13;
						<figcaption>&#13;
							<p><a id="figure4-20">Figure 4-20</a>: The push button inserted into the breadboard</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					</li>&#13;
				<li value="2">Now insert the 10 kΩ resistor, a short link wire, and the capacitor, as shown in <a href="#figure4-21" id="figureanchor4-21">Figure 4-21</a>.<span epub:type="pagebreak" id="Page_57" title="57"/>&#13;
				<figure><img alt="f04021" src="image_fi/500587c04/f04021.png"/><figcaption>&#13;
							<p><a id="figure4-21">Figure 4-21</a>: Adding the 10 kΩ resistor and the capacitor</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					</li>&#13;
				<li value="3">Connect one wire from the Arduino 5 V pin to the upper-right row for the button on the breadboard. Connect another wire from the Arduino GND pin to the same vertical row that connects to the left-hand sides of the wire link and the resistor. This is shown in <a href="#figure4-22" id="figureanchor4-22">Figure 4-22</a>.&#13;
					<figure>&#13;
						<img alt="f04022" src="image_fi/500587c04/f04022.png"/>&#13;
						<figcaption>&#13;
							<p><a id="figure4-22">Figure 4-22</a>: Connecting the 5 V (red) and GND (black) wires</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					</li>&#13;
				<li value="4"><span epub:type="pagebreak" id="Page_58" title="58"/>Run a wire from Arduino digital pin 7 to the lower-right row for the button on the breadboard, as shown in <a href="#figure4-23" id="figureanchor4-23">Figure 4-23</a>.&#13;
					<figure>&#13;
						<img alt="f04023" src="image_fi/500587c04/f04023.png"/>&#13;
						<figcaption>&#13;
							<p><a id="figure4-23">Figure 4-23</a>: Connecting the button to the digital input</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					</li>&#13;
				<li value="5">Insert the LED into the breadboard with the short leg (the cathode) connected to the GND column and the long leg (the anode) in a row to the right. Next, connect the 560 Ω resistor to the right of the LED, as shown in <a href="#figure4-24" id="figureanchor4-24">Figure 4-24</a>.&#13;
					<figure>&#13;
						<img alt="f04024" src="image_fi/500587c04/f04024.png"/>&#13;
						<figcaption>&#13;
							<p><a id="figure4-24">Figure 4-24</a>: Inserting the LED and 560 Ω resistor</p>&#13;
						</figcaption>&#13;
					</figure>&#13;
					</li>&#13;
				<li value="6"><span epub:type="pagebreak" id="Page_59" title="59"/>Connect a wire from the right side of the 560 Ω resistor to Arduino digital pin 3, as shown in <a href="#figure4-25" id="figureanchor4-25">Figure 4-25</a>.</li>&#13;
			</ol>&#13;
			<figure>&#13;
				<img alt="f04025" src="image_fi/500587c04/f04025.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-25">Figure 4-25</a>: Connecting the LED branch to the Arduino</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Before continuing, review the schematic for this circuit and check that your components are wired correctly. Compare the schematic against the actual wiring of the circuit.</p>&#13;
			<h3 id="h2-500587c04-0010">The Sketch</h3>&#13;
			<p class="BodyFirst">For the sketch, enter and upload <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>.</p>&#13;
			<pre><code>// Listing 4-1, Project 4 - Demonstrating a Digital Input<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #define LED 3 &#13;
#define BUTTON 7&#13;
void setup()&#13;
{<span aria-label="annotation2" class="CodeAnnotationHang">2</span>    pinMode(LED, OUTPUT);   // output for the LED  pinMode(BUTTON, INPUT); // input for the button&#13;
} &#13;
void loop()&#13;
{ if ( digitalRead(BUTTON) == HIGH ) { digitalWrite(LED, HIGH); // turn on the LED delay(500);              // wait for 0.5 seconds digitalWrite(LED, LOW);  // turn off the LED }&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Digital input</p>&#13;
			<p><span epub:type="pagebreak" id="Page_60" title="60"/>After you’ve uploaded your sketch, tap the push button briefly. Your LED should stay on for half a second.</p>&#13;
			<h3 id="h2-500587c04-0011">Understanding the Sketch</h3>&#13;
			<p class="BodyFirst">Let’s examine the new items in the sketch for Project 4—specifically, <code>#define</code>, digital input pins, and the <code>if</code> statement.</p>&#13;
			<h4 id="h3-500587c04-0012">Creating Constants with #define</h4>&#13;
			<p class="BodyFirst">Before <code>void setup()</code>, we use <code>#define</code> statements at <span aria-label="annotation1" class="CodeAnnotation">1</span> to create fixed values: when the sketch is compiled, the IDE replaces any instance of the defined word with the number that follows it. For example, when the IDE sees <code>LED</code> in the line at <span aria-label="annotation2" class="CodeAnnotation">2</span>, it replaces it with the number <code>3</code>. Notice that we do not use a semicolon after a <code>#define</code> value.</p>&#13;
			<p>&#13;
				We’re basically using the <code>#define</code> statements to label the digital pins for the LED and button in the sketch. It’s a good idea to label pin numbers and other fixed values (such as a time delay) in this way, because if the value is used repeatedly in the sketch, then you won’t have to edit the same item more than once. In this example, <code>LED</code> is used three times in the sketch, but to change this value we’d have to edit its definition only once in its <code>#define</code> statement.</p>&#13;
			<h4 id="h3-500587c04-0013">Reading Digital Input Pins</h4>&#13;
			<p class="BodyFirst">To read the status of a button, we first define a digital I/O pin as an input in <code>void setup()</code> using the following:</p>&#13;
			<pre><code>pinMode(BUTTON, INPUT); // input for button</code></pre>&#13;
			<p>&#13;
				Next, to discover whether the button is connecting a voltage through to the digital input (that is, it’s being pressed), we use <code>digitalRead(</code><var>pin</var><code>)</code>, where <var>pin</var> is the digital pin number to read. The function returns either <code>HIGH</code> (voltage is close to 5 V at the pin) or <code>LOW</code> (voltage is close to 0 V at the pin).</p>&#13;
			<h4 id="h3-500587c04-0014">Making Decisions with if</h4>&#13;
			<p class="BodyFirst">Using <code>if</code>, we can make decisions in our sketch and tell the Arduino to run different code depending on the decision. For example, in the sketch for Project 4, we used <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a>.</p>&#13;
			<pre><code>// Listing 4-2&#13;
if (digitalRead(BUTTON) == HIGH)&#13;
{ digitalWrite(LED, HIGH); // turn on the LED delay(500);              // wait for 0.5 seconds digitalWrite(LED, LOW);  // turn off the LED&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: A simple <var>if-then</var> example</p>&#13;
			<p><span epub:type="pagebreak" id="Page_61" title="61"/>The first line in this code snippet begins with <code>if</code> because it tests for a condition. If the condition is true (that is, if the voltage is <code>HIGH</code>), then it means that the button is pressed. The Arduino will then run the code that is inside the curly brackets.</p>&#13;
			<p>&#13;
				To determine whether the button is pressed (<code>digitalRead(BUTTON)</code> is set to <code>HIGH</code>), we use a <em>comparison operator</em>, a double equal sign (<code>==</code>). If we were to replace <code>==</code> with <code>!=</code> (not equal to) in the sketch, then the LED would turn off when the button is pressed instead. Try it and see.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							A common mistake is to use a single equal sign (<code>=</code>), which means “make equal to,” in a test statement instead of a double equal sign (<code>==</code>), which says “test whether it is equal to.” You may not get an error message, but your <code>if</code> statement may not work!</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<p>&#13;
				Once you’ve had some success, try changing the length of time that the light stays on, or go back to Project 3 <span class="xref" itemid="xref_target_on page 38 in Chapter 3">on page 38 in Chapter 3</span> and add a push button control. (Don’t disassemble this circuit, though; we’ll use it again in the next example.)</p>&#13;
			<h3 id="h2-500587c04-0012">Modifying Your Sketch: Making More Decisions with if-else</h3>&#13;
			<p class="BodyFirst">You can add another action to an <code>if</code> statement by using <code>else</code>. For example, if we rewrite <a href="#listing4-1">Listing 4-1</a> by adding an <code>else</code> clause, as shown in <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a>, then the LED will turn on <em>if</em> the button is pressed, or <em>else</em> it will be off. Using <code>else</code> forces the Arduino to run another section of code if the test in the <code>if</code> statement is not true.</p>&#13;
			<pre><code>// Listing 4-3&#13;
#define LED 3&#13;
#define BUTTON 7 &#13;
void setup()&#13;
{ pinMode(LED, OUTPUT);   // output for the LED pinMode(BUTTON, INPUT); // input for the button&#13;
} &#13;
void loop()&#13;
{ if ( digitalRead(BUTTON) == HIGH ) { digitalWrite(LED, HIGH); }<b>   else</b> { digitalWrite(LED, LOW); }&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: Adding <var>else</var></p>&#13;
			<h2 id="h1-500587c04-0005"><span epub:type="pagebreak" id="Page_62" title="62"/>Boolean Variables</h2>&#13;
			<p class="BodyFirst">Sometimes you need to record whether something is in either of only two states, such as on or off, or hot or cold. A <em>Boolean variable</em> is the legendary computer “bit” whose value can be only a zero (0, false) or one (1, true). As with any other variable, we need to declare it in order to use it:</p>&#13;
			<pre><code>boolean raining = true; // create the variable "raining" and first make it true</code></pre>&#13;
			<p>Within the sketch, you can change the state of a Boolean with a simple reassignment, such as this:</p>&#13;
			<pre><code>raining = false;</code></pre>&#13;
			<p>&#13;
				Because Boolean variables can only take on the values of true or false, they are well suited to making decisions using <code>if</code>. True/false Boolean comparisons work well with the comparison operators <code>!=</code> and <code>==</code>. Here’s an example:</p>&#13;
			<pre><code>if ( raining == true )&#13;
{ if ( summer != true ) { // it is raining and not summer }&#13;
}</code></pre>&#13;
			<h3 id="h2-500587c04-0013">Comparison Operators</h3>&#13;
			<p class="BodyFirst">We can use various operators to make decisions about two or more Boolean variables or other states. These include the operators <em>not</em> (<code>!</code>), <em>and</em> (<code>&amp;&amp;</code>), and <em>or</em> (<code>||</code>).</p>&#13;
			<h4 id="h3-500587c04-0015">The not Operator</h4>&#13;
			<p class="BodyFirst">The <em>not</em> operator is denoted by an exclamation mark (<code>!</code>). This operator is used as an abbreviation for checking whether something is <em>not true</em>. Here’s an example:</p>&#13;
			<pre><code>if ( !raining )&#13;
{ // it is not raining (raining == false)&#13;
}</code></pre>&#13;
			<h4 id="h3-500587c04-0016">The and Operator</h4>&#13;
			<p class="BodyFirst">The logical <em>and</em> operator is denoted by <code>&amp;&amp;</code>. Using <em>and</em> helps reduce the number of separate <code>if</code> tests. Here’s an example:</p>&#13;
			<pre><code><span epub:type="pagebreak" id="Page_63" title="63"/>if (( raining == true ) &amp;&amp; ( !summer ))&#13;
{ // it is raining and not summer (raining == true and summer == false)&#13;
}</code></pre>&#13;
			<h4 id="h3-500587c04-0017">The or Operator</h4>&#13;
			<p class="BodyFirst">The logical <em>or</em> operator is denoted by <code>||</code>. Using <em>or</em> is pretty intuitive. Here’s an example:</p>&#13;
			<pre><code>if (( raining == true ) || ( summer == true ))&#13;
{ // it is either raining or summer&#13;
}</code></pre>&#13;
			<h3 id="h2-500587c04-0014">Making Two or More Comparisons</h3>&#13;
			<p class="BodyFirst">You can also make two or more comparisons using the same <code>if</code> statement. Here’s an example:</p>&#13;
			<pre><code>if ( snow == true &amp;&amp; rain == true &amp;&amp; !hot )&#13;
{ // it is snowing and raining and not hot&#13;
}</code></pre>&#13;
			<p>&#13;
				And you can use parentheses to set the order of operation. In the next example, the comparison in the parentheses is checked first and given a true or false state, and then that condition is subjected to the remaining test in the <code>if</code> statement:</p>&#13;
			<pre><code>if (( snow == true || rain == true ) &amp;&amp; hot == false))&#13;
{&#13;
// it is either snowing or raining, and not hot&#13;
}</code></pre>&#13;
			<p>&#13;
				Lastly, just like the examples of the not (<code>!</code>) operator before a value, simple true/false tests can be performed without requiring <code>== true</code> or <code>== false</code> in each test. The following code has the same effect as the preceding example:</p>&#13;
			<pre><code>if (( snow || rain ) &amp;&amp; !hot )&#13;
{ // it is either snowing or raining, and not hot // ( snow is true OR rain is true ) AND it is not hot&#13;
}</code></pre>&#13;
			<p>As you can see, it’s possible to have the Arduino make a multitude of decisions using Boolean variables and comparison operators. Once you move on to more complex projects, this will become very useful.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c04-0006"><span><span epub:type="pagebreak" id="Page_64" title="64"/>Project #5: Controlling Traffic</span></h2>&#13;
			<p class="BodyFirst">Now let’s put our newfound knowledge to use by solving a hypothetical problem. As the town planners for a rural county, we have a problem with a single-lane bridge that crosses the river. Every week, one or two accidents occur at night, when tired drivers rush across the bridge without first stopping to see if the road is clear. We have suggested that traffic lights be installed, but the mayor wants to see them demonstrated before signing off on the purchase. We could rent temporary lights, but they’re expensive. Instead, we’ve decided to build a model of the bridge with working traffic lights using LEDs and an Arduino.</p>&#13;
			<h3 id="h2-500587c04-0015">The Goal</h3>&#13;
			<p class="BodyFirst">Our goal is to install three-color traffic lights at each end of the single-lane bridge. The lights allow traffic to flow in only one direction at a time. When sensors located at either end of the bridge detect a car waiting at a red light, the lights will change and allow the traffic to flow in the opposite direction.</p>&#13;
			<h3 id="h2-500587c04-0016">The Algorithm</h3>&#13;
			<p class="BodyFirst">We’ll use two buttons to simulate the vehicle sensors at each end of the bridge. Each set of lights will have red, yellow, and green LEDs. Initially, the system will allow traffic to flow from west to east, so the west-facing lights will be set to green and the east-facing lights will be set to red.</p>&#13;
			<p>When a vehicle approaches the bridge (modeled by pressing the button) and the light is red, the system will turn the light on the opposite side from green to yellow to red, and then wait a set period of time to allow any vehicles already on the bridge to finish crossing. Next, the yellow light on the waiting vehicle’s side will blink as a “get ready” notice for the driver, and finally the light will change to green. The light will remain green until a vehicle approaches the other side, at which point the process repeats.</p>&#13;
			<h3 id="h2-500587c04-0017">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Two red LEDs (LED1 and LED2)</li>&#13;
				<li>Two yellow LEDs (LED3 and LED4)</li>&#13;
				<li>Two green LEDs (LED5 and LED6)</li>&#13;
				<li>Six 560 Ω resistors (R1 to R6)</li>&#13;
				<li>Two 10 kΩ resistors (R7 and R8)</li>&#13;
				<li>Two 100 nF capacitors (C1 and C2)</li>&#13;
				<li><span epub:type="pagebreak" id="Page_65" title="65"/>Two push buttons (S1 and S2)</li>&#13;
				<li>One medium-sized breadboard</li>&#13;
				<li>Arduino and USB cable</li>&#13;
				<li>Various connecting wires</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c04-0018">The Schematic</h3>&#13;
			<p class="BodyFirst">Because we’re controlling only six LEDs and receiving input from two buttons, the design will not be too difficult. <a href="#figure4-26" id="figureanchor4-26">Figure 4-26</a> shows the schematic for our project.</p>&#13;
			<figure>&#13;
				<img alt="f04026" src="image_fi/500587c04/f04026.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-26">Figure 4-26</a>: Schematic for Project 5</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>This circuit is basically a more elaborate version of the button and LED circuit in Project 4, with resistors, more LEDs, and another button.</p>&#13;
			<p>&#13;
				Be sure that the LEDs are inserted in the correct direction: the resistors connect to LED anodes, and the LED cathodes connect to the Arduino GND pin, as shown in <a href="#figure4-27" id="figureanchor4-27">Figure 4-27</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_66" title="66"/>&#13;
				<figure>&#13;
				<img alt="f04027" src="image_fi/500587c04/f04027.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-27">Figure 4-27</a>: The completed circuit</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c04-0019">The Sketch</h3>&#13;
			<p class="BodyFirst">And now for the sketch. Can you see how it matches our algorithm?</p>&#13;
			<pre><code>// Project 5 - Controlling Traffic &#13;
// define the pins that the buttons and lights are connected to:<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #define westButton 3 &#13;
#define eastButton 13&#13;
#define westRed 2&#13;
#define westYellow 1 &#13;
#define westGreen 0&#13;
#define eastRed 12&#13;
#define eastYellow 11&#13;
#define eastGreen 10 &#13;
#define yellowBlinkTime 500 // 0.5 seconds for yellow light blink <span aria-label="annotation2" class="CodeAnnotationHang">2</span> boolean trafficWest = true; // west = true, east = false<span aria-label="annotation3" class="CodeAnnotationHang">3</span> int flowTime = 10000;       // amount of time to let traffic flow<span aria-label="annotation4" class="CodeAnnotationHang">4</span> int changeDelay = 2000;     // amount of time between color changes &#13;
void setup()&#13;
{ // set up the digital I/O pins pinMode(westButton, INPUT); pinMode(eastButton, INPUT); pinMode(westRed, OUTPUT); pinMode(westYellow, OUTPUT);<span epub:type="pagebreak" id="Page_67" title="67"/>   pinMode(westGreen, OUTPUT); pinMode(eastRed, OUTPUT); pinMode(eastYellow, OUTPUT); pinMode(eastGreen, OUTPUT); // set initial state for lights - west side is green first digitalWrite(westRed, LOW); digitalWrite(westYellow, LOW); digitalWrite(westGreen, HIGH);  digitalWrite(eastRed, HIGH); digitalWrite(eastYellow, LOW); digitalWrite(eastGreen, LOW);&#13;
} &#13;
void loop()&#13;
{ if ( digitalRead(westButton) == HIGH ) // request west&gt;east traffic flow { if ( trafficWest != true )  // only continue if traffic flowing in the opposite (east) direction { trafficWest = true; // change traffic flow flag to west&gt;east delay(flowTime);    // give time for traffic to flow  digitalWrite(eastGreen, LOW); // change east-facing lights from green  // to yellow to red digitalWrite(eastYellow, HIGH); delay(changeDelay); digitalWrite(eastYellow, LOW); digitalWrite(eastRed, HIGH); delay(changeDelay);  for ( int a = 0; a &lt; 5; a++ ) // blink yellow light { digitalWrite(westYellow, LOW); delay(yellowBlinkTime); digitalWrite(westYellow, HIGH); delay(yellowBlinkTime); } digitalWrite(westYellow, LOW); digitalWrite(westRed, LOW); // change west-facing lights from red // to green digitalWrite(westGreen, HIGH);  } } if ( digitalRead(eastButton) == HIGH ) // request east&gt;west traffic flow { if ( trafficWest == true )  // only continue if traffic flow is in the opposite (west) direction { trafficWest = false; // change traffic flow flag to east&gt;west delay(flowTime);     // give time for traffic to flow  digitalWrite(westGreen, LOW);  // change west-facing lights from green to yellow to red digitalWrite(westYellow, HIGH); delay(changeDelay); digitalWrite(westYellow, LOW); digitalWrite(westRed, HIGH);<span epub:type="pagebreak" id="Page_68" title="68"/>      delay(changeDelay);  for ( int a = 0 ; a &lt; 5 ; a++ ) // blink yellow light  { digitalWrite(eastYellow, LOW); delay(yellowBlinkTime); digitalWrite(eastYellow, HIGH); delay(yellowBlinkTime); }  digitalWrite(eastYellow, LOW);  digitalWrite(eastRed, LOW); // change east-facing lights from red // to green digitalWrite(eastGreen, HIGH);  } }&#13;
}</code></pre>&#13;
			<p>&#13;
				Our sketch starts by using <code>#define</code> at <span aria-label="annotation1" class="CodeAnnotation">1</span> to associate digital pin numbers with labels for all the LEDs used, as well as the two buttons. We have red, yellow, and green LEDs and a button each for the west and east sides of the bridge. The Boolean variable <code>trafficWest</code> at <span aria-label="annotation2" class="CodeAnnotation">2</span> is used to keep track of which way the traffic is flowing—<code>true</code> is west to east, and <code>false</code> is east to west.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							Notice that <code>trafficWest</code> is a single Boolean variable with the traffic direction set as either <code>true</code> or <code>false</code>. Having a single variable like this instead of two (one for east and one for west) ensures that both directions cannot accidentally be true at the same time, which helps avoid a crash!</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<p>&#13;
				The integer variable <code>flowTime</code> at <span aria-label="annotation3" class="CodeAnnotation">3</span> is the minimum period of time that vehicles have to cross the bridge. When a vehicle pulls up at a red light, the system extends this period to give the opposing traffic time to cross the bridge. The integer variable <code>changeDelay</code> at <span aria-label="annotation4" class="CodeAnnotation">4</span> is the elapsed time between changes of color from green to yellow to red.</p>&#13;
			<p>&#13;
				Before the sketch enters the <code>void loop()</code> section, it is set for traffic to flow from west to east in <code>void setup()</code>.</p>&#13;
			<h3 id="h2-500587c04-0020">Running the Sketch</h3>&#13;
			<p class="BodyFirst">Once it’s running, the sketch does nothing until one of the buttons is pressed. When the east button is pressed, the line:</p>&#13;
			<pre><code>if ( trafficWest == true )</code></pre>&#13;
			<p class="BodyContinued">ensures that the lights change only if the traffic is heading in the opposite direction. The rest of the <code>void loop()</code> section is composed of a simple sequence of waiting and then of turning on and off various LEDs to simulate the traffic lights’ operation.</p>&#13;
			<h2 id="h1-500587c04-0007"><span epub:type="pagebreak" id="Page_69" title="69"/>Analog vs. Digital Signals</h2>&#13;
			<p class="BodyFirst">In this section you’ll learn the difference between digital and analog signals, and you’ll learn how to measure analog signals with the analog input pins.</p>&#13;
			<p>&#13;
				Until now, our sketches have been using digital electrical signals, with just two discrete levels. Specifically, we used <code>digitalWrite(</code><var>pin</var><code>, HIGH)</code> and <code>digitalWrite(</code><var>pin</var><code>, LOW)</code> to blink an LED and <code>digitalRead()</code> to measure whether a digital pin had a voltage applied to it (<code>HIGH</code>) or not (<code>LOW</code>). <a href="#figure4-28" id="figureanchor4-28">Figure 4-28</a> is a visual representation of a digital signal that alternates between high and low.</p>&#13;
			<figure>&#13;
				<img alt="f04028" src="image_fi/500587c04/f04028.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-28">Figure 4-28</a>: A digital signal, with highs appearing as horizontal lines at the top and lows appearing at the bottom</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Unlike digital signals, analog signals can vary with an indefinite number of steps between high and low. For example, <a href="#figure4-29" id="figureanchor4-29">Figure 4-29</a> shows the analog signal of a sine wave. Notice that as time progresses, the voltage floats fluidly between high and low levels.</p>&#13;
			<figure>&#13;
				<img alt="f04029" src="image_fi/500587c04/f04029.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-29">Figure 4-29</a>: An analog signal of a sine wave</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<span epub:type="pagebreak" id="Page_70" title="70"/>&#13;
			<figure>&#13;
				<img alt="f04030" src="image_fi/500587c04/f04030.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-30">Figure 4-30</a>: Analog inputs on the Arduino Uno</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				With our Arduino, high is closer to 5 V and low is closer to 0 V, or GND. We can measure the voltage values of an analog signal with our Arduino using the six analog inputs shown in <a href="#figure4-30" id="figureanchor4-30">Figure 4-30</a>. These analog inputs can safely measure voltages from 0 (GND) to no more than 5 V.</p>&#13;
			<p>&#13;
				If you use the function <code>analogRead()</code>, then the Arduino will return a number between 0 and 1,023 in proportion to the voltage applied to the analog pin. For example, you might use <code>analogRead()</code> to store the value of analog pin 0 in the integer variable <code>a</code>, as shown here:</p>&#13;
			<pre><code>a = analogRead(0); // read analog input pin 0 (A0)&#13;
// returns 0 to 1023, which is usually 0.000 to 4.995 volts</code></pre>&#13;
			<h2 class="HeadProject" id="h1-500587c04-0008"><span>Project #6: Creating a Single-Cell Battery Tester</span></h2>&#13;
			<p class="BodyFirst">Although the popularity and use of cell batteries has declined, most people still have a few devices around the house, such as remote controls, clocks, or children’s toys, that use AA, AAA, C, or D cell batteries. These batteries carry much less than 5 V, so we can measure a cell’s voltage with our Arduino to determine the state of the cell. In this project, we’ll create a battery tester.</p>&#13;
			<h3 id="h2-500587c04-0021">The Goal</h3>&#13;
			<p class="BodyFirst">Single-cell batteries such as AAs usually have a voltage of about 1.6 V when new, which decreases with use and age. We will measure the voltage and express the battery condition visually with LEDs. We’ll use the reading from <code>analogRead()</code>, which we will convert to volts. The maximum voltage that can be read is 5 V, so we divide 5 by 1,024 (the number of possible values), which equals 0.0048. We multiply the value returned by <code>analogRead()</code> by this number to get the reading in volts. For example, if <code>analogRead()</code> returns 512, then we multiply that reading by 0.0048, which equals 2.4576 V.</p>&#13;
			<h3 id="h2-500587c04-0022">The Algorithm</h3>&#13;
			<p class="BodyFirst">Here’s the algorithm for our battery tester:</p>&#13;
			<ol class="decimal">&#13;
				<li value="1">Read from analog pin 0.</li>&#13;
				<li value="2">Multiply the reading by 0.0048 to create a voltage value.</li>&#13;
				<li value="3">If the voltage is greater than or equal to 1.6 V, briefly turn on a green LED.</li>&#13;
				<li value="4">If the voltage is greater than 1.4 V <em>and</em> less than 1.6 V, briefly turn on a yellow LED.</li>&#13;
				<li value="5">If the voltage is less than 1.4 V, briefly turn on a red LED.</li>&#13;
				<li value="6">Repeat indefinitely.</li>&#13;
			</ol>&#13;
			<h3 id="h2-500587c04-0023"><span epub:type="pagebreak" id="Page_71" title="71"/>The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Three 560 Ω resistors (R1 to R3)</li>&#13;
				<li>One green LED (LED1)</li>&#13;
				<li>One yellow LED (LED2)</li>&#13;
				<li>One red LED (LED3)</li>&#13;
				<li>One breadboard</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c04-0024">The Schematic</h3>&#13;
			<p class="BodyFirst">The schematic for the single-cell battery tester circuit is shown in <a href="#figure4-31" id="figureanchor4-31">Figure 4-31</a>. On the left side, notice the two terminals, labeled <em>+</em> and <em>–.</em> Connect the <em>matching</em> sides of the single-cell battery to be tested at those points. Positive should connect to positive, and negative should connect to negative.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">WARNING</span></h2>&#13;
					<p>	Under no circumstances should you measure anything larger than 5 V, nor should you connect positive to negative, or vice versa. Doing these things would damage your Arduino board.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<figure>&#13;
				<img alt="f04031" src="image_fi/500587c04/f04031.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-31">Figure 4-31</a>: Schematic for Project 6</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c04-0025"><span epub:type="pagebreak" id="Page_72" title="72"/>The Sketch</h3>&#13;
			<p class="BodyFirst">Now for the sketch. Since analog values can drift between integers, we’re going to use a new type of variable called a <em>float</em>, which can contain fractional or decimal values:</p>&#13;
			<pre><code>// Project 6 - Creating a Single-Cell Battery Tester&#13;
#define newLED 2 // green LED &#13;
#define okLED 4  // yellow LED &#13;
#define oldLED 6 // red LED &#13;
int analogValue = 0;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> float voltage = 0; &#13;
int ledDelay = 2000; &#13;
void setup()&#13;
{ pinMode(newLED, OUTPUT); pinMode(okLED, OUTPUT); pinMode(oldLED, OUTPUT);&#13;
} &#13;
void loop()&#13;
{<span aria-label="annotation2" class="CodeAnnotationHang">2</span>    analogValue = analogRead(0); <span aria-label="annotation3" class="CodeAnnotationHang">3</span>    voltage = 0.0048*analogValue; <span aria-label="annotation4" class="CodeAnnotationHang">4</span>    if ( voltage &gt;= 1.6 )  { digitalWrite(newLED, HIGH); delay(ledDelay); digitalWrite(newLED, LOW); } <span aria-label="annotation5" class="CodeAnnotationHang">5</span>    else if ( (voltage &lt; 1.6) &amp;&amp; (voltage) &gt; 1.4 )  { digitalWrite(okLED, HIGH); delay(ledDelay); digitalWrite(okLED, LOW); } <span aria-label="annotation6" class="CodeAnnotationHang">6</span>     else if ( voltage &lt;= 1.4 )  { digitalWrite(oldLED, HIGH); delay(ledDelay); digitalWrite(oldLED, LOW); }&#13;
}</code></pre>&#13;
			<p>&#13;
				In this sketch, the Arduino takes the value measured by analog pin 0 at <span aria-label="annotation2" class="CodeAnnotation">2</span> and converts this to a voltage at <span aria-label="annotation3" class="CodeAnnotation">3</span>. You’ll learn more about the new type of variable, the <code>float</code> at <span aria-label="annotation1" class="CodeAnnotation">1</span>, in the next section, which discusses doing arithmetic with an Arduino and using comparison operators to compare numbers.</p>&#13;
			<h2 id="h1-500587c04-0009"><span epub:type="pagebreak" id="Page_73" title="73"/>Doing Arithmetic with an Arduino</h2>&#13;
			<p class="BodyFirst">Like a pocket calculator, the Arduino can perform calculations such as multiplication, division, addition, and subtraction. Here are some examples:</p>&#13;
			<pre><code>a = 100;&#13;
b = a + 20;&#13;
c = b - 200;&#13;
d = c + 80; // d will equal 0</code></pre>&#13;
			<h3 id="h2-500587c04-0026">Float Variables</h3>&#13;
			<p class="BodyFirst">When you need to deal with numbers with a decimal point, you can use the variable type <code>float</code>. The values that can be stored in a <code>float</code> fall between 3.4028235 × 10<sup>38</sup> and −3.4028235 × 10<sup>38</sup> and are generally limited to six or seven decimal places of precision. You can mix integers and <code>float</code> numbers in your calculations. For example, you could add the <code>float</code> number <code>f</code> to the integer <code>a</code> and store the sum as the <code>float</code> variable <code>g</code>:</p>&#13;
			<pre><code>int a = 100;&#13;
float f;&#13;
float g; &#13;
f = a / 3; // f = 33.333333&#13;
g = a + f; // g = 133.333333</code></pre>&#13;
			<h3 id="h2-500587c04-0027">Comparison Operators for Calculations</h3>&#13;
			<p class="BodyFirst">We used comparison operators such as <code>==</code> and <code>!=</code> with <code>if</code> statements and digital input signals in Project 5. In addition to these operators, we can use the following to compare numbers or numerical variables:</p>&#13;
			<ol class="none">&#13;
				<li><code class="bold">&lt;</code>  Less than</li>&#13;
				<li><code class="bold">&gt;</code>  Greater than</li>&#13;
				<li><code class="bold">&lt;=</code>  Less than or equal to</li>&#13;
				<li><code class="bold">&gt;=</code>  Greater than or equal to</li>&#13;
			</ol>&#13;
			<p>&#13;
				We used these operators to compare numbers in lines <span aria-label="annotation4" class="CodeAnnotation">4</span>, <span aria-label="annotation5" class="CodeAnnotation">5</span>, and <span aria-label="annotation6" class="CodeAnnotation">6</span> in the sketch for Project 6.</p>&#13;
			<h2 id="h1-500587c04-0010">Improving Analog Measurement Precision with a Reference Voltage</h2>&#13;
			<p class="BodyFirst">As demonstrated in Project 6, the <code>analogRead()</code> function returns a value proportional to a voltage between 0 and 5 V. The upper value (5 V) is the <em>reference voltage</em>, the maximum voltage that the Arduino analog inputs will accept and return the highest value for (1,023).</p>&#13;
			<p><span epub:type="pagebreak" id="Page_74" title="74"/>To increase precision while reading even lower voltages, we can use a lower reference voltage. For example, when the reference voltage is 5 V, <code>analogRead()</code> represents this with a value from 0 to 1,023. However, if we needed to measure only a voltage with a maximum of 2 V, then we could alter the Arduino output to represent 2 V using the 0 to 1,023 range to allow for more precise measurement. You can do this with either an external or internal reference voltage, as discussed next.</p>&#13;
			<h3 id="h2-500587c04-0028">Using an External Reference Voltage</h3>&#13;
			<p class="BodyFirst">The first method of using a reference voltage is with the <em>AREF</em> (<em>a</em>nalog <em>ref</em>erence) pin, as shown in <a href="#figure4-32" id="figureanchor4-32">Figure 4-32</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04032" src="image_fi/500587c04/f04032.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-32">Figure 4-32</a>: The Arduino Uno AREF pin</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				We can introduce a new reference voltage by connecting the voltage to the AREF pin and the matching GND to the Arduino’s GND. Note that this can lower the reference voltage but will not raise it, because the reference voltage connected to an Arduino Uno must not exceed 5 V. A simple way to set a lower reference voltage is by creating a <em>voltage divider</em> with two resistors, as shown in <a href="#figure4-33" id="figureanchor4-33">Figure 4-33</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04033" src="image_fi/500587c04/f04033.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-33">Figure 4-33</a>: A voltage divider circuit</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				The values of <em>R1</em> and <em>R2</em> will determine the reference voltage according to the formula in <a href="#figure4-34" id="figureanchor4-34">Figure 4-34</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_75" title="75"/>&#13;
				<figure>&#13;
				<img alt="f04034" src="image_fi/500587c04/f04034.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-34">Figure 4-34</a>: Reference voltage formula</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				In the formula, <em>V</em><sub>out</sub> is the reference voltage, and <em>V</em><sub>in</sub> is the input voltage—in this case, 5 V. <em>R1</em> and <em>R2</em> are the resistor values in ohms.</p>&#13;
			<p>&#13;
				The simplest way to divide the voltage is to split <em>V</em><sub>in</sub> in half by setting <em>R1</em> and <em>R2</em> to the same value—for example, 10 kΩ each. When you’re doing this, it’s best to use the lowest-tolerance resistors you can find, such as 1 percent; confirm their true resistance values with a multimeter and use those confirmed values in the calculation. Furthermore, it’s a very good idea to place a 100 nF capacitor between AREF and GND to avoid a noisy AREF and prevent unstable analog readings.</p>&#13;
			<p>&#13;
				When using an external reference voltage, insert the following line in the <code>void setup()</code> section of your sketch:</p>&#13;
			<pre><code><b>analogReference(EXTERNAL); // select AREF pin for reference voltage</b></code></pre>&#13;
			<h3 id="h2-500587c04-0029">Using the Internal Reference Voltage</h3>&#13;
			<p class="BodyFirst">The Arduino Uno also has an internal 1.1 V reference voltage. If this meets your needs, no hardware changes are required. Just add this line to <code>void setup()</code>:</p>&#13;
			<pre><code><b>analogReference(INTERNAL); // select internal 1.1 V reference voltage</b></code></pre>&#13;
			<h2 id="h1-500587c04-0011">The Variable Resistor</h2>&#13;
			<p class="BodyFirst">Variable resistors, also known as <em>potentiometers</em>, can generally be adjusted from 0 Ω up to their rated value. Their schematic symbol is shown in <a href="#figure4-35" id="figureanchor4-35">Figure 4-35</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04035" src="image_fi/500587c04/f04035.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-35">Figure 4-35</a>: Variable resistor (potentiometer) symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Variable resistors have three pin connections: one in the center pin and one on each side. As the shaft of a variable resistor turns, it increases the resistance between one side and the center and decreases the resistance between the opposite side and the center.</p>&#13;
			<p>&#13;
				Variable resistors can be either <em>linear</em> or <em>logarithmic</em>. The resistance of linear models changes at a constant rate as they turn, while the resistance of logarithmic models changes slowly at first and then increases rapidly. Logarithmic potentiometers are used more often in audio amplifier circuits, <span epub:type="pagebreak" id="Page_76" title="76"/>because they model the human hearing response. You can generally identify whether a potentiometer is logarithmic or linear via the marking on the rear. Most will have either an <em>A</em> or a <em>B</em> next to the resistance value: <em>A</em> for logarithmic, <em>B</em> for linear. Most Arduino projects use linear variable resistors, such as the one shown in <a href="#figure4-36" id="figureanchor4-36">Figure 4-36</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04036" src="image_fi/500587c04/f04036.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-36">Figure 4-36</a>: A typical linear variable resistor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				You can also get miniature versions of variable resistors, known as <em>trimpots</em> or <em>trimmers</em> (see <a href="#figure4-37" id="figureanchor4-37">Figure 4-37</a>). Because of their size, trimpots are useful for making adjustments in circuits, but they’re also very useful for breadboard work because they can be slotted in.</p>&#13;
			<figure>&#13;
				<img alt="f04037" src="image_fi/500587c04/f04037.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-37">Figure 4-37</a>: Various trimpots</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note"><span epub:type="pagebreak" id="Page_77" title="77"/>&#13;
				<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							When shopping for trimpots, take note of the type. Often you will want one that is easy to adjust with a screwdriver that you have on hand. The enclosed types, pictured in <a href="#figure4-37">Figure 4-37</a>, last longer than the cheaper, open contact types.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h2 id="h1-500587c04-0012">Piezoelectric Buzzers</h2>&#13;
			<p class="BodyFirst">A <em>piezoelectric element</em> (<em>piezo</em> for short), or buzzer, is a small, round device that can be used to generate loud and annoying noises that are perfect for alarms—or for having fun. <a href="#figure4-38" id="figureanchor4-38">Figure 4-38</a> shows a common example, the TDK PS1240, next to an American quarter, to give you an idea of its size.</p>&#13;
			<figure>&#13;
				<img alt="f04038" src="image_fi/500587c04/f04038.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-38">Figure 4-38</a>: The TDK PS1240 piezo</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Piezos contain a very thin plate inside the housing that moves when an electrical current is applied. When a pulsed current is applied (such as on . . . off . . . on . . . off), the plate vibrates and generates sound waves.</p>&#13;
			<p>It’s simple to use piezos with the Arduino because they can be turned on and off just like an LED. The piezo elements are not polarized and can be connected in either direction.</p>&#13;
			<h3 id="h2-500587c04-0030">Piezo Schematic</h3>&#13;
			<p class="BodyFirst">The schematic symbol for the piezo looks like a loudspeaker (<a href="#figure4-39" id="figureanchor4-39">Figure 4-39</a>), which makes it easy to recognize.</p>&#13;
			<figure>&#13;
				<img alt="f04039" src="image_fi/500587c04/f04039.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-39">Figure 4-39</a>: Piezo schematic symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note"><span epub:type="pagebreak" id="Page_78" title="78"/>&#13;
				<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>&#13;
							When shopping for a piezo for this project, be sure to get the <em>piezo element only</em> type. Some buzzer types look like <a href="#figure4-38">Figure 4-38</a> but include a tone-generating circuit built into the case; we don’t want those because we’re going to drive our tone directly from the Arduino.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h2 class="HeadProject" id="h1-500587c04-0013"><span>Project #7: Trying Out a Piezo Buzzer</span></h2>&#13;
			<p class="BodyFirst">If you have a piezo handy and want to try it out, first connect it between Arduino GND and digital pins D3 to D0 inclusive. Then upload the following demonstration sketch to your Arduino:</p>&#13;
			<pre><code>// Project 7 - Trying Out a Piezo Buzzer&#13;
#define PIEZO 3 // pin 3 is capable of PWM output to drive tones&#13;
int del = 500;&#13;
void setup()&#13;
{ pinMode(PIEZO, OUTPUT);&#13;
} &#13;
void loop()&#13;
{<span aria-label="annotation1" class="CodeAnnotationHang">1</span>    analogWrite(PIEZO, 128);  // 50 percent duty cycle tone to the piezo delay(del); digitalWrite(PIEZO, LOW); // turn the piezo off delay(del);&#13;
}</code></pre>&#13;
			<p>&#13;
				This sketch uses pulse-width modulation on digital pin 3. If you change the duty cycle in the <code>analogWrite()</code> function (currently it’s 128, which is 50 percent on) at <span aria-label="annotation1" class="CodeAnnotation">1</span>, you can alter the sound of the buzzer.</p>&#13;
			<p>&#13;
				To increase the volume of your piezo, increase the voltage applied to it. The voltage is currently limited to 5 V, but the buzzer would be much louder at 9 or 12 V. Because higher voltages can’t be sourced from the Arduino, you would need to use an external power source for the buzzer, such as a 9 V battery, and then switch the power into the buzzer using a BC548 transistor as an electronic switch. You can use the same sketch with the schematic shown in <a href="#figure4-40" id="figureanchor4-40">Figure 4-40</a>.</p>&#13;
			<p>The part of the schematic labeled 12 V will be the positive side of the higher-power supply, whose negative side will connect to the Arduino GND pin.</p>&#13;
			<span epub:type="pagebreak" id="Page_79" title="79"/>&#13;
			<figure>&#13;
				<img alt="f04040" src="image_fi/500587c04/f04040.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-40">Figure 4-40</a>: Schematic for Project 7</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 class="HeadProject" id="h1-500587c04-0014"><span>Project #8: Creating a Quick-Read Thermometer</span></h2>&#13;
			<p class="BodyFirst">Temperature can be represented by an analog signal. We can measure temperature using the TMP36 voltage output temperature sensor made by Analog Devices (<a class="LinkURL" href="http://www.analog.com/tmp36/">http://www.analog.com/tmp36/</a>), shown in <a href="#figure4-41" id="figureanchor4-41">Figure 4-41</a>.</p>&#13;
			<figure>&#13;
				<img alt="f04041" src="image_fi/500587c04/f04041.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-41">Figure 4-41</a>: TMP36 temperature sensor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Notice that the TMP36 looks just like the BC548 transistor we worked with in the relay control circuit in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. The TMP36 outputs <span epub:type="pagebreak" id="Page_80" title="80"/>a voltage that is proportional to the temperature, so you can determine the current temperature using a simple conversion. For example, at 25 degrees Celsius, the output voltage is 750 mV, and each change in temperature of 1 degree results in a change of 10 mV. The TMP36 can measure temperatures between −40 and 125 degrees Celsius.</p>&#13;
			<p>&#13;
				The function <code>analogRead()</code> will return a value between 0 and 1,023, which corresponds to a voltage between 0 and just under 5,000 mV (5 V). If we multiply the output of <code>analogRead()</code> by (5,000/1,024), we will get the actual voltage returned by the sensor. Next, we subtract 500 (an offset used by the TMP36 to allow for temperatures below 0) and then divide by 10, which leaves us with the temperature in degrees Celsius. If you work in Fahrenheit, then multiply the Celsius value by 1.8 and add 32 to the result.</p>&#13;
			<h3 id="h2-500587c04-0031">The Goal</h3>&#13;
			<p class="BodyFirst">In this project, we’ll use the TMP36 to create a quick-read thermometer. When the temperature falls below 20 degrees Celsius, a blue LED turns on; when the temperature is between 20 and 26 degrees, a green LED turns on; and when the temperature is above 26 degrees, a red LED turns on.</p>&#13;
			<h3 id="h2-500587c04-0032">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Three 560 Ω resistors (R1 to R3)</li>&#13;
				<li>One red LED (LED1)</li>&#13;
				<li>One green LED (LED2)</li>&#13;
				<li>One blue LED (LED3)</li>&#13;
				<li>One TMP36 temperature sensor</li>&#13;
				<li>One breadboard</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c04-0033">The Schematic</h3>&#13;
			<p class="BodyFirst">The circuit is simple. When you’re looking at the labeled side of the TMP36, the pin on the left connects to the 5 V input, the center pin is the voltage output, and the pin on the right connects to GND, as shown in <a href="#figure4-42" id="figureanchor4-42">Figure 4-42</a>.</p>&#13;
			<span epub:type="pagebreak" id="Page_81" title="81"/>&#13;
			<figure>&#13;
				<img alt="f04042" src="image_fi/500587c04/f04042.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure4-42">Figure 4-42</a>: Schematic for Project 8</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c04-0034">The Sketch</h3>&#13;
			<p class="BodyFirst">And now for the sketch:</p>&#13;
			<pre><code>// Project 8 - Creating a Quick-Read Thermometer &#13;
// define the pins that the LEDs are connected to:&#13;
#define HOT 6&#13;
#define NORMAL 4&#13;
#define COLD 2 &#13;
float voltage = 0;&#13;
float celsius = 0;&#13;
float hotTemp = 26;&#13;
float coldTemp = 20;&#13;
float sensor = 0; &#13;
void setup()&#13;
{ pinMode(HOT, OUTPUT); pinMode(NORMAL, OUTPUT); pinMode(COLD, OUTPUT);&#13;
} &#13;
void loop()<span epub:type="pagebreak" id="Page_82" title="82"/>{ // read the temperature sensor and convert the result to degrees Celsius<span aria-label="annotation1" class="CodeAnnotationHang">1</span>    sensor = analogRead(0);  voltage = ( sensor * 5000 ) / 1024; // convert raw sensor value to // millivolts voltage = voltage - 500; // remove voltage offset celsius = voltage / 10;  // convert millivolts to Celsius // act on temperature range<span aria-label="annotation2" class="CodeAnnotationHang">2</span>    if ( celsius &lt; coldTemp )  { digitalWrite(COLD, HIGH); delay(1000);  digitalWrite(COLD, LOW); }<span aria-label="annotation3" class="CodeAnnotationHang">3</span>    else if ( celsius &gt; coldTemp &amp;&amp; celsius &lt;= hotTemp )  { digitalWrite(NORMAL, HIGH); delay(1000); digitalWrite(NORMAL, LOW); } else { // celsius is &gt; hotTemp digitalWrite(HOT, HIGH); delay(1000); digitalWrite(HOT, LOW); }&#13;
}</code></pre>&#13;
			<p>&#13;
				The sketch first reads the voltage from the TMP36 and converts it to a temperature in degrees Celsius at <span aria-label="annotation1" class="CodeAnnotation">1</span>. Next, using the <code>if-else</code> statements at <span aria-label="annotation2" class="CodeAnnotation">2</span> and <span aria-label="annotation3" class="CodeAnnotation">3</span>, the code compares the current temperature against the values for hot and cold and turns on the appropriate LED. The <code>delay(1000)</code> statements are used to prevent the lights from flashing on and off too quickly if the temperature fluctuates rapidly between two ranges.</p>&#13;
			<p>You can experiment with the thermometer by blowing cool air over it to lower the temperature or by rubbing two fingers over the TMP36’s body to generate heat.</p>&#13;
			<h2 id="h1-500587c04-0015">Looking Ahead</h2>&#13;
			<p class="BodyFirst">And Chapter 4 comes to a close. You now have a lot more tools to work with, including digital inputs and outputs, new types of variables, and various mathematical functions. In the next chapter, you will have a lot more fun with LEDs, learn to create your own functions, build a computer game and electronic dice, and much more.</p>&#13;
		</section>&#13;
	</body></html>