- en: '<samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CASE
    STUDY: A DETECTION-AWARE ATTACK</samp>'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">案例研究：检测意识攻击</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: 'So far, we’ve covered the design of EDRs, the logic of their components, and
    the internal workings of their sensors. Still, we’ve missed one critical piece
    of the puzzle: how to apply this information in the real world. In this final
    chapter, we’ll systematically analyze the actions we’d like to take against target
    systems and determine our risk of being detected.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 EDR 的设计、其组件的逻辑以及传感器的内部工作原理。然而，我们错过了一个至关重要的环节：如何在现实世界中应用这些信息。在本章中，我们将系统地分析我们希望针对目标系统采取的行动，并评估被检测到的风险。
- en: We’ll target a fictional company, Binford Tools, inventor of the Binford 6100
    left-handed screwdriver. Binford has asked us to identify an attack path from
    a compromised user workstation to a database holding the proprietary design information
    for the 6100\. We’re to be as stealthy as possible so that the company can see
    what its EDR is able to detect. Let’s get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一家虚构公司 Binford Tools 为目标，Binford 6100 左手螺丝刀的发明者。Binford 请求我们识别从被入侵的用户工作站到存储
    6100 机密设计信息的数据库的攻击路径。我们需要尽可能隐蔽，以便公司能了解其 EDR 能够检测到什么。让我们开始吧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Rules of Engagement</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">交战规则</samp>
- en: Binford’s environment consists only of hosts running up-to-date versions of
    the Windows operating system, and all authentication is controlled through on-premises
    Active Directory. Each host has a generic EDR deployed and running, and we aren’t
    allowed to disable, remove, or uninstall it at any point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Binford 的环境仅由运行最新版本 Windows 操作系统的主机构成，所有认证均通过内部的 Active Directory 控制。每台主机都部署并运行了一个通用的
    EDR，且我们在任何时候都不能禁用、移除或卸载它。
- en: Our point of contact has agreed to provide us with a target email address, which
    an employee (whom we’ll refer to as the *white cell*) will monitor, clicking whatever
    links we send to them. However, they won’t add any rule explicitly allowing our
    payloads past their EDR. This will let us spend less time on social engineering
    and more time assessing technical detective and preventive measures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的联系人已同意提供一个目标电子邮件地址，一个员工（我们称之为*白细胞*）将监控该邮箱，点击我们发送的任何链接。然而，他们不会添加任何明确允许我们的有效载荷绕过其
    EDR 的规则。这将使我们能减少社交工程的时间，将更多精力集中在评估技术检测和防范措施上。
- en: Additionally, every employee at Binford has local administrator rights to their
    workstation, lowering the strain on Binford’s understaffed help desk. Binford
    has asked that we leverage this fact during the operation so that they can use
    the results of the engagement to drive a change to their policy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Binford 的每个员工都拥有其工作站的本地管理员权限，这样可以减轻 Binford 帮助台的负担。Binford 要求我们在操作中利用这一点，以便他们能利用此次活动的结果推动政策的改变。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Initial Access</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">初始访问</samp>
- en: We begin by selecting our phishing method. We need fast and direct access to
    the target’s workstation, so we opt to deliver a payload. Threat intelligence
    reporting at the time of the engagement tells us that the manufacturing sector
    is experiencing an uptick in malware dropped using Excel Add-In (XLL) files. Attackers
    have routinely abused XLL files, which allow developers to create high-performance
    Excel worksheet functions, to establish a foothold through phishing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择我们的钓鱼方法。我们需要快速直接访问目标的工作站，因此我们选择传送有效载荷。在此次行动时的威胁情报报告告诉我们，制造行业正在经历使用 Excel
    插件（XLL）文件投放恶意软件的案件激增。攻击者常常滥用 XLL 文件（它允许开发者创建高性能的 Excel 工作表函数）通过钓鱼建立立足点。
- en: To mimic attacks Binford may respond to in the future, we opt to use this format
    as our payload. XLL files are really just DLLs that are required to export an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function (and,
    ideally, its complement, <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoClose()</samp>),
    so we can use a simple shellcode runner to speed up the development process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟 Binford 可能在未来响应的攻击，我们选择使用这种格式作为我们的有效载荷。XLL 文件其实就是需要导出一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp>
    函数（理想情况下，还有其补充函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoClose()</samp>）的
    DLL 文件，因此我们可以使用简单的 shellcode 运行器来加速开发过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Payload</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写有效载荷</samp>
- en: Already, we must make a detection-related design decision. Should the shellcode
    be run locally, in the *excel.exe* process, where it will be tied to the lifetime
    of that process, or should it be run remotely? If we created our own host process
    and injected into it, or if we targeted an existing process, our shellcode could
    live longer but have a higher risk of detection due to *excel.exe* spawning a
    child process and the artifacts of remote process injection being present.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须做出与检测相关的设计决策。我们是应该在本地，即在 *excel.exe* 进程中运行 shellcode，让它与该进程的生命周期绑定，还是应该远程运行它？如果我们创建了自己的宿主进程并将其注入，或者我们针对了一个现有进程，我们的
    shellcode 可以运行得更久，但由于 *excel.exe* 启动了子进程，且远程进程注入的痕迹可能存在，检测的风险也会更高。
- en: As we can always phish more later, we’ll opt to use the local runner and avoid
    prematurely tripping any detections. [Listing 13-1](#list13-1) shows what our
    XLL payload code looks like.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们以后总可以进行更多钓鱼攻击，因此我们选择使用本地运行器，并避免过早触发任何检测。[列表 13-1](#list13-1) 显示了我们的 XLL
    有效载荷代码的样子。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: The XLL payload source code'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-1：XLL 有效载荷源代码
- en: This local shellcode runner is similar to many DLL-based payloads. The exported
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function begins
    with a chunk of shellcode (truncated for brevity) ❶ that has been XOR-encrypted
    using the string *specter* as the key ❷. The first action this function takes
    is decrypting the shellcode using this symmetric key ❸. Next, it creates a memory
    allocation tagged with read-write permissions using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualAlloc()</samp>
    ❹ and then copies the decrypted shellcode into it ❺ ahead of execution. The function
    then changes the memory permissions of the new buffer to tag it as executable
    ❻. Finally, the pointer to the buffer is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateThread()</samp>,
    which executes the shellcode in a new thread ❼, still under the context of *excel.exe*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个本地 shellcode 运行器类似于许多基于 DLL 的有效载荷。导出的 <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp>
    函数首先包含一段 shellcode（为简洁起见已截断）❶，这段代码使用字符串 *specter* 作为密钥进行了 XOR 加密❷。该函数的第一个操作是使用该对称密钥解密
    shellcode❸。接着，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualAlloc()</samp>
    创建一个带有读写权限的内存分配❹，并将解密后的 shellcode 复制到该内存中❺，为执行做好准备。然后，函数将新缓冲区的内存权限更改为可执行❻。最后，指向缓冲区的指针被传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateThread()</samp>，它在新线程中执行该
    shellcode❼，仍然是在 *excel.exe* 的上下文中运行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delivering the Payload</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">投放有效载荷</samp>
- en: We’ll assume that Binford’s inbound mail-filtering system allows XLL files to
    reach users’ inboxes, and we send our file to the white cell. Because the XLL
    needs to be run from disk, the white cell will download it to the internal host
    on which the EDR is deployed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设 Binford 的入站邮件过滤系统允许 XLL 文件进入用户的收件箱，并将文件发送到白细胞。由于 XLL 需要从磁盘运行，白细胞将把它下载到部署了
    EDR 的内部主机上。
- en: When the white cell executes the XLL, a few things will happen. First, *excel.exe*
    will be started with the path to the XLL passed in as a parameter. The EDR almost
    certainly collects this information from its driver’s process-creation callback
    routine (though the Microsoft-Windows-Kernel-Process ETW provider can provide
    most of the same information). The EDR may have a generic detection built around
    the execution of XLL files, which the process command line could trigger, causing
    an alert.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当白细胞执行 XLL 文件时，几件事情将会发生。首先，*excel.exe* 将启动，并将 XLL 的路径作为参数传递进去。EDR 几乎可以肯定会通过其驱动程序的进程创建回调例程收集此信息（尽管
    Microsoft-Windows-Kernel-Process ETW 提供者可以提供大部分相同的信息）。EDR 可能会围绕 XLL 文件的执行构建一个通用的检测机制，进程命令行可能会触发该检测，从而导致警报。
- en: Additionally, the EDR’s scanner may conduct an on-access scan of the XLL file.
    The EDR will collect attributes of the file, assess its contents, and attempt
    to decide whether the content should be allowed to run. Let’s say that we did
    such a great job obfuscating our payload that the shellcode and associated runner
    inside weren’t detected by the scanner.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，EDR 的扫描器可能会对 XLL 文件进行访问扫描。EDR 将收集文件的属性，评估其内容，并尝试决定是否允许其运行。假设我们已经通过极好的混淆技术使得有效载荷中的
    shellcode 和相关的运行器没有被扫描器检测到。
- en: We’re not in the clear yet, though. Remember that most EDRs are deployed in
    multiple large environments and process large amounts of data. With this perspective,
    EDRs can assess the *global uniqueness* of a file, meaning how many times it has
    seen the file in the past. Because we crafted this payload ourselves and it contains
    shellcode tied to our infrastructure, it most likely hasn’t been seen before.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们还没有完全安全。记住，大多数EDR都部署在多个大规模环境中，并处理大量数据。考虑到这一点，EDR 可以评估文件的*全球唯一性*，即它过去见过多少次这个文件。由于我们自己编写了这个有效载荷，并且它包含与我们基础设施相关的
    shellcode，因此它很可能是之前从未见过的。
- en: Luckily, this isn’t the end of the road by any stretch of the imagination. Users
    write new Word documents all the time. They generate reports for their organization
    and doodle in Paint during the third hour of meetings on “cross-functional synergy
    to meet key quarterly metrics.” If EDRs flagged every single unique file they
    came across, they would create an untenable amount of noise. While our global
    uniqueness may trigger some type of alert, it probably isn’t severe enough to
    kick off an investigation and won’t come into play unless the security operations
    center (SOC) responds to a higher-severity alert related to our activity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不是想象中的终点。用户们一直在创建新的Word文档。他们为自己的组织生成报告，在会议的第三小时中用画图工具涂鸦，讨论“跨部门协作以实现关键季度目标”。如果EDR标记它们遇到的每一个唯一文件，系统就会产生难以承受的噪音。虽然我们的全球唯一性可能会触发某种警报，但它可能不足以启动调查，除非安全运营中心（SOC）响应与我们的活动相关的高严重性警报。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Executing the Payload</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">执行有效载荷</samp>
- en: Since we haven’t been blocked yet, *excel.exe* will load and process our XLL.
    As soon as our XLL is loaded, it will hit the <samp class="SANS_TheSansMonoCd_W5Regular_11">DLL_PROCESS_ATTACH</samp>
    reason code, which triggers the execution of our shellcode runner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有被拦截，*excel.exe* 将加载并处理我们的 XLL。只要我们的 XLL 被加载，它将触发 <samp class="SANS_TheSansMonoCd_W5Regular_11">DLL_PROCESS_ATTACH</samp>
    代码，这将触发我们 shellcode 执行器的执行。
- en: When our parent *excel.exe* process was spawned, the EDR injected its DLL, which
    hooked key functions unknown to us at this point. We didn’t use syscalls or include
    any logic to remap these hooked DLLs in *excel.exe*, so we’ll have to pass through
    these hooks and hope we don’t get caught. Thankfully, many of the functions commonly
    hooked by EDRs focus on remote process injection, which doesn’t affect us, as
    we’re not spawning a child process to inject into.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的父进程*excel.exe*被启动时，EDR注入了它的DLL，并挂钩了我们此时尚不知情的关键函数。我们没有使用系统调用，也没有包含任何重新映射这些挂钩DLL的逻辑，因此我们必须通过这些挂钩，希望自己不会被捕捉到。幸运的是，许多EDR通常挂钩的函数主要关注远程进程注入，而这对我们没有影响，因为我们没有创建子进程来进行注入。
- en: 'We also happen to know that this EDR makes use of the Microsoft-Windows-Threat-Intelligence
    ETW provider, so our activities will be subject to monitoring by those sensors
    on top of the EDR vendor’s own function hooks. Let’s examine the riskiness of
    the functions we call in our payload:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，这款EDR使用了Microsoft-Windows-Threat-Intelligence ETW提供程序，因此我们的活动将受到这些传感器的监控，此外还会受到EDR供应商自身功能挂钩的监控。让我们来审视一下我们在有效载荷中调用的函数的风险：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualAlloc()</samp>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualAlloc()</samp>
- en: Since this is the standard local-memory-allocation function in Windows and doesn’t
    allow for remote allocations (as in, memory being allocated in another process),
    its use likely won’t be scrutinized in isolation. Additionally, because we aren’t
    allocating read-write-execute memory, a common default for malware developers,
    we’ve mitigated pretty much all the risk that we can.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是Windows中标准的本地内存分配函数，并且不允许进行远程分配（即内存分配到另一个进程中），因此它的使用可能不会被单独审查。另外，因为我们没有分配可读写执行内存，这通常是恶意软件开发人员的默认选择，所以我们已经尽可能减轻了所有风险。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">memcpy()</samp>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">memcpy()</samp>
- en: Similar to the previous function, <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp>
    is a widely used function and isn’t subject to much scrutiny.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的函数类似，<samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp> 是一个广泛使用的函数，通常不会受到太多审查。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualProtect()</samp>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualProtect()</samp>
- en: This is where things become riskier for us. Because we have to convert the protections
    for our allocation from read-write to read-execute, this step is unfortunately
    unavoidable. Since we’ve passed the desired protection level as a parameter to
    this function, EDRs can trivially identify this technique via function hooking.
    Additionally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    sensor will detect the changes in protection state and notify consumers of the
    Microsoft-Windows-Threat-Intelligence ETW provider.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们变得更加危险的地方。因为我们必须将分配的保护从读写转换为读执行，这一步是无法避免的。不幸的是，由于我们将所需的保护级别作为参数传递给了此函数，EDR
    可以轻松地通过函数挂钩来识别这种技术。此外，<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    传感器将检测到保护状态的变化，并通知 Microsoft-Windows-Threat-Intelligence ETW 提供者的消费者。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!CreateThread()</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!CreateThread()</samp>
- en: In isolation, this function doesn’t present much of a risk, as it is the standard
    way of creating new threads in multithreaded Win32 applications. However, since
    we’ve performed the previous three actions, which, combined, may indicate the
    presence of malware on the system, its use may be the proverbial straw that breaks
    the camel’s back in terms of causing an alert to fire. Unfortunately for us, we
    don’t really have many options to avoid its use, so we’ll just stick with it and
    hope that if we’ve gotten this far, our shellcode will execute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这个函数并没有太大风险，因为它是多线程 Win32 应用程序中创建新线程的标准方式。然而，由于我们已经执行了之前的三个操作，组合起来可能表明系统中存在恶意软件，因此它的使用可能就是压垮骆驼的最后一根稻草，导致警报触发。不幸的是，我们没有太多的选择来避免使用它，所以我们只能坚持下去，并希望如果我们已经走到这一步，我们的
    shellcode 就会成功执行。
- en: This shellcode runner technique could be optimized in plenty of ways, but compared
    to the textbook <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread()</samp>-based
    approach to remote process injection, it’s not too bad. If we assume that these
    indicators fly under the radar of the EDR’s sensors, our agent shellcode will
    execute and begin its process of communicating back to our command-and-control
    infrastructure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 shellcode 运行技术可以通过很多方式进行优化，但与教科书中基于 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread()</samp>
    的远程进程注入方法相比，它还算不错。如果我们假设这些指标能够躲过 EDR 的传感器，那么我们的代理 shellcode 将会执行并开始与我们的命令与控制基础设施进行通信。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Establishing Command
    and Control</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">建立命令与控制</samp>
- en: Most malicious agents establish command and control in similar ways. The first
    message the agent sends to the server is a check-in saying “I’m a new agent running
    on host X!” When the server receives this check-in, it will reply “Hello agent
    on host X! Sleep for this period of time, then message me again for tasking.”
    The agent then idles for the time specified by the server, after which it messages
    it again saying “Back again. This time I’m ready to do some work.” If the operator
    has specified tasking for the agent, the server will pass that information along
    in some format understood by the agent, and the agent will execute the task. Otherwise,
    the server will tell the agent to sleep and try again later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数恶意代理以类似的方式建立命令与控制。代理向服务器发送的第一条消息是一个签到信息：“我是主机 X 上的新代理！”当服务器接收到这个签到消息时，它会回复：“你好，主机
    X 上的代理！休眠一段时间后，再次向我发送消息以获取任务。”然后，代理会按照服务器指定的时间进行空闲，之后再次发送消息：“又回来啦。这次我准备好执行任务了。”如果操作员为代理指定了任务，服务器会以某种代理能够理解的格式传递这些信息，代理会执行任务。否则，服务器会告诉代理休眠并稍后再试。
- en: How do command-and-control agents evade network-based detection? Most of the
    time, the communication happens over HTTPS, the favorite channel of most operators
    because it lets their messages blend in with the high volume of traffic commonly
    flowing to the internet over TCP port 443 on most workstations. To use this protocol
    (and its less-secure sister, HTTP), the communication must follow certain conventions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 命令与控制代理如何逃避基于网络的检测？大多数情况下，通信发生在 HTTPS 上，这是大多数操作员的最爱通道，因为它可以让他们的消息与通过 TCP 443
    端口常规流向互联网的大量流量混合。在使用此协议（及其不太安全的姊妹协议 HTTP）时，通信必须遵循某些约定。
- en: For example, a request must have a *Uniform Resource Identifier (URI)* path
    for both GET requests, used for retrieving data, and POST requests, used for sending
    data. While these URIs don’t technically have to be the same in each request,
    many commercial command-and-control frameworks reuse one static URI path. Additionally,
    the agent and server must have an agreed-upon communication protocol that rides
    on top of HTTPS. This means that their messages generally follow a similar pattern.
    For instance, the lengths of check-in requests and polls for tasking will likely
    be static. They may also be sent at fixed intervals.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个请求必须为GET请求（用于检索数据）和POST请求（用于发送数据）提供一个*统一资源标识符（URI）*路径。虽然这些URI在每个请求中技术上不必相同，但许多商业指挥与控制框架会重复使用一个静态URI路径。此外，代理和服务器必须有一个约定的通信协议，基于HTTPS。这意味着它们的消息通常遵循类似的模式。例如，签到请求和任务轮询的长度可能是静态的，且可能以固定的时间间隔发送。
- en: All of this is to say that, even when command-and-control traffic attempts to
    blend in among the noise, it still generates strong indicators of beaconing activity.
    An EDR developer who knows what to look for can use these to pick out the malicious
    traffic from the benign, probably using the network filter driver and ETW providers
    such as Microsoft-Windows-WebIO and Microsoft-Windows-DNS-Client. While the contents
    of HTTPS messages are encrypted, many important details remain readable, such
    as the URI paths, headers, message lengths, and the time at which the message
    was sent.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切的意思是，即使指挥与控制流量试图在噪声中混淆，它仍然会生成强烈的信标活动指示符。一个知道该寻找什么的EDR开发者可以利用这些指示符将恶意流量从正常流量中挑出来，可能会使用网络过滤驱动程序和像Microsoft-Windows-WebIO、Microsoft-Windows-DNS-Client等ETW提供者。虽然HTTPS消息的内容是加密的，但许多重要的细节仍然可以读取，例如URI路径、头信息、消息长度以及消息发送的时间。
- en: Knowing this, how do we set up our command and control? Our HTTPS channel uses
    the domain blnfordtools.com. We purchased this domain a few weeks before the operation,
    set up DNS to point to a DigitalOcean virtual private server (VPS), and configured
    an NGINX web server on the VPS to use a LetsEncrypt SSL certificate. GET requests
    will be sent to the */home/catalog* endpoint and POST requests to */search?q=6100*,
    which will hopefully blend into normal traffic generated when browsing a tool
    manufacturer’s site. We set our default sleep interval to five minutes to allow
    us to quickly task the agent without being overly noisy, and we use a jitter of
    20 percent to add some variability between request times.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了这一点，我们如何设置我们的指挥与控制？我们的HTTPS通道使用域名blnfordtools.com。我们在操作前几周购买了该域名，将DNS指向了一个DigitalOcean虚拟私人服务器（VPS），并在VPS上配置了NGINX
    Web服务器，使用LetsEncrypt SSL证书。GET请求将被发送到*/home/catalog*端点，POST请求将发送到*/search?q=6100*，希望这些请求能融入到浏览工具制造商网站时产生的正常流量中。我们将默认的休眠间隔设置为五分钟，以便我们能迅速下发任务给代理而不会过于引人注目，并且使用20%的抖动来增加请求时间的变化性。
- en: 'This command-and-control strategy might seem insecure; after all, we’re using
    a newly registered, typo-squatted domain hosted on a cheap VPS. But let’s consider
    what the EDR’s sensors can actually capture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种指挥与控制策略看起来可能不安全；毕竟，我们使用的是一个新注册的、被拼写错误劫持的域名，且托管在一个便宜的VPS上。但让我们考虑一下EDR的传感器实际上可以捕获到什么：
- en: A suspicious process making an outbound network connection
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可疑的进程正在建立出站网络连接
- en: Anomalous DNS lookups
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的DNS查询
- en: Notably missing is all the weirdness related to our infrastructure and indicators
    of beaconing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有与我们基础设施相关的奇怪行为和信标活动的指示符都没有出现。
- en: Although the EDR’s sensors can collect the data required to determine that the
    compromised host is connecting to a newly registered, uncategorized domain pointing
    to a sketchy VPS, actually doing this would mean performing a ton of supporting
    actions, which could negatively affect system performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EDR的传感器可以收集到所需的数据，从而确定被攻陷的主机正在连接一个新注册的、未分类的域名，该域名指向一个可疑的VPS，但实际上执行这些操作意味着要进行大量的支持性工作，这可能会对系统性能产生负面影响。
- en: For example, to track domain categorization, the EDR would need to reach out
    to a reputation-monitoring service. To get registration information, it would
    need to query the registrar. Doing all of this for all connections made on the
    target system would be hard. For that reason, EDR agents typically offload these
    responsibilities to the central EDR server, which performs the lookups asynchronously
    and uses the results to fire off alerts if needed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了跟踪域名分类，EDR需要联系一个声誉监控服务。为了获取注册信息，它需要查询注册商。为了对目标系统上的所有连接执行这一切操作将是困难的。因此，EDR代理通常将这些责任转移到中央EDR服务器上，服务器异步执行查找，并在必要时根据结果触发警报。
- en: 'The indicators of beaconing are missing for nearly the same reasons. If our
    sleep interval were something like 10 seconds with 10 percent jitter, detecting
    the beaconing could be as simple as following a rule like this one: “If this system
    makes more than 10 requests to a website with nine to 11 seconds between each
    request, fire an alert.” But when the sleep interval is five minutes with 20 percent
    jitter, the system would have to generate an alert anytime the endpoint made more
    than 10 requests to a website with four to six minutes between each request, which
    would require maintaining the rolling state of every outbound network connection
    for between 40 minutes and one hour. Imagine how many websites you visit on a
    daily basis, and you can see why this function is better suited for the central
    server.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 信标的指标缺失几乎是由于相同的原因。如果我们的休眠间隔是像10秒钟并且带有10%的抖动，检测信标可能就像遵循以下规则那样简单：“如果该系统在每次请求之间的间隔为9到11秒，且发送超过10次请求到一个网站，则触发警报。”但是，当休眠间隔为五分钟且带有20%的抖动时，系统必须在每个端点每次请求之间间隔四到六分钟的情况下生成警报，这将要求维持每个出站网络连接的滚动状态，持续时间为40分钟到1小时。想象一下你每天访问多少个网站，你就能明白为什么这个功能更适合放在中央服务器上。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evading the Memory
    Scanner</samp>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规避内存扫描器</samp>
- en: The last big threat to the initial access phase of the engagement (as well as
    any future stages in which we spawn an agent) is the EDR’s memory scanner. Like
    the file scanner, this component seeks to detect the presence of malware on the
    system using static signatures. Instead of reading the file from disk and parsing
    its contents, it scans the file after it has been mapped into memory. This allows
    the scanner to assess the content of the file after it has been de-obfuscated
    so that it can be passed to the CPU for execution. In the case of our payload,
    this means our decrypted agent shellcode will be present in memory; the scanner
    needs only to find it and identify it as malicious.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对初始访问阶段（以及任何我们派发代理的未来阶段）构成的最后一个重大威胁是EDR的内存扫描器。与文件扫描器类似，这个组件通过静态签名寻求检测系统中恶意软件的存在。它不是从磁盘读取文件并解析其内容，而是在文件被映射到内存后扫描它。这使得扫描器可以评估文件的内容，在它被去混淆后，再将其传递给CPU执行。就我们的载荷而言，这意味着我们的解密代理shellcode将存在于内存中；扫描器只需找到它并识别为恶意代码。
- en: Some agents include functionality to obscure the presence of the agent in memory
    during periods of inactivity. These techniques have varying levels of efficacy,
    and a scanner could still detect the shellcode by catching the agent between one
    of these sleep periods. Even so, custom shellcode and custom agents are generally
    harder to detect through static signatures. We’ll assume that our bespoke, handcrafted,
    artisanal command-and-control agent was novel enough to avoid being flagged by
    the memory scanner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代理程序包含了在非活动期间隐藏代理存在于内存中的功能。这些技术的效果各不相同，扫描器仍然可能通过捕捉代理在这些休眠期之间的活动来检测到shellcode。即便如此，定制的shellcode和定制的代理通常更难通过静态签名进行检测。我们假设我们的定制、手工制作的指令与控制代理足够新颖，能够避开内存扫描器的检测。
- en: 'At this point, everything has worked in our favor: our initial beaconing didn’t
    fire off an alert worthy of the SOC’s attention. We’ve established access to the
    target system and can begin our post-compromise activities.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，一切对我们有利：我们最初的信标没有触发任何值得SOC关注的警报。我们已经建立了对目标系统的访问权限，并可以开始进行事后渗透活动。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Persistence</samp>
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">持久性</samp>
- en: Now that we’re inside the target environment, we need to make sure we can survive
    a technical or human-induced loss of connection. At this stage of the operation,
    our access is so fragile that if something were to happen to our agent, we’d have
    to start over from the beginning. Therefore, we need to set up some form of persistence
    that will establish a new command-and-control connection if things go south.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入目标环境，需要确保能够应对技术性或人为引起的连接中断。在这一阶段，我们的访问如此脆弱，如果我们的代理出了问题，我们就必须从头开始。因此，我们需要设置某种持久性机制，如果情况变糟，可以建立新的指挥与控制连接。
- en: 'Persistence is a tricky thing. There are an overwhelming number of options
    at our disposal, each with pros and cons. Generally speaking, we’re evaluating
    the following metrics when choosing a persistence technique:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性是一件棘手的事情。我们可以选择的选项数量庞大，每个选项都有优缺点。一般来说，我们在选择持久性技术时会评估以下度量标准：
- en: '**Reliability**   The degree of certainty that the persistence technique will
    trigger our action (for example, launching a new command-and-control agent)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠性**   持久性技术触发我们行动的确定性程度（例如，启动一个新的指挥与控制代理）'
- en: '**Predictability**   The degree of certainty about when the persistence will
    trigger'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**可预测性**   持久性触发时的确定性程度'
- en: '**Required permissions**   The level of access required to set up this persistence
    mechanism'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需权限**   设置该持久性机制所需的访问级别'
- en: '**Required user or system behaviors**   Any actions that must occur on the
    system for our persistence to fire, such as a system reboot or a user going idle'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需的用户或系统行为**   为了触发我们的持久性，系统必须发生的任何操作，例如系统重启或用户闲置'
- en: '**Detection risks**   The understood risk of detection inherent to the technique'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测风险**   该技术固有的检测风险'
- en: Let’s use the creation of scheduled tasks as an example. [Table 13-1](#tab13-1)
    shows how the technique would perform using our metrics. Things seem great initially.
    Scheduled tasks run like a Rolex and are incredibly easy to set up. The first
    issue we encounter is that we need local administrator rights to create a new
    scheduled task, as the associated directory, *C:\Windows\System32\Tasks\*, can’t
    be accessed by standard users.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建计划任务为例。[表 13-1](#tab13-1)展示了该技术如何使用我们的度量标准执行。最初一切看起来都很不错。计划任务像劳力士一样运行，非常容易设置。我们遇到的第一个问题是，创建新的计划任务需要本地管理员权限，因为相关的目录，*C:\Windows\System32\Tasks\*，标准用户无法访问。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    Scheduled Tasks as a Persistence Mechanism</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-1：</samp> <samp class="SANS_Futura_Std_Book_11">评估计划任务作为持久性机制</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">度量</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">评估</samp>
    |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Reliability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    reliably</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">可靠性</samp> | <samp class="SANS_Futura_Std_Book_11">高度可靠</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Predictability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    predictable</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">可预测性</samp> | <samp class="SANS_Futura_Std_Book_11">高度可预测</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Required permissions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Local administrator</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">所需权限</samp> | <samp class="SANS_Futura_Std_Book_11">本地管理员</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp>
    | <samp class="SANS_Futura_Std_Book_11">System must be connected to the network
    at the time of the trigger</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">所需的用户或系统行为</samp> | <samp class="SANS_Futura_Std_Book_11">触发时系统必须连接到网络</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Detection risks</samp> | <samp class="SANS_Futura_Std_Book_11">Very
    high</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">检测风险</samp> | <samp class="SANS_Futura_Std_Book_11">非常高</samp>
    |'
- en: The biggest issue for us, though, is the detection risk. Attackers have abused
    scheduled tasks for decades. It would be fair to say that any EDR agent worth
    its weight would be able to detect the creation of a new scheduled task. As a
    matter of fact, MITRE’s *ATT&CK evaluations*, a capability-validation process
    that many vendors participate in every year, uses scheduled-task creation as one
    of its test criteria for APT3, an advanced persistent threat group attributed
    to China’s Ministry of State Security (MSS). Because remaining stealthy is one
    of our big goals, this technique is off the table for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对我们来说，最大的问题是检测风险。攻击者利用计划任务已经有几十年的历史了。可以公平地说，任何一个值得信赖的EDR代理都能够检测到新计划任务的创建。事实上，MITRE的*ATT&CK评估*，这是一个许多供应商每年参与的能力验证过程，使用计划任务创建作为APT3（一个被归类为中国国家安全部的高级持续性威胁组织）测试标准之一。由于保持隐蔽性是我们的一个重要目标，这种技术对我们来说是不适用的。
- en: 'What persistence mechanism should we choose? Well, nearly every EDR vendor’s
    marketing campaign claims that it covers most cataloged ATT&CK techniques. ATT&CK
    is a collection of known attacker techniques that we understand well and are tracking.
    But what about the unknowns: the techniques about which we are mostly ignorant?
    A vendor can’t guarantee coverage of these; nor can they be assessed against them.
    Even if an EDR has the ability to detect these uncatalogued techniques, it might
    not have the detection logic in place to make sense of the telemetry generated
    by them.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该选择哪种持久性机制呢？几乎每个EDR供应商的营销活动都声称它覆盖了大多数已分类的ATT&CK技术。ATT&CK是一个我们了解并且在追踪的已知攻击者技术的集合。但未知的技术呢？那些我们大多数还不了解的技术呢？供应商无法保证涵盖这些技术；它们也无法与这些技术进行评估。即使一个EDR具备检测这些未分类技术的能力，它也可能没有适当的检测逻辑来理解这些技术生成的遥测数据。
- en: 'To lower our likelihood of detection, we can research, identify, and develop
    these “known unknowns.” To that end, let’s use *shell preview handlers*, a persistence
    technique that I, along with my colleague Emily Leidy, published research about
    in a blog post, “Life Is Pane: Persistence via Preview Handlers.” Preview handlers
    install an application that renders a preview of a file with a specific extension
    when viewed in Windows Explorer. In our case, the application we register will
    be our malware, and it will kick off a new command-and-control agent. This process
    is done almost entirely in the registry; we’ll create new keys that register a
    COM server. [Table 13-2](#tab13-2) evaluates this technique’s riskiness.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '为了降低被检测的可能性，我们可以研究、识别并开发这些“已知的未知”。为此，我们使用*Shell预览处理程序*，这是一种持久性技术，我和我的同事Emily
    Leidy曾在博客文章《Life Is Pane: 通过预览处理程序实现持久性》中发表过研究。预览处理程序安装一个应用程序，当在Windows资源管理器中查看具有特定扩展名的文件时，它会呈现该文件的预览。在我们的案例中，我们注册的应用程序将是我们的恶意软件，它将启动一个新的命令和控制代理。这个过程几乎完全是在注册表中完成的；我们将创建新的键值来注册一个COM服务器。[表13-2](#tab13-2)评估了这一技术的风险。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    Shell Preview Handlers as a Persistence Mechanism</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表13-2：</samp> <samp class="SANS_Futura_Std_Book_11">评估Shell预览处理程序作为持久性机制</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp>
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">度量标准</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">评估</samp>
    |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Reliability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    reliable</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">可靠性</samp> | <samp class="SANS_Futura_Std_Book_11">高度可靠</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Predictability</samp> | <samp class="SANS_Futura_Std_Book_11">Unpredictable</samp>
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">可预测性</samp> | <samp class="SANS_Futura_Std_Book_11">不可预测</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Required permissions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Standard user</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">所需权限</samp> | <samp class="SANS_Futura_Std_Book_11">标准用户</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp>
    | <samp class="SANS_Futura_Std_Book_11">User must browse the target file type
    in Explorer with the pre</samp><samp class="SANS_Futura_Std_Book_11">view pane
    enabled, or the search indexer must process the file</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">所需的用户或系统行为</samp> | <samp class="SANS_Futura_Std_Book_11">用户必须在资源管理器中浏览目标文件类型，并启用预览窗格，或者搜索索引器必须处理该文件</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Detection risks</samp> | <samp class="SANS_Futura_Std_Book_11">Currently
    low but trivial to detect</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">检测风险</samp> | <samp class="SANS_Futura_Std_Book_11">目前较低，但容易被检测到</samp>
    |'
- en: As you can see, these “known unknowns” tend to trade strengths in some areas
    for weaknesses in others. Preview handlers require fewer permissions and are harder
    to detect (though detection is still possible, as their installation requires
    very specific registry changes to be made on the host). However, they are less
    predictable than scheduled tasks due to user-interaction requirements. For operations
    in which detection isn’t a significant concern, reliability and usability may
    trump the other factors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些“已知的未知”在某些方面会交换优点和弱点。预览处理程序需要的权限较少，并且更难被检测到（尽管仍然可能被检测到，因为它们的安装需要在主机上进行非常特定的注册表更改）。然而，由于需要用户交互，它们比计划任务更难以预测。对于检测不是重大问题的操作来说，可靠性和可用性可能会超过其他因素。
- en: Say we use this persistence mechanism. In the EDR, sensors are now hard at work
    collecting telemetry related to the hijacked preview handlers. We had to drop
    a DLL containing a runner for our backup agent to disk from *excel.exe*, so the
    scanner will probably give it a thorough examination, assuming that Excel writing
    a new DLL isn’t suspect enough. We also had to create a ton of registry keys,
    which the driver’s registry-notification callback routine will handle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用这个持久化机制。在EDR中，传感器现在正在努力收集与劫持的预览处理程序相关的遥测数据。我们不得不将一个包含我们备份代理程序的DLL从*excel.exe*写入磁盘，因此扫描器可能会对其进行彻底检查，假设Excel写入新DLL这一行为本身不够可疑。我们还必须创建大量的注册表项，由驱动程序的注册表通知回调例程处理这些注册表项。
- en: Also, the registry-related telemetry our actions generate can be a little difficult
    to manage. This is because COM object registration can be tricky to pick out from
    the large volume of registry data, and because it can be challenging to differentiate
    a benign COM object registration from a malicious one. Additionally, while the
    EDR can monitor the creation of the new preview-handler registry-key value, as
    it has a standard format and location, this requires performing a lookup between
    the class identifier written as the value and the COM object registration associated
    with that class identifier, which isn’t feasible at the sensor level.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的操作生成的与注册表相关的遥测数据可能有些难以管理。这是因为COM对象注册很难从大量的注册表数据中筛选出来，而且很难将无害的COM对象注册与恶意的注册区分开来。此外，虽然EDR可以监控新预览处理程序注册表项值的创建，因为它有一个标准格式和位置，但这需要在类标识符（作为值写入）和与该类标识符相关的COM对象注册之间进行查找，而这在传感器级别是不可行的。
- en: Another detection risk is our manual enablement of Explorer’s preview pane.
    This isn’t crazy behavior on its own. Users can manually enable or disable the
    preview pane at any time through their file browser. It can also be enabled across
    the enterprise via a group policy object. In both of these instances, the process
    making the change (for example, *explorer.exe* in the case of manual enablement)
    is known, meaning that a detection targeting atypical processes setting this registry
    value may be possible. For *excel.exe* to make this change would be very much
    out of the ordinary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个检测风险是我们手动启用Explorer的预览窗格。单独来看，这并不是疯狂的行为。用户可以随时通过文件浏览器手动启用或禁用预览窗格。它也可以通过组策略对象在整个企业范围内启用。在这两种情况下，进行更改的进程（例如，在手动启用的情况下是*explorer.exe*）是已知的，这意味着可能会有一个检测针对不寻常进程设置此注册表值的机制。如果*excel.exe*进行此更改，那就完全不寻常了。
- en: Finally, Explorer has to load our DLL whenever the persistence is triggered.
    This DLL won’t be signed by Microsoft (or likely signed at all). The driver’s
    image-load callback notification routine will be responsible for detecting this
    DLL being loaded and can investigate the signature, along with other metadata
    about the image, to tip off the agent to the fact that a piece of malware is about
    to be mapped into Explorer’s address space. Of course, we could mitigate some
    of this risk by signing our DLL with a valid code-signing certificate, but this
    is beyond the reach of many threat actors, both real and simulated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当持久化被触发时，Explorer都必须加载我们的DLL。这个DLL不会由微软签名（或者可能根本不被签名）。驱动程序的图像加载回调通知例程将负责检测这个DLL是否被加载，并可以检查该图像的签名以及其他元数据，从而提示代理即将将一段恶意软件映射到Explorer的地址空间。当然，我们可以通过使用有效的代码签名证书来签署我们的DLL，从而缓解一些风险，但这对于许多威胁行为者来说，无论是现实中的还是模拟的，都是无法实现的。
- en: We’ll make a trade-off in predictability in favor of lowering our detection
    risk. We choose to install a preview handler for the *.docx* file extension by
    dropping our handler DLL to disk, performing the requisite COM registration, and
    manually enabling Explorer’s preview pane in the registry if it is not already
    enabled.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在可预测性方面做出权衡，以降低被检测的风险。我们选择通过将处理程序DLL写入磁盘、执行所需的COM注册，并在注册表中手动启用资源管理器的预览窗格（如果它尚未启用）来安装一个预览处理程序，用于*.docx*文件扩展名。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reconnaissance</samp>
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">侦察</samp>
- en: Now that we’ve established persistence, we can afford to start taking more risks.
    The next thing we need to figure out is how to get to where we need to go. This
    is when you must think the hardest about detection because you’ll generate vastly
    different indicators based on what you’re doing and how you do it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了持久性，我们可以开始冒更多的风险。接下来，我们需要弄清楚如何到达目标位置。这时你必须最为谨慎地考虑检测问题，因为根据你做什么以及如何做，你会生成完全不同的指示器。
- en: We’ll need a way to run reconnaissance tooling without detection. One of my
    favorite tools for performing local reconnaissance is Seatbelt, a host-based situational
    awareness tool written by Lee Christensen and Will Schroeder. It can enumerate
    a ton of information about the current system, including the running processes,
    mapped drives, and amount of time the system has been online.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来运行侦察工具而不被检测到。我最喜欢的本地侦察工具之一是Seatbelt，这是一款由Lee Christensen和Will Schroeder编写的基于主机的态势感知工具。它可以枚举大量关于当前系统的信息，包括正在运行的进程、映射的驱动器以及系统在线的时间。
- en: A common way to run Seatbelt is to use built-in features of the command- and-control
    agent, such as Cobalt Strike Beacon’s execute-assembly, to execute its .NET assembly
    in memory. Typically, this involves spawning a sacrificial process, loading the
    .NET common language runtime into it, and instructing it to run a specified .NET
    assembly with provided arguments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Seatbelt的一种常见方法是使用命令与控制代理的内置功能，例如Cobalt Strike Beacon的execute-assembly，将其.NET程序集加载到内存中执行。通常，这涉及到生成一个牺牲进程，将.NET公共语言运行时加载到其中，并指示它运行指定的.NET程序集，并传入提供的参数。
- en: 'This technique is substantially less detection prone than trying to drop the
    tool onto the target’s filesystem and executing it from there, but it’s not without
    risk. In fact, the EDR could catch us in a whole slew of ways:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术比试图将工具放置到目标的文件系统上并从那里执行它的检测风险要小得多，但它并非没有风险。事实上，EDR可能会通过各种方式抓住我们：
- en: '**Child Process Creation**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**子进程创建**'
- en: The EDR’s process-creation callback routine could detect the creation of the
    sacrificial process. If the child of the parent process is atypical, it could
    trigger an alert.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: EDR的进程创建回调程序可能会检测到牺牲进程的创建。如果父进程的子进程是非典型的，它可能会触发警报。
- en: '**Abnormal Module Loading**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常模块加载**'
- en: The sacrificial process spawned by the parent may not typically load the common
    language runtime if it is an unmanaged process. This may tip off the EDR’s image-load
    callback routine that in-memory .NET tradecraft is being used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程生成的牺牲进程通常不会加载公共语言运行时，如果它是一个非托管进程。这可能会引起EDR的映像加载回调程序的警觉，表明正在使用内存中的.NET技术。
- en: '**Common Language Runtime ETW Events**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时ETW事件**'
- en: Whenever the common language runtime is loaded and run, it emits events through
    the Microsoft-Windows-DotNETRuntime ETW provider. This allows EDRs that consume
    its events to identify key pieces of information related to the assemblies executing
    on the system, such as their namespace, class and method names, and Platform Invoke
    signatures.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当公共语言运行时被加载并运行时，它会通过Microsoft-Windows-DotNETRuntime ETW提供程序发出事件。这允许消费其事件的EDR识别与系统上执行的程序集相关的关键信息，例如它们的命名空间、类和方法名称以及平台调用签名。
- en: '**Antimalware Scan Interface**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**反恶意软件扫描接口**'
- en: If we’ve loaded version 4.8 or later of the .NET common language runtime, AMSI
    becomes a concern for us. AMSI will inspect the contents of our assembly, and
    each registered provider will have the opportunity to determine whether its contents
    are malicious.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载了4.8版或更高版本的.NET公共语言运行时，AMSI就成了我们的关注点。AMSI将检查我们程序集的内容，每个注册的提供者都有机会确定其内容是否恶意。
- en: '**Common Language Runtime Hooks**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时钩子**'
- en: While the technique isn’t directly covered in this book, many EDRs use hooks
    on the common language runtime to intercept certain execution paths, inspect parameters
    and return values, and optionally block them. For example, EDRs commonly monitor
    *reflection*, the .NET feature that enables the manipulation of loaded modules,
    among other things. An EDR that hooks the common language runtime in this way
    may be able to see things that AMSI alone couldn’t and detect tampering with the
    loaded *amsi.dll*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书没有直接涉及这一技术，但许多EDR（端点检测与响应）使用钩子在公共语言运行时上拦截特定的执行路径，检查参数和返回值，并可选择性地阻止它们。例如，EDR通常监控*反射*，这是.NET的一个特性，允许操作已加载的模块等内容。以这种方式钩住公共语言运行时的EDR可能能够看到AMS独立无法检测到的内容，并发现对已加载的*amsi.dll*的篡改。
- en: '**Tool-Specific Indicators**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具特定指标**'
- en: The actions our tooling takes after being loaded can generate additional indicators.
    Seatbelt, for instance, queries many registry keys.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具加载后所采取的操作可能会生成额外的指标。例如，Seatbelt会查询许多注册表键值。
- en: In short, most vendors know how to identify the execution of .NET assemblies
    in memory. Thankfully for us, there are some alternative procedures, as well as
    tradecraft decisions we can make, that can limit our exposure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，大多数厂商知道如何识别内存中.NET程序集的执行。幸运的是，我们有一些替代程序以及可以做出的技术决策，可以帮助我们减少暴露风险。
- en: An example of this is the *InlineExecute-Assembly* Beacon object file, an open
    source plug-in for Cobalt Strike’s Beacon that allows operators to do everything
    that the normal execute-assembly module allows but without the requirement of
    spawning a new process. On the tradecraft side, if our current process is managed
    (as in, is .NET), then loading the common language runtime would be expected behavior.
    Couple these with bypasses for AMSI and the .NET Runtime ETW provider and we’ve
    limited our detection risk down to any hooks placed into the common language runtime
    and the indicators unique to the tool, which can be addressed independently. If
    we implement these tradecraft and procedural changes, we’re in a decent spot to
    be able to run Seatbelt.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是*InlineExecute-Assembly* Beacon对象文件，这是Cobalt Strike的Beacon的一个开源插件，允许操作员执行正常的execute-assembly模块所能做的一切，但不需要生成新的进程。在技术操作方面，如果我们当前的进程是受管理的（例如，.NET），那么加载公共语言运行时将是预期的行为。将这些与绕过AMSI和.NET运行时ETW提供程序结合使用，我们就将检测风险限制到了任何放置在公共语言运行时的钩子和工具特有的指标，而这些可以独立处理。如果我们实施这些技术手段和程序性变化，我们就处于一个相对安全的位置，可以顺利运行Seatbelt。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privilege Escalation</samp>
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">特权升级</samp>
- en: We know that we need to expand our access to other hosts in Binford’s environment.
    We also know, from our point of contact, that our current user has low privileges
    and hasn’t been granted administrative access to remote systems. Remember, though,
    that Binford grants all domain users local administrator rights on their designated
    workstation so that they can install applications without overburdening their
    helpdesk team. All of this means that we won’t be able to move around the network
    unless we can get into the context of another user, but we also have options for
    how to do that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要扩展对Binford环境中其他主机的访问权限。我们还知道，根据我们的联系人，我们当前的用户权限较低，并没有被授予远程系统的管理员访问权限。然而，记住，Binford为所有域用户在指定的工作站上授予本地管理员权限，这样他们就可以安装应用程序，而不会让帮助台团队负担过重。这一切意味着，除非我们能够进入另一个用户的上下文，否则我们无法在网络中移动，但我们也有一些方法可以实现这一目标。
- en: To take on the identity of another user, we could extract credentials from LSASS.
    Unfortunately, opening a handle to LSASS with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>
    rights can be a death sentence for our operation when facing a modern EDR. There
    are many ways to get around opening a handle with these rights, such as stealing
    a handle opened by another process or opening a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_DUP_HANDLE</samp>
    rights and then changing the requested rights when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>.
    However, we’re still running in *excel.exe* (or *explorer.exe*, if our persistence
    mechanism has fired), and opening a new process handle may cause further investigation
    to occur, if it doesn’t generate an alert outright.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取另一个用户的身份，我们可以从LSASS中提取凭据。不幸的是，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>
    权限打开LSASS的句柄，在面对现代EDR时可能会给我们的操作带来致命风险。有许多方法可以绕过使用这些权限打开句柄，例如窃取其他进程打开的句柄，或者用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_DUP_HANDLE</samp> 权限打开句柄，然后在调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>
    时更改请求的权限。然而，我们仍然在运行 *excel.exe*（如果我们的持久化机制已启动，则可能是 *explorer.exe*），打开一个新进程句柄可能会引起进一步的调查，甚至可能会直接生成警报。
- en: If we want to act as another user but don’t want to touch LSASS, we still have
    plenty of options, especially since we’re local administrators.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以另一个用户的身份行事，但又不想接触LSASS，我们仍然有很多选择，特别是因为我们是本地管理员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a List of
    Frequent Users</samp>
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">获取常用用户列表</samp>
- en: One of my favorite ways is to target users who I know log in to the system.
    To view the available users, we can run Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module, which tells us which users have logged on recently. This will generate
    some indicators related to Seatbelt’s default namespace, classes, and method names,
    but we can simply change those prior to compilation of the assembly. Once we get
    the results from Seatbelt, we can also check the subdirectories under *C:\Users\*
    using *dir* or an equivalent directory-listing utility to see which users have
    a home folder on the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的一种方法是针对我知道已经登录系统的用户。为了查看可用的用户，我们可以运行Seatbelt的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    模块，该模块可以告诉我们最近有哪些用户登录过。这将生成一些与Seatbelt的默认命名空间、类和方法名称相关的指示符，但我们可以在编译程序集之前简单地更改这些名称。一旦我们从Seatbelt获取结果，我们还可以使用
    *dir* 或等效的目录列出工具检查 *C:\Users\* 下的子目录，看看哪些用户在系统上有主文件夹。
- en: Our execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module returns multiple login events from the user *TTAYLOR.ADMIN@BINFORD.COM*
    over the past 10 days. We can assume from the name that this user is an administrator
    to something, though we’re not quite sure to what.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp> 模块时，返回了过去10天内用户
    *TTAYLOR.ADMIN@BINFORD.COM* 的多个登录事件。从名字推测，我们可以假定该用户是某个系统的管理员，尽管我们不确定具体是哪个系统。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hijacking a File
    Handler</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">劫持文件处理程序</samp>
- en: 'Here are two methods for targeting users of the system on which you’re operating:
    backdooring a *.lnk* file on the user’s desktop for an application they frequently
    open, such as a browser, and hijacking a file handler for the target user through
    registry modification. Both techniques rely on the creation of new files on the
    host. However, the use of *.lnk* files has been covered extensively in public
    reporting, so there are likely detections around their creation. File-handler
    hijacks have gotten less attention. Therefore, their use may pose a smaller risk
    to the security of our operation.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两种针对你正在操作的系统用户的攻击方法：通过在用户桌面上为他们经常打开的应用程序（如浏览器）植入一个*.lnk*文件，或者通过注册表修改劫持目标用户的文件处理程序。这两种技术都依赖于在主机上创建新文件。然而，*.lnk*文件的使用已经在公共报告中得到了广泛的覆盖，因此其创建可能会被检测到。文件处理程序劫持较少受到关注。因此，它们的使用可能对我们操作的安全性构成较小的风险。
- en: For readers unfamiliar with this technique, let’s cover the relevant background
    information. Windows needs to know which applications open files with certain
    extensions. For instance, by default, the browser opens *.pdf* files, though users
    can change this setting. These extension-to-application mappings are stored in
    the registry, under *HKLM:\Software\Classes\* for handlers registered for the
    whole system and *HKU:\<SID>\SOFTWARE\Classes\* for per-user registrations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉这种技术的读者，让我们来介绍相关的背景信息。Windows 需要知道哪些应用程序可以打开具有特定扩展名的文件。例如，浏览器默认打开*.pdf*文件，尽管用户可以更改这个设置。这些扩展名到应用程序的映射存储在注册表中，系统范围内的处理程序存储在*HKLM:\Software\Classes\*，而每个用户的注册信息存储在*HKU:\<SID>\SOFTWARE\Classes\*中。
- en: By changing the handler for a specific file extension to a program that we implement,
    we can get our code to execute in the context of the user who opened the hijacked
    file type. Then we can open the legitimate application to fool the user into thinking
    everything is normal. To make this work, we must create a tool that first runs
    our agent shellcode and then proxies the path of the file to be opened to the
    original file handler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将特定文件扩展名的处理程序更改为我们实现的程序，我们可以让我们的代码在打开被劫持文件类型的用户的上下文中执行。然后，我们可以打开合法的应用程序，欺骗用户以为一切正常。为了使其工作，我们必须创建一个工具，首先运行我们的代理shellcode，然后将要打开的文件的路径代理到原始文件处理程序。
- en: The shellcode runner portion can use any method of executing our agent code
    and as such will inherit the indicators unique to that execution method. This
    is the same as was the case with our initial access payload, so we won’t cover
    the details of that again. The proxying portion can be as simple as calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp> on the
    intended file handler and passing in the arguments received from the operating
    system when the user attempts to open the file. Depending on the target of the
    hijack, this can create an abnormal parent–child process relationship, as our
    malicious intermediary handler will be the parent of the legitimate handler. In
    other cases, such as *.accountpicture-ms* files, the handler is a DLL that is
    loaded into *explorer.exe*, making it so that the child process could look like
    a child of *explorer.exe* rather than another executable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode执行部分可以使用任何执行我们代理代码的方法，因此它将继承该执行方法特有的指示符。这与我们最初的访问载荷相同，因此我们不会再次详细讨论。代理部分可以像调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>一样简单，将操作系统在用户尝试打开文件时传递的参数传递给目标文件处理程序。根据劫持的目标，这可能会创建一个异常的父子进程关系，因为我们的恶意中介处理程序将成为合法处理程序的父进程。在其他情况下，如*.accountpicture-ms*文件，处理程序是一个被加载到*explorer.exe*中的DLL，这样子进程看起来更像是*explorer.exe*的子进程，而不是另一个可执行文件的子进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Choosing a File Extension</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">选择文件扩展名</samp>
- en: Because we’re still running in *excel.exe*, the modification of arbitrary file-handler
    binaries may seem odd to an EDR monitoring the registry events. Excel is, however,
    directly responsible for certain file extensions, such as *.xlsx* and *.csv*.
    If detection is a concern, it’s best to choose a handler that is appropriate for
    the context.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们仍在运行*excel.exe*，所以修改任意文件处理程序的二进制文件可能会引起EDR监控注册表事件时的异常。然而，Excel直接负责某些文件扩展名的处理，例如*.xlsx*和*.csv*。如果检测是一个问题，最好选择一个适合上下文的处理程序。
- en: Unfortunately for us, Microsoft has implemented measures to limit our ability
    to change the handler associated with certain file extensions via direct registry
    modification; it checks hashes that are unique to each app and user. We can enumerate
    these protected file extensions by looking for registry keys with <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    subkeys containing a value called <samp class="SANS_TheSansMonoCd_W5Regular_11">Hash</samp>.
    Among these protected file extensions are Office file types (like *.xlsx* and
    *.docx*), *.pdf*, *.txt*, and *.mp4*, to name a few. If we want to hijack Excel-related
    file extensions, we need to somehow figure out the algorithm that Microsoft uses
    to create these hashes and reimplement it ourselves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，微软已经实施了一些措施，限制了我们通过直接修改注册表来更改与某些文件扩展名关联的处理程序的能力；它检查每个应用程序和用户特有的哈希值。我们可以通过查找包含名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Hash</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    子键来枚举这些受保护的文件扩展名。受保护的文件扩展名包括 Office 文件类型（如 *.xlsx* 和 *.docx*）、*.pdf*、*.txt* 和
    *.mp4* 等。如果我们想劫持与 Excel 相关的文件扩展名，我们需要以某种方式弄清楚微软用于生成这些哈希值的算法，并重新实现它。
- en: Thankfully, GitHub user “default-username-was-already-taken” offers a PowerShell
    version of the necessary hashing algorithm, *Set-FileAssoc.ps1*. Working with
    PowerShell can be tricky; it’s subject to high levels of scrutiny by AMSI, script-block
    logging, and consumers monitoring the associated ETW provider. Sometimes the mere
    fact of *powershell.exe* spawning can trigger an alert for a suspicious process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，GitHub 用户“default-username-was-already-taken”提供了所需哈希算法的 PowerShell 版本，*Set-FileAssoc.ps1*。使用
    PowerShell 可能会有些棘手；它会受到 AMSI、高级脚本块日志记录以及消费者监视相关 ETW 提供程序的严格审查。有时，*powershell.exe*
    的启动本身就可能触发对可疑进程的警报。
- en: Thus, we’ll aim to use PowerShell in the safest way possible, with the least
    risk of exposure. Let’s take a closer look at how the execution of this script
    on the target might get us caught and see what we can mitigate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是以最安全的方式使用 PowerShell，尽可能降低暴露的风险。让我们仔细看看，在目标系统上执行这个脚本可能如何导致我们被发现，以及我们可以采取哪些措施来降低风险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Modifying the PowerShell Script</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">修改 PowerShell 脚本</samp>
- en: If you review the script yourself, you’ll see that it isn’t too alarming; it
    appears to be a standard administrative tool. The script first sets up a P/Invoke
    signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!RegQueryInfoKey()</samp>
    function and adds a custom C# class called <samp class="SANS_TheSansMonoCd_W5Regular_11">HashFuncs</samp>.
    It defines a few helper functions that interact with the registry, enumerate users,
    and calculate the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    hash. The final block executes the script, setting the new file handler and hash
    for the specified file extension.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己查看这个脚本，你会发现它并不令人过于担忧；它看起来像是一个标准的管理工具。脚本首先为 <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!RegQueryInfoKey()</samp>
    函数设置一个 P/Invoke 签名，并添加一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">HashFuncs</samp>
    的自定义 C# 类。它定义了几个与注册表交互、枚举用户和计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    哈希值的辅助函数。最后一块执行脚本，设置指定文件扩展名的新文件处理程序和哈希值。
- en: This means we won’t need to modify much. The only things we need to worry about
    are some of the static strings, as those are what sensors will capture. We can
    remove a vast majority of them, as they’re included for debugging purposes. The
    rest we can rename, or *mangle*. These strings include the contents of variables,
    as well as the names of the variables, functions, namespaces, and classes used
    throughout the script. All of these values are fully under our control, so we
    can change them to whatever we want.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不需要做太多修改。我们需要担心的唯一问题是一些静态字符串，因为这些是传感器会捕捉到的内容。我们可以删除绝大部分这些字符串，因为它们是为了调试目的而包含的。其余的我们可以重命名，或者*篡改*。这些字符串包括变量的内容，以及脚本中使用的变量名、函数名、命名空间和类名。所有这些值完全由我们控制，因此我们可以根据需要随意更改它们。
- en: We do need to be careful with what we change these values to, though. EDRs can
    detect script obfuscation by looking at the entropy, or randomness, of a string.
    In a truly random string, the characters should all receive equal representation.
    In the English language, the five most common letters are E, T, A, O, and I; less
    commonly used letters include Z, X, and Q. Renaming our strings to values like
    *z0fqxu5* and *xyz123* could alert an EDR to the presence of high-entropy strings.
    Instead, we can simply use English words, such as *eagle* and *oatmeal*, to perform
    our string replacement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Executing the PowerShell Script</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next decision we need to make is how we’re going to execute this PowerShell
    script. Using Cobalt Strike Beacon as an example agent, we have a few options
    readily available to us in our command-and-control agent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Drop the file to disk and execute it directly with *powershell.exe*.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script in memory using a download cradle and *powershell.exe*.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script in memory using Unmanaged PowerShell (*powerpick*) in a sacrificial
    process.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject Unmanaged PowerShell into a target process and execute the script in
    memory (*psinject*).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Option 1 is the least preferrable, as it involves activities that Excel would
    rarely perform. Option 2 is slightly better because we no longer have to drop
    the script onto the host’s filesystem, but it introduces highly suspicious indicators,
    both in the network artifacts generated when we request the script from the payload-hosting
    server and in the invocation of *powershell.exe* by Excel with a script downloaded
    from the internet.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Option 3 is slightly better than the previous two but isn’t without its own
    risks. Spawning a child process is always dangerous, especially when combined
    with code injection. Option 4 is not much better, as it drops the requirement
    of creating a child process but still necessitates opening a handle to an existing
    process and injecting code into it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If we consider options 1 and 2 to be off the table because we don’t want Excel
    spawning *powershell.exe*, we’re left deciding between options 3 and 4\. There
    is no right answer, but I find the risk of using a sacrificial process more palatable
    than the risk of injecting into another one. The sacrificial process will terminate
    as soon as our script completes its execution, removing persistent artifacts,
    including the loaded DLLs and the in-memory PowerShell script, from the host.
    If we were to inject into another process, those indicators could remain loaded
    in the host process even after our script completes. So, we’ll use option 3.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to decide what our hijack should target. If we wanted to expand
    our access indiscriminately, we’d want to hijack an extension for the entire system.
    However, we’re after the user *TTAYLOR.ADMIN*. Since we have local administrator
    rights on the current system, we can modify the registry keys of a specific user
    through the *HKU* hive, assuming we know the user’s security identifier (SID).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要决定我们的劫持目标是什么。如果我们想要不加区分地扩展访问权限，我们会劫持整个系统的扩展名。但是，我们的目标是用户 *TTAYLOR.ADMIN*。由于我们在当前系统上具有本地管理员权限，因此我们可以通过
    *HKU* hive 修改特定用户的注册表键，前提是我们知道该用户的安全标识符（SID）。
- en: Thankfully, there’s a way to get the SID from Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module. Each 4624 event contains the user’s SID in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubjectUserSid</samp>
    field. Seatbelt comments out this attribute in the code to keep the output clean,
    but we can simply uncomment that line and recompile the tool to get that information
    without needing to run anything else.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以从 Seatbelt 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    模块中获取 SID。每个 4624 事件都会在 <samp class="SANS_TheSansMonoCd_W5Regular_11">SubjectUserSid</samp>
    字段中包含用户的 SID。Seatbelt 在代码中将此属性注释掉，以保持输出的简洁，但我们可以简单地取消注释该行并重新编译工具，以便在不运行其他任何操作的情况下获取该信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Building the Malicious Handler</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">构建恶意处理程序</samp>
- en: With all the requisite information collected we can hijack the handler for the
    *.xlsx* file extension for only this user. The first thing we need to do is create
    the malicious handler. This simple application will execute our shellcode and
    then open the intended file handle, which should open the file selected by the
    user in a way they’d expect. This file will need to be written to the target filesystem,
    so we know we’re going to be scanned, either at the time we upload it or on its
    first invocation based on the configuration of the EDR’s minifilter. To mitigate
    some of this risk, we can obfuscate the evil handler in a way that will hopefully
    allow us to fly under the radar.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了所有必要的信息后，我们可以劫持仅针对该用户的 *.xlsx* 文件扩展名的处理程序。我们需要做的第一件事是创建恶意处理程序。这个简单的应用程序将执行我们的
    shellcode，然后打开目标文件句柄，这应该会以用户预期的方式打开用户选择的文件。此文件需要写入目标文件系统，因此我们知道我们将在上传时或根据 EDR
    的 minifilter 配置在首次调用时被扫描。为了减少一些风险，我们可以通过混淆恶意处理程序的方式，尽可能地避免被扫描工具发现。
- en: The first big issue we’ll need to conceal is the huge blob of agent shellcode
    hanging out in our file. If we don’t obfuscate this, a mature scanner will quickly
    identify our handler as malicious. One of my favorite ways to obscure these agent
    shellcode blobs is called *environmental keying*. The general gist is that you
    encrypt the shellcode using a symmetric key derived from some attribute unique
    to the system or context under which you’ll be running. This can be anything from
    the target’s internal domain name to the serial number of the hard drive inside
    the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要掩盖的第一个大问题是文件中悬挂的巨大的代理 shellcode 数据块。如果我们不对其进行混淆，成熟的扫描器会很快识别出我们的处理程序是恶意的。我最喜欢的一种掩盖这些代理
    shellcode 数据块的方法叫做 *环境键控*。其大致思路是，使用从系统或运行环境中某些唯一属性派生的对称密钥加密 shellcode。这个属性可以是从目标的内部域名到系统硬盘的序列号等任何内容。
- en: 'In our case, we’re targeting the user *TTAYLOR.ADMIN@BINFORD.COM*, so we use
    their username as our key. Because we want the key to be difficult to brute-force
    should our payload fall into the hands of an incident responder, we pad it out
    to 32 characters by repeating the string, making our symmetric key the following:
    *TTAYLOR.ADMIN@BINFORD.COMTTAYLOR*. We could also combine it with other attributes,
    such as the system’s current IP address, to add some more variation to the string.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们的目标是用户 *TTAYLOR.ADMIN@BINFORD.COM*，所以我们使用他们的用户名作为我们的密钥。因为我们希望密钥在我们的有效载荷落入事件响应者手中时难以暴力破解，我们通过重复字符串将密钥填充为
    32 个字符，生成的对称密钥如下：*TTAYLOR.ADMIN@BINFORD.COMTTAYLOR*。我们还可以将其与其他属性（如系统的当前 IP 地址）结合，以增加字符串的多样性。
- en: Back on our payload development system, we generate the agent shellcode and
    encrypt it using a symmetric key algorithm—say, AES-256—along with our key. We
    then replace the non-obfuscated shellcode with the encrypted blob. Next, we need
    to add key-derivation and decryption functions. To get our key, our payload needs
    to query the executing user’s name. There are simple ways to do this, but bear
    in mind that the more simplistic the derivation method, the easier it will be
    for a skilled analyst to reverse the logic. The more obscure the method of identifying
    the user’s name, the better; I’ll leave finding a suitable strategy as an exercise
    to the reader. The decryption function is much more straightforward. We simply
    pad the key out to 32 bytes and then pass the encrypted shellcode and key through
    a standard AES-256 decryption implementation, then save the decrypted results.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的有效载荷开发系统中，我们生成代理壳码并使用对称密钥算法——比如AES-256——以及我们的密钥对其进行加密。然后，我们将未混淆的壳码替换为加密后的二进制数据。接下来，我们需要添加密钥衍生和解密函数。为了获取我们的密钥，载荷需要查询执行用户的用户名。有一些简单的方法可以做到这一点，但请记住，衍生方法越简单，熟练的分析师越容易逆向推断其逻辑。识别用户姓名的方法越隐蔽越好；我将找到合适策略的任务留给读者。解密函数则更加直接。我们只需将密钥填充至32字节，然后通过标准的AES-256解密实现将加密的壳码和密钥传入，最后保存解密后的结果。
- en: Now here comes the trick. Only our intended user should be able to decrypt the
    payload, but we have no guarantees that it won’t fall into the hands of Binford’s
    SOC or managed security service providers. To account for this possibility, we
    can use a *tamper sensor*, which works like this. If decryption works as expected,
    the decrypted buffer will be filled with known contents we can hash. If the wrong
    key is used, the resultant buffer will be invalid, causing a hash mismatch. Our
    application can take the hash of the decrypted buffer before executing it and
    notify us if it detects a hash mismatch. This notification could be a POST request
    to a web server or something as subtle as changing the timestamp of a specific
    file on the system we monitor. We can then initiate a full infrastructure teardown
    so that incident responders can’t start hitting our infrastructure or simply collect
    information about the failure and adjust accordingly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，诀窍来了。只有我们预定的用户应该能够解密载荷，但我们不能保证它不会落入Binford的SOC或托管安全服务提供商的手中。为了应对这种可能性，我们可以使用一个*篡改传感器*，其工作原理如下。如果解密按预期工作，解密后的缓冲区将被已知内容填充，我们可以对其进行哈希处理。如果使用了错误的密钥，结果缓冲区将无效，导致哈希不匹配。我们的应用程序可以在执行解密后的缓冲区之前对其哈希进行计算，并在检测到哈希不匹配时通知我们。这个通知可以是向一个Web服务器发送的POST请求，或者像更改我们监控系统中特定文件的时间戳这样微妙的动作。然后，我们可以启动完整的基础设施拆解，以防事件响应人员开始攻击我们的基础设施，或简单地收集故障信息并做出相应调整。
- en: Since we know we’ll deploy this payload on only one host, we opt for the timestamp-monitoring
    approach. The implementation of this method is irrelevant and has a very low detection
    footprint; we merely change the timestamp of some file hidden deep in some directory
    and then use a persistent daemon to watch it for changes and to notify us if it
    detects something.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道只会在一个主机上部署此有效载荷，因此我们选择时间戳监控方法。这种方法的实现无关紧要，而且检测的痕迹非常小；我们只是更改一些深藏在某个目录中的文件的时间戳，然后使用一个持久守护进程来监视它的变化，并在发现变化时通知我们。
- en: Now we need to figure out the location of the legitimate handler so that we
    can proxy requests to open *.xlsx* files to it. We can pull this from the registry
    for a specific user if we know their SID, which our modified copy of Seatbelt
    told us is *S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032* for *TTAYLOR.ADMIN@BINFORD.COM*.
    We query the *xlsx* value in *HKU:\S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032\SOFTWARE\Microsoft\Windows\CurrentVersion\Extensions*,
    which returns *C:\Program Files (x86)\Microsoft Office\Root\Office16\EXCEL.EXE*.
    Back in our handler, we write a quick function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>
    with the path to the real *excel.exe*, passing along the first parameter, which
    will be the path to the *.xlsx* file to open. This should execute after our shellcode
    runner but should not wait for it to complete so that the agent being spawned
    is apparent to the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要弄清楚合法处理程序的位置，以便将打开*.xlsx*文件的请求代理到它。我们可以从特定用户的注册表中获取这个路径，如果我们知道他们的SID，而我们的修改版Seatbelt工具告诉我们，*TTAYLOR.ADMIN@BINFORD.COM*的SID是*S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032*。我们在*HKU:\S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032\SOFTWARE\Microsoft\Windows\CurrentVersion\Extensions*中查询*xlsx*值，这将返回*C:\Program
    Files (x86)\Microsoft Office\Root\Office16\EXCEL.EXE*。然后，在我们的处理程序中，我们编写一个快速函数来调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>，并传递真实*excel.exe*的路径，以及第一个参数，它将是要打开的*.xlsx*文件的路径。这个操作应该在我们的shellcode运行器之后执行，但不应等待它完成，以便生成的代理程序对用户是明显的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Compiling the Handler</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">编译处理程序</samp>
- en: 'When it comes to compiling our handler, there are a couple of things we need
    to do to avoid detection. These include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译我们的处理程序时，有几件事我们需要做以避免被检测。这些包括：
- en: '**Removing or mangling all string constants**   This will reduce the chance
    that signatures will trigger or be created based on strings used in our code.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除或混淆所有字符串常量**   这将减少基于我们代码中使用的字符串生成签名或触发签名的可能性。'
- en: '**Disabling the creation of program database (PDB) files**   These files include
    the symbols used for debugging our application, which we won’t need on our target.
    They can leak information about our build environment, such as the path at which
    the project was compiled.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用程序数据库（PDB）文件的创建**   这些文件包含用于调试我们应用程序的符号，而我们在目标系统上不需要这些文件。它们可能会泄露有关我们构建环境的信息，例如项目编译时的路径。'
- en: '**Populating image details**   By default, our compiled handler will contain
    only basic information when inspected. To make things look a little bit more realistic,
    we can populate the publisher, version, copyright information, and other details
    you’d see after opening the Details tab in the file’s properties.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充图像详情**   默认情况下，我们编译的处理程序在检查时只包含基本信息。为了让内容看起来更真实，我们可以填充发布者、版本、版权信息以及在文件属性的“详细信息”标签中看到的其他信息。'
- en: Of course, we could take additional measures to further protect our handler,
    such as using LLVM to obfuscate the compiled code and signing the *.exe* with
    a code-signing certificate. But because the risk of this technique being detected
    is already pretty low and we have some protections in place, we’ll save those
    measures for another time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以采取额外的措施来进一步保护我们的处理程序，例如使用LLVM来混淆编译的代码，并用代码签名证书对*.exe*进行签名。但由于这种技术被检测到的风险已经相当低，并且我们已经采取了一些保护措施，因此我们将这些额外的措施留待以后再说。
- en: Once we’ve compiled our handler with these optimizations and tested it in a
    lab environment that mimics the Binford system, we’ll be ready to deploy it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将这些优化应用到处理程序并在模拟Binford系统的实验环境中进行了测试，我们就可以准备部署它了。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registering the Handler</samp>
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">注册处理程序</samp>
- en: Registering a file or protocol handler may seem relatively simple at face value;
    you overwrite the legitimate handler with a path to your own. Is that it? Not
    quite. Nearly every file handler is registered with a programmatic identifier
    (ProgID), a string used to identify a COM class. To follow this standard, we need
    to either register our own ProgID or hijack an existing one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注册文件或协议处理程序看似相对简单；你只需将合法的处理程序路径替换为自己的路径。仅此而已？其实不完全是。几乎所有的文件处理程序都会使用程序标识符（ProgID）进行注册，这是一个用于标识COM类的字符串。为了遵循这个标准，我们需要注册我们自己的ProgID，或者劫持现有的ProgID。
- en: 'Hijacking an existing ProgID can be risky, as it may break some functionality
    on the system and tip the user off that something is wrong, so this probably isn’t
    the right strategy in this case. We could also look for an abandoned ProgID: one
    that used to be associated with some software installed on the system. Sometimes,
    when the software is removed, its uninstaller fails to delete the associated COM
    registration. However, finding these is relatively rare.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 劫持现有的 ProgID 可能很危险，因为它可能会破坏系统中的某些功能，并让用户意识到某些不对劲，所以在这种情况下这可能不是最佳策略。我们也可以尝试寻找一个废弃的
    ProgID：它曾经与系统中安装的某个软件相关联。有时，当软件被卸载时，卸载程序未能删除相关的 COM 注册。但是，找到这些情况的机会相对较小。
- en: Instead, we’ll opt to register our own ProgID. It’s hard for an EDR to monitor
    the creation of all registry keys and all values being set at scale, so the odds
    are good that our malicious ProgID registration will go unnoticed. [Table 13-3](#tab13-3)
    shows the basic changes we’ll need to make under the target user’s registry hive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们选择注册自己的 ProgID。由于 EDR 很难在大规模上监控所有注册表键的创建以及所有值的设置，因此我们恶意的 ProgID 注册很可能不会引起注意。[表
    13-3](#tab13-3)展示了我们在目标用户注册表下需要做的基本修改。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp> <samp class="SANS_Futura_Std_Book_11">Keys
    to Be Created for Handler Registration</samp>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-3：</samp> <samp class="SANS_Futura_Std_Book_11">要为处理程序注册而创建的键</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Key</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">键</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\Excel.WorkBook.16\CLSID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{1CE29631-7A1E-4A36-8C04-AFCCD716A718}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides the ProgID-to-CLSID mapping</samp>
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\Excel.WorkBook.16\CLSID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{1CE29631-7A1E-4A36-8C04-AFCCD716A718}</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供 ProgID 到 CLSID 的映射</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\CLSID\{1CE29631
    -7A1E-4A36-8C04-AFCCD716A718}\ProgID</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">ExcelWorkBook.16</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides the CLSID-to-ProgID mapping</samp>
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\CLSID\{1CE29631
    -7A1E-4A36-8C04-AFCCD716A718}\ProgID</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">ExcelWorkBook.16</samp>
    | <samp class="SANS_Futura_Std_Book_11">提供 CLSID 到 ProgID 的映射</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Classes\CLSID\{1CE29631-7A1E
    -4A36-8C04-AFCCD716A718}\InprocServer32</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\path\to\our\handler.dll</samp>
    | <samp class="SANS_Futura_Std_Book_11">Specifies the path to our malicious handler</samp>
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Classes\CLSID\{1CE29631-7A1E
    -4A36-8C04-AFCCD716A718}\InprocServer32</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\path\to\our\handler.dll</samp>
    | <samp class="SANS_Futura_Std_Book_11">指定我们恶意处理程序的路径</samp> |'
- en: Before deploying our changes to the live target, we can validate them in a lab
    environment using the PowerShell commands shown in [Listing 13-2](#list13-2).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在将更改部署到实际目标之前，我们可以使用 [列表 13-2](#list13-2) 中显示的 PowerShell 命令在实验室环境中验证它们。
- en: '[PRE1]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: Validating COM object registration'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-2：验证 COM 对象注册
- en: We get the type associated with our ProgID and then pass it to a function that
    creates an instance of a COM object. The last command shows the methods supported
    by our server as a final sanity check. If everything worked correctly, we should
    see the methods we implemented in our COM server returned to us via this newly
    instantiated object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取与 ProgID 相关的类型，然后将其传递给一个函数，创建一个 COM 对象的实例。最后的命令显示我们服务器支持的方法，作为最终的检查。如果一切正常，我们应该会通过这个新实例化的对象看到我们在
    COM 服务器中实现的方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deploying the Handler</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">部署处理程序</samp>
- en: Now we can upload the handler to the target’s filesystem. This executable can
    be written to any location the user has access to. Your inclination may be to
    hide it deep in some folder unrelated to Excel’s operation, but this could end
    up looking odd when it’s executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将处理程序上传到目标的文件系统中。这个可执行文件可以写入用户有权限访问的任何位置。你可能会倾向于将它隐藏在与 Excel 操作无关的某个深层文件夹中，但当执行时，这样的做法可能显得有些奇怪。
- en: Instead, hiding it in plain sight might be our best option. Since we’re an admin
    on this system, we can write to the directory in which the real version of Excel
    is installed. If we place our file alongside *excel.exe* and name it something
    innocuous, it may look less suspicious.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将其隐藏在明面上可能是我们最好的选择。由于我们是该系统的管理员，我们可以写入真实版本的 Excel 安装目录。如果我们将文件与 *excel.exe*
    一起放置，并将其命名为某个无害的名字，它看起来可能就不那么可疑了。
- en: As soon as we drop our file to disk, the EDR will subject it to scanning. Hopefully,
    the protections we put in place mean it isn’t deemed malicious (though we might
    not know this until it is executed). If the file isn’t immediately quarantined,
    we can proceed by making the registry changes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将文件保存到磁盘，EDR 将会对其进行扫描。希望我们设置的保护措施能够确保它不会被判定为恶意文件（尽管我们可能直到文件执行后才知道这一点）。如果文件没有立即被隔离，我们可以通过修改注册表来继续操作。
- en: Making changes in the registry can be fairly safe depending on what is being
    modified. As discussed in [Chapter 5](chapter5.xhtml), registry callback notifications
    might have to process thousands upon thousands of registry events per second.
    Thus, they must limit what they monitor. Most EDRs monitor only keys associated
    with specific services, as well as subkeys and values, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">RunAsPPL</samp>
    value, which controls whether LSASS is launched as a protected process. This works
    out well for us, because while we know that our actions will generate telemetry,
    we won’t touch any of the keys that are likely to be monitored.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 修改注册表是相对安全的，具体取决于修改的内容。如[第 5 章](chapter5.xhtml)所述，注册表回调通知可能需要处理每秒成千上万的注册表事件。因此，它们必须限制监视的内容。大多数
    EDR 仅监视与特定服务相关的键，以及子键和值，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">RunAsPPL</samp>
    值，它控制 LSASS 是否作为受保护的进程启动。这对我们有利，因为虽然我们知道我们的操作会生成遥测数据，但我们不会触碰任何可能被监视的键。
- en: That said, we should change as little as possible. Our PowerShell script will
    modify the values shown in [Table 13-4](#tab13-4) under the target user’s registry
    hive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们应尽量减少修改。我们的 PowerShell 脚本将修改目标用户的注册表项中的值，如[表 13-4](#tab13-4)所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp> <samp class="SANS_Futura_Std_Book_11">Registry
    Keys Modified During Handler Registration</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-4：</samp> <samp class="SANS_Futura_Std_Book_11">处理程序注册期间修改的注册表键</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Registry key</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Operation</samp>
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">注册表键</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">操作</samp>
    |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">Delete</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">删除</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">Create</samp> |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">创建</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\Hash</samp>
    | <samp class="SANS_Futura_Std_Book_11">Set value</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\Hash</samp>
    | <samp class="SANS_Futura_Std_Book_11">设置值</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\ProgId</samp>
    | <samp class="SANS_Futura_Std_Book_11">Set value</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\ProgId</samp>
    | <samp class="SANS_Futura_Std_Book_11">设置值</samp> |'
- en: As soon as these registry changes are made, our handler should be functional
    on the system. Whenever the user next opens a *.xlsx* file, our handler will be
    invoked via the common language runtime, execute our shellcode, and then open
    the real Excel to allow the user to interact with the spreadsheet. When our agent
    checks in with our command-and-control infrastructure, we should see it come through
    as *TTAYLOR.ADM@BINFORD.COM*, elevating our privileges to what appears to be an
    administrator account on Binford’s Active Directory domain, all without opening
    a handle to LSASS!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些注册表更改完成，我们的处理程序应该能够在系统上运行。每当用户下次打开一个 *.xlsx* 文件时，我们的处理程序将通过公共语言运行时被调用，执行我们的
    Shellcode，然后打开真实的 Excel 以便用户与电子表格进行交互。当我们的代理与我们的指挥和控制基础设施联系时，我们应该会看到它以 *TTAYLOR.ADM@BINFORD.COM*
    的身份出现，从而将我们的权限提升到 Binford 的 Active Directory 域中的管理员账户，所有这些都不需要打开 LSASS 的句柄！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lateral Movement</samp>
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">横向移动</samp>
- en: Now that our agent is running on what we suspect to be a privileged account,
    we need to discover what kind of access we have in the domain. Rather than throwing
    SharpHound around to collect information (an activity that has become more difficult
    to do successfully), we can perform more surgical examination to figure out how
    we can move to another host.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代理正在运行在我们怀疑是一个特权账户的环境中，我们需要发现我们在域中拥有的访问权限。与其通过使用 SharpHound 来收集信息（这项活动已经变得越来越难以成功执行），我们可以进行更精细的检查，以找出如何跳转到另一台主机。
- en: You might think that lateral movement, or expanding our access to the environment,
    must involve deploying more agents on more hosts. However, this can add a ton
    of new indicators that we may not need. Take PsExec-based lateral movement, for
    example, in which a service binary containing agent shellcode is copied to the
    target system and a service targeting that newly copied binary is created and
    started, initiating a new callback. This would involve generating a network logon
    event, as well as creating a new file, registry keys for the associated service,
    a new process, and a network connection to either our command-and-control infrastructure
    or our compromised hosts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，横向移动，或者扩展我们对环境的访问，必须涉及在更多主机上部署更多的代理。然而，这可能会增加大量我们不需要的新指标。例如，基于 PsExec
    的横向移动，其中包含代理 Shellcode 的服务二进制文件被复制到目标系统，并创建并启动一个指向该新复制二进制文件的服务，从而启动一个新的回调。这将涉及生成一个网络登录事件，以及创建新文件、注册表键、关联服务的新进程和网络连接，连接到我们的指挥和控制基础设施或我们被攻陷的主机。
- en: 'The question then becomes: do we absolutely need to deploy a new agent, or
    are there other ways to get what we need?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 问题就变成了：我们是否绝对需要部署一个新代理，还是有其他方式可以获得我们需要的信息？
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding a Target</samp>
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">寻找目标</samp>
- en: One of the first places to start looking for lateral movement targets is the
    list of established network connections on the current host. This approach has
    a few benefits. First, it doesn’t require network scanning. Second, it can help
    you understand the environment’s firewall configuration, because if there is an
    established connection from the host to another system, it’s safe to assume that
    a firewall rule allowed it. Lastly, it can let us blend in. Since our compromised
    system has connected to the hosts in the list at least once, a new connection
    might seem less anomalous than one to a system with which the host has never communicated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找横向移动目标的首个地方之一是当前主机上已建立的网络连接列表。这种方法有几个好处。首先，它不需要网络扫描。其次，它可以帮助你理解环境的防火墙配置，因为如果主机与另一台系统之间已经建立了连接，那么可以安全地假设防火墙规则允许了它。最后，它可以帮助我们融入环境。由于我们被攻陷的系统至少曾与列表中的主机连接过一次，因此新的连接可能看起来比连接到从未与该主机通信过的系统更加不显眼。
- en: Since we accepted the risk of using Seatbelt previously, we can use it again.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpConnections</samp> module
    lists the existing connections between our host and others in the network, as
    shown in [Listing 13-3](#list13-3).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们之前已经接受了使用 Seatbelt 的风险，我们可以再次使用它。<samp class="SANS_TheSansMonoCd_W5Regular_11">TcpConnections</samp>
    模块列出了我们的主机与网络中其他主机之间的现有连接，如 [列表 13-3](#list13-3) 所示。
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-3: Enumerating network connections with Seatbelt'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-3：使用 Seatbelt 枚举网络连接
- en: This output can sometimes be overwhelming due to the sheer volume of connections
    some systems make. We can prune this list a bit by removing connections we’re
    not interested in. For example, we can remove any HTTP and HTTPS connections,
    as we’d most likely need to provide a username and password to access these servers;
    we have access to a token belonging to *TTAYLOR.ADM@BINFORD.COM* but not the user’s
    password. We can also remove any loopback connections, as this won’t help us expand
    our access to new systems in the environment. That leaves us with a substantially
    smaller list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: From here, we notice multiple connections to internal hosts over arbitrarily
    high ports, indicative of RPC traffic. There are likely no firewalls between us
    and the hosts, as explicit rules for these ports are very rare, but figuring out
    the nature of the protocol is tricky if we don’t have GUI access to the host.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: There is also a connection to an internal host over TCP port 445 ❶, which is
    virtually always an indication of remote file-share browsing using SMB. SMB can
    use our token for authentication and won’t always require us to enter credentials.
    Furthermore, we can leverage the file-sharing functionality to browse the remote
    system without deploying a new agent. That sounds like exactly what we’re after!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enumerating Shares</samp>
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming this is a traditional SMB connection, we now need to find the name
    of the share being accessed. The easy answer, especially if we assume that we’re
    an administrator, is to mount the *C$* share. This will allow us to browse the
    operating system volume as if we were in the root of the *C:* drive.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in enterprise environments, shared drives are rarely accessed in this
    way. Shared folders are much more common. Unfortunately for us, enumerating these
    shares isn’t as simple as just listing out the contents of *\\10.1.10.48\*. There
    are plenty of ways to get this information, though. Let’s explore some of them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">net view</samp>
    **command**   Requires us to launch *net.exe* on the host, which an EDR’s process-creation
    sensors highly scrutinize'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-SmbShare</samp>
    **in PowerShell**   Built-in PowerShell cmdlet that works both locally and remotely
    but requires us to invoke *powershell.exe*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-WmiObject</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Win32_Share</samp> **in PowerShell**   Similar
    to the previous cmdlet but queries for shares over WMI'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SharpWMI.exe</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">action=query query=" "select * from
    win32_share" "</samp> Functionally the same as the previous PowerShell example
    but uses a .NET assembly, which allows us to operate using execute-assembly and
    its equivalents'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** ***Seatbelt.exe*** **network shares**   Nearly identical to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SharpWMI</samp>; uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Share
    WMI</samp> class to query the shares on a remote system'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples, and there are pros and cons to each. Since we’ve
    already put in the work to obfuscate Seatbelt and know that it works well in this
    environment, we can use it again here. Most EDRs work on a process-centric model,
    meaning that they track activity based on processes. Like our initial access,
    we’ll be running in *excel.exe* and, if needed, set our *spawnto* process to the
    same image as it was previously. When we enumerate remote shares on *10.1.10.48*,
    Seatbelt generates the output shown in [Listing 13-4](#list13-4).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 13-4: Enumerating network shares with Seatbelt'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The information tells us a few things about the target system. First, we have
    the ability to browse *C$*, which indicates that either we were granted read access
    to their filesystem volume, or, more likely, we have administrative access to
    the host. Read access to *C$* allows us to enumerate things such as installed
    software and users’ files. These both can provide valuable context about how the
    system is used and who uses it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The other network shares are more interesting than *C$*, though. They look
    like they belong to various business units inside Binford: *FIN* could stand for
    Finance, *ENG* for Engineering, *IT* for Information Technology, *MKT* for Marketing,
    and so on. *ENG* could be a good target based on our stated objectives.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: However, there are detection risks to finding out for sure. When we list the
    contents of a remote share, a few things happen. First, a network connection is
    established with the remote server. The EDR’s network filter driver will monitor
    this, and because it is an SMB client connection, the Microsoft-Windows-SMBClient
    ETW provider comes into play as well. Our client will authenticate to the remote
    system, creating an event through the ETW provider Microsoft-Windows-Security-Auditing
    (as well as an event ID 5140, indicating that a network share was accessed, in
    the security event log) on the remote system. If a *system access control list
    (SACL)*, a type of access control list used to audit access requests made for
    an object, is set on the shared folder or files within, an event will be generated
    via the Microsoft-Windows-Security-Auditing ETW provider (as well as an event
    ID 4663) when the contents of the shared folder are accessed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, that the fact that telemetry was generated on the host doesn’t
    necessarily mean that it was captured. In my experience, EDRs monitor almost none
    of what I mentioned in the preceding paragraph. They might monitor the authentication
    event and network, but we’re using an already-established network connection to
    the SMB server, meaning browsing the *ENG* share could allow us to blend in with
    the normal traffic coming from this system, lessening the likelihood of detection
    due to an anomalous access event.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that we’ll blend in so much that there is no risk at all.
    Our user may not typically browse the *ENG* share, making any access event anomalous
    at the file level. There may be non-EDR controls, such as data-loss prevention
    software or a canary facilitated through the SACL. We have to measure the reward
    of this share potentially holding Binford’s crown jewels against the risk of detection
    posed by our browsing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: All signs are pointing to this drive holding what we’re after, so we start recursively
    listing the subdirectories of the *ENG* share and find *\\10.1.10.48\ENG\Products\6100\3d\screwdriver_v42.stl*,
    a stereolithography file commonly used by design applications in the mechanical
    engineering world. In order to verify that this file is the 3D model for the Binford
    6100 left-handed screwdriver, we’ll need to exfiltrate it and open it in an application
    capable of processing *.stl* files.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">File Exfiltration</samp>
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step of our attack is pulling Binford’s crown jewels out of its environment.
    Oddly, of everything we’ve done in this operation, this has the lowest likelihood
    of detection by the EDR despite having the highest impact to the environment.
    To be fair, it isn’t really the EDR’s domain. Still, sensors could detect our
    data exfiltration, so we should remain thoughtful in our approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to exfiltrate data from a system. Choosing a technique depends
    on a number of factors, such as the data’s location, contents, and size. Another
    factor to consider is how *fault tolerant* the data format is; if we don’t receive
    the full contents of the file, is it still workable? A text file is a good example
    of a very fault-tolerant file type, as missing half of the file means we’re simply
    missing half of the text in the document. On the other hand, images are generally
    not fault tolerant, because if we’re missing some portion of the picture, we generally
    won’t be able to reconstruct it in any meaningful way.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we should consider how quickly we need the data. If we need it soon
    and all at once, we typically inherit a higher risk of detection than if we exfiltrate
    the file slowly because the volume of data transmitted across the network boundary,
    where security monitoring is likely to be implemented, will be higher in a given
    timeframe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In our operation, we can afford to take more risk because we’re not interested
    in staying embedded in the environment for much longer. Through our reconnaissance
    against the *ENG* share, we see that the *.stl* file is 4MB, which isn’t excessive
    compared to other types of files. Since we have a high risk tolerance and are
    working with a small file, let’s take the easy route and exfiltrate the data over
    our command-and-control channel.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的操作中，我们可以承受更多的风险，因为我们不打算在环境中停留太长时间。通过对 *ENG* 共享文件夹的侦察，我们发现 *.stl* 文件的大小为
    4MB，相对于其他类型的文件并不算过大。由于我们有较高的风险容忍度，并且处理的是一个小文件，我们可以选择简单的方式，通过我们的指挥控制通道外泄数据。
- en: Even though we’re using HTTPS, we should still protect the contents of the data.
    Assume the contents of any message that we send will be subjected to inspection
    by a security product. When it comes to exfiltrating files specifically, one of
    our biggest concerns is the file signature, or *magic bytes*, at the beginning
    of the file used to uniquely identify the file type. For *.stl* files, this signature
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">73 6F 6C 69 64</samp>.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用了 HTTPS，我们仍然应该保护数据的内容。假设我们发送的任何消息内容都会受到安全产品的检查。特别是在外泄文件时，我们最关心的问题之一就是文件签名，或称为*魔术字节*，它位于文件的开头，用于唯一标识文件类型。对于
    *.stl* 文件，这个签名是 <samp class="SANS_TheSansMonoCd_W5Regular_11">73 6F 6C 69 64</samp>。
- en: Thankfully, there are many ways to obfuscate the type of file we’re exfiltrating,
    ranging from encrypting the contents of the file to simply trimming off the magic
    bytes before transmitting the file and then appending them again after the file
    is received. For human-readable file types, I prefer encryption, since there may
    be monitoring in place for a specific string in an outbound connection request.
    For other types of files, I’ll usually either remove, mangle, or falsify the magic
    bytes for the file if detection at this stage is a concern.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢技术的发展，我们有很多方法可以混淆我们正在外泄的文件类型，从加密文件内容到在传输文件前简单地去掉魔术字节，然后在文件接收后再附加回来。对于人类可读的文件类型，我倾向于使用加密，因为可能会有监控针对出站连接请求中的特定字符串。对于其他类型的文件，如果在这个阶段存在被检测的风险，我通常会移除、篡改或伪造文件的魔术字节。
- en: When we’re ready to exfiltrate the file, we can use our agent’s built-in download
    functionality to send it over our established command-and-control channel. When
    we do this, we are going to make a request to open the file so that we can read
    its contents into memory. When this happens, the EDR’s filesystem minifilter driver
    will receive a notification and may look at certain attributes associated with
    the event, such as who the requestor is. Since the organization itself would have
    to build a detection from this data, the likelihood of an EDR having a detection
    here is relatively low.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好外泄文件时，可以使用代理内建的下载功能通过已建立的指挥控制通道发送文件。在此过程中，我们将请求打开文件，以便将其内容读取到内存中。当这种情况发生时，EDR
    的文件系统最小过滤驱动程序会收到通知，并可能查看与事件相关的某些属性，例如请求者是谁。由于组织本身需要根据这些数据建立检测规则，因此 EDR 在此阶段进行检测的可能性相对较低。
- en: Once we’ve read the contents of the file into our agent’s address space, we
    can close the handle to the file and start the transfer. Transmitting data over
    HTTP or HTTPS channels will cause related ETW providers to emit events, but these
    typically don’t include the message contents if the channel is secure, as with
    HTTPS. So, we shouldn’t have any issue getting our design plans out. Once we have
    the file downloaded, we simply add back the magic bytes and open the file in the
    3D modeling software of choice ([Figure 13-1](#fig13-1)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将文件的内容读取到代理的地址空间中，我们可以关闭文件的句柄并开始传输。通过 HTTP 或 HTTPS 通道传输数据会导致相关的 ETW 提供者发出事件，但如果通道是安全的，比如使用
    HTTPS，这些事件通常不会包含消息内容。因此，我们不应该遇到任何问题来获取我们的设计计划。一旦文件下载完成，我们只需将魔术字节加回并在选择的 3D 建模软件中打开文件（[图
    13-1](#fig13-1)）。
- en: '![](../images/Figure13-1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The Binford 6100
    left-handed screwdriver</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-1：Binford 6100 左手螺丝刀</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: 'We’ve completed the engagement objective: accessing the design information
    for Binford’s revolutionary product (pun intended). While executing this operation,
    we used our knowledge of an EDR’s detection methods to make educated choices about
    how to move through the environment.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了任务目标：获取Binford革命性产品的设计信息（故意带有双关意味）。在执行这项操作时，我们利用了对EDR检测方法的了解，做出了明智的决策，选择了如何在环境中移动。
- en: Bear in mind that the path we took may not have been the best (or only) way
    to reach the objective. Could we have outpaced Binford’s defenders without considering
    the noise we were making? What if we decided not to work through Active Directory
    and instead used a cloud-based file-hosting application, such as SharePoint, to
    locate the design information? Each of these approaches significantly alters the
    ways in which Binford could detect us.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们采取的路径可能并不是到达目标的最佳（或唯一）方式。我们能否在没有考虑噪音的情况下超越Binford的防御者？如果我们决定不通过Active
    Directory工作，而是使用基于云的文件托管应用程序，比如SharePoint，来定位设计信息，会怎样呢？每一种方法都会显著改变Binford检测我们的方式。
- en: After reading this book, you should be armed with the information you need to
    make these strategic choices on your own. Tread carefully, and good luck.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本书后，你应该掌握了做出这些战略选择所需的信息。请小心行事，祝你好运。
