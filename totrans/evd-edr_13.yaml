- en: '<samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CASE
    STUDY: A DETECTION-AWARE ATTACK</samp>'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we’ve covered the design of EDRs, the logic of their components, and
    the internal workings of their sensors. Still, we’ve missed one critical piece
    of the puzzle: how to apply this information in the real world. In this final
    chapter, we’ll systematically analyze the actions we’d like to take against target
    systems and determine our risk of being detected.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll target a fictional company, Binford Tools, inventor of the Binford 6100
    left-handed screwdriver. Binford has asked us to identify an attack path from
    a compromised user workstation to a database holding the proprietary design information
    for the 6100\. We’re to be as stealthy as possible so that the company can see
    what its EDR is able to detect. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Rules of Engagement</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binford’s environment consists only of hosts running up-to-date versions of
    the Windows operating system, and all authentication is controlled through on-premises
    Active Directory. Each host has a generic EDR deployed and running, and we aren’t
    allowed to disable, remove, or uninstall it at any point.
  prefs: []
  type: TYPE_NORMAL
- en: Our point of contact has agreed to provide us with a target email address, which
    an employee (whom we’ll refer to as the *white cell*) will monitor, clicking whatever
    links we send to them. However, they won’t add any rule explicitly allowing our
    payloads past their EDR. This will let us spend less time on social engineering
    and more time assessing technical detective and preventive measures.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, every employee at Binford has local administrator rights to their
    workstation, lowering the strain on Binford’s understaffed help desk. Binford
    has asked that we leverage this fact during the operation so that they can use
    the results of the engagement to drive a change to their policy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Initial Access</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by selecting our phishing method. We need fast and direct access to
    the target’s workstation, so we opt to deliver a payload. Threat intelligence
    reporting at the time of the engagement tells us that the manufacturing sector
    is experiencing an uptick in malware dropped using Excel Add-In (XLL) files. Attackers
    have routinely abused XLL files, which allow developers to create high-performance
    Excel worksheet functions, to establish a foothold through phishing.
  prefs: []
  type: TYPE_NORMAL
- en: To mimic attacks Binford may respond to in the future, we opt to use this format
    as our payload. XLL files are really just DLLs that are required to export an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function (and,
    ideally, its complement, <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoClose()</samp>),
    so we can use a simple shellcode runner to speed up the development process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Payload</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Already, we must make a detection-related design decision. Should the shellcode
    be run locally, in the *excel.exe* process, where it will be tied to the lifetime
    of that process, or should it be run remotely? If we created our own host process
    and injected into it, or if we targeted an existing process, our shellcode could
    live longer but have a higher risk of detection due to *excel.exe* spawning a
    child process and the artifacts of remote process injection being present.
  prefs: []
  type: TYPE_NORMAL
- en: As we can always phish more later, we’ll opt to use the local runner and avoid
    prematurely tripping any detections. [Listing 13-1](#list13-1) shows what our
    XLL payload code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: The XLL payload source code'
  prefs: []
  type: TYPE_NORMAL
- en: This local shellcode runner is similar to many DLL-based payloads. The exported
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xlAutoOpen()</samp> function begins
    with a chunk of shellcode (truncated for brevity) ❶ that has been XOR-encrypted
    using the string *specter* as the key ❷. The first action this function takes
    is decrypting the shellcode using this symmetric key ❸. Next, it creates a memory
    allocation tagged with read-write permissions using <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualAlloc()</samp>
    ❹ and then copies the decrypted shellcode into it ❺ ahead of execution. The function
    then changes the memory permissions of the new buffer to tag it as executable
    ❻. Finally, the pointer to the buffer is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateThread()</samp>,
    which executes the shellcode in a new thread ❼, still under the context of *excel.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delivering the Payload</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll assume that Binford’s inbound mail-filtering system allows XLL files to
    reach users’ inboxes, and we send our file to the white cell. Because the XLL
    needs to be run from disk, the white cell will download it to the internal host
    on which the EDR is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: When the white cell executes the XLL, a few things will happen. First, *excel.exe*
    will be started with the path to the XLL passed in as a parameter. The EDR almost
    certainly collects this information from its driver’s process-creation callback
    routine (though the Microsoft-Windows-Kernel-Process ETW provider can provide
    most of the same information). The EDR may have a generic detection built around
    the execution of XLL files, which the process command line could trigger, causing
    an alert.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the EDR’s scanner may conduct an on-access scan of the XLL file.
    The EDR will collect attributes of the file, assess its contents, and attempt
    to decide whether the content should be allowed to run. Let’s say that we did
    such a great job obfuscating our payload that the shellcode and associated runner
    inside weren’t detected by the scanner.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not in the clear yet, though. Remember that most EDRs are deployed in
    multiple large environments and process large amounts of data. With this perspective,
    EDRs can assess the *global uniqueness* of a file, meaning how many times it has
    seen the file in the past. Because we crafted this payload ourselves and it contains
    shellcode tied to our infrastructure, it most likely hasn’t been seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, this isn’t the end of the road by any stretch of the imagination. Users
    write new Word documents all the time. They generate reports for their organization
    and doodle in Paint during the third hour of meetings on “cross-functional synergy
    to meet key quarterly metrics.” If EDRs flagged every single unique file they
    came across, they would create an untenable amount of noise. While our global
    uniqueness may trigger some type of alert, it probably isn’t severe enough to
    kick off an investigation and won’t come into play unless the security operations
    center (SOC) responds to a higher-severity alert related to our activity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Executing the Payload</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we haven’t been blocked yet, *excel.exe* will load and process our XLL.
    As soon as our XLL is loaded, it will hit the <samp class="SANS_TheSansMonoCd_W5Regular_11">DLL_PROCESS_ATTACH</samp>
    reason code, which triggers the execution of our shellcode runner.
  prefs: []
  type: TYPE_NORMAL
- en: When our parent *excel.exe* process was spawned, the EDR injected its DLL, which
    hooked key functions unknown to us at this point. We didn’t use syscalls or include
    any logic to remap these hooked DLLs in *excel.exe*, so we’ll have to pass through
    these hooks and hope we don’t get caught. Thankfully, many of the functions commonly
    hooked by EDRs focus on remote process injection, which doesn’t affect us, as
    we’re not spawning a child process to inject into.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also happen to know that this EDR makes use of the Microsoft-Windows-Threat-Intelligence
    ETW provider, so our activities will be subject to monitoring by those sensors
    on top of the EDR vendor’s own function hooks. Let’s examine the riskiness of
    the functions we call in our payload:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualAlloc()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the standard local-memory-allocation function in Windows and doesn’t
    allow for remote allocations (as in, memory being allocated in another process),
    its use likely won’t be scrutinized in isolation. Additionally, because we aren’t
    allocating read-write-execute memory, a common default for malware developers,
    we’ve mitigated pretty much all the risk that we can.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">memcpy()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previous function, <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</samp>
    is a widely used function and isn’t subject to much scrutiny.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!VirtualProtect()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: This is where things become riskier for us. Because we have to convert the protections
    for our allocation from read-write to read-execute, this step is unfortunately
    unavoidable. Since we’ve passed the desired protection level as a parameter to
    this function, EDRs can trivially identify this technique via function hooking.
    Additionally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    sensor will detect the changes in protection state and notify consumers of the
    Microsoft-Windows-Threat-Intelligence ETW provider.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">kernel32!CreateThread()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: In isolation, this function doesn’t present much of a risk, as it is the standard
    way of creating new threads in multithreaded Win32 applications. However, since
    we’ve performed the previous three actions, which, combined, may indicate the
    presence of malware on the system, its use may be the proverbial straw that breaks
    the camel’s back in terms of causing an alert to fire. Unfortunately for us, we
    don’t really have many options to avoid its use, so we’ll just stick with it and
    hope that if we’ve gotten this far, our shellcode will execute.
  prefs: []
  type: TYPE_NORMAL
- en: This shellcode runner technique could be optimized in plenty of ways, but compared
    to the textbook <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateRemoteThread()</samp>-based
    approach to remote process injection, it’s not too bad. If we assume that these
    indicators fly under the radar of the EDR’s sensors, our agent shellcode will
    execute and begin its process of communicating back to our command-and-control
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Establishing Command
    and Control</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most malicious agents establish command and control in similar ways. The first
    message the agent sends to the server is a check-in saying “I’m a new agent running
    on host X!” When the server receives this check-in, it will reply “Hello agent
    on host X! Sleep for this period of time, then message me again for tasking.”
    The agent then idles for the time specified by the server, after which it messages
    it again saying “Back again. This time I’m ready to do some work.” If the operator
    has specified tasking for the agent, the server will pass that information along
    in some format understood by the agent, and the agent will execute the task. Otherwise,
    the server will tell the agent to sleep and try again later.
  prefs: []
  type: TYPE_NORMAL
- en: How do command-and-control agents evade network-based detection? Most of the
    time, the communication happens over HTTPS, the favorite channel of most operators
    because it lets their messages blend in with the high volume of traffic commonly
    flowing to the internet over TCP port 443 on most workstations. To use this protocol
    (and its less-secure sister, HTTP), the communication must follow certain conventions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a request must have a *Uniform Resource Identifier (URI)* path
    for both GET requests, used for retrieving data, and POST requests, used for sending
    data. While these URIs don’t technically have to be the same in each request,
    many commercial command-and-control frameworks reuse one static URI path. Additionally,
    the agent and server must have an agreed-upon communication protocol that rides
    on top of HTTPS. This means that their messages generally follow a similar pattern.
    For instance, the lengths of check-in requests and polls for tasking will likely
    be static. They may also be sent at fixed intervals.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is to say that, even when command-and-control traffic attempts to
    blend in among the noise, it still generates strong indicators of beaconing activity.
    An EDR developer who knows what to look for can use these to pick out the malicious
    traffic from the benign, probably using the network filter driver and ETW providers
    such as Microsoft-Windows-WebIO and Microsoft-Windows-DNS-Client. While the contents
    of HTTPS messages are encrypted, many important details remain readable, such
    as the URI paths, headers, message lengths, and the time at which the message
    was sent.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing this, how do we set up our command and control? Our HTTPS channel uses
    the domain blnfordtools.com. We purchased this domain a few weeks before the operation,
    set up DNS to point to a DigitalOcean virtual private server (VPS), and configured
    an NGINX web server on the VPS to use a LetsEncrypt SSL certificate. GET requests
    will be sent to the */home/catalog* endpoint and POST requests to */search?q=6100*,
    which will hopefully blend into normal traffic generated when browsing a tool
    manufacturer’s site. We set our default sleep interval to five minutes to allow
    us to quickly task the agent without being overly noisy, and we use a jitter of
    20 percent to add some variability between request times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command-and-control strategy might seem insecure; after all, we’re using
    a newly registered, typo-squatted domain hosted on a cheap VPS. But let’s consider
    what the EDR’s sensors can actually capture:'
  prefs: []
  type: TYPE_NORMAL
- en: A suspicious process making an outbound network connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anomalous DNS lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably missing is all the weirdness related to our infrastructure and indicators
    of beaconing.
  prefs: []
  type: TYPE_NORMAL
- en: Although the EDR’s sensors can collect the data required to determine that the
    compromised host is connecting to a newly registered, uncategorized domain pointing
    to a sketchy VPS, actually doing this would mean performing a ton of supporting
    actions, which could negatively affect system performance.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to track domain categorization, the EDR would need to reach out
    to a reputation-monitoring service. To get registration information, it would
    need to query the registrar. Doing all of this for all connections made on the
    target system would be hard. For that reason, EDR agents typically offload these
    responsibilities to the central EDR server, which performs the lookups asynchronously
    and uses the results to fire off alerts if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indicators of beaconing are missing for nearly the same reasons. If our
    sleep interval were something like 10 seconds with 10 percent jitter, detecting
    the beaconing could be as simple as following a rule like this one: “If this system
    makes more than 10 requests to a website with nine to 11 seconds between each
    request, fire an alert.” But when the sleep interval is five minutes with 20 percent
    jitter, the system would have to generate an alert anytime the endpoint made more
    than 10 requests to a website with four to six minutes between each request, which
    would require maintaining the rolling state of every outbound network connection
    for between 40 minutes and one hour. Imagine how many websites you visit on a
    daily basis, and you can see why this function is better suited for the central
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evading the Memory
    Scanner</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last big threat to the initial access phase of the engagement (as well as
    any future stages in which we spawn an agent) is the EDR’s memory scanner. Like
    the file scanner, this component seeks to detect the presence of malware on the
    system using static signatures. Instead of reading the file from disk and parsing
    its contents, it scans the file after it has been mapped into memory. This allows
    the scanner to assess the content of the file after it has been de-obfuscated
    so that it can be passed to the CPU for execution. In the case of our payload,
    this means our decrypted agent shellcode will be present in memory; the scanner
    needs only to find it and identify it as malicious.
  prefs: []
  type: TYPE_NORMAL
- en: Some agents include functionality to obscure the presence of the agent in memory
    during periods of inactivity. These techniques have varying levels of efficacy,
    and a scanner could still detect the shellcode by catching the agent between one
    of these sleep periods. Even so, custom shellcode and custom agents are generally
    harder to detect through static signatures. We’ll assume that our bespoke, handcrafted,
    artisanal command-and-control agent was novel enough to avoid being flagged by
    the memory scanner.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, everything has worked in our favor: our initial beaconing didn’t
    fire off an alert worthy of the SOC’s attention. We’ve established access to the
    target system and can begin our post-compromise activities.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Persistence</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’re inside the target environment, we need to make sure we can survive
    a technical or human-induced loss of connection. At this stage of the operation,
    our access is so fragile that if something were to happen to our agent, we’d have
    to start over from the beginning. Therefore, we need to set up some form of persistence
    that will establish a new command-and-control connection if things go south.
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistence is a tricky thing. There are an overwhelming number of options
    at our disposal, each with pros and cons. Generally speaking, we’re evaluating
    the following metrics when choosing a persistence technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**   The degree of certainty that the persistence technique will
    trigger our action (for example, launching a new command-and-control agent)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictability**   The degree of certainty about when the persistence will
    trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required permissions**   The level of access required to set up this persistence
    mechanism'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required user or system behaviors**   Any actions that must occur on the
    system for our persistence to fire, such as a system reboot or a user going idle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection risks**   The understood risk of detection inherent to the technique'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the creation of scheduled tasks as an example. [Table 13-1](#tab13-1)
    shows how the technique would perform using our metrics. Things seem great initially.
    Scheduled tasks run like a Rolex and are incredibly easy to set up. The first
    issue we encounter is that we need local administrator rights to create a new
    scheduled task, as the associated directory, *C:\Windows\System32\Tasks\*, can’t
    be accessed by standard users.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    Scheduled Tasks as a Persistence Mechanism</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Reliability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    reliably</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Predictability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    predictable</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Required permissions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Local administrator</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp>
    | <samp class="SANS_Futura_Std_Book_11">System must be connected to the network
    at the time of the trigger</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Detection risks</samp> | <samp class="SANS_Futura_Std_Book_11">Very
    high</samp> |'
  prefs: []
  type: TYPE_TB
- en: The biggest issue for us, though, is the detection risk. Attackers have abused
    scheduled tasks for decades. It would be fair to say that any EDR agent worth
    its weight would be able to detect the creation of a new scheduled task. As a
    matter of fact, MITRE’s *ATT&CK evaluations*, a capability-validation process
    that many vendors participate in every year, uses scheduled-task creation as one
    of its test criteria for APT3, an advanced persistent threat group attributed
    to China’s Ministry of State Security (MSS). Because remaining stealthy is one
    of our big goals, this technique is off the table for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'What persistence mechanism should we choose? Well, nearly every EDR vendor’s
    marketing campaign claims that it covers most cataloged ATT&CK techniques. ATT&CK
    is a collection of known attacker techniques that we understand well and are tracking.
    But what about the unknowns: the techniques about which we are mostly ignorant?
    A vendor can’t guarantee coverage of these; nor can they be assessed against them.
    Even if an EDR has the ability to detect these uncatalogued techniques, it might
    not have the detection logic in place to make sense of the telemetry generated
    by them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To lower our likelihood of detection, we can research, identify, and develop
    these “known unknowns.” To that end, let’s use *shell preview handlers*, a persistence
    technique that I, along with my colleague Emily Leidy, published research about
    in a blog post, “Life Is Pane: Persistence via Preview Handlers.” Preview handlers
    install an application that renders a preview of a file with a specific extension
    when viewed in Windows Explorer. In our case, the application we register will
    be our malware, and it will kick off a new command-and-control agent. This process
    is done almost entirely in the registry; we’ll create new keys that register a
    COM server. [Table 13-2](#tab13-2) evaluates this technique’s riskiness.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp> <samp class="SANS_Futura_Std_Book_11">Evaluating
    Shell Preview Handlers as a Persistence Mechanism</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Metric</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Evaluation</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Reliability</samp> | <samp class="SANS_Futura_Std_Book_11">Highly
    reliable</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Predictability</samp> | <samp class="SANS_Futura_Std_Book_11">Unpredictable</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Required permissions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Standard user</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Required user or system behaviors</samp>
    | <samp class="SANS_Futura_Std_Book_11">User must browse the target file type
    in Explorer with the pre</samp><samp class="SANS_Futura_Std_Book_11">view pane
    enabled, or the search indexer must process the file</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Detection risks</samp> | <samp class="SANS_Futura_Std_Book_11">Currently
    low but trivial to detect</samp> |'
  prefs: []
  type: TYPE_TB
- en: As you can see, these “known unknowns” tend to trade strengths in some areas
    for weaknesses in others. Preview handlers require fewer permissions and are harder
    to detect (though detection is still possible, as their installation requires
    very specific registry changes to be made on the host). However, they are less
    predictable than scheduled tasks due to user-interaction requirements. For operations
    in which detection isn’t a significant concern, reliability and usability may
    trump the other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Say we use this persistence mechanism. In the EDR, sensors are now hard at work
    collecting telemetry related to the hijacked preview handlers. We had to drop
    a DLL containing a runner for our backup agent to disk from *excel.exe*, so the
    scanner will probably give it a thorough examination, assuming that Excel writing
    a new DLL isn’t suspect enough. We also had to create a ton of registry keys,
    which the driver’s registry-notification callback routine will handle.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the registry-related telemetry our actions generate can be a little difficult
    to manage. This is because COM object registration can be tricky to pick out from
    the large volume of registry data, and because it can be challenging to differentiate
    a benign COM object registration from a malicious one. Additionally, while the
    EDR can monitor the creation of the new preview-handler registry-key value, as
    it has a standard format and location, this requires performing a lookup between
    the class identifier written as the value and the COM object registration associated
    with that class identifier, which isn’t feasible at the sensor level.
  prefs: []
  type: TYPE_NORMAL
- en: Another detection risk is our manual enablement of Explorer’s preview pane.
    This isn’t crazy behavior on its own. Users can manually enable or disable the
    preview pane at any time through their file browser. It can also be enabled across
    the enterprise via a group policy object. In both of these instances, the process
    making the change (for example, *explorer.exe* in the case of manual enablement)
    is known, meaning that a detection targeting atypical processes setting this registry
    value may be possible. For *excel.exe* to make this change would be very much
    out of the ordinary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Explorer has to load our DLL whenever the persistence is triggered.
    This DLL won’t be signed by Microsoft (or likely signed at all). The driver’s
    image-load callback notification routine will be responsible for detecting this
    DLL being loaded and can investigate the signature, along with other metadata
    about the image, to tip off the agent to the fact that a piece of malware is about
    to be mapped into Explorer’s address space. Of course, we could mitigate some
    of this risk by signing our DLL with a valid code-signing certificate, but this
    is beyond the reach of many threat actors, both real and simulated.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make a trade-off in predictability in favor of lowering our detection
    risk. We choose to install a preview handler for the *.docx* file extension by
    dropping our handler DLL to disk, performing the requisite COM registration, and
    manually enabling Explorer’s preview pane in the registry if it is not already
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reconnaissance</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve established persistence, we can afford to start taking more risks.
    The next thing we need to figure out is how to get to where we need to go. This
    is when you must think the hardest about detection because you’ll generate vastly
    different indicators based on what you’re doing and how you do it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need a way to run reconnaissance tooling without detection. One of my
    favorite tools for performing local reconnaissance is Seatbelt, a host-based situational
    awareness tool written by Lee Christensen and Will Schroeder. It can enumerate
    a ton of information about the current system, including the running processes,
    mapped drives, and amount of time the system has been online.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to run Seatbelt is to use built-in features of the command- and-control
    agent, such as Cobalt Strike Beacon’s execute-assembly, to execute its .NET assembly
    in memory. Typically, this involves spawning a sacrificial process, loading the
    .NET common language runtime into it, and instructing it to run a specified .NET
    assembly with provided arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is substantially less detection prone than trying to drop the
    tool onto the target’s filesystem and executing it from there, but it’s not without
    risk. In fact, the EDR could catch us in a whole slew of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Child Process Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: The EDR’s process-creation callback routine could detect the creation of the
    sacrificial process. If the child of the parent process is atypical, it could
    trigger an alert.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abnormal Module Loading**'
  prefs: []
  type: TYPE_NORMAL
- en: The sacrificial process spawned by the parent may not typically load the common
    language runtime if it is an unmanaged process. This may tip off the EDR’s image-load
    callback routine that in-memory .NET tradecraft is being used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Language Runtime ETW Events**'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the common language runtime is loaded and run, it emits events through
    the Microsoft-Windows-DotNETRuntime ETW provider. This allows EDRs that consume
    its events to identify key pieces of information related to the assemblies executing
    on the system, such as their namespace, class and method names, and Platform Invoke
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Antimalware Scan Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: If we’ve loaded version 4.8 or later of the .NET common language runtime, AMSI
    becomes a concern for us. AMSI will inspect the contents of our assembly, and
    each registered provider will have the opportunity to determine whether its contents
    are malicious.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Language Runtime Hooks**'
  prefs: []
  type: TYPE_NORMAL
- en: While the technique isn’t directly covered in this book, many EDRs use hooks
    on the common language runtime to intercept certain execution paths, inspect parameters
    and return values, and optionally block them. For example, EDRs commonly monitor
    *reflection*, the .NET feature that enables the manipulation of loaded modules,
    among other things. An EDR that hooks the common language runtime in this way
    may be able to see things that AMSI alone couldn’t and detect tampering with the
    loaded *amsi.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tool-Specific Indicators**'
  prefs: []
  type: TYPE_NORMAL
- en: The actions our tooling takes after being loaded can generate additional indicators.
    Seatbelt, for instance, queries many registry keys.
  prefs: []
  type: TYPE_NORMAL
- en: In short, most vendors know how to identify the execution of .NET assemblies
    in memory. Thankfully for us, there are some alternative procedures, as well as
    tradecraft decisions we can make, that can limit our exposure.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is the *InlineExecute-Assembly* Beacon object file, an open
    source plug-in for Cobalt Strike’s Beacon that allows operators to do everything
    that the normal execute-assembly module allows but without the requirement of
    spawning a new process. On the tradecraft side, if our current process is managed
    (as in, is .NET), then loading the common language runtime would be expected behavior.
    Couple these with bypasses for AMSI and the .NET Runtime ETW provider and we’ve
    limited our detection risk down to any hooks placed into the common language runtime
    and the indicators unique to the tool, which can be addressed independently. If
    we implement these tradecraft and procedural changes, we’re in a decent spot to
    be able to run Seatbelt.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privilege Escalation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that we need to expand our access to other hosts in Binford’s environment.
    We also know, from our point of contact, that our current user has low privileges
    and hasn’t been granted administrative access to remote systems. Remember, though,
    that Binford grants all domain users local administrator rights on their designated
    workstation so that they can install applications without overburdening their
    helpdesk team. All of this means that we won’t be able to move around the network
    unless we can get into the context of another user, but we also have options for
    how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: To take on the identity of another user, we could extract credentials from LSASS.
    Unfortunately, opening a handle to LSASS with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>
    rights can be a death sentence for our operation when facing a modern EDR. There
    are many ways to get around opening a handle with these rights, such as stealing
    a handle opened by another process or opening a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_DUP_HANDLE</samp>
    rights and then changing the requested rights when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>.
    However, we’re still running in *excel.exe* (or *explorer.exe*, if our persistence
    mechanism has fired), and opening a new process handle may cause further investigation
    to occur, if it doesn’t generate an alert outright.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to act as another user but don’t want to touch LSASS, we still have
    plenty of options, especially since we’re local administrators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a List of
    Frequent Users</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of my favorite ways is to target users who I know log in to the system.
    To view the available users, we can run Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module, which tells us which users have logged on recently. This will generate
    some indicators related to Seatbelt’s default namespace, classes, and method names,
    but we can simply change those prior to compilation of the assembly. Once we get
    the results from Seatbelt, we can also check the subdirectories under *C:\Users\*
    using *dir* or an equivalent directory-listing utility to see which users have
    a home folder on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Our execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module returns multiple login events from the user *TTAYLOR.ADMIN@BINFORD.COM*
    over the past 10 days. We can assume from the name that this user is an administrator
    to something, though we’re not quite sure to what.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hijacking a File
    Handler</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are two methods for targeting users of the system on which you’re operating:
    backdooring a *.lnk* file on the user’s desktop for an application they frequently
    open, such as a browser, and hijacking a file handler for the target user through
    registry modification. Both techniques rely on the creation of new files on the
    host. However, the use of *.lnk* files has been covered extensively in public
    reporting, so there are likely detections around their creation. File-handler
    hijacks have gotten less attention. Therefore, their use may pose a smaller risk
    to the security of our operation.'
  prefs: []
  type: TYPE_NORMAL
- en: For readers unfamiliar with this technique, let’s cover the relevant background
    information. Windows needs to know which applications open files with certain
    extensions. For instance, by default, the browser opens *.pdf* files, though users
    can change this setting. These extension-to-application mappings are stored in
    the registry, under *HKLM:\Software\Classes\* for handlers registered for the
    whole system and *HKU:\<SID>\SOFTWARE\Classes\* for per-user registrations.
  prefs: []
  type: TYPE_NORMAL
- en: By changing the handler for a specific file extension to a program that we implement,
    we can get our code to execute in the context of the user who opened the hijacked
    file type. Then we can open the legitimate application to fool the user into thinking
    everything is normal. To make this work, we must create a tool that first runs
    our agent shellcode and then proxies the path of the file to be opened to the
    original file handler.
  prefs: []
  type: TYPE_NORMAL
- en: The shellcode runner portion can use any method of executing our agent code
    and as such will inherit the indicators unique to that execution method. This
    is the same as was the case with our initial access payload, so we won’t cover
    the details of that again. The proxying portion can be as simple as calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp> on the
    intended file handler and passing in the arguments received from the operating
    system when the user attempts to open the file. Depending on the target of the
    hijack, this can create an abnormal parent–child process relationship, as our
    malicious intermediary handler will be the parent of the legitimate handler. In
    other cases, such as *.accountpicture-ms* files, the handler is a DLL that is
    loaded into *explorer.exe*, making it so that the child process could look like
    a child of *explorer.exe* rather than another executable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Choosing a File Extension</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because we’re still running in *excel.exe*, the modification of arbitrary file-handler
    binaries may seem odd to an EDR monitoring the registry events. Excel is, however,
    directly responsible for certain file extensions, such as *.xlsx* and *.csv*.
    If detection is a concern, it’s best to choose a handler that is appropriate for
    the context.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for us, Microsoft has implemented measures to limit our ability
    to change the handler associated with certain file extensions via direct registry
    modification; it checks hashes that are unique to each app and user. We can enumerate
    these protected file extensions by looking for registry keys with <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    subkeys containing a value called <samp class="SANS_TheSansMonoCd_W5Regular_11">Hash</samp>.
    Among these protected file extensions are Office file types (like *.xlsx* and
    *.docx*), *.pdf*, *.txt*, and *.mp4*, to name a few. If we want to hijack Excel-related
    file extensions, we need to somehow figure out the algorithm that Microsoft uses
    to create these hashes and reimplement it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, GitHub user “default-username-was-already-taken” offers a PowerShell
    version of the necessary hashing algorithm, *Set-FileAssoc.ps1*. Working with
    PowerShell can be tricky; it’s subject to high levels of scrutiny by AMSI, script-block
    logging, and consumers monitoring the associated ETW provider. Sometimes the mere
    fact of *powershell.exe* spawning can trigger an alert for a suspicious process.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we’ll aim to use PowerShell in the safest way possible, with the least
    risk of exposure. Let’s take a closer look at how the execution of this script
    on the target might get us caught and see what we can mitigate.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Modifying the PowerShell Script</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you review the script yourself, you’ll see that it isn’t too alarming; it
    appears to be a standard administrative tool. The script first sets up a P/Invoke
    signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!RegQueryInfoKey()</samp>
    function and adds a custom C# class called <samp class="SANS_TheSansMonoCd_W5Regular_11">HashFuncs</samp>.
    It defines a few helper functions that interact with the registry, enumerate users,
    and calculate the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserChoice</samp>
    hash. The final block executes the script, setting the new file handler and hash
    for the specified file extension.
  prefs: []
  type: TYPE_NORMAL
- en: This means we won’t need to modify much. The only things we need to worry about
    are some of the static strings, as those are what sensors will capture. We can
    remove a vast majority of them, as they’re included for debugging purposes. The
    rest we can rename, or *mangle*. These strings include the contents of variables,
    as well as the names of the variables, functions, namespaces, and classes used
    throughout the script. All of these values are fully under our control, so we
    can change them to whatever we want.
  prefs: []
  type: TYPE_NORMAL
- en: We do need to be careful with what we change these values to, though. EDRs can
    detect script obfuscation by looking at the entropy, or randomness, of a string.
    In a truly random string, the characters should all receive equal representation.
    In the English language, the five most common letters are E, T, A, O, and I; less
    commonly used letters include Z, X, and Q. Renaming our strings to values like
    *z0fqxu5* and *xyz123* could alert an EDR to the presence of high-entropy strings.
    Instead, we can simply use English words, such as *eagle* and *oatmeal*, to perform
    our string replacement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Executing the PowerShell Script</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next decision we need to make is how we’re going to execute this PowerShell
    script. Using Cobalt Strike Beacon as an example agent, we have a few options
    readily available to us in our command-and-control agent:'
  prefs: []
  type: TYPE_NORMAL
- en: Drop the file to disk and execute it directly with *powershell.exe*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script in memory using a download cradle and *powershell.exe*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the script in memory using Unmanaged PowerShell (*powerpick*) in a sacrificial
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject Unmanaged PowerShell into a target process and execute the script in
    memory (*psinject*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Option 1 is the least preferrable, as it involves activities that Excel would
    rarely perform. Option 2 is slightly better because we no longer have to drop
    the script onto the host’s filesystem, but it introduces highly suspicious indicators,
    both in the network artifacts generated when we request the script from the payload-hosting
    server and in the invocation of *powershell.exe* by Excel with a script downloaded
    from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Option 3 is slightly better than the previous two but isn’t without its own
    risks. Spawning a child process is always dangerous, especially when combined
    with code injection. Option 4 is not much better, as it drops the requirement
    of creating a child process but still necessitates opening a handle to an existing
    process and injecting code into it.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider options 1 and 2 to be off the table because we don’t want Excel
    spawning *powershell.exe*, we’re left deciding between options 3 and 4\. There
    is no right answer, but I find the risk of using a sacrificial process more palatable
    than the risk of injecting into another one. The sacrificial process will terminate
    as soon as our script completes its execution, removing persistent artifacts,
    including the loaded DLLs and the in-memory PowerShell script, from the host.
    If we were to inject into another process, those indicators could remain loaded
    in the host process even after our script completes. So, we’ll use option 3.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to decide what our hijack should target. If we wanted to expand
    our access indiscriminately, we’d want to hijack an extension for the entire system.
    However, we’re after the user *TTAYLOR.ADMIN*. Since we have local administrator
    rights on the current system, we can modify the registry keys of a specific user
    through the *HKU* hive, assuming we know the user’s security identifier (SID).
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there’s a way to get the SID from Seatbelt’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonEvents</samp>
    module. Each 4624 event contains the user’s SID in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubjectUserSid</samp>
    field. Seatbelt comments out this attribute in the code to keep the output clean,
    but we can simply uncomment that line and recompile the tool to get that information
    without needing to run anything else.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Building the Malicious Handler</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With all the requisite information collected we can hijack the handler for the
    *.xlsx* file extension for only this user. The first thing we need to do is create
    the malicious handler. This simple application will execute our shellcode and
    then open the intended file handle, which should open the file selected by the
    user in a way they’d expect. This file will need to be written to the target filesystem,
    so we know we’re going to be scanned, either at the time we upload it or on its
    first invocation based on the configuration of the EDR’s minifilter. To mitigate
    some of this risk, we can obfuscate the evil handler in a way that will hopefully
    allow us to fly under the radar.
  prefs: []
  type: TYPE_NORMAL
- en: The first big issue we’ll need to conceal is the huge blob of agent shellcode
    hanging out in our file. If we don’t obfuscate this, a mature scanner will quickly
    identify our handler as malicious. One of my favorite ways to obscure these agent
    shellcode blobs is called *environmental keying*. The general gist is that you
    encrypt the shellcode using a symmetric key derived from some attribute unique
    to the system or context under which you’ll be running. This can be anything from
    the target’s internal domain name to the serial number of the hard drive inside
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we’re targeting the user *TTAYLOR.ADMIN@BINFORD.COM*, so we use
    their username as our key. Because we want the key to be difficult to brute-force
    should our payload fall into the hands of an incident responder, we pad it out
    to 32 characters by repeating the string, making our symmetric key the following:
    *TTAYLOR.ADMIN@BINFORD.COMTTAYLOR*. We could also combine it with other attributes,
    such as the system’s current IP address, to add some more variation to the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Back on our payload development system, we generate the agent shellcode and
    encrypt it using a symmetric key algorithm—say, AES-256—along with our key. We
    then replace the non-obfuscated shellcode with the encrypted blob. Next, we need
    to add key-derivation and decryption functions. To get our key, our payload needs
    to query the executing user’s name. There are simple ways to do this, but bear
    in mind that the more simplistic the derivation method, the easier it will be
    for a skilled analyst to reverse the logic. The more obscure the method of identifying
    the user’s name, the better; I’ll leave finding a suitable strategy as an exercise
    to the reader. The decryption function is much more straightforward. We simply
    pad the key out to 32 bytes and then pass the encrypted shellcode and key through
    a standard AES-256 decryption implementation, then save the decrypted results.
  prefs: []
  type: TYPE_NORMAL
- en: Now here comes the trick. Only our intended user should be able to decrypt the
    payload, but we have no guarantees that it won’t fall into the hands of Binford’s
    SOC or managed security service providers. To account for this possibility, we
    can use a *tamper sensor*, which works like this. If decryption works as expected,
    the decrypted buffer will be filled with known contents we can hash. If the wrong
    key is used, the resultant buffer will be invalid, causing a hash mismatch. Our
    application can take the hash of the decrypted buffer before executing it and
    notify us if it detects a hash mismatch. This notification could be a POST request
    to a web server or something as subtle as changing the timestamp of a specific
    file on the system we monitor. We can then initiate a full infrastructure teardown
    so that incident responders can’t start hitting our infrastructure or simply collect
    information about the failure and adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know we’ll deploy this payload on only one host, we opt for the timestamp-monitoring
    approach. The implementation of this method is irrelevant and has a very low detection
    footprint; we merely change the timestamp of some file hidden deep in some directory
    and then use a persistent daemon to watch it for changes and to notify us if it
    detects something.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to figure out the location of the legitimate handler so that we
    can proxy requests to open *.xlsx* files to it. We can pull this from the registry
    for a specific user if we know their SID, which our modified copy of Seatbelt
    told us is *S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032* for *TTAYLOR.ADMIN@BINFORD.COM*.
    We query the *xlsx* value in *HKU:\S-1-5-21-486F6D6549-6D70726F76-656D656E7-1032\SOFTWARE\Microsoft\Windows\CurrentVersion\Extensions*,
    which returns *C:\Program Files (x86)\Microsoft Office\Root\Office16\EXCEL.EXE*.
    Back in our handler, we write a quick function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>
    with the path to the real *excel.exe*, passing along the first parameter, which
    will be the path to the *.xlsx* file to open. This should execute after our shellcode
    runner but should not wait for it to complete so that the agent being spawned
    is apparent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Compiling the Handler</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When it comes to compiling our handler, there are a couple of things we need
    to do to avoid detection. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing or mangling all string constants**   This will reduce the chance
    that signatures will trigger or be created based on strings used in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disabling the creation of program database (PDB) files**   These files include
    the symbols used for debugging our application, which we won’t need on our target.
    They can leak information about our build environment, such as the path at which
    the project was compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Populating image details**   By default, our compiled handler will contain
    only basic information when inspected. To make things look a little bit more realistic,
    we can populate the publisher, version, copyright information, and other details
    you’d see after opening the Details tab in the file’s properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could take additional measures to further protect our handler,
    such as using LLVM to obfuscate the compiled code and signing the *.exe* with
    a code-signing certificate. But because the risk of this technique being detected
    is already pretty low and we have some protections in place, we’ll save those
    measures for another time.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve compiled our handler with these optimizations and tested it in a
    lab environment that mimics the Binford system, we’ll be ready to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registering the Handler</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Registering a file or protocol handler may seem relatively simple at face value;
    you overwrite the legitimate handler with a path to your own. Is that it? Not
    quite. Nearly every file handler is registered with a programmatic identifier
    (ProgID), a string used to identify a COM class. To follow this standard, we need
    to either register our own ProgID or hijack an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hijacking an existing ProgID can be risky, as it may break some functionality
    on the system and tip the user off that something is wrong, so this probably isn’t
    the right strategy in this case. We could also look for an abandoned ProgID: one
    that used to be associated with some software installed on the system. Sometimes,
    when the software is removed, its uninstaller fails to delete the associated COM
    registration. However, finding these is relatively rare.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’ll opt to register our own ProgID. It’s hard for an EDR to monitor
    the creation of all registry keys and all values being set at scale, so the odds
    are good that our malicious ProgID registration will go unnoticed. [Table 13-3](#tab13-3)
    shows the basic changes we’ll need to make under the target user’s registry hive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp> <samp class="SANS_Futura_Std_Book_11">Keys
    to Be Created for Handler Registration</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Key</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\Excel.WorkBook.16\CLSID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{1CE29631-7A1E-4A36-8C04-AFCCD716A718}</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides the ProgID-to-CLSID mapping</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Classes\CLSID\{1CE29631
    -7A1E-4A36-8C04-AFCCD716A718}\ProgID</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">ExcelWorkBook.16</samp>
    | <samp class="SANS_Futura_Std_Book_11">Provides the CLSID-to-ProgID mapping</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Classes\CLSID\{1CE29631-7A1E
    -4A36-8C04-AFCCD716A718}\InprocServer32</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">C:\path\to\our\handler.dll</samp>
    | <samp class="SANS_Futura_Std_Book_11">Specifies the path to our malicious handler</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Before deploying our changes to the live target, we can validate them in a lab
    environment using the PowerShell commands shown in [Listing 13-2](#list13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: Validating COM object registration'
  prefs: []
  type: TYPE_NORMAL
- en: We get the type associated with our ProgID and then pass it to a function that
    creates an instance of a COM object. The last command shows the methods supported
    by our server as a final sanity check. If everything worked correctly, we should
    see the methods we implemented in our COM server returned to us via this newly
    instantiated object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deploying the Handler</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we can upload the handler to the target’s filesystem. This executable can
    be written to any location the user has access to. Your inclination may be to
    hide it deep in some folder unrelated to Excel’s operation, but this could end
    up looking odd when it’s executed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, hiding it in plain sight might be our best option. Since we’re an admin
    on this system, we can write to the directory in which the real version of Excel
    is installed. If we place our file alongside *excel.exe* and name it something
    innocuous, it may look less suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we drop our file to disk, the EDR will subject it to scanning. Hopefully,
    the protections we put in place mean it isn’t deemed malicious (though we might
    not know this until it is executed). If the file isn’t immediately quarantined,
    we can proceed by making the registry changes.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes in the registry can be fairly safe depending on what is being
    modified. As discussed in [Chapter 5](chapter5.xhtml), registry callback notifications
    might have to process thousands upon thousands of registry events per second.
    Thus, they must limit what they monitor. Most EDRs monitor only keys associated
    with specific services, as well as subkeys and values, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">RunAsPPL</samp>
    value, which controls whether LSASS is launched as a protected process. This works
    out well for us, because while we know that our actions will generate telemetry,
    we won’t touch any of the keys that are likely to be monitored.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we should change as little as possible. Our PowerShell script will
    modify the values shown in [Table 13-4](#tab13-4) under the target user’s registry
    hive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp> <samp class="SANS_Futura_Std_Book_11">Registry
    Keys Modified During Handler Registration</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Registry key</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Operation</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">Delete</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice</samp>
    | <samp class="SANS_Futura_Std_Book_11">Create</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\Hash</samp>
    | <samp class="SANS_Futura_Std_Book_11">Set value</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SOFT-WARE\Microsoft\Windows\CurrentVer-si-on\Explorer\FileExts\.xlsx\UserChoice\ProgId</samp>
    | <samp class="SANS_Futura_Std_Book_11">Set value</samp> |'
  prefs: []
  type: TYPE_TB
- en: As soon as these registry changes are made, our handler should be functional
    on the system. Whenever the user next opens a *.xlsx* file, our handler will be
    invoked via the common language runtime, execute our shellcode, and then open
    the real Excel to allow the user to interact with the spreadsheet. When our agent
    checks in with our command-and-control infrastructure, we should see it come through
    as *TTAYLOR.ADM@BINFORD.COM*, elevating our privileges to what appears to be an
    administrator account on Binford’s Active Directory domain, all without opening
    a handle to LSASS!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lateral Movement</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our agent is running on what we suspect to be a privileged account,
    we need to discover what kind of access we have in the domain. Rather than throwing
    SharpHound around to collect information (an activity that has become more difficult
    to do successfully), we can perform more surgical examination to figure out how
    we can move to another host.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that lateral movement, or expanding our access to the environment,
    must involve deploying more agents on more hosts. However, this can add a ton
    of new indicators that we may not need. Take PsExec-based lateral movement, for
    example, in which a service binary containing agent shellcode is copied to the
    target system and a service targeting that newly copied binary is created and
    started, initiating a new callback. This would involve generating a network logon
    event, as well as creating a new file, registry keys for the associated service,
    a new process, and a network connection to either our command-and-control infrastructure
    or our compromised hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question then becomes: do we absolutely need to deploy a new agent, or
    are there other ways to get what we need?'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding a Target</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first places to start looking for lateral movement targets is the
    list of established network connections on the current host. This approach has
    a few benefits. First, it doesn’t require network scanning. Second, it can help
    you understand the environment’s firewall configuration, because if there is an
    established connection from the host to another system, it’s safe to assume that
    a firewall rule allowed it. Lastly, it can let us blend in. Since our compromised
    system has connected to the hosts in the list at least once, a new connection
    might seem less anomalous than one to a system with which the host has never communicated.
  prefs: []
  type: TYPE_NORMAL
- en: Since we accepted the risk of using Seatbelt previously, we can use it again.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpConnections</samp> module
    lists the existing connections between our host and others in the network, as
    shown in [Listing 13-3](#list13-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: Enumerating network connections with Seatbelt'
  prefs: []
  type: TYPE_NORMAL
- en: This output can sometimes be overwhelming due to the sheer volume of connections
    some systems make. We can prune this list a bit by removing connections we’re
    not interested in. For example, we can remove any HTTP and HTTPS connections,
    as we’d most likely need to provide a username and password to access these servers;
    we have access to a token belonging to *TTAYLOR.ADM@BINFORD.COM* but not the user’s
    password. We can also remove any loopback connections, as this won’t help us expand
    our access to new systems in the environment. That leaves us with a substantially
    smaller list.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we notice multiple connections to internal hosts over arbitrarily
    high ports, indicative of RPC traffic. There are likely no firewalls between us
    and the hosts, as explicit rules for these ports are very rare, but figuring out
    the nature of the protocol is tricky if we don’t have GUI access to the host.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a connection to an internal host over TCP port 445 ❶, which is
    virtually always an indication of remote file-share browsing using SMB. SMB can
    use our token for authentication and won’t always require us to enter credentials.
    Furthermore, we can leverage the file-sharing functionality to browse the remote
    system without deploying a new agent. That sounds like exactly what we’re after!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enumerating Shares</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming this is a traditional SMB connection, we now need to find the name
    of the share being accessed. The easy answer, especially if we assume that we’re
    an administrator, is to mount the *C$* share. This will allow us to browse the
    operating system volume as if we were in the root of the *C:* drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in enterprise environments, shared drives are rarely accessed in this
    way. Shared folders are much more common. Unfortunately for us, enumerating these
    shares isn’t as simple as just listing out the contents of *\\10.1.10.48\*. There
    are plenty of ways to get this information, though. Let’s explore some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">net view</samp>
    **command**   Requires us to launch *net.exe* on the host, which an EDR’s process-creation
    sensors highly scrutinize'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-SmbShare</samp>
    **in PowerShell**   Built-in PowerShell cmdlet that works both locally and remotely
    but requires us to invoke *powershell.exe*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-WmiObject</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Win32_Share</samp> **in PowerShell**   Similar
    to the previous cmdlet but queries for shares over WMI'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SharpWMI.exe</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">action=query query=" "select * from
    win32_share" "</samp> Functionally the same as the previous PowerShell example
    but uses a .NET assembly, which allows us to operate using execute-assembly and
    its equivalents'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** ***Seatbelt.exe*** **network shares**   Nearly identical to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SharpWMI</samp>; uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Share
    WMI</samp> class to query the shares on a remote system'
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples, and there are pros and cons to each. Since we’ve
    already put in the work to obfuscate Seatbelt and know that it works well in this
    environment, we can use it again here. Most EDRs work on a process-centric model,
    meaning that they track activity based on processes. Like our initial access,
    we’ll be running in *excel.exe* and, if needed, set our *spawnto* process to the
    same image as it was previously. When we enumerate remote shares on *10.1.10.48*,
    Seatbelt generates the output shown in [Listing 13-4](#list13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: Enumerating network shares with Seatbelt'
  prefs: []
  type: TYPE_NORMAL
- en: The information tells us a few things about the target system. First, we have
    the ability to browse *C$*, which indicates that either we were granted read access
    to their filesystem volume, or, more likely, we have administrative access to
    the host. Read access to *C$* allows us to enumerate things such as installed
    software and users’ files. These both can provide valuable context about how the
    system is used and who uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other network shares are more interesting than *C$*, though. They look
    like they belong to various business units inside Binford: *FIN* could stand for
    Finance, *ENG* for Engineering, *IT* for Information Technology, *MKT* for Marketing,
    and so on. *ENG* could be a good target based on our stated objectives.'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are detection risks to finding out for sure. When we list the
    contents of a remote share, a few things happen. First, a network connection is
    established with the remote server. The EDR’s network filter driver will monitor
    this, and because it is an SMB client connection, the Microsoft-Windows-SMBClient
    ETW provider comes into play as well. Our client will authenticate to the remote
    system, creating an event through the ETW provider Microsoft-Windows-Security-Auditing
    (as well as an event ID 5140, indicating that a network share was accessed, in
    the security event log) on the remote system. If a *system access control list
    (SACL)*, a type of access control list used to audit access requests made for
    an object, is set on the shared folder or files within, an event will be generated
    via the Microsoft-Windows-Security-Auditing ETW provider (as well as an event
    ID 4663) when the contents of the shared folder are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, that the fact that telemetry was generated on the host doesn’t
    necessarily mean that it was captured. In my experience, EDRs monitor almost none
    of what I mentioned in the preceding paragraph. They might monitor the authentication
    event and network, but we’re using an already-established network connection to
    the SMB server, meaning browsing the *ENG* share could allow us to blend in with
    the normal traffic coming from this system, lessening the likelihood of detection
    due to an anomalous access event.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that we’ll blend in so much that there is no risk at all.
    Our user may not typically browse the *ENG* share, making any access event anomalous
    at the file level. There may be non-EDR controls, such as data-loss prevention
    software or a canary facilitated through the SACL. We have to measure the reward
    of this share potentially holding Binford’s crown jewels against the risk of detection
    posed by our browsing.
  prefs: []
  type: TYPE_NORMAL
- en: All signs are pointing to this drive holding what we’re after, so we start recursively
    listing the subdirectories of the *ENG* share and find *\\10.1.10.48\ENG\Products\6100\3d\screwdriver_v42.stl*,
    a stereolithography file commonly used by design applications in the mechanical
    engineering world. In order to verify that this file is the 3D model for the Binford
    6100 left-handed screwdriver, we’ll need to exfiltrate it and open it in an application
    capable of processing *.stl* files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">File Exfiltration</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step of our attack is pulling Binford’s crown jewels out of its environment.
    Oddly, of everything we’ve done in this operation, this has the lowest likelihood
    of detection by the EDR despite having the highest impact to the environment.
    To be fair, it isn’t really the EDR’s domain. Still, sensors could detect our
    data exfiltration, so we should remain thoughtful in our approach.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to exfiltrate data from a system. Choosing a technique depends
    on a number of factors, such as the data’s location, contents, and size. Another
    factor to consider is how *fault tolerant* the data format is; if we don’t receive
    the full contents of the file, is it still workable? A text file is a good example
    of a very fault-tolerant file type, as missing half of the file means we’re simply
    missing half of the text in the document. On the other hand, images are generally
    not fault tolerant, because if we’re missing some portion of the picture, we generally
    won’t be able to reconstruct it in any meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we should consider how quickly we need the data. If we need it soon
    and all at once, we typically inherit a higher risk of detection than if we exfiltrate
    the file slowly because the volume of data transmitted across the network boundary,
    where security monitoring is likely to be implemented, will be higher in a given
    timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: In our operation, we can afford to take more risk because we’re not interested
    in staying embedded in the environment for much longer. Through our reconnaissance
    against the *ENG* share, we see that the *.stl* file is 4MB, which isn’t excessive
    compared to other types of files. Since we have a high risk tolerance and are
    working with a small file, let’s take the easy route and exfiltrate the data over
    our command-and-control channel.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we’re using HTTPS, we should still protect the contents of the data.
    Assume the contents of any message that we send will be subjected to inspection
    by a security product. When it comes to exfiltrating files specifically, one of
    our biggest concerns is the file signature, or *magic bytes*, at the beginning
    of the file used to uniquely identify the file type. For *.stl* files, this signature
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">73 6F 6C 69 64</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there are many ways to obfuscate the type of file we’re exfiltrating,
    ranging from encrypting the contents of the file to simply trimming off the magic
    bytes before transmitting the file and then appending them again after the file
    is received. For human-readable file types, I prefer encryption, since there may
    be monitoring in place for a specific string in an outbound connection request.
    For other types of files, I’ll usually either remove, mangle, or falsify the magic
    bytes for the file if detection at this stage is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re ready to exfiltrate the file, we can use our agent’s built-in download
    functionality to send it over our established command-and-control channel. When
    we do this, we are going to make a request to open the file so that we can read
    its contents into memory. When this happens, the EDR’s filesystem minifilter driver
    will receive a notification and may look at certain attributes associated with
    the event, such as who the requestor is. Since the organization itself would have
    to build a detection from this data, the likelihood of an EDR having a detection
    here is relatively low.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve read the contents of the file into our agent’s address space, we
    can close the handle to the file and start the transfer. Transmitting data over
    HTTP or HTTPS channels will cause related ETW providers to emit events, but these
    typically don’t include the message contents if the channel is secure, as with
    HTTPS. So, we shouldn’t have any issue getting our design plans out. Once we have
    the file downloaded, we simply add back the magic bytes and open the file in the
    3D modeling software of choice ([Figure 13-1](#fig13-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The Binford 6100
    left-handed screwdriver</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve completed the engagement objective: accessing the design information
    for Binford’s revolutionary product (pun intended). While executing this operation,
    we used our knowledge of an EDR’s detection methods to make educated choices about
    how to move through the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the path we took may not have been the best (or only) way
    to reach the objective. Could we have outpaced Binford’s defenders without considering
    the noise we were making? What if we decided not to work through Active Directory
    and instead used a cloud-based file-hosting application, such as SharePoint, to
    locate the design information? Each of these approaches significantly alters the
    ways in which Binford could detect us.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book, you should be armed with the information you need to
    make these strategic choices on your own. Tread carefully, and good luck.
  prefs: []
  type: TYPE_NORMAL
