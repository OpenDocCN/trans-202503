- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FORENSIC ANALYSIS OF TIME AND LOCATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explains digital forensic concepts related to Linux time, regional
    settings, and location. Forensic timelines are explored, including how to build
    a forensic timeline from a Linux system. It also describes international configuration
    such as locale, keyboards, and languages. The final section covers geolocation
    technologies and reconstructing a Linux system’s geographic location history.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Time Configuration Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A large part of digital forensics is reconstructing past events. This *digital
    archaeology* depends on understanding concepts of time as applied to Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: '***Time Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The standard representation of time in Linux is taken from Unix. The original
    Unix developers needed a compact way to represent the current time and date. They
    chose January 1, 1970, 00:00:00 UTC as the beginning of time (coinciding with
    the naming of Unix which took place in early 1970), and the number of seconds
    elapsed from that point represented a particular time and date. This date is also
    called the *Unix epoch*, and this format allowed for time and date to be stored
    as a 32-bit number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We refer to a specified point in time as a *timestamp*. The following example
    shows the time in seconds using the Linux `date` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This timestamp is given in text format, but it could also be stored in binary
    format in big- or little-endian form. This same string in hexadecimal is a four-byte
    string: 0x5fe4d502.'
  prefs: []
  type: TYPE_NORMAL
- en: One problem with 32-bit epoch-based time is the maximum number of seconds until
    the clock restarts to zero. This rollover will happen on January 18, 2038, creating
    a similar situation to Y2K (the rollover to January 1, 2000). Linux kernel developers
    are aware of this and have already implemented support for 64-bit timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem with the original Unix time representation was its accuracy,
    which was limited to a precision of one second. This limit was enough for the
    slower speeds of early computers, but modern systems need higher resolution. Common
    terms representing the fractions of a second are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Millisecond** One thousandth of a second (0.0001)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsecond** One millionth of a second (0.000001)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nanosecond** One billionth of a second (0.000000001)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the number of seconds since the epoch with nanosecond
    resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To retain backward compatibility, some filesystems have added an additional
    byte to the timestamp. The individual bits in this byte are split between solving
    the 2038 issue and providing increased resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As you get better at performing forensic analysis work, train yourself to
    notice numeric strings that are likely to be timestamps. For example, if you see
    a 10-digit number beginning with 16 (16*XXXXXXXX*), it could be a timestamp (September
    2020 to November 2023).*'
  prefs: []
  type: TYPE_NORMAL
- en: The format used to display time in human-readable form is customizable. The
    format could be long, short, numeric, or a combination of the three. Regional
    variations also may cause confusion. For example, 1/2/2020 could be February 1
    or January 2, depending on the region. Even the delimiters are different depending
    on region or style (“.” or “/” or “-”).
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1988, ISO created a global standard format for writing numeric dates that
    defined the year, followed by month, followed by day: 2020-01-02\. I recommend
    using this format if your forensic tool supports it (and it probably does). The
    XKCD comic in [Figure 9-1](ch09.xhtml#ch09fig01) may help you remember.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: XKCD Time Format (* [https://xkcd.com/1179/](https://xkcd.com/1179/)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two standards are useful for understanding time formats: ISO 8601 (*[https://www.iso.org/iso-8601-date-and-time-format.html](https://www.iso.org/iso-8601-date-and-time-format.html)*)
    and RFC 3339 (*[https://datatracker.ietf.org/doc/html/rfc3339/](https://datatracker.ietf.org/doc/html/rfc3339/)*).
    When performing digital forensics, especially logfile analysis, make sure that
    you understand the time format used.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Time Zones***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The planet is divided into 24 major time zones, one hour apart.^([1](footnotes.xhtml#ch09foot_01))
    The time zone indicates a geographical region and the time offset from Coordinated
    Universal Time (UTC). A time zone can be applied to a system or a user, and these
    zones are not necessarily the same if a user is logging in remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a system is first installed, the system owner specifies a time zone. This
    setting is a symbolic link (symlink) of */etc/localtime*, which points to a *tzdata*
    file located in */usr/share/zoneinfo/*. Determining the system’s configured time
    zone is simply a matter of identifying where this file is linked. In the following
    example, a system is configured for the region Europe and the city of Zurich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This configuration provides an indicator of the machine’s physical location
    (or at least the region). A discrepancy between a system time zone and a user’s
    time zone at login is interesting, as it indicates the potential location of the
    system owner (using a remotely installed/managed system).
  prefs: []
  type: TYPE_NORMAL
- en: 'The configured time zone is usually static for systems with a fixed location
    like desktop PCs and servers. Laptops that change time zone regularly indicate
    a traveling user. A changed time zone (manually or automatically) can be observed
    in the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These logs show examples of changing the time zone using the GNOME Date & Time
    GUI. The `systemd-timedated` daemon is asked to change the time zone and update
    the symlink for */etc/localtime*. If set to change automatically, the system will
    query GeoClue for the location. GeoClue is the Linux geolocation service (described
    later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Individual users may also specify a login time zone that is different from the
    system’s time zone—for example, on servers where multiple users from around the
    world are logging in remotely via secure shell (SSH). To identify an individual
    user’s time zone, look for the assignment of the `TZ` environment variable. The
    `TZ` variable may be found in the shell startup files (*.bash_login*, *.profile*,
    and others) or set as a variable passed by the SSH program. To determine whether
    SSH is passing the `TZ` variable, check whether the SSH server config (*sshd_config*)
    is explicitly allowing `TZ` with the `AcceptEnv` parameter, or if the client config
    (*ssh_config* or *./ssh/config*) is explicitly passing `TZ` with the `SendEnv`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TZ variable is a POSIX standard and implemented in Linux by the GNU C Library.
    The TZ variable has three formats, which are described here with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time zone and offset** CET+1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time zone and offset with daylight savings** EST+5EDT'
  prefs: []
  type: TYPE_NORMAL
- en: '**A time zone filename** Europe/London'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a more detailed description of the TZ variable at *[https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html](https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: On Fedora and SUSE systems, some packages and scripts may read the */etc/sysconfig/clock*
    file (if it exists). This file describes the hardware clock (if it’s UTC, the
    time zone, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: When using forensic tools for analyzing timestamps, the tool may require specifying
    a time zone. With The Sleuth Kit, for example, commands using time zone information
    can use the `-z` flag to specify the time zone.
  prefs: []
  type: TYPE_NORMAL
- en: '***Daylight Saving and Leap Time***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Daylight saving time is the practice of moving clocks forward an hour in spring
    and backward an hour in fall (“spring forward, fall back") to provide earlier
    daylight during winter and later daylight during summer. This practice is decided
    by regional governments and is not a global standard. Some regions (Russia in
    2014 and Europe in 2021) have abolished, or are in the process of abolishing,
    the daylight saving time change.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be aware of daylight saving time when forensically analyzing
    systems in affected regions. The added or removed hour affects the reconstruction
    of forensic timelines and interpretation of past events. Forensic tools generally
    support daylight saving adjustments if a geographic region is specified. UTC does
    not change for daylight saving time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *tzdata* file described in the previous section contains daylight saving
    information. To extract a list of time intervals (historic and future) for a particular
    time zone, use the `zdump` tool on a Linux machine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the transition time, time zone abbreviation (CET or CEST), current daylight
    saving flag (`isdst=`), and offset from UTC in seconds (`gmtoff=`) are shown.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note those regions that abandoned daylight saving, as the
    final entry in the *tzdata* file is the date and time of last change in the region.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about *tzdata* files, see the tzfile(5) man page. The authoritative
    source for time zone data is the Internet Assigned Numbers Authority (IANA), and
    tz database files can be found on the IANA website (*[https://www.iana.org/time-zones/](https://www.iana.org/time-zones/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Leap years and leap seconds are also a factor in Linux timekeeping, and a challenge
    in forensics. A leap year is the addition of a single day, February 29, every
    four years (there is an exception to the leap year rule once per century). Leap
    seconds are more difficult to predict and are caused by the Earth’s rotation slowing
    down. The International Earth Rotation Service (IERS) decides when to add a leap
    second and publishes that decision half a year in advance (usually planned for
    the end or middle of the year). A list of leap seconds since the Unix epoch (28
    of them as of this writing) are available on the IERS website (*[https://hpiers.obspm.fr/iers/bul/bulc/ntp/leap-seconds.list](https://hpiers.obspm.fr/iers/bul/bulc/ntp/leap-seconds.list)*).
    Linux systems using external time synchronization will automatically add leap
    seconds. Leap years are predictable, and Linux systems are designed to add February
    29 every four years.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be aware of leap years and leap seconds when forensically
    analyzing systems. The additional day and second could affect the reconstruction
    of past events and creation of forensic timelines.
  prefs: []
  type: TYPE_NORMAL
- en: '***Time Synchronization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From a digital forensics perspective, knowing the configured time synchronization
    is important for several reasons. It helps determine when a system was in sync
    or out of sync over time, providing more accurate analysis of system timelines.
    It helps investigations when the clock was deliberately changed or manipulated
    for malicious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain the correct time during normal system operation, an external time
    source is used. Examples of external time sources include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Time Protocol (NTP)** Network-based time sync protocol (RFC 5905)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DCF77** German longwave radio time signal broadcast from near Frankfurt (used
    across Europe)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Positioning System (GPS)** Time received from a network of satellites'
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux systems check and set the date on startup, using NTP after the network
    is functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common NTP software packages used on Linux systems are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ntp** The original NTP reference implementation (*[https://ntp.org/](https://ntp.org/)*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**openntpd** Designed by the OpenBSD community for simplicity and security'
  prefs: []
  type: TYPE_NORMAL
- en: '**chrony** Designed to perform well under a variety of conditions'
  prefs: []
  type: TYPE_NORMAL
- en: '**systemd-timesyncd** Time synchronization built into systemd'
  prefs: []
  type: TYPE_NORMAL
- en: To determine which ntp mechanism is used, check the installed packages for ntp,
    openntpd, or chrony (systemd-timesync is installed as part of systemd). Then check
    which service unit file is enabled by examining the symlinks in */etc/systemd/system/*.wants/*)
    directories. Common unit files are *ntp.service*, *ntpd.service*, *chrony.service*,
    and *openntpd.service*.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd’s timesyncd will create symbolic links such as */etc/systemd/system/
    dbus-org.freedesktop.timesync1.service* and */etc/systemd/system/sysinit.target.wants/
    systemd-timesyncd.service*. On a live system the `timedatectl` command queries
    and manages these files.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the unit files provide information about the configuration.
    Often the time daemons will have a separate configuration file in */etc/* (*ntp.conf*
    or *ntpd.conf*, for example) that defines the behavior of the daemon and specifies
    the time servers used. The systemd-timesyncd configuration is defined in */etc/systemd/timesyncd.conf*
    .
  prefs: []
  type: TYPE_NORMAL
- en: Logs related to the time daemon provide information about startup, shutdown,
    time sync changes, and errors. These can be found in the systemd journal, in syslog
    logs, and in stand-alone logfiles in */var/log/**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show log entries from openntpd, chrony, and systemd-timesyncd,
    with the time being changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A list of servers is typically configured for the system to synchronize time.
    In some cases, a system may have a locally attached time source (DCF77, GPS, and
    so on) that may appear as a server with a 127.*x*.*x*.*x* IP address in the configuration
    file. You can find additional information about the time daemon and the configuration
    files in the software package man pages or at the developer website.
  prefs: []
  type: TYPE_NORMAL
- en: If a GPS device is attached, look for the gpsd (*[https://gpsd.io/](https://gpsd.io/)*)
    software package and associated configuration (*/etc/gpsd/** or */etc/default/gpsd*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clock synchronization is typical but not required, and in some cases, no NTP
    configuration will be found. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines that trust the clock of the host (with a paravirtualized hardware
    clock, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machines where the user sets the clock manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machines where the `ntpdate` command is run at startup (or periodically) to
    set the clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In such cases, the synchronization of the virtual machine’s host or the time
    of the hardware clock on the mainboard becomes important.
  prefs: []
  type: TYPE_NORMAL
- en: Most PC mainboards have a small battery to keep the clock running while the
    system is powered off. The Linux kernel’s real-time clock (RTC) driver makes the
    clock accessible through the */dev/rtc* device (often a symlink to */dev/rtc0*).
    Time synchronization software will keep the hardware clock updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware clock of a system may be set to either the local time or to UTC
    (UTC is recommended). See the hwclock(8) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Clock**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Raspberry Pi does not have a clock battery, and it powers on with an epoch
    time of zero (January 1, 1970 00:00:00). Any logs generated before the Raspberry
    Pi’s time is synchronized will have incorrect timestamps. Knowing when the system’s
    time synchronization established the correct time is important when analyzing
    anything with timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi and other embedded systems may save a timestamp at shutdown
    so that they can set a more reasonable time at early boot (until the time is synchronized).
    This is achieved using the *fake-hwclock* software package. The time is stored
    in a file, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The time stored in the *fake-hwclock.data* file may be in UTC and match the
    corresponding filesystem timestamps (last changed and modified). A periodic cron
    job may update the time written to the file in case of an unexpected crash or
    power loss. See the fake-hwclock(8) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Timestamps and Forensic Timelines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A timestamp refers to a specific point in time, usually associated with some
    action or activity for which there is some digital evidence. Using timestamps
    in a forensic context helps to reconstruct a sequence of past events. However,
    there are challenges with using and trusting timestamps extracted from digital
    data sources. Some of the risks that affect the accuracy of timestamps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Clock drift or skew on machines without time synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delays and latency for non-real-time operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamps discovered without a known time zone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-forensics or the malicious changing of timestamps (using `timestomp`, for
    example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global investigations involving many devices across multiple time zones become
    more complex when the timestamps are impacted by these risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most forensic tools are aware of these issues and include functionality to
    adjust time accordingly. For example, The Sleuth Kit has flags that help:'
  prefs: []
  type: TYPE_NORMAL
- en: -s seconds    Adjust +/- seconds
  prefs: []
  type: TYPE_NORMAL
- en: -z zone    Specify a time zone (for example, CET)
  prefs: []
  type: TYPE_NORMAL
- en: Never completely trust timestamps. Errors, failures, or anti-forensic activity
    are always possible, so try to corroborate with timestamps on different devices
    or other evidence sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A forensic timeline is the reconstruction of events based on timestamps found
    related to investigations. The first digital forensics timelines were created
    from the timestamps of the filesystem metadata (last accessed, modified, changed,
    and so on). Today, investigators assemble timestamp data from multiple sources
    into a single *super-timeline*, which can include any relevant timestamps, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem timestamps (MACB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs (syslog, systemd journal, and application logs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser history, cookies, cache, and bookmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration data containing timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recycle/trash data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email and attachments (mbox, maildir)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Office document metadata (PDFs, LibreOffice, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EXIF data (metadata from photos or videos)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatility output files (memory forensics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Captured network traffic (PCAP files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CCTV cameras and building access systems (badge readers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone, chat, and other communication records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup archives (tar *.snar* files and backup indexes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other timestamp sources (mobile phones, IoT devices, or cloud)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A popular super-timelining framework is log2timeline/plaso, which uses free
    and open source tools to assemble timestamps from a variety of sources. You can
    visit the project website (*[https://github.com/log2timeline/plaso/](https://github.com/log2timeline/plaso/)*)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The forensic timeline of every Linux image contains several significant time
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Unix epoch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files that existed before installation (distro-provided files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time of original system installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last timestamp observed during normal operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time of forensic acquisition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should never be any timestamps after the forensic acquisition. If there
    are, they could indicate the drive image was tampered with or modified. Dates
    appearing after an acquisition could also have been deliberately created (faked)
    through anti-forensic activity.
  prefs: []
  type: TYPE_NORMAL
- en: Building and interpreting timelines presents some challenges. With large technical
    datasets, the number of timestamps available can be difficult to process (especially
    manually). Many timestamps will describe trivial or non-relevant events. Sometimes
    a collection of many timestamps describes a single overall event.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge is determining whether some event was caused by the user or
    the machine. It is also important to note, especially for filesystem forensics,
    that the farther back we look on the timeline, the less information we’ll likely
    find. Over time, sectors are overwritten, filesystem timestamps are updated, and
    other information is lost during normal system operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internationalization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The internationalization of a Linux system includes the configuration of locale,
    languages, keyboards, and other region-specific information. Global investigations
    involving the identification of people (also known as attribution) benefit greatly
    from understanding the local regional artifacts found on a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Linux internationalization refers to the support for multiple languages and
    cultural settings. The word *internationalization* is sometimes abbreviated as
    *i18n* because there are 18 characters between the *i* and *n*.
  prefs: []
  type: TYPE_NORMAL
- en: On Fedora-based and SUSE systems, some packages and scripts may read the i18n,
    keyboard, console, and language files (if they exist) in the */etc/sysconfig/*
    directory. Debian-based systems have similar keyboard, hwclock, console-setup,
    and locale files in the */etc/default/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Those files can be examined during a forensic investigation, but they have been
    partly superseded by the systemd equivalents described here.
  prefs: []
  type: TYPE_NORMAL
- en: '***Locale and Language Settings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Much of the internationalization of Linux is configured by defining the locale
    settings. The locale is part of glibc and can be used by any locale-aware software
    to control language, formatting, and other regional settings. These settings are
    defined in the */etc/locale.conf* file, which may not exist (if the system uses
    other default settings), might contain a single line (language, for example),
    or may have a detailed locale configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the language is defined as Canadian English (Unicode). The locale definition
    file describes things like date format, currency, and other local information.
    The definitions for available locales are found in */usr/share/ i18n/locales*
    and stored in readable text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'On some systems, the locale-gen program generates all the locales specified
    in */etc/locale.gen* and installs them in */usr/lib/locale/locale-archive*, where
    they can be used by any user on the system. The `localedef` tool can list the
    locales in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output should correspond to the configuration in the */etc/locale.gen* file.
    The file can be copied to a separate examination machine for offline analysis
    (using the `-i` flag).
  prefs: []
  type: TYPE_NORMAL
- en: 'From a user’s perspective, a locale is a collection of variables that define
    their local or regional preferences. On a running system, the `locale` command
    lists the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These variables determine the language, numeric formats (commas instead of periods,
    for example), time (24-hour versus AM/PM), currency, paper size, name and address
    styles, measurement, and more. Some of these variables are defined by POSIX and
    others have been added by the Linux community. In a postmortem forensic examination
    we can reconstruct these preferences from configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the locale(5) man page for more information about each of these variables
    (there are three locale man pages with different section numbers: locale(1), locale(5),
    and locale(7), so be sure to consult the right one).'
  prefs: []
  type: TYPE_NORMAL
- en: A user can also create a mixed locale composed from variables taken from multiple
    installed locales (for example, North American English language together with
    European time settings).
  prefs: []
  type: TYPE_NORMAL
- en: If no variables are defined by the user (in the shell startup scripts), the
    system-wide default locale defined in */etc/locale.conf* is used. Systemd uses
    the `localectl` tool to manage localization and reads *locale.conf* during system
    boot. Any localization explicitly defined by system administrators and users is
    interesting and may help an investigation. For example, a mixture of settings
    may indicate a person speaking a certain language, but residing in a different
    country.
  prefs: []
  type: TYPE_NORMAL
- en: Most international software projects include support for multiple languages
    for interactive messages, error messages, help pages, documentation, and other
    information communicated to the user. When separate language files are provided
    with a software package, those files are stored in */usr/share/locale/* and dynamically
    chosen depending on the configured language. The `LANG=` variable specifies the
    language to be used, which can be a system-wide default or configured for each
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Graphical environments may have additional or separate language information
    and configuration settings (for example, the `KDE_LANG` variable for KDE or settings
    in the dconf database for GNOME). The XDG **.desktop* files typically have language
    translation strings defined in the file. Some applications require separate installation
    of language packs (for example, dictionaries, office programs, and man pages).
  prefs: []
  type: TYPE_NORMAL
- en: '***Physical Keyboard Layout***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A physical system’s attached keyboard is interesting because it tells us something
    about the person who uses it. The keyboard country and language suggest the user’s
    cultural origin (however, many non-English-speaking Linux computer programmers
    and enthusiasts choose a US English keyboard). The keyboard design may also provide
    information about how the owner is using the machine. There are gamer keyboards,
    programmer/sysadmin keyboards, ergonomic keyboards, touchscreen keyboards, collectable
    keyboards, and other exotic keyboard designs. These physical keyboard characteristics
    may be useful contextual information in a forensic examination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in analyzing the keyboard is to identify the physically attached
    device. A USB keyboard’s manufacturer and product information can be found in
    the kernel logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `idVendor` is `0853`, which is Topre (see *[http://www.linux-usb.org/usb-ids.html](http://www.linux-usb.org/usb-ids.html)*),
    the `Manufacturer` is `LEOPOLD`, and the product (`0134`) is described as a `Mini
    Keyboard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual machines don’t have physical keyboards (unless a physical USB keyboard
    is passed through directly to the virtual machine), and a virtual keyboard may
    appear as a PS/2 device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The electronic/digital hardware interface to a keyboard is generic and language
    independent. A Linux system must be manually configured to map the language-specific
    layout and symbols seen on the physical key caps. This configuration can be done
    separately for the console and graphical environments.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level scancodes generated by the physical keyboard are translated by the
    kernel into keycodes. These keycodes are mapped in userspace (either on the console
    or graphical environment) to keysyms, which are the characters (glyphs) in a human
    language. The available character sets are stored in */usr/share/i18n/charmaps/*
    as compressed text files. A system-wide character set can be defined as the default,
    and a user may choose their own at login.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems replaced the early Unix serial ports with virtual consoles where
    the keyboard, mouse, and video are attached. These consoles are the text interface
    that is available when no graphical environment is started and typically seen
    at boot time or on server systems. The console keyboard (and font) can be configured
    in */etc/vconsole.conf* with the `KEYMAP=` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a graphical environment is used, the keyboard configuration describes the
    model, language, and other options. KDE stores this information in the *.config/kxkbrc*
    file of a user’s home directory. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, a Happy Hacking Keyboard (`hhk`) is used, the available language layouts
    are `us` and `ch` (Switzerland), and other options are specified (CAPS LOCK is
    remapped as a CTRL key).
  prefs: []
  type: TYPE_NORMAL
- en: GNOME stores keyboard information in the dconf database under the *org.gnome.libgnomekbgd*
    key. See [Chapter 10](ch10.xhtml) on how to analyze the dconf database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If systemd or the `localectl` command was used (manually or in a script) to
    set the configuration, the keyboard configuration will be stored in the */etc/X11/xorg.conf.d/00-keyboard.conf*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, another Happy Hacking Keyboard (`hhk`) is configured with a Swiss (`ch`)
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other window managers and graphical environments may also use dconf or have
    their own configuration files. Debian-based systems may store this information
    as variables in the */etc/default/keyboard* file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: XKB refers to the *X Keyboard Extension* from the X11 specification. See the
    xkeyboard-config(7) man page for a list of keyboard models, layouts, and options.
    Some Wayland compositors will also use these `XKB*` variables to configure the
    keyboard (Sway WM, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux and Geographic Location**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Answering the geographic “where?” question in a forensic investigation requires
    the reconstruction of the physical locations of a Linux device over time. If a
    device was stolen or missing and then subsequently recovered, where was it located
    during that time period? If a device was seized or quarantined for investigation,
    what is the history of device locations related to the incident? We can attempt
    to answer these questions using geolocation analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-held mobile devices are well known for their location-aware features, mostly
    due to the GPS implemented in hardware. Linux systems are usually installed on
    generic PCs that don’t have a built-in GPS. However, forensic artifacts indicating
    geographic location can still be found. In some cases, geolocation data may also
    be derived or inferred from other sources (external to the forensic image under
    examination).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference to location may have several different contexts, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global context** Latitude and longitude (GPS coordinates)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regional context** Cultural or political region (locale, keyboard)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizational context** Campus, building, office, or desk (IT inventory)'
  prefs: []
  type: TYPE_NORMAL
- en: These location references may be determined or inferred from a forensic analysis
    of a system or surrounding infrastructure where the system has been connected.
  prefs: []
  type: TYPE_NORMAL
- en: '***Geographic Location History***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Location history is the record of an object changing its point in space over
    a period of time. To reconstruct location history, we need physical location data
    together with timestamps. Knowing when a physical location changed helps us build
    a location timeline. Many of the ideas described here are not limited to Linux
    systems and may apply generally to other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard, language, and other locale settings provide a broad indicator
    of region location. For example, knowing that the default paper size is US Letter
    or A4 indicates whether a system is from the North American region or not. If
    a system has a Swiss keyboard and German language, it indicates a German-speaking
    region of Switzerland. If the paper size or keyboard changed at a certain (known)
    time, it may indicate a change of region.
  prefs: []
  type: TYPE_NORMAL
- en: Time and time zone changes are potential indicators of travel. If a system suddenly
    changed its time zone settings (as previously shown in the logs), that indicates
    a change in location. The number of time zones changed may also be interesting,
    as it may suggest a mode of travel (flight versus automobile).
  prefs: []
  type: TYPE_NORMAL
- en: An analysis of timestamps before and after time zone switching could also be
    interesting. Was there a significant gap in timestamp activity before the time
    zone changed? Or do the timestamps show the person was working throughout the
    period when the time zone change took place?
  prefs: []
  type: TYPE_NORMAL
- en: 'To some extent, the IP address can provide an approximate geographic location.
    This method of determining location is sometimes called *IP geolocation* or *geo-IP*
    lookup. IP ranges are allocated to regional internet registries (RIRs) that delegate
    the use of ranges to an assigned region. The five RIRs (and their dates of inception)
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: RIPE NCC, RIPE Network Coordination Centre (1992)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APNIC, Asia-Pacific Network Information Centre (1993)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIN, American Registry for Internet Numbers (1997)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LACNIC, Latin American and Caribbean Internet Address Registry (1999)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AfriNIC, African Network Information Centre (2004)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: National internet registries (NIRs) and local internet registries (LIRs) may
    further assign IP ranges to geographic regions. Companies like MaxMind (*[https://www.maxmind.com/](https://www.maxmind.com/)*)
    may compile data from internet registries, information from internet service providers
    (ISPs), and other analytical sources to produce IP lookup databases that are sold
    as products and services.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*IP geolocation for devices that use tunneling, relaying, anonymization, mobile
    networks, international non-public networks, or private IP ranges (RFC 1918) may
    not provide accurate results.*'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a forensic examination reveals an IP address linked to a timestamp,
    it is a point on the location history timeline. IP addresses from within an organization’s
    internal network may offer more accurate location information (network configuration
    documentation, IT inventory databases, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: At the link layer, the surrounding MAC addresses found in logs may be a location
    indicator. The MAC addresses of local routers or other fixed-location devices
    on a network segment may help determine location. For example, corporate IT environments
    may have an inventory of infrastructure MAC addresses that are assigned to physical
    buildings or offices. Wi-Fi infrastructure (BSSIDs) logged or cached on a local
    machine may also be a geographic location indicator.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the machine’s MAC address or other unique identifiers may be
    logged at a wireless infrastructure provider (for example, WWAN mobile devices
    connecting to cell towers or WLAN wireless interfaces connecting to public Wi-Fi
    hotspots).
  prefs: []
  type: TYPE_NORMAL
- en: Connections to stationary Bluetooth devices may indicate a physical location
    (for example, evidence that a laptop used Bluetooth to connect with a desktop
    PC, home stereo, keyboard, or printer at a known location). Bluetooth connections
    to other mobile devices that have geolocation information may help reconstruct
    location history (for example, a laptop connected to a mobile phone or automobile
    that has stored GPS location information).
  prefs: []
  type: TYPE_NORMAL
- en: Application data may provide information about past locations of a roaming Linux
    system. For example, many providers will deposit cookies containing geolocation
    information whenever someone visits their website. In addition, any connections
    made to remote services may retain location information in the server logs (assuming
    the logs can be reliably linked to the machine under examination). In some cases,
    this information can be formally requested (by subpoena or other lawful request).
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation information is often found in the metadata of files (photos, for
    example). However, this is not necessarily an indication of the PC’s location,
    but rather the device that originally took the photo.
  prefs: []
  type: TYPE_NORMAL
- en: If a Linux system is equipped with a GPS device, it is likely using the gpsd
    software package. Any programs or applications using gpsd may have logs or cached
    location data.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop PCs are usually located in a fixed physical location. If seized, the
    exact location is known (obviously). In a forensic report, other information may
    be important to document, like a building address, room number, or specific desk
    in an open plan office. In an enterprise environment, the physical location of
    a machine may have changed over time, and the location history can be reconstructed
    from changes to the IT inventory (if it exists and tracks changes to system location).
  prefs: []
  type: TYPE_NORMAL
- en: 'To some extent, we can also step into the physical world to determine the location
    of a particular electronic device. For example, some people collect stickers and
    put them on the lids of their laptops. People do this for various reasons: to
    easily identify their laptop, deter theft, or promote favorite products, projects,
    conferences, or other things. Laptop lid stickers create a unique visual identifier
    that can be matched with CCTV camera footage or geolocation tags of photos containing
    the laptop. They may also match specific conferences and events where the stickers
    were distributed.'
  prefs: []
  type: TYPE_NORMAL
- en: '***GeoClue Geolocation Service***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The GeoClue software project was started to provide location information for
    location-aware applications using D-Bus. As documented on its website (*[https://gitlab.freedesktop.org/geoclue/geoclue/](https://gitlab.freedesktop.org/geoclue/geoclue/)*),
    it derives location information from:'
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi-based geolocation using Mozilla Location Service (accuracy in yards/meters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPS(A) receivers (accuracy in inches/centimeters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPS of other devices on the local network, such as smartphones (accuracy in
    inches/centimeters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3G modems (accuracy in miles/kilometers, unless the modem has GPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoIP (city-level accuracy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoClue was initially written for use by GNOME applications, but it is a D-Bus
    service and can be used by any application that is authorized in the GeoClue configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'GeoClue’s configuration file defines which location sources to use and which
    local applications are permitted to request location information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The daemon itself does not log location information; however, applications that
    use it may log or store this information.
  prefs: []
  type: TYPE_NORMAL
- en: The preference for using location services is stored in the user’s dconf database
    (*org.gnome.system.location.enabled*). This preference is independent of whether
    the `geoclue` service is running. If a user disables location services in their
    GUI settings, the `geoclue` service will not be disabled system-wide. Determining
    whether GeoClue was enabled requires checking for the existence of the systemd
    *geoclue.service* file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter described how to analyze time-related elements of a Linux system.
    It explored the Linux internationalization features and how they can be useful
    in a forensic investigation. It also considered geolocation in the context of
    a Linux forensic analysis. This chapter has touched on user activity and behavior,
    a topic that the next chapter covers in greater depth.
  prefs: []
  type: TYPE_NORMAL
