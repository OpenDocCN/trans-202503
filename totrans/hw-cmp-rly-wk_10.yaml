- en: '## **10'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **10'
- en: OPERATING SYSTEMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'So far, we’ve examined a computer’s hardware and software. In this chapter,
    we look at a particular kind of software: operating systems. First, we cover the
    challenges of programming without an operating system (OS). Then we look at an
    overview of OSes. We spend the bulk of the chapter detailing some of the core
    capabilities of operating systems. In the projects, you have a chance to examine
    the workings of Raspberry Pi OS.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了计算机的硬件和软件。在本章中，我们将关注一种特定类型的软件：操作系统。首先，我们将讨论没有操作系统（OS）时编程的挑战。接着，我们将概述操作系统。我们将在本章的大部分内容中详细介绍操作系统的核心功能。在项目中，你将有机会深入了解Raspberry
    Pi OS的工作原理。
- en: '**Programming Without an Operating System**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**没有操作系统的编程**'
- en: 'Let’s begin by considering what it’s like to use and program a device without
    an OS. As you’ll see in a minute, operating systems provide an interface between
    hardware and other software. However, on a device without an OS, the software
    has direct access to the hardware. There are many examples of computers that work
    this way, but let’s focus on one type in particular: early video game consoles.
    If we look back at game consoles such as the Atari 2600, the Nintendo Entertainment
    System, or the Sega Genesis, we find hardware that runs code from a cartridge,
    with no operating system in place. [Figure 10-1](ch10.xhtml#ch10fig1) illustrates
    the idea that the game’s software ran directly on the console hardware, with nothing
    in between.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑一下在没有操作系统的设备上使用和编程的情况。正如你马上会看到的，操作系统提供了硬件与其他软件之间的接口。然而，在没有操作系统的设备上，软件可以直接访问硬件。有许多计算机就是这样工作的，但我们特别关注其中的一种类型：早期的电子游戏主机。如果我们回顾像雅达利2600、任天堂娱乐系统或世嘉Genesis这样的游戏主机，我们会发现这些硬件从游戏卡带中运行代码，没有操作系统。[图10-1](ch10.xhtml#ch10fig1)展示了游戏软件直接在主机硬件上运行的概念，中间没有任何介入。
- en: '![image](../images/fig10-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-1.jpg)'
- en: '*Figure 10-1: Early video games ran directly on game console hardware, with
    no operating system.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：早期的视频游戏直接在游戏主机硬件上运行，没有操作系统。*'
- en: To use such a system you simply inserted a cartridge and turned on the system
    to start the game. The game console ran only one program at a time—the game currently
    in the cartridge slot. On most systems of this kind, turning on the system without
    a cartridge inserted did nothing, since the CPU didn’t have any instructions to
    run. To switch to a different game, you needed to turn off the system, swap cartridges,
    and turn it back on. There was no concept of switching between programs while
    the system was running. Nor were any programs running in the background. A single
    program, the game, had the complete attention of the hardware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种系统时，你只需插入一个卡带并打开系统以开始游戏。这款游戏主机一次只能运行一个程序——即当前插入卡带中的游戏。在大多数此类系统中，如果没有插入卡带，打开系统不会有任何反应，因为CPU没有任何指令可供执行。要切换到另一个游戏，你需要关掉系统，交换卡带，再重新开机。系统运行时没有切换程序的概念，也没有任何程序在后台运行。一个程序，即游戏，完全占用了硬件的所有资源。
- en: As a programmer, making a game for a system like this meant taking responsibility
    for directly controlling hardware with code. Once the system powered up, the CPU
    began running the code on the cartridge. The game developer not only had to write
    software for the game’s logic but also had to initialize the system, control the
    video hardware, read the hardware state of the controller inputs, and so forth.
    Different console hardware had radically different designs, so a developer needed
    to understand the intricacies of the hardware they were targeting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，为这种系统制作游戏意味着必须负责直接通过代码控制硬件。系统启动后，CPU开始运行卡带中的代码。游戏开发者不仅需要为游戏的逻辑编写软件，还必须初始化系统、控制视频硬件、读取控制器输入的硬件状态等。不同的游戏主机硬件设计差异极大，因此开发者需要了解他们所针对硬件的复杂性。
- en: Fortunately for old-school game developers, a game console would retain the
    same hardware design, more or less, during the years it was manufactured. For
    example, all Nintendo Entertainment System (NES) consoles have the same type of
    processor, RAM, picture processing unit (PPU), and audio processing unit (APU).
    To be a successful NES developer you had to have a solid understanding of all
    this hardware, but at least the hardware was the same in every NES sold to gamers.
    Developers knew exactly what hardware would be in a system, so they could target
    their code to that specific hardware, which allowed them to squeeze every ounce
    of performance from the system. However, to port their game to another type of
    game console, they often had to rewrite a substantial portion of their code. Additionally,
    every game cartridge had to include similar code to accomplish fundamental tasks,
    such as initializing the hardware. Although developers could reuse code they had
    previously written for other games, this still meant different developers were
    solving the same challenges over and over, with varying degrees of success.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于老派的游戏开发者来说，游戏主机在制造的过程中，硬件设计几乎没有变化。例如，所有的任天堂娱乐系统 (NES) 游戏主机都拥有相同类型的处理器、内存、图像处理单元
    (PPU) 和音频处理单元 (APU)。要成为一名成功的 NES 开发者，你必须对所有这些硬件有深刻的理解，但至少每台出售给玩家的 NES 主机的硬件都是一样的。开发者知道系统中会有什么硬件，因此可以将代码针对特定硬件进行优化，这样他们就能从系统中榨取每一分性能。然而，要将他们的游戏移植到另一种类型的游戏主机时，他们通常不得不重写大量代码。此外，每个游戏卡带必须包含类似的代码来完成基本任务，比如初始化硬件。尽管开发者可以重用他们之前为其他游戏编写的代码，但这仍然意味着不同的开发者一次又一次地解决相同的挑战，且成功的程度各不相同。
- en: '**Operating Systems Overview**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作系统概述**'
- en: Operating systems provide a different model for programming, and in doing so,
    address many of the challenges associated with writing code that directly targets
    specific hardware. An *operating system (OS)* is software that communicates with
    computer hardware and provides an environment for the execution of programs. Operating
    systems allow programs to request system services, such as reading from storage
    or communicating over a network. OSes handle the initialization of a computer
    system and manage the execution of programs. This includes running multiple programs
    in parallel, or *multitasking*, ensuring that multiple programs can share time
    on the processor and share system resources. An OS puts boundaries in place to
    ensure that programs are isolated from each other and from the OS, and to ensure
    that users who share a system are granted appropriate access. You can think of
    an operating system as a layer of code between hardware and applications, as illustrated
    in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供了一种不同的编程模型，并通过这种方式，解决了许多与直接针对特定硬件编写代码相关的挑战。*操作系统 (OS)* 是与计算机硬件通信并为程序执行提供环境的软件。操作系统允许程序请求系统服务，如从存储设备读取数据或通过网络进行通信。操作系统负责计算机系统的初始化，并管理程序的执行。这包括并行运行多个程序，或称为*多任务处理*，确保多个程序能够共享处理器时间和系统资源。操作系统设置边界，确保程序之间以及程序与操作系统之间相互隔离，并确保共享系统的用户获得适当的访问权限。你可以将操作系统视为硬件和应用程序之间的代码层，如[图
    10-2](ch10.xhtml#ch10fig2)所示。
- en: '![image](../images/fig10-2.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-2.jpg)'
- en: '*Figure 10-2: An operating system acts as a layer between hardware and applications.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：操作系统充当硬件和应用程序之间的层。*'
- en: This layer provides a set of capabilities that abstract away the details of
    the underlying hardware, allowing software developers to focus on the logic of
    their software, rather than on communicating with specific hardware. As you might
    expect, this is very useful, given the diversity of today’s computing devices.
    Considering the amazing variety of hardware found in smartphones and PCs, writing
    code for each type of device is impractical. Operating systems hide the details
    of hardware and provide common services that applications can build on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层提供了一套抽象底层硬件细节的功能，使软件开发者能够专注于软件的逻辑，而不是与特定硬件进行通信。正如你可能预料的那样，考虑到当今计算设备的多样性，这非常有用。考虑到智能手机和个人电脑中硬件的惊人多样性，为每种设备编写代码是不切实际的。操作系统隐藏了硬件的细节，并提供了应用程序可以构建的通用服务。
- en: 'At a high level, the components included with an operating system can be categorized
    into two major buckets:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，操作系统包含的组件可以分为两个主要类别：
- en: The kernel
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: Everything else
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一切
- en: An operating system *kernel* is responsible for managing memory, facilitating
    device I/O, and providing a set of system services for applications. The kernel
    allows multiple programs to run in parallel and share hardware resources. It is
    the core part of an operating system, but it alone provides no way for end users
    to interact with the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的*内核*负责管理内存、促进设备 I/O，并为应用程序提供一组系统服务。内核允许多个程序并行运行并共享硬件资源。它是操作系统的核心部分，但单独并不能为最终用户提供与系统交互的方式。
- en: Operating systems also include non-kernel components that are needed for a system
    to be of use. This includes the *shell*, a user interface for working with the
    kernel. The terms *shell* and *kernel* are part of a metaphor for operating systems,
    where the OS is thought of as a nut or seed. The kernel is at the core; a shell
    surrounds it. The shell can be either a command line interface (CLI) or a graphical
    user interface (GUI). Some examples of shells are the Windows shell GUI (including
    the desktop, Start menu, taskbar, and File Explorer), and the Bash shell CLI found
    on Linux and Unix systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统还包括一些非内核组件，这是系统有用的必备部分。包括*shell*，即与内核交互的用户界面。*shell*和*内核*这两个术语是操作系统的隐喻，其中操作系统被视为一个坚果或种子。内核处于核心位置，shell环绕其周围。shell
    可以是命令行界面（CLI）或图形用户界面（GUI）。一些 shell 的例子包括 Windows 的 shell GUI（包括桌面、开始菜单、任务栏和文件资源管理器）以及
    Linux 和 Unix 系统中的 Bash shell CLI。
- en: Some capabilities of operating systems are provided by software that runs in
    the background, distinct from the kernel, known as *daemons* or *services* (not
    to be confused with kernel system services mentioned earlier). An example of such
    a service is Task Scheduler on Windows or cron on Unix and Linux, both of which
    allow the user to schedule programs to run at certain times.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的一些功能由在后台运行的软件提供，这些软件与内核不同，称为*守护进程*或*服务*（不要与前面提到的内核系统服务混淆）。这种服务的一个例子是 Windows
    上的任务调度程序或 Unix 和 Linux 上的 cron，它们都允许用户在特定时间安排程序运行。
- en: Operating systems also commonly include *software libraries* for developers
    to build on. Such libraries include common code that many applications can leverage.
    Additionally, components of the operating system itself, such as the shell and
    services, use the functionality provided by such libraries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统还通常包括*软件库*，供开发人员进行构建。这些库包含许多应用程序可以利用的通用代码。此外，操作系统本身的组件，如 shell 和服务，也使用这些库提供的功能。
- en: When it comes to interacting with hardware, the kernel acts in partnership with
    device drivers. A *device driver*, or simply *driver*, is software designed to
    interact with specific hardware. An operating system’s kernel needs to work with
    a wide variety of hardware, so rather than designing the kernel to know how to
    interact with every hardware device in the world, software developers implement
    the code for specific devices in device drivers. Operating systems typically include
    a set of device drivers for common hardware and also provide a mechanism for installing
    additional drivers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在与硬件交互时，内核与设备驱动程序协作。*设备驱动程序*，或简称*驱动程序*，是用于与特定硬件交互的软件。操作系统的内核需要与各种硬件设备协作，因此，软件开发人员将与特定设备交互的代码实现为设备驱动程序，而不是让内核了解如何与世界上每个硬件设备交互。操作系统通常包括一套常见硬件的设备驱动程序，并提供安装额外驱动程序的机制。
- en: Most operating systems include a collection of basic applications like a text
    editor and calculator, often referred to collectively as *utilities*. A web browser
    is also a standard inclusion for many operating systems. Such utilities are arguably
    not truly part of the operating system and are rather simply applications, but
    in practice, most operating systems include this kind of software. [Figure 10-3](ch10.xhtml#ch10fig3)
    provides a summarized view of the components included in an operating system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都包括一些基本应用程序，如文本编辑器和计算器，通常统称为*实用程序*。网络浏览器也是许多操作系统的标准组件。这些实用程序可以说并不真正属于操作系统，而只是应用程序，但实际上，大多数操作系统都包括这种软件。[图
    10-3](ch10.xhtml#ch10fig3) 提供了操作系统中组件的简要概述。
- en: '![image](../images/fig10-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-3.jpg)'
- en: '*Figure 10-3: An operating system includes multiple components.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：操作系统包含多个组件。*'
- en: As you can see in [Figure 10-3](ch10.xhtml#ch10fig3), at the foundation of the
    software stack, right above hardware, are the kernel and device drivers. Libraries
    provide functionality that applications build on, so libraries are shown as a
    layer between the kernel and applications. The shell, services, and utilities
    also build on libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 10-3](ch10.xhtml#ch10fig3)中所见，在软件栈的基础部分，硬件之上，是内核和设备驱动程序。库提供应用程序构建所需的功能，因此库被显示为位于内核和应用程序之间的层。Shell、服务和实用工具也基于库构建。
- en: '**Operating System Families**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作系统家族**'
- en: 'Today, there are two dominant operating system families: Unix-like operating
    systems, and Microsoft Windows. As the name implies, *Unix-like* operating systems
    behave like a Unix operating system. Linux, macOS, iOS, and Android are all examples
    of Unix-like operating systems. *Unix* was first developed at Bell Labs and has
    a history that goes back to the 1960s. Unix initially ran on a PDP-7 minicomputer,
    but it has since been ported to many kinds of computers. Originally written in
    assembly language, Unix was later rewritten in C, allowing it to be compiled for
    various processors. Today it’s used on servers, and it has a strong presence on
    personal computers and smartphones thanks to Apple’s macOS and iOS, both of which
    are based on Unix. Unix supports multiple users, multitasking, and a unified,
    hierarchical directory structure. It has a robust command line shell, supported
    by well-defined standard command line tools that can be used together to accomplish
    complex tasks.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，主流的操作系统家族有两个：类Unix操作系统和Microsoft Windows。如其名所示，*类Unix*操作系统表现得像Unix操作系统。Linux、macOS、iOS和Android都是类Unix操作系统的例子。*Unix*最初在贝尔实验室开发，其历史可以追溯到1960年代。Unix最初运行在PDP-7小型计算机上，但后来被移植到许多种计算机上。Unix最初是用汇编语言编写的，后来被重写成C语言，从而使其能够在各种处理器上编译运行。今天，Unix被用于服务器，并且由于苹果的macOS和iOS（这两者都基于Unix），它在个人计算机和智能手机上也占有重要地位。Unix支持多用户、多任务处理和统一的层次化目录结构。它有一个强大的命令行Shell，并通过一套明确标准的命令行工具支持，可以将这些工具结合使用，完成复杂任务。
- en: The *Linux* kernel was originally developed by Linus Torvalds, who set out to
    create an operating system that was similar to Unix. Linux isn’t Unix, but it’s
    certainly Unix-like. It behaves much like Unix while not including any Unix source
    code. A *Linux distribution* is an OS that’s a bundling of the Linux kernel with
    other software. The Linux kernel is *open source*, meaning its source code is
    freely available. Many distributions of Linux are available at no cost. A typical
    Linux distribution includes a Linux kernel and a collection of Unix-like components
    from the GNU project (pronounced “guh-new”).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux*内核最初是由Linus Torvalds开发的，他的目标是创建一个类似Unix的操作系统。Linux不是Unix，但它无疑是类Unix的。它的行为很像Unix，但不包含任何Unix源代码。*Linux发行版*是将Linux内核与其他软件捆绑在一起的操作系统。Linux内核是*开源的*，这意味着其源代码是公开的。许多Linux发行版是免费的。典型的Linux发行版包括一个Linux内核和来自GNU项目的一些类Unix组件（发音为“guh-new”）。'
- en: '*GNU*, a recursive acronym that stands for *GNU’s Not Unix*, is a software
    project started in the 1980s, with a goal of creating a Unix-like operating system
    as free software. The GNU project and Linux are separate efforts, but they have
    become closely associated. The release of the Linux kernel in 1991 prompted an
    effort to port GNU software to Linux. At the time, GNU didn’t have a complete
    kernel, whereas Linux lacked a shell, libraries, and so forth. Linux provided
    a kernel for GNU code to run upon, while the GNU project provided a shell, libraries,
    and utilities to Linux. In this way, the two projects are complementary, and together
    form a complete operating system.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU*是一个递归首字母缩略词，代表*GNU不是Unix*，这是一个始于1980年代的软件项目，目标是将Unix-like操作系统作为自由软件创建。GNU项目和Linux是两个独立的努力，但它们已紧密相关。1991年Linux内核发布后，促使了将GNU软件移植到Linux的努力。当时，GNU没有完整的内核，而Linux缺乏Shell、库等。因此，Linux为GNU代码提供了内核，而GNU项目则为Linux提供了Shell、库和实用工具。通过这种方式，这两个项目互为补充，共同形成了一个完整的操作系统。'
- en: Today, people commonly use the term *Linux* to refer to operating systems that
    are combinations of the Linux kernel and GNU software. This is somewhat controversial,
    since calling the entire OS “Linux” doesn’t recognize the large part that GNU
    software plays in many Linux distributions. That said, in this book I follow the
    prevalent convention of referring to the entire OS as Linux, rather than GNU/Linux
    or something similar.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，人们通常用*Linux*一词来指代由Linux内核和GNU软件组合而成的操作系统。这有些争议，因为将整个操作系统称为“Linux”没有体现出GNU软件在许多Linux发行版中所起的重要作用。尽管如此，在本书中，我遵循普遍的惯例，将整个操作系统称为Linux，而非GNU/Linux或类似的名称。
- en: Today, Linux is commonly found on servers and embedded systems, and it’s popular
    with software developers. The Android operating system is based on the Linux kernel,
    so Linux has a huge presence in the smartphone market. Raspberry Pi OS (previously
    called Raspbian) is also a Linux distribution that includes GNU software, and
    we’ll be using Raspberry Pi OS to explore Linux further. In general, in this book
    I’m going to lean on Linux rather than Unix when giving examples of Unix-like
    behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Linux通常用于服务器和嵌入式系统，并且在软件开发者中非常流行。Android操作系统基于Linux内核，因此Linux在智能手机市场占有重要地位。Raspberry
    Pi OS（前称Raspbian）也是一个包括GNU软件的Linux发行版，我们将使用Raspberry Pi OS来进一步探索Linux。总体来说，在本书中，我将更多依赖Linux，而非Unix，来举例说明类Unix行为。
- en: Microsoft Windows is the dominant operating system on personal computers, including
    desktops and laptops. It also has a strong presence in the server space (Windows
    Server). Windows is unique in that it doesn’t trace its roots back to Unix. Early
    versions of Windows were based on MS-DOS (Microsoft Disk Operating System). Although
    popular in the home computer market, these early versions of Windows were not
    robust enough to compete against Unix-like operating systems in the server or
    high-end workstation market.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Windows是个人计算机上占主导地位的操作系统，包括台式机和笔记本电脑。它在服务器领域（Windows Server）也有着强大的影响力。Windows的独特之处在于它并不追溯至Unix。Windows的早期版本基于MS-DOS（微软磁盘操作系统）。尽管在家用计算机市场广受欢迎，这些早期版本的Windows在服务器或高端工作站市场上并不足够强大，无法与类Unix操作系统竞争。
- en: In parallel to the development of Windows, Microsoft partnered with IBM in the
    1980s to create the OS/2 operating system, an intended successor to MS-DOS on
    the IBM PC. Microsoft and IBM disagreed on the direction of the OS/2 project,
    and in 1990, IBM took over development of OS/2, whereas Microsoft pivoted their
    efforts to another operating system they already had under development, Windows
    NT. Unlike the MS-DOS–based versions of Windows, Windows NT was based on a new
    kernel. Windows NT was designed to be portable across different hardware, be compatible
    with various types of software, support multiple users, and provide high levels
    of security and reliability. Microsoft hired Dave Cutler from Digital Equipment
    Corporation (DEC) to lead the work on Windows NT. He brought a number of former
    DEC engineers with him, and elements of the NT kernel’s design can be traced to
    Dave Cutler’s work on the VMS operating system at DEC.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows的发展并行，微软在1980年代与IBM合作创建了OS/2操作系统，这是MS-DOS在IBM PC上的继任者。微软和IBM在OS/2项目的方向上产生了分歧，1990年，IBM接管了OS/2的开发，而微软则将精力转向了另一款已经在开发中的操作系统——Windows
    NT。与基于MS-DOS的Windows版本不同，Windows NT基于全新的内核。Windows NT的设计旨在能够在不同的硬件上移植，兼容多种类型的软件，支持多用户，并提供高度的安全性和可靠性。微软从数字设备公司（DEC）聘请了Dave
    Cutler来领导Windows NT的开发工作。他带领了一批来自DEC的前工程师，NT内核设计的部分元素可以追溯到Dave Cutler在DEC开发VMS操作系统时的工作。
- en: In its early releases, Windows NT was positioned as a business-focused version
    of Windows that would coexist with the consumer-focused version of Windows. These
    two Windows versions were quite different in their implementations, but they shared
    a similar user interface and programming interface. The user interface similarities
    meant that users familiar with Windows could readily be productive on a Windows
    NT system. The common programming interface allowed software developed for DOS-based
    Windows to work, sometimes without alteration, on Windows NT. With the release
    of Windows XP in 2001, Microsoft brought the NT kernel to a consumer-focused release
    of Windows. Since the release of Windows XP, all versions of desktop and server
    Windows have been built upon the NT kernel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '在早期版本中，Windows NT 被定位为一款面向商业的 Windows 版本，旨在与面向消费者的 Windows 版本共存。这两个 Windows
    版本在实现上有很大不同，但它们共享相似的用户界面和编程接口。用户界面的相似性意味着熟悉 Windows 的用户可以迅速在 Windows NT 系统上投入生产工作。通用的编程接口使得为基于
    DOS 的 Windows 开发的软件能够在 Windows NT 上运行，有时甚至无需修改。随着 2001 年 Windows XP 的发布，微软将 NT
    内核带入了面向消费者的 Windows 版本。从 Windows XP 发布起，所有桌面和服务器版 Windows 都是基于 NT 内核构建的。  '
- en: '[Table 10-1](ch10.xhtml#ch10tab1) lists some operating systems and devices
    commonly in use today and the OS family for each.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-1](ch10.xhtml#ch10tab1) 列出了今天常用的一些操作系统和设备，以及它们所属的操作系统家族。'
- en: '**Table 10-1:** Common Operating Systems'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** 常见操作系统'
- en: '| **OS or device** | **Family** | **Notes** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统或设备** | **家族** | **备注** |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Android | Unix-like | Android uses the Linux kernel, although otherwise,
    it isn’t very Unix-like. Its user experience and application programming interfaces
    are quite different from a typical Unix system. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Android | 类Unix | Android 使用 Linux 内核，尽管在其他方面，它并不算非常 Unix-like。其用户体验和应用编程接口与典型的
    Unix 系统大相径庭。 |'
- en: '| iOS | Unix-like | iOS is based on the Unix-like open source Darwin operating
    system. Like Android, the iOS user experience and programming interface are different
    from a typical Unix system. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| iOS | 类Unix | iOS 基于类 Unix 的开源 Darwin 操作系统。与 Android 相似，iOS 的用户体验和编程接口与典型的
    Unix 系统不同。 |'
- en: '| macOS | Unix-like | macOS is based on the Unix-like open source Darwin operating
    system. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| macOS | 类Unix | macOS 基于类 Unix 的开源 Darwin 操作系统。 |'
- en: '| PlayStation 4 | Unix-like | The PlayStation 4 OS is based on the Unix-like
    FreeBSD kernel. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| PlayStation 4 | 类Unix | PlayStation 4 操作系统基于类 Unix 的 FreeBSD 内核。 |'
- en: '| Raspberry Pi OS | Unix-like | Raspberry Pi OS is a Linux distribution. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Raspberry Pi OS | 类Unix | Raspberry Pi OS 是一个 Linux 发行版。 |'
- en: '| Ubuntu | Unix-like | Ubuntu is a Linux distribution. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu | 类Unix | Ubuntu 是一个 Linux 发行版。 |'
- en: '| Windows 10 | Windows | Windows 10 uses the Windows NT kernel. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Windows 10 | Windows | Windows 10 使用 Windows NT 内核。 |'
- en: '| Xbox One | Windows | Xbox One has an OS that uses the Windows NT kernel.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Xbox One | Windows | Xbox One 的操作系统使用 Windows NT 内核。 |'
- en: '**EXERCISE 10-1: GET TO KNOW THE OPERATING SYSTEMS IN YOUR LIFE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10-1：了解你生活中的操作系统**'
- en: Choose a couple of computing devices that you own or use, say a laptop, smartphone,
    or game console. What operating system does each device run? To what operating
    system family (Windows, Unix-like, other) does each belong?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 选择几台你拥有或使用的计算设备，例如笔记本电脑、智能手机或游戏机。每个设备运行的操作系统是什么？它们属于哪种操作系统家族（Windows、类 Unix、其他）？
- en: '**Kernel Mode and User Mode**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核模式与用户模式**'
- en: An operating system is responsible for ensuring that the programs that run on
    it behave well. What does this mean in practice? Let’s look at some examples.
    Each program must not interfere with other programs or with the kernel. Users
    shouldn’t be able to modify system files. Applications must not be allowed to
    directly access hardware; all such requests must go through the kernel. Given
    these kinds of requirements, how can the operating system ensure that non-OS code
    complies with the mandates of the operating system? This is handled by leveraging
    a CPU capability that grants the operating system special rights while placing
    restrictions on other code; this is known as the *privilege level* of the code.
    A processor may offer more than two levels of privilege, but most operating systems
    only use two levels. The level of higher privilege is known as *kernel mode*,
    and the level of lower privilege is known as *user mode*. Kernel mode is also
    referred to as *supervisor mode*. Code running in kernel mode has full access
    to the system, including access to all memory, I/O devices, and special CPU instructions.
    Code running in user mode has limited access. Generally speaking, the kernel and
    many device drivers run in kernel mode, whereas everything else runs in user mode,
    as illustrated in [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的责任是确保其上运行的程序行为良好。实践中这意味着什么呢？我们来看几个例子。每个程序不得干扰其他程序或内核。用户不应能够修改系统文件。应用程序不得直接访问硬件；所有此类请求必须通过内核处理。考虑到这些要求，操作系统如何确保非操作系统代码遵守操作系统的规定呢？这通过利用一种CPU能力来实现，该能力赋予操作系统特殊权限，同时对其他代码施加限制；这就是*特权级别*。处理器可能提供超过两个特权级别，但大多数操作系统仅使用两个级别。较高的特权级别称为*内核模式*，较低的特权级别称为*用户模式*。内核模式也被称为*监督模式*。在内核模式下运行的代码可以完全访问系统，包括访问所有内存、I/O设备和特殊的CPU指令。而在用户模式下运行的代码则有着有限的访问权限。通常情况下，内核和许多设备驱动程序在内核模式下运行，而其他所有程序则在用户模式下运行，如[图10-4](ch10.xhtml#ch10fig4)所示。
- en: '![image](../images/fig10-4.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-4.jpg)'
- en: '*Figure 10-4: The division of code that runs in user mode vs. kernel mode*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：用户模式与内核模式下运行的代码的划分*'
- en: Code allowed to run in kernel mode is *trusted*, whereas user mode code is *untrusted*.
    Code that runs in kernel mode has full access to everything on a system, so it
    better be trustworthy! By only allowing trusted code to run in kernel mode, the
    operating system can ensure that user mode code is well-behaved.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核模式下运行的代码是*可信的*，而用户模式下的代码是*不可信的*。在内核模式下运行的代码可以完全访问系统中的所有内容，因此它必须是值得信赖的！通过仅允许可信代码在内核模式下运行，操作系统可以确保用户模式下的代码行为规范。
- en: '**KERNEL MODE COMPONENTS IN WINDOWS**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows中的内核模式组件**'
- en: 'It’s worth noting that Microsoft Windows has a few other major components that
    run in kernel mode. In Windows, foundational kernel mode capabilities are actually
    split between two components: the kernel and the *executive*. The distinction
    is only relevant when discussing the internal architecture of Windows; the separation
    is not of concern to most software developers or users. In fact, the compiled
    machine code for both the kernel and the executive is contained in the same file
    (*ntoskrnl.exe*). I won’t distinguish between the Windows NT kernel and executive
    for the remainder of this book. Besides the kernel, executive, and device drivers,
    Windows has other major components that run in kernel mode. The *Hardware Abstraction
    Layer (HAL)* isolates the kernel, executive, and device drivers from differences
    in low-level hardware, such as variations in motherboards. The *windowing and
    graphics system (win32k)* provides capabilities for drawing graphics and programmatically
    interacting with user interface elements.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，微软Windows还有一些其他主要组件运行在内核模式下。在Windows中，基础的内核模式功能实际上分布在两个组件中：内核和*执行组件*。这种区分仅在讨论Windows的内部架构时才有意义；对于大多数软件开发人员或用户而言，这种分离并不重要。事实上，内核和执行组件的编译机器代码都包含在同一个文件中（*ntoskrnl.exe*）。在本书的其余部分，我将不区分Windows
    NT内核和执行组件。除了内核、执行组件和设备驱动程序之外，Windows还有其他几个主要组件运行在内核模式下。*硬件抽象层（HAL）*将内核、执行组件和设备驱动程序与低级硬件的差异（如主板的变化）隔离开来。*窗口和图形系统（win32k）*提供绘制图形和通过编程与用户界面元素交互的能力。
- en: '**Processes**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进程**'
- en: One of an operating system’s main functions is to provide a platform for programs
    to run. As we saw in the previous chapter, programs are sequences of machine instructions,
    typically stored in an executable file. However, a set of instructions stored
    in a file can’t actually perform any work on its own. Something needs to load
    the file’s instructions into memory and direct the CPU to run the program, all
    while ensuring the program doesn’t misbehave. That’s the job of the operating
    system. When an operating system starts a program, it creates a *process*, a running
    instance of that program. Earlier we covered things that run in user mode (such
    as the shell, services, and utilities)—each of these execute within a process.
    If code is running in user mode, it’s running within a process, as illustrated
    in [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的主要功能之一是为程序提供运行平台。正如我们在上一章所看到的，程序是机器指令的序列，通常存储在可执行文件中。然而，存储在文件中的一组指令本身并不能执行任何工作。必须有某些东西将文件中的指令加载到内存中，并指导
    CPU 执行程序，同时确保程序不出现异常行为。这正是操作系统的工作。当操作系统启动一个程序时，它会创建一个 *进程*，即该程序的一个运行实例。在前面的内容中，我们讨论了运行在用户模式中的事物（例如
    shell、服务和实用工具）——这些都在进程中执行。如果代码在用户模式下运行，它就在进程内运行，如 [图 10-5](ch10.xhtml#ch10fig5)
    所示。
- en: A process is a container in which a program runs. This container includes a
    private virtual memory address space (more on this later), a copy of the program
    code loaded into memory, and other information about the state of the process.
    A program can be started multiple times, and each execution results in the operating
    system creating a new process. Each process has a unique identifier (a number)
    called a *process identifier*, a *process ID*, or just a *PID*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是程序运行的容器。这个容器包括一个私有的虚拟内存地址空间（稍后会详细介绍），加载到内存中的程序代码的副本，以及关于进程状态的其他信息。一个程序可以被启动多次，每次执行都会导致操作系统创建一个新的进程。每个进程都有一个唯一的标识符（一个数字），称为
    *进程标识符*、*进程 ID*，或简称 *PID*。
- en: '![image](../images/fig10-5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-5.jpg)'
- en: '*Figure 10-5: Processes run in user mode*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：在用户模式下运行的进程*'
- en: Other than initial processes started by the kernel, every process has a parent,
    the process that started it. This relationship of parent to child creates a tree
    of processes. If a child’s parent process terminates before the child, the child
    becomes an *orphan process*, meaning, not surprisingly, it has no parent. On Windows,
    the orphaned child process simply remains parentless. On Linux, an orphaned process
    is typically adopted by the *init process*, the first user mode process to start
    on a Linux system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由内核启动的初始进程外，每个进程都有一个父进程，也就是启动它的进程。父子进程的这种关系构成了进程树。如果一个子进程的父进程在子进程之前终止，那么这个子进程就成了
    *孤儿进程*，也就是说，毫不奇怪，它没有父进程。在 Windows 上，孤儿进程的子进程将保持没有父进程。而在 Linux 上，孤儿进程通常会被 *init
    进程* 收养，init 进程是 Linux 系统上启动的第一个用户模式进程。
- en: '[Figure 10-6](ch10.xhtml#ch10fig6) shows a process tree on Raspberry Pi OS.
    This view was generated using the `pstree` utility.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-6](ch10.xhtml#ch10fig6) 显示了 Raspberry Pi OS 上的进程树。这个视图是使用 `pstree` 工具生成的。'
- en: '![image](../images/fig10-6.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-6.jpg)'
- en: '*Figure 10-6: An example Linux process tree as shown by `pstree`*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：通过 `pstree` 显示的 Linux 进程树示例*'
- en: In [Figure 10-6](ch10.xhtml#ch10fig6), we see that the init process was `systemd`;
    it was the first process to start, and it in turn started other processes. Child
    threads are shown with curly braces (more on threads soon). To generate this output,
    I ran the `pstree` command from a command line shell, and in the output, you can
    see that `pstree` itself is running, as expected. It’s the child of `bash` (the
    shell), which in turn is the child of `sshd`. In other words, you can tell from
    this output that I ran `pstree` from a Bash shell that was opened in a remote
    Secure Shell (SSH) session.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 10-6](ch10.xhtml#ch10fig6) 中，我们看到 init 进程是 `systemd`；它是第一个启动的进程，接着它又启动了其他进程。子线程使用大括号显示（稍后会详细讨论线程）。为了生成这个输出，我在命令行
    shell 中运行了 `pstree` 命令，在输出中，你可以看到 `pstree` 本身正在运行，正如预期的那样。它是 `bash`（shell）的子进程，而
    `bash` 又是 `sshd` 的子进程。换句话说，从这个输出可以看出，我是在一个远程安全 Shell（SSH）会话中打开的 Bash shell 中运行
    `pstree`。
- en: To see the process tree on a computer running Windows, I recommend that you
    use the Process Explorer tool that you can download from Microsoft. It’s a GUI
    application that gives you a rich view of the processes running on your computer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看运行 Windows 的计算机上的进程树，我建议你使用可以从 Microsoft 下载的 Process Explorer 工具。它是一个图形界面应用程序，能够让你深入查看计算机上正在运行的进程。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #20](ch10.xhtml#proj20) on [page 218](ch10.xhtml#page_218),
    where you can look at running processes on your device*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #20](ch10.xhtml#proj20) 以及 [第 218 页](ch10.xhtml#page_218)，在那里你可以查看设备上运行的进程*。'
- en: '**Threads**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线程**'
- en: By default, a program executes instructions sequentially, handling one task
    at a time. But what if a program needs to perform two or more tasks in parallel?
    For example, let’s say a program needs to perform some long-running calculation
    while updating the user interface at the same time, perhaps to show a progress
    bar. If the program is completely sequential, once the program begins its calculation,
    the user interface is neglected, since the CPU time allocated to the program must
    be spent elsewhere. The desired behavior is that the UI updates while the calculation
    runs—these are two separate tasks that need to happen in parallel. Operating systems
    provide this capability with *threads of execution*, or just *threads*. A thread
    is a schedulable unit of execution within a process. A thread runs within a process
    and can execute any program code loaded in that process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，程序按顺序执行指令，一次处理一个任务。但如果程序需要并行执行两个或更多任务怎么办？例如，假设一个程序需要在执行长期计算的同时更新用户界面，也许是为了显示进度条。如果程序是完全顺序执行的，那么一旦开始计算，用户界面就会被忽视，因为分配给程序的
    CPU 时间必须被用在其他地方。期望的行为是，在计算运行的同时更新 UI——这两个任务需要并行发生。操作系统通过 *执行线程*，或简称 *线程*，提供了这种能力。线程是进程内可调度的执行单元。线程在进程内运行，并且可以执行加载到该进程中的任何程序代码。
- en: The code run by a thread typically encompasses a particular task that a program
    wishes to accomplish. Since threads belong to a process, they share an address
    space, code, and other resources with all the other threads in that process. A
    process begins with one thread and may create other threads as needed when work
    needs to be handled in parallel. Each thread has an identifier called a *thread
    ID*, or *TID*. The kernel also creates threads to manage its work. [Figure 10-7](ch10.xhtml#ch10fig7)
    illustrates the relationship between threads, processes, and the kernel.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 线程执行的代码通常包括程序希望完成的特定任务。由于线程属于进程，它们与该进程中的其他线程共享地址空间、代码和其他资源。一个进程从一个线程开始，可能会根据需要创建其他线程，以便并行处理工作。每个线程都有一个标识符，称为
    *线程 ID* 或 *TID*。内核也会创建线程来管理其工作。[图 10-7](ch10.xhtml#ch10fig7) 说明了线程、进程和内核之间的关系。
- en: In Windows, threads and processes are distinct object types. A process object
    is a container, and threads belong to a process. In Linux, the distinction is
    more nuanced. The Linux kernel represents both processes and threads using a single
    data type that serves as both a process and a thread. In Linux, a group of threads
    that share an address space and have a common process identifier are considered
    a process; there is no separate process type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，线程和进程是不同的对象类型。进程对象是一个容器，线程属于一个进程。在 Linux 中，这种区分更为微妙。Linux 内核使用单一的数据类型来表示进程和线程，该类型既可以表示进程，也可以表示线程。在
    Linux 中，一组共享地址空间并具有相同进程标识符的线程被视为一个进程；没有单独的进程类型。
- en: '![image](../images/fig10-7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-7.jpg)'
- en: '*Figure 10-7: Threads belong to user mode processes or to the kernel.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：线程属于用户模式进程或内核。*'
- en: The Linux terminology used to refer to the identifiers for processes and threads
    can be a bit confusing. In user mode, a process has a process ID (PID) and a thread
    has a thread ID (TID). This is just like Windows. However, the Linux kernel refers
    to the ID of a thread as a PID and the ID of a process as a *thread group identifier
    (TGID)*!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中用于表示进程和线程标识符的术语可能会让人有些困惑。在用户模式下，进程有进程 ID（PID），线程有线程 ID（TID）。这与 Windows
    类似。然而，Linux 内核将线程的 ID 称为 PID，而将进程的 ID 称为 *线程组标识符（TGID）*！
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #21](ch10.xhtml#proj21) on [page 220](ch10.xhtml#page_220),
    where you can create your own thread*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #21](ch10.xhtml#proj21) 以及 [第 220 页](ch10.xhtml#page_220)，在那里你可以创建自己的线程*。'
- en: What does it really mean for multiple threads to run in parallel? Let’s say
    your computer has 10 processes running, and each process has 4 threads. That’s
    40 threads in user mode alone! We say that threads run in parallel, but can all
    40 threads really run at the same time? No, not unless your computer has 40 processor
    cores, which it probably doesn’t. Each processor core can only run one thread
    at a time, so the number of cores in a device determines how many threads can
    run at once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程并行运行到底意味着什么呢？假设你的计算机有10个进程在运行，每个进程有4个线程。仅用户模式下就有40个线程在运行！我们说线程是并行运行的，但40个线程真的能够同时运行吗？不，除非你的计算机有40个处理器核心，而这通常不可能。每个处理器核心一次只能运行一个线程，因此设备中的核心数量决定了可以同时运行多少个线程。
- en: '**PHYSICAL AND LOGICAL CORES**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理核心与逻辑核心**'
- en: Not all cores are equally capable of parallelism. A *physical core* is a hardware
    implementation of a core within a CPU. *Logical cores* represent the ability of
    a single physical core to run multiple threads at once (one thread per logical
    core). Intel refers to this capability as *hyper-threading*. As an example, the
    computer I’m using to write this book has two physical cores, each with two logical
    cores, for a total of four logical cores. This means that my computer can run
    four threads at once, although logical cores cannot achieve the full parallelism
    of physical cores.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有核心都具备相同的并行能力。*物理核心*是CPU内部核心的硬件实现。*逻辑核心*表示一个物理核心能够同时运行多个线程的能力（每个逻辑核心运行一个线程）。英特尔称这种能力为*超线程技术*。举个例子，我现在用来写这本书的计算机有两个物理核心，每个物理核心有两个逻辑核心，总共有四个逻辑核心。这意味着我的计算机可以同时运行四个线程，尽管逻辑核心无法实现物理核心的完全并行性。
- en: 'So if we have 40 threads that need to run, but only 4 cores, what happens?
    The operating system implements a *scheduler*, a software component that’s responsible
    for ensuring that threads each get their turn to run. Different approaches are
    used across operating systems to implement scheduling, but the fundamental goal
    is the same: give threads time to run. A thread gets a short period of time to
    run (known as a *quantum*), then the thread is suspended to allow another thread
    to run. Later, the first thread is scheduled again, and it picks up where it left
    off. This is mostly hidden from the thread’s code and the developer who wrote
    the application. From the perspective of the thread’s code, it’s running continuously,
    and developers write their multithreaded applications as if all their threads
    were running continuously in parallel.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有40个线程需要运行，但只有4个核心，会发生什么？操作系统实现了一个*调度器*，这是一个负责确保每个线程都能轮流运行的软件组件。操作系统采用不同的方法来实现调度，但根本目标是相同的：给线程分配运行的时间。每个线程会获得一个短暂的运行时间（称为*时间片*），然后线程会被挂起，以便让另一个线程运行。之后，第一个线程会被重新调度，并从它中断的地方继续执行。这一过程大部分对线程的代码以及编写应用程序的开发者是隐藏的。从线程代码的角度来看，它是连续运行的，开发者在编写多线程应用时，通常认为所有线程都是在并行运行的。
- en: '**Virtual Memory**'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟内存**'
- en: Operating systems support multiple running processes, each of which need to
    use memory. Most of the time, one process does not need to read or write to the
    memory of another process, and in fact, it’s generally undesirable. We don’t want
    a misbehaving process stealing data or overwriting data in another process or,
    worse, in the kernel. Additionally, developers don’t want their process’s address
    space to become fragmented from the memory usage of other processes. For these
    reasons, operating systems do not grant user mode processes access to physical
    memory, and instead each process is presented with *virtual memory*—an abstraction
    that gives each process its own large, private address space.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统支持多个正在运行的进程，每个进程都需要使用内存。大多数情况下，一个进程不需要读写另一个进程的内存，事实上，这通常是不希望发生的。我们不希望一个有问题的进程窃取或覆盖另一个进程的数据，甚至更糟糕的是，覆盖内核中的数据。此外，开发者也不希望他们进程的地址空间因为其他进程的内存使用而变得碎片化。基于这些原因，操作系统并不允许用户模式进程访问物理内存，而是为每个进程提供了*虚拟内存*——这一抽象概念为每个进程提供了一个独立且庞大的私有地址空间。
- en: In [Chapter 7](ch07.xhtml), we covered memory addressing in which each physical
    byte in hardware is assigned an address. Such hardware memory addresses are called
    *physical addresses*. These addresses are typically hidden from user mode processes.
    Operating systems instead present processes with *virtual memory*, where each
    address is a *virtual address*. Each process is given its own virtual memory space
    to work in. To an individual process, memory appears as a large range of addresses.
    When a process writes to a certain virtual address, that address does not directly
    refer to a hardware memory location. The virtual address is translated to a physical
    address when needed, as shown in [Figure 10-8](ch10.xhtml#ch10fig8), but the details
    of this translation are hidden from the process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml)中，我们讲解了内存寻址，其中硬件中的每个物理字节都被分配了一个地址。这些硬件内存地址被称为*物理地址*。这些地址通常对用户模式进程是隐藏的。操作系统则向进程呈现*虚拟内存*，每个地址都是一个*虚拟地址*。每个进程都被分配了自己的虚拟内存空间来工作。对单个进程来说，内存表现为一个很大的地址范围。当一个进程写入某个虚拟地址时，这个地址并不直接指向硬件内存位置。虚拟地址在需要时会被转换为物理地址，如[图10-8](ch10.xhtml#ch10fig8)所示，但这种转换的细节对进程是隐藏的。
- en: The advantage of this approach is that each process is given a large, private
    range of virtual memory addresses that it can work with. In general, each process
    on a system is presented the *same* range of memory addresses. For example, each
    process might be given 2GB of virtual address space, from address 0x0000000 to
    0x7FFFFFFF. This might seem problematic; what happens when two programs try to
    use the same memory address? Can one program overwrite or read another program’s
    data? Thanks to virtual addressing, this isn’t a problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，每个进程都被分配了一个大型、私有的虚拟内存地址范围来使用。通常，系统中的每个进程都会呈现*相同*的内存地址范围。例如，每个进程可能会被分配2GB的虚拟地址空间，从地址0x0000000到0x7FFFFFFF。这看起来可能会有问题；当两个程序尝试使用相同的内存地址时会发生什么？一个程序能否覆盖或读取另一个程序的数据？多亏了虚拟地址，这并不是问题。
- en: The same virtual address for multiple programs maps to different physical addresses,
    so there’s no chance of one program accidentally accessing another’s data in memory.
    This means that the data stored at a certain virtual address is different across
    different processes—the virtual addresses may be the same, but the data stored
    there differs. That said, mechanisms are in place for programs to share memory
    if they need to. In older operating systems, memory space wasn’t so cleanly divided,
    leading to abundant opportunities for programs to corrupt memory in other programs
    or even in the operating system. Fortunately, all modern operating systems ensure
    separation of memory between processes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多个程序的相同虚拟地址映射到不同的物理地址，因此不会发生一个程序意外访问另一个程序数据的情况。这意味着，在不同进程中，存储在某个虚拟地址处的数据是不同的——虚拟地址可能相同，但存储的数据不同。也就是说，若程序需要共享内存，是有机制支持的。在较旧的操作系统中，内存空间并没有如此清晰的划分，这导致了程序在其他程序甚至操作系统中的内存损坏的机会。幸运的是，所有现代操作系统都确保了进程之间内存的隔离。
- en: '![image](../images/fig10-8.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-8.jpg)'
- en: '*Figure 10-8: Virtual address space for each process is mapped to physical
    memory*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：每个进程的虚拟地址空间映射到物理内存*'
- en: It’s important to understand that although the address range of a process may
    be 2GB in size (for example), that doesn’t mean that all 2GB of virtual memory
    is immediately available for the process to use. Only a subset of those addresses
    is backed by physical memory. Think back to the projects you performed in [Chapters
    8](ch09.xhtml) and [9](ch09.xhtml); those were actually virtual memory addresses
    that you were examining, not physical ones.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，尽管一个进程的地址范围可能是2GB（例如），但这并不意味着所有2GB的虚拟内存都会立即可供进程使用。只有其中一部分地址由物理内存支持。回想一下你在[第8章](ch09.xhtml)和[第9章](ch09.xhtml)中进行的项目；你当时实际上是在检查虚拟内存地址，而不是物理地址。
- en: The kernel has a separate virtual address space to work in with a range of addresses
    that’s distinct from the address range assigned to user mode processes. Unlike
    user mode address space, kernel address space is shared by all code running in
    kernel mode. That means that any code running in kernel mode has access to everything
    in the kernel address space. This also gives such code the opportunity to modify
    the contents of any kernel memory. This reinforces the idea that code that runs
    in kernel mode must be trusted!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有一个单独的虚拟地址空间，用来处理一个与分配给用户模式进程的地址范围不同的地址范围。与用户模式地址空间不同，内核地址空间由所有在内核模式下运行的代码共享。这意味着任何在内核模式下运行的代码都可以访问内核地址空间中的所有内容。这也使得这些代码有机会修改任何内核内存的内容。这加强了一个观点，即在内核模式下运行的代码必须是值得信任的！
- en: So how is virtual address space divided between user mode and kernel mode? Let’s
    look at 32-bit operating systems. As discussed in [Chapter 7](ch07.xhtml), for
    a 32-bit system, memory addresses are represented as 32-bit numbers, which means
    4GB of address space in total. This address space’s range of addresses must be
    split between kernel mode and user mode. For a 4GB address space, both Windows
    and Linux allow for a split of either 2GB user/2GB kernel or 3GB user/1GB kernel,
    based on a configuration setting. [Figure 10-9](ch10.xhtml#ch10fig9) illustrates
    an even 2GB split of virtual memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么虚拟地址空间是如何在用户模式和内核模式之间划分的呢？让我们以32位操作系统为例。如[第7章](ch07.xhtml)所述，对于32位系统，内存地址被表示为32位数字，这意味着总共4GB的地址空间。这个地址空间的地址范围必须在内核模式和用户模式之间进行划分。对于4GB的地址空间，Windows和Linux都允许通过配置设置进行2GB用户/2GB内核或3GB用户/1GB内核的划分。[图10-9](ch10.xhtml#ch10fig9)展示了虚拟内存的均等2GB划分。
- en: '![image](../images/fig10-9.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-9.jpg)'
- en: '*Figure 10-9: Virtual address space on a 32-bit system with an even 2GB/2GB
    split*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：32位系统上虚拟地址空间的2GB/2GB均等划分*'
- en: Keep in mind that we’re strictly concerned with *virtual* addresses here. A
    32-bit system has 4GB of virtual address space regardless of how much *physical*
    memory it has. Let’s say a computer only has 1GB of RAM; it still has 4GB of virtual
    address space under a 32-bit OS. Recall that a virtual address range doesn’t represent
    mapped physical memory, only a range where physical memory *can be* mapped. That
    said, it’s certainly possible for the kernel and all running processes to request
    more bytes of virtual memory than the total size of RAM. In that situation, the
    operating system can move bytes of memory to secondary storage to make room in
    RAM for newly requested memory, a process known as *paging*. Typically, the least
    used memory gets paged first so that actively used memory can remain in RAM. When
    the paged memory is needed, the OS must load it back into RAM. Paging allows for
    greater virtual memory usage, at the cost of a performance hit incurred while
    bytes are moved to and from secondary storage. Keep in mind that secondary storage
    is significantly slower than RAM.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们这里只关注的是*虚拟*地址。无论物理内存有多少，32位系统的虚拟地址空间始终为4GB。假设一台计算机只有1GB的RAM，它在32位操作系统下仍然有4GB的虚拟地址空间。回想一下，虚拟地址范围并不代表映射的物理内存，它仅仅是物理内存*可以被*映射的范围。也就是说，内核和所有运行中的进程完全可以请求更多的虚拟内存字节，超过RAM的总大小。在这种情况下，操作系统可以将内存字节移动到辅助存储中，以腾出RAM空间供新请求的内存使用，这个过程被称为*分页*。通常，最少使用的内存首先会被分页，以便活动内存可以保持在RAM中。当需要分页的内存时，操作系统必须将其重新加载到RAM中。分页使得可以使用更大的虚拟内存，但代价是当字节在辅助存储和RAM之间移动时，会造成性能上的损失。请记住，辅助存储的速度远远低于RAM。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #22](ch10.xhtml#proj22) on [page 222](ch10.xhtml#page_222),
    where you can examine virtual memory*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目#22](ch10.xhtml#proj22)，在[第222页](ch10.xhtml#page_222)上，您可以查看虚拟内存的相关内容*。'
- en: With the arrival of 64-bit processors and operating systems came the potential
    for much, much larger address spaces. If we represented memory addresses with
    a full 64 bits, virtual address space would be about 4 *billon* times the size
    of 32-bit address space! However, such a large address space isn’t needed today,
    so 64-bit operating systems use a smaller number of bits to represent addresses.
    Different 64-bit operating systems on different processors use varying numbers
    of bits to represent an address. Both 64-bit Linux and 64-bit Windows support
    48-bit addresses, which translates to 256TB of virtual address space, about 65,000
    times the size of 32-bit address space—more than enough space for today’s typical
    application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着64位处理器和操作系统的到来，出现了更大地址空间的潜力。如果我们用完整的64位表示内存地址，虚拟地址空间将是32位地址空间的约4 *billion*倍！然而，今天并不需要如此大的地址空间，因此64位操作系统使用较少的位数来表示地址。不同的64位操作系统在不同的处理器上使用不同的位数来表示地址。64位Linux和64位Windows都支持48位地址，这意味着虚拟地址空间为256TB，约为32位地址空间的65,000倍——这对于今天的典型应用来说空间已经足够大了。
- en: '**Application Programming Interface (API)**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用程序编程接口（API）**'
- en: When most people think of an operating system, they think of the user interface,
    the shell. The shell is what people see, and it influences how people perceive
    the system. For example, a Windows user typically thinks of Windows as the taskbar,
    Start menu, desktop, and so forth. However, the user interface is actually only
    a small part of the operating system’s code, and it’s just an interface, the point
    where the system and the user meet. From the perspective of an application (or
    a software developer), interacting with the operating system isn’t defined by
    the UI, but by the operating system’s *application programming interface (API)*.
    APIs are not only for operating systems; any software that wants to allow a programmatic
    means of interaction can provide an API, but our focus here is specifically on
    OS APIs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数人想到操作系统时，他们会想到用户界面，即Shell。Shell是人们看到的部分，它影响人们如何看待系统。例如，Windows用户通常认为Windows就是任务栏、开始菜单、桌面等等。然而，用户界面实际上只是操作系统代码的一小部分，它只是一个界面，系统和用户的接触点。从应用程序（或软件开发人员）的角度来看，与操作系统的交互并不是由UI定义的，而是由操作系统的*应用程序编程接口（API）*定义的。API不仅仅适用于操作系统；任何希望提供程序化交互方式的软件都可以提供API，但我们这里的重点是操作系统API。
- en: An OS API is a specification, defined in source code and described in documentation,
    that details how a program should interact with the OS. A typical OS API includes
    a list of functions (including their names, inputs, and outputs) and data structures
    needed for interacting with the operating system. Software libraries included
    with the operating system provide the implementation of the API specification.
    Software developers speak of “calling” or “using” an API as a shorthand way of
    saying that their code is invoking one of the functions specified in the API (and
    implemented in a software library).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统API是一种规范，定义在源代码中并在文档中描述，详细说明了程序应该如何与操作系统交互。一个典型的操作系统API包括一系列函数（包括其名称、输入和输出）以及与操作系统交互所需的数据结构。操作系统随附的软件库提供了API规范的实现。软件开发人员通常将“调用”或“使用”API作为一种简便的说法，表示他们的代码正在调用API中指定的某个函数（并由软件库实现）。
- en: In the same way that a UI defines an OS’s “personality” for users, the API defines
    the OS’s personality for applications. [Figure 10-10](ch10.xhtml#ch10fig10) illustrates
    how users and applications interact with an operating system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用户界面为用户定义了操作系统的“个性”一样，API为应用程序定义了操作系统的个性。[图10-10](ch10.xhtml#ch10fig10)展示了用户和应用程序如何与操作系统交互。
- en: '![image](../images/fig10-10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-10.jpg)'
- en: '*Figure 10-10: Operating system interfaces: UI for users; API for applications*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：操作系统接口：用户的UI；应用程序的API*'
- en: As seen in [Figure 10-10](ch10.xhtml#ch10fig10), users interact with the operating
    system user interface, also known as the shell. The shell translates the user’s
    commands into API calls. The API then invokes internal operating system code to
    perform the requested action. Applications don’t need to go through the UI; they
    simply call the API directly. From this point of view, the shell interacts with
    the operating system API just like any other application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 10-10](ch10.xhtml#ch10fig10) 所示，用户通过操作系统用户界面与操作系统进行交互，这就是 Shell。Shell 将用户的命令转化为
    API 调用。API 然后调用操作系统的内部代码来执行请求的操作。应用程序不需要通过用户界面；它们只需要直接调用 API。从这个角度来看，Shell 与操作系统的
    API 交互方式和其他应用程序一样。
- en: Let’s look at an example of interfacing with operating systems via an API. Creating
    a file is a common capability of operating systems, something that both users
    and applications need to do. Graphical shells and command line shells provide
    simple ways for users to create files. However, an application doesn’t need to
    go through the GUI or CLI to create a file. Let’s examine how an application can
    go about creating a file programmatically.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个通过 API 与操作系统接口的示例。创建文件是操作系统的常见功能，用户和应用程序都需要进行此操作。图形化 Shell 和命令行 Shell
    提供了简单的方式供用户创建文件。然而，应用程序不需要通过图形用户界面（GUI）或命令行界面（CLI）来创建文件。让我们探讨一下应用程序如何通过编程方式创建文件。
- en: For Unix or Linux systems, you can use an API function called `open` to create
    a file. The following C language example uses the `open` function to create a
    new file called *hello.txt*. The `O_WRONLY` flag indicates a write-only operation,
    and `O_CREAT` indicates that a file is to be created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unix 或 Linux 系统，你可以使用一个名为`open`的 API 函数来创建文件。以下 C 语言示例使用 `open` 函数创建一个名为
    *hello.txt* 的新文件。`O_WRONLY` 标志表示只写操作，`O_CREAT` 表示要创建一个文件。
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The same thing can be accomplished on Windows using the `CreateFileA` API function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，可以使用 `CreateFileA` API 函数来完成相同的操作：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both of these examples use the C programming language. Operating systems are
    commonly written in C, so their APIs tend to be naturally suited for use in a
    C program. For programs written in other languages, the OS API must still be called
    when the program runs, but the programming language wraps that API call in its
    own syntax, hiding the details of the API from the developer. This allows for
    code that’s portable across operating systems. Even the C language does this,
    providing a standard library of functions that work on any operating system. These
    functions, in turn, must make an OS-specific API call when they run. Consider
    again the example of creating a file; in C we can instead use the `fopen` function
    as shown in the following code. This function is part of the C language’s standard
    library and works on any operating system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都使用了 C 编程语言。操作系统通常使用 C 语言编写，因此它们的 API 天然适用于 C 程序。在其他语言编写的程序中，当程序运行时，仍然需要调用操作系统的
    API，但是该编程语言会将该 API 调用封装在其自身的语法中，隐藏 API 的细节。这使得代码可以跨操作系统移植。即使是 C 语言也这样做，提供了一组可以在任何操作系统上运行的标准库函数。这些函数反过来必须在运行时调用特定操作系统的
    API。再考虑一下创建文件的例子；在 C 语言中，我们可以使用 `fopen` 函数，如以下代码所示。该函数是 C 语言标准库的一部分，适用于任何操作系统。
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As another example, we can use the following Python code to create a new file.
    This code works on any OS where a Python interpreter is installed. The Python
    interpreter takes care of calling the appropriate OS API on behalf of the application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，我们可以使用以下 Python 代码来创建一个新文件。这段代码可以在任何安装了 Python 解释器的操作系统上运行。Python 解释器会代替应用程序调用适当的操作系统
    API。
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For Unix-like operating systems, the API varies somewhat based on the specific
    flavor of Unix or Linux and the version of the kernel. However, most Unix-like
    operating systems comply with a standard specification, either in full or in part.
    This standard is known as the *Portable Operating System Interface (POSIX)*, and
    it provides a standard not only for the OS API, but also for the shell’s behavior
    and included utilities. POSIX provides a baseline for Unix-like operating systems,
    but a modern Unix-like OS often has its own API. *Cocoa* is Apple’s API for macOS,
    and there is a similar API for iOS known as *Cocoa Touch*. Android also has its
    own set of programming interfaces, collectively known as the *Android Platform
    APIs*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类Unix操作系统，API会根据具体的Unix或Linux版本以及内核的版本有所不同。然而，大多数类Unix操作系统都遵循一个标准规范，无论是完全遵守还是部分遵守。这个标准被称为*可移植操作系统接口（POSIX）*，它不仅为操作系统API提供标准，也为Shell的行为和包含的工具提供标准。POSIX为类Unix操作系统提供了基准，但现代类Unix操作系统通常有自己的API。*Cocoa*是Apple为macOS提供的API，iOS也有一个类似的API，称为*Cocoa
    Touch*。Android也有自己的编程接口，统称为*Android平台API*。
- en: The other major OS family, Windows, has its own API. The *Windows API* has grown
    and expanded over time. The original version of the Windows API was a 16-bit version
    now known as *Win16*. When Windows was updated to a 32-bit operating system in
    the 1990s, a 32-bit version of the API, *Win32*, was released. Now that Windows
    is a 64-bit operating system, there is a corresponding *Win64* API. Microsoft
    also introduced a new API in Windows 10, the *Universal Windows Platform (UWP)*,
    with a goal of making app development consistent across various types of devices
    that run Windows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一大操作系统家族Windows有其自己的API。*Windows API*随着时间的发展不断增长和扩展。Windows API的最初版本是一个16位版本，现在被称为*Win16*。当Windows在1990年代更新为32位操作系统时，发布了32位版本的API，即*Win32*。现在Windows已经是64位操作系统，对应的API是*Win64*。微软还在Windows
    10中推出了一个新的API，*通用Windows平台（UWP）*，旨在使Windows上运行的各种类型设备的应用开发保持一致。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #23](ch10.xhtml#proj23) on [page 224](ch10.xhtml#page_224),
    where you can try interacting with the Linux operating system API*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #23](ch10.xhtml#proj23)，位于[第224页](ch10.xhtml#page_224)，在那里你可以尝试与Linux操作系统API互动。*'
- en: '**The User Mode Bubble and System Calls**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户模式泡泡与系统调用**'
- en: As mentioned earlier, code that runs in user mode has limited access to the
    system. So what are some of the things that user mode code *can* do? It can read
    and write to its own virtual memory, and it can perform mathematical and logical
    operations. It can control the program flow of its own code. On the other hand,
    code running in user mode *cannot* access physical memory addresses, including
    addresses used for memory-mapped I/O. That means that it cannot, on its own, print
    text to a console window, get input from the keyboard, draw graphics to the screen,
    play a sound, receive touchscreen input, communicate over a network, or read a
    file from a hard drive! I like to say that “user mode code runs in a bubble” ([Figure
    10-11](ch10.xhtml#ch10fig11)). It cannot interact with the outside world, at least
    not without some help. Another way of stating this is that user mode code cannot
    directly perform I/O. The practical effect of this is that code running in user
    mode can do useful work, but it cannot share the results of that work without
    assistance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户模式下运行的代码对系统的访问权限是有限的。那么，用户模式代码*能做*什么呢？它可以读写自己的虚拟内存，并可以执行数学和逻辑运算。它可以控制自己代码的程序流。另一方面，运行在用户模式下的代码*不能*访问物理内存地址，包括用于内存映射I/O的地址。这意味着它无法自行将文本打印到控制台窗口，获取键盘输入，绘制屏幕上的图形，播放声音，接收触摸屏输入，通过网络通信，或从硬盘读取文件！我喜欢说“用户模式代码运行在一个泡泡中”([图
    10-11](ch10.xhtml#ch10fig11))。它无法与外部世界互动，至少没有一些帮助的话是做不到的。另一种说法是，用户模式代码不能直接执行I/O操作。实际上，这意味着运行在用户模式下的代码可以做有用的工作，但无法在没有帮助的情况下共享这些工作成果。
- en: '![image](../images/fig10-11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-11.jpg)'
- en: '*Figure 10-11: A process runs in a user mode bubble. It can do math, perform
    logic, access virtual memory, and control program flow, but it cannot interact
    directly with the outside world.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：一个进程运行在用户模式泡泡中。它可以进行数学运算、执行逻辑、访问虚拟内存并控制程序流，但无法直接与外部世界互动。*'
- en: 'You may wonder how it is that user mode applications interact with users. Of
    course, applications are somehow able to interact with the outside world, but
    how is that accomplished? The answer is that user mode code has one other important
    capability: it can request that kernel mode code perform work on its behalf. When
    user mode code requests that kernel mode code perform a privileged operation on
    its behalf, this is known as a *system call*, as illustrated in [Figure 10-12](ch10.xhtml#ch10fig12).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，用户模式应用程序是如何与用户进行交互的。自然，应用程序以某种方式能够与外部世界交互，但这是如何实现的呢？答案是，用户模式代码有一个其他重要的能力：它可以请求内核模式代码代表它执行工作。当用户模式代码请求内核模式代码代表它执行特权操作时，这被称为*系统调用*，如[图10-12](ch10.xhtml#ch10fig12)所示。
- en: '![image](../images/fig10-12.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-12.jpg)'
- en: '*Figure 10-12: A user mode process can interact with the outside world with
    help from the kernel by making a system call.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-12：用户模式进程可以通过发出系统调用，借助内核与外部世界交互。*'
- en: For example, if user mode code needs to read from a file, it makes a system
    call to request that the kernel read certain bytes from a certain file. The kernel,
    working in conjunction with a storage device driver, performs the necessary I/O
    to read the file, and then provides the requested data back to the user mode process.
    This is illustrated in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户模式代码需要从文件中读取数据，它会发出系统调用，请求内核从某个文件中读取特定的字节。内核与存储设备驱动程序协同工作，执行必要的I/O操作以读取文件，然后将请求的数据返回给用户模式进程。这如[图10-13](ch10.xhtml#ch10fig13)所示。
- en: '![image](../images/fig10-13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-13.jpg)'
- en: '*Figure 10-13: The kernel acts as an intermediary for user mode code that needs
    to access hardware resources, such as secondary storage.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：内核作为中介，帮助用户模式代码访问硬件资源，如二级存储。*'
- en: The user mode code doesn’t need to know anything about the physical storage
    device or any related device drivers. The kernel provides an abstraction, encapsulating
    the details and allowing the user mode code to simply get things done. The example
    API functions we covered earlier, `open` and `CreateFileA`, work this way behind
    the scenes, using system calls to request privileged operations. Of course, there
    are constraints on what the kernel will allow. A user mode process cannot, for
    example, read a file that it does not have access to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式代码不需要了解任何关于物理存储设备或相关设备驱动程序的信息。内核提供了一个抽象，封装了细节，让用户模式代码可以简单地完成任务。我们之前提到的示例API函数`open`和`CreateFileA`在幕后就是这样工作的，它们通过系统调用请求特权操作。当然，内核会对允许的操作有所限制。例如，用户模式进程不能读取没有访问权限的文件。
- en: CPUs provide instructions specifically to facilitate system calls. On ARM processors,
    the `SVC` instruction (formerly `SWI`) is used, and it’s referred to as a *supervisor
    call*. On x86 processors, the `SYSCALL` and `SYSENTER` instructions are available
    for this purpose. Both Linux and Windows implement a large number of system calls,
    and each call is identified with a unique number. For example, on Linux for ARM,
    the `write` system call (which writes to a file) is number 4\. To make a system
    call, a program needs to load a certain processor register with the desired system
    call number, put any additional parameters in other specific registers, and then
    execute the system call instruction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CPU提供了专门的指令来简化系统调用。在ARM处理器上，使用`SVC`指令（以前称为`SWI`），它被称为*监控调用*。在x86处理器上，提供了`SYSCALL`和`SYSENTER`指令来实现这一目的。Linux和Windows都实现了大量的系统调用，每个调用都有一个唯一的编号。例如，在Linux的ARM版本中，`write`系统调用（用于写入文件）的编号是4。要进行系统调用，程序需要将所需的系统调用编号加载到某个处理器寄存器中，将任何附加参数放入其他特定的寄存器，然后执行系统调用指令。
- en: Although software developers can make system calls directly in machine code
    or assembly language, fortunately this isn’t needed in most cases. Operating systems
    and high-level programming languages provide capabilities for making system calls
    in a natural way for programmers, usually through the OS API or the language’s
    standard library. Programmers simply write code to perform an action and may not
    even realize that behind the scenes a system call is being made.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管软件开发人员可以直接在机器代码或汇编语言中进行系统调用，但幸运的是，在大多数情况下并不需要这么做。操作系统和高级编程语言提供了以自然的方式进行系统调用的能力，通常通过操作系统API或语言的标准库来实现。程序员只需编写代码来执行某个操作，可能甚至没有意识到在幕后正在进行系统调用。
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #24](ch10.xhtml#proj24) on [page 226](ch10.xhtml#page_226),
    where you can observe system calls made from programs*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #24](ch10.xhtml#proj24)，位于 [第 226 页](ch10.xhtml#page_226)，你可以在那里观察从程序中发起的系统调用*。'
- en: '**APIs and System Calls**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**API 和系统调用**'
- en: Earlier we covered the topic of an operating system’s API, and we just looked
    at system calls. How does an OS API differ from a system call? The two are related,
    but they are not equivalent. System calls define a mechanism for user mode code
    to request kernel mode services. The API describes a way for applications to interact
    with the operating system, regardless of whether kernel mode code is invoked.
    Some API functions make system calls, whereas other API functions do not require
    a system call. The specifics of this depend on the operating system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了操作系统的 API 主题，并且刚刚看过系统调用。操作系统 API 和系统调用有什么不同？二者是相关的，但并不等同。系统调用定义了一种机制，允许用户模式代码请求内核模式服务。API
    描述了应用程序如何与操作系统交互，无论是否调用了内核模式代码。有些 API 函数会发起系统调用，而另一些 API 函数则不需要系统调用。这取决于操作系统的具体实现。
- en: Let’s first look at Linux. If we restrict our definition of Linux to the kernel,
    we could say that the Linux API is effectively a specification for using Linux
    system calls, since system calls are the programmatic interface to the kernel.
    However, operating systems based on Linux are more than the kernel. For example,
    consider Android, which uses the Linux kernel. Android has its own set of programming
    interfaces, the Android Platform APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来看一下 Linux。如果我们将 Linux 的定义限制在内核层面，那么可以说 Linux API 实际上是使用 Linux 系统调用的规范，因为系统调用是与内核交互的编程接口。然而，基于
    Linux 的操作系统不仅仅是内核。例如，考虑使用 Linux 内核的 Android。Android 有自己的一套编程接口，即 Android 平台 API。
- en: In the case of Microsoft Windows, the Windows NT kernel provides a set of system
    calls, made available through an interface known as the Native API. Application
    developers rarely use the Native API directly; it’s intended for use by operating
    system components. Instead, developers use the Windows API, which acts as a wrapper
    around the Native API. However, not all of the Windows API functions require a
    system call. Let’s look at a couple of examples from the Windows API. The Windows
    API function `CreateFileW` creates or opens a file. It’s a wrapper around the
    Native API `NtCreateFile`, which makes a system call to the kernel. In contrast,
    the Windows API function `PathFindFileNameW` (which finds a filename in a path)
    does not interact with the Native API or make any system calls. Creating a file
    requires the help of the kernel, whereas finding a filename in a path string only
    requires virtual memory access, something that can happen in user mode.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Microsoft Windows 中，Windows NT 内核提供了一组系统调用，通过一种称为原生 API 的接口提供。应用程序开发人员很少直接使用原生
    API；它主要供操作系统组件使用。相反，开发人员使用 Windows API，它是原生 API 的封装。然而，并非所有 Windows API 函数都需要系统调用。我们来看看
    Windows API 的几个例子。Windows API 函数`CreateFileW`用于创建或打开文件。它是原生 API `NtCreateFile`
    的封装，后者会向内核发起系统调用。相比之下，Windows API 函数`PathFindFileNameW`（用于在路径中查找文件名）不与原生 API 交互，也不发起任何系统调用。创建文件需要内核的帮助，而在路径字符串中查找文件名只需要虚拟内存访问，这可以在用户模式下完成。
- en: To recap, an operating system API describes the programmatic interface for the
    OS. System calls provide a mechanism for user mode code to request privileged
    kernel mode operations. Certain API functions rely on system calls, whereas others
    do not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，操作系统 API 描述了操作系统的编程接口。系统调用提供了一种机制，允许用户模式的代码请求特权的内核模式操作。某些 API 函数依赖于系统调用，而另一些则不依赖。
- en: '**Operating System Software Libraries**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作系统软件库**'
- en: 'As mentioned earlier, an operating system API describes the programmatic interface
    to an operating system. Although a technical interface description is helpful
    to a programmer, when a program runs, it needs a concrete method of invoking the
    API. This is accomplished with software libraries. An *operating system’s software
    library* is a collection of code, included with the OS, that provides an implementation
    of the OS API. That is, the library contains code that performs the operations
    described in the API specification. In [Chapter 9](ch09.xhtml), we talked about
    the libraries available for programming languages: both the language’s standard
    library and additional libraries maintained by the community of developers who
    work in that language. The software libraries we’re discussing here are similar;
    the only difference is that these libraries are part of operating systems.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，操作系统API描述了与操作系统交互的程序接口。尽管技术接口描述对程序员有帮助，但当程序运行时，它需要一个具体的方法来调用API。这是通过软件库来实现的。*操作系统的软件库*是操作系统随附的代码集合，提供操作系统API的实现。也就是说，库包含执行API规范中描述的操作的代码。在[第9章](ch09.xhtml)中，我们讨论了编程语言的库：包括语言的标准库以及由使用该语言的开发者社区维护的附加库。我们在这里讨论的软件库类似；唯一的区别是这些库是操作系统的一部分。
- en: An OS library is similar to an executable program; it’s a file containing bytes
    of machine code. However, it typically has no entry point and therefore usually
    can’t run on its own. Instead, the library *exports* (makes available) a set of
    functions that can be used by programs. A program that makes use of a software
    library *imports* functions from that library and is said to *link* to that library.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统库类似于可执行程序；它是一个包含机器码字节的文件。然而，它通常没有入口点，因此通常无法独立运行。相反，库*导出*（使可用）一组可以被程序使用的函数。使用软件库的程序*导入*该库中的函数，并被称为*链接*到该库。
- en: Operating systems include a set of library files that export the various functions
    defined by the API. Some of these functions are just wrappers that immediately
    make a kernel system call. Other functions are fully implemented in user mode
    code contained in the library file itself. Others are somewhere in-between, implementing
    some logic in user mode while also making one or more system calls, as shown in
    [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统包含一组库文件，导出API定义的各种函数。这些函数中的一些只是包装器，立即执行内核系统调用。其他函数则完全在用户模式代码中实现，并包含在库文件本身中。还有一些介于两者之间，在用户模式中实现一些逻辑，同时也进行一个或多个系统调用，如[图10-14](ch10.xhtml#ch10fig14)所示。
- en: In a typical Linux distribution, many of the available Linux kernel system calls
    are made available through the *GNU C Library* (or `glibc`). This library also
    includes the C programming language’s standard library, including functions that
    do not require a system call. The primary `glibc` file is typically named something
    like *libc.so.6*, where *so* means *shared object* and *6* indicates the version.
    Using this library, a software developer working in C or C++ can easily make use
    of capabilities provided by the Linux kernel and by the C runtime library. Given
    the ubiquity of this library in most Linux distributions, it’s reasonable to consider
    the functions in `glibc` as part of the standard Linux API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Linux发行版中，许多可用的Linux内核系统调用通过*GNU C库*（或`glibc`）提供。这个库还包括C编程语言的标准库，其中包括不需要系统调用的函数。主要的`glibc`文件通常命名为*libc.so.6*，其中*so*表示*共享对象*，而*6*表示版本。通过这个库，C或C++开发者可以轻松使用Linux内核和C运行时库提供的功能。鉴于该库在大多数Linux发行版中的普遍存在，可以合理地将`glibc`中的函数视为标准Linux
    API的一部分。
- en: '![image](../images/fig10-14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig10-14.jpg)'
- en: '*Figure 10-14: The operating system API is implemented across a set of libraries.
    Some functions in those libraries make system calls to the kernel; others do not.
    User mode programs interact with the API.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：操作系统API通过一组库来实现。这些库中的一些函数会调用内核的系统调用；而另一些则不会。用户模式程序与API进行交互。*'
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #25](ch10.xhtml#proj25) on [page 227](ch10.xhtml#page_227),
    where you can try the GNU C Library*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目#25](ch10.xhtml#proj25)在[第227页](ch10.xhtml#page_227)，在这里你可以尝试GNU C库*。'
- en: The Microsoft Windows API is fairly extensive; it has grown to include many
    libraries over the years. The three fundamental Windows API library files are
    *kernel32.dll*, *user32.dll*, and *gdi32.dll*. System calls exported from the
    NT kernel are made available to user mode programs through *kernel32.dll*. System
    calls exported from win32k (the windowing and graphics system) are made available
    to user mode programs through *user32.dll* and *gdi32.dll*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Windows API相当广泛，随着时间的推移，它已经包含了许多库。三个基本的Windows API库文件是*kernel32.dll*、*user32.dll*和*gdi32.dll*。通过*kernel32.dll*，NT内核导出的系统调用可以提供给用户模式程序。通过*user32.dll*和*gdi32.dll*，win32k（窗口和图形系统）导出的系统调用可以提供给用户模式程序。
- en: The *dll* extension on these files indicates that these are *dynamic link libraries*,
    similar to shared object (*.so*) files in Linux. That is, the *dll* file extension
    indicates that the file contains shared library code that a process can load and
    run. The *32* suffix in the filename was added as part of the 16-bit to 32-bit
    Windows transition. Today, 64-bit versions of Windows still retain the *32* suffix
    on these files for compatibility reasons. In fact, 64-bit versions of Windows
    include two versions of these files (same name, different directories), one for
    32-bit applications and one for 64-bit applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件上的*dll*扩展名表示它们是*动态链接库*，类似于Linux中的共享对象（*.so*）文件。也就是说，*dll*文件扩展名表示该文件包含共享库代码，进程可以加载并运行。文件名中的*32*后缀是在16位到32位Windows过渡期间添加的。如今，64位版本的Windows仍然在这些文件上保留*32*后缀，以保持兼容性。实际上，64位版本的Windows包括这两个版本的文件（相同的名称，不同的目录），一个用于32位应用程序，一个用于64位应用程序。
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s possible for a program to invoke system calls without going through a
    software library. By setting values in processor registers and issuing a processor-specific
    instruction, such as `SVC` on ARM or `SYSCALL` on x86, a program can directly
    make a system call. However, this requires programming in assembly language, leading
    to source code that won’t work across processor architectures. Furthermore, an
    operating system’s API can include functions that aren’t implemented with a system
    call, so making direct system calls isn’t a replacement for the operating system’s
    software libraries*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序有可能在不通过软件库的情况下调用系统调用。通过设置处理器寄存器中的值并发出特定处理器的指令，例如ARM上的`SVC`或x86上的`SYSCALL`，程序可以直接进行系统调用。然而，这需要用汇编语言进行编程，导致的源代码不能跨处理器架构工作。此外，操作系统的API可能包含一些不是通过系统调用实现的函数，因此直接调用系统调用并不能替代操作系统的软件库。*'
- en: '**WINDOWS SUBSYSTEM FOR LINUX**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows子系统 for Linux**'
- en: The Linux kernel and the Windows NT kernel expose different system calls, and
    their executables are stored in different formats, making software compiled for
    one OS incompatible with the other. However, in 2016, Microsoft announced the
    *Windows Subsystem for Linux (WSL)*, a Windows 10 feature that allows many 64-bit
    Linux programs to run, without modification, on Windows. In the first version
    of WSL, this was accomplished by intercepting system calls made by Linux executables
    and handling them within the NT kernel. A second version of WSL relies on a real
    Linux kernel to handle system calls. This Linux kernel runs in a virtual machine
    alongside the NT kernel. We’ll cover more on virtual machines in [Chapter 13](ch13.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核和Windows NT内核暴露不同的系统调用，并且它们的可执行文件存储在不同的格式中，这使得为一个操作系统编译的软件与另一个操作系统不兼容。然而，在2016年，微软宣布了*Windows子系统
    for Linux (WSL)*，这是一个Windows 10功能，允许许多64位Linux程序在Windows上运行，而无需修改。在WSL的第一个版本中，这是通过拦截Linux可执行文件发出的系统调用并在NT内核中处理它们来实现的。WSL的第二个版本依赖于一个真实的Linux内核来处理系统调用。这个Linux内核在虚拟机中运行，并与NT内核一起运行。我们将在[第13章](ch13.xhtml)中详细介绍虚拟机。
- en: '**Application Binary Interface**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用程序二进制接口**'
- en: Now that we’ve covered the concept of an application programming interface (API)
    and how it relates to system calls and libraries, let’s examine a related concept,
    an ABI. An *application binary interface (ABI)* defines the machine code interface
    to a software library. This is in contrast to the API, which defines a source
    code interface. Generally speaking, an API is consistent across various processor
    families, whereas an ABI varies across processor families. A developer can write
    code that utilizes an operating system API, then compile the code for multiple
    processor types. The source code targets a common API, whereas the compiled code
    targets an architecture-specific ABI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了应用程序编程接口（API）的概念以及它如何与系统调用和库相关联，接下来让我们来探讨一个相关的概念，即ABI。*应用程序二进制接口（ABI）*定义了软件库的机器代码接口。这与API相对，API定义的是源代码接口。一般来说，API在各种处理器系列之间是一致的，而ABI则在处理器系列之间有所不同。开发人员可以编写利用操作系统API的代码，然后将代码编译为多种处理器类型。源代码针对的是一个通用的API，而编译后的代码则针对特定架构的ABI。
- en: Once compiled, the resulting machine code adheres to the ABI for the target
    architecture. This means that at execution time, it’s really the ABI, not the
    API, that defines the interaction between compiled programs and software libraries.
    It’s important that the ABI exposed by OS libraries remains consistent over time.
    Such consistency allows older programs to continue to run on newer releases of
    the operating system without needing to be recompiled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译，生成的机器代码会遵循目标架构的ABI。这意味着在执行时，真正定义已编译程序和软件库之间交互的是ABI，而不是API。操作系统库所暴露的ABI保持一致性非常重要。这种一致性使得较旧的程序能够在操作系统的新版本中继续运行，而无需重新编译。
- en: '**Device Drivers**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设备驱动程序**'
- en: Today’s computers support a wide variety of hardware devices, such as displays,
    keyboards, cameras, and so forth. These devices each implement an interface for
    input/output, allowing the device to communicate with the rest of the system.
    Different device types use different approaches for I/O; a Wi-Fi adapter has very
    different needs from a game controller. Even devices of the same general type
    may implement different I/O approaches. For example, two different models of video
    cards may communicate very differently with the rest of the system. Direct interactions
    with hardware are restricted to code running in kernel mode, but it isn’t reasonable
    to expect an operating system kernel to know how to communicate with every device
    out there. This is where device drivers come in. A *device driver* is software
    that interacts with a hardware device and provides a programmatic interface to
    that hardware.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的计算机支持各种各样的硬件设备，例如显示器、键盘、摄像头等。这些设备各自实现了输入/输出接口，允许设备与系统的其他部分进行通信。不同类型的设备使用不同的方法进行输入/输出；例如，Wi-Fi适配器与游戏控制器的需求差异很大。即使是相同类型的设备，也可能实现不同的输入/输出方法。例如，两种不同型号的显卡与系统的其他部分进行通信的方式可能完全不同。与硬件的直接交互仅限于在内核模式下运行的代码，但不可能指望操作系统内核知道如何与每一种设备通信。这就是设备驱动程序的作用。*设备驱动程序*是与硬件设备交互并为该硬件提供编程接口的软件。
- en: Typically, a device driver is implemented as a *kernel module*, a file containing
    code that the kernel can load and execute in kernel mode. This is needed to allow
    drivers access to hardware. Because of this, device drivers have wide-ranging
    access, similar to the kernel itself, so only trusted drivers should be installed.
    The kernel works in conjunction with device drivers to interact with hardware
    on behalf of code running in user mode. This allows hardware interactions to occur
    without the operating system or applications knowing the details of how to work
    with specific hardware. This is a form of encapsulation. In some cases, drivers
    can execute in user mode (such as those using Microsoft’s User-Mode Driver Framework),
    but such an approach still requires some component in kernel mode, usually provided
    by the operating system, to handle hardware interactions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设备驱动程序作为一个*内核模块*实现，这是一个包含代码的文件，内核可以加载并在内核模式下执行。这是允许驱动程序访问硬件所必需的。因此，设备驱动程序具有广泛的访问权限，类似于内核本身，所以只有受信任的驱动程序应该被安装。内核与设备驱动程序协同工作，代表用户模式下运行的代码与硬件进行交互。这使得硬件交互可以在操作系统或应用程序不了解如何与特定硬件交互的情况下进行。这是一种封装的形式。在某些情况下，驱动程序可以在用户模式下执行（例如使用微软的用户模式驱动程序框架），但这种方法仍然需要内核模式中的某些组件，通常由操作系统提供，用于处理硬件交互。
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #26](ch10.xhtml#proj26) on [page 230](ch10.xhtml#page_230),
    where you can see loaded kernel modules, including device drivers, on Raspberry
    Pi OS*.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #26](ch10.xhtml#proj26)在[第230页](ch10.xhtml#page_230)，在那里你可以查看包括设备驱动程序在内的加载的内核模块，在Raspberry
    Pi OS上。*'
- en: '**Filesystems**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件系统**'
- en: Nearly every computer has some kind of secondary storage, usually a hard disk
    drive (HDD) or a solid-state drive (SSD). Such devices are effectively containers
    of bits that can be read and written, and where data persists even when the system
    is powered down. Storage devices are divided into regions called *partitions*.
    Operating systems implement *filesystems* to organize the data on storage devices
    into files and directories. A partition must be *formatted* with a particular
    filesystem before it can be used by the operating system. Different OSes use different
    filesystems. Linux commonly uses the ext (extended) family of filesystems (ext2,
    ext3, ext4), whereas Windows uses FAT (File Allocation Table) and NTFS (NT File
    System). Some operating systems present storage as a *volume*, a logical abstraction
    built on one or more partitions. In such a system, filesystems reside on a volume
    rather than on a partition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每台计算机都有某种类型的二级存储设备，通常是硬盘驱动器（HDD）或固态硬盘（SSD）。这些设备实际上是可以读取和写入的比特容器，而且即使系统关闭电源，数据依然可以保存。存储设备被划分为称为*分区*的区域。操作系统实现*文件系统*，将存储设备上的数据组织成文件和目录。在分区被操作系统使用之前，必须先用特定的文件系统进行*格式化*。不同的操作系统使用不同的文件系统。Linux通常使用ext（扩展）系列文件系统（ext2、ext3、ext4），而Windows使用FAT（文件分配表）和NTFS（NT文件系统）。一些操作系统将存储呈现为*卷*，这是基于一个或多个分区构建的逻辑抽象。在这种系统中，文件系统位于卷上，而不是分区上。
- en: A *file* is a container of data, and a *directory* (also known as a folder)
    is a container of files or other directories. The contents of a file can be anything;
    the structure of the data stored within the file is determined by the program
    that wrote the file to storage. Unix-like systems organize their directory structure
    as a unified hierarchy of directories. The hierarchy starts at the root, designated
    with a single forward slash (`/`), and all other directories are descendants of
    the root. For example, library files are stored in */usr/lib*, where *usr* is
    a subdirectory of the root, and *lib* is a subdirectory of *usr*. This unified
    hierarchy applies even when there is more than one storage device on the system.
    Additional storage devices are mapped to a location in the directory structure;
    this is known as *mounting* a device. For example, a USB drive could be mounted
    to */mnt/usb1*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件*是数据的容器，*目录*（也称为文件夹）是文件或其他目录的容器。文件的内容可以是任何东西；文件中存储的数据结构由写入文件的程序决定。类Unix系统将其目录结构组织为统一的目录层次结构。该层次结构从根目录开始，根目录用一个斜杠（`/`）表示，所有其他目录都是根目录的子目录。例如，库文件存储在*/usr/lib*中，其中*usr*是根目录的子目录，*lib*是*usr*的子目录。这种统一的层次结构即使在系统中有多个存储设备时也适用。额外的存储设备会映射到目录结构中的某个位置；这被称为*挂载*设备。例如，一个USB驱动器可以挂载到*/mnt/usb1*。'
- en: In contrast, Microsoft Windows assigns a drive letter (A–Z) to each volume.
    So rather than a unified directory structure, each drive has its own root and
    hierarchy of directories. Windows uses a backslash (`\`) in its directory paths,
    and a colon (`:`) after a drive letter. For example, the Windows system files,
    stored on the C drive, are typically located under *C:\windows\system32*. This
    convention dates back to DOS (and earlier), when drives A and B were reserved
    for floppy disks, and drive C represented an internal hard drive. To this day,
    drive C is typically used as the drive letter for the volume where Windows is
    installed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，微软Windows为每个卷分配一个驱动器字母（A–Z）。因此，与统一的目录结构不同，每个驱动器都有自己的根目录和目录层次结构。Windows在目录路径中使用反斜杠（`\`），并在驱动器字母后面加上冒号（`:`）。例如，存储在C驱动器上的Windows系统文件通常位于*C:\windows\system32*目录下。这种约定源于DOS（以及更早的版本），当时A和B驱动器被保留给软盘，而C驱动器表示内部硬盘。直到今天，C驱动器通常用作Windows安装所在卷的驱动器字母。
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #27](ch10.xhtml#proj27) on [page 230](ch10.xhtml#page_230),
    where you can check out the details of storage and files on Raspberry Pi OS*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #27](ch10.xhtml#proj27)在[第230页](ch10.xhtml#page_230)，在那里你可以查看Raspberry
    Pi OS上存储和文件的详细信息。*'
- en: '**Services and Daemons**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**服务与守护进程**'
- en: Operating systems provide the ability for processes to automatically run in
    the background, without user interaction. Such processes are called *services*
    on Windows and *daemons* on Unix-like systems. A typical operating system includes
    a number of such services that run by default, such as a service to configure
    network settings, or a service that runs tasks on a schedule. Services are used
    to provide capabilities that aren’t tied to a specific user, don’t need to run
    in kernel mode, but do need to be available on demand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供了让进程在后台自动运行而无需用户交互的功能。这类进程在 Windows 上称为 *services*，在类 Unix 系统上称为 *daemons*。典型的操作系统包括多个默认运行的此类服务，比如用于配置网络设置的服务，或者按计划运行任务的服务。服务用于提供不依赖于特定用户、不需要在内核模式下运行但又需要随时可用的功能。
- en: Operating systems usually include a component responsible for managing services.
    Some services need to start when the OS boots; others need to run in response
    to a particular event. Often services should be restarted in the case of an unexpected
    failure. In Windows, the *Service Control Manager* (*SCM*) performs these types
    of functions. The SCM’s executable file is *services.exe*, which is started early
    in the Windows boot process and continues to run as long as Windows itself is
    running. Many modern Linux distributions have adopted `systemd` as the standard
    component for managing daemons, although other mechanisms can be used in Linux
    to start and manage daemons. As discussed earlier, `systemd` also acts as the
    init process, so it’s started very early in the Linux boot process and continues
    to run while the system is up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常包括一个负责管理服务的组件。有些服务需要在操作系统启动时启动；其他服务则需要响应特定事件运行。通常在发生意外故障时，服务应重新启动。在 Windows
    中，*服务控制管理器* (*SCM*) 执行这些功能。SCM 的可执行文件是 *services.exe*，它在 Windows 启动过程中很早就开始运行，并在
    Windows 运行时继续运行。许多现代 Linux 发行版已经将 `systemd` 作为管理守护进程的标准组件，尽管 Linux 中也可以使用其他机制来启动和管理守护进程。如前所述，`systemd`
    还充当初始化进程，因此它在 Linux 启动过程中非常早就开始运行，并在系统运行时继续执行。
- en: The Unix and Linux term *daemon* comes from Maxwell’s demon, a hypothetical
    being described in a physics thought experiment. This creature worked in the background,
    much like a computer daemon. Outside of computing, *daemon* is typically pronounced
    just like “demon,” but when referring to background processes, “DAY-mon” is an
    equally acceptable pronunciation. Historically, *service* was a Windows-specific
    term, but now it is used on Linux as well, often to refer to daemons that are
    started by `systemd`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 和 Linux 中的术语 *daemon* 源自物理学思想实验中描述的假想生物 Maxwell's demon。这个生物像计算机的守护进程一样在后台工作。在计算机之外，*daemon*
    通常发音为“demon”，但在指代后台进程时，“DAY-mon”也是一种可以接受的发音。历史上，*service* 是一个特定于 Windows 的术语，但现在它在
    Linux 上也被使用，通常指由 `systemd` 启动的守护进程。
- en: '**NOTE**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #28](ch10.xhtml#proj28) on [page 231](ch10.xhtml#page_231),
    where you can check out services on Raspberry Pi OS*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅 [第28号项目](ch10.xhtml#proj28)，以及 [第231页](ch10.xhtml#page_231)，你可以在这里查看 Raspberry
    Pi OS 上的服务*。'
- en: '**Security**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: An operating system provides a security model for the code that runs on that
    OS. In this context, *security* means that software, and users of that software,
    should only have access to appropriate parts of the system. This may not seem
    like a big deal for a personal device like a laptop or smartphone. If only one
    user logs into a system, shouldn’t they have access to everything? Well, no, at
    least not by default. Users make mistakes, including running code that isn’t trustworthy.
    If a user accidentally runs malicious software on their device, the OS can help
    limit the damage by restricting that user’s access. On a shared system where multiple
    users log in, a user should not be able to read or modify another user’s data,
    at least not by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为在其上运行的代码提供安全模型。在此背景下，*安全性* 意味着软件及其用户应该只访问系统的适当部分。这对像笔记本电脑或智能手机这样的个人设备来说，可能看起来不是什么大问题。如果只有一个用户登录系统，难道他们不应该能够访问所有内容吗？嗯，不，至少默认情况下不是这样。用户会犯错误，包括运行不可信的代码。如果用户不小心在设备上运行了恶意软件，操作系统可以通过限制该用户的访问权限来帮助减少损害。在共享系统上，多个用户登录时，用户不应该能够读取或修改另一个用户的数据，至少默认情况下不应该。
- en: Operating systems make use of multiple techniques to provide security. Let’s
    look at just a few here. Simply putting applications in a user mode bubble goes
    a long way toward ensuring that software doesn’t intentionally or accidentally
    mess with other applications or with the kernel. Operating systems also implement
    filesystem security, ensuring that data stored in files can only be accessed by
    appropriate users and processes. Virtual memory itself can be secured—regions
    of memory can be marked as read only or as executable, helping to limit misuse
    of memory. Providing a login system for users allows the operating system to manage
    security based on the user’s identity. These are all baseline expectations of
    a modern operating system. Unfortunately, security vulnerabilities are regularly
    discovered in operating systems, allowing malicious actors to bypass the defenses
    of the OS. Keeping modern internet-connected operating systems up-to-date with
    the latest updates is critical to maintaining security.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用多种技术来提供安全性。这里我们仅介绍其中一些。简单地将应用程序放入用户模式的隔离环境中，能够大大确保软件不会故意或无意地干扰其他应用程序或内核。操作系统还实现了文件系统安全，确保存储在文件中的数据只能被合适的用户和进程访问。虚拟内存本身也可以被保护——内存区域可以被标记为只读或可执行，从而帮助限制内存的滥用。为用户提供登录系统，使操作系统能够根据用户身份管理安全性。这些都是现代操作系统的基本安全要求。不幸的是，操作系统中经常会发现安全漏洞，允许恶意行为绕过操作系统的防御机制。保持现代互联网连接操作系统的最新更新对于确保安全至关重要。
- en: '**Summary**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter we covered operating systems, software that communicates with
    computer hardware and provides an environment for the execution of programs. You
    learned about the operating system kernel, non-kernel components, and the separation
    of kernel mode and user mode. We reviewed the two dominant operating system families:
    Unix-like operating systems and Microsoft Windows. You learned that a program
    runs in a container known as a process, and multiple threads can execute in parallel
    within that process. We looked at various aspects of programmatically interacting
    with an operating system: the API, system calls, software libraries, and the ABI.
    In the next chapter, we’ll move beyond single-device computing and examine the
    internet, looking at the various layers and protocols that make the internet possible.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了操作系统，操作系统是与计算机硬件通信并为程序执行提供环境的软件。你了解了操作系统内核、非内核组件以及内核模式与用户模式的分离。我们回顾了两大主流操作系统家族：类
    Unix 操作系统和 Microsoft Windows。你了解到，程序在一个名为进程的容器中运行，并且多个线程可以在该进程内并行执行。我们查看了与操作系统编程交互的各个方面：API、系统调用、软件库和
    ABI。在下一章中，我们将超越单设备计算，研究互联网，看看使互联网成为可能的各种层次和协议。
- en: '**PROJECT #20: EXAMINE RUNNING PROCESSES**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #20：检查正在运行的进程**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you
    flip to [Appendix B](appb.xhtml) and read the entire “Raspberry Pi” section if
    you haven’t already.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行 Raspberry Pi OS 的 Raspberry Pi。如果你还没有阅读过，建议翻到[附录 B](appb.xhtml)并阅读整个“Raspberry
    Pi”部分。
- en: In this project, you’ll look at processes running on a Raspberry Pi. The `ps`
    tool provides various views of running processes. Let’s begin with the following
    command, which provides a tree view of processes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将查看 Raspberry Pi 上运行的进程。`ps` 工具提供了多种查看运行中进程的方式。让我们从以下命令开始，它提供了进程的树形视图。
- en: '[PRE4]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output should look something like the following text. I’ve only reproduced
    a portion of it here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下文本。我这里只复制了一部分。
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The indentation level indicates a parent/child relationship. For example, in
    the preceding output, we see that `systemd` is the parent of `systemd-journal`,
    `systemd-udevd`, and so forth. Or inversely, we can see that `ps` (the command
    currently running) is the child of `bash`, which is the child of `sshd`, and so
    forth.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进级别表示父子关系。例如，在上述输出中，我们可以看到 `systemd` 是 `systemd-journal`、`systemd-udevd` 等的父进程。或者反过来，我们可以看到
    `ps`（当前运行的命令）是 `bash` 的子进程，而 `bash` 是 `sshd` 的子进程，依此类推。
- en: 'The displayed columns are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的列如下：
- en: '**PID**   The process ID'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**PID**   进程 ID'
- en: '**TTY**   The associated terminal'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**TTY**   关联的终端'
- en: '**TIME**   The cumulative CPU time'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**TIME**   累计 CPU 时间'
- en: '**CMD**   The executable name'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMD**   可执行文件名称'
- en: The number of processes running may surprise you when you run `ps` in this way!
    The operating system handles many things, and as a result, it’s normal for a large
    number of processes to run at any given time. Typically you see that the first
    process listed is PID 2, `kthreadd`. This is the parent of kernel threads, and
    the children you see listed under `kthreadd` are threads running in kernel mode.
    The other process to note is PID 1, the init process, the first user mode process
    that starts. In the preceding output, the init process is `systemd`. The Linux
    kernel starts both the init process and `kthreadd`, in that order, which ensures
    they are assigned PIDs 1 and 2, respectively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the init process. This is the first user mode process
    to start, and the specific executable that runs can vary on different versions
    of Linux. You can use `ps` to find the command used to start PID 1:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see output like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This tells you that the command used to kick off the init process was `/sbin/init`.
    So how does running `/sbin/init` result in `systemd` executing, as you saw in
    the earlier `ps` output? This happens because `/sbin/init` is actually a symbolic
    link to `systemd`. A *symbolic link* references another file or directory. You
    can see this with the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this output, you can see that `/sbin/init` is a symbolic link to `/lib/systemd/systemd`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convenient view of the process tree can be generated by using the `pstree`
    tool, as mentioned earlier in this chapter. Running `pstree` presents a nicely
    formatted user mode process tree, starting with the init process. Give it a try:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alternatively, if your Raspberry Pi is configured to boot to the desktop environment,
    you may also want to try the Task Manager application that’s included with Raspberry
    Pi OS. It provides a graphical view of running processes, as shown in [Figure
    10-15](ch10.xhtml#ch10fig15).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig10-15.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Task Manager in Raspberry Pi OS*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #21: CREATE A THREAD AND OBSERVE IT**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. See “Raspberry Pi” on
    [page 341](appb.xhtml#page_341).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll write a program that creates a thread. You’ll then observe
    the thread running. Use the text editor of your choice to create a new file called
    *threader.c* in the root of your home folder. Enter the following C code into
    your text editor (you don’t have to preserve indentation and empty lines, but
    be sure to maintain line breaks).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before continuing, let’s examine the source code. I won’t go into all the details
    here, but in summary, the program starts in the `main` function ❺, which creates
    a thread ❻ that runs the function `mythread` ❶. This means there are two threads,
    the `main` thread and `mythread`. Both threads run in an infinite loop ❷❼, where
    every so often they print the PID and TID of the current thread ❸❽. For variety,
    `mythread` prints about every 5 seconds ❹, while `main` prints approximately every
    10 seconds ❾. This helps illustrate that the threads are in fact running in parallel
    and doing work on their own schedule. Let’s try it out.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们来看看源代码。我在这里不会讲解所有细节，但总结来说，程序从`main`函数❺开始，创建一个运行`mythread`函数❶的线程❻。这意味着有两个线程，`main`线程和`mythread`线程。两个线程都在无限循环中运行❷❼，并且时不时地打印当前线程的PID和TID❸❽。为了变化，`mythread`大约每5秒打印一次❹，而`main`大约每10秒打印一次❾。这有助于说明两个线程实际上是并行运行的，并且各自按自己的节奏工作。我们来试试看。
- en: Once the file is saved, use the GNU C Compiler (`gcc`) to compile your code
    into an executable file. The following command takes *threader.c* as an input
    and outputs an executable file named *threader*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，使用GNU C编译器（`gcc`）将代码编译成可执行文件。以下命令将*threader.c*作为输入，输出一个名为*threader*的可执行文件。
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now try running the code using the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令运行代码：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The running program should output something like this, although the PID and
    TID numbers will be different:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的程序应该输出类似以下内容，尽管PID和TID数字会有所不同：
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As the program runs, expect the two threads to continue printing their PID and
    TID information. The TID and PID numbers won’t change for this instance of the
    program, since it’s the same process and threads running the entire time. You
    should see `mythread` print twice as often as `main`—every 5 seconds versus every
    10 seconds.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序的运行，预期两个线程会继续打印它们的PID和TID信息。由于这是同一个进程和线程在整个时间内运行，所以TID和PID数字不会改变。你应该看到`mythread`打印的频率是`main`的两倍——每5秒一次，而`main`每10秒打印一次。
- en: Leave that program running and look at your list of running processes and threads.
    To do this, you need to open a second terminal window and run the following command
    (the `|` symbol can be entered with SHIFT-backslash right above ENTER, on US keyboards).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 保持该程序运行，并查看正在运行的进程和线程列表。为此，你需要打开第二个终端窗口并运行以下命令（`|`符号可以通过按SHIFT和反斜杠键（位于ENTER键上方）来输入，在美国键盘上）。
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the `T` option to the `ps` command shows threads as well as processes.
    The `grep` utility filters your output to only see the `threader` process information.
    In this output, the first column is the PID and the second column is the TID.
    So you can see that the output from `ps` matches the output from your program.
    The two threads share a PID but have different TIDs. Also, note that the `main`
    thread’s TID matches its PID. This is expected for the first thread in a process.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ps`命令中添加`T`选项，可以同时显示线程和进程。`grep`命令用于过滤输出，只显示`threader`进程的信息。在这个输出中，第一列是PID，第二列是TID。所以你可以看到，`ps`的输出与程序输出匹配。两个线程共享PID，但有不同的TID。还要注意，`main`线程的TID与其PID相同。这是进程中第一个线程的预期行为。
- en: 'To halt execution of the threader program, you can press CTRL-C in the terminal
    window where it’s running. Or, from the second terminal window, you can use the
    `kill` utility, specifying the PID of the main thread, like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止线程程序的执行，可以在其运行的终端窗口按CTRL-C，或者从第二个终端窗口使用`kill`命令，指定主线程的PID，如下所示：
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**PROJECT #22: EXAMINE VIRTUAL MEMORY**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #22：检查虚拟内存**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. See “Raspberry Pi” on
    [page 341](appb.xhtml#page_341).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的树莓派。请参见[第341页](appb.xhtml#page_341)的“树莓派”。
- en: 'In this project, you’ll examine virtual memory usage on Raspberry Pi OS. Let’s
    begin with a look at how address space is divided between kernel mode and user
    mode. This project assumes you are running the 32-bit version of Raspberry Pi
    OS, meaning there is 4GB of virtual address space. Linux allows for a split of
    that 4GB as either 2GB user and 2GB kernel, or 3GB user and 1GB kernel. Lower
    addresses are used for user mode, and higher addresses are used for kernel mode.
    That means that in a 2:2 split, kernel mode addresses start at 0x80000000, and
    in a 3:1 split, kernel mode addresses start at 0xC0000000\. You can see the start
    of kernel mode address space with this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the `dmesg` command does not produce any output, simply restart your Raspberry
    Pi and then run the `dmesg` command again. The command should produce output similar
    to the following.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’re wondering why you need to restart the Raspberry Pi if this command
    comes up empty, here’s some background information. The Linux kernel logs diagnostic
    messages to something called the kernel ring buffer, which the *`dmesg`* tool
    displays. The messages in the buffer are intended to give users some insight into
    the workings of the kernel. Only a limited number of messages are stored here;
    as newer messages are added, older messages are removed. The particular message
    we want to see (regarding *`lowmem`*) is written when the system starts, so if
    your system has been running for a while, it may have been overwritten. Restarting
    the system ensures that the message is written again.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, on my system, kernel `lowmem` starts at `0x80000000`, indicating
    a 2:2 split. This means that user mode processes can use addresses `0x00000000`
    to `0x7fffffff`. That range of addresses can reference 2GB of memory, and although
    the entire address space is available to every process, a typical process only
    actually needs to use a portion of that range. Certain addresses are mapped to
    physical memory, but others are left unmapped.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If your system returns a value of `0xc0000000` for the beginning of `lowmem`,
    then your system is running with a 3:1 split. This gives user mode processes 3GB
    of virtual address space, from `0x00000000` to `0xbfffffff`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pick a process and examine its virtual memory usage. Raspberry Pi OS
    uses Bash as its default shell process, so if you’re working from a command line
    in Raspberry Pi OS, at least one instance of `bash` should be running. Let’s find
    the PID of a `bash` instance:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should output text similar to the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In my case, the PID of `bash` was `2670`. Now, run the following command to
    see the virtual memory mapping in the `bash` process. When you enter the command,
    be sure to replace `*<pid>*` with the PID returned on your system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output will be similar to the following, where each line represents a region
    of virtual memory in the process address space.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first column is the region start address, the second column is the size
    of the region, the third column represents the permissions of the region (`r`
    = read, `w` = write, `x` = execute, `p` = private, `s` = shared), and the final
    column is the region name. The region name is either a filename or a name that
    identifies the memory region if it isn’t mapped from a file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是区域的起始地址，第二列是区域的大小，第三列表示区域的权限（`r` = 读，`w` = 写，`x` = 执行，`p` = 私有，`s` = 共享），最后一列是区域名称。区域名称要么是文件名，要么是标识内存区域的名称（如果它不是从文件映射的）。
- en: You can see that almost every region in the output is within the expected user
    mode range of `0x00000000` to `0x7fffffff`. The one exception is the last entry,
    which corresponds to the ARM CPU vector page, and represents a special case, as
    it’s outside the standard user mode address range. As you can see in the preceding
    output, this particular instance of bash only has a `total` of `6052K` (about
    6MB) of virtual memory mapped out of a possible 2GB, or around 0.3 percent.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到输出中的几乎所有区域都在期望的用户模式范围`0x00000000`到`0x7fffffff`内。唯一的例外是最后一项，它对应于ARM CPU向量页面，并表示一个特殊情况，因为它位于标准用户模式地址范围之外。如前面的输出所示，这个特定实例的bash仅映射了`6052K`（大约6MB）的虚拟内存，总共可用2GB，大约为0.3%。
- en: '**PROJECT #23: TRY THE OPERATING SYSTEM API**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #23：尝试操作系统API**'
- en: 'Prerequisite: A Raspberry Pi, running the Raspberry Pi OS.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的Raspberry Pi。
- en: In this project, you’ll try invoking the operating system API in various ways.
    You’ll specifically focus on creating a file and writing some text to it. Use
    the text editor of your choice to create a file called *newfile.c* in the root
    of your home folder. Enter the following C code into your text editor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将尝试以不同方式调用操作系统API。你将特别关注创建一个文件并向其写入一些文本。使用你喜欢的文本编辑器，在你的主文件夹根目录下创建一个名为*newfile.c*的文件，并在其中输入以下C代码。
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we continue, let’s examine the source code to understand exactly what
    it does. In short, the program uses three API functions, `open`, `write`, and
    `close`, to create a new file, write some text to it, and finally close the file.
    Our focus here is to see how the operating system’s API allows a program to interact
    with the computer’s hardware, specifically a storage device. Let’s go through
    the program in more detail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们检查一下源代码，确切了解它的功能。简而言之，程序使用三个API函数：`open`、`write`和`close`，来创建一个新文件、向其中写入一些文本，并最终关闭文件。我们在这里的重点是查看操作系统的API如何允许程序与计算机的硬件交互，特别是存储设备。让我们更详细地了解一下程序。
- en: After the requisite include statements, the next line defines `msg` as a text
    string ❶ that later will be written to the newly created file. The code then defines
    `main`, the entry point of the program ❷. Within `main`, an integer named `fd`
    is declared ❸. Next, the OS API `open` function is called to create a new file
    named *file1.txt* ❹. The other arguments passed to the `open` function specify
    the details of how the file should be opened. For simplicity, I won’t cover those
    details here, but feel free to research the meanings of these arguments. The `open`
    function returns a file descriptor, which is saved in the `fd` variable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要的包含语句之后，下一行将`msg`定义为一个文本字符串 ❶，稍后将写入新创建的文件。接下来，代码定义了`main`，程序的入口点 ❷。在`main`中，声明了一个名为`fd`的整数
    ❸。然后，调用操作系统API的`open`函数来创建一个名为*file1.txt*的新文件 ❹。传递给`open`函数的其他参数指定了文件打开的详细信息。为了简便起见，我这里不涉及这些细节，但你可以自由研究这些参数的含义。`open`函数返回一个文件描述符，该描述符保存在`fd`变量中。
- en: The `write` function is then used to write the `msg` text to *file1.txt* (identified
    by the file descriptor stored in `fd`) ❺. The `write` function requires inputs
    of both the data to write (`msg`) and the number of bytes to write, determined
    by `sizeof(msg) - 1`. You subtract 1 because the C language terminates strings
    with a null character, and you don’t need to write that byte to the output file.
    The program is now finished working with the file and calls the `close` function
    on the file descriptor to indicate that the file is no longer in use ❻. Finally,
    the program exits with a return code of 0 ❼, indicating success.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`write`函数被用来将`msg`文本写入*file1.txt*（由存储在`fd`中的文件描述符标识） ❺。`write`函数需要输入写入的数据（`msg`）和写入的字节数，字节数由`sizeof(msg)
    - 1`决定。你要减去1，因为C语言使用空字符终止字符串，而你不需要将那个字节写入输出文件。程序现在已完成文件操作，并调用`close`函数关闭文件描述符，表示文件不再使用
    ❻。最后，程序以返回代码0退出 ❼，表示成功。
- en: Once the file is saved, use the GNU C Compiler (`gcc`) to compile the code into
    an executable file. The command below takes *newfile.c* as an input and generates
    an executable file named *newfile*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件保存好，使用 GNU C 编译器（`gcc`）将代码编译成可执行文件。下面的命令以 *newfile.c* 为输入，生成一个名为 *newfile*
    的可执行文件。
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now try running the code using the following command. You won’t see any output,
    since the text is written to a file rather than the terminal.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令运行代码。你不会看到任何输出，因为文本被写入了文件，而不是终端。
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To determine if the program ran successfully, you need to see if a file was
    created. The file should be named *file1.txt* and exist in your current directory.
    You can use the `ls` command to list the contents of the current directory and
    look for the file. Assuming *file1.txt* is present, you can see its contents using
    the `cat` command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定程序是否成功运行，你需要检查是否创建了一个文件。文件应该被命名为 *file1.txt* 并存在于你当前的目录中。你可以使用 `ls` 命令列出当前目录的内容，并查找该文件。假设
    *file1.txt* 存在，你可以使用 `cat` 命令查看文件内容。
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command should print `Hello, file!` to the terminal, since that’s the text
    the program wrote to the file. Or you can view the file’s properties in the File
    Manager application of the Raspberry Pi OS desktop, and you can open *file1.txt*
    in your text editor of choice.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应打印 `Hello, file!` 到终端，因为这就是程序写入文件的文本。或者，你也可以在 Raspberry Pi OS 桌面的文件管理器应用中查看文件属性，打开
    *file1.txt* 文件并用你喜欢的文本编辑器查看。
- en: When you use the C programming language you get a look at specifics of the OS
    API functions, since `open`, `write`, and `close` are defined as C functions.
    However, you aren’t limited to C when interacting with the OS. Other languages
    provide their own layer on top of the API, hiding some of the complexity from
    software developers. To illustrate this, let’s write an equivalent program in
    Python.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 C 编程语言时，你会看到操作系统 API 函数的具体实现，因为 `open`、`write` 和 `close` 被定义为 C 函数。然而，和操作系统交互时你并不仅限于使用
    C 语言。其他语言提供了自己的一层封装，隐藏了部分复杂性，方便软件开发者使用。为了说明这一点，让我们用 Python 编写一个等效的程序。
- en: Use the text editor of your choice to create a file called *newfile.py* in the
    root of your home folder. Enter the following Python code into your text editor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器，在主文件夹的根目录创建一个名为 *newfile.py* 的文件。将以下 Python 代码输入到你的文本编辑器中。
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Before continuing, let’s examine the source code. This program effectively does
    the same thing as the previous program, except the output filename is different
    (*file2.txt*) ❶, and the text written to that file is also different ❷. In this
    case, Python happens to use the same names as the OS API (`open`, `write`, `close`),
    but these are not direct calls to the operating system; rather, they are calls
    into the Python standard library.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们先来看看源代码。这个程序的功能和之前的程序几乎一样，唯一的不同是输出的文件名不同（*file2.txt*）❶，以及写入文件的文本也有所不同❷。在这个例子中，Python
    恰好使用了与操作系统 API 相同的名称（`open`、`write`、`close`），但这些并不是直接的操作系统调用，而是调用了 Python 标准库中的函数。
- en: 'Once you’ve saved this code, you can run it. Remember that Python is an interpreted
    language, so rather than compiling your Python code, just run it using the Python
    interpreter, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存了这段代码，就可以运行它。记住，Python 是一种解释型语言，所以你不需要编译 Python 代码，只需使用 Python 解释器运行它，如下所示：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To determine if the program ran successfully, you need to see if *file2.txt*
    was created with the expected contents. You can again use `ls` and `cat` to verify
    this, or you can look in the desktop File Manager to see the file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定程序是否成功运行，你需要检查 *file2.txt* 是否被创建并包含预期的内容。你可以再次使用 `ls` 和 `cat` 命令来验证，或者直接在桌面文件管理器中查看文件。
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although it may seem as if you’re just leveraging Python’s capabilities to manipulate
    a file, keep in mind that Python cannot do this on its own. The Python interpreter
    is making system API calls on your behalf when it runs your code. You’ll get to
    observe this in the next project.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来你只是利用 Python 的能力来操作文件，但请记住，Python 无法独立完成这项工作。当你运行代码时，Python 解释器实际上是在代表你进行系统
    API 调用。你将在下一个项目中观察到这一点。
- en: '**PROJECT #24: OBSERVE SYSTEM CALLS**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #24：观察系统调用**'
- en: 'Prerequisite: Complete [Project #23](ch10.xhtml#proj23).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '前提条件：完成 [项目 #23](ch10.xhtml#proj23)。'
- en: 'In this project, you’ll observe the system calls made by the programs you wrote
    in [Project #23](ch10.xhtml#proj23). To do this you’ll use a tool called `strace`,
    which traces system calls and prints the output to the terminal.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，你将观察到你在 [项目 #23](ch10.xhtml#proj23) 中编写的程序所做的系统调用。为此，你将使用一个叫做 `strace`
    的工具，它可以追踪系统调用并将输出打印到终端。'
- en: 'Open a terminal on your Raspberry Pi and use `strace` to run the `newfile`
    program you previously wrote in C and compiled:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `strace` tool launches a program (`newfile` in this case) and shows all
    the system calls that are made while that program runs. At the beginning of the
    output, you can see a number of system calls that represent the work required
    to load the executable file and required libraries. This is work that happens
    before the code you wrote runs; you can skip past that text. Near the end of the
    output, you should see text similar to the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This should look familiar; it’s almost the same three API functions that you
    used to create *file1.txt* and write text to it. The C functions that you called
    from your program are just thin wrappers around the system calls of the same name,
    with the exception of `open`, which invokes the `openat` system call. The values
    after the equals signs are the return values from the three system calls. On my
    system, the `openat` function returned `3`, which is a number known as a *file
    descriptor* that refers to the opened file. You can see the file descriptor value
    used as a parameter to the subsequent calls to `write` and `close`. The `write`
    function returned `13`, the number of bytes written. The `close` function returned
    `0`, an indicator of success.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the same approach to also check out the system calls made from the
    Python program you wrote in [Project #23](ch10.xhtml#proj23).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Expect to see even more output here, since `strace` is actually monitoring the
    Python interpreter, which in turn has to load *newfile.py* and run it. If you
    look near the end of the output, you should see calls to `openat`, `write`, and
    `close`, just as you did in the C program. This shows that despite the source
    code differences between C and Python, in the end, the same system calls are invoked
    to interact with files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strace` tool can be used to quickly get an idea of how a program interacts
    with the operating system. For example, earlier in this chapter, we used the `ps`
    utility to get a list of processes. If you want to understand how `ps` works,
    you can run `ps` under `strace`, like so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Look at the output from this command to see what system calls `ps` makes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #25: USE GLIBC**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll write code to use the C library and examine the details
    of how this works. Use the text editor of your choice to create a new file called
    *random.c* in the root of your home folder. Enter the following C code into your
    text editor.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This little program simply prints a random integer value to the terminal. The
    first thing the program does is call the `srand` function to seed the random number
    generator ❶, a necessary step to ensure a unique sequence of numbers is generated.
    The current time, as returned from the `time` function, is used as the seed value.
    The next line prints out a random value returned from the `rand` function ❷. To
    accomplish all of this, the program uses four functions from the C library (`time`,
    `srand`, `rand`, and `printf`).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序只是简单地将一个随机整数值打印到终端。程序首先调用 `srand` 函数来为随机数生成器设定种子❶，这是确保生成唯一数字序列的必要步骤。当前时间（由
    `time` 函数返回）被用作种子值。接下来的一行打印出由 `rand` 函数返回的随机值❷。为了完成这些操作，程序使用了 C 库中的四个函数（`time`、`srand`、`rand`
    和 `printf`）。
- en: Once the file is saved, you can use the GNU C Compiler (`gcc`) to compile the
    code into an executable file. The following command takes *random.c* as an input
    and outputs an executable file named *random*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件保存，你可以使用 GNU C 编译器（`gcc`）将代码编译成可执行文件。以下命令以 *random.c* 作为输入，输出一个名为 *random*
    的可执行文件。
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now try running the code using the following command. The program should output
    a random number. Run it multiple times to confirm that it outputs different numbers.
    However, quickly running it twice may produce the same result, since the seed
    value returned from the `time` function only increments every second.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令运行代码。程序应该输出一个随机数。多次运行它来确认输出的是不同的数字。然而，快速运行两次可能会产生相同的结果，因为从 `time`
    函数返回的种子值每秒才会增加一次。
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you’ve ensured that the program works, look at the libraries that the
    program imports. One way to do this is to run the `readelf` utility, like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确保程序正常工作，查看程序导入的库。可以通过运行 `readelf` 工具来实现，像这样：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Look for the `NEEDED` sections in the output, like the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 查找输出中的 `NEEDED` 部分，如下所示：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This tells you that the *libc.so.6* library is required for this program to
    run. This is expected, as this is the GNU C Library (also known as `glibc`). In
    other words, because the program relies on functions in the C standard library,
    the operating system must load the *libc.so.6* library file so that the library
    code is available. This is a good start, but what if you want to see the specific
    list of functions that the `random` program uses from this library? You can observe
    this with the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你，程序运行需要 *libc.so.6* 库。这是预期的，因为这是 GNU C 库（也称为`glibc`）。换句话说，由于程序依赖于 C 标准库中的函数，操作系统必须加载
    *libc.so.6* 库文件，以便提供库代码。这是一个好的开始，但如果你想查看 `random` 程序从这个库中使用的具体函数列表怎么办？你可以通过以下方式查看：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This gives you output like the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你如下的输出：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding output, in the rightmost column, you can see the expected four
    functions (`srand`, `rand`, `printf`, and `time`) along with some additional functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，在最右侧的列中，你可以看到预期的四个函数（`srand`、`rand`、`printf` 和 `time`）以及一些额外的函数。
- en: 'Now that you’ve established which `glibc` functions were imported by your `random`
    program, you may wish to see the list of all functions that are exported by `glibc`.
    These are the functions this library makes available for programs to use. You
    can get this information with the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确定了 `glibc` 函数被 `random` 程序导入，可能你想查看 `glibc` 导出的所有函数列表。这些是该库为程序提供的可用函数。你可以通过以下命令获取这个信息：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sometimes it’s useful to see information about loaded libraries while you’re
    debugging a running process. Let’s try that by debugging the `random` program.
    To start, enter the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在调试运行中的进程时，查看已加载库的信息是很有用的。让我们通过调试 `random` 程序来试试。首先，输入以下命令：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point `gdb` has loaded the file but no instructions have run yet. From
    the `(gdb)` prompt, enter the following to start running the program. The debugger
    halts execution once it reaches the beginning of the `main` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此时 `gdb` 已经加载了文件，但还没有运行任何指令。从 `(gdb)` 提示符下，输入以下命令以开始运行程序。调试器将在到达 `main` 函数的开头时暂停执行。
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look at the loaded shared libraries:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 查看已加载的共享库：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first library, *ld-linux-armhf.so.3* ❶, is the Linux dynamic linker library.
    It’s responsible for loading other libraries. Linux ELF binaries are compiled
    to use a specific linker library; this information is in the ELF header of the
    compiled program. You can find the linker library for the `random` program using
    the following command from a terminal window (not in `gdb`):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see in the preceding output, the linker library specified for the
    `random` program is *ld-linux-armhf.so.3*, the same dynamic linker library we
    just discussed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Take a look back at the `info sharedlibrary` output in `gdb`; you can see that
    the second library listed is `libarmmem-v71.so` ❷. This library is specified in
    the file */etc/ld.so.preload*, a text file that lists libraries that load for
    every program that’s executed on the system.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Now move on to the third library, which is the one of interest, *libc.so.6*
    ❸, the GNU C Library (`glibc`). In the `readelf` and `objdump` output earlier
    you saw that this library was imported by the executable file, and here you can
    see that it did indeed successfully load while running. You can also see the specific
    address range where it loaded (`0x76e6e050` to `0x76f702b4`), and the specific
    directory path from which it loaded.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You can exit the debugger at any time by typing `quit` in `gdb`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #26: VIEW LOADED KERNEL MODULES**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll take a look at the loaded kernel modules, including
    device drivers, on Raspberry Pi OS. Device drivers are typically implemented as
    kernel modules on Linux, although not all kernel modules are device drivers. To
    list the loaded modules, you can either examine the contents of the */proc/modules*
    file or use the `lsmod` tool like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To view more details about a specific module, use the `modinfo` utility like
    so (using the `snd` module as an example):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**PROJECT #27: EXAMINE STORAGE DEVICES AND FILESYSTEMS**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll take a look at storage devices and filesystems. Let’s
    begin by listing the block devices, which is how Linux characterizes storage devices.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here we see a single “disk” named `mmcblk0` ❶, which is the microSD card in
    the Raspberry Pi. You can see that it’s divided into two partitions of varying
    sizes. Partition 1 is mapped to the */boot* directory in the unified directory
    structure ❷, while partition 2 is mapped to the root (*/*) ❸.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the overall usage of the storage device using the `df` command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This command lets you view the various mounted filesystems, their size, and
    how full they are. Only the `root` ❶ and `/boot` ❷ directories are mapped to storage
    devices. The others are temporary filesystems that reside in memory, not a persistent
    storage device.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: You can get a view of the directories on your system by running the `tree` command.
    The parameters used here limit your output to directories only, and only go three
    levels deep in the hierarchy.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can also see a similar view from the desktop environment using the File
    Manager application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #28: VIEW SERVICES**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll look at services/daemons. Raspberry Pi OS uses the
    `systemd` init system, and it includes a utility called `systemctl` that you can
    use to see the state of services:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This should produce output similar to the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you aren’t automatically returned to a terminal prompt, hit Q in your terminal
    to exit the view of services. To see the details of a particular service, try
    this command, using `cron.service` as an example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output of this command includes the path and PID of the process that’s associated
    with the service. In the case of `cron.service`, the path on my system is */usr/sbin/cron*,
    and it happened to be PID 367.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to viewing daemon processes is to view all the processes that
    are children of `systemd`, that is, PID 1\. This is relevant since services are
    started by `systemd` and appear as child processes of PID 1\. Note that this output
    may include more than just services/daemons, since orphaned processes are adopted
    by PID 1.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
