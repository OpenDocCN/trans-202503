- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitmaps
  prefs: []
  type: TYPE_NORMAL
- en: Most vector images start or end (often both) their lives as bitmaps ([1.1](c01.xhtml#section1.1)),
    and Inkscape's SVG documents are no exception. Many vector drawings, artistic
    as well as technical, are developed from tracings of photos, scans, or other bitmap
    drawings; at the other end of their lifetimes, almost all vector pieces are exported
    into bitmap formats for viewing in software that cannot deal directly with vectors.
    Bitmaps are an important object type in Inkscape, and the techniques for dealing
    with them are sufficiently complex and interesting to devote an entire chapter
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 18.1 Bitmap as Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a bitmap image file, insert it into your Inkscape document with
    the File ▶ Import command. You can also File ▶ Open any bitmap file as a document
    in its own right. In this case, Inkscape automatically creates a new SVG document,
    its page size ([3.5.2](c03.xhtml#section3.5.2)) matching the pixel size of the
    bitmap, and places the bitmap on the canvas (into the document root—that is, not
    in any layer). You can now add other objects to that document and save it as SVG
    (if you want to get a bitmap with the result, you need to export it, [18.6](#section18.6)),
    or you can copy and paste the bitmap object from that document into any other.
  prefs: []
  type: TYPE_NORMAL
- en: '[1.1]'
  prefs: []
  type: TYPE_NORMAL
- en: Inkscape can read a large number of bitmap formats, including all of the major
    ones (PNG, JPG, TIFF, GIF, BMP, but it can't (yet) read the relatively new WebP
    even though it can export it). Choose**All Bitmaps** in the **Import** dialog
    to see only the files in supported bitmap formats. Past versions of Inkscape failed
    when trying to open bitmaps larger than several thousands pixels in one of the
    dimensions; now you won't have problems with images measuring tens of thousands
    of pixels (if your computer has enough RAM).
  prefs: []
  type: TYPE_NORMAL
- en: Whether opened or imported, what you end up with in your document is a *bitmap
    object* ([Figure 18-1](#fig18-1)). In most aspects, this is a regular object that
    you can transform, duplicate, clone, apply filters to, and so on. In the status
    bar, it is described asImage with its pixel size, for example 640 × 480. The pixel
    size of a bitmap is simply how many pixels it has horizontally and vertically;
    this is not the same as the size of the bitmap object on your canvas—you can scale
    it to any size in your SVG, but the intrinsic pixel size of the bitmap never changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-example.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-1: A bitmap object in a document'
  prefs: []
  type: TYPE_NORMAL
- en: 18.2 Bitmap Import Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 18-2](#fig18-2) shows the dialog you see when you open or import a
    bitmap into Inkscape.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-import-dialog.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-2: Importing a bitmap from a file'
  prefs: []
  type: TYPE_NORMAL
- en: 18.2.1 Linking vs. Embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first choice you face with a bitmap is whether to *embed* it or *link* to
    it. By default, any bitmap you import into Inkscape is linked to the document—that
    means the actual content of the bitmap is always taken from the original bitmap
    file. The SVG document contains just a reference to that file—its filename and
    path relative to the location of the SVG file. The status bar description of a
    linked bitmap object reports its filename (inkscape.ico in [Figure 18-1](#fig18-1)).
  prefs: []
  type: TYPE_NORMAL
- en: This way, the SVG file size is kept to a minimum, and multiple SVG documents
    can reuse the same bitmap file. This also means that any changes made to that
    linked bitmap file outside Inkscape will be reflected in the Inkscape document
    immediately. Moreover, you can run an external editor (such as GIMP or Photoshop)
    on your linked image from inside Inkscape by right-clicking the bitmap object
    and choosing Edit externally.
  prefs: []
  type: TYPE_NORMAL
- en: On the Imported Images page of Preferences ([3.1.1](c03.xhtml#section3.1.1)),
    you can uncheck Automatically reload images to disable the updating of imported
    bitmaps. It is also where you can choose which Bitmap editor you want to use to
    edit them via Edit externally (browse to select an executable file).
  prefs: []
  type: TYPE_NORMAL
- en: The biggest disadvantage of linked bitmaps is in how easy it is to disrupt this
    link. If the bitmap file is deleted or moved to a different location relative
    to the SVG document, the result is not pretty, as [Figure 18-3](#fig18-3) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-broken.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-3: What Inkscape shows when it cannot find a linked bitmap file'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common problem when you send your art to someone but forget to include
    the linked images.
  prefs: []
  type: TYPE_NORMAL
- en: What matters for Inkscape is the relative location of the bitmap, because in
    the `xlink:href` attribute of the `svg:image` object, it stores the relative path
    from the SVG document location to the image file. For example, if the bitmap is
    in the images subfolder of the folder in which your SVG document resides, you
    can move that folder along with its images subfolder to a different location without
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Inkscape can also store the *absolute path* to the image in the `sodipodi:absref`
    attribute; if that attribute is present, Inkscape will use it if the relative
    link in`xlink:href` fails. You can enable this behavior, disabled by default,
    with the Store absolute path for linked images checkbox on the Imported Images
    page of Preferences. Using `sodipodi:absref` will restore the images if you move
    the SVG document to another location on the same computer but leave the linked
    images behind; it won't help, however, if you move the images, or if you try to
    open the SVG on a different computer without its associated images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent any linking problems once and for all, *embed* your image into the
    SVG document by choosing the corresponding option during bitmap import ([Figure 18-2](#fig18-2)).
    The status bar description for such an image looks like Image 64 × 64: embedded.
    An embedded image is stored right inside the SVG file, so it will never be lost.
    On the downside, this increases the file size of the SVG file (by about 1.4 times
    the file size of the bitmap file, which may be significant). Also, embedded images
    cannot be edited in an external bitmap editor and cannot be shared by multiple
    SVGs.'
  prefs: []
  type: TYPE_NORMAL
- en: If you imported an image as linked but now want to embed it, use **Extensions ▶ Images ▶ Embed
    Images**. You can apply this either to the selected bitmap object (leaving all
    others as they are) or to all bitmap objects in the document, as shown in [Figure 18-4](#fig18-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-embed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-4: Extensions ▶ Images ▶ Embed Images embeds linked images into SVG.'
  prefs: []
  type: TYPE_NORMAL
- en: WithExtensions ▶ Images ▶ Extract Image, you can reverse this—extract the selected
    embedded image, or all embedded images in the document, into linked file(s). You
    will be asked for the path to save the extracted file, as [Figure 18-5](#fig18-5)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-extract.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-5: Extensions ▶ Images ▶ Extract Image converts embedded images to
    linked.'
  prefs: []
  type: TYPE_NORMAL
- en: 18.2.2 Size on Import
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What size does an image have when you open or import it?
  prefs: []
  type: TYPE_NORMAL
- en: By its nature, a bitmap does not have a physical size measured in inches or
    centimeters. What it has is the *pixel size*—for example, 960 by 480 pixels. In
    addition to that, some bitmap formats specify the suggested *resolution*, also
    called the DPI (for *dots per inch*, a historic term meaning the same as pixels
    per inch). For example, if an image of 960 by 480 pixels has the resolution of
    96 dpi, then it is supposed to be displayed in a space of 10 by 5 inches. For
    Inkscape, which is a vector application, this is no more than a suggestion—it
    treats the pixels of a bitmap as vector shapes that can be scaled to any size.
  prefs: []
  type: TYPE_NORMAL
- en: '[1.1]'
  prefs: []
  type: TYPE_NORMAL
- en: Not all bitmap formats can specify DPI, and not all images have a meaningful
    DPI value. Still, by default Inkscape uses the image's DPI when it's available
    to calculate the *initial* size of the bitmap object on canvas. Otherwise, it
    uses the Default import resolution (on the Imported Images page of Preferences),
    which is 96 dpi. At this resolution, the size of each pixel square is exactly
    1×1 px ([A.6](b01.xhtml#sectionA.6)). You can force Inkscape to use the same resolution
    for all imported images, disregarding their own DPI, by turning on the Override
    file resolution checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: 18.2.3 Rendering Options [1.1]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitmaps consist of pixels ([1.1](c01.xhtml#section1.1)), which, to Inkscape,
    are little different from flat-color rectangles that get scaled, rotated, or skewed
    when you transform the image. If you zoom in close enough, you can even make out
    those individual pixels—but only barely, because by default Inkscape tries to
    smooth them out. If you dislike it, you can turn this smoothing off, when you
    import an image, by setting the Image Rendering Mode ([Figure 18-2](#fig18-2))
    to Blocky (optimizeSpeed). The default None (auto) and Smooth (optimizeQuality)
    are currently the same, and both smooth out pixels at high zoom levels, as shown
    in [Figure 18-6](#fig18-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-rendering.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-6: Image rendering options'
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to use Blocky, for example, when you work with pixel art where
    the position of each individual pixel matters. It is also preferable for large
    images that are not going to be zoomed into—for them, the jaggedness of individual
    pixels will never be seen, but the Blocky option results in slightly faster rendering.
  prefs: []
  type: TYPE_NORMAL
- en: If you have one or more images imported with wrong settings that you need to
    change, use the**Extensions ▶ Images ▶ Set Image Attributes** extension. Its Render
    images blocky option can apply to all images in the document or only to selected
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3 Clipping and Masking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, the first thing you'll want to do to an imported bitmap is*crop* it,
    removing the unnecessary margins and leaving only part of the image. Inkscape
    provides several ways to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: All techniques in this section are shown for bitmap objects—because that's what
    they are most often used for—but you can apply them to any kind of object, including
    groups or layers (which, as you remember, are just a special kind of groups).
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.1 Clipping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inkscape allows any object to be *clipped* by a path, so that only part of the
    object inside that path will be visible. To determine which points are inside
    and which are outside, the same rules are used as for filling ([12.1.2](c12.xhtml#section12.1.2)).
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a bitmap object, draw a clipping path or shape over it using any
    convenient tool, such as the Rectangle or Pen. Then, select both the bitmap and
    the path/shape and choose Object ▶ Clip ▶ Set. The clipping path disappears (it
    now resides in `defs`, [A.4](b01.xhtml#sectionA.4)), but the bottom object is
    now clipped by it. To edit the clipping path (via its nodes or shape handles)
    without unclipping, click the corresponding toggle in the Node tool's controls
    bar, as shown in [Figure 18-7](#fig18-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-clip.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-7: Applying clipping to a bitmap object'
  prefs: []
  type: TYPE_NORMAL
- en: At any time, you can do Object ▶ Clip ▶ Release to remove the clipping and get
    the object and its clipping path as two separate objects again.
  prefs: []
  type: TYPE_NORMAL
- en: The clipping path can be a group of paths or shapes, not a single path or shape.
    It makes more practical sense, however, to have a group as the clip target, not
    as the clipping path. When you clip a group, you can always enter it ([4.9.1](c04.xhtml#section4.9.1))
    and work inside, adding more objects, moving them around, or perhaps replacing
    the original object you intended to clip with a different one—all without releasing
    the clip. That's why I recommend, even if you have a single bitmap you want to
    crop, to group it first with itself and then clip that group, not the bare bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.2 Masking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Masking is similar to clipping. You select the object and the mask and chooseObject ▶ Mask ▶ Set
    to mask it, or Object ▶ Mask ▶ Release to remove the mask. However, with clipping,
    an object is limited to the interior of the clipping path; any properties of the
    clip, such as opacity, fill color, stroke, or blur, have no effect on clipping.
    Clipping is *binary*: at any point, the clipped object is either visible or not.
    Masking, on the other hand, is *gradual*—it may make an object *partially* transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the rule to remember: in a mask, *black* makes the masked object*transparent*
    (invisible), and *white* makes it *opaque* (visible). A 50 percent gray or 50-percent-opaque
    white makes the masked object semitransparent, but 50-percent-opaque black works
    just the same as fully opaque black (makes the object invisible). Any points not
    covered by the mask, or where the mask is 100 percent transparent, are not visible
    in the masked object. In other words, to make the object visible, the mask must
    have*visible lightness*: an opaque white mask gives 100 percent visibility, while
    anything darker or more transparent produces less than 100 percent visibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, masking is most useful with gradients or blurring. For example, you
    can blend a photo strip with the background using a linear gradient mask, or feather
    the edges of a photo cutout using a blurred mask ([Figure 18-8](#fig18-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-mask.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-8: Masking a bitmap object'
  prefs: []
  type: TYPE_NORMAL
- en: The Node tool has another button for editing the mask of the selected object.
    However, this being the Node tool, that button only allows you to node-edit the
    single path or shape of the mask—you can't change its color, gradient, or blur;
    for this, you need to release the mask and set it again after changing.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with a clipping path, both a mask and a masked object can be groups.
    It makes sense to use masking on a group, even if it's a single-object group at
    first, because you can enter that group and work inside it without removing the
    mask.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3.3 Bitmap as Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your imported bitmap to remain a rectangle and you only want to
    shave off some margins, you can turn it into a *pattern* ([10.8](c10.xhtml#section10.8))
    by pressing Alt-I. This does not change the visible display but converts a rectangular
    bitmap (it must not be rotated or skewed for this to work properly) into a rectangle
    object ([11.2](c11.xhtml#section11.2)) with a pattern fill displaying the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: This method is convenient because you can edit the shape or path and its bitmap
    fill at the same time ([Figure 18-9](#fig18-9)). If you resize the rectangle via
    its two corner handles—for example, with the Node or Rectangle tool ([11.2.1](c11.xhtml#section11.2.1))—it
    doesn’t affect the fill, which means you can crop it by moving the rectangle handles
    inward. At the same time, you can use the pattern's three handles to move, scale,
    and rotate the pattern, as described in[10.8.2](c10.xhtml#section10.8.2). (Initially,
    the pattern handles coincide with the rectangle handles; drag the X-shaped handle
    in the top-left corner to separate them.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-pattern.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-9: A bitmap as a pattern in a rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: After you convert your bitmap to a patterned rectangle, you can convert it to
    path with Shift-Ctrl-C and node-edit the result, or intersect ([12.2](c12.xhtml#section12.2))
    the rectangle with another path. Transforming, by default, affects both the shape/path
    and its pattern fill; see [6.11](c06.xhtml#section6.11) for how to change that.
  prefs: []
  type: TYPE_NORMAL
- en: 18.4 Retouching and Patching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple bitmap editing tasks, such as hiding defects or suppressing unnecessary
    details, are possible in Inkscape using its vector tools, without resorting to
    an external bitmap editor. While this approach is limited, it is often surprisingly
    useful and fast.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you need to remove a small blemish in a photo. Start by zooming in closely
    and drawing a calligraphic stroke over it. Then, switch to the Dropper tool and
    pick a color from the photo nearby to assign it to the newly created path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, this may be all you really need—even such a primitive patch
    may blend well enough to become invisible once you zoom out. More likely, however,
    the edges of the patch will still be noticeable on at least one side. The next
    step is, therefore, a gradient: switch to the Gradient tool ([10.1](c10.xhtml#section10.1)),
    draw a linear or elliptic gradient trying to match the dominant direction of color
    change in the background, and use the Dropper tool again ([8.8](c08.xhtml#section8.8))
    to pick colors for the gradient stops. If the gradient fails to make the patch
    completely blend into the background, see if a little blurring can help, as shown
    in [Figure 18-10](#fig18-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-retouch.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-10: Covering a small blemish on the cheek with a vector patch path,
    made "invisible" by gradient and blur'
  prefs: []
  type: TYPE_NORMAL
- en: When these simple methods aren't good enough, try the new Mesh Gradient tool
    ([10.7](c10.xhtml#section10.7)) with automatic color picking for the mesh nodes
    ([10.7.5](c10.xhtml#section10.7.5)) to create a more complex or extensive patch.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done retouching, don't forget to group the bitmap object with all
    its vector patches so the group can be moved as a single object.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5 Tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a vector editor, two crucial bitmap-related capabilities are converting
    a bitmap to vector objects (*tracing*) and vice versa (*bitmap export*). Inkscape
    offers rich and powerful tools for these conversions, which the rest of this chapter
    explores in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.1 Manual Tracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of tracing a bitmap does not involve any tools other than those you
    already know. Just switch to the Pen tool ([14.1.1](c14.xhtml#section14.1.1)),
    zoom in on your bitmap, and do a series of clicks around or along an area that
    you want to turn into a vector path ([Figure 18-11](#fig18-11)). Use click-and-release
    in a sharp corner to create a cusp node; for smooth curved edges, make a series
    of short click-and-drags along the curved line. Vary the density of your clicks
    depending on how precisely you want to trace a specific area. Double-click, press
    Enter, or click the starting node to finish the path.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-manual.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-11: Tracing a bitmap manually using the Pen (in the default Bézier
    mode)'
  prefs: []
  type: TYPE_NORMAL
- en: For extra smoothness, you can trace in Spiro or BSpline modes ([14.1.4](c14.xhtml#section14.1.4));
    in those modes, any click creates a smooth node, and for a cusp node, do a Shift-click.
    Also, in the BSpline mode, remember to click not on the curve itself but a little
    outward on its curved side, so that the smooth path is inscribed into the polygon
    you create with your clicks. If you're tracing art without any curves at all,
    use the Straight lines mode so that an accidental drag does not create a smooth
    node you don't need.
  prefs: []
  type: TYPE_NORMAL
- en: This technique may seem tedious and time-consuming at first, but once you get
    the hang of it, you will be able to trace complex art surprisingly quickly. Like
    any manual technique, its main advantage is the complete creative control—you
    decide what parts to trace and what to ignore, how to simplify complex shapes,
    where to diverge from the bitmap, and where to place each node. Depending on your
    skill, the result may look more satisfying than either an automatic trace or a
    completely manual drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2 The Trace Bitmap Dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inkscape's tool for automatic bitmap tracing, based on the stand-alone Potrace
    open source tracer ([http://potrace.sourceforge.net/](http://potrace.sourceforge.net/)),
    is very powerful. With it, you can trace anything from a simple black-and-white
    logo that needs just a few nodes to a complex photo that produces dozens of colored
    paths with thousands of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Trace Bitmap dialog (Shift-Alt-B, [Figure 18-12](#fig18-12)) has two main
    areas: the options panel on the left and the preview panel on the right. What
    the preview panel shows is not the traced vector path (that might be time-consuming
    to create) but the bitmap as it will be fed to the tracer—with all the color reduction
    and filtering preprocessing as specified in the options panel. To update the preview
    after the options change, click **Update**. Note that the dialog always shows,
    and the tracer always traces, a complete bitmap even if it is clipped, masked,
    or otherwise obscured in the document.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracedialog.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-12: The Trace Bitmap dialog'
  prefs: []
  type: TYPE_NORMAL
- en: To perform the actual trace of the selected bitmap object, click **OK**. For
    a large bitmap, this may be slow; watch the status bar for progress messages.
    You can interrupt tracing by clicking the Stop button; Revert resets the options
    to defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The tracing tool has several modes of operation. These modes are divided into
    *single-scan modes* that create a single path from an image and *multiple-scan
    modes* that create multiple paths (grouped together).
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2.1 Brightness Cutoff
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Brightness cutoff is the simplest approach to tracing a path. The resulting
    path covers anything that is darker than the threshold you set. This trace path,
    while a single object, can consist of multiple nonoverlapping subpaths ([12.1.1](c12.xhtml#section12.1.1)).
    This is the best tracing mode for simple monochromatic shapes such as logos, text,
    vignettes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Threshold is set as a fraction of the image's complete brightness range
    ([Figure 18-13](#fig18-13)). For example, at 0.6, the trace path covers the areas
    that are darker than 60 percent of the image; the Invert checkbox inverts the
    threshold so the path will cover the brightest 40 percent of the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracecutoff.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-13: Brightness cutoff tracing with different threshold values'
  prefs: []
  type: TYPE_NORMAL
- en: The Autotrace mode is another brightness-cutoff mode powered by a different
    tracing backend, Autotrace, instead of the Potrace backend other modes use. In
    this mode, you can't set the threshold, but the default might just work for you,
    as [Figure 18-14](#fig18-14) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracecutoff-autotrace.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-14: Brightness cutoff tracing with different threshold values'
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2.2 Tracing Quality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even if the bitmap you're tracing is itself a rendition of a vector path, the
    trace will never exactly reproduce that original path. Converting a vector shape
    into a bitmap always incurs loss of information, and Inkscape's tracer cannot
    restore this lost information other than by guessing. Generally it's pretty good
    at it, but there will be cases—especially when tracing low-resolution bitmaps
    or those containing text—where you will be disappointed by its failure to recognize
    features (arcs, straight lines, corners) that you can easily see in the bitmap,
    as shown in [Figure 18-15](#fig18-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracequality.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-15: Some common quality problems with bitmap tracing'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best piece of advice in this situation is to get your bitmap at the highest
    possible *resolution*. It''s very hard to get a decent trace from a bitmap whose
    crucial features are several pixels across; tracing a higher-resolution version
    of an image often makes a huge difference. Also, you can try to adjust the Threshold
    and experiment with the Options at the bottom of the dialog (these options apply
    to all modes, both single-scan and multiple-scan):'
  prefs: []
  type: TYPE_NORMAL
- en: The Speckles option removes any color blobs that are smaller than the specified
    number of pixels across. This suppresses small superfluous subpaths when tracing
    dirty or dithered bitmaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the Smooth corners parameter makes the trace algorithm less inclined
    to recognize sharp corners in the image. This may be useful when tracing a naturally
    smooth shape from a highly pixelated, low-resolution bitmap where you don't want
    accidental pixel cusps to become sharp corners in the traced path. Conversely,
    lowering this parameter is appropriate when you are tracing geometric shapes without
    any curved lines. When Smooth corners is zero, the resulting path consists almost
    entirely of straight line segments with cusp nodes between them (but corners may
    still be chamfered).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Optimize paths parameter tries to reduce the number of nodes in the trace
    path, much like the Simplify command does ([12.3](c12.xhtml#section12.3)). Raising
    this value decreases the number of nodes you get but also increases the chance
    of introducing visible distortions or losing the details of your shapes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.5.2.3 Other Single-Scan Modes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Edge detection mode applies the edge detection filter to the bitmap before
    tracing it. As a result, the trace path will contain narrow strips that follow
    the color boundaries in the source bitmap. The lower the Threshold is, the more
    edges will be detected and traced.
  prefs: []
  type: TYPE_NORMAL
- en: The Color quantization mode first quantizes (divides) the image into the given
    number of areas (Colors), each with its own dominant color, much like when reducing
    a full-color image to a fixed palette in a bitmap editor. It then traces *every
    other* such area, which typically makes color gradients appear striped, as [Figure 18-16](#fig18-16)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-traceedges.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-16: The Edge detection and Color quantization modes'
  prefs: []
  type: TYPE_NORMAL
- en: Very visually interesting is the Centerline tracing option provided by Autotrace.
    It's a bit similar to Edge detection but creates a stroked path, not stroke-like
    strips. In the areas where there are no well-defined edges, this mode creates
    a charming geometric pattern with a predilection for diagonals, as shown in [Figure 18-17](#fig18-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracecenterline.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-17: The Centerline tracing (autotrace) mode'
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2.4 Multiple-Scan Modes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like the single-scan Color quantization mode, each multiple-scan mode starts
    by quantizing the image into the given number of areas (theScans parameter). It
    then traces each area separately, assigns an appropriate color or gray level to
    the trace path, and groups all the paths together. With enough scans, the result
    for a high-resolution bitmap may look pretty decent—faithfully reproducing the
    color gradients, blur, natural textures, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: TheBrightness steps mode is the best for grayscale images; it ignores any hue
    or saturation differences and groups pixels into areas based solely on their brightness
    ([Figure 18-18](#fig18-18)). The Colors mode considers all aspects of the colors
    when performing quantization, which results in the most faithful reproduction
    of full-color images (see [Figure 16 in the color insert](c15b.xhtml#ill-fig16)).
    Finally, the Grays option works the same as Colors, except the resulting paths
    are painted with approximating shades of gray instead of the original colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracemulti.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-18: Multiple scans: 10 brightness steps'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Smooth option applies a certain amount of blur to the image before quantizing
    it; this may produce better results in complex photographic images. TheStack scans
    option is best kept on: it makes sure that each area''s path covers not only that
    area but also all areas below it in z-order, which means there will be no gaps
    between the scans, as shown in [Figure 18-19](#fig18-19).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracestack.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-19: Stacking scans vs. abutting them'
  prefs: []
  type: TYPE_NORMAL
- en: The Remove background option simply removes the bottommost scan path from the
    group. This is useful when you are tracing a photo of something on a flat-color
    background and want to have the vector representation of the object only without
    the background.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2.5 Object Extraction with SIOX
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SIOX stands for "Simple Interactive Object eXtraction"; this is an algorithm
    that assists you in separating a foreground object from the background in an image.
    In Inkscape, it is a preprocessor applied to an image before it is traced (using
    any mode) when you turn on the SIOX checkbox next to the Update button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The "Interactive" part of SIOX suggests, however, that it cannot do its magic
    fully automatically but needs some help. For SIOX to work, you must have two objects
    selected: the bitmap and, on top of it, a mask path that identifies the foreground
    object you''re interested in. That mask path can be pretty crude, but it must
    cover the entire foreground object and some minimal amount of background around
    it. The result of a SIOX scan is rarely perfect (in [Figure 18-20](#fig18-20),
    bits of background still need to be cleared away around the cat), but it''s a
    good starting point that you can get to very easily.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracesiox.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-20: Using the SIOX option to extract a foreground object during tracing'
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.2.6 Pixel Art Tracing [1.1]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inkscape has yet another tracing backend called *libdepixelize* designed for
    vectorizing low-resolution bitmaps where meaningful features can be as small as
    single pixels and there's little to no anti-aliasing. Such images, usually called
    *pixel art*, were the norm in computer games of the low-resolution era but, surprisingly,
    remain a popular subgenre of digital art even today.
  prefs: []
  type: TYPE_NORMAL
- en: Inkscape is not the best application for creating pixel art, but the Pixel art
    tab of its Trace Bitmap dialog makes it one of the best for reusing some old (or
    new) pixel art in your vector designs. This doesn't mean simple re-creating a
    bitmap's pixels as square paths; if you need that, just import your bitmap with
    the Blocky option ([18.2.3](#section18.2.3)) and use it as is without tracing.
    Instead, Inkscape's pixel art tracer attempts to infer and re-create the shapes
    the pixel art author had in mind—from their pixel approximations. As improbable
    as that sounds, the results are often very satisfying. For example, where two
    same-color pixels are diagonally adjacent, the pixel art tracer is smart enough
    to deduce they are a single feature and melt them together in the output, as demonstrated
    in [Figure 18-21](#fig18-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-tracepixel.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-21: Using the pixel art tracer'
  prefs: []
  type: TYPE_NORMAL
- en: The default Voronoi option of the pixel art tracer is usually the best; the
    grouping of polygons it creates is known as a *Voronoi tessellation* (named after
    a 19th-century Russian mathematician). The other output option, B-splines, tries
    to further smooth out the shapes of the Voronoi polygons, but the result is usually
    not as neat. For comparison, [Figure 18-21](#fig18-21) also shows what the regular
    Potrace color tracer would do to the same pixel art image.
  prefs: []
  type: TYPE_NORMAL
- en: The options in the Heuristics section are best left to their defaults. If you
    want to learn more about the algorithm used by the pixel art tracer and about
    what these options can give you, start with the tutorial at [https://inkscape.org/doc/tutorials/tracing-pixelart/tutorial-tracing-pixelart.html](https://inkscape.org/doc/tutorials/tracing-pixelart/tutorial-tracing-pixelart.html)
    written by the authors of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6 Bitmap Export
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, Inkscape's SVG files are often used on the web directly, thanks to
    web browsers' support for SVG. Still, ours remains a bitmap-dominated world, so
    the quality of rasterization and the bitmap export capabilities are crucial for
    a vector editor.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1 The Export PNG Image Dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the Export PNG Image dialog (Shift-Ctrl-E) to export your drawing or any
    part of it into a PNG file at any resolution. The dialog''s areas, top to bottom,
    allow you to select:'
  prefs: []
  type: TYPE_NORMAL
- en: The canvas area you want to export ([18.6.1.1](#section18.6.1.1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pixel size of the bitmap ([18.6.1.2](#section18.6.1.2))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename of the export file and its format ([18.6.1.3](#section18.6.1.3))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional export options ([18.6.1.4](#section18.6.1.4))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export format parameters ([18.6.1.5](#section18.6.1.5))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.6.1.1 Export Area
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the area you want to export, you have four main options at the top of the
    dialog:Page, Drawing, Selection, and Custom ([Figure 18-22](#fig18-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-export.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-22: The Export PNG Image dialog'
  prefs: []
  type: TYPE_NORMAL
- en: The Page button exports the page of your SVG document, as visualized by the
    frame on the canvas ([2.3](c02.xhtml#section2.3)), but any objects beyond the
    edges of the page are excluded. The Drawing button exports the bounding box of
    the entire visible drawing (hidden layers or objects don't count), which can be
    smaller or larger than the page; the page frame is not visible in the exported
    bitmap. When the Selection button is pressed, the dialo`g exports the bounding
    box of the current selection (again, it can be inside or outside the page frame—this
    does not matter).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can click Custom and type your own document coordinates for
    the top-left corner (x0, y0) as well as either the bottom-right corner (x1, y1)
    or the width and height of the export area. You can also choose the measurement
    unit for these values (the default is `px`, [A.6](b01.xhtml#sectionA.6)).
  prefs: []
  type: TYPE_NORMAL
- en: The Export PNG Image dialog is not modal—that is, you can keep working on the
    canvas while it is open. Unless you choose Custom, the dialog responds to changing
    the selection by switching to the Selection mode and updating the coordinates
    to match the bounding box of the new selection. If nothing is selected and you
    are not in Custom, the dialog defaults to the Drawing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1.2 Image Size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the Image size, type the width and height in pixels (here, it is bitmap
    pixels, not px units), or adjust the resolution value of dpi, which stands for
    *dots* (that is, pixels) *per inch*. The default resolution of 96 dpi results
    in one SVG px unit translating to one pixel of the rendered bitmap. The horizontal
    and vertical DPI values are always the same; changing any one of the three editable
    values (Width, Height, dpi) changes the other two to match.
  prefs: []
  type: TYPE_NORMAL
- en: If your drawing contains some px-sized objects (such as strokes a whole number
    of px wide) and you want them to export precisely into the pixels of the bitmap,
    it may not be sufficient to choose the resolution of 96 dpi. For example, a 1×1
    px square in SVG might fall on a boundary between pixels in an exported bitmap
    and thus would end up smeared into four adjacent pixels instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: One way to fix this is by applying the Pixelize filter ([17.4](c17.xhtml#section17.4))
    to the exported objects. Another is to suppress anti-aliasing in PNG export options
    ([18.6.1.5](#section18.6.1.5)). Both those methods work, but you may find that
    your single-pixel features disappear or get snapped to a wrong pixel position
    in export. To fix this properly, you need to put in some more work. Enable the
    grid ([7.2](c07.xhtml#section7.2)) and snap your objects to the default 1 px-sized
    grid (or use the Pixel Snap extension, [13.4.2.6](c13.xhtml#section13.4.2.6)).
    Make sure your export area is itself aligned to the grid—that is, it has integer
    x0 and y0 coordinates when measured in px. After that, exporting at 96 dpi will
    give you a perfectly crisp image with no unwanted anti-aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1.3 Export Filename and Format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the Filename, you can type or paste a complete path to the file or click
    the Export As button to access your filesystem and choose a folder and a file.
    If you've already exported this object or the whole page, Inkscape will try to
    fill in the filename automatically for you ([18.6.1.4](#section18.6.1.4)). If
    the file exists, you will be asked if you want to overwrite it.
  prefs: []
  type: TYPE_NORMAL
- en: '[1.1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a long time, PNG was the only export format Inkscape supported. By default,
    Inkscape still exports to PNG; the PNG format preserves the maximum rendering
    quality Inkscape is capable of, including alpha transparency, anti-aliasing, and
    RGB color with 8 bits per channel. Since version 1.1, you can also export to some
    other formats: JPG (lossy), WebP (lossy or lossless), and TIFF (lossless), as
    well as optimized PNG (lossy or lossless). Choose one of these formats from the
    **Save as type** list in the **Export As** filename chooser, or simply append
    the corresponding extension to the filename (.jpg, .webp, or .tiff; you cannot
    select optimized PNG by extension).'
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1.4 Export Hints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you're exporting a single selected object, the export filename and resolution
    are remembered and stored in that object's node in the SVG document (so you may
    need to save once you're done with the export). These values are then restored
    into the Export PNG Image dialog whenever you select this object to export again.
    Similarly, the filename and resolution are remembered when you're exporting the
    Page or Drawing.
  prefs: []
  type: TYPE_NORMAL
- en: These*export hints* are great time savers when you need to export multiple objects—for
    example, slices of a web page graphic— to multiple bitmap files. If you've done
    this once (and saved your document after that), just select your objects with
    the Export PNG Image dialog open and you will see their saved export filenames
    in the Filename field. For the same reason—to make it easier to export multiple
    objects one by one—the dialog stays open even after you click Export (although
    there's also a Close when complete checkbox under the Filename field).
  prefs: []
  type: TYPE_NORMAL
- en: You can speed up the process even more by selecting all objects you want to
    export and checking the Batch export all selected objects checkbox. Now, when
    you click Export, Inkscape will create one bitmap file per selected object. If
    an object has already been exported before—that is, has the filename and resolution
    hints saved—those values will be used for it; otherwise, a name for the bitmap
    file will be constructed from the object's ID (for example, text2402.png, see
    [A.9](b01.xhtml#sectionA.9)), and the file will be placed in the folder where
    your SVG document was last saved.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, even if you are exporting a selection, you are actually exporting
    an area—the bounding box of the selection—which may contain other visible objects.
    Checking the Hide all except selected checkbox ensures that the exported bitmap
    will contain *only* the exported objects, while all others, even if they overlap
    the export area, will not be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1.5 Export Format Parameters [1.1]
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inkscape allows you to adjust various parameters of export formats. There is
    no preview window, but if you want to try different parameter values and see the
    result at once, use this trick. Export your object and then import it back into
    Inkscape, placing it next to the object or area you're exporting. Now, you can
    export it over and over to the same file with different options, and Inkscape
    will reload the newly exported file each time, displaying the effect of your settings
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1.5.1 PNG
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the dialog's Advanced section (collapsed by default), you can set some format
    options for the regular PNG export (not optimized PNG).
  prefs: []
  type: TYPE_NORMAL
- en: Use interlacing creates interlaced PNGs which, when used on a web page, will
    display a lower-resolution version of the image before it is fully transmitted
    from the web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit depth controls how color is represented in the output PNG. The default value
    is `RGBA_8`, which means RGB color, Alpha channel (transparency), 8 bits per channel;
    this is exactly how color is represented in Inkscape's renderer, so this option
    stores the program's rasterization output optimally. You can trim the output by
    dropping the alpha channel (`RGB_8`) or by switching to grayscale with (`GrayAlpha_8`)
    or without alpha (`Gray_8`) and with any number of bits per channel, down to 1
    bit for a strictly black-and-white image (`Gray_1`). You can also use full-color
    representation with 16 bits per channel (`RGBA_16`), but since the renderer is
    still 8-bit, this will not actually increase the amount of information in the
    output (for example, if you're experiencing banding in gradients, this option
    will not reduce it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression sets the level of compression of the PNG file; the optimal value
    depends on the content of the file, so if you want to get the smallest possible
    PNG file, I recommend using external utilities like *pngcrush* on Inkscape's PNGs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pHYs dpi is the resolution value recorded in the PNG file; this value is rarely
    used, so there's no harm in leaving it at 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Antialiasing is actually a parameter of Inkscape's renderer (called Cairo),
    not of the PNG file. This is where you can either turn off all anti-aliasing (the
    `CAIRO_ANTIALIASING_NONE` option) or try to improve on the default `CAIRO_ANTIALIASING_GOOD`
    by choosing `CAIRO_ANTIALIASING_BEST`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 18.6.1.5.2 Other Formats
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For formats other than regular PNG, an Options dialog pops up after the progress
    bar is finished—that is, after Inkscape is done rendering the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: For JPG, you can set the Quality (1 to 100, default 90) and the Progressive
    option; when downloaded over a slow connection, a Progressive JPG file will show
    a low-resolution preview before the complete full-resolution image (this only
    makes sense for large images). WebP has a Lossless option and adjustable parameters
    for Quality and Speed. TIFF has onlyQuality and Speed parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For the optimized PNG format, you can turn on Interlaced (similar to JPG's Progressive
    option) and choose how many trials will be performed in an attempt to achieve
    the best compression for the image. On the Lossy Options tab of the Options dialog,
    you can enable various reductions (bit depth, color type, palette) that can make
    the image even smaller but also lower quality.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.2 Exporting via the Command Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the capabilities of the Export PNG Image dialog are also available when
    you run Inkscape from the command line. This way, Inkscape can be used as a GUI-less
    utility from scripts or programs to automate various SVG rendering jobs. For example,
    this is how you export an object with`id="text2402"` at 600 dpi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Exporting to formats other than PNG via command line does not work as of Inkscape
    1.1. For a complete list of Inkscape's command line switches, refer to [Appendix C](b03.xhtml#chC).
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.3 Icon Preview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While there's no preview pane in the Export PNG Image dialog, if you use Inkscape
    to create icons, one way to preview your work rendered to different icon sizes
    is via the Icon Preview dialog, which you can call from the View menu ([Figure 18-23](#fig18-23)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/icon-preview.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-23: The Icon Preview dialog'
  prefs: []
  type: TYPE_NORMAL
- en: This dialog contains previews of your document rasterized in a few typical icon
    sizes, from 16×16 to 128×128 pixels; in the left side of the dialog, one of these
    renderings is additionally displayed magnified so you can see how your vector
    objects translate to actual pixels. Click the **Selection** checkbox to switch
    the preview from showing the entire document to the current selection.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.4 Make a Bitmap Copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After you export something from your document, you can import ([18.1](#section18.1))
    the bitmap file back to check how rasterization worked. If, however, you need
    that bitmap in your document and not as a separate file, you can use Inkscape''s
    shortcut: the Edit ▶ Make a Bitmap Copy command.'
  prefs: []
  type: TYPE_NORMAL
- en: This command exports the selected objects (without saving the file) and imports
    the result as an embedded bitmap back to the document, overlaying it on top of
    the selection. You can set the export’s resolution on the Imported Images page
    of the Preferences; the default is 96 dpi, and for that value, the command will
    additionally snap the export area to the 1 px grid, making sure the pixels of
    the created bitmap align exactly with the boundaries of px squares, as shown in
    [Figure 18-24](#fig18-24).
  prefs: []
  type: TYPE_NORMAL
- en: '![](20/bi-copy.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-24: A 96-dpi bitmap copy of a path, aligned to the grid'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this command for a quick preview of how your art will rasterize
    (after which, the bitmap object can be deleted). It is also useful when you have
    some very slow-rendering filters ([17.6](c17.xhtml#section17.6)) but do not want
    to work in the No Filters or Outline modes; in that case, just make a bitmap copy
    of the filtered object and hide the slow-rendering original.
  prefs: []
  type: TYPE_NORMAL
- en: 18.7 Bitmap Filters and Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can apply Inkscape's filters ([Chapter 17](c17.xhtml#ch17)) to any kind
    of object, but they are perhaps most useful when you have a bitmap that is not
    editable with the standard vector tools. I especially recommend blend mode overlays
    ([17.2](c17.xhtml#section17.2)) and the preset filters ([17.4](c17.xhtml#section17.4))
    in theBlurs, Color, and Image Effects submenus. You should use filters whenever
    possible because they are nondestructive and do not change the original bitmap
    file you imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, you really do need to change the bitmap data itself. As
    mentioned above ([18.2.1](#section18.2.1)), with a linked image, you can just
    run your favorite bitmap editor on it, and you can even launch that editor from
    within Inkscape. This capability, however, is not available for embedded images.
    In those cases, extensions ([Chapter 19](c19.xhtml#ch19)) can help; a number of
    common bitmap processing algorithms have been implemented as extensions. Here
    are those that are most useful—and not (or not quite) achievable via filters—from
    the Extensions ▶ Raster submenu ([Figure 18-25](#fig18-25)):'
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive Threshold shifts each pixel to extreme values in each of the RGB channels,
    depending on whether that pixel is above or below a threshold. That threshold
    is calculated from that pixel's local neighborhood (whose size is defined by the
    Width and Height parameters). This is a valuable transformation, because it is
    similar to the way humans perceive images—we judge a point "light" or "dark" relative
    to its local area, not relative to the average lightness of the entire image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add Noise gives you a choice of various types of noise to overlay on your image;
    most types look more or less like scattered sand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crop is a way to reduce the size of an SVG with an embedded image—unlike clipping,
    it actually removes part of the bitmap data from the edges (you can specify how
    much to crop on each side).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despeckle, Enhance, and Reduce Noise implement various noise reduction algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dither randomly scatters pixels in a bitmap, with Amount specifying the radius
    of scattering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equalize applies histogram equalization to the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HSB Adjust adjusts the hue (in the range of –360 to 360), saturation (–200 to
    200), and brightness (–200 to 200).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implode, Swirl, and Wave smoothly distort an image more or less as their names
    suggest. Wave uses a horizontal sine wave with the given amplitude and wavelength.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level blackens pixels that are darker than the Black Point, whitens pixels brighter
    than the White Point, and scales those that fall within this range to the full
    color range. When the Black Point is greater than 0 or the White Point is less
    than 100, the extension increases the contrast of the image. Gamma Correction
    specifies additional brightness correction (1 means no change).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level (with Channel) is the same as Level but for a single channel only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Median paints each pixel with the median color of its circular neighborhood;
    the result is somewhat similar to blurring, but Median preserves sharp boundaries
    between colors that are too different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalize increases contrast by expanding the color range of pixels to the full
    range of color (for example, if the image has no reds, all colors will be tinted
    toward red to compensate for that).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oil Painting is similar to Median but additionally melts similar adjacent colors
    in a way that's reminiscent of paint strokes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resample changes the pixel size of the bitmap without scaling it. Resampling*up*
    does not change the appearance of an image, but it may be useful if you plan to
    apply some other effect and want it to work with higher resolution. Resampling
    *down* makes the image lose detail without changing its dimensions in the document;
    like Crop, this reduces the file size of an SVG document with an embedded bitmap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharpen and Unsharp Mask are the classic algorithms for sharpening an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](20/bi-effects.svg.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-25: Examples of extension effects from Extensions ▶ Raster'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike filters, extensions make permanent changes to the bitmaps they process.
    You can undo an extension but you cannot, for example, readjust its parameters
    after it is applied. Also, unlike filters, these extensions can work*only* on
    bitmap objects—you cannot, for example, apply a bitmap effect to a clone of a
    bitmap. If the bitmap is linked, these effects embed it and work on the embedded
    copy, not on the external linked original. Refer to [19.1](c19.xhtml#section19.1)
    for general tips on working with extension effects.
  prefs: []
  type: TYPE_NORMAL
- en: 18.8 Color Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Color management aims to ensure that the colors in your artwork are correctly
    translated between different output devices, typically from screen to print. The
    ranges of colors that can be reproduced are different for different devices, and
    some color distortions are unavoidable. Color management allows you to preview,
    control, and thereby minimize such distortions.
  prefs: []
  type: TYPE_NORMAL
- en: Inkscape has never claimed to be the best in class when it comes to color management.
    You can use screen-proofing to preview output colors, but you can't, using Inkscape
    alone, prepare a color-separated file for print with a color profile embedded.
    However, in most cases, you can get the result you need by employing some additional
    software, as described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in the years since the first edition of this book, the importance
    of color management has certainly diminished. These days, a lot more graphics
    go from screen to screen than from screen to paper. Also, consumer-grade computer
    screens and desktop color printers are now much more uniform in quality—and most
    desktop printers will accept and print the same RGB data as is displayed on your
    screen, performing their own color conversion without you needing to do any extra
    work.
  prefs: []
  type: TYPE_NORMAL
- en: It's only when you intend to print your design on high-end commercial printers,
    usually by sending it to a print service provider, that you will need to look
    into Inkscape's color management facilities. Even then, some providers can perform
    color management on your documents for you if you ask them to. If you have sufficient
    control over this process (for example, can review the print proofs), this is
    usually the best option, because the print service staff knows what works best
    with their equipment.
  prefs: []
  type: TYPE_NORMAL
- en: 18.8.1 ICC Color Profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ICC color profile is a file that describes the color capabilities of an output
    device. If you want to prepare your document for outputting on a specific device,
    you must first obtain the ICC profile that exactly corresponds to this device
    and the output media (for example, the paper type used for printing). Sometimes,
    you can find an appropriate profile file on the internet (for example, on the
    website of the printer hardware's manufacturer), but typically, you would request
    it from the print service provider you will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get the destination profile, you need to install it into your operating
    system. On Windows 10, it's as easy as right-clicking an .icc file and selecting
    Install Profile. On Linux, you need to have *gnome-color-manager* or *colord-kde*
    installed; then, double-click the .icc file and click Import.
  prefs: []
  type: TYPE_NORMAL
- en: 18.8.2 Screen Proofing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the color range of a typical printer is narrower than that of a computer
    display, Inkscape can proof (preview) the print output on your screen by emulating
    the printer colors. This is called *screen proofing* or *soft proofing*. For this,
    you need to have two ICC color profiles: one for the printer you''re going to
    use and another for your screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should have your display *calibrated* using a special hardware
    device called *colorimeter*; this calibration creates a custom ICC profile of
    your display. Unless your quality requirements are truly demanding, however, you
    can probably make do with a generic RGB profile, such as the one that comes installed
    with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In **Preferences**, go to the **Input/Output ▶ Color management** page. Choose
    the display profile (if you have more than one) in the **Display adjustment**
    section. Then, in the **Proofing** section, check **Simulate output on screen**
    and choose the **Device profile** of your target device (that is, the printer
    on which you're planning to print your artwork). After that is set up, toggle
    the color-managed view via **View ▶ Color-Managed View** or the little toggle
    button in between the vertical and horizontal scroll bars in Inkscape's editing
    window.
  prefs: []
  type: TYPE_NORMAL
- en: For both screen and target device profiles, you can also choose Device rendering
    intent. The default Perceptual is the best choice in most cases; if you want the
    output to look as color-rich as possible (for example, when printing simple business
    graphics), try Saturation.
  prefs: []
  type: TYPE_NORMAL
- en: If a screen color is "out of gamut"—that is, cannot be rendered on the output
    device at all—you can make it immediately visible by designating an out-of-gamut
    marker color. For example, if your design has no reds, check **Mark out of gamut
    colors** and choose red for **Out of gamut warning color**. Then, wherever you
    see red in your drawing, you'll know you need to change the actual color of that
    object (which is shown in the status bar or in the Fill and Stroke dialog—the
    red mark is only in the drawing) if you want it to print without gross distortions.
  prefs: []
  type: TYPE_NORMAL
- en: 18.8.3 Separating and Embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Screen proofing is helpful, but it may not be enough—you may be required to
    produce a file already converted to the target color system. Such files are often
    called*color-separated* because they contain the separate color channels (usually
    CMYK,[8.4.2](c08.xhtml#section8.4.2)) corresponding to the inks of the output
    device. Such a file may also have the target color profile embedded into it. The
    most commonly used formats are PDF (vector) and TIFF (bitmap); both can contain
    color-separated data and embed ICC profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Although it can export PDF and PNG, Inkscape cannot do color separation or profile
    embedding. You need some other software to do the job for you, such as Adobe Photoshop
    (for TIFF) or Illustrator (for PDF); both can import Inkscape's SVG format directly.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use open source software. The Scribus page layout program ([http://scribus.net/](http://scribus.net/))
    will import SVG and create color-separated PDFs; starting from Inkscape 1.0.1,
    you can set up PDF export via Scribus from Inkscape's Save dialog (see the Inkscape
    1.0.1 Release Notes for details). The Cyan plug-in for GIMP ([https://github.com/rodlie/cyan/](https://github.com/rodlie/cyan/))
    will take Inkscape-exported PNG bitmap and convert it into a color-separated TIFF
    with screen proofing for complete control.
  prefs: []
  type: TYPE_NORMAL
