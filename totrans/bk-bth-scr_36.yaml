- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 33 STACKS, QUEUES, AND REAL-WORLD OBJECTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, I’ll build two more Batch data structures from scratch: stacks
    and queues. Both hold a finite set of ordered values, with the only difference
    being that stacks fit the last-in-first-out paradigm, while queues are first-in-first-out.
    I’ll detail both data structures in general and demonstrate how to build their
    unique functionalities. And of course, you’ll learn applications of these new
    tools, even a Batch pseudo-compiler of other bat files.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this chapter is as much about real-world Batch objects as it’s about
    stacks and queues. I’ll also use what you learned in the previous chapter to construct
    object bat files for each data structure. The objects will allow you to maintain
    multiple stacks or queues simultaneously, and they’ll ideally inspire future real-world
    Batch objects of your own. I’ll even finish up with final thoughts on Batch object-oriented
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *stack* is a data structure containing an ordered list of data items, organized
    as *last-in-first-out (LIFO)*. Undoubtedly, the best metaphor for a stack is a
    spring-loaded cafeteria plate dispenser. The weight of each plate pushes down
    a spring at the base of the dispenser so that only the top plate in the stack
    is available. Add more plates and the stack drops down so that only what’s now
    the top plate is poking up. The first plate added is at the bottom of the stack,
    and the first one retrieved is the last one added to the top of the stack. You
    can’t access a plate lower on the stack without first removing the plates above
    it, one by one. Take that top plate and the stack rises the height of a single
    plate, exposing the one that was just underneath it, while protecting the rest
    from the clumsy and possibly unhygienic hoi polloi.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can add or *push* a data item onto a stack, followed by more
    data items. At any point, you can retrieve or *pop* the data item at the top of
    the stack—that is, get the item added most recently. Most object-oriented languages
    come with a built-in stack data structure with methods for pushing an item onto
    the stack, popping the last item, and peeking at the last added item without actually
    removing it. There should also be methods to clear the stack and to determine
    whether the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Batch has no such built-in data structure, but if you’re still with me in this
    final chapter, I’ll assume that you also enjoy the challenge of creating atypical
    Batch functionality. The underlying structure of the stack in Batch is merely
    a single variable. To push the first value onto a stack, we’ll simply assign it
    to the stack variable. Then we’ll push subsequent items onto the stack by prepending
    to that variable, pushing the existing items down the stack.
  prefs: []
  type: TYPE_NORMAL
- en: To execute a pop request, we’ll extract the leading item in the variable from
    the contents of the variable, leaving the rest. A peek request will be similar,
    except we’ll leave the stack undisturbed. To make this work, we’ll need a delimiter
    between each item guaranteed not to be in the data. Spaces, pipes, and commas
    are good options, depending on the expected data, but my preference is the tab
    character. If it’s possible that your data might have tabs, you should choose
    something else as the delimiter; it can even be a variable itself set by the user.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the different pieces of functionality needed to implement a stack,
    I’ll construct and use a stack of friends. The first task is to come up with a
    variable name; any will do, but I’ll use the stkFriends variable. My convention
    is to prepend the name of the stack with stk, making it clear to anyone that stumbles
    across it (who also happens to know this convention) that the variable is the
    manifestation of a stack. In short order, I’ll bring all of this functionality
    into an object, but first I’ll step through the methodology for the push, pop,
    and peek functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical place to start is with the *push*, and this solitary set command
    is all you need to push Walter onto the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, as well as in future listings, I’m using a solid arrow to represent the
    tab character. By default, it is indistinguishable from one or more spaces in
    most editors, but if using Notepad++, you can show tab characters as arrows by
    selecting **View** ▶ **Show Symbol** ▶ **Show Space and Tab**. (Other editors
    have a similar feature, and if you’ve gotten this far into the book using Notepad,
    you are clearly a glutton for punishment.)
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the stkFriends variable twice in the command, assigning it to itself,
    resolved with percent signs and prepended with the item I’m adding, Walter, and
    the delimiter, a tab character. This has, in effect, added the value to the top
    of the stack. Instead of the hardcoded data item, you can easily use a resolved
    variable in its place for the friend being added.
  prefs: []
  type: TYPE_NORMAL
- en: If the stack is already empty, this command populates it with its first value,
    followed by a tab and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: '**Peek**'
  prefs: []
  type: TYPE_NORMAL
- en: The *peek* function finds the item on the top of the stack without altering
    the stack. It just takes a peek, without popping. We don’t know how many values
    are on the stack, if any at all, but we do know that if stkFriends is populated,
    its first tab-delimited value is at the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code populates aFriend with whatever’s on top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The parsing of delimited data is clearly a job for the for /F command. I’m using
    the stack variable as text input, and since we’ve delimited the variable by tabs,
    I’m setting the delims keyword to a tab. The tokens=1 clause is implied, meaning
    that the for variable defined as %%s resolves to the first token in the string,
    and since that first token is the last item placed onto the stack, we’ll simply
    capture it as aFriend.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that I’m wiping out the aFriend variable prior to the for command.
    If the stack is empty, the for /F command doesn’t execute, so initializing the
    variable ensures that an empty stack returns a null value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pop**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pop* function is remarkably similar to the peek function with one significant
    difference; it also removes the returned data item from the top of the stack.
    Notice that the logic for this task mimics the previous listing with two additions:
    the tokens clause and the final set command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the implied tokens clause, I’m setting the keyword to 1*. This
    has no impact on the for variable, %%s, itself. It still resolves to the top item
    on the stack, but now the interpreter assigns the remainder of the text field
    to the second token, %%t. Since the rest of the text field is the entire stack
    minus the first item, I’m simply reassigning the abbreviated stack to the stack
    variable with the last set command. The entire process is analogous to breaking
    one square off the end of a chocolate bar and pushing the rest of the bar back
    into the wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stacks and queues go together like chocolate and peanut butter. At its core,
    a *queue* is the *first-in-first-out (FIFO)* version of a stack. (This is the
    same as last-in-last-out, but LILO has never caught on.) The metaphor for a stack
    took us to a cafeteria, but the metaphor for a queue takes us to a restaurant.
    If you’re the first to show up without a reservation at a busy time, the host
    staff will likely put your name at the top of a list. They’ll add others to the
    list, and when a table frees up, you’ll be sat first from the list. Each of the
    others on this list will move up and continue to wait their turn in order.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a truly horrible business idea. I’ll open a pancake restaurant, call
    it Stacks, and use a stack for those waiting for a table. The group that arrives
    just as we get busy is first onto the stack, where they’ll wait, perhaps patiently,
    as others are added to and removed from the stack (that is, sat). Even if there
    are 20 groups on the stack, the people who just showed up get the next table.
    Obviously, this is a far better application for a queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a queue in Batch is almost identical to implementing a stack.
    The one significant difference is that when adding a data item to the queue, you’ll
    want to append it to the end of the variable instead of prepending it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are also a couple of differences in nomenclature. First, because the variable
    represents a queue, I’ve changed its leading text from stk to que, but again,
    this is just one convention. Second, the terms *push* and *pop* make sense only
    when thinking about a stack, such as a plate dispenser. When adding and removing
    values from a queue, I’ll instead use the pedestrian yet accurate terms *add*
    and *remove*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Everything else is the same between the two data structures. Notice that the
    previous set command also uses the tab delimiter. The add and remove functions
    are respectively identical to the push and pop functions, other than the variable
    name, since both target the first delimited data item in the variable. In fact,
    they are so similar I’ll hold off showing you these functions until I build the
    queue object.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*We live in a finite world, and just as the cafeteria plate dispenser can accept
    only so many plates, Batch has a limitation pertinent to stacks and queues. A
    single variable can’t exceed 32,767 bytes, and since this design of stacks and
    queues relies on a single variable holding the entire data structure, the cumulative
    size of all data items and delimiters in a stack or queue can’t cross this threshold.
    For instance, you can store 16,383 one-byte values or 1,927 sixteen-byte values.
    For most applications, this is sufficient, but if it isn’t, you can instead build
    these data structures with an array and a pointer to keep track of the pertinent
    index.*'
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Batch Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 32](chapter32.xhtml), I explored Batch object-oriented design. I
    detailed a model that implemented every possible piece of functionality involving
    the four pillars of OOP, but in truth, that model isn’t representative of typical
    object bat files. Fortunately, the stack and queue offer instructive real-world
    examples of Batch objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ll show the stack object bat file, *oStack.bat*, in two parts, starting with
    the comments and mainline logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most striking difference between this code and the objects from the prior
    chapter is that I’ve replaced the “traffic cop” hiding private methods with a
    call command exposing all the methods as public.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 32](chapter32.xhtml), all object bat files had a for command containing
    the list of public methods, but the *oStack.bat* object bat file has only public
    methods. As a result, instead of maintaining a list, the call command directs
    the execution to the appropriate method, thus making all of the methods public.
    Since the second parameter is the name of the method to be called, I’m stripping
    it of possible double quotes and prepending it with a colon to create the name
    of the called label: :%~2.'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the stack is the first parameter coming into the bat file and also
    the first argument I pass to each of the methods. The second argument passed to
    each method is the third input parameter, and it has different uses dependent
    on the method. But instead of discussing this here, maybe I should instead just
    point you to the comments at the top of the bat file clearly delineating the parameters
    accepted by the object and its public methods.
  prefs: []
  type: TYPE_NORMAL
- en: The two pipes and the code block following the call command is a real-world
    application of conditional execution. (In [Chapter 28](chapter28.xhtml), I provided
    a detailed example of this technique, including why the cmd command at the top
    of the bat file is resetting the return code to 0.) The upshot is that if the
    object receives a valid method, it invokes that method successfully, and if the
    parameter is an invalid method name, this logic writes the error message to *Log.txt*
    and ends the execution. Thus, all methods are public.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we don’t have this conditional execution and error handling?
    It works perfectly fine if every call to the bat file passes a valid method name.
    However, if for the first argument someone errantly passes the homophone for Peek
    referring to a mountaintop, the interpreter writes the following to stderr, and
    the execution continues unabated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter neither finds nor calls the method, nor does it set the return
    variable, if applicable, resulting in unpredictable downstream results. Something
    like this deserves a hard abort to pique our attention, and that’s exactly what
    the conditional execution and rudimentary error handling is accomplishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the remainder of *oStack.bat* and its public methods mentioned in the
    prior comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I’ve already discussed the mechanism for the push, pop, and peek functionality
    in the “Stacks” section, and in this object, you’ll find the polymorphic version
    for each under the appropriately named label. For instance, the :Push method sets
    the stk%~1 variable in lieu of stkFriends. For this object to work with multiple
    stacks, it can’t explicitly reference a particular stack variable. Instead, it
    builds the name of the stack by resolving the first parameter and prepending it
    with the stk text before setting it to the concatenation of %~2, a tab character,
    and !stk%~1!. The second parameter is the value being pushed onto the stack, and
    the tab character is the delimiter. This command uses the stk%~1 variable a second
    time to retrieve the existing values on the stack, resolving the variable with
    exclamation marks and delayed expansion. Ultimately, this pushes the second parameter
    onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The :Pop and :Peek methods also make use of stk%~1 for setting and/or resolving
    the stack. The only other new feature in these methods is that I’m setting %~2
    to the return value because the second parameter for both methods is the name
    of the variable being returned.
  prefs: []
  type: TYPE_NORMAL
- en: For this to be a proper stack object, it must provide two more methods typical
    of this data structure in other languages. The first accepts the name of the stack
    as its only parameter and clears all data items from it. To complete the task,
    the :Clear method simply sets stk%~1 to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The other method returns a boolean that evaluates to true if the stack is empty
    or to false if anything is on the stack. The :IsEmpty method determines if stk%~1
    is defined. Depending on the result, it sets the second parameter to either true
    or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to use the stack object. These four calls add three friends
    to a new stack, with Marty being the last in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first call is probably unnecessary, but in the off chance that the stkFriends
    variable is defined, this initializes it. You can think of it as a constructor
    even though this design doesn’t have one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this multiple times, and the aFriend variable will come back as Marty
    every time because it peeks only at the data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This also returns Marty when called, but only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next pop invocation returns Donny, the value placed on the stack just before
    Marty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now only Walter remains on the stack. You can add two more friends, but Walter
    remains in the bottom position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Remember that arguments with embedded spaces need to be encased in double quotes
    and that *oStack.bat* handles them deftly with the use of tildes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The isEmpty call returns a boolean variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The bool variable resolves as false since there are three items on the stack,
    and this logic writes NOT Empty to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to start from scratch, we can empty the stack of all its data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Call the object again to invoke the isEmpty method, and it returns the boolean
    set to true.
  prefs: []
  type: TYPE_NORMAL
- en: The Queue Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since stacks and queues are so similar, I’m modeling the queue object on the
    stack object. But still, notice the many subtle differences and just one significant
    difference as you examine the complete contents of the stack object bat file,
    *oQueue.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I’ve changed the stk text leading the variable name to que for obvious reasons.
    The :Push and :Pop methods have given way to the :Add and :Remove methods, respectively,
    and the comments at the top of the object clearly reflect these changes. The significant
    alteration is in the set command ❶ that adds a data item to the queue in the :Add
    method. It now adds the value to the end of the line instead of the beginning,
    meaning that the first item in is the first item out.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of the method names are different, but the execution of this object
    should look familiar. Here’s an example of five calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last call returns aFriend populated with the value of Walter, the first
    data item added to the queue. Compare this to the stack object that returned Marty
    for a very similar call.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and Queue Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find applications for the queue object wherever there’s a need to process
    data in order. You might create a queue to hold a list of server names retrieved
    from a source, perhaps one or more files. Then as you remove each server from
    the queue, you can perform a particular task on that server. The task might be
    as simple as verifying that it’s up and running, or it might involve the creation
    of directories or complex file movements. What’s important is that the queue allows
    you to take each server in order.
  prefs: []
  type: TYPE_NORMAL
- en: With interactive Batch, you might ask the user for a list of multiple inputs.
    Instead of retrieving one piece of data, processing it, and then asking for another,
    you can ask for all of the data up front as you add all of it to a queue. Then
    the bat file can process each data item in order without another question.
  prefs: []
  type: TYPE_NORMAL
- en: Stack applications aren’t always as obvious, but when you need one, it’s usually
    the only adequate tool for the job. You can use a stack to reverse the order of
    letters or words looking for palindromes. Recursion is another application of
    a stack. With each recursive call, the interpreter pushes the current state of
    all variables onto a stack. You don’t have direct access to this stack, but after
    making too many recursive calls, the interpreter reports that the recursion has
    exceeded “STACK limits” ([Chapter 23](chapter23.xhtml)). That’s not a coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: Using a stack, you can even create a pseudo-compiler for bat files or other
    uncompiled source code. I don’t want to oversell this; proper compilers perform
    a number of tasks, and while we can go a long way toward performing just one of
    those tasks (the balancing of brackets), it won’t be bullet-proof. The concept
    behind this pseudo-compiler is that an open parenthesis needs a matching close
    parenthesis, just as curly and square brackets must come in pairs. They can be
    deeply nested, but a square bracket can’t close a curly bracket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the complete contents of *PseudoCompiler.bat*, a bat file that attempts
    to balance all sets of brackets in a bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At a high level, this bat file accepts one file to be pseudo-compiled as its
    sole parameter ❶. When this code encounters any type of open bracket (including
    parentheses), it pushes the character onto a stack ❺. Then whenever it sees a
    close bracket of any type, it pops the last open bracket off the stack ❽ and looks
    to see if they are a matching pair. If not, it aborts. When it’s done reading
    the bat file, it needs to verify that the stack is empty ❾, because if it isn’t,
    we must also abort because the input has at least one unclosed bracket.
  prefs: []
  type: TYPE_NORMAL
- en: A deeper dive demonstrates many techniques introduced throughout this book,
    and it’s always fun to deconstruct a four-level deep nested for command. After
    clearing the Compiler stack, the outer for /F command ❶ accepts the lone parameter,
    %~1, as its input and reads each record sequentially. You can pseudo-compile any
    bat file by dragging and dropping it onto *PseudoCompiler.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: The for /L command ❷ iterates through each of the first 100 bytes of the input
    record. Double quotes cause issues when resolved in later if commands, so the
    first if command ❸ adeptly filters out the offending character. I’m using two
    escape characters for the comparison, and another one in the next line, where
    I execute an optionless for command ❹ that passes each of the three possible open
    brackets into its code block. It treats the curly and square brackets as text,
    but I must escape the open parenthesis. If I find one of the three characters,
    I push the open bracket onto the stack ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Another for command ❻ is the driver for finding and handling instances of close
    brackets. It passes all three pairs of open and close brackets, delimited by a
    colon, into its code block, where the final /F command ❼ breaks each pair into
    two tokens. If the byte from the file I’m examining matches the second token,
    I’ve found a close brackets, so I pop the last added item off the stack ❽. If
    that byte is a null, the close bracket is an orphan, so the code aborts and writes
    a rudimentary message to the console. If instead the popped byte doesn’t match
    the corresponding start bracket, the abort message notes the mismatched brackets.
  prefs: []
  type: TYPE_NORMAL
- en: If we make it through the entire file without finding a mismatch, the trailing
    logic checks that the stack is empty of all brackets ❾ with the use of a boolean.
    If an orphan remains, the code aborts because there’s at least one unmatched open
    bracket. After clearing this last if command, the brackets have all balanced,
    and the code triumphantly reports the success ❿.
  prefs: []
  type: TYPE_NORMAL
- en: This code demonstrates a great use for a stack, but it has limitations and,
    as mentioned, is far from bullet-proof. First and foremost, it assumes that each
    record is 100 bytes or less. The error handling in general also leaves much to
    be desired. At the very least, it should track the line of the infraction.
  prefs: []
  type: TYPE_NORMAL
- en: As the interpreter processes each record, it resolves variables delimited by
    exclamation marks, so this routine doesn’t validate any variable names containing
    brackets (think arrays and hash tables). Such variables will likely resolve to
    nothing, but if the two bat files share any variables, that can also cause problems.
    For instance, when I attempted to recursively pseudo-compile *PseudoCompiler.bat*
    (by copying and pasting it onto itself), popped resolved to an open parenthesis,
    resulting in it incorrectly reporting a mismatch. This self-pseudo-compile also
    failed on the unpaired open brackets ❹ being treated as text data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with these limitations that accentuate the *pseudo* in pseudo-compiler,
    this is still a solid means of tracking down most missed parentheses and brackets
    in a typical bat file—and a great application of a stack. Notice that this bat
    file calls the stack object we built earlier for four distinct tasks: clearing
    the stack, pushing, popping, and determining if the stack is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As a final note on the nested for commands, notice that I’ve chosen descriptive
    for variables that don’t conflict with each other. I capture the entire record
    (%%r) and* *iterate through it with an index (%%i), grabbing individual bytes
    (%%b). Then I pass a pair (%%p) of brackets into a loop, breaking them up into
    the open bracket (%%x) and the implied close bracket (%%y). The last two might
    not be descriptive, but I’m limited because they must be consecutive alphabetical
    characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Batch Object-Oriented Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I could have discussed the stack and queue data structures without presenting
    them as objects. The methods in this chapter would have been routines inside of
    an ordinary bat file with hardcoded names for the data structures, but as important
    as stacks and queues are, this chapter is also about real-world object-oriented
    design.
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented example in the prior chapter ([Chapter 32](chapter32.xhtml))
    was pedagogical at its core. It showed as many aspects of Batch object-oriented
    design as possible, but the two objects in this chapter are examples of real-world
    Batch objects. When I code objects, they’re far more likely to resemble *oStack.bat*
    than *oMovie.bat* or *oComedy.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see the advantages of putting all of the stack-specific code
    into a single reusable and concise bat file—that is, an object. This allows you
    to code hundreds of future stacks with this one object without ever having to
    consider the details of how the stack itself is implemented. With this in mind,
    you can reconsider arrays and hash tables ([Chapter 29](chapter29.xhtml)), imagining
    an object for each with methods for adding elements, retrieving elements, and
    clearing all elements. Further imagine other methods for displaying the contents
    of the array or hash table, writing all elements to a file, or even sorting the
    elements of the array. If you’re feeling bold, you could even use the stack object
    in the array object to reverse the order of the array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world Batch objects implement only the functionality of OOP that’s needed
    to get a job done. In a strict object-oriented language, you can’t use an object
    until you invoke the constructor, but in Batch, for better or worse, you have
    more flexibility. The objects in this chapter don’t even have constructors. Since
    Batch is not a true object-oriented language, you’re free to use only the pieces
    of the OOP paradigm that you choose, and there’s no compiler to say otherwise.
    I could have created a constructor (it would’ve looked a lot like the :Clear method),
    but I left it out for no other reason than that I didn’t feel it was needed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also no inheritance in this chapter. You can easily use *oStack.bat*
    and *oQueue.bat* without it, and that’s exactly how I typically implement Batch
    object-oriented design, but you can always extend any object. Some future coder,
    maybe even you, might later build a child object inheriting from one of these
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you’re using the queue object to maintain a list of servers
    to be processed in some way, you might also need to look up an IP address for
    each or just verify that it’s on the network. You can encapsulate this new logic
    in an object that also inherits the data and methods from what would then become
    the *parent* queue object, while a procedural coder would resort to artlessly
    cloning the queue logic. (I hope that you can sense the great distain with which
    I typed that last clause.)
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also shown that you can maintain a list of public methods or simply expose
    all methods in an object as public. All of this shows the flexibility of Batch
    object-oriented design. You can use only the design elements that you want or
    need and not what you don’t want or need. If it makes sense to have a constructor,
    create one; otherwise, don’t. If nothing else, small bat files with narrowly focused
    tasks are ideal. I encourage you to use some or all of the Batch object-oriented
    design paradigm that I’ve shown in these last two chapters in your bat files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this final chapter, I detailed two new data structures, namely, stacks and
    queues, showing you how to push and pop (or add and remove) data items. You also
    learned how to peek at the next value, clear all values, and determine whether
    the data structure is empty. I shared a few ideas about stack and queue applications,
    even creating a pseudo-compiler. It isn’t perfect, but it’s very useful and nicely
    demonstrated how to use a stack.
  prefs: []
  type: TYPE_NORMAL
- en: I also took all that you learned about stacks and queues and wrapped it up into
    two real-world Batch objects. You learned how to construct similar objects, using
    only the components of object-oriented design that make sense to you, and how
    to invoke those objects. I hope you’ll make use of the stack and queue objects
    and look for future problems in need of an object-oriented solution.
  prefs: []
  type: TYPE_NORMAL
