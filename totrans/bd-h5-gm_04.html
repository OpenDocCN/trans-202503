<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Game Logic"><div class="titlepage"><div><div><h1 class="title"><a id="game_logic"/>Chapter 3. Game Logic</h1></div></div></div><p><a id="iddle1270" class="indexterm"/><a id="iddle1282" class="indexterm"/><a id="iddle1293" class="indexterm"/><a id="iddle1311" class="indexterm"/><a id="iddle1453" class="indexterm"/><a id="iddle1568" class="indexterm"/><a id="iddle1571" class="indexterm"/><a id="iddle1730" class="indexterm"/><a id="iddle1853" class="indexterm"/><a id="iddle1909" class="indexterm"/><a id="iddle1973" class="indexterm"/><a id="iddle2000" class="indexterm"/><a id="iddle2182" class="indexterm"/>At this point, we’ve created an intro screen with a New Game button and a single bubble that a player can fire off the screen. In this chapter, we’ll turn the <span class="emphasis"><em>Bubble Shooter</em></span> into more of a game. You’ll learn how to draw the game board and display the level to the player, and then learn about collision detection.</p><p><span class="emphasis"><em>Collisions</em></span> are central to many games and happen when sprites touch. Once you can detect collisions, you can write code that makes the sprites react to them. In the <span class="emphasis"><em>Bubble Shooter</em></span>, collisions occur when a fired bubble slams into a bubble in the game grid. We’ll implement two reactions: the fired bubble will stick to the board if it doesn’t form a color group of three or more bubbles, or it will cause a valid group to fall from the board.</p><p>But before we can calculate collisions, we need an object for a bubble to collide with. The first section of this chapter discusses drawing the initial board and setting up the game state. To do so, we’ll need to follow a process containing a number of steps, shown in <a class="xref" href="ch03.html#game_loop_starts_by_drawing_the_board_an" title="Figure 3-1. The game loop starts by drawing the board and ends by showing the score.">Figure 3-1</a>.</p><div class="figure"><a id="game_loop_starts_by_drawing_the_board_an"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00011"/><img src="httpatomoreillycomsourcenostarchimages2184509.png" alt="The game loop starts by drawing the board and ends by showing the score."/></div></div><p class="title">Figure 3-1. The game loop starts by drawing the board and ends by showing the score.</p></div><p><a id="iddle1143" class="indexterm"/><a id="iddle1148" class="indexterm"/><a id="iddle1271" class="indexterm"/><a id="iddle1569" class="indexterm"/><a id="iddle1572" class="indexterm"/><a id="iddle1731" class="indexterm"/><a id="iddle1736" class="indexterm"/><a id="iddle1893" class="indexterm"/><a id="iddle1899" class="indexterm"/><a id="iddle1912" class="indexterm"/><a id="iddle1916" class="indexterm"/><a id="iddle2186" class="indexterm"/><a id="iddle2249" class="indexterm"/><a id="iddle2446" class="indexterm"/>We’ll draw the game board first and then add collision detection to the bubble that’s been fired. In the next chapter, we’ll implement the mechanism to pop groups of bubbles based on matching color.</p><p>Let’s work through the steps and turn them into code.</p><div class="sect1" title="Drawing the Game Board"><div class="titlepage"><div><div><h1 class="title"><a id="drawing_the_game_board"/>Drawing the Game Board</h1></div></div></div><p><a id="iddle1144" class="indexterm"/><a id="iddle1149" class="indexterm"/><a id="iddle1151" class="indexterm"/><a id="iddle1162" class="indexterm"/><a id="iddle1369" class="indexterm"/><a id="iddle1755" class="indexterm"/><a id="iddle1894" class="indexterm"/><a id="iddle1918" class="indexterm"/><a id="iddle1946" class="indexterm"/><a id="iddle1970" class="indexterm"/><a id="iddle2419" class="indexterm"/><a id="iddle2552" class="indexterm"/><a id="iddle2612" class="indexterm"/>The game board has a similar structure for every level, and each board contains rows of bubbles in four different colors. Alternate rows contain either an odd or even number of bubbles depending on whether the row is odd or even. We’ll store all this state information in a <code class="literal">Board</code> object and store the current board as a variable in the <code class="literal">Game</code> object.</p><p>The object structure you choose should vary depending on the game design, but the goals should be the same as when you’re deciding how to structure code in web applications: group objects that perform similar operations, and strike a balance with how much common functions are abstracted. Don’t define several classes that contain very little code, but don’t create too few classes with long code listings that will be difficult to read and understand. Game developers often base initial structural decisions on instinct and experience as well as on hard-and-fast rules. Always be prepared to refactor code if you think your original choices are no longer valid.</p><p>The rows that make up the board will be an array of <code class="literal">Bubble</code> objects. We’ll create this array when we instantiate the <code class="literal">Board</code> object. Later, we’ll transfer the drawing of the board elements to the DOM from within <span class="emphasis"><em>ui.js</em></span>. Ending up with a large mass of code within a <code class="literal">Game</code> class is easy to do but undesirable; therefore, take the opportunity to hand off responsibilities to other classes whenever possible, especially when rendering objects to the screen.</p><p>In <span class="emphasis"><em>game.js</em></span>, we need to create a variable to hold the board and a new instance of a <code class="literal">Board</code> object. The board is generated when the New Game button is clicked. Add the following new code to <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00039"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
  var Game = function(){
    var curBubble;
    <span class="strong"><strong>var board;</strong></span>
    <span class="emphasis"><em>--snip--</em></span>
    var startGame = function(){
      $(".but_start_game").unbind("click");
      BubbleShoot.ui.hideDialog();
      curBubble = getNextBubble();
      <span class="strong"><strong>board = new BubbleShoot.Board();</strong></span>
      <span class="strong"><strong>BubbleShoot.ui.drawBoard(board);</strong></span>
      $("#game").bind("click",clickGameScreen);
    };
    <span class="emphasis"><em>--snip--</em></span>
  };
  return Game;
})(jQuery);</pre><p><a id="iddle1138" class="indexterm"/><a id="iddle1145" class="indexterm"/><a id="iddle1171" class="indexterm"/><a id="iddle1260" class="indexterm"/><a id="iddle1304" class="indexterm"/><a id="iddle1585" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle1648" class="indexterm"/><a id="iddle1901" class="indexterm"/><a id="iddle2001" class="indexterm"/><a id="iddle2232" class="indexterm"/><a id="iddle2275" class="indexterm"/><a id="iddle2276" class="indexterm"/><a id="iddle2384" class="indexterm"/><code class="literal">Board</code> is a new constructor that we need to make. Create a new file called <span class="emphasis"><em>board.js</em></span> and add it to the list of files to load in <code class="literal">Modernizr.load</code> in <span class="emphasis"><em>index.html</em></span>. Add the following code to the new file:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00040"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Board = (function($){
➊  var NUM_ROWS = 9;
➋  var NUM_COLS = 32;
    var Board = function(){
      var that = this;
➌    var rows = createLayout();
➍    this.getRows = function(){ return rows;};
      return this;
    };
    var createLayout = function(){
      var rows = [];
➎    for(var i=0;i&lt;NUM_ROWS;i++){
        var row = [];
➏      var startCol = i%2 == 0 ? 1 : 0;
        for(var j=startCol;j&lt;NUM_COLS;j+=2){
➐        var bubble = BubbleShoot.Bubble.create(i,j);
          row[j] = bubble;
        };
        rows.push(row);
      };
      return rows;
    };
    return Board;
  })(jQuery);</pre><p><code class="literal">NUM_ROWS</code> ➊ and <code class="literal">NUM_COLS</code> ➋ are constants that determine the number of rows and columns that make up the bubble board grid. The number of columns may seem high, since we certainly won’t have 32 bubbles in a row. The reason for such a large column value is that we’ll create a grid entry for every half bubble width, because odd and even rows are offset on the game board. This design decision results in a more visually appealing layout, making it look like bubbles are stacking on top of each other. It also creates more interesting angles for the player to fire at.</p><p>All the bubbles on the first row and every subsequent odd row will have odd <span class="emphasis"><em>y</em></span>-coordinates, and those on even rows will have even <span class="emphasis"><em>y</em></span>-coordinates. The rows increment in integer steps, but the array we’ll use starts with an index of zero: the first row will be at index 0, the second will be at index 1, and so on. Thus, the bubble coordinates (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>), starting from the top-left corner of the bubble board, will be labeled as shown in <a class="xref" href="ch03.html#coordinates_of_the_bubbles_in_the_game_g" title="Figure 3-2. Coordinates of the bubbles in the game grid">Figure 3-2</a>. Specifying coordinates this way and having a half-populated grid avoids having to work with half values and decimal points. In addition, we can store the layout of the board in arrays indexed by integers. Working with integers rather than decimals doesn’t change the process we’ll follow to calculate collisions, but it does make the code more readable.</p><div class="figure"><a id="coordinates_of_the_bubbles_in_the_game_g"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00012"/><img src="httpatomoreillycomsourcenostarchimages2184511.png.jpg" alt="Coordinates of the bubbles in the game grid"/></div></div><p class="title">Figure 3-2. Coordinates of the bubbles in the game grid</p></div><p><a id="iddle1146" class="indexterm"/><a id="iddle1261" class="indexterm"/><a id="iddle1305" class="indexterm"/><a id="iddle1312" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1370" class="indexterm"/><a id="iddle1376" class="indexterm"/><a id="iddle1420" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1902" class="indexterm"/><a id="iddle2002" class="indexterm"/>In the code, we’ll now call the <code class="literal">createLayout</code> function ➌, which returns a two-dimensional array of rows and columns. We provide public access to this array in the next line ➍. Once we have a <code class="literal">Board</code> object, we can retrieve the bubble at any specific row and column position. For example, to access a bubble at coordinate (4,1) we would write:</p><a id="pro_id00041"/><pre class="programlisting">var rows = board.getRows();
var row = rows[1];
var bubble = row[4];</pre><p>Bubbles are accessed by row and then column number. First, we grab all the rows with <code class="literal">board.getRows</code>, and then we store the first row from the board as <code class="literal">row</code>. Next, we access the fourth bubble within <code class="literal">row</code> by its column number. Because the <code class="literal">row</code> array is only half populated, all odd entries in even-indexed rows (starting at zero) and all even entries in odd rows will be null.</p><p>The <code class="literal">createLayout</code> function contains a loop ➎. For each row we want to create, <code class="literal">startCol</code> ➏ calculates whether to start on column 1 or 0 depending on whether the row is odd or even, respectively. Then another loop increments to the maximum column number, creates a new <code class="literal">Bubble</code> object ➐, and adds it to the row array, which is returned on completion.</p><p>For this function to work, we need to adapt the <code class="literal">Bubble</code> class to accept row and column input coordinates, and we need to make a change to the <code class="literal">Bubble.create</code> method. Also, if a <code class="literal">Bubble</code> object knows its position in the grid by storing its coordinates, that information will be useful when we need to calculate groups to pop. When we know a bubble’s position, we can access that bubble, as it’s stored within the <code class="literal">Board</code> object. Then given a bubble, we can interrogate it to determine its position. Each bubble will have a <code class="literal">type</code> property, which corresponds to its color, and the property will be determined at creation time.</p><p>When you start coding your own game ideas, the decisions about where to store data and how to access it are critical. Your solution will depend on the type of game you’re building. In <span class="emphasis"><em>Bubble Shooter</em></span>, we store a relatively small number of <code class="literal">Bubbles</code> within a <code class="literal">Board</code> object. To find out information about a particular bubble, we can access the data that the <code class="literal">Board</code> stores by retrieving data from the <code class="literal">rows</code> array.</p><p><a id="iddle1378" class="indexterm"/><a id="iddle1388" class="indexterm"/><a id="iddle1412" class="indexterm"/><a id="iddle2370" class="indexterm"/>Depending on how we need to use that bubble data, this method might not be the most elegant solution. For example, imagine we want to find all of the red bubbles in the game. Currently, we would have to loop over every space on the board, check whether the bubble is red, and then store the outcome. The game grid is small, so modern processors can perform this operation quickly. As long as we don’t run the color check too many times a second, the current code structure should work.</p><p>But now imagine <span class="emphasis"><em>thousands</em></span> of bubbles on the screen. Looping over all the bubbles just to find red ones would consume too much processing power. Instead, we might want to store bubbles in multiple arrays—one for all the red bubbles, one for all the green bubbles, and so on—for instant access to all bubbles of each color. However, there would still be a tradeoff: to check whether a given space on the board is occupied by a bubble, regardless of color, we would have to look at multiple arrays.</p><p>When you have only a rough sense of how fast a processor can run an operation, it’s best to make your code clear and simple. If your game is playable and runs sufficiently fast, you won’t need to experiment with different ways to access data. Alternatively, if you identify bottlenecks, you’ll then have to refactor some sections to increase their speed. Game development is an iterative process; you’ll revisit existing lines of code as much as you write new ones.</p><p>How you design objects and where you store their data will vary from game to game. But remember this: if the <code class="literal">Game</code> object needs to use that data, one way or another you must allow the object to access it. Whether data is stored directly in a variable or in an array within <code class="literal">Game</code>, or is accessed through an intermediate object that <code class="literal">Game</code> has access to (such as the <code class="literal">Board</code> object in <span class="emphasis"><em>Bubble Shooter</em></span>), the code will need to access that object’s state if it needs to make decisions about that object.</p><p>To support a bubble storing its position on the board and its color, amend <span class="emphasis"><em>bubble.js</em></span> as follows:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00042"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Bubble = (function($){
    var Bubble = function(➊<span class="strong"><strong>row,col,type</strong></span>,sprite){
      var that = this;
      <span class="strong"><strong>this.getType = function(){ return type;};</strong></span>
      this.getSprite = function(){ return sprite;};
      <span class="strong"><strong>this.getCol = function(){ return col;};</strong></span>
      <span class="strong"><strong>this.getRow = function(){ return row;};</strong></span>
    };
    Bubble.create = function(➋<span class="strong"><strong>rowNum,colNum,type</strong></span>){
➊    <span class="strong"><strong>if(type === undefined){</strong></span>
➋      <span class="strong"><strong>type = Math.floor(Math.random() * 4);</strong></span>
      <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>var sprite = $(document.createElement("div"));</strong></span>
      <span class="strong"><strong>sprite.addClass("bubble");</strong></span>
      <span class="strong"><strong>sprite.addClass("bubble_" + type);</strong></span>
      var bubble = new Bubble(<span class="strong"><strong>rowNum,colNum,type,</strong></span>sprite);
      return bubble;
    };
    return Bubble;
  })(jQuery);</pre><p><a id="iddle1083" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1415" class="indexterm"/><a id="iddle1423" class="indexterm"/><a id="iddle1779" class="indexterm"/><a id="iddle2165" class="indexterm"/><a id="iddle2385" class="indexterm"/><a id="iddle2428" class="indexterm"/><a id="iddle2521" class="indexterm"/><a id="iddle2613" class="indexterm"/><a id="iddle2634" class="indexterm"/><code class="literal">Bubble</code> now takes grid coordinates and a bubble type as well as the sprite object ➊, where type corresponds to colors that were specified in <span class="emphasis"><em>game.css</em></span>. The Bubble.create method accepts the same parameters ➋; if type isn’t passed ➌, one of the four types (colors) is chosen at random ➍.</p><p>Now we have a <code class="literal">Board</code> object, plenty of bubbles, and their types and positions. But all this information is entirely in memory and is stored within the <code class="literal">Board</code> object’s <code class="literal">rows</code> property. Next, we’ll render the level using this information so players can see the game board.</p><div class="sect2" title="Rendering the Level"><div class="titlepage"><div><div><h2 class="title"><a id="rendering_the_level"/>Rendering the Level</h2></div></div></div><p>Drawing the level is a perfect job for the <code class="literal">ui</code> class, because <code class="literal">ui</code> represents the game state but doesn’t affect that state.</p><p>Separating the code that calculates an object’s position from the code that renders that object to the screen is a principle you should apply in all of your game ideas. Not only does it separate rendering code from game logic, thereby improving readability, but it also allows you to more easily change how objects are rendered. For example, if the <span class="emphasis"><em>Bubble Shooter</em></span> board was larger and didn’t fit on the screen but we wanted to implement a zoom or pan feature, we could change the code that renders the board to either offset the rendering position or to scale up or down to draw a different size board. The power of separating rendering from game logic will become apparent when we switch from DOM-based sprites to drawing onto the HTML <code class="literal">canvas</code> element in <a class="xref" href="ch06.html" title="Chapter 6. Rendering Canvas Sprites">Chapter 6</a>.</p><p>Because the creation of a <code class="literal">bubble</code> object involves creating a DOM sprite element, the rendering process needs to place this element in the document and position it correctly. These simple steps follow:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Loop over all the rows and columns and pull out each <code class="literal">bubble</code> object.</p></li><li class="listitem"><p>Write the bubble’s HTML into the DOM.</p></li><li class="listitem"><p>Position the bubble in the correct position.</p></li></ol></div><p>The next piece of code you add will apply these steps. Open <span class="emphasis"><em>ui.js</em></span>, add a new method (<code class="literal">drawBoard</code>) after <code class="literal">fireBubble</code>, and then add a new <code class="literal">ROW_HEIGHT</code> constant at the top:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00043"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    var ui = {
      BUBBLE_DIMS : 44,
      <span class="strong"><strong>ROW_HEIGHT : 40,</strong></span>
      init : function(){
      },
      fireBubble : function(bubble,coords,duration){
        <span class="emphasis"><em>--snip--</em></span>
      }<span class="strong"><strong>,</strong></span>
      <span class="strong"><strong>drawBoard : function(board){</strong></span>
  ➊      <span class="strong"><strong>var rows = board.getRows();</strong></span>
        <span class="strong"><strong>var gameArea = $("#board");</strong></span>
        <span class="strong"><strong>for(var i=0;i&lt;rows.length;i++){</strong></span>
          <span class="strong"><strong>var row = rows[i];</strong></span>
➋        <span class="strong"><strong>for(var j=0;j&lt;row.length;j++){</strong></span>
            <span class="strong"><strong>var bubble = row[j];</strong></span>
➌          <span class="strong"><strong>if(bubble){</strong></span>
➍            <span class="strong"><strong>var sprite = bubble.getSprite();</strong></span>
➎            <span class="strong"><strong>gameArea.append(sprite);</strong></span>
              <span class="strong"><strong>var left = j * ui.BUBBLE_DIMS/2;</strong></span>
              <span class="strong"><strong>var top = i * ui.ROW_HEIGHT;</strong></span>
➏            <span class="strong"><strong>sprite.css({</strong></span>
                <span class="strong"><strong>left : left,</strong></span>
                <span class="strong"><strong>top : top</strong></span>
              <span class="strong"><strong>});</strong></span>
            <span class="strong"><strong>};</strong></span>
          <span class="strong"><strong>};</strong></span>
        <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    return ui;
  })(jQuery);</pre><p><a id="iddle1351" class="indexterm"/><a id="iddle1398" class="indexterm"/><a id="iddle1682" class="indexterm"/><a id="iddle1756" class="indexterm"/>The <code class="literal">drawBoard</code> method retrieves the board rows and columns ➊ and loops over them ➋. If there’s a bubble ➌ (recall that every other <span class="emphasis"><em>x</em></span>-coordinate position is <code class="literal">null</code> due to the sparse grid system), <code class="literal">drawBoard</code> grabs the <code class="literal">sprite</code> object ➍, appends it to the board ➎, and calculates its coordinates before setting its position ➏.</p><p>To determine a bubble’s position, <code class="literal">drawBoard</code> first calculates the left coordinate, which is the bubble’s column number multiplied by half its width. To calculate the top coordinate, we’ll use a value slightly smaller than the <code class="literal">BUBBLE_DIMS</code> height. The odd and even rows are staggered, and we want the bubbles to look like they fit together. To create the stacking effect, the vertical separation will be slightly less than the horizontal distance. At the top of <span class="emphasis"><em>ui.js</em></span>, <code class="literal">ROW_HEIGHT</code> has been set to 40, which is 4 pixels less than the height. This value was determined through trial and error rather than geometrical calculation: adjust the numbers until the bubble grid looks pleasing to you.</p><p>Reload and click <span class="strong"><strong>New Game</strong></span>; you should see a nicely rendered board. You can even fire a bubble at the rest of the board; unfortunately, it should just go straight through without hitting anything and continue off the screen as before.</p><p>Because we have only one bubble, we need to refresh to retry the process. Before we begin working on collision detection, we’ll make sure we can keep firing one bubble after another.</p></div><div class="sect2" title="The Bubble Queue"><div class="titlepage"><div><div><h2 class="title"><a id="bubble_queue"/>The Bubble Queue</h2></div></div></div><p>Although the player will have only a finite number of bubbles to fire, the game needs to provide those bubbles in a constant stream. Therefore, we’ll need to add a function that creates a new bubble, adds it to the DOM, and queues up the next bubble as soon as the user fires the first one.</p><p><a id="iddle1283" class="indexterm"/><a id="iddle1854" class="indexterm"/><a id="iddle1933" class="indexterm"/><a id="iddle1947" class="indexterm"/><a id="iddle1987" class="indexterm"/><a id="iddle2191" class="indexterm"/><a id="iddle2553" class="indexterm"/><a id="iddle2614" class="indexterm"/>In <span class="emphasis"><em>game.js</em></span>, add the following variables and functions and change the initialization for <code class="literal">curBubble</code> to call a new <code class="literal">getNextBubble</code> function:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00044"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
    var curBubble;
    var board;
➊  <span class="strong"><strong>var numBubbles;</strong></span>
➋  <span class="strong"><strong>var MAX_BUBBLES = 70;</strong></span>
    this.init = function(){
      $(".but_start_game").bind("click",startGame);
    };
    var startGame = function(){
      $(".but_start_game").unbind("click");
➌    <span class="strong"><strong>numBubbles = MAX_BUBBLES;</strong></span>
      BubbleShoot.ui.hideDialog();
      curBubble = getNextBubble();
      board = new BubbleShoot.Board();
      BubbleShoot.ui.drawBoard(board);
      $("#game").bind("click",clickGameScreen);
    };
    var getNextBubble = function(){
      var bubble = BubbleShoot.Bubble.create();
      bubble.getSprite().addClass("cur_bubble");
      $("#board").append(bubble.getSprite());
➍    <span class="strong"><strong>BubbleShoot.ui.drawBubblesRemaining(numBubbles);</strong></span>
      <span class="strong"><strong>numBubbles--;</strong></span>
      return bubble;
    };
    var clickGameScreen = function(e){
      var angle = BubbleShoot.ui.getBubbleAngle(curBubble .getSprite(),e);
      var duration = 750;
      var distance = 1000;
      var distX = Math.sin(angle) * distance;
      var distY = Math.cos(angle) * distance;
      var bubbleCoords = BubbleShoot.ui.getBubbleCoords(curBubble .getSprite());
      var coords = {
        x : bubbleCoords.left + distX,
        y : bubbleCoords.top - distY
      };
      BubbleShoot.ui.fireBubble(curBubble,coords,duration);
➎    <span class="strong"><strong>curBubble = getNextBubble();</strong></span>
    };
    return Game;
  })(jQuery);</pre><p>The new code first creates a variable ➊ to store the number of bubbles the player has fired. Because the number of fired bubbles is an integer—a basic data type—we’ll store it as a variable in <code class="literal">Game</code>. If, for example, we had a time limit that a level had to be completed within, we might create an object to store time remaining along with bubbles remaining rather than continuing to create variables in <code class="literal">Game</code>. As it is, the variable suits our purpose.</p><p><a id="iddle1320" class="indexterm"/><a id="iddle1882" class="indexterm"/><a id="iddle2361" class="indexterm"/><a id="iddle2591" class="indexterm"/><a id="iddle2635" class="indexterm"/>The code also sets a constant for the maximum number of bubbles ➋ the player can fire. When a level is started, it sets the number of bubbles remaining to the value of <code class="literal">MAX_BUBBLES</code> ➌ and calls a new function in <span class="emphasis"><em>ui.js</em></span> to display the number of remaining bubbles on the screen ➍. Finally, the code calls <code class="literal">getNextBubble</code> ➎ each time a bubble is fired to prepare a new one.</p><p>We also want to show the player the number of remaining bubbles available to fire within a level, so create the <code class="literal">drawBubblesRemaining</code> method in <span class="emphasis"><em>ui.js</em></span>, appending this new function to the <code class="literal">ui</code> object:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00045"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.ui = (function($){
  var ui = {
    BUBBLE_DIMS : 44,
    ROW_HEIGHT : 40,
    <span class="emphasis"><em>--snip--</em></span>
    drawBoard : function(board){
      <span class="emphasis"><em>--snip--</em></span>
    }<span class="strong"><strong>,</strong></span>
    <span class="strong"><strong>drawBubblesRemaining : function(numBubbles){</strong></span>
      <span class="strong"><strong>$("#bubbles_remaining").text(numBubbles);</strong></span>
    <span class="strong"><strong>}</strong></span>
  };
  return ui;
})(jQuery);</pre><p>Additionally, we need to display the number of remaining bubbles, so add a new element in <span class="emphasis"><em>index.html</em></span>:</p><p><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00046"/><pre class="programlisting">&lt;div id="game"&gt;
  &lt;div id="board"&gt;&lt;/div&gt;
  <span class="strong"><strong>&lt;div id="bubbles_remaining"&gt;&lt;/div&gt;</strong></span>
&lt;/div&gt;</pre><p>Add some styling for the <code class="literal">bubbles_remaining</code> div into <span class="emphasis"><em>main.css</em></span>:</p><p><span class="emphasis"><em>main.css</em></span></p><a id="pro_id00047"/><pre class="programlisting">#bubbles_remaining
{
  position: absolute;
  left: 479px;
  top: 520px;
  width: 50px;
  font-size: 26px;
  font-weight: bold;
  color: #000;
  text-align: center;
}</pre><p>Now refresh the game. You should be able to fire bubbles into the distance, get a new one as soon as the first is fired (until you’ve used 70 bubbles, or whatever value you used for <code class="literal">MAX_BUBBLES</code>), and be able to fire that new bubble immediately.</p><p><a id="iddle1272" class="indexterm"/><a id="iddle1573" class="indexterm"/><a id="iddle1732" class="indexterm"/><a id="iddle1848" class="indexterm"/><a id="iddle2371" class="indexterm"/><a id="iddle2606" class="indexterm"/>Often, you can break down a game into a repeating <span class="emphasis"><em>turn loop</em></span>. The loop is usually initiated by a player action and then closed when that action has been resolved. In <span class="emphasis"><em>Bubble Shooter</em></span>, the loop commences when the player clicks the screen to fire the button and completes when the next bubble is ready to fire. At this point we have the basic turn loop, but to create the game, we need to flesh out the middle part of the loop to calculate where to stop a bubble and whether to pop bubbles.</p></div></div><div class="sect1" title="Detecting Collisions"><div class="titlepage"><div><div><h1 class="title"><a id="detecting_collisions"/>Detecting Collisions</h1></div></div></div><p>Although you can now fire bubbles, they pass straight through the board without affecting the bubble grid. The game design calls for them to collide with the board and either become part of the board or cause groups of bubbles that are the same color to pop. The next task is to work out where collisions occur.</p><p>We can calculate collisions in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Move a sprite forward a few pixels for each frame and then try to detect any overlaps with other sprites. If there’s an overlap, we know we’ve hit another bubble.</p></li><li class="listitem"><p>Use geometry to calculate where the sprite might collide with another bubble before it even starts moving.</p></li></ul></div><p>In fast-paced arcade games, you might choose the first option, as long as there’s no chance objects will pass through each other without a collision being detected. These pass-throughs can happen when objects move at high speeds, and collision checks occur after an object has moved numerous pixels since the previous check. For example, in a game in which you fire a bullet at a one-foot-thick wall, the bullet would only be guaranteed to collide with the wall if you check for collisions every foot. If you checked for collisions every two feet instead, you might check for a collision just before the bullet should hit and find no wall. Then two feet further along when you check again, the bullet would be past the wall, again resulting in no collision.</p><p>To work around the fast-moving-object problem, we could make sure the steps are always small enough that pass-throughs never happen; however, that requires more calculations, which may not be possible without significant computing power. This problem is more likely to surface in a browser environment: because we never know the specs of the end user’s computer, we can’t take processing power for granted.</p><p>The second option, using geometry, is more accurate if it’s feasible. Fortunately, our game design has fairly simplistic geometric properties. Unfortunately, this option isn’t possible in games in which sprites have more complex shapes. In that case, you’d have to check whether pixels overlap on a frame-by-frame basis and test thoroughly to ensure you don’t see any side effects. For <span class="emphasis"><em>Bubble Shooter</em></span>, we’ll use a geometrical approach because we have the following advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The game is on a regular grid.</p></li><li class="listitem"><p>All the objects (the bubbles) are identical.</p></li><li class="listitem"><p><a id="iddle1273" class="indexterm"/><a id="iddle1284" class="indexterm"/><a id="iddle1285" class="indexterm"/><a id="iddle1294" class="indexterm"/><a id="iddle1295" class="indexterm"/><a id="iddle1574" class="indexterm"/><a id="iddle1577" class="indexterm"/><a id="iddle1578" class="indexterm"/><a id="iddle1733" class="indexterm"/><a id="iddle1855" class="indexterm"/>We’re working in only two dimensions.</p></li><li class="listitem"><p>The player moves only one object.</p></li><li class="listitem"><p>All the objects are simple geometric shapes (circles), so the calculation of where edges meet is easy.</p></li></ul></div><p>These conditions make geometric calculations for collisions relatively straightforward. Because game development often involves a lot of geometry, having a good grounding in trigonometry and vectors is essential. The next section discusses the geometry involved in this game. Then we’ll turn that geometry into code.</p><div class="sect2" title="Collision Geometry"><div class="titlepage"><div><div><h2 class="title"><a id="collision_geometry"/>Collision Geometry</h2></div></div></div><p>When you need to calculate collisions, draw the geometry on a piece of paper before you write the detection code. You’ll then be able to visualize the values you’ll need to calculate, as shown in <a class="xref" href="ch03.html#visualizing_the_geometry_behind_a_bubble" title="Figure 3-3. Visualizing the geometry behind a bubble collision">Figure 3-3</a>.</p><div class="figure"><a id="visualizing_the_geometry_behind_a_bubble"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00013"/><img src="httpatomoreillycomsourcenostarchimages2184513.png.jpg" alt="Visualizing the geometry behind a bubble collision"/></div></div><p class="title">Figure 3-3. Visualizing the geometry behind a bubble collision</p></div><p>The bubble being fired should cause a collision when its center passes within 2<span class="emphasis"><em>R</em></span> (where <span class="emphasis"><em>R</em></span> is a bubble’s radius) of another bubble’s center, meaning that the two circumferences are touching. Because the intersection point will always be normal (at 90 degrees) to the colliding bubble’s edge and the edge of the bubble being hit, we need to check for a collision only if the path of the moving bubble’s center comes within 2<span class="emphasis"><em>R</em></span> of another bubble’s center.</p><p>To determine where collisions occur, we need to check every other bubble on the board to determine whether the fired bubble’s path passes through it. If it overlaps with multiple bubbles, as it does in <a class="xref" href="ch03.html#fired_bubble_may_be_on_a_path_to_collide" title="Figure 3-4. The fired bubble may be on a path to collide with multiple other bubbles.">Figure 3-4</a>, we need to make sure that the struck bubble we pick is the first collision that occurs, which will be the one in which the firing bubble has traveled the least distance.</p><div class="figure"><a id="fired_bubble_may_be_on_a_path_to_collide"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00014"/><img src="httpatomoreillycomsourcenostarchimages2184515.png.jpg" alt="The fired bubble may be on a path to collide with multiple other bubbles."/></div></div><p class="title">Figure 3-4. The fired bubble may be on a path to collide with multiple other bubbles.</p></div><p><a id="iddle1274" class="indexterm"/><a id="iddle1286" class="indexterm"/><a id="iddle1575" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1581" class="indexterm"/><a id="iddle1734" class="indexterm"/><a id="iddle2020" class="indexterm"/><a id="iddle2021" class="indexterm"/><a id="iddle2660" class="indexterm"/><a id="iddle2661" class="indexterm"/>Detecting a collision is equivalent to detecting when a vector drawn from the center line of the bubble we’re firing intersects with a circle with a radius double that of our bubbles. This will be known as a bubble’s <span class="emphasis"><em>hitbox</em></span>. <a class="xref" href="ch03.html#if_the_fired_bubbleapostrophes_travel_pa" title="Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s circular hitbox, a collision occurs.">Figure 3-5</a> shows how we can redraw this concept to help us think about it in a way that’s easier to compute.</p><div class="figure"><a id="if_the_fired_bubbleapostrophes_travel_pa"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00015"/><img src="httpatomoreillycomsourcenostarchimages2184517.png.jpg" alt="If the fired bubble’s travel path intersects a stationary bubble’s circular hitbox, a collision occurs."/></div></div><p class="title">Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s circular hitbox, a collision occurs.</p></div><p>In this diagram, the small filled circle marks the center of the bubble being fired. The bubble it will collide with is the inner circle, and the intersection with the bubble’s hitbox (the point marked with the arrow 2<span class="emphasis"><em>R</em></span>, which is double a bubble’s radius) is where the bubble will stop.</p><p>Turning the diagram into a mathematical formula means using vectors. Rather than working through the math before showing any code, let’s go straight into the necessary JavaScript, which includes explanatory annotations.</p><div class="sidebar"><a id="simplifying_hitboxes"/><p class="title">Simplifying Hitboxes</p><p><a id="iddle1084" class="indexterm"/><a id="iddle1384" class="indexterm"/><a id="iddle1399" class="indexterm"/><a id="iddle1424" class="indexterm"/><a id="iddle1565" class="indexterm"/><a id="iddle1566" class="indexterm"/><a id="iddle2233" class="indexterm"/><a id="iddle2303" class="indexterm"/><a id="iddle2372" class="indexterm"/>Because we are working with circles, creating a hitbox is simpler than it might be if you were dealing with, for example, a figure that runs and jumps, as in a platform game. In that case, you might not want to detect collisions just by checking whether pixels overlap because of possible performance issues; instead, you could simplify the geometry of the main character and create a rectangular hitbox to check against. Not all games lend themselves to this approach. However, if you can reduce complex character outlines to simple geometrical shapes, you can detect collisions with much greater precision and less processing power than by checking whether pixels have overlapped. Always look for creative, efficient solutions to avoid brute-force techniques that monopolize resources.</p></div><p>The calculation is a large block of code with a specific function, so we’ll put it in its own file. Create a file called <span class="emphasis"><em>collision-detector.js</em></span> and add it to the <code class="literal">Modernizr.load</code> call in <span class="emphasis"><em>index.html</em></span>. Type in the following:</p><p><span class="emphasis"><em>collision-detector.js</em></span></p><a id="pro_id00048"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.CollisionDetector = (function($){
    var CollisionDetector = {
      findIntersection : function(curBubble,board,angle){
        var rows = board.getRows();
        var collision = null;
        var pos = curBubble.getSprite().position();
        var start = {
          left : pos.left + BubbleShoot.ui.BUBBLE_DIMS/2,
          top : pos.top + BubbleShoot.ui.BUBBLE_DIMS/2
        };
        var dx = Math.sin(angle);
        var dy = -Math.cos(angle);
        for(var i=0;i&lt;rows.length;i++){
          var row = rows[i];
          for(var j=0;j&lt;row.length;j++){
            var bubble = row[j];
            if(bubble){
➊            var coords = bubble.getCoords();
              var distToBubble = {
                x : start.left - coords.left,
                y : start.top - coords.top
              };
              var t = dx * distToBubble.x + dy * distToBubble.y;
              var ex = -t * dx + start.left;
              var ey = -t * dy + start.top;
              var distEC = Math.sqrt((ex - coords.left) * (ex - coords.left) +
                (ey - coords.top) * (ey - coords.top));
              if(distEC&lt;BubbleShoot.ui.BUBBLE_DIMS * .75){
                var dt = Math.sqrt(BubbleShoot.ui.BUBBLE_DIMS * BubbleShoot.
                  ui.BUBBLE_DIMS - distEC * distEC);
                var offset1 = {
                  x : (t - dt) * dx,
                  y : -(t - dt) * dy
                };
                var offset2 = {
                  x : (t + dt) * dx,
                  y : -(t + dt) * dy
                };
                var distToCollision1 = Math.sqrt(offset1.x * offset1.x +
                  offset1.y * offset1.y);
                var distToCollision2 = Math.sqrt(offset2.x * offset2.x +
                  offset2.y * offset2.y);
                if(distToCollision1 &lt; distToCollision2){
                  var distToCollision = distToCollision1;
                  var dest = {
                    x : offset1.x + start.left,
                    y : offset1.y + start.top
                  };
                }else{
                  var distToCollision = distToCollision2;
                  var dest = {
                    x : -offset2.x + start.left,
                    y : offset2.y + start.top
                  };
                }
                if(!collision || collision.distToCollision&gt;distToCollision){
                  collision = {
                    bubble : bubble,
                    distToCollision : distToCollision,
                    coords : dest
                  };
                };
              };
            };
          };
        };
        return collision;
      }
    };
    return CollisionDetector;
  })(jQuery);</pre><p><a id="iddle1262" class="indexterm"/><a id="iddle1371" class="indexterm"/><a id="iddle1638" class="indexterm"/>In a moment I’ll break down the code in <span class="emphasis"><em>collision-detector.js</em></span>. But first, notice the call to a new method in <span class="emphasis"><em>bubble.js</em></span> called <code class="literal">getCoords</code> ➊, which returns the center (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) coordinate of a bubble based on its position in the row/column hierarchy. You’ll need to amend the bubble class to add the new method:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00049"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.Bubble = (function($){
  var Bubble = function(row,col,type,sprite){
    var that = this;
    this.getType = function(){ return type;};
    this.getSprite = function(){ return sprite;};
    this.getCol = function(){ return col;};
    this.getRow = function(){ return row;};
    <span class="strong"><strong>this.getCoords = function(){</strong></span>
      <span class="strong"><strong>var coords = {</strong></span>
        <span class="strong"><strong>left :</strong></span> ➊<span class="strong"><strong>that.getCol() *</strong></span> ➋<span class="strong"><strong>BubbleShoot.ui.BUBBLE_DIMS/2 +</strong></span>
          ➎<span class="strong"><strong>BubbleShoot.ui.BUBBLE_DIMS/2,</strong></span>
        <span class="strong"><strong>top :</strong></span> ➌<span class="strong"><strong>that.getRow() *</strong></span> ➍<span class="strong"><strong>BubbleShoot.ui.ROW_HEIGHT +</strong></span>
          ➎<span class="strong"><strong>BubbleShoot.ui.BUBBLE_DIMS/2</strong></span>
      <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>return coords;</strong></span>
    <span class="strong"><strong>}</strong></span>
  };
  Bubble.create = function(rowNum,colNum,type){
    --<span class="emphasis"><em>snip</em></span>--
  };
  return Bubble;
})(jQuery);</pre><p><a id="iddle1287" class="indexterm"/><a id="iddle1379" class="indexterm"/><a id="iddle1389" class="indexterm"/><a id="iddle1425" class="indexterm"/><a id="iddle1856" class="indexterm"/><a id="iddle2429" class="indexterm"/><a id="iddle2662" class="indexterm"/>The game coordinates of a bubble are simple to calculate: you start by finding each top-left corner coordinate. The <span class="emphasis"><em>x</em></span>-coordinate (left) is the column number ➊ multiplied by half the bubble sprite’s width ➋. The <span class="emphasis"><em>y</em></span>-coordinate (top) is the row number ➌ multiplied by the row height ➍, which is slightly less than the bubble’s full height. To find the center of a bubble, just add half the bubble’s dimensions ➎ to both <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>.</p><p>When you’re developing game logic, the center coordinates of an object are more often the focus, whereas for rendering purposes, you’ll usually specify the top-left corner along with a width and a height. Building a handy method into the object that converts from one to the other will save you from writing out the math each time you need to switch.</p></div><div class="sect2" title="Collision Detection Logic"><div class="titlepage"><div><div><h2 class="title"><a id="collision_detection_logic"/>Collision Detection Logic</h2></div></div></div><p>Now let’s walk through the entire <code class="literal">findIntersection</code> routine in <span class="emphasis"><em>CollisionDetector.js</em></span> block by block. If you don’t want to dig into the math right now, you can skip this breakdown—it’s purely the math of detecting collisions and doesn’t contain any new HTML5 or game development concepts. However, know that in almost every game you write, you’ll break down the complexities of how objects interact into a model that you can manipulate with relatively simple mathematics.</p><div class="sect3" title="Starting Position and Direction Vector"><div class="titlepage"><div><div><h3 class="title"><a id="starting_position_and_direction_vector"/>Starting Position and Direction Vector</h3></div></div></div><p>The first part added to <span class="emphasis"><em>collision-detector.js</em></span> is the standard library intro:</p><a id="pro_id00050"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.CollisionDetector = (function($){
  var CollisionDetector = {</pre><p>We’ve created an object called <code class="literal">CollisionDetector</code>. Now let’s look at the first method on that object:</p><a id="pro_id00051"/><pre class="programlisting">findIntersection : function(curBubble,board,angle){</pre><p><a id="iddle1152" class="indexterm"/><a id="iddle1301" class="indexterm"/><a id="iddle1400" class="indexterm"/><a id="iddle2420" class="indexterm"/>When you call <code class="literal">CollisionDetector</code>, you’ll use <code class="literal">BubbleShoot.CollisionDetector.findIntersection</code>. It accepts the parameters <code class="literal">curBubble</code> (an instance of the <code class="literal">Bubble</code> class), the <code class="literal">board</code> variable (an instance of <code class="literal">Board</code>), and the angle at which the bubble is being fired, giving the function everything it needs to know about the starting situation.</p><p>Now, examine the first variables within <code class="literal">findIntersection</code>:</p><a id="pro_id00052"/><pre class="programlisting">var rows = board.getRows();
var collision = null;</pre><p>We’ll loop over each row to check for collisions, so let’s grab the board rows into a local variable. Assuming there’s no collision by default, this will be the state returned by the function if no intersections occur. As a result, if the fired bubble doesn’t hit another bubble, it will keep moving forward.</p><p>The starting value of <code class="literal">collision</code> is <code class="literal">null</code> instead of <code class="literal">false</code> because if an intersection occurs, it will hold the bubble that’s been collided with, plus some other information, rather than a Boolean that indicates whether or not a collision has occurred. We need to know that a collision has occurred (which would be a “true” or “false” result), but more important, we need to send back information about what was collided with and where the collision occurred:</p><a id="pro_id00053"/><pre class="programlisting">var pos = curBubble.getSprite().position();
var start = {
  left : pos.left + BubbleShoot.ui.BUBBLE_DIMS/2,
  top : pos.top + BubbleShoot.ui.BUBBLE_DIMS/2
};</pre><p>The next pair of variables retrieves the bubble’s starting position (on the screen) as an object with top and left properties:</p><a id="pro_id00054"/><pre class="programlisting">var dx = Math.sin(angle);
var dy = -Math.cos(angle);</pre><p>Finally, <code class="literal">dx</code> and <code class="literal">dy</code> define how much a bubble moves left or right (<code class="literal">dx</code>) or up (<code class="literal">dy</code>) relative to the total distance the bubble will move. With those variables defined, we can loop through the rows and columns of the game board:</p><a id="pro_id00055"/><pre class="programlisting">for(var i=0;i&lt;rows.length;i++){
  var row = rows[i];
  for(var j=0;j&lt;row.length;j++){
    var bubble = row[j];
    if(bubble){</pre><p>We’ll start at the top left of the game board and work our way down and to the right. Because we only fire bubbles upward, we know that a bubble will never collide with another from the top of the game board. We also know that if multiple collision candidates are present along the bubble’s path, we want to grab the one where the bubble has traveled the least <a id="iddle1035" class="indexterm"/><a id="iddle1385" class="indexterm"/><a id="iddle1582" class="indexterm"/><a id="iddle2022" class="indexterm"/><a id="iddle2108" class="indexterm"/><a id="iddle2663" class="indexterm"/>distance—that is, the collision that happened first. Remember that because columns are sparsely populated (every other entry is null), we also need to make sure we’re actually looking at a bubble before we try to do anything with it—hence the <code class="literal">if(bubble)</code> check.</p></div><div class="sect3" title="Calculating Collisions"><div class="titlepage"><div><div><h3 class="title"><a id="calculating_collisions"/>Calculating Collisions</h3></div></div></div><p>Next we need to use some geometry to check whether the fired bubble’s hitbox collided with another bubble. We’ll determine where the vector defined by (<span class="emphasis"><em>dx</em></span>,<span class="emphasis"><em>dy</em></span>), which begins at the center of the fired bubble, intersects with the circle drawn in <a class="xref" href="ch03.html#fired_bubble_may_be_on_a_path_to_collide" title="Figure 3-4. The fired bubble may be on a path to collide with multiple other bubbles.">Figure 3-4</a>. Let’s start with the equation of a circle:</p><p>(<span class="emphasis"><em>x</em></span> – <span class="emphasis"><em>c</em></span><sub>x</sub>)<sup>2</sup> + (<span class="emphasis"><em>y</em></span> – <span class="emphasis"><em>c</em></span><sub>y</sub>)<sup>2</sup> = <span class="emphasis"><em>r</em></span><sup>2</sup></p><p>Here, <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are the points on the circle’s circumference, <span class="emphasis"><em>c</em></span><sub>x</sub> and <span class="emphasis"><em>c</em></span><sub>y</sub> are the center points of the circle, and <span class="emphasis"><em>r</em></span> is the radius of the circle. We’ll need those points to find the distance to the starting bubble.</p><a id="pro_id00056"/><pre class="programlisting">var coords = bubble.getCoords();
var distToBubble = {
  x : start.left - coords.left,
  y : start.top - coords.top
};</pre><p>This part of the loop contains a bubble to check a collision against, so let’s get <span class="emphasis"><em>c</em></span><sub>x</sub> and <span class="emphasis"><em>c</em></span><sub>y</sub>, the center coordinates of the bubble (<code class="literal">coords</code> in the preceding code), and calculate the distance between this point and the fired bubble’s coordinates. We don’t yet know whether or not a collision will occur.</p><p>The bubble being fired follows a set of coordinates defined by the equations:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>p</em></span><sub>x</sub> =</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>e</em></span><sub>x</sub> + <span class="emphasis"><em>td</em></span><sub>x</sub></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><span class="emphasis"><em>p</em></span><sub>y</sub> =</p></td><td style="" valign="top"><p><span class="emphasis"><em>e</em></span><sub>y</sub> + <span class="emphasis"><em>td</em></span><sub>y</sub></p></td></tr></tbody></table></div><p>where <span class="emphasis"><em>p</em></span><sub>x</sub> and <span class="emphasis"><em>p</em></span><sub>y</sub> are points on the trajectory of the bubble’s center point. The calculation of <span class="emphasis"><em>p</em></span><sub>x</sub> and <span class="emphasis"><em>p</em></span><sub>y</sub> happens in jQuery’s <code class="literal">animate</code> method and is the standard equation for moving a point along a line. Next, we’ll calculate <span class="emphasis"><em>t</em></span> at the closest point on this line to the center of the bubble that we’re checking against:</p><a id="pro_id00057"/><pre class="programlisting">var t = dx * distToBubble.x + dy * distToBubble.y;</pre><p>This line tells us at what proportion of the fired bubble’s total movement it will be closest to the candidate bubble’s center. From this, we can calculate the screen coordinates where this happens:</p><a id="pro_id00058"/><pre class="programlisting">var ex = -t * dx + start.left;
var ey = -t * dy + start.top;</pre><p><a id="iddle1426" class="indexterm"/><a id="iddle1570" class="indexterm"/><a id="iddle2604" class="indexterm"/>With these coordinates, we can find the distance of <span class="emphasis"><em>e</em></span> (the closest point on the fired bubble’s center line to the center of the candidate bubble):</p><a id="pro_id00059"/><pre class="programlisting">var distEC = Math.sqrt((ex - coords.left) * (ex - coords.left) + (ey -
  coords.top) * (ey - coords.top));</pre><p>If the distance <code class="literal">distEC</code> is less than double the candidate bubble’s radius, a collision occurs. If not, the fired bubble will not collide with this candidate bubble.</p><div class="sidebar"><a id="trial_and_error_vsdot_calculation"/><p class="title">Trial and Error vs. Calculation</p><p>Note that although <code class="literal">BubbleShoot.ui.BUBBLE_DIMS</code> gives the width and height of the sprite, we’re checking <code class="literal">distEC</code> against a bubble image that is actually slightly smaller. Multiplying the <code class="literal">BUBBLE_DIMS</code> value by 0 .75 (obtained from a bit of trial and error) gives a diameter for a bubble that works in the game.</p><p>We can arrive at a more precise value for <code class="literal">distEC</code> by measuring the width of the bubble, which is 44 pixels in the images in this book. Dividing by the <code class="literal">BUBBLE_DIMS</code> of 50 pixels, the result is a multiplier of 0 .88. Although this larger value might be more exact, it requires the player to be more accurate when trying to fire bubbles through gaps. Therefore, 0 .75 just feels better to the player, because it gives them more chances to make shots that they would find very difficult if the math were precise.</p><p>Often in game development, you’ll make decisions based on trial and error as much as by calculation. In this case, by using a slightly smaller value, you give the player the opportunity to fire bubbles through small gaps in the game board. Players won’t notice the lax enforcement of the laws of physics, and they’ll enjoy the game more.</p></div><p>If <code class="literal">distEC</code> is less than three-quarters of the bubble sprite width, we know that the fired bubble’s travel path intersects the candidate bubble’s hitbox at some point:</p><a id="pro_id00060"/><pre class="programlisting">if(distEC &lt; BubbleShoot.ui.BUBBLE_DIMS * .75){</pre><p>Most likely, a second intersection point will occur where the line exits the bubble’s hitbox (see <a class="xref" href="ch03.html#if_the_fired_bubbleapostrophes_travel_pa" title="Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s circular hitbox, a collision occurs.">Figure 3-5</a>, which shows the center line of the fired bubble passing through the hitbox at two points), but we only want the first. Two calculations will ensure that we have the correct intersection. Let’s look at the first calculation:</p><a id="pro_id00061"/><pre class="programlisting">var dt = Math.sqrt(BubbleShoot.ui.BUBBLE_DIMS * BubbleShoot.ui.BUBBLE_DIMS
  - distEC * distEC);</pre><p>Here, we find the distance between the center of the struck bubble and the closest point on the fired bubble’s path. The second calculation follows:</p><a id="pro_id00062"/><pre class="programlisting">var offset1 = {
  x : (t - dt) * dx,
  y : -(t - dt) * dy
};
var offset2 = {
  x : (t + dt) * dx,
  y : -(t + dt) * dy
};</pre><p>The points on the line that cross the stationary bubble’s center are calculated here as offsets from the fired bubble’s path at point <code class="literal">t</code>.</p></div><div class="sect3" title="Finding the Correct Collision Point"><div class="titlepage"><div><div><h3 class="title"><a id="finding_the_correct_collision_point"/>Finding the Correct Collision Point</h3></div></div></div><p>Now we want to choose which intersection we’ll encounter first—that is, which point is closest to where we’re firing <code class="literal">curBubble</code> from—so we need the distances to each potential collision point:</p><a id="pro_id00063"/><pre class="programlisting">var distToCenter1 = Math.sqrt(offset1.x * offset1.x + offset1.y *
  offset1.y);
var distToCenter2 = Math.sqrt(offset2.x * offset2.x + offset2.y *
  offset2.y);</pre><p>Next, we’ll choose the correct collision point and calculate where <code class="literal">curBubble</code> needs to stop by adding the starting coordinates back into the system:</p><a id="pro_id00064"/><pre class="programlisting">if(distToCollision1 &lt; distToCollision2){
  var distToCollision = distToCollision1;
  var dest = {
    x : offset1.x + start.left,
    y : offset1.y + start.top
  };
}else{
  var distToCollision = distToCollision2;
  var dest = {
    x : -offset2.x + start.left,
    y : offset2.y + start.top
  };
}</pre><p>Most of the time, if the center of the bubble being fired collides with the edge of another bubble, it’ll cross twice: once on the way in and once on the way out. In the rare cases where it just brushes past and only a single collision point occurs, we’ll get two identical results, so it doesn’t matter which one we choose.</p><p><a id="iddle1556" class="indexterm"/><a id="iddle1576" class="indexterm"/><a id="iddle1583" class="indexterm"/><a id="iddle1921" class="indexterm"/>At this point, the function will loop over every bubble in the display and check for collisions; however, we don’t want to know about <span class="emphasis"><em>every</em></span> collision—just the <span class="emphasis"><em>nearest</em></span> one that occurs earliest in <code class="literal">curBubble</code>’s movement path.</p><p>To store the current best-match collision, we use the <code class="literal">collision</code> variable, which was set to <code class="literal">null</code> before the loop started. Then, each time we find a collision, we check to see if the new collision is closer than the previous best. If no previous collision happened, the first one we find will be the best. The <code class="literal">collision</code> object stores a reference to the stationary bubble that the fired bubble collides with, the distance to the collision, and the coordinates where it happened:</p><a id="pro_id00065"/><pre class="programlisting">         if(!collision || collision.distToCollision&gt;distToCollision){
            collision = {
              bubble : bubble,
              distToCollision : distToCollision,
              coords : dest
            };
          };
        };
      }
    }
  };
  return collision;
};</pre><p>Now the <code class="literal">findIntersection</code> function will return an object with all the data we need if a collision is found or <code class="literal">null</code> if no collision occurs. All of these calculations happen before the bubble has even started moving.</p></div></div></div><div class="sect1" title="Reacting to Collisions"><div class="titlepage"><div><div><h1 class="title"><a id="reacting_to_collisions"/>Reacting to Collisions</h1></div></div></div><p>We now need to use the collision coordinates we have in an amended version of <code class="literal">clickGameScreen</code> in <span class="emphasis"><em>game.js</em></span> so we can fire and stop bubbles. We’ve written the first step in detecting a collision by resolving what the bubble has collided with (which may be <span class="emphasis"><em>nothing</em></span>!). Now, <code class="literal">Game</code> needs to decide how to react to that information.</p><p>First, we check for a collision. If one occurs, we move the bubble to wherever the collision occurred. If one doesn’t occur, we fire the bubble off the screen. Change the existing <code class="literal">clickGameScreen</code> function in <span class="emphasis"><em>game.js</em></span> to the following:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00066"/><pre class="programlisting">  var clickGameScreen = function(e){
    var angle = getBubbleAngle(e);
    var bubble = $("#bubble");
    var duration = 750;
    var distance = 1000;
    <span class="strong"><strong>var collision = BubbleShoot.CollisionDetector.findIntersection(curBubble,</strong></span>
      <span class="strong"><strong>board,angle);</strong></span>
    <span class="strong"><strong>if(collision){</strong></span>
      <span class="strong"><strong>var coords = collision.coords;</strong></span>
  ➊    <span class="strong"><strong>duration = Math.round(duration * collision.distToCollision / distance);</strong></span>
    <span class="strong"><strong>}else{</strong></span>
      var distX = Math.sin(angle) * distance;
      var distY = Math.cos(angle) * distance;
      var bubbleCoords = BubbleShoot.ui.getBubbleCoords(curBubble.getSprite());
      var coords = {
        x : bubbleCoords.left + distX,
        y : bubbleCoords.top - distY
      };
    <span class="strong"><strong>};</strong></span>
    BubbleShoot.ui.fireBubble(curBubble,coords,duration);
    curBubble = getNextBubble();
  };</pre><p><a id="iddle1062" class="indexterm"/><a id="iddle1100" class="indexterm"/><a id="iddle1139" class="indexterm"/><a id="iddle1153" class="indexterm"/><a id="iddle1160" class="indexterm"/><a id="iddle1163" class="indexterm"/><a id="iddle1234" class="indexterm"/><a id="iddle1586" class="indexterm"/><a id="iddle1790" class="indexterm"/><a id="iddle2421" class="indexterm"/><a id="iddle2664" class="indexterm"/>If the distance the bubble moves has changed due to a collision, the time it needs to get there should also change, so all bubbles fire at the same velocity. We’ll use the collision data to recalculate that duration ➊.</p><p>Reload the game and fire a bubble. The bubble should stop when it hits the main group. But it still doesn’t look quite right. The bubble stops, but it doesn’t integrate itself into the board. It just sticks wherever it hits. Also, if you fire more bubbles, they just pile on top of each other; new bubbles won’t collide with previously fired bubbles. The problem is that the board state doesn’t change to synchronize with the display state, so we’ll correct this using two steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Add the fired bubble to the board state in the correct row and column.</p></li><li class="listitem"><p>When the fired bubble stops, lock it into a tidy grid position.</p></li></ol></div><p>The second step will use information from the first.</p><div class="sect2" title="Adding the bubble Object to the Board"><div class="titlepage"><div><div><h2 class="title"><a id="adding_the_bubble_object_to_the_board"/>Adding the bubble Object to the Board</h2></div></div></div><p>The <code class="literal">bubble</code> object, <code class="literal">curBubble</code>, is in the DOM and should end up close to the correct position on the screen, so we can add it to the board’s row/column array when we know where it should fit.</p><p>To calculate the row number, we divide the <span class="emphasis"><em>y</em></span>-coordinate by the height of rows and round down the result. Calculating the column number is similar, except we need to snap to either odd column numbers on even rows (including zero) or even column numbers on odd rows. Finally, we can add the bubble to the <code class="literal">rows</code> property of the <code class="literal">Board</code> object, because <code class="literal">Board</code> is where we’re storing positional information for all of the bubbles.</p><p>The function to add the fired bubble is trivial, so we’ll put that in <span class="emphasis"><em>board.js</em></span>. Within the definition of the board class and after the <code class="literal">getRows</code> method, add the following:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00067"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Board = (function($){
    var NUM_ROWS = 9;
    var NUM_COLS = 32;
    var Board = function(){
      var that = this;
      var rows = createLayout();
      this.getRows = function(){ return rows;};
      <span class="strong"><strong>this.addBubble = function(bubble,coords){</strong></span>
        <span class="strong"><strong>var rowNum = Math.floor(coords.y / BubbleShoot.ui.ROW_HEIGHT);</strong></span>
        <span class="strong"><strong>var colNum = coords.x / BubbleShoot.ui.BUBBLE_DIMS * 2;</strong></span>
        <span class="strong"><strong>if(rowNum % 2 == 1)</strong></span>
          <span class="strong"><strong>colNum -= 1;</strong></span>
        <span class="strong"><strong>colNum = Math.round(colNum/2) * 2;</strong></span>
        <span class="strong"><strong>if(rowNum % 2 == 0)</strong></span>
          <span class="strong"><strong>colNum -= 1;</strong></span>
        <span class="strong"><strong>if(!rows[rowNum])</strong></span>
          <span class="strong"><strong>rows[rowNum] = [];</strong></span>
➊        <span class="strong"><strong>rows[rowNum][colNum] = bubble;</strong></span>
➋        <span class="strong"><strong>bubble.setRow(rowNum);</strong></span>
➌        <span class="strong"><strong>bubble.setCol(colNum);</strong></span>
      <span class="strong"><strong>};</strong></span>
      return this;
    };
    var createLayout = function(){
      <span class="emphasis"><em>--snip--</em></span>
    };
    return Board;
  })(jQuery);</pre><p><a id="iddle1161" class="indexterm"/><a id="iddle1416" class="indexterm"/><a id="iddle1417" class="indexterm"/><a id="iddle1427" class="indexterm"/><a id="iddle1557" class="indexterm"/><a id="iddle1922" class="indexterm"/><a id="iddle2430" class="indexterm"/>Note that as well as adding the bubble into the correct row-column position in <code class="literal">rows[][]</code> ➊, we’re also passing the calculated row ➋ and column ➌ numbers to the <code class="literal">bubble</code> object so it knows its location relative to the other bubbles. We don’t have those method calls yet, so let’s create them now in <span class="emphasis"><em>bubble.js</em></span> in the <code class="literal">Bubble</code> class definition:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00068"/><pre class="programlisting">var Bubble = function(row,col,type,sprite){
  var that = this;
  this.getType = function(){ return type;};
  this.getSprite = function(){ return sprite;};
  this.getCol = function(){ return col;};
  <span class="strong"><strong>this.setCol = function(colIn){ col = colIn;};</strong></span>
  this.getRow = function(){ return row;};
  <span class="strong"><strong>this.setRow = function(rowIn){ row = rowIn;};</strong></span>
  this.getCoords = function(){
    <span class="emphasis"><em>--snip--</em></span>
  }
};</pre><p>Next, amend <span class="emphasis"><em>game.js</em></span> to call this new method in <code class="literal">clickGameScreen</code>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00069"/><pre class="programlisting">var clickGameScreen = function(e){
  var angle = BubbleShoot.ui.getBubbleAngle(curBubble.getSprite(),e);
  var duration = 750;
  var distance = 1000;
  var collision = BubbleShoot.CollisionDetector.findIntersection(curBubble,
    board,angle);
  if(collision){
    var coords = collision.coords;
    duration = Math.round(duration * collision.distToCollision / distance);
    <span class="strong"><strong>board.addBubble(curBubble,coords);</strong></span>
  }else{
    var distX = Math.sin(angle) * distance;
    var distY = Math.cos(angle) * distance;
    var bubbleCoords = BubbleShoot.ui.getBubbleCoords(curBubble.getSprite());
    var coords = {
      x : bubbleCoords.left + distX,
      y : bubbleCoords.top - distY
    };
  };
  BubbleShoot.ui.fireBubble(curBubble,coords,duration);
  curBubble = getNextBubble();
};</pre><p><a id="iddle1032" class="indexterm"/><a id="iddle1036" class="indexterm"/><a id="iddle1263" class="indexterm"/><a id="iddle1306" class="indexterm"/><a id="iddle1386" class="indexterm"/><a id="iddle1390" class="indexterm"/><a id="iddle1592" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1765" class="indexterm"/><a id="iddle1772" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle2003" class="indexterm"/><a id="iddle2109" class="indexterm"/><a id="iddle2115" class="indexterm"/><a id="iddle2622" class="indexterm"/><a id="iddle2636" class="indexterm"/>Reload the game and shoot a few bubbles. They should start to pile up, although some may still overlap because they don’t quite settle properly into the grid. It’s progress, but we want the bubbles to line up nicely when they collide—that’s what we’ll do next.</p></div><div class="sect2" title="Locking the bubble Object into the Grid"><div class="titlepage"><div><div><h2 class="title"><a id="locking_the_bubble_object_into_the_grid"/>Locking the bubble Object into the Grid</h2></div></div></div><p>When the fired bubbles collide with the rest of the board, we want to lock them in place rather than just having them stop wherever they hit. The current movement works well, but we need to add another step that locks the bubble into position when it reaches its destination.</p><p>After <code class="literal">board.addBubble</code> has been run, the <code class="literal">bubble</code> object knows which row and column it’s located in; therefore, calling its <code class="literal">getCoords</code> method (which calculates based on row and column) will retrieve the coordinates where it should be rather than the coordinates where it actually stopped. To nudge it into place, we’ll add a <code class="literal">complete</code> function that can be set as part of a jQuery <code class="literal">animate</code> call and use the information the bubble already has. As a result, we can fire the bubble and forget about it rather than creating a process to tidy up bubbles as they land. jQuery’s <code class="literal">complete</code> callback function is a useful place to put code that needs to run when an animation has finished. For example, in a game with an explosion effect, the frames of the animation could run, and when the animation finishes, the DOM elements that formed the explosion could be removed from the screen.</p><p>The <code class="literal">complete</code> property is called when the animation has ended. In <span class="emphasis"><em>ui.js</em></span> amend <code class="literal">fireBubble</code> as follows:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00070"/><pre class="programlisting">  fireBubble : function(bubble,coords,duration){
    bubble.getSprite().animate({
        left : coords.x - ui.BUBBLE_DIMS/2,
        top : coords.y - ui.BUBBLE_DIMS/2
      },
      {
        duration : duration,
        easing : "linear"<span class="strong"><strong>,</strong></span>
        <span class="strong"><strong>complete : function(){</strong></span>
➊        <span class="strong"><strong>if(bubble.getRow() !== null){</strong></span>
            <span class="strong"><strong>bubble.getSprite().css({</strong></span>
              <span class="strong"><strong>left : bubble.getCoords().left - ui.BUBBLE_DIMS/2,</strong></span>
              <span class="strong"><strong>top : bubble.getCoords().top - ui.BUBBLE_DIMS/2</strong></span>
            <span class="strong"><strong>});</strong></span>
          <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>}</strong></span>
    });
  },</pre><p><a id="iddle1428" class="indexterm"/><a id="iddle1683" class="indexterm"/>When you reload, the bubbles you fire should settle into the grid system. Note that we use <code class="literal">getRow</code> to check whether a collision has occurred ➊, because <code class="literal">getRow</code> should return <code class="literal">null</code> for a bubble that misses all other bubbles and moves off the screen.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00005"/>Summary</h1></div></div></div><p>Now that fired bubbles collide with the others on the board, <span class="emphasis"><em>Bubble Shooter</em></span> is starting to act more like a game. We’ve moved sprites across the screen using jQuery, made the game react to the player’s input, and set up some of the basic game logic. However, currently there’s no way to pop bubbles, and it won’t be much of a game without that functionality. Popping logic and displaying an animation are the subjects of the next chapter.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00006"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Each row of the game board is offset to form a staggered pattern. Change the code in <code class="literal">createLayout</code> so the bubbles form a regular grid. How will this change the game?</p></li><li class="listitem"><p>Now that you can make <code class="literal">createLayout</code> build a different grid pattern, write code to generate an entirely new layout. For example, you could draw only every alternate column or build a more creative layout.</p></li><li class="listitem"><p><span class="emphasis"><em>Bubble Shooter</em></span> has a simple object structure that consists of a <code class="literal">Game</code>, a <code class="literal">Board</code>, and a set of <code class="literal">Bubbles</code>. What sort of objects would you need if you were building a game like <span class="emphasis"><em>Angry Birds</em></span>, <span class="emphasis"><em>Bejeweled</em></span>, or <span class="emphasis"><em>Candy Crush</em></span>?</p></li></ol></div></div></div></body></html>