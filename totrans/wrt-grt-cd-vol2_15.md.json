["```\n\n\t\t\t#include <stdio.h>\n\nvoid func( void )\n{\n    return;\n}\nint main( void )\n{\n    func();\n    return( 0 );\n}\n```", "```\n\n\t\t\t_func:\n        ; Set up activation record for function.\n        ; Note R1 is used as the stack pointer by\n        ; the PowerPC ABI (application binary\n        ; interface, defined by IBM).\n\n        stmw r30,-8(r1)\n        stwu r1,-48(r1)\n        mr r30,r1\n\n        ; Clean up activation record prior to the return\n\n        lwz r1,0(r1)\n        lmw r30,-8(r1)\n\n        ; Return to caller (branch to address\n        ; in the link register):\n\n        blr\n\n_main:\n        ; Save return address from\n        ; main program (so we can\n        ; return to the OS):\n\n        mflr r0\n        stmw r30,-8(r1) ; Preserve r30/31\n        stw r0,8(r1)    ; Save rtn adrs\n        stwu r1,-80(r1) ; Update stack for func()\n        mr r30,r1       ; Set up frame pointer\n\n        ; Call func:\n\n        bl _func\n\n        ; Return 0 as the main\n        ; function result:\n\n        li r0,0\n        mr r3,r0\n        lwz r1,0(r1)\n        lwz r0,8(r1)\n        mtlr r0\n        lmw r30,-8(r1)\n        blr\n```", "```\n\n\t\t\tfunc:\n    @ args = 0, pretend = 0, frame = 0\n    @ frame_needed = 1, uses_anonymous_args = 0\n    @ link register save eliminated.\n\n    str fp, [sp, #-4]!  @ Save frame pointer on stack\n    add fp, sp, #0\n    nop\n    add sp, fp, #0\n    @ sp needed\n    ldr fp, [sp], #4    @ Load FP from stack.\n    bx  lr              @ Return from subroutine\n\nmain:\n    @ args = 0, pretend = 0, frame = 0\n    @ frame_needed = 1, uses_anonymous_args = 0\n\n    push    {fp, lr}    @ Save FP and return address\n\n    add fp, sp, #4      @ Set up FP\n    bl  func            @ Call func\n    mov r3, #0          @ main return value = 0\n    mov r0, r3\n\n    @ Note that popping PC returns to Linux\n    pop {fp, pc}\n```", "```\n\n\t\t\tfunc:\n.LFB0:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    nop\n    popq    %rbp\n    ret\n\nmain:\n.LFB1:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    call    func\n    movl    $0, %eax\n    popq    %rbp\n    ret\n```", "```\n\n\t\t\t#include <stdio.h>\n\nextern void func( void );\n\nint main( void )\n{\n    func();\n\n    return( 0 );\n}\n```", "```\n\n\t\t\t.text\n        .align 2\n        .globl _main\n_main:\n        ; Set up main's activation record:\n\n        mflr r0\n        stw r0,8(r1)\n        stwu r1,-80(r1)\n\n        ; Call a \"stub\" routine that will\n        ; do the real call to func():\n\n        bl L_func$stub\n\n        ; Return 0 as Main's function\n        ; result:\n\n        lwz r0,88(r1)\n        li r3,0\n        addi r1,r1,80\n        mtlr r0\n        blr\n\n; The following is a stub that calls the\n; real func() function, wherever it is in\n; memory.\n\n        .data\n        .picsymbol_stub\nL_func$stub:\n        .indirect_symbol _func\n\n        ; Begin by saving the LINK register\n        ; value in R0 so we can restore it\n        ; later.\n\n        mflr r0\n\n        ; The following code sequence gets\n        ; the address of the L_func$lazy_ptr\n        ; pointer object into R12:\n\n        bcl 20,31,L0$_func      ; R11<-adrs(L0$func)\nL0$_func:\n        mflr r11\n        addis r11,r11,ha16(L_func$lazy_ptr-L0$_func)\n\n        ; Restore the LINK register (used by the\n        ; preceding code) from R0:\n\n        mtlr r0\n\n        ; Compute the address of func() and move it\n        ; into the PowerPC COUNT register:\n\n        lwz r12,lo16(L_func$lazy_ptr-L0$_func)(r11)\n        mtctr r12\n\n        ; Set up R11 with an environment pointer:\n\n        addi r11,r11,lo16(L_func$lazy_ptr-L0$_func)\n\n        ; Branch to address held in the COUNT\n        ; register (that is, to func):\n\n        bctr\n\n; The linker will initialize the following\n; dword (.long) value with the address of\n; the actual func() function:\n\n        .data\n        .lazy_symbol_pointer\nL_func$lazy_ptr:\n        .indirect_symbol _func\n        .long dyld_stub_binding_helper\n```", "```\n\n\t\t\tusing System;\n\nnamespace Calls_f\n{\n     class program\n      {\n        static void f()\n        {\n            return;\n        }\n        static void Main( string[] args)\n        {\n            f();\n        }\n      }\n}\n```", "```\n\n\t\t\t.method private hidebysig static void  f() cil managed\n{\n  // Code size       4 (0x4)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  br.s       IL_0003\n  IL_0003:  ret\n} // end of method program::f\n\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // Code size       8 (0x8)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  call       void Calls_f.program::f()\n  IL_0006:  nop\n  IL_0007:  ret\n} // end of method program::Main\n```", "```\n\n\t\t\tpublic class Calls_f\n{\n    public static void f()\n    {\n        return;\n    }\n\n    public static void main( String[] args )\n    {\n        f();\n    }\n}\n```", "```\n\n\t\t\tCompiled from \"Calls_f.java\"\npublic class Calls_f extends java.lang.Object{\npublic Calls_f();\n  Code:\n   0:   aload_0\n        //call Method java/lang/Object.\"<init>\":()\n   1:   invokespecial   #1;\n   4:   return\n\npublic static void f();\n  Code:\n   0:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   invokestatic    #2; //Method f:()\n   3:   return\n\n}\n```", "```\n\n\t\t\tvoid g( void )\n{\n    return;\n}\n\nvoid f( void )\n{\n    g();\n    g();\n    return;\n}\n\nint main( void )\n{\n    f();\n    return( 0 );\n}\n```", "```\n\n\t\t\t; g's function code:\n\n_g:\n        ; Set up g's environment\n        ; (set up activation record):\n\n        stmw r30,-8(r1)\n        stwu r1,-48(r1)\n        mr r30,r1\n\n        ; Tear down the activation\n        ; record.\n\n        lwz r1,0(r1)\n        lmw r30,-8(r1)\n\n        ; Return to caller via LINK:\n\n        blr\n\n; f's function code:\n\n_f:\n        ; Set up activation record,\n        ; including saving the value\n        ; of the LINK register:\n\n        mflr r0         ; R0 = LINK\n        stmw r30,-8(r1)\n        stw r0,8(r1)    ; Save LINK\n        stwu r1,-80(r1)\n        mr r30,r1\n\n        ; Call g (twice):\n\n        bl _g\n        bl _g\n\n        ; Restore LINK from the\n        ; activation record and\n        ; then clean up activation\n        ; record:\n\n        lwz r1,0(r1)\n        lwz r0,8(r1)    ; R0 = saved adrs\n        mtlr r0         ; LINK = RO\n        lmw r30,-8(r1)\n\n        ; Return to main function:\n\n        blr\n\n; Main function code:\n\n_main:\n        ; Save main's return\n        ; address into main's\n        ; activation record:\n\n        mflr r0\n        stmw r30,-8(r1)\n        stw r0,8(r1)\n        stwu r1,-80(r1)\n        mr r30,r1\n\n        ; Call the f function:\n\n        bl _f\n\n        ; Return 0 to whomever\n        ; called main:\n\n        li r0,0\n        mr r3,r0\n        lwz r1,0(r1)\n        lwz r0,8(r1)    ; Move saved return\n        mtlr r0         ; address to LINK\n        lmw r30,-8(r1)\n        ; Return to caller:\n\n        blr\n```", "```\n\n\t\t\tfunction sum( a:integer; b:integer ):integer;\nbegin\n\n       (* returns sum of a & b as function result *)\n\n        sum := a + b;\n\nend;\n      .\n      .\n      .\nsum( aParam, bParam );\n```", "```\n\n\t\t\tmov( aParam, eax );\nadd( bParam, eax );\nmov( eax, destVariable );\n```", "```\n\n\t\t\tpush( aParam );\npush( bParam );\ncall sum;\n```", "```\n\n\t\t\t// Construct the activation record\n\npush( ebp );\nmov( esp, ebp );\n\n// Get aParam's value\n\nmov( [ebp+12], eax );\n\n// Compute their sum and return in EAX\n\nadd( [ebp+8], eax );\n\n// Restore EBP's value\n\npop( ebp );\n\n// Return to caller, cleaning up\n// the activation record.\n\nret( 8 );\n```", "```\n\n\t\t\t#include <stdio.h>\n\n// Make geti and getj external functions\n// to thwart constant propagation so we\n// can see the effects of the following\n// code.\n\nextern int geti( void );\nextern int getj( void );\n\n// Inline function demonstration. Note\n// that \"_inline\" is the legacy MSVC++ \"C\" way\n// of specifying an inline function (the\n// actual \"inline\" keyword was a C++/C99 feature,\n// which this code avoids in order to make\n// the assembly output a little more readable).\n//\n//\n// \"inlineFunc\" is a simple inline function\n// that demonstrates how the C/C++ compiler\n// does a simple inline macro expansion of\n// the function:\n\n_inline int inlineFunc( int a, int b )\n{\n    return a + b;\n}\n\n_inline int ilf2( int a, int b )\n{\n    // Declare some variable that will require\n    // an activation record to be built (that is,\n    // register allocation won't be sufficient):\n\n    int m;\n    int c[4];\n    int d;\n\n    // Make sure we use the \"c\" array so that\n    // the optimizer doesn't ignore its\n    // declaration:\n\n    for( m = 0; m < 4; ++m )\n    {\n        c[m] = geti();\n    }\n    d = getj();\n    for( m = 0; m < 4; ++m )\n    {\n        d += c[m];\n    }\n    // Return a result to the calling program:\n\n    return (a + d) - b;\n}\n\nint main( int argc, char **argv )\n{\n    int i;\n    int j;\n    int sum;\n    int result;\n\n    i = geti();\n    j = getj();\n    sum = inlineFunc( i, j );\n    result = ilf2( i, j );\n    printf( \"i+j=%d, result=%d\\n\", sum, result );\n    return 0;\n}\n```", "```\n\n\t\t\t_main      PROC NEAR\nmain    PROC\n;\n; Create the activation record:\n;\n$LN6:\n        mov     QWORD PTR [rsp+8], rbx\n        push    rdi\n        sub     rsp, 32        ; 00000020H\n; Line 66\n;\n; i = geti();\n;\n        call    ?geti@@YAHXZ   ; geti -- returns result in EAX\n        mov     edi, eax       ; Save i in edi\n\n; Line 67\n;\n; j = getj();\n;\n        call    ?getj@@YAHXZ   ; getj -- Returns result in EAX\n; Line 69\n;\n; Inline expansion of inlineFunc()\n;\n        mov     edx, eax       ; Pass j in EDX\n        mov     ecx, edi       ; Pass i in ECX\n        mov     ebx, eax       ; Use EBX as \"sum\" local\n        call    ?ilf2@@YAHHH@Z ; ilf2\n\n;       Computes sum = i+j (inline)\n\n        lea     edx, DWORD PTR [rbx+rdi]\n\n; Line 70\n;\n; Call to printf function:\n\n        mov     r8d, eax\n        lea     rcx, OFFSET FLAT:??_C@_0BD@INCDFJPK@i?$CLj?$DN?$CFd?0?5result?$DN?$CFd?6?$AA@\n        call    printf\n; Line 72\n;\n; Return from main function\n;\n        mov     rbx, QWORD PTR [rsp+48]\n        xor     eax, eax\n        add     rsp, 32        ; 00000020H\n        pop     rdi\n        ret     0\nmain    ENDP\n\n?ilf2@@YAHHH@Z PROC            ; ilf2, COMDAT\n; File v:\\t.cpp\n; Line 30\n$LN24:\n        mov     QWORD PTR [rsp+8], rbx\n        mov     QWORD PTR [rsp+16], rsi\n        push    rdi\n        sub     rsp, 64        ; 00000040H\n;\n; Extra code to help prevent hacks from messing with\n; stack data (clears array data to prevent observing old\n; memory data).\n\n        mov     rax, QWORD PTR __security_cookie\n        xor     rax, rsp\n        mov     QWORD PTR __$ArrayPad$[rsp], rax\n        mov     edi, edx\n        mov     esi, ecx\n; Line 43\n; Loop to fill \"v\" array:\n;\n        xor     ebx, ebx\n$LL4@ilf2:\n; Line 45\n        call    ?geti@@YAHXZ   ; geti\n        mov     DWORD PTR c$[rsp+rbx*4], eax\n        inc     rbx\n        cmp     rbx, 4\n        jl      SHORT $LL4@ilf2\n\n; Line 47\n;\n; d = getj();\n;\n        call    ?getj@@YAHXZ   ; getj\n; Line 50\n;\n; Second for loop is unrolled and expanded inline:\n;\n; d += c[m];\n\n        mov     r8d, DWORD PTR c$[rsp+8]\n        add     r8d, DWORD PTR c$[rsp+12]\n        add     r8d, DWORD PTR c$[rsp]\n        add     r8d, DWORD PTR c$[rsp+4]\n;\n; return (a+d) - b\n;\n        add     eax, r8d\n; Line 55\n        sub     eax, edi\n        add     eax, esi\n; Line 56\n;\n; Verify code did not mess with stack before leaving\n; (array overflow):\n;\n        mov     rcx, QWORD PTR __$ArrayPad$[rsp]\n        xor     rcx, rsp\n        call    __security_check_cookie\n        mov     rbx, QWORD PTR [rsp+80]\n        mov     rsi, QWORD PTR [rsp+88]\n        add     rsp, 64        ; 00000040H\n        pop     rdi\n        ret     0\n?ilf2@@YAHHH@Z ENDP            ; ilf2\n\n?inlineFunc@@YAHHH@Z PROC      ; inlineFunc, COMDAT\n; File v:\\t.cpp\n; Line 26\n        lea     eax, DWORD PTR [rcx+rdx]\n; Line 27\n        ret     0\n?inlineFunc@@YAHHH@Z ENDP      ; inlineFunc\n```", "```\n\n\t\t\t#include <stdio.h>\n\ntypedef struct\n{\n    int array[256];\n} a_t;\n\nvoid f( a_t a )\n{\n    a.array[0] = 0;\n    return;\n}\n\nint main( void )\n{\n    a_t b;\n\n    f( b );\n    return( 0 );\n}\n```", "```\n\n\t\t\t_f:\n        li r0,0 ; To set a.array[0] = 0\n\n        ; Note: the PowerPC ABI passes the\n        ; first eight dwords of data in\n        ; R3..R10\\. We need to put that\n        ; data back into the memory array\n        ; here:\n\n        stw r4,28(r1)\n        stw r5,32(r1)\n        stw r6,36(r1)\n        stw r7,40(r1)\n        stw r8,44(r1)\n        stw r9,48(r1)\n        stw r10,52(r1)\n\n        ; Okay, store 0 into a.array[0]:\n\n        stw r0,24(r1)\n\n        ; Return to caller:\n\n        blr\n\n; main function:\n\n_main:\n\n        ; Set up main's activation record:\n\n        mflr r0\n        li r5,992\n        stw r0,8(r1)\n\n        ; Allocate storage for a:\n\n        stwu r1,-2096(r1)\n\n        ; Copy all but the first\n        ; eight dwords to the\n        ; activation record for f:\n\n        addi r3,r1,56\n        addi r4,r1,1088\n        bl L_memcpy$stub\n\n        ; Load the first eight dwords\n        ; into registers (as per the\n        ; PowerPC ABI):\n\n        lwz r9,1080(r1)\n        lwz r3,1056(r1)\n        lwz r10,1084(r1)\n        lwz r4,1060(r1)\n        lwz r5,1064(r1)\n        lwz r6,1068(r1)\n        lwz r7,1072(r1)\n        lwz r8,1076(r1)\n\n        ; Call the f function:\n\n        bl _f\n\n        ; Clean up the activation record\n        ; and return 0 to main's caller:\n\n        lwz r0,2104(r1)\n        li r3,0\n        addi r1,r1,2096\n        mtlr r0\n        blr\n\n; Stub function that copies the structure\n; data to the activation record for the\n; main function (this calls the C standard\n; library memcpy function to do the actual copy):\n\n        .data\n        .picsymbol_stub\nL_memcpy$stub:\n        .indirect_symbol _memcpy\n        mflr r0\n        bcl 20,31,L0$_memcpy\nL0$_memcpy:\n        mflr r11\n        addis r11,r11,ha16(L_memcpy$lazy_ptr-L0$_memcpy)\n        mtlr r0\n        lwz r12,lo16(L_memcpy$lazy_ptr-L0$_memcpy)(r11)\n        mtctr r12\n        addi r11,r11,lo16(L_memcpy$lazy_ptr-L0$_memcpy)\n        bctr\n.data\n.lazy_symbol_pointer\nL_memcpy$lazy_ptr:\n        .indirect_symbol _memcpy\n        .long dyld_stub_binding_helper\n```", "```\n\n\t\t\t#include <stdio.h>\n\ntypedef struct\n{\n    int array[256];\n} a_t;\n\nvoid f( a_t *a )\n{\n    a->array[0] = 0;\n    return;\n}\n\nint main( void )\n{\n    a_t b;\n    f( &b );\n    return( 0 );\n}\n```", "```\n\n\t\t\tf:\n    @ Build activation record:\n\n    str fp, [sp, #-4]!  @ Push old FP on stack\n    add fp, sp, #0      @ FP = SP\n    sub sp, sp, #12     @ Reserve storage for locals\n    str r0, [fp, #-8]   @ Save pointer to 'a'\n    ldr r3, [fp, #-8]   @ r3 = a\n\n    @ a->array[0] = 0;\n\n    mov r2, #0\n    str r2, [r3]\n    nop\n\n    @ Remove locals from stack.\n\n    add sp, fp, #0\n\n    @ Pop FP from stack:\n\n    ldr fp, [sp], #4\n\n    @ Return to main function:\n\n    bx  lr\n\nmain:\n    @ Save Linux return address and FP:\n\n    push    {fp, lr}\n @ Set up activation record:\n\n    add fp, sp, #4\n    sub sp, sp, #1024   @ Reserve storage for b\n    sub r3, fp, #1024   @ R3 = &b\n    sub r3, r3, #4\n\n    mov r0, r3          @ Pass &b to f in R0\n    bl  f               @ Call f\n\n    @ Return 0 result to Linux:\n\n    mov r3, #0\n    mov r0, r3\n    sub sp, fp, #4      @ Clean up stack frame\n    pop {fp, pc}        @ Returns to Linux\n```", "```\n\n\t\t\t#include <stdio.h>\n\n// Make geti an external function\n// to thwart constant propagation so we\n// can see the effects of the following\n// code.\n\nextern int geti( void );\n\n// globalValue is a global variable that\n// we use to pass data to the \"usesGlobal\"\n// function:\n\nint globalValue = 0;\n // Inline function demonstration. Note\n// that \"_inline\" is the legacy MSVC++ \"C\" way\n// of specifying an inline function (the\n// actual \"inline\" keyword is a C99/C++ feature,\n// which this code avoids in order to make\n// the assembly output a little more readable).\n\n_inline int usesGlobal( int plusThis )\n{\n    return globalValue+plusThis;\n}\n\n_inline int usesParm( int plusThis, int globalValue )\n{\n    return globalValue+plusThis;\n}\n\nint main( int argc, char **argv )\n{\n    int i;\n    int sumLocal;\n    int sumGlobal;\n\n    // Note: the call to geti in between setting globalValue\n    // and calling usesGlobal is intentional. The compiler\n    // doesn't know that geti doesn't modify the value of\n    // globalValue (and neither do we, frankly), and so\n    // the compiler cannot use constant propagation here.\n\n    globalValue = 1;\n    i = geti();\n    sumGlobal = usesGlobal( 5 );\n\n    // If we pass the \"globalValue\" as a parameter rather\n    // than setting a global variable, then the compiler\n    // can optimize the code away:\n\n    sumLocal = usesParm( 5, 1 );\n    printf( \"sumGlobal=%d, sumLocal=%d\\n\", sumGlobal, sumLocal );\n    return 0;\n}\n```", "```\n\n\t\t\t_main      PROC NEAR\n;   globalValue = 1;\n\n    mov    DWORD PTR _globalValue, 1\n\n;   i = geti();\n;\n; Note that because of dead code elimination,\n; MSVC++ doesn't actually store the result\n; away into i, but it must still call geti()\n; because geti() could produce side effects\n; (such as modifying globalValue's value).\n\n    call   _geti\n\n;   sumGlobal = usesGlobal( 5 );\n;\n; Expanded inline to:\n;\n; globalValue+plusThis\n\n    mov    eax, DWORD PTR _globalValue\n    add    eax, 5          ; plusThis = 5\n\n; The compiler uses constant propagation\n; to compute:\n;   sumLocal = usesParm( 5, 1 );\n; at compile time. The result is 6, which\n; the compiler directly passes to print here:\n\n    push   6\n\n; Here's the result for the usesGlobal expansion,\n; computed above:\n\n    push   eax\n    push   OFFSET FLAT:formatString ; 'string'\n    call   _printf\n    add    esp, 12                  ; Remove printf parameters\n\n; return 0;\n\n    xor    eax, eax\n    ret    0\n_main      ENDP\n_TEXT      ENDS\n           END\n```", "```\n\n\t\t\tprogram ActivationRecordDemo;\n\n    procedure C;\n    begin\n\n        (* Stack Snapshot here *)\n\n    end;\n\n    procedure B;\n    begin\n\n        C;\n\n    end;\n\n    procedure A;\n    begin\n\n        B;\n\n    end;\n\nbegin (* Main program *)\n\n    A;\n\nend.\n```", "```\n\n\t\t\tvoid recursive( int cnt )\n{\n    if( cnt != 0 )\n    {\n        recursive( cnt - 1 );\n    }\n}\n\nint main( int argc, char **argv )\n{\n    recursive( 2 );\n}\n```", "```\n\n\t\t\tprocedure HasBoth( i:integer; j:integer; k:integer );\nvar\n    a  :integer;\n    r  :integer;\n    c  :char;\n    b  :char;\n    w  :smallint;  (* smallints are 16 bits *)\nbegin\n        .\n        .\n        .\nend;\n```", "```\nHasBoth( 5, x, y + 2 );\n```", "```\n\n\t\t\tpushd( 5 );\npush( x );\nmov( y, eax );\nadd( 2, eax );\npush( eax );\ncall HasBoth;\n```", "```\n\n\t\t\t// Preserve caller's base address.\n\n        push( ebp );\n\n        // ESP points at the value we just saved. Use its address\n        // as the activation record's base address.\n\n        mov( esp, ebp );\n```", "```\nsub( 12, esp );\n```", "```\n\n\t\t\t// Deallocates the local variables\n// by copying EBP to ESP.\n\nmov( ebp, esp );\n\n// Restore original EBP value.\n\npop( ebp );\n\n// Pops return address and\n//  12 parameter bytes (3 dwords)\n\nret( 12 );\n```", "```\n\n\t\t\tchar c;\nint  i;\n```", "```\n\n\t\t\tchar c0;\nint  i0;\nchar c1;\nint  i1;\nchar c2;\nint  i2;\nchar c3;\nint  i3;\n```", "```\n\n\t\t\tchar c0;\nchar c1;\nchar c2;\nchar c3;\nint  i0;\nint  i1;\nint  i2;\nint  i3;\n```", "```\nHasBoth( 5, x, y + 2 );\n```", "```\n\n\t\t\t// Push the value for parameter i:\n\npushd( 5 );\n\n// Push x's value for parameter j:\n\npush( x );\n\n// Compute y + 2 in EAX and push this as the value\n// for parameter k:\n\nmov( y, eax );\nadd( 2, eax );\npush( eax );\n\n// Call the HasBoth procedure with these\n// three parameter values:\n\ncall HasBoth;\n```", "```\n\n\t\t\tvoid HasBoth( int i, int j, int k )\n{\n    int a;\n    int r;\n    char c;\n    char b;\n    short w;  /* assumption: short ints are 16 bits */\n        .\n        .\n        .\n}\n```", "```\nHasBoth( 5, x, y + 2 );\n```", "```\n\n\t\t\t// Compute y + 2 in EAX and push this\n// as the value for parameter k\n\nmov( y, eax );\nadd( 2, eax );\npush( eax );\n\n// Push x's value for parameter j\n\npush( x );\n\n// Push the value for parameter i\n\npushd( 5 );\n\n// Call the HasBoth procedure with\n// these three parameter values\n\ncall HasBoth;\n\n// Remove parameters from the stack.\n\nadd( 12, esp );\n```", "```\n\n\t\t\tprocedure OneByteParm( b:byte ); @nodisplay;\n    // local variable declarations\nbegin OneByteParm;\n    .\n    .\n    .\nend OneByteParm;\n```", "```\n\n\t\t\t// Declaration set #1:\n\nchar string[256];\nint i;\nint j;\nchar c;\n```", "```\n\n\t\t\t// Declaration set #2\n\nint i;\nint j;\nchar c;\nchar string[256];\n```", "```\n\n\t\t\t#include <stdio.h>\nint main( int argc, char **argv )\n{\n    int a;\n    int b[256];\n    int c;\n    int d[16*1024*1024];\n    int e;\n    int f;\n\n    a = argc;\n    b[0] = argc + argc;\n    b[255] = a + b[0];\n    c = argc + b[1];\n    d[0] = argc + a;\n    d[4095] = argc + b[255];\n    e = a + c;\n    printf\n    (\n        \"%d %d %d %d %d \",\n        a,\n        b[0],\n        c,\n        d[0],\n        e\n    );\n    return( 0 );\n}\n```", "```\n\n\t\t\t.data\n        .cstring\n        .align 2\n        LC0:\n        .ascii \"%d %d %d %d %d \\0\"\n        .text\n\n; main function:\n\n        .align 2\n        .globl _main\n_main:\n        ; Set up main's activation record:\n\n        mflr r0\n        stmw r30,-8(r1)\n        stw r0,8(r1)\n        lis r0,0xfbff\n        ori r0,r0,64384\n        stwux r1,r1,r0\n        mr r30,r1\n        bcl 20,31,L1$pb\nL1$pb:\n        mflr r31\n\n        ; The following allocates\n        ; 16MB of storage on the\n        ; stack (R30 is the stack\n        ; pointer here).\n\n        addis r9,r30,0x400\n        stw r3,1176(r9)\n\n        ; Fetch the value of argc\n        ; into the R0 register:\n\n        addis r11,r30,0x400\n        lwz r0,1176(r11)\n        stw r0,64(r30)      ; a = argc\n\n        ; Fetch the value of argc\n        ; into r9\n\n        addis r11,r30,0x400\n        lwz r9,1176(r11)\n\n        ; Fetch the value of argc\n        ; into R0:\n\n        addis r11,r30,0x400\n        lwz r0,1176(r11)\n\n        ; Compute argc + argc and\n        ; store it into b[0]:\n\n        add r0,r9,r0\n        stw r0,80(r30)\n\n        ; Add a + b[0] and\n        ; store into c:\n\n        lwz r9,64(r30)\n        lwz r0,80(r30)\n        add r0,r9,r0\n        stw r0,1100(r30)\n        ; Get argc's value, add in\n        ; b[1], and store into c:\n\n        addis r11,r30,0x400\n        lwz r9,1176(r11)\n        lwz r0,84(r30)\n        add r0,r9,r0\n        stw r0,1104(r30)\n\n        ; Compute argc + a and\n        ; store into d[0]:\n\n        addis r11,r30,0x400\n        lwz r9,1176(r11)\n        lwz r0,64(r30)\n        add r0,r9,r0\n        stw r0,1120(r30)\n\n        ; Compute argc + b[255] and\n        ; store into d[4095]:\n\n        addis r11,r30,0x400\n        lwz r9,1176(r11)\n        lwz r0,1100(r30)\n        add r0,r9,r0\n        stw r0,17500(r30)\n\n        ; Compute argc + b[255]:\n\n        lwz r9,64(r30)\n        lwz r0,1104(r30)\n        add r9,r9,r0\n\n; ************************************************\n        ; Okay, here's where it starts\n        ; to get ugly. We need to compute\n        ; the address of e so we can store\n        ; the result currently held in r9\n        ; into e. But e's offset exceeds\n        ; what we can encode into a single\n        ; instruction, so we have to use\n        ; the following sequence rather\n        ; than a single instruction.\n\n        lis r0,0x400\n        ori r0,r0,1120\n        stwx r9,r30,r0\n\n; ************************************************\n        ; The following sets up the\n        ; call to printf and calls printf:\n\n        addis r3,r31,ha16(LC0-L1$pb)\n        la r3,lo16(LC0-L1$pb)(r3)\n        lwz r4,64(r30)\n        lwz r5,80(r30)\n        lwz r6,1104(r30)\n        lwz r7,1120(r30)\n        lis r0,0x400\n        ori r0,r0,1120\n        lwzx r8,r30,r0\n        bl L_printf$stub\n        li r0,0\n        mr r3,r0\n        lwz r1,0(r1)\n        lwz r0,8(r1)\n        mtlr r0\n        lmw r30,-8(r1)\n        blr\n\n; Stub, to call the external printf function:\n\n        .data\n        .picsymbol_stub\nL_printf$stub:\n        .indirect_symbol _printf\n        mflr r0\n        bcl 20,31,L0$_printf\nL0$_printf:\n        mflr r11\n        addis r11,r11,ha16(L_printf$lazy_ptr-L0$_printf)\n        mtlr r0\n        lwz r12,lo16(L_printf$lazy_ptr-L0$_printf)(r11)\n        mtctr r12\n        addi r11,r11,lo16(L_printf$lazy_ptr-L0$_printf)\n        bctr\n.data\n.lazy_symbol_pointer\nL_printf$lazy_ptr:\n        .indirect_symbol _printf\n        .long dyld_stub_binding_helper\n```", "```\n\n\t\t\tlis r0,0x400\nori r0,r0,1120\nstwx r9,r30,r0\n```", "```\nstw r0,64(r30)      ; a = argc\n```", "```\n\n\t\t\t.globl _main\n_main:\n\n; Build main's activation record:\n\n        mflr r0\n        stw r31,-4(r1)\n        stw r0,8(r1)\n        bcl 20,31,L1$pb\nL1$pb:\n        ; Compute values, set up parameters,\n        ; and call printf:\n\n        lis r0,0xfbff\n        slwi r9,r3,1\n        ori r0,r0,64432\n        mflr r31\n        stwux r1,r1,r0\n        add r11,r3,r9\n        mr r4,r3\n        mr r0,r3\n        lwz r6,68(r1)\n        add r0,r0,r11 ;c = argc + b[1]\n        stw r0,17468(r1)\n        mr r5,r9\n        add r6,r3,r6\n        stw r9,64(r1)\n        addis r3,r31,ha16(LC0-L1$pb)\n        stw r11,1084(r1)\n        stw r9,1088(r1)\n        la r3,lo16(LC0-L1$pb)(r3)\n        mr r7,r9\n        add r8,r4,r6\n        bl L_printf$stub\n\n; Clean up main's activation\n; record and return 0:\n\n        lwz r1,0(r1)\n        li r3,0\n        lwz r0,8(r1)\n        lwz r31,-4(r1)\n        mtlr r0\n        blr\n```", "```\n\n\t\t\t.LC0:\n    .ascii  \"%d %d %d %d %d \\000\"\n\nmain:\n\n    @ Set up activation record\n\n    push    {fp, lr}\n    add fp, sp, #4\n\n    @ Reserve storage for locals.\n    @ (2 instructions due to instruction\n    @ size limitations).\n\n    add sp, sp, #-67108864\n    sub sp, sp, #1056\n\n    @ Store argc (passed in R0)\n    @ into a. Three additions\n    @ (-67108864, 4, and -1044)\n    @ are needed because of ARM\n    @ 32-bit instruction encoding\n    @ limitations\n\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    str r0, [r3, #-1044]\n\n    @ a = argc\n\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r3, [r3, #-1044]    @ r3 = argc\n    str r3, [fp, #-8]       @ a = argc\n\n    @ b[0] = argc + argc\n\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r2, [r3, #-1044]    @ R2 = argc\n    ldr r3, [r3, #-1044]    @ R3 = argc\n    add r3, r2, r3          @ R3 = argc + argc\n    str r3, [fp, #-1040]    @ b[0] = argc+argc\n\n    ldr r2, [fp, #-1040]    @ R2 = b[0]\n    ldr r3, [fp, #-8]       @ R3 = a\n    add r3, r2, r3          @ a + b[0]\n    str r3, [fp, #-20]      @ b[255] = a  +b[0]\n\n    ldr r2, [fp, #-1036]    @ R2 = b[1]\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r3, [r3, #-1044]    @ R3 = argc\n    add r3, r2, r3          @ argc + b[1]\n    str r3, [fp, #-12]      @ c = argc + b[1]\n\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r2, [r3, #-1044]    @ R2 = argc\n    ldr r3, [fp, #-8]       @ R3 = a\n    add r3, r2, r3          @ R3 = argc + a\n    add r2, fp, #-67108864\n    sub r2, r2, #4\n    str r3, [r2, #-1036]    @ d[0] = argc + a\n\n    ldr r2, [fp, #-20]      @ R2 = b[255]\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r3, [r3, #-1044]    @ R3 = argc\n    add r3, r2, r3          @ R3 = argc + b[255]\n    add r2, fp, #-67108864\n    sub r2, r2, #4\n    add r2, r2, #12288\n    str r3, [r2, #3056]     @ d[4095] = argc + b[255]\n\n    ldr r2, [fp, #-8]       @ R2 = a\n    ldr r3, [fp, #-12]      @ R3 = c\n    add r3, r2, r3          @ R3 = a + c\n    str r3, [fp, #-16]      @ e = a + c\n\n    @ printf function call:\n\n    ldr r1, [fp, #-1040]\n    add r3, fp, #-67108864\n    sub r3, r3, #4\n    ldr r3, [r3, #-1036]\n    ldr r2, [fp, #-16]\n    str r2, [sp, #4]\n    str r3, [sp]\n    ldr r3, [fp, #-12]\n    mov r2, r1\n    ldr r1, [fp, #-8]\n    ldr r0, .L3\n    bl  printf\n    @ return to Linux from function\n    mov r3, #0\n    mov r0, r3\n    sub sp, fp, #4\n\n    pop {fp, pc}\n\n.L3:\n    .word   .LC0\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .section        .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n        .string \"%d %d %d %d %d \"\n        .text\n        .p2align 2,,3\n        .globl main\n        .type   main,@function\nmain:\n        ; Build main's activation record:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        pushl   %ebx\n        subl    $67109892, %esp\n\n        ; Fetch ARGC into ECX:\n\n        movl    8(%ebp), %ecx\n\n        ; EDX = 2*argc:\n\n        leal    (%ecx,%ecx), %edx\n\n        ; EAX = a (ECX) + b[0] (EDX):\n\n        leal    (%edx,%ecx), %eax\n\n        ; c (ebx) = argc (ecx) + b[1]:\n\n        movl    %ecx, %ebx\n        addl    -1028(%ebp), %ebx\n        movl    %eax, -12(%ebp)\n ; Align stack for printf call:\n\n        andl    $-16, %esp\n\n        ;d[0] (eax) = argc (ecx) + a (eax);\n\n        leal    (%eax,%ecx), %eax\n\n        ; Make room for printf parameters:\n\n        subl    $8, %esp\n        movl    %eax, -67093516(%ebp)\n\n        ; e = a + c\n\n        leal    (%ebx,%ecx), %eax\n\n        pushl   %eax    ;e\n        pushl   %edx    ;d[0]\n        pushl   %ebx    ;c\n        pushl   %edx    ;b[0]\n        pushl   %ecx    ;a\n        pushl   $.LC0\n        movl    %edx, -1032(%ebp)\n        movl    %edx, -67109896(%ebp)\n        call    printf\n        xorl    %eax, %eax\n        movl    -4(%ebp), %ebx\n        leave\n        ret\n```", "```\n\n\t\t\tprocedure RefValue\n (\n    var dest:integer;\n    var passedByRef:integer;\n        passedByValue:integer\n);\nbegin\n\n    dest := passedByRef + passedByValue;\n\nend;\n```", "```\n\n\t\t\tprocedure RefValue\n(\nvar     dest:int32;\nvar     passedByRef:int32;\n            passedByValue:int32\n); @noframe;\nbegin RefValue;\n\n    // Standard entry sequence (needed because of @noframe).\n    // Set up base pointer.\n    // Note: don't need SUB(nn,esp) because\n    // we don't have any local variables.\n\n    push( ebp );\n    mov( esp, ebp );\n\n    // Get pointer to actual value.\n\n    mov( passedByRef, edx );\n\n    // Fetch value pointed at by passedByRef.\n mov( [edx], eax );\n\n    // Add in the value parameter.\n\n    add( passedByValue, eax );\n\n    // Get address of destination reference parameter.\n\n    mov( dest, edx );\n\n    // Store sum away into dest.\n\n    mov( eax, [edx] );\n\n    // Exit sequence doesn't need to deallocate any local\n    // variables because there are none.\n\n    pop( ebp );\n    ret( 12 );\n\nend RefValue;\n```", "```\n\n\t\t\t#include <stdio.h>\n\ntypedef struct\n{\n    int a;\n    char b;\n    short c;\n    char d;\n} s_t;\n\ns_t func( void )\n{\n    s_t s;\n\n    s.a = 0;\n    s.b = 1;\n    s.c = 2;\n    s.d = 3;\n    return s;\n}\n\nint main( void )\n{\n    s_t t;\n\n    t = func();\n    printf( \"%d %d\", t.a, func().a );\n    return( 0 );\n}\n```", "```\n\n\t\t\t.text\n        .align 2\n        .globl _func\n\n; func() -- Note: upon entry, this\n;           code assumes that R3\n;           points at the storage\n;           to hold the return result.\n\n_func:\n        li r0,1\n        li r9,2\n        stb r0,-28(r1) ; s.b = 1\n        li r0,3\n        stb r0,-24(r1) ; s.d = 3\n        sth r9,-26(r1) ; s.c = 2\n        li r9,0        ; s.a = 0\n\n        ; Okay, set up the return\n        ; result.\n\n        lwz r0,-24(r1) ; r0 = d::c\n        stw r9,0(r3)   ; result.a = s.a\n        stw r0,8(r3)   ; result.d/c = s.d/c\n        lwz r9,-28(r1)\n        stw r9,4(r3)   ; result.b = s.b\n\n        blr\n        .data\n        .cstring\n        .align 2\nLC0:\n        .ascii \"%d %d\\0\"\n        .text\n        .align 2\n        .globl _main\n_main:\n        mflr r0\n        stw r31,-4(r1)\n        stw r0,8(r1)\n        bcl 20,31,L1$pb\nL1$pb:\n        ; Allocate storage for t and\n        ; temporary storage for second\n        ; call to func:\n\n        stwu r1,-112(r1)\n\n        ; Restore LINK from above:\n\n        mflr r31\n        ; Get pointer to destination\n        ; storage (t) into R3 and call func:\n\n        addi r3,r1,64\n        bl _func\n\n        ; Compute \"func().a\"\n\n        addi r3,r1,80\n        bl _func\n\n        ; Get t.a and func().a values\n        ; and print them:\n\n        lwz r4,64(r1)\n        lwz r5,80(r1)\n        addis r3,r31,ha16(LC0-L1$pb)\n        la r3,lo16(LC0-L1$pb)(r3)\n        bl L_printf$stub\n        lwz r0,120(r1)\n        addi r1,r1,112\n        li r3,0\n        mtlr r0\n        lwz r31,-4(r1)\n        blr\n\n; stub for printf function:\n\n        .data\n        .picsymbol_stub\nL_printf$stub:\n        .indirect_symbol _printf\n        mflr r0\n        bcl 20,31,L0$_printf\nL0$_printf:\n        mflr r11\n        addis r11,r11,ha16(L_printf$lazy_ptr-L0$_printf)\n        mtlr r0\n        lwz r12,lo16(L_printf$lazy_ptr-L0$_printf)(r11)\n        mtctr r12\n        addi r11,r11,lo16(L_printf$lazy_ptr-L0$_printf)\n        bctr\n        .data\n        .lazy_symbol_pointer\nL_printf$lazy_ptr:\n        .indirect_symbol _printf\n        .long dyld_stub_binding_helper\n```", "```\n\n\t\t\t.file   \"t.c\"\n        .text\n        .p2align 2,,3\n        .globl func\n        .type   func,@function\n\n; On entry, assume that the address\n; of the storage that will hold the\n; function's return result is passed\n; on the stack immediately above the\n; return address.\n\nfunc:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $24, %esp       ; Allocate storage for s.\n\n        movl    8(%ebp), %eax   ; Get address of result\n        movb    $1, -20(%ebp)   ; s.b = 1\n        movw    $2, -18(%ebp)   ; s.c = 2\n        movb    $3, -16(%ebp)   ; s.d = 3\n        movl    $0, (%eax)      ; result.a = 0;\n        movl    -20(%ebp), %edx ; Copy the rest of s\n        movl    %edx, 4(%eax)   ; to the storage for\n        movl    -16(%ebp), %edx ; the return result.\n        movl    %edx, 8(%eax)\n        leave\n        ret     $4\n.Lfe1:\n        .size   func,.Lfe1-func\n        .section        .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n        .string \"%d %d\"\n\n        .text\n        .p2align 2,,3\n        .globl main\n        .type   main,@function\nmain:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $40, %esp       ; Allocate storage for\n        andl    $-16, %esp      ; t and temp result.\n\n        ; Pass the address of t to func:\n\n        leal    -24(%ebp), %eax\n        subl    $12, %esp\n        pushl   %eax\n        call    func\n\n        ; Pass the address of some temporary storage\n        ; to func:\n\n        leal    -40(%ebp), %eax\n        pushl   %eax\n        call    func\n        ; Remove junk from stack:\n\n        popl    %eax\n        popl    %edx\n\n        ; Call printf to print the two values:\n\n        pushl   -40(%ebp)\n        pushl   -24(%ebp)\n        pushl   $.LC0\n        call    printf\n        xorl    %eax, %eax\n        leave\n        ret\n```", "```\n\n\t\t\t#include <stdio.h>\n\ntypedef struct\n{\n    int a;\n    char b;\n    short c;\n    char d;\n} s_t;\n\nvoid func( s_t *s )\n{\n    s->a = 0;\n    s->b = 1;\n    s->c = 2;\n    s->d = 3;\n    return;\n}\n\nint main( void )\n{\n    s_t s,t;\n    func( &s );\n    func( &t );\n    printf( \"%d %d\", s.a, t.a );\n    return( 0 );\n}\n```", "```\n\n\t\t\t        .file   \"t.c\"\n        .text\n        .p2align 2,,3\n        .globl func\n        .type   func,@function\nfunc:\n        pushl   %ebp\n        movl    %esp, %ebp\n        movl    8(%ebp), %eax\n        movl    $0, (%eax)      ; s->a = 0\n        movb    $1, 4(%eax)     ; s->b = 1\n        movw    $2, 6(%eax)     ; s->c = 2\n        movb    $3, 8(%eax)     ; s->d = 3\n        leave\n        ret\n.Lfe1:\n        .size   func,.Lfe1-func\n        .section        .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n        .string \"%d %d\"\n        .text\n        .p2align 2,,3\n        .globl main\n        .type   main,@function\nmain:\n        ; Build activation record and allocate\n        ; storage for s and t:\n\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $40, %esp\n        andl    $-16, %esp\n        subl    $12, %esp\n\n        ; Pass address of s to func and\n        ; call func:\n\n        leal    -24(%ebp), %eax\n        pushl   %eax\n        call    func\n\n        ; Pass address of t to func and\n        ; call func:\n\n        leal    -40(%ebp), %eax\n        movl    %eax, (%esp)\n        call    func\n\n        ; Remove junk from stack:\n\n        addl    $12, %esp\n        ; Print the results:\n\n        pushl   -40(%ebp)\n        pushl   -24(%ebp)\n        pushl   $.LC0\n        call    printf\n        xorl    %eax, %eax\n        leave\n        ret\n```"]