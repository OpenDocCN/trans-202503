- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The String Instructions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指令
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'A *string* is a collection of values stored in contiguous memory locations.
    The x86-64 CPUs can process four types of strings: byte strings, word strings,
    double-word strings, and quad-word strings.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是存储在连续内存位置中的一组值。x86-64 CPU 可以处理四种类型的字符串：字节字符串、字字符串、双字字符串和四字字符串。'
- en: The x86-64 microprocessor family supports several instructions specifically
    designed to cope with strings. They can move strings, compare strings, search
    for a specific value within a string, initialize a string to a fixed value, and
    do other primitive operations on strings. The x86-64’s string instructions are
    also useful for assigning and comparing arrays, tables, and records, and they
    may speed up your array-manipulation code considerably. This chapter explores
    various uses of the string instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 微处理器系列支持几条专门用于处理字符串的指令。它们可以移动字符串、比较字符串、在字符串中查找特定值、将字符串初始化为固定值，并对字符串执行其他基础操作。x86-64
    的字符串指令对于分配和比较数组、表格和记录也非常有用，它们可能大大加速你的数组操作代码。本章将探讨字符串指令的各种用途。
- en: 14.1 The x86-64 String Instructions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 x86-64 字符串指令
- en: 'All members of the x86-64 family support five string instructions: `movs``x`,
    `cmps``x`, `scas``x`, `lods``x`, and `stos``x`.^([1](#c14-footnote-1)) (`x` =
    `b`, `w`, `d`, or `q` for byte, word, double word, or quad word, respectively;
    this book generally drops the `x` suffix when talking about these string instructions
    in a general sense.) Moving, comparing, scanning, loading, and storing are the
    primitives on which you can build most other string operations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 x86-64 系列处理器都支持五条字符串指令：`movs``x`、`cmps``x`、`scas``x`、`lods``x` 和 `stos``x`。^([1](#c14-footnote-1))（`x`
    = `b`、`w`、`d` 或 `q`，分别表示字节、字、双字或四字；本书通常在讨论这些字符串指令时省略 `x` 后缀。）移动、比较、扫描、加载和存储是你可以构建大多数其他字符串操作的基础。
- en: 'The string instructions operate on *blocks* (contiguous linear arrays) of memory.
    For example, the `movs` instruction moves a sequence of bytes from one memory
    location to another, the `cmps` instruction compares two blocks of memory, and
    the `scas` instruction scans a block of memory for a particular value. The source
    and destination blocks (and any other values an instruction needs) are not provided
    as explicit operands, however. Instead, the string instructions use specific registers
    as operands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指令操作的是 *块*（连续的线性数组）内存。例如，`movs` 指令将一系列字节从一个内存位置移动到另一个位置，`cmps` 指令比较两个内存块，`scas`
    指令扫描内存块以查找特定值。然而，源块和目标块（以及指令需要的任何其他值）并不是作为显式操作数提供的。相反，字符串指令使用特定寄存器作为操作数：
- en: RSI (source index) register
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSI（源索引）寄存器
- en: RDI (destination index) register
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDI（目标索引）寄存器
- en: RCX (count) register
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RCX（计数）寄存器
- en: AL, AX, EAX, and RAX registers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AL、AX、EAX 和 RAX 寄存器
- en: The direction flag in the FLAGS register
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLAGS 寄存器中的方向标志
- en: For example, the `movs` (*move string*) instruction copies RCX elements from
    the source address specified by RSI to the destination address specified by RDI.
    Likewise, the `cmps` instruction compares the string pointed at by RSI, of length
    RCX, to the string pointed at by RDI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`movs`（*移动字符串*）指令将从 RSI 指定的源地址复制 RCX 个元素到 RDI 指定的目标地址。同样，`cmps` 指令将 RSI 指向的字符串（长度为
    RCX）与 RDI 指向的字符串进行比较。
- en: 'The sections that follow describe how to use these five instructions, starting
    with a prefix that makes the instructions do what you’d expect: repeat their operation
    for each value in the string pointed to by RSI.^([2](#c14-footnote-2))'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了如何使用这五条指令，首先是一个前缀，它使指令按照预期执行：对由 RSI 指向的字符串中的每个值重复操作。^([2](#c14-footnote-2))
- en: 14.1.1 The rep, repe, repz, and the repnz and repne Prefixes
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 rep、repe、repz、repnz 和 repne 前缀
- en: By themselves, the string instructions do not operate on strings of data. For
    example, the `movs` instruction will only copy a single byte, word, double word,
    or quad word. The repeat prefixes tell the x86-64 to do a multi-byte string operation—specifically,
    to repeat a string operation up to RCX times.^([3](#c14-footnote-3))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，字符串指令不会对数据字符串进行操作。例如，`movs` 指令只会复制一个字节、字、双字或四字。重复前缀告诉 x86-64 执行多字节字符串操作——具体来说，重复执行字符串操作最多
    RCX 次。^([3](#c14-footnote-3))
- en: 'The syntax for the string instructions with repeat prefixes is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带有重复前缀的字符串指令的语法如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You don’t normally use the repeat prefixes with the `lods` instruction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不会将重复前缀与 `lods` 指令一起使用。
- en: The `rep` prefix tells the CPU to “repeat this operation the number of times
    specified by the RCX register.” The `repe` prefix says to “repeat this operation
    while the comparison is equal, or up to the number of times specified by RCX (whichever
    condition fails first).” The `repne` prefix’s action is “repeat this operation
    while the comparison is not equal, or up to the number of times specified by RCX.”
    As it turns out, you’ll use `repe` for most character string comparisons; `repne`
    is used mainly with the `scas``x` instructions to locate a specific character
    within a string (such as a zero-terminating byte).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`rep` 前缀告诉 CPU “按 RCX 寄存器指定的次数重复此操作。” `repe` 前缀表示“当比较相等时，重复此操作，或重复 RCX 指定的次数（先满足的条件为止）。”
    `repne` 前缀的动作是“当比较不相等时，重复此操作，或重复 RCX 指定的次数。” 实际上，你会在大多数字符字符串比较中使用 `repe`；`repne`
    主要与 `scas``x` 指令一起使用，用来在字符串中查找特定字符（如零终止字节）。'
- en: You can use repeat prefixes to process entire strings with a single instruction.
    You can use the string instructions, without the repeat prefix, as string primitive
    operations to synthesize more powerful string operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用重复前缀通过单条指令处理整个字符串。你也可以在不使用重复前缀的情况下使用字符串指令，作为字符串原始操作来合成更强大的字符串操作。
- en: 14.1.2 The Direction Flag
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 方向标志
- en: The *direction flag* in the FLAGS register controls how the CPU processes strings.
    If the direction flag is clear, the CPU increments RSI and RDI after operating
    on each string element. For example, executing `movs` will move the byte, word,
    double word, or quad word at RSI to RDI and then increment RSI and RDI by 1, 2,
    4, or 8 (respectively). When specifying the `rep` prefix before this instruction,
    the CPU increments RSI and RDI for each element in the string (the count in RCX
    specifies the number of elements). At completion, the RSI and RDI registers will
    be pointing at the first item beyond the strings.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FLAGS 寄存器中的 *方向标志* 控制 CPU 如何处理字符串。如果方向标志被清除，CPU 在处理每个字符串元素后会增加 RSI 和 RDI。例如，执行
    `movs` 将会把 RSI 处的字节、字、双字或四字移动到 RDI，然后分别增加 RSI 和 RDI 1、2、4 或 8（依此类推）。当在此指令前指定 `rep`
    前缀时，CPU 会为字符串中的每个元素增加 RSI 和 RDI（RCX 中的计数指定元素的数量）。完成后，RSI 和 RDI 寄存器将指向字符串之后的第一个元素。
- en: If the direction flag is set, the x86-64 decrements RSI and RDI after it processes
    each string element (again, RCX specifies the number of string elements for a
    repeated string operation). Afterward, the RSI and RDI registers will be pointing
    at the first byte, word, or double word before the strings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方向标志被设置，x86-64 在处理每个字符串元素后会递减 RSI 和 RDI（同样，RCX 指定了重复字符串操作的元素数量）。之后，RSI 和 RDI
    寄存器将指向字符串之前的第一个字节、字或双字。
- en: You can change the direction flag’s value by using the `cld` (*clear direction
    flag*) and `std` (*set direction flag*) instructions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cld`（*清除方向标志*）和 `std`（*设置方向标志*）指令来改变方向标志的值。
- en: The Microsoft ABI requires that the direction flag be clear upon entry into
    a (Microsoft ABI–compliant) procedure. Therefore, if you set the direction flag
    within a procedure, you should always clear that flag when you are finished using
    it (and especially before calling any other code or returning from the procedure).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 ABI 要求在进入一个（符合微软 ABI 的）过程时，方向标志必须被清除。因此，如果在过程内设置了方向标志，你应该在使用完它后始终清除该标志（特别是在调用其他代码或从过程返回之前）。
- en: 14.1.3 The movs Instruction
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 movs 指令
- en: 'The `movs` instruction uses the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`movs` 指令使用以下语法：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `movsb` (*move string, bytes*) instruction fetches the byte at address RSI,
    stores it at address RDI, and then increments or decrements the RSI and RDI registers
    by 1\. If the `rep` prefix is present, the CPU checks RCX to see whether it contains
    0\. If not, it moves the byte from RSI to RDI and decrements the RCX register.
    This process repeats until RCX becomes 0\. If RCX contains 0 upon initial execution,
    the `movsb` instruction will not copy any data bytes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsb`（*移动字符串，字节*）指令获取地址 RSI 处的字节，将其存储到地址 RDI，然后将 RSI 和 RDI 寄存器分别增加或减少 1。如果存在
    `rep` 前缀，CPU 会检查 RCX 是否为 0。如果不是，它会将字节从 RSI 移动到 RDI 并递减 RCX 寄存器。这个过程会重复，直到 RCX
    变为 0。如果 RCX 在初次执行时为 0，`movsb` 指令将不会复制任何数据字节。'
- en: The `movsw` (*move string, words*) instruction fetches the word at address RSI,
    stores it at address RDI, and then increments or decrements RSI and RDI by 2\.
    If there is a `rep` prefix, the CPU repeats this procedure RCX times.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsw`（*移动字符串，字长*）指令从地址RSI获取一个字，将其存储到地址RDI，然后将RSI和RDI分别增加或减少2。如果有`rep`前缀，CPU会重复执行此过程RCX次。'
- en: The `movsd` instruction operates in a similar fashion on double words. It increments
    or decrements RSI and RDI by 4 after each data movement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsd`指令在双字（double words）上以类似的方式操作。在每次数据移动后，它会将RSI和RDI各增加或减少4。'
- en: Finally, the `movsq` instruction does the same thing on quad words. It increments
    or decrements RSI and RDI by 8 after each data movement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`movsq`指令对四字（quad words）执行相同的操作。每次数据移动后，它会将RSI和RDI各增加或减少8。
- en: 'For example, this code segment copies 384 bytes from `CharArray1` to `CharArray2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码将384字节从`CharArray1`复制到`CharArray2`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you substitute `movsw` for `movsb`, the preceding code will move 384 words
    (768 bytes) rather than 384 bytes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用`movsw`替换`movsb`，前面的代码将移动384个字（768字节），而不是384个字节：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember, the RCX register contains the element count, not the byte count; fortunately,
    the MASM `lengthof` operator returns the number of array elements (words), not
    the number of bytes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，RCX寄存器包含的是元素计数，而不是字节计数；幸运的是，MASM中的`lengthof`操作符返回的是数组元素的数量（字长），而不是字节数量。
- en: 'If you’ve set the direction flag before executing a `movsq`, `movsb`, `movsw`,
    or `movsd` instruction, the CPU decrements the RSI and RDI registers after moving
    each string element. This means that the RSI and RDI registers must point at the
    last element of their respective strings before executing a `movsb`, `movsw`,
    `movsd`, or `movsq` instruction. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在执行`movsq`、`movsb`、`movsw`或`movsd`指令之前设置了方向标志，CPU将在每次移动一个字符串元素后递减RSI和RDI寄存器。这意味着，在执行`movsb`、`movsw`、`movsd`或`movsq`指令之前，RSI和RDI寄存器必须指向各自字符串的最后一个元素。例如：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although sometimes processing a string from tail to head is useful (see “Comparing
    Extended-Precision Integers” on page 834), generally you’ll process strings in
    the forward direction. For one class of string operations, being able to process
    strings in both directions is mandatory: moving strings when the source and destination
    blocks overlap. Consider what happens in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时从尾到头处理字符串是有用的（参见第834页的“比较扩展精度整数”），但通常情况下，你会按正向方向处理字符串。对于某一类字符串操作，能够在两种方向上处理字符串是必需的：当源和目标块重叠时移动字符串。考虑以下代码的执行：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sequence of instructions treats `CharArray1` and `CharArray2` as a pair
    of 384-byte strings. However, the last 383 bytes in the `CharArray1` array overlap
    the first 383 bytes in the `CharArray2` array. Let’s trace the operation of this
    code byte by byte.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这组指令将`CharArray1`和`CharArray2`当作一对384字节的字符串来处理。然而，`CharArray1`数组中的最后383个字节与`CharArray2`数组中的前383个字节重叠。让我们逐字节跟踪这段代码的执行。
- en: 'When the CPU executes the `movsb` instruction, it does the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU执行`movsb`指令时，它会执行以下操作：
- en: Copies the byte at RSI (`CharArray1`) to the byte pointed at by RDI (`CharArray2`).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RSI指向的字节（`CharArray1`）复制到RDI指向的字节（`CharArray2`）。
- en: Increments RSI and RDI, and decrements RCX by 1\. Now the RSI register points
    at `CharArray1 + 1` (which is the address of `CharArray2`), and the RDI register
    points at `CharArray2 + 1`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加RSI和RDI，并将RCX递减1。现在RSI寄存器指向`CharArray1 + 1`（即`CharArray2`的地址），RDI寄存器指向`CharArray2
    + 1`。
- en: Copies the byte pointed at by RSI to the byte pointed at by RDI. However, this
    is the byte originally copied from location `CharArray1`. So, the `movsb` instruction
    copies the value originally in location `CharArray1` to both locations `CharArray2`
    and `CharArray2 + 1`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RSI指向的字节复制到RDI指向的字节。然而，这个字节原本是从`CharArray1`位置复制过来的。因此，`movsb`指令将原本位于`CharArray1`位置的值复制到`CharArray2`和`CharArray2
    + 1`位置。
- en: Again increments RSI and RDI, and decrements RCX.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次增加RSI和RDI，并递减RCX。
- en: Copies the byte from location `CharArray1 + 2` (`CharArray2 + 1`) to location
    `CharArray2 + 2`. Once again, this is the value that originally appeared in location
    `CharArray1`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位于`CharArray1 + 2`（`CharArray2 + 1`）的字节复制到`CharArray2 + 2`位置。同样，这个值原本出现在`CharArray1`位置。
- en: Each repetition of the loop copies the next element in `CharArray1` to the next
    available location in the `CharArray2` array. Pictorially, it looks something
    like [Figure 14-1](#figure14-1). The result is that the `movsb` instruction replicates
    `X` throughout the string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的每次重复都会将`CharArray1`中的下一个元素复制到`CharArray2`数组中下一个可用的位置。形象地看，类似于[图14-1](#figure14-1)。结果是`movsb`指令在字符串中复制了`X`。
- en: '![f14001](image_fi/501089c14/f14001.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f14001](image_fi/501089c14/f14001.png)'
- en: 'Figure 14-1: Copying data between two overlapping arrays (forward direction)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1：在两个重叠数组之间复制数据（正向方向）
- en: If you really want to move one array into another when they overlap like this,
    you should move each element of the source string to the destination string, starting
    at the end of the two strings, as shown in [Figure 14-2](#figure14-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的希望在两个数组重叠时将一个数组移入另一个数组，你应该从两个字符串的末尾开始，逐个元素地将源字符串的每个元素移动到目标字符串，如[图14-2](#figure14-2)所示。
- en: '![f14002](image_fi/501089c14/f14002.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f14002](image_fi/501089c14/f14002.png)'
- en: 'Figure 14-2: Using a backward copy to copy data in overlapping arrays'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2：使用反向复制复制重叠数组中的数据
- en: Setting the direction flag and pointing RSI and RDI at the end of the strings
    will allow you to (correctly) move one string to another when the two strings
    overlap and the source string begins at a lower address than the destination string.
    If the two strings overlap and the source string begins at a higher address than
    the destination string, clear the direction flag and point RSI and RDI at the
    beginning of the two strings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方向标志并将RSI和RDI指向字符串的末尾，当两个字符串重叠并且源字符串的地址低于目标字符串时，这样可以让你（正确地）将一个字符串移动到另一个字符串。如果两个字符串重叠并且源字符串的地址高于目标字符串，则清除方向标志并将RSI和RDI指向两个字符串的开头。
- en: If the two strings do not overlap, you can use either technique to move the
    strings around in memory. Generally, operating with the direction flag clear is
    the easiest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串没有重叠，你可以使用任意一种技巧在内存中移动字符串。通常，清除方向标志进行操作是最简单的。
- en: You shouldn’t use the `movs``x` instruction to fill an array with a single byte,
    word, double-word, or quad-word value. Another string instruction, `stos`, is
    much better for this purpose.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该使用`movs``x`指令将一个数组填充为单一字节、字、双字或四字的值。另一个字符串指令`stos`在这种情况下要好得多。
- en: 'If you are moving a large number of bytes from one array to another, the copy
    operation will be faster if you can use the `movsq` instruction rather than the
    `movsb` instruction. If the number of bytes you wish to move is an even multiple
    of 8, this is a trivial change; just divide the number of bytes to copy by 8,
    load this value into RCX, and then use the `movsq` instruction. If the number
    of bytes is not evenly divisible by 8, you can use the `movsq` instruction to
    copy all but the last 1, 2, . . . , 7 bytes of the array (that is, the remainder
    after you divide the byte count by 8). For example, if you want to efficiently
    move 4099 bytes, you can do so with the following instruction sequence:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要从一个数组移动大量字节到另一个数组，使用`movsq`指令比使用`movsb`指令要更快。如果你要移动的字节数是8的偶数倍，那么这只是一个微不足道的变化；只需将要复制的字节数除以8，将这个值加载到RCX寄存器中，然后使用`movsq`指令。如果字节数不能被8整除，你可以使用`movsq`指令复制数组中除了最后1、2、……、7个字节以外的所有字节（也就是说，除去字节数除以8后的余数）。例如，如果你想高效地移动4099个字节，你可以使用以下指令序列：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this technique to copy data never requires more than four `movs``x` instructions
    because you can copy 1, . . . , 7 bytes with no more than one (each) of the `movsb`,
    `movsw`, and `movsd` instructions. The preceding scheme is most efficient if the
    two arrays are aligned on quad-word boundaries. If not, you might want to move
    the `movsb`, `movsw`, or `movsd` instruction (or all three) before or after the
    `movsq` instruction so that `movsq` works with quad-word–aligned data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术复制数据时，最多只需要四个`movs``x`指令，因为你可以用不超过一个（每个）`movsb`、`movsw`和`movsd`指令来复制1、……、7个字节。如果两个数组按照四字对齐，这种方案最为高效。如果没有四字对齐，你可能需要将`movsb`、`movsw`或`movsd`指令（或所有三者）移到`movsq`指令之前或之后，以便`movsq`指令与四字对齐的数据一起工作。
- en: 'If you do not know the size of the block you are copying until the program
    executes, you can still use code like the following to improve the performance
    of a block move of bytes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序执行时才知道要复制的块的大小，仍然可以使用如下代码来提高字节块移动的性能：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On many computer systems, the `movsq` instruction provides about the fastest
    way to copy bulk data from one location to another. While there are, arguably,
    faster ways to copy data on certain CPUs, ultimately the memory bus performance
    is the limiting factor, and the CPUs are generally much faster than the memory
    bus. Therefore, unless you have a special system, writing fancy code to improve
    memory-to-memory transfers is probably a waste of time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多计算机系统上，`movsq`指令提供了一种快速的方式，将数据从一个位置复制到另一个位置。虽然在某些CPU上可能有更快的方式复制数据，但最终内存总线性能才是限制因素，而CPU通常比内存总线要快。因此，除非你有特别的系统，编写复杂的代码来提升内存到内存的传输速度可能是在浪费时间。
- en: Also, Intel has improved the performance of the `movs``x` instructions on later
    processors so that `movsb` operates as efficiently as `movsw`, `movsd`, and `movsq`
    when copying the same number of bytes. On these later processors, it may be more
    efficient to use `movsb` to copy the specified number of bytes rather than go
    through all the complexity outlined previously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，英特尔在后来的处理器中改进了`movs``x`指令的性能，使得在复制相同数量字节时，`movsb`的效率与`movsw`、`movsd`和`movsq`相同。在这些后来的处理器上，使用`movsb`来复制指定数量的字节可能比之前提到的复杂方法更高效。
- en: 'The bottom line is this: if the speed of a block move matters to you, try it
    several different ways and pick the fastest (or the simplest, if they all run
    the same speed, which is likely).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是：如果块移动的速度对你很重要，可以尝试几种不同的方法，并选择最快的（或者如果它们速度相同，选择最简单的，这种情况也很有可能）。
- en: 14.1.4 The cmps Instruction
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 cmps指令
- en: 'The `cmps` instruction compares two strings. The CPU compares the value referenced
    by RDI to the value pointed at by RSI. RCX contains the number of elements in
    the source string when using the `repe` or `repne` prefix to compare entire strings.
    Like the `movs` instruction, MASM allows several forms of this instruction:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmps`指令用于比较两个字符串。CPU将RDI指向的值与RSI指向的值进行比较。当使用`repe`或`repne`前缀来比较整个字符串时，RCX包含源字符串中的元素数量。像`movs`指令一样，MASM允许此指令的几种形式：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Without a repeat prefix, the `cmps` instruction subtracts the value at location
    RDI from the value at RSI and updates the flags according to the result (which
    it discards). After comparing the two locations, `cmps` increments or decrements
    the RSI and RDI registers by 1, 2, 4, or 8 (for `cmpsb`, `cmpsw`, `cmpsd`, and
    `cmpsq`, respectively). `cmps` increments the RSI and RDI registers if the direction
    flag is clear and decrements them otherwise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有重复前缀，`cmps`指令会将RDI位置的值与RSI位置的值相减，并根据结果更新标志（结果会被丢弃）。在比较完这两个位置后，`cmps`会根据`cmpsb`、`cmpsw`、`cmpsd`和`cmpsq`的不同，分别将RSI和RDI寄存器加1、加2、加4或加8。如果方向标志为清除，`cmps`会递增RSI和RDI寄存器，否则会递减它们。
- en: Remember, the value in the RCX register determines the number of elements to
    process, not the number of bytes. Therefore, when using `cmpsw`, RCX specifies
    the number of words to compare. Likewise, for `cmpsd` and `cmpsq`, RCX contains
    the number of double and quad words to process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，RCX寄存器中的值决定了处理的元素数量，而不是字节数。因此，在使用`cmpsw`时，RCX指定比较的字数。同样，`cmpsd`和`cmpsq`时，RCX包含要处理的双字和四字的数量。
- en: The `repe` prefix compares successive elements in a string as long as they are
    equal and RCX is greater than 0\. The `repne` prefix does the same as long the
    elements are not equal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`repe`前缀会在元素相等并且RCX大于0时，比较字符串中的连续元素。`repne`前缀则在元素不相等时执行相同操作。'
- en: After the execution of `repne cmps`, either the RCX register is 0 (in which
    case the two strings are totally different), or the RCX contains the number of
    elements compared in the two strings until a match is found. While this form of
    the `cmps` instruction isn’t particularly useful for comparing strings, it is
    useful for locating the first pair of matching items in a couple of byte, word,
    or double-word arrays.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完`repne cmps`后，RCX寄存器的值为0（此时两个字符串完全不同），或者RCX包含两个字符串中比较的元素数量，直到找到匹配项。虽然这种形式的`cmps`指令对比较字符串并不特别有用，但它对于定位字节、字或双字数组中第一对匹配的元素非常有用。
- en: 14.1.4.1 Comparing Character Strings
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4.1 比较字符字符串
- en: Character strings are usually compared using *lexicographical ordering*, the
    standard alphabetical ordering you’ve grown up with. We compare corresponding
    elements until encountering a character that doesn’t match or the end of the shorter
    string. If a pair of corresponding characters does not match, compare the two
    strings based on that single character. If the two strings match up to the length
    of the shorter string, compare their length. The two strings are equal if and
    only if their lengths are equal and each corresponding pair of characters in the
    two strings is identical. The length of a string affects the comparison only if
    the two strings are identical up to the length of the shorter string. For example,
    `Zebra` is less than `Zebras` because it is the shorter of the two strings; however,
    `Zebra` is greater than `AAAAAAAAAAH!` even though `Zebra` is shorter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通常使用 *字典顺序* 来比较，也就是你从小到大熟悉的标准字母顺序。我们比较对应的元素，直到遇到一个不匹配的字符或更短字符串的结尾。如果一对对应的字符不匹配，就基于该字符来比较两个字符串。如果两个字符串匹配到更短字符串的长度，那么就比较它们的长度。只有当两个字符串的长度相等，并且每对对应的字符都完全相同，两个字符串才被认为相等。字符串的长度只在两个字符串在更短字符串的长度范围内完全相等时才影响比较。例如，`Zebra`
    小于 `Zebras`，因为它是较短的那个字符串；然而，尽管 `Zebra` 较短，它还是大于 `AAAAAAAAAAH!`。
- en: 'For (ASCII) character strings, use the `cmpsb` instruction in the following
    manner:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（ASCII）字符字符串，请按以下方式使用 `cmpsb` 指令：
- en: Clear the direction flag.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除方向标志。
- en: Load the RCX register with the length of the smaller string.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RCX 寄存器加载为较短字符串的长度。
- en: Point the RSI and RDI registers at the first characters in the two strings you
    want to compare.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RSI 和 RDI 寄存器指向你要比较的两个字符串的第一个字符。
- en: Use the `repe` prefix with the `cmpsb` instruction to compare the strings on
    a byte-by-byte basis.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `repe` 前缀和 `cmpsb` 指令按字节逐一比较字符串。
- en: If the two strings are equal, compare their lengths.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个字符串相等，则比较它们的长度。
- en: 'The following code compares a couple of character strings:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码比较了几个字符字符串：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you’re using bytes to hold the string lengths, you should adjust this code
    appropriately (that is, use a `movzx` instruction to load the lengths into RCX).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用字节来存储字符串长度，应该适当地调整此代码（即，使用 `movzx` 指令将长度加载到 RCX 寄存器中）。
- en: 14.1.4.2 Comparing Extended-Precision Integers
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4.2 比较扩展精度整数
- en: You can also use the `cmps` instruction to compare multi-word integer values
    (that is, extended-precision integer values). Because of the setup required for
    a string comparison, this isn’t practical for integer values less than six or
    eight double words in length, but for large integer values, it’s excellent.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `cmps` 指令来比较多字整数值（即扩展精度整数值）。由于进行字符串比较需要一定的设置，因此对于小于六个或八个双字长度的整数值，这种方法并不实际，但对于大整数值来说，非常适用。
- en: 'Unlike with character strings, we cannot compare integer strings by using lexicographical
    ordering. When comparing strings, we compare the characters from the least significant
    byte to the most significant byte. When comparing integers, we must compare the
    values from the most significant byte, word, or double word down to the least
    significant. So, to compare two 32-byte (256-bit) integer values, use the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串不同，我们不能通过字典顺序来比较整数串。在比较字符串时，我们从最低有效字节到最高有效字节依次比较字符。而在比较整数时，我们必须从最高有效字节、字或双字开始，逐步比较到最低有效字节。所以，要比较两个32字节（256位）的整数值，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code compares the integers from their most significant qword down to the
    least significant qword. The `cmpsq` instruction finishes when the two values
    are unequal or upon decrementing RCX to 0 (implying that the two values are equal).
    Once again, the flags provide the result of the comparison.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将整数从最重要的四字（qword）到最不重要的四字进行比较。`cmpsq` 指令在两个值不相等时停止，或者当 RCX 递减至 0 时停止（意味着两个值相等）。一如既往，标志提供比较结果。
- en: 14.1.5 The scas Instruction
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 `scas` 指令
- en: The `scas` (*scan string*) instruction is used to search for a particular element
    within a string—for example, to quickly scan for a 0 throughout another string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`scas`（*扫描字符串*）指令用于在字符串中查找特定元素——例如，快速扫描另一个字符串中的 0。'
- en: Unlike the `movs` and `cmps` instructions, `scas` requires only a destination
    string (pointed at by RDI). The source operand is the value in the AL (`scasb`),
    AX (`scasw`), EAX (`scasd`), or RAX (`scasq`) register. The `scas` instruction
    compares the value in the accumulator (AL, AX, EAX, or RAX) against the value
    pointed at by RDI and then increments (or decrements) RDI by 1, 2, 4, or 8\. The
    CPU sets the flags according to the result of the comparison.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `movs` 和 `cmps` 指令不同，`scas` 只需要一个目标字符串（由 RDI 指向）。源操作数是 AL（`scasb`）、AX（`scasw`）、EAX（`scasd`）或
    RAX（`scasq`）寄存器中的值。`scas` 指令将累加器中的值（AL、AX、EAX 或 RAX）与由 RDI 指向的值进行比较，然后将 RDI 增加（或减少）1、2、4
    或 8。CPU 根据比较结果设置标志。
- en: 'The `scas` instructions take the following forms:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`scas` 指令有以下几种形式：'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the `repe` prefix, `scas` scans the string, searching for an element that
    does not match the value in the accumulator. When using the `repne` prefix, `scas`
    scans the string, searching for the first element that is equal to the value in
    the accumulator. This is counterintuitive, because `repe` `scas` actually scans
    through the string while the value in the accumulator is equal to the string operand,
    and `repne` `scas` scans through the string while the accumulator is not equal
    to the string operand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `repe` 前缀时，`scas` 扫描字符串，寻找一个与累加器中的值不匹配的元素。使用 `repne` 前缀时，`scas` 扫描字符串，寻找第一个与累加器中的值相等的元素。这有点反直觉，因为
    `repe` `scas` 实际上是在扫描字符串，而累加器中的值与字符串操作数相等，`repne` `scas` 则是在扫描字符串，而累加器的值与字符串操作数不相等。
- en: Like the `cmps` and `movs` instructions, the value in the RCX register specifies
    the number of elements, not bytes, to process when using a repeat prefix.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `cmps` 和 `movs` 指令一样，RCX 寄存器中的值指定了在使用重复前缀时要处理的元素数量，而不是字节数量。
- en: 14.1.6 The stos Instruction
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.6 `stos` 指令
- en: 'The `stos` instruction stores the value in the accumulator at the location
    specified by RDI. After storing the value, the CPU increments or decrements RDI
    depending on the state of the direction flag. Although the `stos` instruction
    has many uses, its primary use is to initialize arrays and strings to a constant
    value. For example, if you have a 256-byte array that you want to clear out with
    0s, use the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos` 指令将累加器中的值存储到由 RDI 指定的位置。存储值后，CPU 会根据方向标志的状态增加或减少 RDI。虽然 `stos` 指令有很多用途，但它的主要用途是将数组和字符串初始化为常量值。例如，如果你有一个
    256 字节的数组，想用 0 清空它，可以使用以下代码：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code writes 32 quad words rather than 256 bytes because a single `stosq`
    operation is faster (on some older CPUs) than four `stosb` operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码写入的是 32 个四字，而不是 256 个字节，因为单个 `stosq` 操作比四个 `stosb` 操作要快（在一些旧的 CPU 上）。
- en: 'The `stos` instructions take eight forms:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos` 指令有八种形式：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `stosb` instruction stores the value in the AL register into the specified
    memory location(s), `stosw` stores the AX register into the specified memory location(s),
    `stosd` stores EAX into the specified location(s), and `stosq` stores RAX into
    the specified location(s). With the `rep` prefix, this process repeats the number
    of times specified by the RCX register.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`stosb` 指令将 AL 寄存器中的值存储到指定的内存位置，`stosw` 将 AX 寄存器存储到指定的内存位置，`stosd` 将 EAX 存储到指定的位置，`stosq`
    将 RAX 存储到指定的位置。使用 `rep` 前缀时，这个过程会重复 RCX 寄存器指定的次数。'
- en: If you need to initialize an array with elements that have different values,
    you cannot (easily) use `stos`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要初始化一个元素值不同的数组，你无法（轻易地）使用 `stos`。
- en: 14.1.7 The lods Instruction
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.7 `lods` 指令
- en: The `lods` instruction copies the byte, word, double word, or quad word pointed
    at by RSI into the AL, AX, EAX, or RAX register, after which it increments or
    decrements the RSI register by 1, 2, 4, or 8\. Use `lods` to fetch bytes (`lodsb`),
    words (`lodsw`), double words (`lodsd`), or quad words (`lodsq`) from memory for
    further processing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`lods` 指令将由 RSI 指向的字节、字、双字或四字复制到 AL、AX、EAX 或 RAX 寄存器中，之后它会增加或减少 RSI 寄存器的值，步长为
    1、2、4 或 8。使用 `lods` 从内存中获取字节（`lodsb`）、字（`lodsw`）、双字（`lodsd`）或四字（`lodsq`）以进行进一步处理。'
- en: 'Like `stos`, the `lods` instructions take eight forms:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `stos` 一样，`lods` 指令也有八种形式：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will probably never use a repeat prefix with this instruction, because the
    accumulator register will be overwritten each time `lods` repeats. At the end
    of the repeat operation, the accumulator will contain the last value read from
    memory.^([4](#c14-footnote-4))
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不会在此指令中使用重复前缀，因为每次 `lods` 重复时，累加器寄存器都会被覆盖。重复操作结束时，累加器将包含从内存读取的最后一个值。^([4](#c14-footnote-4))
- en: 14.1.8 Building Complex String Functions from lods and stos
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.8 从 lods 和 stos 构建复杂的字符串函数
- en: 'You can use the `lods` and `stos` instructions to generate any particular string
    operation. For example, suppose you want a string operation that converts all
    the uppercase characters in a string to lowercase. You could use the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `lods` 和 `stos` 指令生成任何特定的字符串操作。例如，假设你需要一个将字符串中的所有大写字符转换为小写的字符串操作。你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `rpt` loop fetches the byte at the location specified by RSI, tests whether
    it is an uppercase character, converts it to lowercase if it is (leaving it unchanged
    if it is not), stores the resulting character at the location specified by RDI,
    and then repeats this process the number of times specified by the value in RCX.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpt` 循环获取 RSI 指定位置的字节，测试其是否为大写字母，如果是，则将其转换为小写字母（如果不是，则保持不变），然后将结果字符存储在 RDI
    指定的位置，并重复这一过程，直到 RCX 中的值指定的次数为止。'
- en: Because the `lods` and `stos` instructions use the accumulator as an intermediary
    location, you can use any accumulator operation to quickly manipulate string elements.
    This could be something as simple as a `toLower` (or `toUpper`) function or as
    complex as data encryption. You might even use this instruction sequence to compute
    a hash, checksum, or CRC value while moving data from one string to another. Any
    operation you would do on a string on a character-by-character basis while moving
    the string data around is a candidate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `lods` 和 `stos` 指令使用累加器作为中介位置，你可以使用任何累加器操作来快速操作字符串元素。这可以是像 `toLower`（或 `toUpper`）这样的简单函数，也可以是像数据加密这样的复杂操作。你甚至可以使用这一指令序列在将数据从一个字符串移动到另一个字符串时计算哈希值、校验和或
    CRC 值。在移动字符串数据的同时，你对字符串逐字符进行的任何操作都是可行的。
- en: 14.2 Performance of the x86-64 String Instructions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 x86-64 字符串指令的性能
- en: In the early x86-64 processors, the string instructions provided the most efficient
    way to manipulate strings and blocks of data. However, these instructions are
    not part of Intel’s RISC Core instruction set and can be slower (though more compact)
    than if you did the same operations with discrete instructions. Intel has optimized
    `movs` and `stos` on later processors so that they operate as rapidly as possible,
    but the other string instructions can be fairly slow.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 x86-64 处理器中，字符串指令提供了操作字符串和数据块的最有效方法。然而，这些指令并不是 Intel RISC 核心指令集的一部分，因此可能比使用离散指令执行相同操作时要慢（尽管它们更紧凑）。Intel
    在后来的处理器上优化了 `movs` 和 `stos` 指令，使其尽可能快速运行，但其他字符串指令可能相对较慢。
- en: As always, it’s a good idea to implement performance-critical algorithms by
    using different algorithms (with and without the string instructions) and comparing
    their performance to determine which solution to use. Because the string instructions
    run at different speeds relative to other instructions depending on which processor
    you’re using, try your experiments on the processors where you expect your code
    to run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，建议通过使用不同的算法（包括使用和不使用字符串指令的算法）来实现性能关键的算法，并通过比较它们的性能来确定使用哪种解决方案。由于字符串指令相对于其他指令的运行速度取决于你使用的处理器，因此请在你预期代码运行的处理器上进行实验。
- en: 14.3 SIMD String Instructions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 SIMD 字符串指令
- en: The SSE4.2 instruction set extensions include four powerful instructions for
    manipulating character strings. These instructions were first introduced in 2008,
    so some computers in use today still might not support them. Always use `cpuid`
    to determine if these instructions are available before attempting to use them
    in wide-distribution commercial applications (see “Using cpuid to Differentiate
    Instruction Sets” in Chapter 11).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SSE4.2 指令集扩展包括四条强大的字符字符串操作指令。这些指令最早在 2008 年推出，因此今天仍有一些计算机可能不支持它们。在尝试在广泛分发的商业应用程序中使用它们之前，请始终使用
    `cpuid` 来确定这些指令是否可用（请参见第 11 章中的“使用 cpuid 区分指令集”）。
- en: 'The four SSE4.2 instructions that process text and string fragments are as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本和字符串片段的四条 SSE4.2 指令如下：
- en: '`PCMPESTRI` Packed compare explicit-length strings, return index'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPESTRI` 打包比较显式长度字符串，返回索引'
- en: '`PCMPESTRM` Packed compare explicit-length strings, return mask'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPESTRM` 打包比较显式长度字符串，返回掩码'
- en: '`PCMPISTRI` Packed compare implicit-length strings, return index'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPISTRI` 打包比较隐式长度字符串，返回索引'
- en: '`PCMPISTRM` Packed compare implicit-length strings, return mask'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPISTRM` 打包比较隐式长度字符串，返回掩码'
- en: '*Implicit-length strings* use a sentinel (trailing) byte to mark the end of
    the string, specifically, a zero-terminating byte (or word, in the case of Unicode
    characters). *Explicit-length strings* are those for which you supply a string
    length.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Instructions that produce an index return the index of the first (or last) matching
    occurrence within the source string. Instructions that return a bit mask return
    an array of 0 or (all) 1 bits that mark each occurrence of the match within the
    two input strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The packed compare string instructions are among the most complex in the x86-64
    instruction set. The syntax for these instructions is
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: where `X` is `E` or `I`, and `Y` is `I` or `M`. Both forms use 128-bit operands
    (no 256-bit YMM registers for the `v`-prefixed form in this case), and, unlike
    most SSE instructions, the `(v)pcmp``X``str``Y` instructions allow memory operands
    that are not aligned on a 16-byte boundary (they would be nearly useless for their
    intended operation if they required 16-byte-aligned memory operands).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)pcmp``X``str``Y` instructions compare corresponding bytes or words in
    a pair of XMM registers, combine the results of the individual comparisons into
    a vector (bit mask), and return the results for all the comparisons. The `imm`[8]
    operand controls various comparison attributes as described in “Type of Comparison”
    on the following page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.1 Packed Compare Operand Sizes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bits 0 and 1 of the immediate operand specify the size and type of the string
    elements. The elements can be bytes or words, or they can be treated as unsigned
    or signed values for the comparison (see [Table 14-1](#table14-1)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 specifies word (Unicode) or byte (ASCII) operands. Bit 1 specifies whether
    the operands are signed or unsigned. Generally, for character strings, you use
    unsigned comparisons. However, in certain situations (or when processing strings
    of integers rather than characters), you may want to specify signed comparisons.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: Packed Compare `imm`[8] Bits 0 and 1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 0–1 | 00 | Both source operands contain 16 unsigned bytes. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '|  | 01 | Both source operands contain 8 unsigned words. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '|  | 10 | Both source operands contain 16 signed bytes. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '|  | 11 | Both source operands contain 8 signed words. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: 14.3.2 Type of Comparison
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bits 2 and 3 of the immediate operand specify how the instruction will compare
    the two strings. There are four comparison types, which test characters from one
    string against the set of characters in the second, test characters from one string
    against a range of characters, do a straight string comparison, or search for
    a substring within another string (see [Table 14-2](#table14-2)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-2: Packed Compare `imm`[8] Bits 2 and 3'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| 2–3 | 00 | Equal any: compares each character in the second source string
    against a set of characters appearing in the first source operand. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '|  | 01 | Ranges: compares each value in the second source operand against
    a set of ranges specified by the first source operand. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '|  | 10 | Equal each: compares each corresponding element for equality (character-by-character
    comparison of the two operands). |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '|  | 11 | Equal ordered: searches for the substring specified by the first
    operand within the string specified by the second operand. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: Bits 2 to 3 specify the type of comparison to perform (the *aggregate operation*
    in Intel terminology). *Equal each* (10b) is probably the easiest comparison to
    understand. The packed compare instruction will compare each corresponding character
    in the string (up to the length of the string—more on that later) and set a Boolean
    flag for the result of the comparison of each byte or word in the string, as shown
    in [Figure 14-3](#figure14-3). This is comparable to the operation of the C/C++
    `memcmp()` or `strcmp()` functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![f14003](image_fi/501089c14/f14003.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Equal each aggregate comparison operation'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The *equal any* comparison compares each byte in the second source operand to
    see whether it is any of the characters found in the first source operand (XMM[src2]/mem[src2]).
    For example, if XMM[src1] contains the string `abcdefABCDEF` (and four 0 bytes),
    and XMM[src2]/mem[src2] contains `12AF89C0`, the resulting comparison would yield
    00101100b (1s in the character positions corresponding to the A, F, and C characters).
    Also note that the first character (1) maps to bit 0, and the A and F characters
    map to bits 2 and 3\. This is similar to the `strspn()` and `strcspn()` functions
    in the C Standard Library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The *equal ordered* comparison searches for each occurrence of the string in
    XMM[src1] that can be found in the XMM[src2]/mem[src2] operand. For example, if
    the XMM[src2]/mem[src2] operand contains the string `never need shine` and the
    XMM[src1] operand has the string `ne` (padded with 0s), then the equal ordered
    comparison produces the vector 0100000001000001b. This is similar to the `strstr()`
    function in the C Standard Library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The *ranges* comparison aggregate operation breaks the entries in the XMM[src1]
    operand into pairs (at even and odd indexes in the register). The first element
    (byte or word) specifies a lower bound, and the second entry specifies an upper
    bound. The XMM[src1] register supports up to eight byte ranges or four word ranges
    (if you need fewer ranges, pad the remaining pairs with 0s). This aggregate operation
    compares each character in the XMM[src2]/mem[src2] operand against each of these
    ranges and stores true in the resultant vector if the character is within one
    of the specified ranges (inclusive) and false if it is outside all of these ranges.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.3 Result Polarity
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bits 4 and 5 of the immediate operand specify the result polarity (see [Table
    14-3](#table14-3)). This chapter will fully discuss the meaning of these bits
    in a moment (some additional commentary is necessary).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-3: Packed Compare `imm`[8] Bits 4 and 5'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| 4–5 | 00 | Positive polarity |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '|  | 01 | Negative polarity |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '|  | 10 | Positive masked |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '|  | 11 | Negative masked |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: 14.3.4 Output Processing
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bit 6 of the immediate operand specifies the instruction result (see [Table
    14-4](#table14-4)). The packed compare instructions do not use bit 7; it should
    always be 0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-4: Packed Compare `imm`[8] Bit 6 (and 7)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0 | `(v)pcom``X``stri` only, the index returned in ECX is the first result.
    `(v)pcom``X``strm` only, the mask appears in the LO bits of XMM0 with zero extension
    to 128 bits. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | `(v)pcom``X``stri` only, the index returned in ECX is the last result.
    `(v)pcom``X``strm` only, expand the bit mask into a byte or word mask. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| 7 | 0 | This bit is reserved and should always be 0. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: The `(v)pcmpestrm` and `(v)pcmpistrm` instructions produce a bit-mask result
    and store it into the XMM0 register (this is fixed—the CPU does not determine
    this by the operands to these instructions). If bit 6 of the `imm`8 operand contains
    a 0, these two instructions pack this bit mask into 8 or 16 bits and store them
    into the LO 8 (or 16) bits of XMM0, zero-extending that value through the upper
    bits of XMM0\. If `imm`8 bit 6 contains a 1, these instructions will store the
    bit mask (all 1 bits per byte or word) throughout the XMM0 register.^([5](#c14-footnote-5))
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)pcmpestri` and `(v)pcmpistri` instructions produce an index result and
    return this value in the ECX register.^([6](#c14-footnote-6)) If bit 6 of the
    `imm`8 operand contains a 0, these two instructions return the index of the LO
    set bit in the result bit mask (that is, the first matching comparison). If bit
    6 of the `imm`8 operand is 1, these instructions return the index of the highest-order
    set bit in the resultant bit mask (that is, the last matching comparison). If
    there are no set bits in the result bit mask, these instructions return 16 (for
    byte comparisons) or 8 (for word comparisons) in the ECX register. Although these
    instructions internally generate a bit mask result in order to calculate the index,
    they do not overwrite the XMM0 register (as do the `(v)pcmpestrm` and `(v)pcmpistrm`
    instructions).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.5 Packed String Compare Lengths
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `(v)pcmp``X``str``Y` instructions have a 16-byte (XMM register size) comparison
    limit. This is true even on AVX processors with 32-byte YMM registers. To compare
    larger strings requires executing multiple `(v)pcmp``X``str``Y` instructions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The `(v)pcmpistri` and `(v)pcmpistrm` instructions use an implicit string length.
    The strings appear in the XMM registers or memory with the first character (if
    any) appearing in the LO byte followed by the remaining characters in the string.
    The strings end with a zero-terminating byte or word. If there are more than 16
    characters (if byte strings, or 8 characters if word strings), then the register
    (or 128-bit memory) size delimits the string.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpistri`和`(v)pcmpistrm`指令使用隐式字符串长度。字符串出现在XMM寄存器或内存中，首字符（如果有）出现在LO字节中，后续字符按顺序排列。字符串以零终止字节或字结束。如果字符数超过16（字节字符串）或8（字字符串），则寄存器（或128位内存）大小将限制字符串的长度。'
- en: The `(v)pcmpestri` and `(v)pcmpestrm` instructions use explicitly supplied string
    lengths. The RAX and EAX registers specify the string length for the string appearing
    in XMM[src1], and the RDX and EDX registers specify the string length for the
    string appearing in XMM[src2]/mem[src2]. If the string length is greater than
    16 (for byte strings) or 8 (for word strings), the instruction saturates the length
    at 16 or 8\. Also, the `(v)pcmpestri` and `(v)pcmpestrm` instructions take the
    absolute value of the length, so –1 to –16 is equivalent to 1 to 16\.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpestri`和`(v)pcmpestrm`指令使用显式提供的字符串长度。RAX和EAX寄存器指定XMM[src1]中字符串的长度，RDX和EDX寄存器指定XMM[src2]/mem[src2]中字符串的长度。如果字符串长度大于16（字节字符串）或8（字字符串），指令会将长度饱和为16或8。另外，`(v)pcmpestri`和`(v)pcmpestrm`指令会取长度的绝对值，因此-1到-16等同于1到16。'
- en: The reason the explicit-length instructions saturate the length to 16 (or 8)
    is to allow a program to process larger strings in a loop. By processing 16 bytes
    (or 8 words) at a time in a loop and decrementing the overall string length (from
    some large value down to 0), the packed string operations will operate on 16 or
    8 characters per loop iteration until the very last loop iteration. At that point,
    the instructions will process the remaining (total length mod 16 or 8) characters
    in the string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显式长度指令将长度饱和为16（或8）的原因是允许程序在循环中处理更大的字符串。通过在循环中每次处理16字节（或8字）并递减总字符串长度（从某个大值递减到0），打包字符串操作将在每次循环迭代时处理16个或8个字符，直到最后一次循环迭代。在这一点上，指令将处理字符串中剩余的（总长度对16或8取模）字符。
- en: The reason the explicit-length instructions take the absolute value of the length
    is to allow code that processes large strings to either decrement the loop counter
    (from a large positive value) to 0 or increment the loop counter (from a negative
    value) toward 0, whichever is more convenient for the program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显式长度指令取长度的绝对值的原因是允许处理大字符串的代码将循环计数器（从大正值到0递减）或（从负值递增）到0，以便程序能够更方便地操作。
- en: Whenever the length (implicit or explicit) is less than 16 (for bytes) or 8
    (for words), certain characters in the XMM register (or 128-bit memory location)
    will be invalid. Specifically, every character after the zero-terminating character
    (for implicit-length strings) or beyond the count in RAX and EAX or RDX and EDX
    will be invalid. Regardless of the presence of invalid characters, the packed
    compare instructions still produce an intermediate bit vector result by comparing
    all characters in the string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当长度（隐式或显式）小于16（字节）或8（字）时，XMM寄存器（或128位内存位置）中的某些字符将无效。具体来说，零终止字符后的每个字符（对于隐式长度字符串）或超出RAX和EAX或RDX和EDX中计数的部分将无效。无论是否存在无效字符，打包比较指令仍会通过比较字符串中的所有字符，生成一个中间位向量结果。
- en: 'Because the string lengths of the two input strings (in XMM[src1] and XMM[src2]/mem[src2])
    are not necessarily equal, there are four possible situations: `src1` and `src2`
    are both invalid, exactly one of the two source operands is invalid (and the other
    is valid, so there are two cases here), or both are valid. Depending on which
    operands are valid or invalid, the packed compare instructions may force the result
    to true or false. [Table 14-5](#table14-5) lists how these instructions force
    results, based on the type of comparison (aggregate operation) specified by the
    `imm`8 operand.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '由于两个输入字符串（在XMM[src1]和XMM[src2]/mem[src2]中）的字符串长度不一定相等，因此有四种可能的情况：`src1`和`src2`都无效，恰好一个源操作数无效（另一个有效，所以这里有两种情况），或者两者都有效。根据哪个操作数有效或无效，打包比较指令可能会强制结果为真或假。[表14-5](#table14-5)列出了这些指令如何强制结果，具体取决于`imm`8操作数指定的比较类型（聚合操作）。 '
- en: 'Table 14-5: Comparison Result When Source 1 and Source 2 Are Valid or Invalid'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-5：当源1和源2有效或无效时的比较结果
- en: '| **Src1** | **Src2** | **Equal any** | **Ranges** | **Equal each** | **Equal
    ordered** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| Invalid | Invalid | Force false | Force false | Force true | Force true |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| Invalid | Valid | Force false | Force false | Force false | Force true |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| Valid | Invalid | Force false | Force false | Force false | Force false |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| Valid | Valid | Result | Result | Result | Result |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: To understand the entries in this table, you must consider each comparison type
    individually.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The *equal any* comparison checks whether each character appearing in `src2`
    appears anywhere in the set of characters specified by `src1`. If a character
    in `src1` is invalid, that means the instructions are comparing against a character
    that is not in the set; in this situation, you want to return false (regardless
    of `src2`’s validity). If `src1` is valid but `src2` is invalid, you’re at (or
    beyond) the end of the string; that’s not a valid comparison, so equal any also
    forces a false result in this situation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The *ranges* comparison is also (in a sense) comparing a source string (`src2`)
    against a set of characters (specified by the ranges in `src1`). Therefore, the
    packed compare instructions force false if either (or both) operands are invalid
    for the same reasons as *equal any* comparisons.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The *equal each* comparison is the traditional string comparison operation,
    comparing the string in `src2` to the string in `src1`. If the corresponding character
    in both strings is invalid, you’ve moved beyond the end of both strings. The packed
    compare instructions force the result to true in this situation because these
    instructions are, effectively, comparing empty strings at this point (and empty
    strings are equal). If a character in one string is valid but the corresponding
    character in the other string is invalid, you’re comparing actual characters against
    an empty string, which is always *not equal*; hence, the packed string comparison
    instructions force a false result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The *equal ordered* operation searches for the substring XMM[src1] within the
    larger string XMM[src2]/mem[src2]. If you’ve gone beyond the end of both strings,
    you’re comparing empty strings (and one empty string is always a substring of
    another empty string), so the packed comparison instructions return a true result.
    If you’ve reached the end of the string in `src1` (the substring to search for),
    the result is true even if there are more characters in `src2`; hence, the packed
    comparisons return true in this situation. However, if you’ve reached the end
    of the `src2` string but not the end of the `src1` (substring) string, there is
    no way that *equal ordered* will return true, so the packed comparison instructions
    force a false in this situation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If the polarity bits (bits 4 to 5 of `imm`8) contain 00b or 10b, the polarity
    bits do not affect the comparison operation. If the polarity bits are 01b, the
    packed string comparison instructions invert all the bits in the temporary bit
    map result before copying the data to XMM0 (`(v)pcmpistrm` and `(v)pcmpestrm`)
    or calculating the index (`(v)pcmpestri` and `(v)pcmpistri`). If the polarity
    setting is 11b, the packed string comparison instructions invert the resultant
    bit if and only if the corresponding `src2` character is valid.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.6 Packed String Comparison Results
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last thing to note about the packed string comparison instructions is how
    they affect the CPU flags. These instructions are unusual among the SSE/AVX instructions
    insofar as they affect the condition codes. However, they do not affect the condition
    codes in standard ways (for example, you cannot use the carry and zero flags to
    test for string less than or greater than, as you can with the `cmps` instructions).
    Instead, these instructions overload the meanings of the carry, zero, sign, and
    overflow flags; furthermore, each instruction defines the meaning of these flags
    independently.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: All eight instructions—`(v)pcmpestri`, `(v)pcmpistri`, `(v)pcmpestrm`, and `(v)pcmpistrm`—clear
    the carry flag if all of the bits in the (internal) result bit map are 0 (no comparison);
    these instructions set the carry flag if there is at least 1 bit set in the bit
    map. Note that the carry flag is set or cleared after the application of the polarity.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The zero flag indicates whether the `src2` length is less than 16 (8 for word
    characters). For the `(v)pcmpestri` and `(v)pcmpestrm` instructions, the zero
    flag is set if EDX is less than 16 (8); for the `(v)pcmpistri` and `(v)pcmpistrm`
    instructions, the zero flag is set if XMM[src2]/mem[src2] contains a null character.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The sign flag indicates whether the `src1` length is less than 16 (8 for word
    characters). For the `(v)pcmpestri` and `(v)pcmpestrm` instructions, the sign
    flag is set if EAX is less than 16 (8); for the `(v)pcmpistri` and `(v)pcmpistrm`
    instructions, the zero flag is set if XMM[src1] contains a null character.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The overflow flag contains the setting for bit 0 of the result bit map (that
    is, whether the first character of the source string was a match). This can be
    useful after an equal ordered comparison to see if the substring is a prefix of
    the larger string (for example).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Alignment and Memory Management Unit Pages
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `(v)pcmp``X``str``Y` instructions are nice insofar as they do not require
    their memory operand to be 16-byte aligned. However, this lack of alignment creates
    a special problem of its own: it is possible for a single `(v)pcmp``X``str``Y`
    instruction memory access to cross an MMU page boundary. As noted in “Memory Access
    and 4K Memory Management Unit Pages” in Chapter 3, some MMU pages might not be
    accessible and will generate a general protection fault if the CPU attempts to
    read data from them.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If the string is less than 16 bytes in length and ends before the page boundary,
    using `(v)pcmp``X``str``Y` to access that data may cause an inadvertent page fault
    when it reads a full 16 bytes from memory, including data beyond the end of the
    string. Though accessing data beyond the string that crosses into a new, inaccessible
    MMU page is a rare situation, it can happen, so you want to ensure you don’t access
    data across MMU page boundaries unless the next MMU page contains actual data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have aligned an address on a 16-byte boundary and you access 16 bytes
    from memory starting at that address, you never have to worry about crossing into
    a new MMU page. MMU pages contain an integral multiple of 16 bytes (there are
    256 16-byte blocks in an MMU page). If the CPU accesses 16 bytes starting at a
    16-byte boundary, the last 15 bytes of that block will fall into the same MMU
    page as the first byte. This is why most SSE memory accesses are okay: they require
    16-byte-aligned memory operands. The exceptions are the unaligned move instructions
    and the `(v)pcmp``X``str``Y` instructions.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You typically use the unaligned move instructions (for example, `movdqu` and
    `movupd`) to move 16 actual bytes of data into an SSE/AVX register; therefore,
    these instructions don’t usually access extra bytes in memory. The `(v)pcmp``X``str``Y`
    instructions, however, often access data bytes beyond the end of the actual string.
    These instructions read a full 16 bytes from memory even if the string consumes
    fewer than 16 of those bytes. Therefore, when using the `(v)pcmp``X``str``Y` instructions
    (and the other unaligned moves, if you’re using them to read beyond the end of
    a data structure), you should ensure that the memory address you are supplying
    is at least 16 bytes before the end of an MMU page, or that the next page in memory
    contains valid data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: As Chapter 3 notes, there is no machine instruction that lets you test a page
    in memory to see if the application can legally access that page. So you have
    to ensure that no memory accesses by the `(v)pcmp``X``str``Y` instructions will
    cross a page boundary. The next chapter provides several examples.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 For More Information
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agner Fog is one of the world’s foremost experts on optimization of x86(-64)
    assembly language. His website ([https://www.agner.org/optimize/#manuals/](https://www.agner.org/optimize/#manuals/))
    has a lot to say about optimizing memory moves and other string instructions.
    This website is highly recommended if you want to write fast string code in x86
    assembly language.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: T. Herselman has spent a huge amount of time writing fast `memcpy` functions.
    You can find his results at [https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/](https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/)
    (or just search the web for *Apex memmove*). The length of this code will, undoubtedly,
    convince you to stick with the `movs` instruction (which runs fairly fast on modern
    x86-64 CPUs).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Test Yourself
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What size operands do the generic string instructions support?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the five general-purpose string instructions?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What size operands do the `pcmp``X``str``Y` instructions support?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What registers does the `rep` `movsb` instruction use?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What registers does the `cmpsw` instruction use?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What registers does the `repne` `scasb` instruction use?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What registers does the `stosd` instruction use?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to increment the RSI and RDI registers after each string operation,
    what direction flag setting do you use?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to decrement the RSI and RDI registers after each string operation,
    what direction flag setting do you use?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a function or procedure modifies the direction flag, what should that function
    do before returning?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Microsoft ABI requires a function to _ the direction flag before returning
    if it modifies the flag’s value.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which string instructions have Intel optimized for performance on later x86-64
    CPUs?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you want to set the direction flag prior to using a `movs` instruction?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you want to clear the direction flag prior to using a `movs` instruction?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can happen if the direction flag is not set properly when you are executing
    a `movs` instruction?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which string prefix would you normally use with `cmpsb` to test two strings
    to see if they are equal?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When comparing two character strings, how should the direction flag normally
    be set?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need to test whether RCX is 0 before executing a string instruction with
    a repeat prefix?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted to search for a zero-terminating byte in a C/C++ string, what
    (general-purpose) string instruction would be most appropriate?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted to fill a block of memory with 0s, what string instruction would
    be most appropriate?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted to concoct your own string operations, what string instruction(s)
    would you use?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which string instruction would you typically never use with a repeat prefix?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before using one of the `pcmp``X``str``Y` instructions, what should you do?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which SSE string instructions automatically handle zero-terminated strings?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which SSE string instructions require an explicit length value?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where do you pass explicit lengths to the `pcmp``X``str``Y` instructions?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `pcmp``X``str``Y` aggregate operation searches for characters belonging
    to a set of characters?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `pcmp``X``str``Y` aggregate operation compares two strings?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `pcmp``X``str``Y` aggregate operation checks whether one string is a substring
    of another?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the problem with the `pcmp``X``str``Y` instruction and MMU pages?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
