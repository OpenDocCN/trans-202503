- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: 'Dental Hygiene: Introduction to Embedded Security'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 口腔卫生：嵌入式安全简介
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The sheer variety of embedded devices makes studying them fascinating, but that
    same variety can also leave you scratching your head over yet another shape, package,
    or weird integrated circuit (IC) and what it means in relation to its security.
    This chapter begins with a look at various hardware components and the types of
    software running on them. We then discuss attackers, various attacks, assets and
    security objectives, and countermeasures to provide an overview of how security
    threats are modeled. We describe the basics of creating an attack tree you can
    use both for defensive purposes (to find opportunities for countermeasures) and
    offensive purposes (to reason about the easiest possible attack). Finally, we
    conclude with thoughts on coordinated disclosure in the hardware world.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的种类繁多，这使得研究它们变得非常有趣，但同样的多样性也可能让你对又一种新的形状、封装或奇怪的集成电路（IC）感到困惑，并且不知道它与安全性之间的关系是什么。本章从各种硬件组件和它们上运行的软件类型开始。接着我们讨论攻击者、各种攻击、资产和安全目标，以及防御措施，概述安全威胁是如何建模的。我们描述了创建攻击树的基础知识，既可以用于防御目的（寻找防御措施的机会），也可以用于进攻目的（推理出最容易的攻击方式）。最后，我们以关于硬件领域协调披露的思考作为结尾。
- en: Hardware Components
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件组件
- en: Let’s start by looking at the relevant parts of the physical implementation
    of an embedded device that you’re likely to encounter. We’ll touch on the main
    bits you’ll observe when first opening a device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看你可能会遇到的嵌入式设备的物理实现相关部分开始。我们将涉及你在首次打开设备时会看到的主要部分。
- en: 'Inside an embedded device is a *printed circuit board (PCB)* that generally
    includes the following hardware components: processor, volatile memory, nonvolatile
    memory, analog components, and external interfaces (see [Figure 1-1](#figure1-1)).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备内部有一个*印刷电路板（PCB）*，通常包括以下硬件组件：处理器、易失性存储器、非易失性存储器、模拟组件和外部接口（见[图1-1](#figure1-1)）。
- en: '![f01001](image_fi/278748c01/f01001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](image_fi/278748c01/f01001.png)'
- en: 'Figure 1-1: Typical PCB of an embedded device'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：嵌入式设备的典型PCB
- en: The magic of computation happens in a *processor (central processing unit*,
    or *CPU)*. In [Figure 1-1](#figure1-1), the processor is embedded inside the *System-on-Chip
    (SoC)* in the center 1. Generally, the processor executes the main software and
    operating system (OS), and the SoC contains additional hardware peripherals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的魔力发生在*处理器（中央处理单元，*CPU*)中。在[图1-1](#figure1-1)中，处理器嵌入在*系统芯片（SoC）*的中央1位置。通常，处理器执行主软件和操作系统（OS），而SoC包含额外的硬件外设。
- en: Usually implemented in dynamic RAM (DRAM) chips in discrete packages, *volatile
    memory* 2 is memory that the processor uses while it’s in action; its contents
    are lost when the device powers down. DRAM memory operates at frequencies close
    to the processor frequency, and it needs wide buses in order to keep up with the
    processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*易失性存储器* 2 通常以动态RAM（DRAM）芯片的形式在分立封装中实现，它是处理器在运行时使用的存储器；当设备断电时，它的内容会丢失。DRAM存储器的工作频率接近处理器频率，并且需要宽总线以跟上处理器的速度。'
- en: In [Figure 1-1](#figure1-1), *nonvolatile memory* 3 is where the embedded device
    stores data that needs to persist after power to the device is removed. This memory
    storage can be in the form of EEPROMs, flash memory, or even SD cards and hard
    drives. Nonvolatile memory usually contains code for booting as well as stored
    applications and saved data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1-1](#figure1-1)中，*非易失性存储器* 3 是嵌入式设备存储在设备断电后仍需保持的数据的地方。这种存储方式可以是EEPROM、闪存，甚至是SD卡和硬盘。非易失性存储器通常包含启动代码以及存储的应用程序和保存的数据。
- en: Although not very interesting for security in their own right, the *analog components*,
    such as resistors, capacitors, and inductors, are the starting point for *side-channel
    analysis* and *fault-injection attacks*, which we’ll discuss at length in this
    book. On a typical PCB the analog components are all the little black, brown,
    and blue parts that don’t look like a chip and may have labels starting with “C,”
    “R,” or “L.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*模拟组件*（如电阻器、电容器和电感器）本身在安全性方面并不特别有趣，但它们是*旁路分析*和*故障注入攻击*的起点，我们将在本书中详细讨论这些内容。在典型的PCB中，模拟组件通常是那些看起来不像芯片的小黑色、棕色和蓝色部件，它们的标签可能以“C”、“R”或“L”开头。
- en: '*External interfaces* provide the means for the SoC to make connections to
    the outside world. The interfaces can be connected to other commercial off-the-shelf
    (COTS) chips as part of the PCB system interconnect. This includes, for example,
    a high-speed bus interface to DRAM or to flash chips as well as low-speed interfaces,
    such as I2C and SPI to a sensor. The external interfaces can also be exposed as
    connectors and pin headers on the PCB; for example, USB and PCI Express (PCIe)
    are examples of high-speed interfaces that connect devices externally. This is
    where all communication happens; for example, with the internet, local debugging
    interfaces, or sensors and actuators. (See Chapter 2 for more details on interfacing
    with devices.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*外部接口*为 SoC 提供了与外界连接的方式。这些接口可以连接到其他商用现成（COTS）芯片，作为 PCB 系统互联的一部分。例如，这包括高速度的总线接口到
    DRAM 或闪存芯片，以及低速接口，如 I2C 和 SPI 连接到传感器。外部接口还可以作为 PCB 上的连接器和针脚头暴露出来；例如，USB 和 PCI
    Express（PCIe）是连接外部设备的高速接口的例子。这是所有通信发生的地方；例如，与互联网、本地调试接口或传感器和执行器的通信。（有关与设备接口的更多细节，请参见第二章。）'
- en: Miniaturization allows an SoC to have more *intellectual property (IP) blocks*.
    [Figure 1-2](#figure1-2) shows an example of an Intel Skylake SoC.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微型化使得 SoC 能够拥有更多的*知识产权（IP）块*。[图 1-2](#figure1-2) 显示了一个英特尔 Skylake SoC 的例子。
- en: '![f01002](image_fi/278748c01/f01002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](image_fi/278748c01/f01002.png)'
- en: 'Figure 1-2: Intel Skylake SoC (public domain by Fritzchens Fritz)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：英特尔 Skylake SoC（Fritzchens Fritz 公共领域）
- en: 'This die contains multiple cores, including the main central processing unit
    (CPU) cores, the Intel Converged Security and Management Engine (CSME), the graphics
    processing unit (GPU), and much more. Internal buses in an SoC are harder to access
    than external buses, making SoCs an inconvenient starting point for hacking. SoCs
    can contain the following IP blocks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个芯片包含多个核心，包括主要的中央处理单元（CPU）核心、英特尔融合安全与管理引擎（CSME）、图形处理单元（GPU）等。SoC 内部总线比外部总线更难访问，这使得
    SoC 在黑客攻击中的起点并不方便。SoC 可能包含以下 IP 块：
- en: '**Several (micro)processors and peripherals**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个（微）处理器和外围设备**'
- en: For instance, an application processor, a crypto engine, a video accelerator,
    and the I2C interface driver.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用处理器、一个加密引擎、一个视频加速器和 I2C 接口驱动程序。
- en: '**Volatile memory**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**易失性内存**'
- en: In the form of DRAM ICs stacked on top of the SoC, SRAMs, or register banks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以堆叠在 SoC 上的 DRAM IC、SRAM 或寄存器组的形式存在。
- en: '**Nonvolatile memory**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**非易失性内存**'
- en: In the form of on-die read-only memory (ROM), one-time-programmable (OTP) fuses,
    EEPROM, and flash memory. OTP fuses typically encode critical chip configuration
    data, such as identity information, lifecycle stage, and anti-rollback versioning
    information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以芯片内只读存储器（ROM）、一次性可编程（OTP）熔丝、EEPROM 和闪存的形式存在。OTP 熔丝通常会编码关键的芯片配置数据，例如身份信息、生命周期阶段以及反回滚版本信息。
- en: '**Internal buses**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部总线**'
- en: Though technically just a bunch of microscopic wires, the interconnect between
    the different components in the SoC is, in fact, a major security consideration.
    Think of this interconnect as the network between two nodes in an SoC. Being a
    network, the internal buses could be susceptible to spoofing, sniffing, injection,
    and all other forms of man-in-the-middle attacks. Advanced SoCs include access
    control at various levels to ensure that components in the SoC are “firewalled”
    from each other.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上只是一些微小的导线，SoC 内不同组件之间的互联实际上是一个重要的安全问题。可以把这个互联看作是 SoC 中两个节点之间的网络。作为网络，内部总线可能会受到伪装、嗅探、注入以及所有形式的中间人攻击的威胁。高级
    SoC 包括多级访问控制，以确保 SoC 中的各个组件彼此“防火墙”隔离。
- en: Each of these components is part of the *attack surface*, the starting point
    for an attacker, and is therefore of interest. In Chapter 2, we’ll study these
    external interfaces more in depth, and in Chapter 3, we’ll look at ways to find
    information on the various chips and components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件每一个都是*攻击面*的一部分，是攻击者的起点，因此具有一定的关注度。在第二章，我们将更深入地研究这些外部接口，在第三章，我们将探讨如何查找关于各种芯片和组件的信息。
- en: Software Components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件组件
- en: Software is a structured collection of CPU instructions and data that a processor
    executes. For our purposes, it doesn’t matter whether that software is stored
    in ROM, flash, or on an SD card—although it may come as a disappointment to our
    elder readers that we will not cover punch cards. Embedded devices can contain
    some (or none) of the following types of software.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是 CPU 指令和数据的结构化集合，由处理器执行。就我们而言，软件是否存储在 ROM、闪存或 SD 卡上并不重要——虽然可能会让我们年长的读者失望的是，我们不会讨论穿孔卡。嵌入式设备可以包含以下一些（或没有）类型的软件。
- en: Initial Boot Code
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始启动代码
- en: The initial boot code is the set of instructions a processor executes when it’s
    first powered on. The initial boot code is generated by the processor manufacturer
    and stored in ROM. The main function of *boot ROM code* is to prepare the main
    processor to run the code that follows. Normally, it allows a bootloader to execute
    in the field, including routines for authenticating a bootloader or for supporting
    alternate bootloader sources (such as through USB). It’s also used for support
    during manufacturing for personalization, failure analysis, debugging, and self-tests.
    Often the features available in the boot ROM are configured via *fuses*, which
    are one-time programmable bits integrated into the silicon that provide the option
    to disable some of the boot ROM functionality permanently when the processor leaves
    the manufacturing facility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 初始启动代码是处理器在首次通电时执行的一组指令。初始启动代码由处理器制造商生成并存储在 ROM 中。*启动 ROM 代码* 的主要功能是准备主处理器执行后续代码。通常，它允许引导加载程序在现场执行，包括用于认证引导加载程序或支持备用引导加载程序源（例如通过
    USB）的例程。它还用于制造过程中的支持，包括个性化、故障分析、调试和自检。启动 ROM 中可用的功能通常通过*保险丝*进行配置，保险丝是集成在硅中的一次性可编程位，它在处理器离开制造设施时提供永久禁用某些启动
    ROM 功能的选项。
- en: 'Boot ROM has properties differentiating it from regular code: it is immutable,
    it is the first code to run on a system, and it must have access to the complete
    CPU/SoC to support manufacturing, debugging, and chip failure analysis. Developing
    ROM code requires a lot of care. Because it’s immutable, it’s usually not possible
    to patch a vulnerability in ROM that is detected post-manufacture (although some
    chips support *ROM* *patching* via fuses). Boot ROM executes before any network
    functionality is active, so physical access is required to exploit any vulnerabilities.
    A vulnerability exploited during this phase of boot likely results in direct access
    to the entire system.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 ROM 具有与常规代码不同的属性：它是不可变的，它是系统上运行的第一段代码，且必须能够访问完整的 CPU/SoC，以支持制造、调试和芯片故障分析。开发
    ROM 代码需要非常小心。由于它是不可变的，通常无法修补在制造后发现的 ROM 漏洞（尽管某些芯片支持通过保险丝进行*ROM* *修补*）。启动 ROM 在任何网络功能激活之前执行，因此利用任何漏洞需要物理访问。在启动阶段被利用的漏洞通常会导致直接访问整个系统。
- en: Considering the high stakes for manufacturers in terms of reliability and reputation,
    in general, boot ROM code is usually small, clean, and well verified (at least
    it should be).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到制造商在可靠性和声誉方面的高风险，一般来说，启动 ROM 代码通常较小、简洁且经过良好验证（至少应该是这样）。
- en: Bootloader
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: The *bootloader* initializes the system after the boot ROM executes. It is typically
    stored on nonvolatile but mutable storage, so it can be updated in the field.
    The PCB’s original equipment manufacturer (OEM) generates the bootloader, allowing
    it to initialize PCB-level components. It may also optionally lock down some security
    features in addition to its primary task of loading and authenticating an operating
    system or *trusted execution environment (TEE)*. In addition, the bootloader may
    provide functionality for provisioning a device or debugging. Being the earliest
    mutable code to run on a device, the bootloader is an attractive target to attack.
    Less-secure devices may have a boot ROM that doesn’t authenticate the bootloader,
    allowing attackers to replace the bootloader code easily.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导加载程序* 在启动 ROM 执行后初始化系统。它通常存储在非易失性但可变的存储介质上，因此可以在现场更新。PCB 的原始设备制造商（OEM）生成引导加载程序，使其能够初始化
    PCB 级组件。它还可以选择性地锁定一些安全功能，除了其加载和认证操作系统或*受信执行环境（TEE）*的主要任务外。此外，引导加载程序还可能提供设备配置或调试的功能。作为设备上第一个可变的代码，引导加载程序是一个有吸引力的攻击目标。安全性较差的设备可能拥有不认证引导加载程序的启动
    ROM，从而允许攻击者轻松替换引导加载程序代码。'
- en: Bootloaders are authenticated with digital signatures, which are typically verified
    by embedding a public key (or the hash of a public key) in the boot ROM or fuses.
    Because this public key is hard to modify, it’s considered the *root of trust*.
    The manufacturer signs the bootloader using the private key associated with the
    public key, so the boot ROM code can verify and trust that the manufacturer produced
    it. Once the bootloader is trusted, it can, in turn, embed a public key for the
    next stage of code and provide trust that the next stage is authentic. This *chain
    of trust*can extend all the way down to applications running on an OS (see [Figure
    1-3](#figure1-3)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序通过数字签名进行身份验证，这些签名通常通过将公钥（或公钥的哈希值）嵌入引导ROM或保险丝中来验证。由于这个公钥很难被修改，因此它被认为是*信任根*。制造商使用与公钥关联的私钥对引导加载程序进行签名，因此引导ROM代码可以验证并信任制造商是其生产者。一旦引导加载程序被信任，它可以进一步嵌入下一阶段代码的公钥，并提供对下一阶段代码真实性的信任。这个*信任链*可以一直扩展到运行在操作系统上的应用程序（见[图1-3](#figure1-3)）。
- en: '![f01003](image_fi/278748c01/f01003.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f01003](image_fi/278748c01/f01003.png)'
- en: 'Figure 1-3: Chain of trust—bootloader stages and verification'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：信任链—引导加载程序阶段与验证
- en: Theoretically, creating this chain of trust seems pretty secure, but the scheme
    is vulnerable to a number of attacks, ranging from exploiting verification weaknesses
    to fault injection, timing attacks, and more. See Jasper’s talk at Hardwear.io
    USA 2019 “Top 10 Secure Boot Mistakes” on YouTube ([https://www.youtube.com/watch?v=B9J8qjuxysQ/](https://www.youtube.com/watch?v=B9J8qjuxysQ/))
    for an overview of the top 10 mistakes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，创建这个信任链似乎非常安全，但该方案容易受到多种攻击的威胁，包括利用验证漏洞、故障注入、时间攻击等。请参阅Jasper在2019年Hardwear.io
    USA大会上的讲座《十大安全启动错误》，该讲座可以在YouTube上观看([https://www.youtube.com/watch?v=B9J8qjuxysQ/](https://www.youtube.com/watch?v=B9J8qjuxysQ/))，以了解十大错误概述。
- en: Trusted Execution Environment OS and Trusted Applications
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受信执行环境操作系统与受信应用程序
- en: At the time of writing, the TEE is a rare feature in smaller embedded devices,
    but it’s very common in phones and tablets based on systems such as Android. The
    idea is to create a “virtual” secure SoC by partitioning an entire SoC into “secure”
    and “nonsecure” worlds. This means that every component on the SoC is either exclusively
    active in the secure world, exclusively active in the nonsecure world, or is able
    to switch between the two dynamically. For instance, an SoC developer may choose
    to put a crypto engine in the secure world, networking hardware in the nonsecure
    world, and allow the main processor to switch between the two worlds. This could
    allow the system to encrypt network packets in the secure world and then transmit
    them via the nonsecure world—that is, the “normal world”—ensuring that the encryption
    key never reaches the main OS or a user application on the processor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，TEE在较小的嵌入式设备中是一种罕见的特性，但在基于如Android等系统的手机和平板电脑中非常常见。其理念是通过将整个SoC划分为“安全”和“不安全”世界来创建一个“虚拟”安全SoC。这意味着SoC上的每个组件要么仅在安全世界中活动，要么仅在不安全世界中活动，或者能够在两者之间动态切换。例如，一个SoC开发人员可能会选择将加密引擎放在安全世界中，将网络硬件放在不安全世界中，并允许主处理器在两者之间切换。这可以使系统在安全世界中加密网络数据包，然后通过不安全世界——即“普通世界”——进行传输，从而确保加密密钥永远不会到达主操作系统或处理器上的用户应用程序。
- en: On mobile phones and tablets, the TEE includes its own operating system, with
    access to all secure world components. The *rich execution environment (REE)*
    includes the “normal world” operating system, such as a Linux or iOS kernel and
    user applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机和平板电脑上，TEE包括其自己的操作系统，可以访问所有安全世界组件。*丰富执行环境（REE）*包括“普通世界”操作系统，例如Linux或iOS内核和用户应用程序。
- en: The goal is to keep all nonsecure and complex operations, such as user applications,
    in the nonsecure world, and all secure operations, such as banking applications,
    in the secure world. These secure applications are called *trusted applications
    (TAs)* . The TEE kernel is an attack target that, once compromised, typically
    provides complete access to both the secure and nonsecure worlds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将所有不安全且复杂的操作，如用户应用程序，保留在不安全世界中，而将所有安全操作，如银行应用程序，保留在安全世界中。这些安全应用程序被称为*受信应用程序（TAs）*。TEE内核是一个攻击目标，一旦被攻破，通常会提供对安全世界和不安全世界的完全访问。
- en: Firmware Images
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固件镜像
- en: Firmware is the low-level software that runs on CPUs or peripherals. Simple
    peripherals in a device are often fully hardware based, but more complex peripherals
    can contain a microcontroller that runs firmware. For instance, most Wi-Fi chips
    require a firmware “blob” to be loaded after power-up. For those running Linux,
    a look at */lib/firmware* shows how much firmware is involved in running PC peripherals.
    As with any piece of software, firmware can be complex and therefore sensitive
    to attacks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 固件是运行在 CPU 或外设上的低级软件。设备中的简单外设通常完全基于硬件，但更复杂的外设可能包含运行固件的微控制器。例如，大多数 Wi-Fi 芯片需要在上电后加载固件“二进制块”。对于运行
    Linux 的设备，查看*/lib/firmware* 目录可以看到运行 PC 外设时涉及的固件数量。与任何软件一样，固件可能非常复杂，因此容易受到攻击。
- en: Main Operating System Kernel and Applications
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要操作系统内核和应用程序
- en: The main OS in an embedded system can be a general-purpose OS, like Linux, or
    a real-time OS, like VxWorks or FreeRTOS. Smart cards may contain proprietary
    OSs that run applications written in Java Card. These OSs can offer security functionality
    (for example, cryptographic services) and implement *process isolation*, which
    means if one process is compromised, another process may still be secure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中的主要操作系统可以是通用操作系统，如 Linux，或者是实时操作系统，如 VxWorks 或 FreeRTOS。智能卡可能包含运行 Java
    Card 应用程序的专有操作系统。这些操作系统可以提供安全功能（例如，加密服务）并实现*进程隔离*，这意味着如果一个进程被攻破，另一个进程可能仍然保持安全。
- en: An OS makes life easier for software developers who can rely on a broad range
    of existing functionality, but that may not be a viable option for smaller devices.
    Very small devices may have no OS kernel but run only one *bare-metal* program
    to manage them. This usually implies no process isolation, so compromising one
    function leads to compromising the entire device.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为软件开发者提供了便利，他们可以依赖现有的广泛功能，但对于较小的设备来说，这可能不是一个可行的选项。非常小的设备可能没有操作系统内核，而只运行一个*裸机*程序来管理它们。这通常意味着没有进程隔离，因此一旦某个功能被攻破，整个设备都会受到影响。
- en: Hardware Threat Modeling
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件威胁建模
- en: Threat modeling is one of the more important necessities in the defense of any
    system. Resources for defending a system are not unlimited, so analyzing how those
    resources are best spent to minimize attack opportunities is essential. This is
    the road to “good enough” security.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁建模是任何系统防御中的重要任务之一。防御系统的资源是有限的，因此分析如何最佳地使用这些资源以最小化攻击机会至关重要。这是通向“足够好”安全性的道路。
- en: 'When performing threat modeling, we roughly do the following: take a defensive
    view to identify the system’s important assets and ask ourselves how those assets
    should be secured. On the flip side, from an offensive viewpoint, we could identify
    who the attackers might be, what their goals might be, and what attacks they could
    choose to attempt. These considerations provide insights into what to protect
    and how to protect the most valuable assets.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行威胁建模时，我们大致做以下几步：从防御角度出发，识别系统的重要资产，并问自己这些资产应如何被保护。另一方面，从攻击角度出发，我们可以识别潜在的攻击者、他们的目标以及他们可能选择尝试的攻击方式。这些考虑有助于了解应该保护什么以及如何保护最有价值的资产。
- en: 'The standard reference work for threat modeling is Adam Shostack’s book *Threat
    Modeling: Designing for Security* (Wiley, 2014). The broad field of threat modeling
    is fascinating, as it includes security of the development environment through
    to manufacturing, supply chain, shipping, and the operational lifetime. We’ll
    address the basic aspects of threat modeling here and apply them to embedded device
    security, focusing on the device itself.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁建模的标准参考书是 Adam Shostack 的《*威胁建模：设计安全性*》（Wiley，2014）。威胁建模这一广泛领域非常引人入胜，因为它涵盖了从开发环境到制造、供应链、运输以及运营生命周期的安全性。在这里，我们将讨论威胁建模的基本方面，并将其应用于嵌入式设备安全，重点关注设备本身。
- en: What Is Security?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是安全？
- en: The *Oxford English Dictionary* defines security as “the state of being free
    from danger or threat.” This rather binary definition implies that the only secure
    system is either one that no one would bother to attack or one that can defend
    every threat. The former, we call a *brick*, because it no longer can boot; the
    latter, we call a *unicorn*, because unicorns don’t exist. There is no perfect
    security, so you could argue that any defense is not worth the effort. This attitude
    is known as *security nihilism*. However, that attitude disregards the important
    fact that a *cost-benefit* trade-off is associated with each and every attack.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*牛津英语词典*将安全定义为“免受危险或威胁的状态”。这个相当二元的定义暗示，唯一安全的系统要么是没人愿意攻击的系统，要么是能够防御所有威胁的系统。前者，我们称之为*砖头*，因为它无法再启动；后者，我们称之为*独角兽*，因为独角兽并不存在。没有完美的安全性，因此你可以认为任何防御都不值得付出努力。这种态度被称为*安全虚无主义*。然而，这种态度忽视了一个重要的事实，即每一次攻击都伴随着*成本-收益*的权衡。'
- en: We all understand cost and benefit in terms of money. For an attacker, costs
    are usually related to buying or renting equipment needed for carrying out attacks.
    Benefits come in the form of fraudulent purchases, stolen cars, ransomware payouts,
    and slot machine cash-outs, just to name a few.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都明白金钱方面的成本和收益。对于攻击者来说，成本通常与购买或租赁实施攻击所需的设备有关。收益则表现为欺诈性购买、被盗汽车、勒索软件赎金以及老虎机现金提取，仅举几例。
- en: 'The costs and benefits of performing attacks are not exclusively monetary,
    however. An obvious non-monetary cost is time; a less obvious cost is attacker
    frustration. For example, an attacker who is hacking for fun may simply move on
    to another target in the face of frustration. There is surely a defense lesson
    here. See Chris Domas’s talk at DEF CON 23 for more on this idea: “Repsych: Psychological
    Warfare in Reverse Engineering.” Nonmonetary benefits include gathering personally
    identifiable information and fame derived from conference publications or successful
    sabotage (although those benefits may also be monetized).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，执行攻击的成本和收益并不仅限于金钱。一个显而易见的非金钱成本是时间；一个不太明显的成本是攻击者的挫败感。例如，一个为了娱乐而进行黑客攻击的攻击者可能会在面对挫折时简单地转向另一个目标。这里肯定有一个防御的教训。有关这个想法的更多内容，请参见Chris
    Domas在DEF CON 23上的演讲：“Repsych：反向工程中的心理战”。非金钱的收益包括获取个人身份信息和从会议出版物或成功破坏中获得的名声（尽管这些收益也可能变现）。
- en: In this book, we consider a system “secure enough” if the cost of an attack
    is higher than the benefit. A system design may not be impenetrable, but it should
    be hard enough that no one will see an entire attack through to success. In summary,
    threat modeling is the process of determining how to reach a secure-enough state
    in a particular device or system. Next, let’s look at several aspects that affect
    the benefits and costs of an attack.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们认为如果攻击的成本高于收益，则一个系统是“足够安全”的。一个系统的设计可能并不坚不可摧，但它应该足够坚固，以至于没有人能够将整个攻击过程推进到成功。总之，威胁建模是确定如何在特定设备或系统中达到“足够安全”状态的过程。接下来，我们来看看几个影响攻击收益和成本的方面。
- en: Attacks Through Time
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 穿越时间的攻击
- en: 'The US National Security Agency (NSA) has a saying: “Attacks always get better;
    they never get worse.” In other words, attacks get cheaper and stronger over time.
    This tenet particularly holds at larger timescales, because of increased public
    knowledge of a target, decreased cost of computing power, and the ready availability
    of hacking hardware. The time from a chip’s initial design to final production
    can span several years, followed by at least a year to implement the chip in a
    device, resulting in three to five years before it’s operational in a commercial
    environment. This chip may need to remain operational for a few years (in the
    case of Internet of Things [IoT] products), or 10 years (for an electronic passport),
    or even for 20 years (in automotive and medical environments). Thus, designers
    need to take into account whatever attacks might be happening 5 to 25 years hence.
    This is clearly impossible, so often software fixes have to be pushed out to mitigate
    unpatchable hardware problems. To put it in perspective, 25 years ago a smart
    card may have been very hard to break, but after working your way through this
    book, a 25-year-old smart card should pose little resistance in extracting its
    keys.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 美国国家安全局（NSA）有句名言：“攻击总是越来越好，而不是变得更差。”换句话说，攻击随着时间的推移变得更便宜、更强大。这个原理尤其适用于较长的时间尺度，因为公众对目标的了解增加、计算能力的成本下降以及黑客硬件的易得性。芯片从初步设计到最终生产可能需要几年时间，接着至少需要一年时间将芯片集成到设备中，导致芯片在商业环境中投入使用时通常需要三到五年的时间。这个芯片可能需要在几年内保持正常工作（例如物联网产品），或者十年（如电子护照），甚至二十年（如汽车和医疗环境）。因此，设计师需要考虑未来5到25年内可能发生的任何攻击。这显然是不可能的，因此通常需要推迟软件修复以缓解无法修补的硬件问题。换句话说，25年前，智能卡可能很难被破解，但通过本书的学习后，25年的智能卡应该几乎没有任何抵抗力来提取其密钥。
- en: Cost differences also appear on smaller timescales when going from an initial
    attack to repeating that attack. The *identification phase* involves identifying
    vulnerabilities. The *exploitation phase* follows, which involves using the identified
    vulnerabilities to exploit a target. In the case of (scalable) software vulnerabilities,
    the identification cost may be significant, but the exploitation cost is almost
    zero, as the attack can be automated. For hardware attacks, the exploitation cost
    may still be significant.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 成本差异也出现在较短的时间尺度上，从初始攻击到重复攻击之间的差距。*识别阶段*涉及识别漏洞。紧接着是*利用阶段*，即利用已识别的漏洞来攻击目标。在（可扩展的）软件漏洞的情况下，识别成本可能很高，但利用成本几乎为零，因为攻击可以自动化。而对于硬件攻击，利用成本仍然可能很高。
- en: On the benefits side, attacks typically have a limited window within which they
    have value. Cracking Commodore 64 copy protection today provides little monetary
    advantage. A video stream of your favorite sportsball game has high value only
    while the game is in progress and before the result is known. The day afterward,
    its value is significantly lower.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在效益方面，攻击通常具有一个有限的有效期。在今天破解Commodore 64的复制保护几乎没有任何经济价值。你最喜欢的体育比赛的视频流只有在比赛进行时和结果未揭晓之前才具有高价值。比赛结束后的第二天，其价值显著降低。
- en: Scalability of Attacks
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 攻击的可扩展性
- en: The identification and exploitation phases of software and hardware attacks
    differ significantly from each other in terms of cost and benefit. The cost of
    the hardware exploitation phase may be comparable to that of the identification
    phase, which is uncommon for software. For instance, a securely designed smart
    card payment system makes use of diversified keys so that finding the key on one
    card means you learn nothing about the key of another card. If card security is
    sufficiently strong, attackers need weeks or months and expensive equipment to
    make a few thousand dollars’ worth of fraudulent purchases on each card. They
    must repeat the process for every new card to gain the next few thousand dollars.
    If the cards are that strong, obviously no business case exists for financially
    motivated attackers; such an attack scales poorly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 软件和硬件攻击的识别阶段和利用阶段在成本和效益上有显著区别。硬件利用阶段的成本可能与识别阶段相当，而软件攻击则不常见这种情况。例如，设计得很安全的智能卡支付系统使用了多样化的密钥，使得在一张卡上找到密钥并不能让你了解另一张卡的密钥。如果卡片安全性足够强，攻击者需要数周或数月的时间和昂贵的设备才能在每张卡上进行几千美元的欺诈性购买。为了获得下一个几千美元，他们必须为每张新卡重复这一过程。如果卡片这么强，显然对于以经济利益为动机的攻击者而言没有商业可行性；这种攻击的可扩展性很差。
- en: On the other hand, consider the Xbox 360 modchips. [Figure 1-4](#figure1-4)
    shows the Xenium ICE modchip as the white PCB to the left.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，考虑一下 Xbox 360 改装芯片。[图1-4](#figure1-4) 显示了 Xenium ICE 改装芯片，左侧是白色 PCB。
- en: '![f01004](image_fi/278748c01/f01004.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f01004](image_fi/278748c01/f01004.png)'
- en: 'Figure 1-4: Xenium ICE modchip in an Xbox, used to bypass code verification
    (photo by Helohe, CC BY 2.5 license)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：Xenium ICE 改装芯片在 Xbox 中的应用，用于绕过代码验证（图片来源：Helohe，CC BY 2.5 许可证）
- en: A Xenium ICE modchip on the left in [Figure 1-4](#figure1-4) is soldered to
    the main Xbox PCB in order to perform its attack. The board automates a fault
    injection attack to load arbitrary firmware. This hardware attack is so easily
    performed, selling modchips could be turned into a business; therefore, we say
    it “scales well” (Chapter 13 provides a more detailed description of this attack).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](#figure1-4)中左侧的 Xenium ICE 改装芯片被焊接到 Xbox 主板上，以执行攻击。该板通过自动化故障注入攻击加载任意固件。这种硬件攻击非常容易执行，以至于销售改装芯片本身就可以成为一项商业活动；因此，我们称其为“具有良好的扩展性”（第13章提供了该攻击的详细描述）。'
- en: Hardware attackers benefit from economies of scale, but only if the exploitation
    cost is very low. One example of this is hardware attacks to extract secrets that
    can then be used at scale, such as recovery of a master firmware update key hidden
    in hardware facilitating access to a multitude of firmware. Another example is
    the once-off operation of extracting boot ROM or firmware code, which can expose
    system vulnerabilities that can be exploited many times over.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件攻击者受益于规模经济，但前提是利用成本必须非常低。一个例子是硬件攻击提取可以大规模使用的秘密，比如恢复隐藏在硬件中的主固件更新密钥，从而访问大量固件。另一个例子是一次性操作提取启动
    ROM 或固件代码，这样可以暴露出可反复利用的系统漏洞。
- en: Finally, scale is not important for some hardware attacks. For example, hacking
    once would be sufficient for obtaining an unencrypted copy of a video from a digital
    rights management (DRM) system that is then pirated, as is the case with launching
    a single nuclear missile or decrypting a president’s tax returns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于一些硬件攻击而言，规模并不重要。例如，黑客攻击一次就足以获得未加密的数字版权管理（DRM）系统视频副本，然后进行盗版，就像发射一次核导弹或解密总统的税务申报表一样。
- en: The Attack Tree
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击树
- en: An *attack tree* visualizes the steps an attacker takes when going from the
    attack surface to the ability to compromise an asset, allowing us to analyze an
    attack strategy systematically. The four ingredients we consider in an attack
    tree are attackers, attacks, assets (security objectives), and countermeasures
    (see [Figure 1-5](#figure1-5)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*攻击树*可视化了攻击者从攻击面到破坏资产能力的步骤，帮助我们系统地分析攻击策略。我们在攻击树中考虑的四个要素是攻击者、攻击、资产（安全目标）和对策（见[图1-5](#figure1-5)）。'
- en: '![f01005](image_fi/278748c01/f01005.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f01005](image_fi/278748c01/f01005.png)'
- en: 'Figure 1-5: Relationship between elements of threat modeling'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：威胁建模要素之间的关系
- en: Profiling the Attackers
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击者画像
- en: Profiling the attackers is important because attackers have motives, resources,
    and limitations. You could claim that botnets or worms are nonhuman players lacking
    motivation, but a worm is initially launched by a person pressing enter with glee,
    anger, or greedy anticipation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 画像攻击者非常重要，因为攻击者有动机、资源和限制。你可以说僵尸网络或蠕虫是没有动机的非人类玩家，但蠕虫的初始启动是由一个人按下回车键时的喜悦、愤怒或贪婪预期驱动的。
- en: Profiling the attacker hinges significantly on the nature of the attack required
    for a particular type of device. The attack itself determines the necessary equipment
    and expense required; both factors help profile the attacker to some extent. The
    government wanting to unlock a mobile phone is an example of a costly attack that
    has a high incentive, such as espionage and state security.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者画像在很大程度上取决于特定设备所需的攻击类型。攻击本身决定了所需的设备和费用；这两个因素在一定程度上帮助画像攻击者。例如，政府想要解锁一部手机，这是一个代价高昂、动机强烈的攻击，动机可能是间谍活动或国家安全。
- en: 'The following are some common attack scenarios and associated motives, characters,
    and capabilities of the corresponding attackers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的攻击场景，以及相应攻击者的动机、特征和能力：
- en: '**Criminal enterprise**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**犯罪企业**'
- en: Financial gain primarily motivates criminal enterprise attacks. Maximizing profit
    requires scaling. As discussed before, a hardware attack may be at the root of
    a scalable attack, which necessitates a well-provisioned hardware attack laboratory.
    As an example, consider attacks on the pay-TV industry, where pirates have solid
    business cases that justify millions of dollars’ worth of equipment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经济利益主要驱动着犯罪企业攻击。最大化利润需要规模化。正如之前所讨论的，硬件攻击可能是可扩展攻击的根源，这就需要一个设备齐全的硬件攻击实验室。例如，考虑对付费电视行业的攻击，海盗们有着合理的商业案例，能够
    justify 数百万美元的设备投入。
- en: '**Industry competition**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**行业竞争**'
- en: An attacker’s motivation in this security scenario ranges from *competitive
    analysis* (an innocent euphemism for reverse engineering to see what the competition
    is doing), to sleuthing IP infringement, to gathering ideas and inspiration for
    improving one’s own related product. Indirect sabotage by damaging a competitor’s
    brand image is a similar tactic. This type of attacker is not necessarily an individual
    but may be part of a team employed (perhaps underground) or externally hired by
    a company that has all the needed hardware tools.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个安全场景中，攻击者的动机可以从*竞争分析*（一个无害的委婉说法，用来形容逆向工程，看看竞争对手在做什么），到调查知识产权侵权，再到收集创意和灵感以改进自己的相关产品。通过破坏竞争对手的品牌形象进行间接破坏也是一种类似的手段。这类攻击者不一定是个人，可能是某个团队的一部分，受雇于（可能是地下的）或外部聘请的公司，他们拥有所需的硬件工具。
- en: '**Nation-states**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**国家级攻击者**'
- en: Sabotage, espionage, and counterterrorism are common motivators. Nation-states
    likely have all the tools, knowledge, and time at their disposal. By the infamous
    words of James Mickens, if the Mossad (national intelligence agency of Israel)
    targets you, whatever you do in terms of countermeasures, “you’re still gonna
    be Mossad’ed upon.”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意破坏、间谍活动和反恐是常见的动机。国家级攻击者可能拥有所有必要的工具、知识和时间。引用詹姆斯·米肯斯的著名话语，如果摩萨德（以色列国家情报局）盯上了你，不管你采取什么反制措施，“你仍然会被摩萨德盯上。”
- en: '**Ethical hackers**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**道德黑客**'
- en: Ethical hackers may be a threat, but with a different risk. They may have hardware
    skills and access to basic tools at home or expensive tools at a local university,
    making them as well-equipped as malicious attackers. Ethical hackers are drawn
    to problems where they feel they can make a difference. They can be hobbyists
    driven to understand how things work, or people who strive to be the best or well
    known for their abilities. They also can be researchers who trade on their skills
    for a primary or secondary income, or patriots or protestors who strongly support
    or oppose causes. An ethical hacker doesn’t necessarily present no risk. One smart
    lock manufacturer once lamented to us that a big concern of the company was ending
    up on stage as an example at an ethical hacking event; they perceived this as
    impacting the trust in their brand. In reality, most criminals will use a brick
    to “hack” the lock, so lock customers have little risk of a hack, but the slogan
    “Don’t worry, they’ll use a brick and not a computer,” doesn’t work so well in
    a public relations campaign.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 道德黑客可能构成威胁，但其风险有所不同。他们可能拥有硬件技能，并能访问家中的基本工具，或者在本地大学拥有昂贵的工具，使他们的装备和恶意攻击者一样强大。道德黑客被吸引去解决他们认为能带来改变的问题。他们可以是业余爱好者，驱动他们的是对事物工作原理的理解，或者是那些努力成为最好或者因其能力而著名的人。他们也可能是通过技能谋生的研究人员，或者是强烈支持或反对某些事业的爱国者或抗议者。道德黑客不一定没有风险。曾有一家智能锁制造商向我们抱怨，他们公司的一大担忧是最终成为道德黑客活动中的一个例子，他们认为这会影响品牌的信任度。实际上，大多数罪犯会使用砖块来“破解”锁具，所以锁具客户遭遇黑客攻击的风险很小，但“别担心，他们会用砖块而不是电脑”这种宣传口号，在公关活动中并不奏效。
- en: '**Layperson attackers**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**外行攻击者**'
- en: This last type of attacker is typically an individual or small group of people
    with an axe to grind by way of hurting another individual, company, or infrastructure.
    They might, however, not always have the technical acumen. Their aim could be
    financial gain via blackmail or selling trade secrets, or simply to hurt another
    party. Successful hardware attacks from such attackers are generally unlikely
    due to limited knowledge and budget. (For all laypersons out there, please don’t
    DM us on how to break into your ex’s Facebook account.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击者通常是个人或小团体，他们通过伤害其他个人、公司或基础设施来报复某些原因。然而，他们不一定具备足够的技术能力。其目标可能是通过敲诈或出售商业机密获得经济利益，或者仅仅是为了伤害他人。由于知识和预算的限制，这类攻击者成功进行硬件攻击的可能性通常较低。（对于所有外行人来说，请不要私信我们询问如何破解你前任的Facebook账号。）
- en: Identifying potential attackers is not necessarily clear-cut and depends on
    the device. In general, it is easier to profile attackers when considering a concrete
    product versus a product’s component. For instance, the threat of hacking a brand
    of IoT coffee makers over the internet to produce a weak brew could be linked
    to the various attacker types just listed. Profiling becomes more complex higher
    up the supply chain of a device. A component in IoT devices may be an *advanced
    encryption standard (AES)* accelerator provided by an IP vendor. This accelerator
    is integrated in an SoC, which is integrated onto a PCB, from which a final device
    is made. How would the IP vendor of the AES accelerator identify the threats on
    the 1,001 different devices using that AES accelerator? The vendor would need
    to concentrate more on the type of attack than on the attackers (for instance,
    by implementing a degree of resistance against side-channel attacks).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确定潜在的攻击者并非易事，这取决于设备的类型。通常，当考虑到具体的产品而非产品的组件时，更容易识别攻击者类型。例如，黑客通过互联网攻击某品牌的 IoT
    咖啡机，使其泡出较弱的咖啡，这一威胁可以与上述不同类型的攻击者相关联。随着设备供应链层次的提高，攻击者画像变得更加复杂。IoT 设备中的某个组件可能是由 IP
    供应商提供的*高级加密标准（AES）*加速器。这个加速器集成在 SoC 中，再集成到 PCB 上，最终制造成设备。那么 AES 加速器的 IP 供应商如何识别使用该加速器的
    1,001 种不同设备上的威胁呢？供应商需要更多地关注攻击类型，而不是攻击者（例如，通过实施抵御侧信道攻击的措施）。
- en: When you design a device, we strongly advise you to ascertain from your component
    suppliers what attack types have been guarded against. Threat modeling without
    that knowledge cannot be thorough, and perhaps more important, if suppliers aren’t
    queried on this, they won’t be motivated to improve their security measures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计设备时，我们强烈建议你向组件供应商询问他们防范了哪些类型的攻击。没有这些知识的威胁建模无法做到彻底，更重要的是，如果不向供应商询问，他们也不会有动力改进他们的安全措施。
- en: Types of Attacks
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击类型
- en: Hardware attacks obviously target hardware, such as opening up a *Joint Test
    Action Group (JTAG)* debugging port, but they may also target software, such as
    bypassing password verification. This book does not address software attacks on
    software, but it does address using software to attack hardware.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件攻击显然是针对硬件的，例如打开*联合测试行动组（JTAG）*调试端口，但它们也可能针对软件，例如绕过密码验证。本书不涉及软件对软件的攻击，但它确实涉及使用软件攻击硬件。
- en: As mentioned previously, the attack surface is the starting point for an attacker—the
    directly accessible bits of hardware and software. When considering the attack
    surface, we usually assume full physical access to the device. However, being
    within Wi-Fi range (*proximate range*) or being connected through any network
    (*remote*) can also be a starting point for an attack.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，攻击面是攻击者的起点——硬件和软件的直接可访问部分。考虑攻击面时，我们通常假设对设备有完全的物理访问权限。然而，处于 Wi-Fi 范围内（*近距离范围*）或通过任何网络连接（*远程*）也可以是攻击的起点。
- en: The attack surface may start with the PCB, whereas a more skilled attacker may
    extend the attack surface to the chip using decapping and microprobing techniques,
    as described later in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击面可能从 PCB 开始，而一个更熟练的攻击者可能会通过去除封装和微探针技术将攻击面扩展到芯片，如本章后续所述。
- en: Software Attacks on Hardware
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件上的软件攻击
- en: 'Software attacks on hardware use various software controls over hardware or
    the monitoring of hardware. There are two subclasses of software attacks on hardware:
    fault injection and side-channel attacks.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件上的软件攻击使用各种软件控制硬件或监控硬件。硬件上的软件攻击有两类子攻击：故障注入和侧信道攻击。
- en: Fault Injection
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障注入
- en: '*Fault injection* is the practice of pushing hardware to a point that induces
    processing errors. A fault injection by itself is not an attack; it’s what you
    do with the effect of the fault that turns it into an attack. Attackers attempt
    to exploit these artificially produced errors. For example, they can obtain privileged
    access by bypassing security checks. The practice of injecting a fault and then
    exploiting the effect of that fault is called a *fault attack*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障注入*是将硬件推至导致处理错误的极限的做法。单独的故障注入并不是攻击；是故障的效果被利用后才会变成攻击。攻击者试图利用这些人为产生的错误。例如，他们可以通过绕过安全检查获得特权访问。故障注入并利用该故障效果的做法称为*故障攻击*。'
- en: '*DRAM hammering* is a well-known fault injection technique in which the DRAM
    memory chip is bombarded with an unnatural access pattern in three adjacent rows.
    By repeatedly activating the outer two rows, bit flips occur in the center *victim
    row*. The *Rowhammer attack* exploits DRAM bit flips by causing victim rows to
    be page tables. *Page tables* are structures maintained by an operating system
    that limit the memory access of applications. By changing access control bits
    or physical memory addresses in those page tables, an application can access memory
    it normally would not be able to access, which easily leads to privilege escalation.
    The trick is to massage the memory layout such that the victim row with page tables
    is in between attacker-controlled rows and then activate these rows from high-level
    software. This method has been proven possible on the x86 and ARM processors,
    from low-level software all the way up to JavaScript. See the article “Drammer:
    Deterministic Rowhammer Attacks on Mobile Platforms” by Victor van der Veen et
    al. for more information.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*DRAM击打*是一种著名的故障注入技术，其中DRAM内存芯片以一种不自然的访问模式轰击三个相邻的行。通过反复激活外部的两行，中心的*受害行*会发生位翻转。*Rowhammer攻击*通过引发DRAM位翻转来利用受害行，导致这些行成为页表。*页表*是操作系统维护的结构，限制应用程序的内存访问。通过更改这些页表中的访问控制位或物理内存地址，应用程序可以访问通常无法访问的内存，这很容易导致特权提升。诀窍是调整内存布局，使得包含页表的受害行位于攻击者控制的行之间，然后从高级软件激活这些行。这种方法已在x86和ARM处理器上得到了验证，从低级软件到JavaScript都可以实现。有关更多信息，请参见Victor
    van der Veen等人所著的《Drammer: Deterministic Rowhammer Attacks on Mobile Platforms》。'
- en: '*CPU overclocking* is another fault-injection technique. Overclocking the CPU
    causes a temporary fault called a *timing fault* to occur. Such a fault can manifest
    itself as a bit error in a CPU register. *CLKSCREW* is an example of a CPU overclocking
    attack. Because software on mobile phones can control the CPU frequency as well
    as the core voltage, by lowering the voltage and momentarily increasing the CPU
    frequency, an attacker can induce the CPU to make faults. By timing this correctly,
    attackers can generate a fault in the RSA signature verification, which allows
    them to load improperly signed arbitrary code. For more information, see “CLKSCREW:
    Exposing the Perils of Security-Oblivious Energy Management” by Adrian Tang et
    al.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*CPU超频*是另一种故障注入技术。超频CPU会导致一种暂时性故障，称为*时序故障*。这种故障可能表现为CPU寄存器中的位错误。*CLKSCREW*就是一个CPU超频攻击的例子。由于手机上的软件可以控制CPU频率以及核心电压，通过降低电压并短暂提高CPU频率，攻击者可以诱使CPU发生故障。通过正确地把握时机，攻击者可以在RSA签名验证中制造故障，从而加载不正确签名的任意代码。更多信息，请参见Adrian
    Tang等人所著的《CLKSCREW: Exposing the Perils of Security-Oblivious Energy Management》。'
- en: You can find these kinds of vulnerabilities anywhere software can force hardware
    to run outside normal operating parameters. We expect further variants will continue
    to emerge.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何软件能够迫使硬件超出正常操作参数的地方找到这些漏洞。我们预计未来会继续出现更多变种。
- en: Side-Channel Attacks
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 辅助通道攻击
- en: Software timing relates to the amount of wall-clock time required for a processor
    to complete a software task. In general, more complex tasks need more time. For
    example, sorting a list of 1,000 numbers takes longer than sorting a list of 100
    numbers. It should be no surprise that an attacker can use software execution
    time as a handle for an attack. In modern embedded systems, it is easy for an
    attacker to measure the execution time, often down to the resolution of a single
    clock cycle! This leads to *timing attacks*, in which an attacker tries to relate
    software execution time to the value of internal secret information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 软件时序与处理器完成软件任务所需的墙钟时间有关。通常，任务越复杂，需要的时间越长。例如，排序1000个数字比排序100个数字需要更多的时间。攻击者利用软件执行时间作为攻击手段并不意外。在现代嵌入式系统中，攻击者很容易测量执行时间，甚至精确到一个时钟周期的分辨率！这就导致了*时序攻击*，攻击者试图将软件执行时间与内部秘密信息的值关联起来。
- en: For instance, the `strcmp` function in C determines whether two strings are
    the same. It compares characters one by one, starting at the front, and when it
    encounters a differing character, it terminates. When using `strcmp` to compare
    an entered password to a stored password, the duration of `strcmp`’s execution
    leaks information about the password, as it terminates upon finding the first
    nonmatching character between the attacker’s candidate password and the password
    protecting the device. The `strcmp` execution time therefore leaks the number
    of initial characters in the password that are correct. (We detail this attack
    in Chapter 8 and describe the proper way of implementing this comparison in Chapter
    14.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C语言中的`strcmp`函数用于判断两个字符串是否相同。它逐个比较字符，从前到后，当遇到不同的字符时，就会终止。在使用`strcmp`将输入的密码与存储的密码进行比较时，`strcmp`的执行时长泄露了密码的一些信息，因为它会在找到攻击者提供的密码与保护设备的密码之间的第一个不匹配字符时终止。因此，`strcmp`的执行时间泄露了密码中最初正确字符的数量。（我们在第8章中详细介绍了这种攻击，并在第14章中描述了正确实现这种比较的方法。）
- en: '*RAMBleed* is another side-channel attack that can be launched from software,
    as demonstrated by Kwong et al. in “RAMBleed: Reading Bits in Memory Without Accessing
    Them.” It uses the Rowhammer-style weaknesses to read bits from DRAM. In a RAMBleed
    attack, the flips happen in an attacker’s row based on the data in victim rows.
    This way, an attacker can observe the memory contents of another process.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*RAMBleed*是另一种可以通过软件发起的侧信道攻击，Kwong等人在《RAMBleed：在不访问内存的情况下读取内存中的比特》一文中展示了这种攻击。它利用了类似Rowhammer的漏洞来从DRAM中读取比特。在RAMBleed攻击中，翻转发生在攻击者的行中，基于受害者行中的数据。通过这种方式，攻击者可以观察到另一个进程的内存内容。'
- en: Microarchitectural Attacks
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 微架构攻击
- en: Now that you understand the principle of timing attacks, consider the following.
    Modern-day CPUs are fast because of the huge number of optimizations that have
    been identified and implemented over the years. A cache, for instance, is built
    on the premise that recently accessed memory locations are soon likely to be accessed
    again. Therefore, the data at those memory locations is stored physically closer
    to the CPU for faster access. Another example of an optimization arose from the
    insight that the result of multiplying a number *N* by 0 or 1 is trivial, so performing
    the full multiplication calculation isn’t needed, as the answer is always simply
    0 or *N*. Such optimizations are part of the *microarchitecture*, which is the
    hardware implementation of an instruction set.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了时序攻击的原理，请考虑以下内容。现代CPU之所以快速，是因为多年来已经识别并实施了大量优化。例如，缓存是基于这样一个前提：最近访问的内存位置很可能会再次被访问。因此，这些内存位置的数据会物理上更靠近CPU，以便更快地访问。另一个优化的例子源自这样一个见解：将一个数字*N*与0或1相乘的结果是显而易见的，因此不需要进行完整的乘法计算，因为答案始终是0或*N*。这些优化是*微架构*的一部分，微架构是指指令集的硬件实现。
- en: However, this is where optimizations for speed and security are at odds. If
    the optimization is activated related to some secret value, that optimization
    may hint at values in the data. For instance, if a multiplication of *N* times
    *K* for an unknown *K* is sometimes faster than other times, the value of *K*
    could be 0 or 1 in the fast cases. Or, if a memory region is cached, it can be
    accessed faster, so a fast access means a particular region has been accessed
    recently.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，优化速度和安全性常常是对立的。如果某些与机密值相关的优化被启用，可能会泄露数据中的某些值。例如，如果某个未知的*K*值的*N*次*K*乘法有时比其他时候更快，那么在速度较快的情况下，*K*值可能是0或1。或者，如果某个内存区域被缓存，它的访问速度会更快，因此快速访问意味着该区域最近被访问过。
- en: 'The notorious *Spectre* attack from 2018 exploits a neat optimization called
    *speculative execution*. Computing whether a conditional branch should be taken
    or not takes time. Instead of waiting for the branch condition to be computed,
    speculative execution guesses the branch condition and executes the next instructions
    as if the guess is correct. If the guess is correct, the execution simply continues,
    and if the guess is incorrect, the execution will be rolled back. This speculative
    execution, however, still affects the state of the CPU caches. Spectre forces
    a CPU to perform a speculative operation that affects the cache in a way that
    depends on some secret value, and then it uses a cache timing attack to recover
    the secret. As shown in “Spectre Attacks: Exploiting Speculative Execution,” by
    Paul Kocher et al., we can use this trick in some existing or crafted programs
    to dump the entire process memory of a victim process. The larger issue at hand
    is that processors have been optimized for speed in this way for decades, and
    there are many optimizations that may be exploited similarly.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 恶名昭彰的*Spectre*攻击源自2018年，利用了一种称为*预测执行*的巧妙优化。计算是否应该执行条件分支需要时间。预测执行并不等待分支条件被计算出来，而是猜测分支条件并像猜测正确一样执行下一条指令。如果猜测正确，执行就继续进行；如果猜测错误，执行将被回滚。然而，这种预测执行仍然会影响CPU缓存的状态。Spectre迫使CPU执行一种预测操作，影响缓存的方式依赖于某些秘密值，然后使用缓存定时攻击恢复该秘密。正如Paul
    Kocher等人在《Spectre攻击：利用预测执行》中所展示的那样，我们可以在一些现有或自制的程序中使用这个技巧，转储受害进程的整个进程内存。更大的问题是，处理器在过去几十年中一直以这种方式进行速度优化，并且还有许多类似的优化可能被利用。
- en: PCB-Level Attacks
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCB级攻击
- en: The PCB is often the initial attack surface for devices, so it’s crucial for
    attackers to learn as much as possible from the PCB design. The design provides
    clues as to where exactly to hook into the PCB or reveals where better attack
    points are located. For example, to reprogram a device’s firmware (potentially
    enabling full control over a device), the attacker first needs to identify the
    firmware programming port on the PCB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PCB通常是设备的初始攻击面，因此攻击者必须尽可能多地从PCB设计中获取信息。设计提供了有关在哪里接入PCB的线索，或者揭示了更好的攻击点。例如，要重新编程设备的固件（可能完全控制设备），攻击者首先需要在PCB上识别固件编程端口。
- en: For PCB-level attacks, all that’s needed to access many devices is a screwdriver.
    Some devices implement physical tamper resistance and tamper response, such as
    FIPS (Federal Information Processing Standard) 140 level 3 or 4 validated devices
    or payment terminals. Although it’s an interesting sport in itself, bypassing
    tamper-proofing and getting to the electronics is beyond the scope of this book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PCB级攻击，访问许多设备所需的工具只是一把螺丝刀。一些设备实现了物理防篡改和篡改响应，例如通过FIPS（联邦信息处理标准）140级3或4认证的设备或支付终端。虽然这本身是一个有趣的运动，但绕过防篡改措施并接触到电子设备超出了本书的范围。
- en: One example of a PCB-level attack is taking advantage of SoC options that are
    configured by pulling certain pins high or low using *straps*. The straps are
    visible on the PCB as 0 Ω (zero-ohm) resistors (see [Figure 1-6](#figure1-6)).
    These SoC options may well include debug enablement, booting without signature
    checking, or other security-related settings.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PCB级攻击的例子是利用通过*跳线*将某些引脚拉高或拉低来配置SoC选项。这些跳线在PCB上以0Ω（零欧姆）电阻的形式显示（见[图1-6](#figure1-6)）。这些SoC选项可能包括启用调试、无签名检查启动或其他与安全相关的设置。
- en: '![f01006](image_fi/278748c01/f01006.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![f01006](image_fi/278748c01/f01006.png)'
- en: 'Figure 1-6: Zero-ohm resistors (R29 and R31)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：零欧姆电阻（R29和R31）
- en: Adding or removing the straps to change configuration is trivial. Although modern
    multilayer PCBs and surface-mount devices complicate modifications, all you need
    are a steady hand, a microscope, tweezers, a heat gun, and, above all, patience
    to complete the task.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或移除跳线以改变配置非常简单。尽管现代多层PCB和表面贴装设备使得修改更加复杂，但只需要一只稳健的手、一台显微镜、一把镊子、一只热风枪，最重要的是耐心，就能完成这项任务。
- en: Another useful attack at the PCB level is to read the flash chip on a PCB, which
    typically contains most of the software that runs in the device, revealing a treasure
    trove of information. Although some flash devices are read-only, most allow you
    to write critical changes back to them in a way that removes or limits security
    functions. The flash chip likely enforces read-only permissions via some access
    control mechanism, which may be susceptible to fault injection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PCB级别的另一个有用攻击是读取PCB上的闪存芯片，通常它包含设备中运行的大部分软件，揭示了一个宝贵的信息宝库。虽然一些闪存设备是只读的，但大多数允许你对其进行写入关键更改，从而移除或限制安全功能。闪存芯片可能通过某种访问控制机制强制执行只读权限，而这种机制可能容易受到故障注入攻击。
- en: For systems designed with security in mind, changes to flash should result in
    a non-bootable system because the flash image needs to include a valid digital
    signature. Sometimes the flash image is scrambled or encrypted; the former can
    be reversed (we’ve seen simple XORs), and the latter requires acquiring the key.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设计时考虑到安全性的系统，闪存的更改应该导致系统无法启动，因为闪存镜像需要包含有效的数字签名。有时，闪存镜像是被打乱或加密的；前者可以被逆向（我们曾看到过简单的异或运算），后者需要获取密钥。
- en: We’ll discuss PCB reverse engineering in more detail in Chapter 3, and we’ll
    discuss controlling the clock and power when we look at interfacing with real
    targets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章中更详细地讨论PCB逆向工程，并在讨论与真实目标接口时讨论时钟和电源的控制。
- en: Logical Attacks
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑攻击
- en: '*Logical attacks* work at the level of logical interfaces (for instance, by
    communicating through existing I/O ports). Unlike a PCB-level attack, a logical
    attack does not work at the physical level. A logical attack is aimed at the embedded
    device’s software or firmware and tries to breach the security without physical
    hacking. You could compare it to breaking into a house (device) by realizing that
    the owner (software) has a habit of leaving the back door (interface) unlocked;
    hence, no lockpicking is needed.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑攻击*是在逻辑接口层面上进行的（例如，通过现有的I/O端口进行通信）。与PCB级别的攻击不同，逻辑攻击不在物理层面上工作。逻辑攻击针对嵌入式设备的软件或固件，并试图在不进行物理入侵的情况下突破安全性。你可以把它比作通过发现设备的所有者（软件）习惯于将后门（接口）保持解锁而闯入房屋（设备），因此无需破解锁具。'
- en: Famous logical attacks revolve around memory corruption and code injection,
    but logical attacks have a much wider scope. For example, if the debugging console
    is still available on a hidden serial port of an electronic lock, sending the
    “unlock” command may trigger the lock to open. Or, if a device powers down some
    countermeasures in low-power conditions, injecting low-battery signals can disable
    those security measures. Logical attacks target design errors, configuration errors,
    implementation errors, or features that can be abused to break the security of
    a system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的逻辑攻击围绕着内存损坏和代码注入展开，但逻辑攻击的范围要广得多。例如，如果调试控制台仍然可用，并且连接在电子锁的隐藏串行端口上，发送“解锁”命令可能会触发锁定打开。或者，如果设备在低功耗状态下关闭一些对策，注入低电池信号可以禁用这些安全措施。逻辑攻击针对设计错误、配置错误、实现错误或可以被滥用的功能，从而突破系统的安全性。
- en: Debugging and Tracing
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试和追踪
- en: Among the most powerful control mechanisms built into a CPU during design and
    manufacture are the hardware debugging and tracing functions. This is often implemented
    on top of a *Joint Test Action Group (JTAG)*or *Serial Wire Debug (SWD)* interface.
    [Figure 1-7](#figure1-7) shows an exposed JTAG header.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU的设计和制造过程中，内置的最强大控制机制之一是硬件调试和追踪功能。这通常在*联合测试行动小组（JTAG）*或*串行线调试（SWD）*接口之上实现。[图1-7](#figure1-7)显示了一个暴露的JTAG头。
- en: Be aware that on secure devices, fuses, a PCB strap, or some proprietary secret
    code or challenge/response mechanism can turn off debugging and tracing. Perhaps
    only the JTAG header is removed on less-secure devices (more on JTAG in the following
    chapters).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在安全设备上，保险丝、PCB带或某些专有的秘密代码或挑战/响应机制可以关闭调试和追踪功能。可能只有在较不安全的设备上移除JTAG头（关于JTAG的更多内容将在后续章节中讨论）。
- en: '![f01007](image_fi/278748c01/f01007.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f01007](image_fi/278748c01/f01007.png)'
- en: 'Figure 1-7: PCB with exposed JTAG header. Normally, it’s not labeled as nicely
    as in this example!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：带有暴露JTAG头的PCB。通常，它不像这个例子中那样标签明确！
- en: Fuzzing Devices
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模糊测试设备
- en: '*Fuzzing* is a technique borrowed from software security that aims at identifying
    security problems in code specifically. Fuzzing’s typical goal is to find crashes
    to exploit for code injection. *Dumb fuzzing* amounts to sending random data to
    a target and observing its behavior. Robust and secure targets remain stable under
    such an attack, but less-robust or less-secure targets may show abnormal behavior
    or crash. Crash dumps or a debugger inspection can pinpoint the source of a crash
    and its exploitability. *Smart fuzzing* focuses on protocols, data structures,
    typical crash-causing values, or code structure and is more effective at generating
    *corner cases* (situations that should not normally be expected) that will crash
    a target. *Generation-based fuzzing* creates inputs from scratch, whereas *mutation-based
    fuzzing* takes existing inputs and modifies them. *Coverage-guided fuzzing* uses
    additional data (for instance, coverage information about which parts of the program
    are exercised with a particular input) to allow you to find deeper bugs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*是一种借鉴自软件安全领域的技术，旨在专门识别代码中的安全问题。模糊测试的典型目标是寻找崩溃点，以便利用漏洞进行代码注入。*愚蠢模糊测试*即向目标发送随机数据并观察其行为。健壮和安全的目标在这种攻击下通常会保持稳定，但不够健壮或不够安全的目标可能会表现出异常行为或崩溃。崩溃转储或调试器检查可以准确定位崩溃源和可利用性。*智能模糊测试*则专注于协议、数据结构、典型的崩溃引发值或代码结构，更有效地生成*边界情况*（通常不应发生的情况），这些情况可能会导致目标崩溃。*基于生成的模糊测试*从头开始创建输入，而*基于变异的模糊测试*则修改现有输入。*基于覆盖率的模糊测试*使用额外的数据（例如，关于特定输入执行时哪些程序部分被触及的覆盖信息）来帮助你发现更深层次的bug。'
- en: You also can apply fuzzing to devices, though under much more challenging circumstances
    as compared to fuzzing software. With device fuzzing, it is typically much harder
    to obtain coverage information about the software running on it, because you may
    have much less control over that software. Fuzzing over an external interface
    without further control over the device disallows obtaining coverage information,
    and in some cases, doing so makes establishing whether a corruption occurred difficult.
    Finally, fuzzing is effective when it can be done at high speed. In software fuzzing,
    this can be thousands to millions of cases per second. Achieving this performance
    is nontrivial on embedded devices. *Firmware re-hosting*is a technique that takes
    a device’s firmware and puts it in an emulation environment that can be run on
    PCs. It resolves most of the issues with on-device fuzzing, at the cost of having
    to create a working emulation environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将模糊测试应用于设备，尽管与对软件进行模糊测试相比，这会面临更加具有挑战性的情况。对于设备模糊测试，通常很难获取软件覆盖信息，因为你可能对运行在设备上的软件控制较少。通过外部接口进行模糊测试而没有进一步控制设备的能力，会导致无法获取覆盖信息，在某些情况下，这样做会使得确认是否发生了损坏变得困难。最后，模糊测试在能够以高速进行时最为有效。在软件模糊测试中，通常每秒可以进行成千上万甚至百万次测试。在嵌入式设备上实现这样的性能并非易事。*固件重托管*是一种技术，它将设备的固件放入可以在PC上运行的仿真环境中。这解决了设备内模糊测试中的大多数问题，代价是需要创建一个有效的仿真环境。
- en: Flash Image Analysis
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 闪存镜像分析
- en: Most devices include flash chips that are external to the main CPU. If a device
    is software-upgradeable, you can often find firmware images on the internet. Once
    you’ve obtained an image, you can use various flash image analysis tools, such
    as *binwalk*, to help identify the various parts of the image, including code
    sections, data sections, filesystem(s), and digital signatures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备包含与主CPU外部连接的闪存芯片。如果设备支持软件升级，通常可以在互联网上找到固件镜像。一旦你获得了镜像文件，就可以使用各种闪存镜像分析工具，如*binwalk*，帮助识别镜像中的各个部分，包括代码段、数据段、文件系统以及数字签名。
- en: 'Finally, disassembly and decompiling of the various software images is very
    important in determining possible vulnerabilities. There is also some initial
    interesting work regarding static analysis (such as concolic execution) of device
    firmware. See “BootStomp: On the Security of Bootloaders in Mobile Devices” by
    Nilo Redini et al.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，拆解和反编译各种软件镜像对于确定潜在的漏洞非常重要。关于设备固件的静态分析（如符号执行）也有一些初步的有趣工作。请参阅Nilo Redini等人撰写的《BootStomp:
    移动设备引导程序安全性研究》。'
- en: Noninvasive Attacks
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非侵入性攻击
- en: Noninvasive attacks don’t physically modify a chip. Side-channel attacks use
    some measurable behavior of a system to disclose secrets (for example, measuring
    a device’s power consumption to extract an AES key). A fault attack uses fault
    injection into the hardware to circumvent a security mechanism; for example, a
    large electromagnetic (EM) pulse can disable a password verification test so that
    it accepts any password. (Chapters 4 and 5 of this book are devoted to these topics.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 非侵入性攻击不会物理修改芯片。侧信道攻击利用系统某些可测量的行为来泄露秘密（例如，通过测量设备的功耗来提取 AES 密钥）。故障攻击通过故障注入进入硬件来绕过安全机制；例如，一个强大的电磁（EM）脉冲可以禁用密码验证测试，使其接受任何密码。（本书第
    4 章和第 5 章专门讨论这些主题。）
- en: Chip-Invasive Attacks
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 芯片侵入性攻击
- en: This class of attack targets the package or silicon inside a package and, therefore,
    operates at a miniature scale—that of the wires and gates. Doing this requires
    much more sophisticated, advanced, and expensive techniques and equipment than
    we’ve discussed so far. Such attacks are beyond the scope of this book, but here’s
    a brief look at what advanced attackers can do.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类攻击以封装或封装内的硅为目标，因此操作的尺度非常微小——即电线和门级。进行这些操作需要比我们目前讨论的更加复杂、先进且昂贵的技术和设备。这些攻击超出了本书的范围，但我们可以简要了解高级攻击者可以做些什么。
- en: Decapsulation, Depackaging, and Rebonding
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 去封装、去包装和重新连接
- en: '*Decapsulation* is the process of removing some of the IC packaging material
    using chemical warfare, usually by dripping fuming nitric or sulfuric acid onto
    the chip package until it dissolves. The result is a hole in the package through
    which you can examine the microchip itself, and if you do it properly, the chip
    still works.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*去封装*是通过化学战手段去除一些集成电路（IC）封装材料的过程，通常是将烟雾状的硝酸或硫酸滴在芯片封装上，直到其溶解。结果是封装上留下一个孔，可以通过这个孔检查微芯片本身，如果操作得当，芯片仍然可以正常工作。'
- en: When *depackaging*, you dunk the whole package in acid, after which the entire
    chip is laid bare. You need to rebond the chip to restore its functionality, which
    means reattaching the tiny wires that normally connect the chip to the pins of
    a package (see [Figure 1-8](#figure1-8)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在*去封装*过程中，你将整个封装浸入酸中，之后芯片的整个内部被暴露出来。你需要重新连接芯片，以恢复其功能，这意味着需要重新连接通常将芯片与封装引脚连接的小金属线（见[图1-8](#figure1-8)）。
- en: '![f01008](image_fi/278748c01/f01008.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![f01008](image_fi/278748c01/f01008.png)'
- en: 'Figure 1-8: A decapped chip that shows exposed bonding wires (Travis Goodspeed,
    CC BY 2.0 license)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：去封装的芯片，显示了暴露的连接线（Travis Goodspeed，CC BY 2.0 许可）
- en: Even though they may die in the process, dead chips are fine for imaging and
    optical reverse engineering. However, for most attacks, chips must be alive.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管芯片在过程中可能会损坏，但已损坏的芯片对于成像和光学逆向工程是可以使用的。然而，对于大多数攻击，芯片必须是活的。
- en: Microscopic Imaging and Reverse Engineering
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 微观成像与逆向工程
- en: Once the chip is exposed, the first step is to identify the larger functional
    blocks of the chip and, specifically, find the blocks of interest. [Figure 1-2](#figure1-2)
    shows some of these structures. The largest blocks on the die will be memory,
    like static RAM (SRAM) for CPU caches or tightly coupled memory, and ROM for boot
    code. Any long, mostly straight bunches of lines are buses interconnecting CPUs
    and peripherals. Simply knowing the relative sizes and what the various structures
    look like allows you to begin reverse engineering chips.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦芯片暴露出来，第一步是识别芯片的较大功能模块，特别是找到感兴趣的模块。[图1-2](#figure1-2)展示了其中的一些结构。芯片上的最大模块通常是内存，比如用于
    CPU 缓存或紧耦合内存的静态 RAM（SRAM），以及用于启动代码的 ROM。任何长而几乎直的线条都是连接 CPU 和外设的总线。仅仅了解相对尺寸以及各种结构的外观，就能开始逆向工程芯片。
- en: When a chip is decapped, as in [Figure 1-8](#figure1-8), you can see only the
    top metal layer. To reverse engineer the entire chip, you also need to *delayer*
    it, which means polishing off the chip’s individual metal layers to expose the
    one below it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当芯片去封装时，如[图1-8](#figure1-8)所示，你只能看到顶层金属层。要逆向工程整个芯片，你还需要*剥层*，即通过打磨掉芯片的金属层以暴露其下层。
- en: '[Figure 1-9](#figure1-9) shows a cross section of a *complementary metal oxide
    semiconductor (CMOS)* chip, which is how most modern chips are built. As you can
    see, a number of layers and vias of copper metals eventually connect the transistors
    (polysilicon/substrate). The lowest-level metal is used for creating *standard
    cells*, which are the elements that create logical gates (AND, XOR, and so on)
    from a number of transistors. Top-level metals are usually used for power and
    clock routing.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-9](#figure1-9) 显示了一个*互补金属氧化物半导体（CMOS）*芯片的横截面，这是大多数现代芯片的构建方式。如你所见，一些层和铜金属的通孔最终连接了晶体管（多晶硅/基板）。最底层的金属用于创建*标准单元*，这些单元是通过多个晶体管创建逻辑门（与、异或等）的元素。顶层金属通常用于电源和时钟布线。'
- en: '![f01009](image_fi/278748c01/f01009.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![f01009](image_fi/278748c01/f01009.png)'
- en: 'Figure 1-9: Cross section of CMOS'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9：CMOS 的横截面
- en: '[Figure 1-10](#figure1-10) shows photographs of the different layers inside
    a typical chip.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-10](#figure1-10) 显示了典型芯片内部不同层的照片。'
- en: '![f01010](image_fi/278748c01/f01010.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![f01010](image_fi/278748c01/f01010.png)'
- en: 'Figure 1-10: Different layers inside a CMOS chip (image courtesy of Christopher
    Tarnovsky, [semiconductor.guru@gmail.com](http://mailto:semiconductor.guru@gmail.com))'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10：CMOS 芯片内部的不同层（图片由 Christopher Tarnovsky 提供，邮箱：[semiconductor.guru@gmail.com](http://mailto:semiconductor.guru@gmail.com)）
- en: 'Good chip imaging allows you to rebuild a netlist from the images or a binary
    dump of the boot ROM. A *netlist* is essentially a description of how all gates
    are connected, which encompasses all the digital logic in a design. Both a netlist
    and a boot ROM dump allow attackers to find weaknesses in the code or chip design.
    Chris Gerlinsky’s “Bits from the Matrix: Optical ROM Extraction” and Olivier Thomas’s
    “Integrated Circuit Offensive Security,” presented at the Hardwear.io 2019 conference,
    provide good introductions to the topic.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的芯片成像可以让你从图像或启动 ROM 的二进制转储中重建网表。*网表*本质上是对所有逻辑门连接方式的描述，涵盖了设计中的所有数字逻辑。网表和启动
    ROM 转储都可以帮助攻击者找到代码或芯片设计中的弱点。Chris Gerlinsky 的《来自矩阵的比特：光学 ROM 提取》和 Olivier Thomas
    的《集成电路攻防安全》，分别在 Hardwear.io 2019 大会上展示，提供了该主题的良好介绍。
- en: Scanning Electron Microscope Imaging
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扫描电子显微镜成像
- en: A *scanning electron microscope (SEM)* performs a raster scan of a target using
    an electron beam and takes measurements from an electron detector to form an image
    of the scanned target with a resolution of better than 1 nm, allowing you to image
    individual transistors and wires. As with microscope imaging, you can create netlists
    from the images.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*扫描电子显微镜（SEM）*使用电子束对目标进行光栅扫描，并通过电子探测器测量扫描目标的图像，分辨率优于 1 纳米，允许你成像单个晶体管和电线。与显微镜成像一样，你可以从图像中创建网表。'
- en: Optical Fault Injection and Optical Emission Analysis
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 光学故障注入与光学发射分析
- en: 'Once a chip surface is visible, it’s possible to have “phun with photons.”
    Due to an effect called *hot carrier luminescence*, switching transistors occasionally
    emit photons. With an IR-sensitive *charge-coupled device (CCD)* sensor like those
    used in hobbyist astronomy, or an *avalanche photodiode (APD)* if you want to
    get fancy, you can detect active photon areas, which contributes to the reverse
    engineering process (or more specifically to side-channel analysis), as in correlating
    secret keys with photon measurements. See “Simple Photonic Emission Analysis of
    AES: Photonic Side Channel Analysis for the Rest of Us” by Alexander Schlösser
    et al.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦芯片表面可见，就可以“与光子玩乐”。由于一种叫做*热载流子发光*的效应，开关晶体管偶尔会发射光子。使用像业余天文爱好者常用的红外敏感*电荷耦合器件（CCD）*传感器，或者如果你想要更先进的设备，可以使用*雪崩光电二极管（APD）*，你可以检测到活跃的光子区域，这有助于反向工程过程（更具体地说是侧信道分析），例如将秘密密钥与光子测量相关联。见
    Alexander Schlösser 等人的《AES 的简单光子发射分析：为我们普通人提供的光子侧信道分析》。
- en: In addition to using photons to observe processes, you can also use them to
    inject faults by changing the gates’ conductivity, which is called *optical fault
    injection* (see Chapter 5 and Appendix A for more details).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用光子观察过程外，你还可以通过改变门的导电性来注入故障，这被称为*光学故障注入*（有关更多细节，请参见第 5 章和附录 A）。
- en: Focused Ion Beam Editing and Microprobing
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集中离子束编辑与微探针
- en: A *focused ion beam (FIB)* , pronounced “fib,” uses a beam of ions either to
    mill away parts of a chip or deposit material onto a chip at a nanometer scale,
    allowing attackers to cut chip wires, re-route chip wires, or create probe pads
    for microprobing. FIB edits take time and skill (and an expensive FIB), but as
    you can imagine, such edits can circumvent many hardware security mechanisms if
    an attacker is able to locate them. The numbers in [Figure 1-11](#figure1-11)
    show holes a FIB created in order to access lower metal layers. The “hat” structures
    around the holes are created to bypass an active shield countermeasure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚焦离子束（FIB）*，发音为“fib”，使用离子束在纳米级别上切削芯片部分或向芯片上沉积材料，使攻击者能够切断芯片线路、重定向芯片线路，或为微探测创建探针垫。FIB编辑需要时间和技术（以及昂贵的FIB设备），但正如你所想象的那样，若攻击者能够定位它们，这种编辑能够绕过许多硬件安全机制。图[Figure
    1-11](#figure1-11)中的数字展示了FIB为了访问下层金属层而创建的孔。这些孔周围的“帽子”结构是为了绕过主动屏蔽对策而创建的。'
- en: '*Microprobing* is a technique used to measure or inject current into a chip
    wire, which may not require a FIB probe pad for larger feature sizes. Skill is
    a prerequisite for performing any of these attacks, although once an attacker
    has the resources to perform attacks at this level, it is extraordinarily difficult
    to maintain security.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*微探测*是一种用来测量或向芯片线路注入电流的技术，对于较大特征尺寸的芯片，可能不需要FIB探针垫。执行这些攻击的技能是必要的，虽然一旦攻击者具备了进行此类攻击的资源，在这个层次上保持安全是异常困难的。'
- en: '![f01011](image_fi/278748c01/f01011.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![f01011](image_fi/278748c01/f01011.png)'
- en: 'Figure 1-11: A number of FIB edits to facilitate microprobing (image courtesy
    of Christopher Tarnovsky, [semiconductor.guru@gmail.com](http://mailto:semiconductor.guru@gmail.com))'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-11：多个FIB编辑以促进微探测（图片由Christopher Tarnovsky提供， [semiconductor.guru@gmail.com](http://mailto:semiconductor.guru@gmail.com)）
- en: We’ve covered a number of different attacks relative to embedded systems here.
    Remember that any single attack is enough to compromise a system. The cost and
    skills vary drastically, however, so be sure to understand what sort of security
    objective you require. Resisting an attack from someone with a million-dollar
    budget and resisting an attack from someone with $25 and a copy of this book are
    very different endeavors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这里讨论了多种与嵌入式系统相关的攻击。请记住，任何单一攻击都足以危及系统。然而，攻击的成本和技能差异非常大，因此一定要明白你所需要的安全目标是什么。抵抗一个拥有百万美元预算的攻击者和抵抗一个拥有25美元及这本书副本的攻击者，是完全不同的挑战。
- en: Assets and Security Objectives
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产与安全目标
- en: The question to ask when considering the assets being designed into the product
    is, “What assets do I really care about?” An attacker will ask the same question.
    The assets’ defender might arrive at a wide range of answers to this seemingly
    simple question. The CEO of a company may focus on brand image and financial health.
    The chief privacy officer cares about the confidentiality of consumers’ private
    information, and the cryptographer in residence is paranoid about secret key material.
    All of those responses to the question are interrelated. If keys are exposed,
    customer privacy may be impacted, which in turn negatively impacts brand image
    and consequently threatens the financial health of the entire company. However,
    at each level, the protection mechanisms differ.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑设计进产品中的资产时，应该问自己：“我真正关心的资产是什么？”攻击者也会问同样的问题。资产的防守者可能会对这个看似简单的问题给出一系列不同的回答。公司的CEO可能会关注品牌形象和财务健康。首席隐私官关注消费者私密信息的机密性，而常驻的密码学家则对秘密密钥材料感到极度敏感。所有这些回答都是相互关联的。如果密钥被暴露，客户隐私可能会受到影响，进而影响品牌形象，最终威胁到整个公司的财务健康。然而，在每个层次上，保护机制是不同的。
- en: An asset also represents a value to an attacker. What exactly is valuable depends
    on the attacker’s motivation. It might be a vulnerability that allows the attacker
    to sell a code execution exploit to other attackers. The desired asset could be
    credit-card details or victims’ payment keys. Corporate-world intentions might
    be to target a competitor’s brand maliciously.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个资产也代表了攻击者的价值。到底什么是有价值的，取决于攻击者的动机。它可能是一个漏洞，使得攻击者可以将代码执行漏洞卖给其他攻击者。所需的资产可能是信用卡信息或受害者的支付密钥。企业世界中的动机可能是恶意地针对竞争对手的品牌。
- en: When threat modeling, analyze both attacker and defender perspectives. For the
    purposes of this book, we limit ourselves to technical assets on a device, so
    we assume that our assets are represented as some sequence of bits on a target
    device that are to remain confidential and integrity-protected. *Confidentiality*
    is the property of keeping an asset hidden from attackers, and *integrity* is
    the property of not allowing an attacker to modify it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行威胁建模时，需要分析攻击者和防御者的角度。就本书而言，我们仅限于分析设备上的技术资产，因此我们假设我们的资产是表示为目标设备上某个比特序列的内容，这些内容需要保持保密并保护完整性。*保密性*是指保持资产对攻击者隐藏的特性，而*完整性*是指不允许攻击者修改资产的特性。
- en: As a security enthusiast, you may be wondering why we didn’t mention availability.
    *Availability* is the property of maintaining a responsive and functional system,
    and it’s particularly important for data centers and systems that deal with safety,
    such as industrial control systems and autonomous vehicles, where interruption
    in system functionality can’t happen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个安全爱好者，你可能会好奇为什么我们没有提到可用性。*可用性*是指保持系统响应和功能性的特性，这对于数据中心和处理安全的系统（如工业控制系统和自动驾驶汽车）尤其重要，因为在这些系统中，功能中断是不能发生的。
- en: 'It makes sense to defend asset availability only in situations when a device
    cannot be physically accessed, such as when access is via the network and internet.
    Making such services unavailable is the purpose of denial-of-service attacks that
    take down websites. For embedded devices, compromising availability is trivial:
    just switch it off, hit it with a hammer, or blow it up.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在设备无法被物理访问的情况下（例如通过网络和互联网进行访问），防御资产可用性才有意义。使这类服务不可用是拒绝服务攻击的目的，旨在使网站瘫痪。对于嵌入式设备来说，妥协可用性是微不足道的：只需将其关闭，敲击它，或把它炸掉。
- en: A *security objective* is how well you want to protect the assets you define,
    against what types of attacks and attackers, and for how long. Defining security
    objectives helps focus the design arguments on the strategies to counter the expected
    threats. Inevitably trade-offs will occur due to many possible scenarios, and
    although we realize there are no one-size-fits-all solutions, we give some common
    examples next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全目标*是指你希望如何保护所定义的资产，防范哪些类型的攻击和攻击者，以及保护多久。定义安全目标有助于将设计重点集中在应对预期威胁的策略上。由于许多可能的情景，必然会发生权衡，尽管我们意识到没有一刀切的解决方案，但接下来我们将给出一些常见的示例。'
- en: Though not very common, specification of a device’s strengths and weaknesses
    is a sure sign of security maturity of a vendor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不太常见，但设备强项和弱点的规格说明是供应商安全成熟度的明显标志。
- en: Confidentiality and Integrity of Binary Code
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制代码的保密性和完整性
- en: Typically, for binary code, the main objective is integrity protection or making
    sure the code that runs on the device is the code the author intended. Integrity
    protection restricts code modification but presents a double-edged sword. Strong
    integrity protection can lock down a device from its owner, limiting the code
    available to run on it. A whole community of hackers tries to circumvent these
    mechanisms on gaming consoles in order to run their own code. On the other hand,
    integrity protection certainly has the unintended benefit of protecting against
    malware infecting the boot chain, game piracy, or governments installing a backdoor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于二进制代码，主要目标是保护完整性，确保设备上运行的代码就是作者意图的代码。完整性保护限制了代码的修改，但也带来了双刃剑的效果。强大的完整性保护可能会将设备锁定，使其所有者无法使用，限制可运行的代码。一整个黑客社区试图绕过这些机制，在游戏机上运行他们自己的代码。另一方面，完整性保护确实有意外的好处，可以防止恶意软件感染引导链、游戏盗版或政府安装后门。
- en: The goal for confidentiality as a security objective is to make it more difficult
    to copy intellectual property, such as digital content, or to find vulnerabilities
    in firmware. The latter also makes it harder for bona fide security researchers
    to find and report vulnerabilities, as well as for attackers to exploit those
    vulnerabilities. (See the “Disclosing Security Issues” section on page 33 for
    more on this complex dilemma.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性作为一种安全目标的目的是使复制知识产权（例如数字内容）或寻找固件中的漏洞变得更加困难。后者还使得真正的安全研究人员更难发现和报告漏洞，同时也使攻击者更难利用这些漏洞。（有关这一复杂困境的更多内容，请参见第33页的“披露安全问题”部分。）
- en: Confidentiality and Integrity of Keys
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥的保密性和完整性
- en: 'Cryptography turns data protection problems into key protection problems. In
    practice, keys are typically easier to protect than full data blobs. For threat
    modeling, note that there are now two assets: the plaintext data and the key itself.
    Confidentiality of keys as an objective, therefore, usually links to confidentiality
    of the data that is being protected.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学将数据保护问题转化为密钥保护问题。实际上，密钥通常比完整的数据块更容易保护。在威胁建模中，需要注意的是，现在有两个资产：明文数据和密钥本身。因此，将密钥的机密性作为目标，通常与所保护数据的机密性密切相关。
- en: 'For example, integrity is important when public keys are stored on a device
    for authenticity checks: if attackers can substitute the original public keys
    with their own, they can sign arbitrary data that passes signature verification
    on the device. However, integrity is not always an objective for keys; for instance,
    if the purpose of a key is to decrypt a stored data blob, modifying the key simply
    results in the inability to perform the decryption.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当公钥存储在设备上进行身份验证检查时，完整性非常重要：如果攻击者能够将原始公钥替换为自己的密钥，他们就可以签署任何数据，使其通过设备上的签名验证。然而，完整性并非总是密钥的目标；例如，如果密钥的目的是解密存储的数据块，那么修改密钥只会导致无法执行解密操作。
- en: Another interesting aspect is how keys are securely injected into a device or
    generated at the manufacturing stage. An option is to encrypt or sign the keys
    themselves, but that involves yet another key. It’s turtles all the way down.
    Somewhere in the system exists a *root of trust*, a key or mechanism that we simply
    have to trust.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的方面是如何将密钥安全地注入设备或在制造阶段生成密钥。一个选项是加密或签名密钥本身，但这又涉及到另一个密钥。这就像是“乌龟背上的乌龟”，一直往下延伸。在系统的某个地方存在一个*信任根*，一个我们必须信任的密钥或机制。
- en: A typical solution is to trust the manufacturing process during initial key
    generation or during key injection. For instance, *Trusted Platform Module (TPM)*
    specification v2.0 calls for an *endorsement primary seed (EPS)*. This EPS is
    a unique identifier for each TPM, and it is used to derive some primary key material.
    As per the specification, this EPS must be injected into the TPM or created on
    the TPM during manufacturing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一种典型的解决方案是在初始密钥生成或密钥注入过程中信任制造过程。例如，*受信任平台模块（TPM）*规范v2.0要求一个*背书主种子（EPS）*。这个EPS是每个TPM的唯一标识符，用于推导一些主密钥材料。根据规范，这个EPS必须在制造过程中注入TPM或在TPM上创建。
- en: This practice does limit exposure of key material, but it creates a critical
    central collection point for key material at the manufacturing facility. Key injection
    systems especially must be well protected to avoid compromising the injected keys
    for *all* parts being configured by this system. Best practices involve key generation
    on-device, such that the manufacturing facility doesn’t have access to all keys,
    as well as secret splitting, making sure that different stages in manufacturing
    inject or generate different parts of the key material.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法确实限制了密钥材料的暴露，但它在制造设施中为密钥材料创建了一个关键的集中收集点。尤其是密钥注入系统必须得到良好的保护，以避免泄露此系统配置的*所有*部件的密钥。最佳做法是进行设备上的密钥生成，这样制造设施就不会访问所有密钥，同时采用秘密分割，确保制造过程中不同阶段注入或生成不同部分的密钥材料。
- en: Remote Boot Attestation
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程启动验证
- en: '*Boot attestation* is the ability to verify cryptographically that a system
    did in fact boot from authentic firmware images. *Remote boot attestation*is the
    ability to do so remotely. Two parties are involved in attestation: the *prover*
    intends to prove to the *verifier* that some *measurements* of the system have
    not been tampered with. For instance, you can use remote boot attestation to allow
    or deny a device access to an enterprise network or to decide to provide an online
    service to a device. In the latter case, the device is the prover, the online
    service is the verifier, and the measurements are hashes of configuration data
    and (firmware) images used during boot. To prove the measurements are not tampered
    with, they are digitally signed using a private key during the boot stages. The
    verifier can check the signatures against an allow or block list and should have
    a means of verifying the private key used for creating the signatures. The verifier
    detects tampering and ensures that the remote device is not running old and perhaps
    vulnerable boot images.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*启动认证*是通过加密方式验证系统是否确实从真实的固件映像启动的能力。*远程启动认证*是指能够远程进行此验证的能力。认证涉及两方：*证明者*旨在向*验证者*证明系统的某些*度量*未被篡改。例如，您可以使用远程启动认证来允许或拒绝设备访问企业网络，或决定是否为设备提供在线服务。在后一种情况下，设备是证明者，在线服务是验证者，而度量则是启动过程中使用的配置数据和（固件）映像的哈希值。为了证明这些度量未被篡改，它们会在启动阶段使用私钥进行数字签名。验证者可以将签名与允许或阻止列表进行比对，并应具备验证用于创建签名的私钥的方法。验证者能够检测篡改行为，并确保远程设备没有运行过时且可能存在漏洞的启动映像。'
- en: As always, this presents a few practical issues. First, the verifier must somehow
    be able to trust the prover’s signing key—for instance, by trusting a certificate
    containing the prover’s public key, which is signed by some trustworthy authority.
    In the best case, this authority has been able to establish trust during the manufacturing
    process, as described previously. Second, the more comprehensive the coverage
    of the boot images and data, the more there will be different configurations in
    the field. This means that it becomes infeasible to allow all *known-good* configurations,
    so one has to revert to blocking *known-bad* configurations. However, determining
    a *known-bad* configuration is not a trivial exercise and can usually be done
    only after a modification has been detected and analyzed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这会带来一些实际问题。首先，验证者必须能够以某种方式信任证明者的签名密钥——例如，通过信任一个包含证明者公钥的证书，该证书由某个可信的权威机构签署。在最理想的情况下，这个权威机构已经能够在制造过程中建立起信任，如前文所述。第二，启动映像和数据的覆盖范围越广，现场的配置就会越多。这意味着允许所有*已知良好*配置变得不可行，因此必须转而阻止*已知不良*配置。然而，确定*已知不良*配置并非易事，通常只有在检测到修改并进行分析之后才能完成。
- en: Note that boot attestation guards the boot-time components that are hashed for
    authenticity. It does not guard against runtime attacks, such as code injection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，启动认证仅保护被哈希以验证真实性的启动时组件。它并不防范运行时攻击，如代码注入。
- en: Confidentiality and Integrity of Personally Identifiable Information
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 个人身份信息的机密性与完整性
- en: '*Personally identifiable information (PII)* is data that can identify an individual.
    The obvious data includes names, cell phone numbers, addresses, and credit card
    numbers, but the less obvious data could be accelerometer data recorded in a wearable
    device. PII confidentiality becomes an issue when applications installed on a
    device exfiltrate this information. For example, accelerometer data that characterizes
    a person’s walking gait can be used to identify that person: see “Gait Identification
    Using Accelerometer on Mobile Phone” by Hoang Minh Thang et al. Mobile phone power
    consumption data can pinpoint a person’s location from the way the radio in the
    phone consumes power, depending on the distance to cell towers, as described in
    “PowerSpy: Location Tracking Using Mobile Device Power Analysis” by Yan Michalevsky
    et al.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人身份信息（PII）*是能够识别个体的数据。显而易见的数据包括姓名、手机号码、地址和信用卡号码，但不太显而易见的数据可能是可穿戴设备中记录的加速度计数据。当安装在设备上的应用程序外泄这些信息时，PII的机密性就成为问题。例如，描述一个人步态的加速度计数据可以用来识别此人：请参见Hoang
    Minh Thang等人撰写的《使用手机加速度计进行步态识别》。手机电池消耗数据可以根据手机与基站的距离，通过分析手机的电池消耗模式来定位某人的位置，具体请参见Yan
    Michalevsky等人撰写的《PowerSpy：基于移动设备功耗分析的定位追踪》。'
- en: The medical field has regulation around PII as well. The *Health Insurance Portability
    and Accountability Act (HIPAA)* of 1996 is a law in the United States with a strong
    focus on privacy for medical information and applies to any system processing
    patient PII. HIPAA has rather nonspecific requirements for technical security.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 医疗领域对 PII 也有相关法规。1996 年的《健康保险可携带性与责任法案 (HIPAA)》是美国的一部法律，重点关注医疗信息的隐私保护，并适用于处理患者
    PII 的任何系统。HIPAA 对技术安全有相对不具体的要求。
- en: Integrity of PII data is essential to avoid impersonation. In banking smart
    cards, the key material is tied to an account and, therefore, to an identity.
    EMVCo, a credit-card consortium, has very explicit technical requirements in contrast
    to HIPAA. For instance, key material must be protected against logical, side-channel,
    and fault attacks, and this protection needs to be proven by actual attacks performed
    by an accredited lab.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PII 数据的完整性至关重要，以避免冒充。在银行智能卡中，密钥材料与账户关联，因此也与身份关联。EMVCo（一个信用卡联盟）有非常明确的技术要求，与 HIPAA
    不同。例如，密钥材料必须能够防御逻辑攻击、旁道攻击和故障攻击，并且这种保护需要通过经认证实验室进行实际攻击来证明。
- en: Sensor Data Integrity and Confidentiality
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传感器数据的完整性和保密性
- en: You have just learned how sensor data is related to PII. Integrity has to be
    important, because the device needs to sense and record its environment accurately.
    This is even more crucial when the system is using sensor input to control actuators.
    A great (though disputed) example is that of a US RQ-170 drone being forced to
    land in Iran, allegedly after its GPS signal was spoofed to make it believe it
    was landing at a US base in Afghanistan.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了传感器数据如何与 PII 相关。完整性必须很重要，因为设备需要准确地感知和记录其环境。当系统使用传感器输入控制执行器时，这一点尤为重要。一个很好的（尽管存在争议的）例子是，美国
    RQ-170 无人机被迫在伊朗着陆，据信是因为其 GPS 信号被伪造，使其误以为自己正在阿富汗的美国基地着陆。
- en: When a device is using some form of artificial intelligence for decision making,
    the integrity of the decisions is challenged by a field of research called *adversarial
    machine learning*. One example is exploiting weaknesses in neural net classifiers
    by artificially modifying pictures of a stop sign. To humans, the modification
    is not detectable, but the picture can be completely unrecognizable using standard
    image recognition algorithms when it should in fact have been recognizable. Although
    the recognition of the neural net may be foiled, modern self-driving cars have
    a database of the locations of signs that they can fall back to, so in this particular
    instance, it shouldn’t be a safety issue. “Practical Black-Box Attacks Against
    Machine Learning” by Nicolas Papernot et al. has more details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备使用某种形式的人工智能进行决策时，决策的完整性会受到名为 *对抗机器学习* 的研究领域的挑战。一个例子是通过人为修改停车标志的图片来利用神经网络分类器的弱点。对人类来说，这种修改是不可察觉的，但当使用标准的图像识别算法时，这张图片可能会变得完全无法识别，而事实上它应该是可以识别的。虽然神经网络的识别可能会受到阻碍，但现代的自动驾驶汽车有一个包含标志位置的数据库，它们可以回退使用，因此在这种特定情况下，这不应该构成安全问题。Nicolas
    Papernot 等人在《实用的黑箱攻击：对机器学习的攻击》一文中提供了更多细节。
- en: Content Confidentiality Protection
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容保密保护
- en: Content protection boils down to trying to make sure people pay for the media
    content they consume and that they stay within some license restrictions, such
    as date and geographic location, using *digital rights/restrictions management
    (DRM)*. DRM mostly depends on encryption of the data stream for transport of content
    in/out of a device and on access control logic inside a device to deny software
    access to plaintext content. For mobile devices, most of the protection requirements
    are aimed at software-only attacks, but for set-top boxes, protection requirements
    include side-channel and fault attacks. Thus, set-top boxes are considered harder
    to break and are used for higher-value content.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内容保护归结为确保人们为其消费的媒体内容付费，并且他们遵守一些许可限制，如日期和地理位置，使用 *数字版权/限制管理（DRM）*。DRM 主要依赖于加密数据流，以便在设备之间传输内容，并且依赖于设备内部的访问控制逻辑来拒绝软件访问明文内容。对于移动设备，大多数保护要求集中在软件攻击上，而对于机顶盒，保护要求则包括旁道攻击和故障攻击。因此，机顶盒被认为更难攻破，并且用于更高价值的内容。
- en: Safety and Resilience
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性和韧性
- en: '*Safety* is the property of not causing harm (to people, for example), and
    *resilience* is the ability to remain operational in case of (non-malicious) failures.
    For instance, a microcontroller in a satellite will be subject to intensive radiation
    that causes so-called *single event upsets (SEUs)*. SEUs flip bits in the state
    of the chip, which could lead to errors in its decision making. The resilient
    solution is to detect this and correct the error or detect and reset to a known-good
    state. Such resilience may not necessarily be secure; it gives someone attempting
    fault injection unlimited tries as the system keeps accepting abuse.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全性* 是指不对他人（例如人类）造成伤害的特性，而 *韧性* 是指在发生（非恶意）故障时保持运行的能力。例如，卫星中的微控制器将会受到强烈辐射的影响，这种辐射会导致所谓的
    *单粒子翻转（SEU）*。SEU 会翻转芯片状态中的比特，可能导致其决策出现错误。韧性解决方案是检测这种错误并进行修正，或者检测并重置到已知的良好状态。这种韧性不一定是安全的；它给了试图进行故障注入的攻击者无限的尝试机会，因为系统会持续接受滥用。'
- en: Similarly, it isn’t safe to shut down an autonomous vehicle’s control unit at
    highway speeds as soon as a sensor indicates malicious activity. First, any detector
    can generate false positives, and, second, this potentially allows an attacker
    to use the sensor to harm all passengers. As with all objectives, this one presents
    the product’s developer with trade-offs between security and safety/resilience.
    Resilience and safety are not the same as security; sometimes they are at odds
    with security. For an attacker, this means opportunities exist to break a device
    because of good intentions to make it safe or resilient.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在传感器检测到恶意活动时，立即关闭自动驾驶车辆的控制单元并不安全，尤其是在高速公路行驶时。首先，任何检测器都可能产生误报；其次，这样做可能允许攻击者利用传感器危害所有乘客。与所有目标一样，这个问题使产品开发者面临安全与安全性/韧性之间的权衡。韧性和安全性不同于安全性，有时它们与安全性相冲突。对攻击者来说，这意味着由于出于保护安全或增强韧性的良好意图，可能会给他们提供机会去破坏设备。
- en: Countermeasures
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对策
- en: 'We define *countermeasures* as any (technical) means to reduce the probability
    of success or impact of an attack. Countermeasures have three functions: protect,
    detect, and respond. (We discuss some of these countermeasures further in Chapter
    14.)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *对策* 定义为任何（技术性的）手段，旨在减少攻击成功或影响的概率。对策有三个功能：保护、检测和响应。（我们将在第十四章进一步讨论一些对策。）
- en: Protect
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护
- en: This category of countermeasures attempts to avoid or mitigate attacks. An example
    is encrypting the contents of flash memory against prying eyes. If the key is
    hidden well, it provides almost unbreakable protection. Other protection measures
    offer only partial protection. If a single CPU instruction corruption can cause
    an exploitable fault, randomizing the critical instruction’s timing over five
    clock cycles still gives an attacker a 20 percent probability of hitting it. Bypassing
    some protection measures completely is possible because they protect only against
    a specific class of attacks (for instance, a side-channel countermeasure does
    not protect against code injection).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类对策旨在避免或减轻攻击。一个例子是加密闪存的内容，防止窥探。如果密钥隐藏得很好，它能提供几乎无法破解的保护。其他保护措施则提供部分保护。如果单条
    CPU 指令的损坏会导致可利用的故障，通过随机化关键指令的时序（跨越五个时钟周期），攻击者仍有 20% 的概率能击中它。某些保护措施可能会被完全绕过，因为它们仅对特定类型的攻击提供保护（例如，侧信道对策并不防止代码注入）。
- en: Detect
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测
- en: This category of countermeasure requires either some kind of hardware detection
    circuitry or detection logic in software. For instance, you can monitor a chip’s
    power supply for voltage peaks or dips that are indicative of a voltage fault
    attack. You can also use software to detect anomalous states. For example, systems
    that constantly analyze network traffic or application logs can detect attacks.
    Other common anomaly detection techniques are the verification of so-called stack
    canaries, detecting guard pages that have been accessed, finding switch statements
    with no matching case, and cyclic redundancy check (CRC) errors on internal variables,
    among many others.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类对策需要硬件检测电路或软件中的检测逻辑。例如，你可以监测芯片的电源供应，观察电压峰值或下降，这些可能表明发生了电压故障攻击。你也可以使用软件来检测异常状态。例如，持续分析网络流量或应用日志的系统可以检测攻击。其他常见的异常检测技术包括验证所谓的堆栈金丝雀、检测已被访问的保护页、查找没有匹配的
    case 的 switch 语句，以及检测内部变量的循环冗余校验（CRC）错误，等等。
- en: Respond
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应
- en: Detection has little purpose without a response. The type of response depends
    on the device’s use case. For highly secure devices, like payment smart cards,
    wiping all device secrets (effectively self-inflicting a denial-of-service attack)
    would be wise when detecting an attack. Doing this would not be a good idea in
    safety-critical systems that must continue to operate. In those cases, phoning
    home or falling back to a crippled-but-safe mode are more appropriate responses.
    Another undervalued but effective response for human attackers is to bore the
    will to live out of them (for instance, by resetting a device and increasingly
    lengthening the boot time).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 检测没有响应是没有太大意义的。响应的类型取决于设备的使用场景。对于像支付智能卡这样的高安全性设备，检测到攻击时擦除所有设备的机密信息（实际上是自我施加拒绝服务攻击）是明智的做法。而在必须继续运行的安全关键系统中，这种做法就不太适合。在这些情况下，回拨电话或回退到受限但安全的模式是更合适的响应。对于人为攻击者，另一个被低估但有效的响应是让他们失去生存意志（例如，通过重置设备并逐渐延长启动时间）。
- en: Countermeasures are critical to building a secure system. Especially in hardware,
    where physical attacks may be impossible to protect against fully, adding detection
    and response often raises the bar beyond what an attacker is willing to do or
    is even capable of doing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 防御措施对于构建安全系统至关重要，特别是在硬件方面，物理攻击可能完全无法防护时，增加检测与响应通常能够提升难度，超过攻击者愿意付出的代价，甚至超出他们能够做到的范围。
- en: An Attack Tree Example
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个攻击树示例
- en: Now that we’ve described the four ingredients needed for effective threat modeling,
    let’s start with an example where we, as attackers, want to hack our way into
    an IoT toothbrush with the purpose of extracting confidential information and
    (just for fun) increasing the brushing speed to something that 9 out of 10 dentists
    would disapprove of (but that last one loves a good challenge).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了有效威胁建模所需的四个要素，让我们从一个例子开始，在这个例子中，我们作为攻击者，希望通过破解物联网牙刷来提取机密信息，并（仅仅为了好玩）将刷牙速度提高到9位牙医中10位都不赞成的程度（但最后一位牙医却乐于接受这种挑战）。
- en: 'In our sample attack tree, shown in [Figure 1-12](#figure1-12), we have the
    following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例攻击树中，如[图1-12](#figure1-12)所示，包含以下内容：
- en: Rounded boxes indicate the states an attacker is in or assets an attacker has
    compromised (“nouns”).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形框表示攻击者所处的状态或攻击者已攻破的资产（“名词”）。
- en: Square boxes indicate successful attacks the attacker has performed (“verbs”).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方框表示攻击者已成功执行的攻击（“动词”）。
- en: A solid arrow shows the consequential flow between the preceding states and
    attacks.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实心箭头表示前述状态与攻击之间的因果流动。
- en: A dotted arrow indicates attacks that are mitigated by some countermeasure.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线箭头表示通过某些防御措施已被缓解的攻击。
- en: Several incoming arrows indicate that “any single one of the arrows can lead
    to this.”
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多条传入箭头表示“任何一条箭头都可以导致此结果”。
- en: The “and” triangle means all the incoming arrows must be satisfied.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “和”三角形表示所有传入的箭头必须满足。
- en: The numbers in the attack tree mark the stages of the toothbrush attack. As
    attackers, we have physical access to an IoT toothbrush (1). Our mission is to
    install a telnet backdoor on the toothbrush to determine what PII is present on
    the device (8) and also to run the toothbrush at ludicrous speed (11).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击树中的数字标记了牙刷攻击的各个阶段。作为攻击者，我们拥有对一把物联网牙刷的物理访问权限（1）。我们的任务是向牙刷上安装一个telnet后门，以确定设备上存在的个人身份信息（PII）（8），并且让牙刷以超高速运行（11）。
- en: '![f01012](image_fi/278748c01/f01012.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![f01012](image_fi/278748c01/f01012.png)'
- en: 'Figure 1-12: IoT toothbrush attack tree'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-12：物联网牙刷攻击树
- en: Lowercase letters indicate the attacks, and Roman numerals indicate the mitigations.
    One of the first things we do is desolder the flash and read out the contents—all
    16MB of it (a). We see, however, that the image has no readable strings. After
    some entropy analysis, the content appears to be either encrypted or compressed,
    but since there is no header identifying the compression format, we assume this
    content is encrypted as shown in attack (2) and attack mitigation (i). To decrypt
    it, we need the encryption key. It doesn’t seem to be stored in flash, a mitigation
    shown at (ii), so it’s likely stored somewhere in ROM or fuses. Without access
    to a scanning electron microscope, we are unable to “read them out” from silicon.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母表示攻击，罗马数字表示缓解措施。我们做的第一件事是将闪存拆下来并读取内容——所有16MB的内容（a）。然而，我们发现该镜像没有可读的字符串。经过一些熵分析后，内容似乎是加密或压缩的，但由于没有头部信息标识压缩格式，我们假设该内容如攻击（2）和缓解措施（i）所示，是加密的。为了进行解密，我们需要加密密钥。它似乎并未存储在闪存中，这是缓解措施（ii）所示的情况，因此它很可能存储在ROM或熔丝中。由于我们无法访问扫描电子显微镜，因此无法“从硅片中读取它们”。
- en: Instead, we decide to poke around with power analysis. We hook up a power probe
    and oscilloscope and take a power trace of the system while it is booting. The
    trace shows about one million little peaks. Knowing from our flash readout that
    the image is 16MB, we deduce that each peak corresponds to 16 bytes of encrypted
    data. We’ll just assume this is an AES-128 encryption in either of the common
    *electronic code block (ECB)* or *cipher block chaining (CBC)* modes. *ECB* is
    a mode where each block is decrypted independently of other blocks, and *CBC*
    is a mode where the decryption of the latter blocks depends on the earlier blocks.
    Since we know the firmware image’s ciphertext, we can try a power analysis attack
    based on the peaks we measure. After much preprocessing of the traces and doing
    a differential power analysis (DPA) attack (b), we’re able to identify a likely
    key candidate. (Don’t worry; you will learn what DPA is as you progress further
    through this book.) Decryption with ECB produces garbage, but CBC gives us several
    readable strings in attack (c); it seems we have found the right key at stage
    (3) and have successfully decrypted the image at stage (4)!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们决定进行功率分析。我们连接一个功率探测器和示波器，并在系统启动时获取功率跟踪数据。跟踪图显示大约有一百万个小峰值。通过从闪存读取数据得知图像为16MB，我们推测每个峰值对应16字节的加密数据。我们假设这是一种AES-128加密，可能使用常见的*电子密码本（ECB）*或*密码块链接（CBC）*模式。*ECB*是一种每个块独立解密的模式，而*CBC*则是一种后续块的解密依赖于前面块的模式。由于我们知道固件镜像的密文，我们可以基于测量到的峰值尝试进行功率分析攻击。在对跟踪数据进行大量预处理并进行差分功率分析（DPA）攻击（b）后，我们成功识别出了一个可能的密钥候选项。（别担心，你会在本书后续章节中了解什么是DPA。）使用ECB解密得到的内容是垃圾数据，但CBC模式下我们得到了几个可读字符串，在攻击（c）阶段；看起来我们在阶段（3）找到了正确的密钥，并在阶段（4）成功解密了图像！
- en: From the decrypted image, we can use traditional software reverse engineering
    (g) techniques to identify which code blocks do what, where data is stored, how
    actuators are driven, and, important from a security point of view, we can now
    look for vulnerabilities in the code (9). Further, we modify the decrypted image
    at stage (d) to include a backdoor that will allow us to telnet into the toothbrush
    remotely (5).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从解密后的镜像中，我们可以使用传统的软件逆向工程（g）技术来识别各个代码块的功能、数据存储位置、执行器如何驱动，以及从安全角度来看，如何寻找代码中的漏洞（9）。进一步地，我们在阶段（d）修改解密后的镜像，加入一个后门，使我们可以远程通过Telnet进入牙刷（5）。
- en: We re-encrypt the image and flash it in attack (d), only to discover that the
    toothbrush doesn’t boot. We have run into what is most likely firmware signature
    verification. Without the private key used to sign the images, we cannot run a
    modified image due to mitigation (iii). One common attack on this countermeasure
    is that of voltage fault injection. With fault injection, we’ll aim to corrupt
    the one instruction responsible for deciding whether to accept or reject a firmware
    image. This is usually a comparison that uses the Boolean result returned from
    an `rsa_signature_verify()` function. Since this code is implemented in ROM, we
    cannot really get information about the implementation from reverse engineering.
    So, we try an old trick—take a side-channel trace when the unmodified image boots
    and compare it to a side-channel trace of booting a modified image in attack (e).
    The point where the traces differ is likely to be the moment where the boot code
    decides whether to accept the firmware image in stage (6). We generate a fault
    at that instant to attempt to modify the decision.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新加密图像并在攻击(d)中闪存它，结果发现牙刷无法启动。我们遇到的很可能是固件签名验证问题。如果没有用来签署图像的私钥，我们无法运行经过修改的图像，这是由于缓解措施(iii)的存在。一种常见的对抗这种反制措施的攻击是电压故障注入。通过故障注入，我们的目标是破坏负责决定是否接受或拒绝固件图像的那条指令。通常这是一个比较操作，使用从`rsa_signature_verify()`函数返回的布尔结果。由于这段代码是实现于ROM中，我们无法通过逆向工程获取有关实现的详细信息。因此，我们尝试一个老技巧——在未修改的图像启动时获取侧信道追踪，并将其与攻击(e)中启动修改后图像的侧信道追踪进行对比。追踪差异的地方很可能是引导代码决定是否接受固件图像的时刻，位于阶段(6)。我们在这一瞬间生成一个故障，尝试修改决策。
- en: We load the malicious image and drop the voltage for a few hundred nanoseconds
    at a random point in a 5-microsecond window in attack (f), at around the instant
    when we determined the decision is made. After a few hours of repeating this attack,
    we’re in luck; the toothbrush boots our malicious image in stage (7). Now that
    the modified code allows us to telnet in, we reach the stage (8), where we can
    remotely control the brushing and spy on any usage of the brush. And now in the
    final and fun stage (11), we turn up the speed to ludicrous!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载恶意图像，并在攻击的5微秒窗口内随机某一点将电压降低几百纳秒（见图(f)），大约是在我们确定决策已作出时的瞬间。经过几小时的反复攻击，我们终于运气好，牙刷成功加载了我们的恶意图像，进入了阶段(7)。现在，经过修改的代码允许我们telnet登录，我们达到了阶段(8)，在这里我们可以远程控制刷牙操作并监视任何刷牙使用情况。而在最后一个有趣的阶段(11)，我们将速度调至极限！
- en: This is obviously a silly example, since the obtained information and access
    are likely not valuable enough for a serious attacker; physical access is needed
    to perform the side-channel and fault attacks, and a reset of the device by the
    proper owner causes a denial of service. However, it’s an enlightening exercise,
    and it’s always worthwhile to play with these toy scenarios.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个愚蠢的例子，因为获取的信息和访问权限可能不足以对一个严肃的攻击者产生足够的价值；进行侧信道和故障攻击需要物理接触，并且设备所有者进行重置会导致服务拒绝。然而，这是一次启发性的练习，玩这些玩具场景总是值得的。
- en: When drawing attack trees, it’s easy to get carried away and make the tree huge.
    Remember that attackers probably will try only a few of the easiest attacks (this
    tool helps identify what those are). Focus on the relevant attacks, which you
    can determine by profiling the attacker and attack capabilities earlier in the
    threat modeling.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制攻击树时，很容易失控，导致树变得非常庞大。记住，攻击者可能只会尝试一些最简单的攻击（这个工具可以帮助识别这些攻击）。请专注于相关攻击，这些攻击可以通过在威胁建模中提前分析攻击者和攻击能力来确定。
- en: Identification vs. Exploitation
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份识别与利用
- en: The toothbrush attack path concentrates on the *identification* *phase* of an
    attack by finding a key, reverse engineering the firmware, modifying the image,
    and discovering the fault-injection instant. Remember that exploitation is the
    endeavor to scale up the hack by accessing multiple devices. When repeating the
    attack on another device, you can reuse much of the information gained during
    identification. Subsequent attack results require only flashing an image in attack
    (d) at stage (5), knowing the fault injection point in stage (6), and generating
    the fault by attack (f). Exploitation effort is always lower than identification
    effort. In some formalisms of creating attack trees, each arrow is annotated with
    the attack cost and effort, but here we avoid getting too much into quantitative
    risk modeling.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 牙刷攻击路径集中在攻击的*识别* *阶段*，通过找到密钥、逆向固件、修改镜像并发现故障注入点来进行。记住，利用阶段是通过访问多个设备来扩展攻击。当在另一个设备上重复攻击时，可以重用识别阶段获得的许多信息。后续的攻击结果只需要在第（5）阶段的攻击（d）中刷写一个镜像，在第（6）阶段知道故障注入点，并通过攻击（f）产生故障。利用的努力总是低于识别的努力。在某些创建攻击树的形式中，每个箭头都会注释攻击的成本和努力，但在这里我们避免过多涉及定量风险建模。
- en: Scalability
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The toothbrush attack is not scalable, because the exploitation phase requires
    physical access. For PII or remote actuation, it’s usually of interest for an
    attacker only if this can be done at scale.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 牙刷攻击并不可扩展，因为利用阶段需要物理访问。对于PII或远程激活，通常只有在可以大规模实施的情况下，攻击者才会对此感兴趣。
- en: However, let’s say that in our reverse engineering attack (g), stage (9) manages
    to identify a vulnerability for which we create an exploit (h) in stage (10).
    We find that the vulnerability is accessible through an open TCP port, so attack
    (j) can exploit this vulnerability remotely. This instantly changes the attack’s
    entire scale. Having used hardware attacks in the identification phase, we can
    rely solely on remote software attacks in the exploitation phase (12). Now, we
    can attack any toothbrush, gain access to anyone’s brushing habits, and irritate
    gums on a global scale. What a time to be alive.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设在我们的逆向工程攻击（g）中，第（9）阶段成功识别出一个漏洞，我们在第（10）阶段创建了一个利用工具。我们发现该漏洞通过开放的TCP端口可访问，因此攻击（j）可以远程利用这个漏洞。这立即改变了攻击的整个规模。通过在识别阶段使用硬件攻击，我们在利用阶段（12）可以仅依赖远程软件攻击。现在，我们可以攻击任何牙刷，获取任何人的刷牙习惯，并在全球范围内刺激牙龈。真是活在一个令人兴奋的时代。
- en: Analyzing the Attack Tree
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析攻击树
- en: The attack tree helps visualize attack paths in order to discuss them as a team,
    identify points where additional countermeasures can be built, and analyze the
    efficacy of existing countermeasures. For instance, it is easy to see that mitigation
    by firmware image encryption (i) has forced the attacker to use a side-channel
    attack (b), which is more difficult than simply reading out a memory. Similarly,
    mitigation by firmware image signing (iii) forced an attacker into a fault-injection
    attack (f).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击树有助于可视化攻击路径，以便团队讨论、识别可以构建额外对策的节点，并分析现有对策的有效性。例如，可以很容易地看到，通过固件镜像加密（i）减缓了攻击者，迫使其使用侧信道攻击（b），这种方式比直接读取内存更加困难。同样，固件镜像签名（iii）的防护措施也迫使攻击者使用故障注入攻击（f）。
- en: However, the main risk is still the scalable attack path through exploitation
    (j), which is currently unmitigated. Obviously, the vulnerability should be patched,
    anti-exploitation countermeasures should be introduced, and network restrictions
    should be put in place to disallow anybody from directly connecting to the toothbrush
    remotely.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，主要的风险仍然是通过利用（j）进行的可扩展攻击路径，这种攻击当前没有得到缓解。显然，应该修补漏洞，引入防止利用的对策，并设置网络限制，禁止任何人远程直接连接到牙刷。
- en: Scoring Hardware Attack Paths
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件攻击路径评分
- en: Apart from visualizing attack paths for analysis, we can also add some quantification
    to figure out which attacks are easier or cheaper for an attacker. In this section,
    we introduce several industry-standard rating systems.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可视化攻击路径以进行分析外，我们还可以加入一些量化因素，来评估哪些攻击对攻击者来说更容易或更便宜。在这一部分，我们介绍了几种行业标准的评级系统。
- en: The *Common Vulnerability Scoring System (CVSS)* attempts to score vulnerabilities
    for severity, typically in the context of networked computers in an organization.
    It assumes the vulnerability is known and tries to score how bad it would be if
    it were to be exploited. The *Common Weakness Scoring System (CWSS)*quantifies
    weaknesses in systems, but those weaknesses are not necessarily vulnerabilities
    and not necessarily in the context of networked computers. Finally, the *Joint
    Interpretation Library (JIL)* is used to score (hardware) attack paths in the
    Common Criteria (CC) certification scheme.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用漏洞评分系统（CVSS）*试图为漏洞的严重性打分，通常用于组织中网络化计算机的情境。它假设漏洞已知，并尝试评估如果该漏洞被利用会造成多大影响。*通用弱点评分系统（CWSS）*量化了系统中的弱点，但这些弱点不一定是漏洞，也不一定是在网络化计算机的情境中。最后，*联合解释库（JIL）*用于在通用准则（CC）认证方案中评分（硬件）攻击路径。'
- en: All of these scoring methods have various parameters and scores for each parameter,
    which together create a final tally to help compare various vulnerabilities or
    attack paths. These scoring methods also share the advantage of replacing indefinite
    arguments about parameters with scores that make sense only in the target context
    of the scoring method. [Table 1-1](#table1-1) provides an overview of the three
    ratings and where they are applicable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些评分方法都有各种参数和每个参数的分数，所有这些参数和分数共同构成了一个最终的总分，以帮助比较不同的漏洞或攻击路径。这些评分方法的一个优点是，它们通过分数代替了关于参数的模糊讨论，分数的意义仅限于评分方法的目标上下文。[表
    1-1](#table1-1)提供了三个评分标准的概述及其适用范围。
- en: 'Table 1-1: Overview of Attack Rating Systems'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：攻击评分系统概览
- en: '|  | **Common Vulnerability Scoring System** | **Common Weakness Scoring System**
    | **Common Criteria Joint Interpretation Library** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  | **通用漏洞评分系统** | **通用弱点评分系统** | **通用准则联合解释库** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Purpose** | Helps organizations with their vulnerability management processes
    | Prioritizes software weakness addressing the needs of government, academia,
    and industry | Rates attacks in order to pass/fail CC evaluation |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **目的** | 帮助组织进行漏洞管理流程 | 优先解决软件弱点，满足政府、学术界和工业界的需求 | 评分攻击以通过/未通过 CC 评估 |'
- en: '| **Impact** | Distinguishes confidentiality/integrity/availability | Technical
    impact 0.0–1.0, acquired privilege (layer) | N/A |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **影响** | 区分机密性/完整性/可用性 | 技术影响 0.0–1.0，获得的权限（层级） | 不适用 |'
- en: '| **Asset** **v****alue** | N/A | Business impact 0.0–1.0 | N/A |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **资产** **价值** | 不适用 | 业务影响 0.0–1.0 | 不适用 |'
- en: '| **Identification** **c****ost** | Assumes identification already happened
    | Likelihood of discovery | Identification phase rating for elapsed time, expertise,
    knowledge, access, equipment, and open samples |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **识别** **成本** | 假设识别已经完成 | 被发现的可能性 | 识别阶段的评分，包括时间流逝、专业知识、知识、访问权限、设备和开放样本
    |'
- en: '| **Exploitation** **c****ost** | Various factors; no hardware aspects | Various
    factors; no hardware aspects | Exploitation phase rating |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **利用** **成本** | 各种因素；没有硬件方面 | 各种因素；没有硬件方面 | 利用阶段评分 |'
- en: '| **Attack** **v****ector** | Four levels, from physical to remote | Level
    0.0–1.0, from physical to internet | Assumes physically present attacker |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **攻击** **向量** | 四个级别，从物理到远程 | 级别 0.0–1.0，从物理到互联网 | 假设攻击者物理在场 |'
- en: '| **External** **m****itigations** | “Modified” category includes mitigations
    | External control effectiveness | No external mitigations |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **外部** **缓解措施** | “修改”类别包括缓解措施 | 外部控制效果 | 无外部缓解措施 |'
- en: '| **Scalability** | Not really, some related aspects | Not really, some related
    aspects | Low exploitation cost may imply scalability |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **可扩展性** | 并不完全是，有些相关方面 | 并不完全是，有些相关方面 | 低利用成本可能意味着可扩展性 |'
- en: In a defensive context, you can use ratings to judge the impact of an attack
    after it occurs as a means to decide how to respond to an attack. For instance,
    if a vulnerability is detected in a piece of software, CVSS scoring can help decide
    whether to roll out an emergency patch (with all its associated costs) or push
    out the fix in the next major version if the vulnerability is minor.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在防御情境下，你可以使用评分来判断攻击发生后的影响，以决定如何应对攻击。例如，如果在某个软件中发现了漏洞，CVSS评分可以帮助决定是推出紧急修补程序（及其相关费用），还是将修复程序推迟到下一个主要版本，如果漏洞较小的话。
- en: You can also use scoring in a defensive context to judge which countermeasures
    are needed. In the context of Common Criteria Smart Card certification, the JIL
    scoring actually becomes a critical part of the security objective—the chip must
    resist attacks rated at up to 30 points to be considered resistant to attackers
    of high attack potential. The SOG-IS document “Application of Attack Potential
    to Smartcards” explains the scoring, and it touches upon a number of hardware
    attacks. To give you an idea of the rating, if it takes a few weeks to pull out
    a secret key using a two-laser beam system for laser fault injection, this attack
    rates 30 or below. If it takes six months to pull out a key using a side-channel
    attack, implementing a countermeasure is not necessary, as this attack rates 31
    or higher.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在防御性上下文中使用评分来判断需要哪些对策。在通用标准智能卡认证的背景下，JIL评分实际上成为了安全目标的一个关键部分——芯片必须抵御被评为最高30分的攻击，才能被认为对高攻击潜力的攻击者具有抵抗力。SOG-IS文档《攻击潜力在智能卡中的应用》解释了这种评分，并涉及了一些硬件攻击。为了给你一个评分的概念，如果使用双激光束系统进行激光故障注入，需要几周时间才能提取出一个秘密密钥，这种攻击的评分为30分或以下。如果使用侧信道攻击需要六个月才能提取密钥，那么就不需要实施对策，因为这种攻击的评分为31分或更高。
- en: The CWSS is aimed at rating weaknesses in systems before they are exploited.
    It is a useful scoring method during development, as it helps assign priorities
    to the weaknesses’ remedies. Everyone knows that each fix comes at a cost and
    that attempting to fix all bugs isn’t practical, so rating weaknesses allows developers
    to concentrate on the most significant ones.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CWSS旨在对系统中的弱点进行评分，以便在它们被利用之前进行评估。这是一个在开发过程中非常有用的评分方法，因为它有助于为弱点的修复措施分配优先级。大家都知道，每个修复都需要付出成本，而且试图修复所有漏洞是不切实际的，因此对弱点进行评分可以让开发人员集中精力解决最重要的问题。
- en: In reality, most attackers do some sort of scoring as well to minimize the cost
    and maximize the impact of the attack. Although attackers do not publish much
    on these topics, Dino Dai Zovi had a cool talk called “Attacker Math 101” at SOURCE
    Boston 2011 that attempted to put some bounds on attacker costing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，大多数攻击者也会进行某种评分，以最小化攻击成本并最大化攻击的影响。尽管攻击者在这些话题上并没有发布太多内容，但Dino Dai Zovi在2011年SOURCE波士顿会议上做了一场名为“攻击者数学101”的精彩演讲，尝试为攻击者成本设定一些界限。
- en: 'These ratings are limited, ambiguous, imprecise, subjective, and not market
    specific, but they form a good starting point for discussing an attack or vulnerability.
    If you’re doing threat modeling for embedded systems, we recommend starting with
    JIL, which is primarily focused on hardware attacks. When concerned with software
    attacks, use CWSS, as those are the contexts for the scoring methods. With CWSS,
    you can drop irrelevant aspects and tune others, such as business impacts, to
    assess asset values or scalability. Also, make sure you score the entire attack
    path, from the attacker’s starting point all the way through to the impact on
    the asset, so you have a consistent comparison between scores. None of the three
    ratings deal well with scalability: an attack on a million systems may produce
    only a marginally worse score than on a single system. Other limitations undoubtedly
    exist, but currently no better known industry standards exist.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些评分是有限的、模糊的、不精确的、主观的，并且不具备特定市场背景，但它们为讨论攻击或漏洞提供了一个良好的起点。如果你正在为嵌入式系统进行威胁建模，我们建议从JIL开始，它主要关注硬件攻击。当涉及软件攻击时，使用CWSS，因为这些是评分方法的应用背景。使用CWSS时，你可以去掉无关的方面，调整其他方面，比如业务影响，以评估资产的价值或可扩展性。此外，确保你对整个攻击路径进行评分，从攻击者的起点一直到对资产的影响，这样你就能在不同评分之间做出一致的比较。三种评分方法都无法很好地处理可扩展性问题：对百万台系统的攻击可能只会比对单台系统的攻击产生稍微更差的评分。其他限制也毫无疑问地存在，但目前没有更好的行业标准。
- en: In various security certification schemes, an implicit or explicit security
    objective is present. For example, as mentioned earlier, for smart cards, attacks
    of only 30 JIL points or lower are considered relevant. An attack like in Tarnovsky’s
    2010 Black Hat DC presentation “Deconstructing a ‘Secure’ Processor” is more than
    30 points and, therefore, not considered part of the security objective. For FIPS
    140-2, no attacks outside the specific list of attacks are considered relevant.
    For example, a side-channel attack can compromise a FIPS 140-2 validated crypto
    engine in a day, and the FIPS 140-2 security objective will still consider it
    to be secure. Any time you use a device that has a security certificate, check
    that the certificate’s security objectives are in line with yours.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种安全认证方案中，都有隐性或显性的安全目标。例如，前面提到的，对于智能卡，只有30个JIL点或更低的攻击才被认为是相关的。比如Tarnovsky在2010年黑帽大会DC演讲中展示的攻击“解构一个‘安全’处理器”超过了30个点，因此不被认为是安全目标的一部分。对于FIPS
    140-2来说，任何不在特定攻击列表中的攻击都不被认为是相关的。例如，侧信道攻击可以在一天内攻破FIPS 140-2认证的加密引擎，而FIPS 140-2的安全目标仍然认为它是安全的。每次使用具有安全证书的设备时，都要确保该证书的安全目标与您的目标一致。
- en: Disclosing Security Issues
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全问题的披露
- en: Disclosure of security issues is a hotly debated topic, and we do not purport
    to be solving that in a few paragraphs. We do want to add some color to the debate
    when it comes to hardware security issues. Hardware and software will always have
    security issues. With software, you may be able to distribute new versions or
    patches. Fixing hardware is expensive for many reasons.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题披露是一个备受争议的话题，我们并不打算在几段话中解决这个问题。我们希望在讨论硬件安全问题时为辩论增添一些色彩。硬件和软件始终会存在安全问题。对于软件，您可能能够分发新版本或补丁。而修复硬件因各种原因而成本高昂。
- en: We believe the goal of disclosure is public security and safety, not manufacturer
    business cases or researcher fame and fortune. This means disclosure must serve
    the public in the long run. Disclosure is a tool to force manufacturers to fix
    a vulnerability and also to inform the public about a certain product’s risks.
    An unwelcome side effect of full disclosure is that a large group of attackers
    will be able to exploit the vulnerability until a fix is widely available.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为披露的目标是公共安全和安保，而不是制造商的商业利益或研究人员的名利。这意味着披露必须从长远来看为公众服务。披露是迫使制造商修复漏洞的工具，同时也让公众了解某产品的风险。完全披露的一个不受欢迎的副作用是，一大批攻击者将在修复广泛发布之前利用该漏洞。
- en: For hardware vulnerabilities, the bug is often not patchable after manufacturing,
    though issuing a software patch can mitigate it. In that case, a similar convention
    to software disclosure of 90 days until disclosure may work fine. For pure hardware
    fixes, we are not aware of such conventions (though we’ve seen the application
    of software conventions).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于硬件漏洞，通常在生产后该漏洞无法修复，尽管发布软件补丁可以缓解此问题。在这种情况下，类似于软件披露的90天披露期可能也适用。对于纯硬件的修复，我们尚不清楚有类似的惯例（尽管我们见过软件惯例的应用）。
- en: In hardware, it’s common that a software update cannot work around a bug, and
    patches are practically impossible to distribute and install. A well-intentioned
    manufacturer can fix a bug in the next release, but products in the field will
    remain vulnerable. In this situation, the only advantage to disclosure is an informed
    public; the disadvantage is a long time span until the vulnerable products are
    replaced or discontinued. An alternative is partial disclosure. For instance,
    a manufacturer may name the risk and the product but not disclose the details
    of how to exploit the vulnerability. (This strategy hasn’t worked well in the
    software world, where the vulnerabilities are often found quickly even after an
    unspecific disclosure.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中，通常无法通过软件更新绕过漏洞，而且补丁几乎不可能分发和安装。一位有良好意图的制造商可以在下一个版本中修复漏洞，但现场的产品仍然会受到威胁。在这种情况下，披露的唯一好处是公众的知情；缺点是直到有漏洞修复产品替换或停产前，会有很长的时间间隔。另一种选择是部分披露。例如，制造商可以说明风险和产品，但不披露如何利用漏洞的具体细节。（这种策略在软件领域并不奏效，因为即便是非具体的披露，漏洞也通常很快被发现。）
- en: Complications increase when the vulnerability is not patchable and can directly
    affect health and safety. Consider an attack that can shut down every single pacemaker
    remotely. Disclosure of the latter situation will surely spook patients away from
    having pacemakers fitted, causing more people to die from heart attacks. On the
    other hand, it would encourage the supplier to increase the security in the next
    version, reducing the risk of an attack with lethal consequences. Unique trade-offs
    will occur for self-driving cars, IoT toothbrushes, SCADA systems and every other
    application and device. Even more challenges arise when vulnerabilities exist
    in one type of chip used in a variety of products.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当漏洞无法修补，并且可能直接影响健康和安全时，复杂性会增加。考虑一个攻击，它可以远程关闭每一个心脏起搏器。如果披露这种情况，肯定会让患者对安装心脏起搏器产生恐惧，导致更多人因心脏病发作而死亡。另一方面，这将促使供应商在下一版本中提高安全性，减少具有致命后果的攻击风险。对于自动驾驶汽车、物联网牙刷、SCADA系统以及其他所有应用和设备，都会出现独特的权衡。特别是当漏洞存在于一种芯片上，而这种芯片被广泛应用于各种产品时，挑战会更大。
- en: We’re not claiming to have the magic answer to all situations here, but we encourage
    everyone to consider carefully the kind of disclosure to pursue. Manufacturers
    should design systems around the premise that they will be broken and plan safe
    scenarios around that premise. Unfortunately, this practice is not prevalent,
    especially in situations where time to market and low cost rule.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是说我们能提供所有情况下的“魔法答案”，但我们鼓励每个人认真考虑要采取什么样的披露方式。制造商应以系统最终会被攻破为前提来设计系统，并围绕这一前提制定安全场景。不幸的是，这种做法并不普遍，特别是在市场推出时间和低成本主导的情况下。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter outlined some embedded security basics. We described the software
    and hardware components you’ll undoubtedly stumble upon when analyzing a device,
    and we discussed what “security” means philosophically. To analyze security properly,
    we introduced the four components of a threat model: the attackers, various (hardware)
    attacks, a system’s assets and security objectives, and, finally, the types of
    countermeasures you can implement. We also described tools to create, analyze,
    and rate attacks using an attack tree and industry-standard rating systems. Finally,
    we explored the tricky topic of disclosure in the context of hardware vulnerabilities.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了一些嵌入式安全基础知识。我们描述了在分析设备时，您无疑会遇到的软硬件组件，并讨论了“安全”在哲学上的含义。为了正确分析安全问题，我们介绍了威胁模型的四个组成部分：攻击者、各种（硬件）攻击、系统的资产和安全目标，最后是您可以实施的反制措施类型。我们还描述了用于创建、分析和评估攻击的工具，使用攻击树和行业标准评级系统。最后，我们探讨了硬件漏洞的披露这一棘手的话题。
- en: Laden with all this knowledge, our next step will be to start poking at devices,
    which is what we’ll do in the next chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些知识，我们的下一步将是开始对设备进行探测，这也是我们在下一章要做的事情。
