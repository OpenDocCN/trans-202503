<html><head></head><body>
<h2 class="h2" id="ch11"><a id="page_189"/><strong><span class="big">11</span></strong><br/><strong>LEGACY ISSUES AND BAGGAGE FROM C</strong></h2>
<p class="noindent">Objective-C and Cocoa help mitigate many security problems that you might run into with C or C++. Objective-C is, however, still a flavor of C, which fundamentally isn’t a “safe” language, and some Cocoa APIs are still vulnerable to the types of data theft or code execution attacks you might expect in C programs. C and C++ can also be intermingled freely with Objective-C. Many iOS applications use large amounts of C and C++ code, whether because developers want to use a familiar library or are trying to keep code as portable as possible between platforms. There are some mitigations in place to prevent code execution attacks, as discussed in <a href="ch01.html#ch01">Chapter 1</a>, but these can be bypassed by more skilled attackers. As such, it’s a good idea to familiarize yourself with these bugs and attacks.</p>
<p class="indent">In this chapter, you’ll learn about some of the types of attacks to look out for, the places where C bugs creep into Objective-C, and how to fix these issues. The topic of native C code issues is broad, so this chapter is a “greatest hits” of these issues to give you the basic foundation for understanding the theory behind these flaws and the attacks that exploit them.</p>
<h3 class="h3" id="ch11lev1sec01"><a id="page_190"/><strong>Format Strings</strong></h3>
<p class="noindentb">Format string attacks<sup><a href="footnote.html#fn100" id="fn_100">1</a></sup> leverage a misuse of APIs that expect a <em>format string</em>, or a string that defines the data types of which the string will be composed. In C, the most commonly used functions that accept format strings are in the <code>printf</code> family; there are a number of other functions, such as <code>syslog</code>, that accept them as well. In Objective-C, these methods usually have suffixes like <code>WithFormat</code> or <code>AppendingFormat</code>, though there are several exceptions. Here are examples of all three:</p>
<p class="bull">• <code>[NSString *WithFormat]</code></p>
<p class="bull">• <code>[NSString stringByAppendingFormat]</code></p>
<p class="bull">• <code>[NSMutableString appendFormat]</code></p>
<p class="bull">• <code>[NSAlert alertWithMessageText]</code></p>
<p class="bull">• <code>[NSException raise:format:]</code></p>
<p class="bull">• <code>NSLog()</code></p>
<p class="indentt">Attackers commonly exploit format string vulnerabilities to do two things: execute arbitrary code and read process memory. These vulnerabilities generally stem from two age-old C format string operators: <code>%n</code> and <code>%x</code>. The rarely used <code>%n</code> operator is meant to store the value of the characters printed so far in an integer on the stack. It can, however, be leveraged to overwrite portions of memory. The <code>%x</code> operator is meant to print values as hexadecimal, but when no value is passed in to be printed, it reads values from the stack.</p>
<p class="indent">Unfortunately for us bug hunters, Apple has disabled <code>%n</code> in Cocoa classes that accept format strings. But the <code>%n</code> format string <em>is</em> allowed in regular C code, so code execution format string attacks are still possible.<sup><a href="footnote.html#fn101" id="fn_101">2</a></sup> The reason that <code>%n</code> can result in code execution is because it writes to the stack, and the format string is also stored on the stack. Exploitation varies depending on the specific bug, but the main upshot is that by crafting a format string that contains <code>%n</code> and also a memory address to write to, you can get arbitrary integers written to specific parts of memory. In combination with some shell code, this can be exploited similarly to a buffer overflow attack.<sup><a href="footnote.html#fn102" id="fn_102">3</a></sup></p>
<p class="indent">The <code>%x</code> operator, on the other hand, is alive and well in both Objective-C methods and C functions. If an attacker can pass <code>%x</code> to an input that lacks a format string specifier, the input will be interpreted as a format string, and the contents of a stack will be written in hexadecimal where the expected string should appear. If attackers can then view this output, they can collect <a id="page_191"/>potentially sensitive information from the process’s memory, such as user-names, passwords, or other personal data.</p>
<p class="indent">Of course, both of these vulnerabilities rely on a program not controlling user input properly. Let’s take a look at how an attacker might misuse format strings in such a situation and how applications can prevent that from happening.</p>
<h4 class="h4" id="ch11lev2sec01"><em><strong>Preventing Classic C Format String Attacks</strong></em></h4>
<p class="noindent">The typical example of a format string vulnerability is when a program passes a variable directly to <code>printf</code>, without manually specifying a format string. If this variable’s contents are supplied by external input that an attacker can control, then the attacker could execute code on a device or steal data from its memory. You can test some contrived vulnerable code like this in Xcode:</p>
<pre><span class="rose">char</span> *t;<br/>t = <span class="red">"%x%x%x%x%x%x%x%x";</span><br/>printf(t);</pre>
<p class="indent">This code simply supplies a string containing a bunch of <code>%x</code> specifiers to the <code>printf</code> function. In a real-world program, these values could come from any number of places, such as a user input field or DNS query result. When the code executes, you should see a string of hexadecimal output written to your console. This output contains the hexadecimal values of variables stored on the stack. If an application has stored a password or encryption key as a value on the stack and parses some attacker-supplied data, an attacker could cause this information to leak to somewhere they can then read. If you change the previous example to contain <code>%n</code> specifiers, the behavior is different. Here’s how that would look:</p>
<pre><span class="rose">char</span> *t;<br/>t = <span class="red">"%n%n%n%n%n"</span>;<br/>printf(t);</pre>
<p class="indent">Running this example in Xcode should cause Xcode to drop to <code>lldb</code> with the error <code>EXC_BAD_ACCESS</code>. Whenever you see that message, your program is trying to read or write to some memory it shouldn’t. In a carefully crafted attack, you won’t see such errors, of course; the code will simply execute.</p>
<p class="indent">But you can prevent attackers from hijacking strings pretty easily by controlling user input. In this case, just change that <code>printf</code> to specify its own format string, as follows:</p>
<pre><span class="rose">char</span> *t;<br/>t = <span class="red">"%n%n%n%n%n"</span>;<br/>printf(<span class="red">"%s"</span>, t);</pre>
<p class="indent"><a id="page_192"/>Run this in Xcode, and you should see the literal <code>%n%n%n%n%n</code> written harmlessly to the console. These examples, of course, are plain old C, but knowing how they work will help you explore format string attacks with an Objective-C twist.</p>
<h4 class="h4" id="ch11lev2sec02"><em><strong>Preventing Objective-C Format String Attacks</strong></em></h4>
<p class="noindent">Similar to plain C, you can pass in any of the <code>printf</code> format operators to a number of different Objective-C APIs. You can test this easily in Xcode by passing a bogus format string to <code>NSLog</code>:</p>
<pre><span class="violet1">NSString</span> *userText = <span class="red">@"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"</span>;<br/><span class="violet1">NSLog(userText);</span></pre>
<p class="indent">Much like the previous <code>%x</code> example, this will spit out memory contents in hexadecimal to the console. One format string vulnerability I’ve come across in real iOS applications is code that passes user-supplied input to a “formatting” function, which does some processing and returns an <code>NSString</code> object, as shown in <a href="ch11.html#ch11ex1">Listing 11-1</a>.</p>
<pre>   <span class="violet1">NSString</span> *myStuff = <span class="red">@"Here is my stuff."</span>;<br/>   <span class="violet1">NSString</span> *unformattedStuff = <span class="red">@"Evil things %x%x%x%x%x"</span>;<br/><span class="ent">➊</span> myStuff = [myStuff <span class="violet">stringByAppendingFormat</span>:[<span class="green">UtilityClass</span> <span class="violet">formatStuff</span>:<br/>        unformattedStuff.text]];</pre>
<p class="listcap"><a id="ch11ex1"/><em>Listing 11-1: Totally the wrong way to pass in data to a format string</em></p>
<p class="indent">This example just assumes that the resulting <code>NSString</code> stored in <code>myStuff</code> at <span class="ent">➊</span> is safe; after all, the contents of <em>unformattedStuff.text</em> were “formatted.” But unless the <code>formatStuff</code> method has some special way of sanitizing that input file, the resulting string could contain format string specifiers. If that happens, you still have a format string issue, and the resulting string will contain values from the stack.</p>
<p class="indent"><code>NSString</code> objects aren’t magically safe from format string attacks. The correct way to output an <code>NSString</code> passed to a method requiring a format string is to use the <code>%@</code> specifier, as shown in <a href="ch11.html#ch11ex2">Listing 11-2</a>.</p>
<pre><span class="violet1">NSString</span> myStuff = <span class="red">@"Here is my stuff."</span>;<br/>myStuff = [myStuff <span class="violet">stringByAppendingFormat</span>:<span class="red">@"%@"</span>, [<span class="green">UtilityClass</span> <span class="violet">formatStuff</span>:<br/>     unformattedStuff.text]];</pre>
<p class="listcap"><a id="ch11ex2"/><em>Listing 11-2: The correct way to use a method expecting a format string</em></p>
<p class="indent">With the <code>%@</code> specifier in front, no matter how many <code>%x</code> and <code>%n</code> operators <em>unformattedStuff.text</em> might contain, <code>myStuff</code> should come out as a harmless string.</p>
<p class="indent"><a id="page_193"/>The <code>%x</code> and <code>%n</code> specifiers are the most useful ones to attackers, but even in their absence, attackers can still cause undesirable behavior, such as crashes, when trying to read inaccessible memory, even using basic <code>%s</code> specifiers. Now that I’ve covered how format string attacks work and how to prevent them, I’ll show you some other methods of executing malicious code.</p>
<h3 class="h3" id="ch11lev1sec02"><strong>Buffer Overflows and the Stack</strong></h3>
<p class="noindent">Buffer overflows have long haunted the world of C, allowing crafted input from untrusted sources to crash programs or execute third-party code within the process of a vulnerable program. While buffer overflows have been known since the 1970s, the first prominent example of their exploitation was the Morris worm, which included a buffer overflow exploit of the UNIX <code>finger</code> daemon.</p>
<p class="indent">Buffer overflows start by overwriting portions of memory. The basic memory layout of a process consists of the program code, any data the program needs to run, the stack, and the heap, as shown in <a href="ch11.html#ch11fig1">Figure 11-1</a>.</p>
<div class="image"><img alt="image" src="graphics/f11-01.jpg"/></div>
<p class="figcap"><a id="ch11fig1"/><em>Figure 11-1: Arrangement of process memory</em></p>
<p class="indent">The <em>code</em> segment (often referred to as the <em>text</em> segment) is where the program’s actual executable is loaded into memory. The <em>data</em> segment contains the program’s global variables and static local variables. The <em>heap</em> is where the bulk of nonexecutable program data will reside, in memory dynamically allocated by the program. The <em>stack</em> is where local variables are stored, as well as addresses of functions and, importantly, a pointer to the address that contains the next instructions that the program is to execute.</p>
<p class="indent">There are two basic types of overflows: those that overwrite portions of a program’s stack and those that overwrite portions of the heap. Let’s look at a buffer overflow vulnerability now.</p>
<h4 class="h4" id="ch11lev2sec03"><a id="page_194"/><em><strong>A strcpy Buffer Overflow</strong></em></h4>
<p class="noindent">A classic example of a stack-based buffer overflow is shown in <a href="ch11.html#ch11ex3">Listing 11-3</a>.</p>
<pre><span class="rose">#include</span> &lt;string.h&gt;<br/><br/>uid_t check_user(<span class="rose">char</span> *provided_uname, <span class="rose">char</span> *provided_pw) {<br/>    <span class="rose">char</span> password[32];<br/>    <span class="rose">char</span> username[32];<br/><br/>    strcpy(password, provided_pw);<br/>    strcpy(username, provided_uname);<br/><br/>    <span class="rose">struct</span> *passwd pw = getpwnam(username);<br/><br/>    <span class="rose">if</span> (0 != strcmp(crypt(password), pw-&gt;pw_passwd))<br/>        <span class="rose">return</span> -1;<br/><br/>    <span class="rose">return</span> pw-&gt;uid;<br/>}</pre>
<p class="listcap"><a id="ch11ex3"/><em>Listing 11-3: Code vulnerable to an overflow</em></p>
<p class="indent">Both <code>username</code> and <code>password</code> have been allocated 32 bytes. Under most circumstances, this program should function normally and compare the user-supplied password to the stored password since usernames and passwords tend to be less than 32 characters. However, when either value is supplied with an input that exceeds 32 characters, the additional characters start overwriting the memory adjacent to the variable on the stack, as illustrated in <a href="ch11.html#ch11fig2">Figure 11-2</a>. This means that an attacker can overwrite the return address of the function, specifying that the next thing to be executed is a blob of malicious code the attacker has placed in the current input or elsewhere in memory.</p>
<div class="image"><img alt="image" src="graphics/f11-02.jpg"/></div>
<p class="figcap"><a id="ch11fig2"/><em>Figure 11-2: Memory layout before and after an overflow</em></p>
<p class="indent"><a id="page_195"/>Since this example hardcodes a character limit and doesn’t check that the input is within the limit, attacker-controlled input can be longer than the receiving data structure allows. Data will overflow the bounds of that buffer and overwrite portions of memory that could allow for code execution.</p>
<h4 class="h4" id="ch11lev2sec04"><em><strong>Preventing Buffer Overflows</strong></em></h4>
<p class="noindent">There are a few ways to prevent buffer overflows, and most of them are pretty simple.</p>
<h5 class="h5" id="ch11lev3sec01"><strong>Checking Input Size Before Using It</strong></h5>
<p class="noindent">The easiest fix is to sanity check any input before loading it into a data structure. For example, vulnerable programs like the one in <a href="ch11.html#ch11ex3">Listing 11-3</a> often defend against buffer overflows by calculating the size of incoming data themselves, rather than trusting an externally supplied size to be the right length. This fix can be as simple as replacing the <code>strcpy</code> functions in <a href="ch11.html#ch11ex3">Listing 11-3</a> with <code>if</code> statements like this one:</p>
<pre><span class="rose">if</span> (strnlen(provided_pw, 32) &lt; strnlen(password, 32))<br/>    strcpy(password, provided_pw);</pre>
<p class="indent">Checking the size of the provided password with <code>sizeof</code> should ensure that any data exceeding the size of the buffer is rejected. Ideally of course, you wouldn’t be using statically sized buffers at all—higher level classes like <code>NSString</code> or <code>std::string</code> and their associated methods should take care of these kinds of issues for you.</p>
<h5 class="h5" id="ch11lev3sec02"><strong>Using Safer String APIs</strong></h5>
<p class="noindent">Another coding best practice that can protect you from buffer overflows is avoiding “known bad” APIs, such as the <code>strcpy</code> and <code>strcat</code> families. These copy data into a destination buffer without checking whether the destination can actually handle that much data, which is why adding a size check was so important in the previous section. <a href="ch11.html#ch11ex3">Listing 11-3</a> showed one bad use of <code>strcpy</code>; here’s an even simpler one:</p>
<pre><span class="rose">void</span> copythings(<span class="rose">char</span> *things) {<br/>    <span class="rose">char</span> buf[32];<br/>    strcpy(buf, things);<br/>}</pre>
<p class="indent">In this simple and obvious kind of buffer overflow vulnerability, the <code>buf</code> buffer is only 32 bytes long, and the argument <code>things</code> is copied into it. But this code never checks the size of the <code>things</code> buffer before attempting to copy it into <code>buf</code>. If any call this function passes in a buffer is larger than 32 bytes, the result will be a buffer overflow.</p>
<p class="indent"><a id="page_196"/>The safer way to copy and concatenate strings is to use the <code>strlcpy</code> and <code>strlcat</code> functions,<sup><a href="footnote.html#fn103" id="fn_103">4</a></sup> which take the size of the destination buffer as an argument, as follows:</p>
<pre><span class="rose">void</span> copythings(<span class="rose">char</span> *things) {<br/>    <span class="rose">char</span> buf[32];<br/>    length = strlcpy(buf, things, <span class="rose">sizeof</span>(buf));<br/>}</pre>
<p class="indent">Here, the <code>strlcpy</code> function will copy only 31 bytes of the source string, plus a null terminator. This may result in the string being truncated, but at least it won’t overflow the statically sized buffer. The <code>strl</code> family is not available on all platforms but is available on BSD-based systems, including iOS.</p>
<p class="indent">In addition to these types of overflows, errors can also be made when performing integer operations, which can lead to a denial of service or code execution.</p>
<h3 class="h3" id="ch11lev1sec03"><strong>Integer Overflows and the Heap</strong></h3>
<p class="noindent"><em>Integer overflows</em> result from performing a calculation that gives a value larger than the maximum size of an integer on a platform. As you likely know, there are two types of integers in C (and therefore, in Objective-C): signed and unsigned. Signed integers can be positive or negative, and unsigned integers are always positive. If you attempt to perform a calculation that overflows the value of either type of integers, badness occurs. An unsigned integer will wrap around past the maximum value of an integer, starting over at zero. If the integer is signed, it will start at a negative number, the minimum value of an unsigned integer. Here’s an example:</p>
<pre><span class="violet1">NSInteger</span> foo = 9223372036854775807;<br/><span class="violet1">NSLog(</span><span class="red">@"%li"</span><span class="violet1">,</span> (<span class="rose">long</span>)foo);<br/>foo++;<br/><span class="violet1">NSLog(</span><span class="red">@"%li"</span><span class="violet1">,</span> (<span class="rose">long</span>)foo);</pre>
<p class="indent">This starts with a signed integer <code>foo</code>, using the maximum size of a signed integer on iOS. When the number is incremented, the output on the console should wrap around to a negative number, <code>-9223372036854775808</code>.</p>
<p class="indent">If you were to use an unsigned integer as shown in the following example, you’d see the integer overflow, and the output on the console would be <code>0</code>:</p>
<pre><span class="violet1">NSUInteger foo = 18446744073709551615;<br/>NSLog(</span><span class="red">@"%lu"</span><span class="violet1">,</span> (<span class="rose">unsigned long</span><span class="violet1">)foo);</span><br/><span class="violet1">foo++;</span><br/><span class="violet1">NSLog(</span><span class="red">@"%lu"</span><span class="violet1">,</span> (<span class="rose">unsigned long</span><span class="violet1">)foo);</span></pre>
<p class="indent"><a id="page_197"/>While buffer overflows overwrite the stack, integer overflows give attackers access to the heap, and I’ll show you how that works next.</p>
<h4 class="h4" id="ch11lev2sec05"><em><strong>A malloc Integer Overflow</strong></em></h4>
<p class="noindent">An integer overflow most often causes issues when it occurs while calculating the necessary space to pass to a <code>malloc()</code> call, making the space allocated far too small to contain the value to store. When data is loaded into the newly allocated space, the data that won’t fit is written beyond the end of the allocated space, into the heap. This puts you in a heap overflow situation: if the attacker provides maliciously crafted data to <code>malloc()</code> and overwrites the right pointer in the heap, code execution can occur.</p>
<p class="indent">Integer overflow vulnerabilities tend to take the following form:</p>
<pre>   <span class="rose">#define</span> GOAT_NAME_LEN 32<br/><br/>   <span class="rose">typedef struct</span> Goat {<br/>     <span class="rose">int</span> leg_count;    <span class="green1"><span class="codeitalic">// usually 4</span></span><br/>     bool has_goatee;<br/>     <span class="rose">char</span> name[GOAT_NAME_LEN];<br/>     <span class="rose">struct</span> Goat* parent1;<br/>     <span class="rose">struct</span> Goat* parent2;<br/>     size_t kid_count;<br/>     <span class="rose">struct</span> Goat** kids;<br/>   } Goat;<br/><br/>   <span class="rose">int</span> ReadInt(<span class="rose">int</span> socket) {<br/>     <span class="rose">int</span> result;<br/>     read(socket, &amp;result, <span class="rose">sizeof</span>(result));<br/>     <span class="rose">return</span> result;<br/>   }<br/><br/>   <span class="rose">void</span> ReadGoat(Goat* goat, <span class="rose">int</span> socket) {<br/>     read(socket, goat, <span class="rose">sizeof</span>(Goat));<br/>   }<br/><br/>   Goat* ReadGoats(<span class="rose">int</span>* count, <span class="rose">int</span> socket) {<br/><span class="ent">➊</span>   *count = ReadInt(socket);<br/><span class="ent">➋</span>   Goat* goats = malloc(*count * <span class="rose">sizeof</span>(Goat));<br/><span class="ent">➌</span>   <span class="rose">for</span> (<span class="rose">int</span> i = 0; i &lt; *count; ++i) {<br/>       ReadGoat(&amp;goats[i], socket);<br/>     }<br/>     <span class="rose">return</span> goats;<br/>   }</pre>
<p class="indent"><a id="page_198"/>This code creates an object of type <code>Goat</code>, as well as the <code>ReadGoats</code> function, which accepts a socket and the number of goats to read from that socket. At <span class="ent">➊</span>, the <code>ReadInt</code> function reads the number of goats that will be processed from the socket itself.</p>
<p class="indent">If that number is sufficiently large, the <code>malloc()</code> operation at <span class="ent">➋</span> will result in a size so large that the integer wraps around to negative numbers. With the right value of <code>count</code>, an attacker could make the <code>malloc()</code> attempt to allocate zero bytes, or a very small number. When the loop at <span class="ent">➌</span> executes, it will read the number of goats from the socket that corresponds to the very large value of <code>count</code>. Because <code>goats</code> is small, this can overflow the allocated memory, allowing data to be written to the heap.</p>
<h4 class="h4" id="ch11lev2sec06"><em><strong>Preventing Integer Overflows</strong></em></h4>
<p class="noindent">There are several approaches to preventing integer overflows, but the basic idea is to check the values of integers before you operate on them. I suggest adopting the basic structure from Apple’s coding guide.<sup><a href="footnote.html#fn104" id="fn_104">5</a></sup> Here’s one example:</p>
<pre><span class="rose">if</span> (n &gt; 0 &amp;&amp; m &gt; 0 &amp;&amp; INT_MAX/n &gt;= m) {<br/>    size_t bytes = n * m;<br/>    foo = malloc(bytes);<br/>}</pre>
<p class="indent">Before calculating the value of <code>bytes</code>, this <code>if</code> statement checks that <code>n</code> and <code>m</code> are greater than 0 and divides one factor by a maximum size to make sure that the result is larger than the other factor. If both conditions are true, then you know that <code>bytes</code> will fit into an integer, and it should be safe to use it to allocate memory.</p>
<h3 class="h3" id="ch11lev1sec04"><strong>Closing Thoughts</strong></h3>
<p class="noindent">The list of C coding flaws in this chapter is far from exhaustive, but knowing some of these flaws should help you start spotting C-related issues in iOS applications. There are also many other resources that can help you hone your C security skills. If you’re interested in learning more about the intricacies of C and how it can go wrong, I recommend getting a copy of Peter van der Linden’s <em>Expert C Programming: Deep C Secrets</em> (Prentice Hall, 1994).</p>
<p class="indent">Now that I’ve aired some of the dirty laundry of C, let’s head back to Cocoa land and look at modern attacks derived largely from the field of web application security: injection attacks.</p>
</body></html>