<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_283"/><strong><span class="big">11</span><br/>SHORTCUTS AND APPROXIMATIONS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">So far, we’ve spent a lot of time looking at how to compute efficiently, especially with regard to memory usage. But there’s one thing that’s better than computing efficiently, and that’s not computing at all. This chapter looks at two ways to avoid computing: taking shortcuts and approximating.</p>
<p class="indent">We think of computers as very exact and precise. But, as we saw in “<a href="ch01.xhtml#ch01lev1sec6">Representing Real Numbers</a>” on <a href="ch01.xhtml#page_14">page 14</a>, they really aren’t. We can write code to be as exact as we want. For example, the UNIX <code>bc</code> utility is an arbitrary precision calculator that’s perfect if you need lots of accuracy, but it’s not a very efficient approach because computer hardware doesn’t support arbitrary precision. This leads to the question, how close is good enough for a particular application? Effective use of computing resources means not doing more work than necessary. Calculating all the digits of π before using it is just not rational!</p>
<h3 class="h3" id="ch11lev1sec1"><span epub:type="pagebreak" id="page_284"/><strong>Table Lookup</strong></h3>
<p class="noindent">Many times it’s simpler and faster to look something up in a table than to do a calculation. We’ll look at a few examples of this approach in the following subsections. Table lookup is similar to the loop-invariant optimization that was discussed in <a href="ch08.xhtml#ch08">Chapter 8</a> in that if you’re going to use something a lot, it often makes sense to calculate it once in advance.</p>
<h4 class="h4" id="ch11lev2sec1"><strong><em>Conversion</em></strong></h4>
<p class="noindent">Suppose we need to read a temperature sensor and display the result in tenths of a degree Celsius (°C). A clever hardware designer has given us a circuit that produces a voltage based on the measured temperature that we can read using an A/D converter (see “<a href="ch06.xhtml#ch06lev2sec15">Analog-to-Digital Conversion</a>” on <a href="ch06.xhtml#page_162">page 162</a>). The curve looks like <a href="ch11.xhtml#ch11fig01">Figure 11-1</a>.</p>
<div class="image"><a id="ch11fig01"/><img src="../images/11fig01.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-1: Temperature sensor curve</em></p>
<p class="indent">You can see that the curve is not a convenient straight line. We can calculate the temperature (t) from the voltage (v) using the following formula, where <em>A</em>, <em>B</em>, and <em>C</em> are constants determined by the particular model of sensor:</p>
<div class="equ-image"><img src="../images/eq284-01.jpg" alt="Image"/></div>
<p class="indent">As you can see, a lot of floating-point arithmetic is involved, including natural logarithms, which is costly. So let’s skip it all. Instead, let’s build a table that maps voltage values into temperatures. Suppose we have a 10-bit A/D and that 8 bits is enough to hold our temperature value. That means we only need a 1,024-byte table to eliminate all the calculation, as shown in <a href="ch11.xhtml#ch11fig02">Figure 11-2</a>.</p>
<div class="image"><a id="ch11fig02"/><img src="../images/11fig02.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-2: Table lookup conversion</em></p>
<h4 class="h4" id="ch11lev2sec2"><span epub:type="pagebreak" id="page_285"/><strong><em>Texture Mapping</em></strong></h4>
<p class="noindent">Table lookup is a mainstay of <em>texture mapping</em>, a technique that helps provide realistic-looking images in video games and movies. The idea behind it is that pasting an image onto an object such as a wall takes a lot less computation than algorithmically generating all the detail. This is all well and good, but it has its own issues. Let’s say we have a brick wall texture such as the one in <a href="ch11.xhtml#ch11fig03">Figure 11-3</a>.</p>
<div class="image"><a id="ch11fig03"/><img src="../images/11fig03.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-3: Brick wall texture</em></p>
<p class="indent">Looks pretty good. But video games aren’t static. You might be running away from a brick wall at high speed because you’re being chased by zombies. The appearance of the brick wall needs to change based on your distance from it. <a href="ch11.xhtml#ch11fig04">Figure 11-4</a> shows how the wall looks from a long distance away (on the left) and from very close (on the right).</p>
<div class="image"><a id="ch11fig04"/><img src="../images/11fig04.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-4: Brick wall texture at different distances</em></p>
<p class="indent">As you might expect, adjusting the texture for distance is a lot of work. As the viewpoint moves farther away from the texture, adjacent pixels must be averaged together. It’s important to be able to do this calculation quickly so that the image doesn’t jump around.</p>
<p class="indent">Lance Williams (1949–2017) at the New York Institute of Technology Graphics Language Laboratory devised a clever approach called <em>MIP mapping</em> (named from the Latin <em>multum in parvo</em>, meaning “many things in a small place”). His paper on this topic, entitled “Pyramidal Parametrics,” was published in the July 1983 SIGGRAPH proceedings. His method is still in use today, not only in software but also in hardware.</p>
<p class="indent"><span epub:type="pagebreak" id="page_286"/>As we saw in “<a href="ch01.xhtml#ch01lev1sec12">Representing Colors</a>” on <a href="ch01.xhtml#page_27">page 27</a>, a pixel has three 8-bit components, one each for red, green, and blue. Williams noticed that on 32-bit systems, a quarter of the space was left over when these components were arranged in a rectangular fashion, as shown in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a>.</p>
<div class="image"><a id="ch11fig05"/><img src="../images/11fig05.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-5: Color component arrangement with leftover space</em></p>
<p class="indent">He couldn’t just let that space go to waste, so he put it to good use in a different way than Tom Duff and Thomas Porter did (see “<a href="ch01.xhtml#ch01lev2sec18">Adding Transparency</a>” on <a href="ch01.xhtml#page_29">page 29</a>). Williams noticed that because it was one-fourth of the space, he could put a one-fourth-size copy of the image into that space, and then another one-fourth-size copy into <em>that</em> space, and so on, as shown in <a href="ch11.xhtml#ch11fig06">Figure 11-6</a>. He called this arrangment a MIP map.</p>
<div class="image"><a id="ch11fig06"/><img src="../images/11fig06.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-6: Multiple image layout</em></p>
<p class="indent">Making a MIP map out of our brick wall texture results in the image shown in <a href="ch11.xhtml#ch11fig07">Figure 11-7</a> (you’ll have to imagine the color components in this grayscale image).</p>
<div class="image"><a id="ch11fig07"/><img src="../images/11fig07.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-7: MIP mapped texture</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_287"/>As you can see, there’s a lot more detail in the closer-up images, where it’s important. This is interesting, but other than being a clever storage mechanism, what use is it? Take a look at <a href="ch11.xhtml#ch11fig08">Figure 11-8</a>, which unfolds one of the colors of the MIP map into a pyramid.</p>
<div class="image"><a id="ch11fig08"/><img src="../images/11fig08.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-8: MIP map pyramid</em></p>
<p class="indent">The image at the tip of the pyramid is what things look like from far away, and there’s more detail as we head toward the base. When we need to compute the actual texture to display for the position of the eye in <a href="ch11.xhtml#ch11fig08">Figure 11-8</a>, we don’t need to average together all the pixels in the base image; we just need to use the pixels in the nearest layer. This saves a lot of time, especially when the vantage point is far away.</p>
<p class="indent"><span epub:type="pagebreak" id="page_288"/>Precomputing information that’s going to be used a lot—in this case, the lower-resolution versions of the texture—is equivalent to loop-invariant optimization.</p>
<h4 class="h4" id="ch11lev2sec3"><strong><em>Character Classification</em></strong></h4>
<p class="noindent">Table lookup methods had a big influence on the addition of libraries to the programming language C. Back in <a href="ch08.xhtml#ch08">Chapter 8</a>, we saw that <em>character classification</em>—deciding which characters were letters, numbers, and so on—is an important part of lexical analysis. Going back to the ASCII code chart in <a href="ch01.xhtml#ch01tab10">Table 1-10</a>, you could easily write code to implement classification, such as that shown in <a href="ch11.xhtml#ch11list01">Listing 11-1</a>.</p>
<pre>int<br/>
isdigit(int c)<br/>
{<br/>
  return (c &gt;= '0' &amp;&amp; c &lt;= '9');<br/>
}<br/>
<br/>
int<br/>
ishexdigit(int c)<br/>
{<br/>
  return (c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'A' &amp;&amp; c &lt;= 'F' || c &gt;= 'a' &amp;&amp; c &lt;= 'f');<br/>
}<br/>
<br/>
int<br/>
isalpha(int c)<br/>
{<br/>
  return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z');<br/>
}<br/>
<br/>
int<br/>
isupper(int c)<br/>
{<br/>
  return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z');<br/>
}</pre>
<p class="listing" id="ch11list01"><em>Listing 11-1: Character classification code</em></p>
<p class="indent">Some at Bell Labs suggested putting commonly useful functions, such as the ones in <a href="ch11.xhtml#ch11list01">Listing 11-1</a>, into <em>libraries</em>. Dennis Ritchie (1941–2011) argued that people could easily write their own. But Nils-Peter Nelson in the computer center had written an implementation of these routines that used a table instead of a collection of <code>if</code> statements. The table was indexed by character value, and each entry in the table had bits for aspects like uppercase, lowercase, digit, and so forth, as shown in <a href="ch11.xhtml#ch11fig09">Figure 11-9</a>.</p>
<span epub:type="pagebreak" id="page_289"/>
<div class="image"><a id="ch11fig09"/><img src="../images/11fig09.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-9: Character classification table</em></p>
<p class="indent">Classification, in this case, involved looking up the value in the table and checking the bits, as shown in <a href="ch11.xhtml#ch11list02">Listing 11-2</a>.</p>
<pre>unsigned char table[128] = [ ... ];<br/>
<br/>
#define isdigit(c)    (table[(c) &amp; 0x7f] &amp; DIGIT)<br/>
#define ishexdigit(c) (table[(c) &amp; 0x7f] &amp; HEXADECIMAL)<br/>
#define isalpha(c)    (table[(c) &amp; 0x7f] &amp; (UPPER | LOWER))<br/>
#define isupper(c)    (table[(c) &amp; 0x7f] &amp; UPPER)</pre>
<p class="listing" id="ch11list02"><em>Listing 11-2: Table-driven character classification code</em></p>
<p class="indent">As you can see, the functions in <a href="ch11.xhtml#ch11list02">Listing 11-2</a> are simpler than those in <a href="ch11.xhtml#ch11list01">Listing 11-1</a>. And they have another nice property, which is that they’re all essentially the same code; the only difference is the value of the constants that are ANDed with the table contents. This approach was 20 times faster than what anybody else had done, so Ritchie gave in and these functions were added as a library, setting the stage for additional libraries.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_290"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You’ll notice that I use</em> macros <em>in <a href="ch11.xhtml#ch11list02">Listing 11-2</a> but</em> functions <em>in <a href="ch11.xhtml#ch11list01">Listing 11-1</a>. In case you haven’t seen macros before, they’re a language construct that substitutes the code on the right for the code on the left. So, if your source code included <span class="codeitalic">isupper('a')</span>, the language</em> preprocessor <em>would replace it with <span class="codeitalic">table[('a') &amp;</span> <span class="codeitalic">0x7f] &amp; UPPER</span>. This is great for small chunks of code because there’s no function call overhead. But the code in <a href="ch11.xhtml#ch11list01">Listing 11-1</a> couldn’t reasonably be implemented using macros because we have to handle the case where someone does <span class="codeitalic">isupper(*p++)</span>. If the code in <a href="ch11.xhtml#ch11list01">Listing 11-1</a> were implemented as macros, then in <span class="codeitalic">ishexdigit</span>, for example, <span class="codeitalic">p</span> would be incremented six times, which would be a surprise to the caller. The version in <a href="ch11.xhtml#ch11list02">Listing 11-2</a> references the argument only once, so that doesn’t happen.</em></p>
</div>
<h3 class="h3" id="ch11lev1sec2"><strong>Integer Methods</strong></h3>
<p class="noindent">It should be obvious from the earlier discussion of hardware that some operations are cheaper to perform in terms of speed and power consumption than others. Integer addition and subtraction are inexpensive. Multiplication and division cost more, although we can multiply and divide by 2 cheaply using shift operations. Floating-point operations are considerably more expensive. Complex floating-point operations, such as the calculation of trigonometric and logarithmic functions, are much more expensive. In keeping with the theme for this chapter, it would be best if we could find ways to avoid using the more expensive operations.</p>
<p class="indent">Let’s look at some visual examples. <a href="ch11.xhtml#ch11list03">Listing 11-3</a> modifies the web page skeleton from <a href="ch10.xhtml#ch10list01">Listing 10-1</a> to have <code>style</code>, a <code>script</code> fragment, and a <code>body</code>.</p>
<pre> 1 &lt;style&gt;<br/>
 2    canvas {<br/>
 3      border: 5px solid black;<br/>
 4    }<br/>
 5 &lt;/style&gt;<br/>
 6 ...<br/>
 7 &lt;script&gt;<br/>
 8    $(function() {<br/>
 9      var canvas = $('canvas')[0].getContext('2d');<br/>
10<br/>
11      // Get the canvas width and height.  Force them to be numbers<br/>
12      // because attr yields strings and JavaScript often produces<br/>
13      // unexpected results when using strings as numbers.<br/>
14<br/>
15      var height = Number($('canvas').attr('height'));<br/>
16      var width = Number($('canvas').attr('width'));<br/>
17<br/>
18      canvas.translate(0, height);<br/>
19      canvas.scale(1, -1);<br/>
20    });<br/>
21 &lt;/script&gt;<br/>
22 ...<br/>
23 &lt;body&gt;<br/>
24   &lt;canvas width="500" height="500"&gt;&lt;/canvas&gt;<br/>
25 &lt;/body&gt;</pre>
<p class="listing" id="ch11list03"><em>Listing 11-3: Basic canvas</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_291"/>I briefly mentioned canvases back in “<a href="ch09.xhtml#ch09lev1sec10">HTML5</a>” on <a href="ch09.xhtml#page_255">page 255</a>. A <em>canvas</em> is an element on which you can do free-form drawing. You can think of it as a piece of graph paper.</p>
<p class="indent">The canvas “graph paper” isn’t exactly what you’re used to because it doesn’t use the standard Cartesian coordinate system by default. This is an artifact of the direction in which the raster was drawn on televisions (see “<a href="ch06.xhtml#ch06lev2sec22">Raster Graphics</a>” on <a href="ch06.xhtml#page_180">page 180</a>); the raster starts at the upper left. The x-coordinate behaves normally, but the y-coordinate starts at the top and increases downward. This coordinate system was kept when television monitors were repurposed for computer graphics.</p>
<p class="indent">Modern computer graphics systems support arbitrary coordinate systems for which graphics hardware often includes support. A <em>transformation</em> is applied to every (<em>x</em>, <em>y</em>) coordinate you specify and maps your coordinates to the screen coordinates (<em>x′</em>, <em>y′</em>) using the following formulas:</p>
<p class="equation"><em>x</em>′ = <em>Ax</em> + <em>By</em> + <em>C</em></p>
<p class="equation"><em>y</em>′ = <em>Dx</em> + <em>Ey</em> + <em>F</em></p>
<p class="indent">The <em>C</em> and <em>F</em> terms provide <em>translation</em>, which means they move things around. The <em>A</em> and <em>E</em> terms provide <em>scaling</em>, which means they make things bigger and smaller. The <em>B</em> and <em>D</em> terms provide <em>rotation</em>, which means they change the orientation. These are often represented in matrix form.</p>
<p class="indent">For now, we just care about translation and scaling to convert the canvas coordinate system into a familiar one. We translate downward by the height of the canvas on line 13 and then flip the direction of the y-axis on line 14. The order matters; if we did these translations in the reverse order, the origin would be above the canvas.</p>
<p class="indent">Graphics are effectively created from blobs of primary colors plopped on a piece of graph paper (see “<a href="ch01.xhtml#ch01lev1sec12">Representing Colors</a>” on <a href="ch01.xhtml#page_27">page 27</a>). But how fine a piece of graph paper do we need? And how much control do we need over the color blob composition?</p>
<p class="indent">The <code>width</code> and <code>height</code> attributes on line 19 set the size of the <code>canvas</code> in pixels (see “<a href="ch06.xhtml#ch06lev2sec17">Digital Images</a>” on <a href="ch06.xhtml#page_173">page 173</a>). The <em>resolution</em> of the display is the number of pixels per inch (or per centimeter). The size of the canvas on your screen depends on the resolution of your screen. Unless it’s a real antique, you probably can’t see the individual pixels. (Note that the resolution of the human eye isn’t a constant across the field of vision; see “A Photon Accurate Model of the Human Eye,” Michael Deering, SIGGRAPH 2005.) Even though current UHD monitors are awesome, techniques such as supersampling are still needed to make things look really good.</p>
<p class="indent">We’ll start by drawing things at a very low resolution so we can see the details. Let’s make some graph paper by adding a JavaScript function that clears the canvas and draws a grid, as shown in <a href="ch11.xhtml#ch11list04">Listing 11-4</a>. We’ll also use a scaling transformation to get integer value grid intersections. The scale applies to everything drawn on the canvas, so we have to make the line width smaller.</p>
<span epub:type="pagebreak" id="page_292"/>
<pre> 1  var grid = 25;                                // 25 pixel grid spacing<br/>
 2<br/>
 3  canvas.scale(grid, grid);<br/>
 4  width = width / grid;<br/>
 5  height = height / grid;<br/>
 6  canvas.lineWidth = canvas.lineWidth / grid;<br/>
 7  canvas.strokeStyle = "rgb(0, 0, 0)";          // black<br/>
 8<br/>
 9  function<br/>
10  clear_and_draw_grid()<br/>
11  {<br/>
12    canvas.clearRect(0, 0, width, height);      // erase canvas<br/>
13    canvas.save(); // save canvas settings<br/>
14    canvas.setLineDash([0.1, 0.1]);             // dashed line<br/>
15    canvas.strokeStyle = "rgb(128, 128, 128)";  // gray<br/>
16    canvas.beginPath();<br/>
17<br/>
18    for (var i = 1; i &lt; height; i++) {          // horizontal lines<br/>
19      canvas.moveTo(0, i);<br/>
20      canvas.lineTo(height, i);<br/>
21    }<br/>
22<br/>
23    for (var i = 1; i &lt; width; i++) {           // vertical lines<br/>
24      canvas.moveTo(i, 0);<br/>
25      canvas.lineTo(i, width);<br/>
26    }<br/>
27<br/>
28    canvas.stroke();<br/>
29    canvas.restore();                           // restore canvas settings<br/>
30  }<br/>
31<br/>
32  clear_and_draw_grid();                        // call on start-up</pre>
<p class="listing" id="ch11list04"><em>Listing 11-4: Drawing a grid</em></p>
<h4 class="h4" id="ch11lev2sec4"><strong><em>Straight Lines</em></strong></h4>
<p class="noindent">Now let’s draw a couple of lines by placing colored circles on the grid in <a href="ch11.xhtml#ch11list05">Listing 11-5</a>. One line is horizontal, and the other has a slope of 45 degrees. The diagonal line blobs are slightly bigger so we can see both lines at the point where they intersect.</p>
<pre> 1  for (var i = 0; i &lt;= width; i++) {<br/>
 2    canvas.beginPath();<br/>
 3    canvas.fillStyle = "rgb(255, 255, 0)";     // yellow<br/>
 4    canvas.arc(i, i, 0.25, 0, 2 * Math.PI, 0);<br/>
 5    canvas.fill();<br/>
 6<br/>
 7    canvas.beginPath();<br/>
 8    canvas.fillStyle = "rgb(255, 0, 0)";       // red<br/>
 9    canvas.arc(i, 10, 0.2, 0, 2 * Math.PI, 0);<br/>
10    canvas.fill();<br/>
11  }</pre>
<p class="listing" id="ch11list05"><em>Listing 11-5: Horizontal and diagonal lines</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_293"/>As you can see in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a> and by running the program, the pixels are farther apart on the diagonal line than they are on the horizontal line (<img class="middle" src="../images/eq293-01.jpg" alt="Image"/> farther apart, according to Pythagoras). Why does this matter? Because both lines have the same number of pixels emitting light, but when the pixels are farther apart on the diagonal line, the light density is less, making it appear dimmer than the horizontal line. There’s not much you can do about it; designers of displays adjust the shape of the pixels to minimize this effect. It’s more of an issue on cheaper displays than on desktop monitors and phones.</p>
<div class="image"><a id="ch11fig10"/><img src="../images/11fig10.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-10: Pixel spacing</em></p>
<p class="indent">The horizontal, vertical, and diagonal lines are the easy cases. How do we decide what pixels to illuminate for other lines? Let’s make a line-drawing program. We’ll start by adding some controls after the <code>canvas</code> element in the <code>body</code>, as shown in <a href="ch11.xhtml#ch11list06">Listing 11-6</a>.</p>
<pre>1  &lt;div&gt;<br/>
2    &lt;label for="y"&gt;Y Coordinate: &lt;/label&gt;<br/>
3    &lt;input type="text" size="3" id="y"/&gt;<br/>
4    &lt;button id="draw"&gt;Draw&lt;/button&gt;<br/>
5    &lt;button id="erase"&gt;Erase&lt;/button&gt;<br/>
6  &lt;/div&gt;</pre>
<p class="listing" id="ch11list06"><em>Listing 11-6: Basic line-drawing program body</em></p>
<p class="indent">Then, in <a href="ch11.xhtml#ch11list07">Listing 11-7</a>, we’ll replace the code from <a href="ch11.xhtml#ch11list05">Listing 11-5</a> with event handlers for the <code>draw</code> and <code>erase</code> buttons. The <code>draw</code> function uses the dreaded <em>y</em> = <em>mx</em> + <em>b</em>, with <em>b</em> always being 0 in our case. Surprise! Some stuff from math is actually used.</p>
<pre> 1  $('#draw').click(function() {<br/>
 2    if ($('#y').val() &lt; 0 || $('#y').val() &gt; height) {<br/>
 3      alert('y value must be between 0 and ' + height);<br/>
 4    }<br/>
 5    else if (parseInt($('#y').val()) != $('#y').val()) {<br/>
 6      alert('y value must be an integer');<br/>
 7    }<br/>
 8    else {<br/>
 9      canvas.beginPath();                  // draw ideal line<br/>
10      canvas.moveTo(0, 0);<br/>
11      canvas.setLineDash([0.2, 0.2]);      // dashed line<br/>
12      canvas.lineTo(width, $('#y').val());<br/>
13      canvas.stroke();<br/>
14<br/>
15      var m = $('#y').val() / width;       // slope<br/>
<span epub:type="pagebreak" id="page_294"/>16<br/>
17      canvas.fillStyle = "rgb(0, 0, 0)";<br/>
18<br/>
19      for (var x = 0; x &lt;= width; x++) {   // draw dots on grid<br/>
20        canvas.beginPath();<br/>
21        canvas.arc(x, Math.round(x * m), 0.15, 0, 2 * Math.PI, 0);<br/>
22        canvas.fill();<br/>
23      }<br/>
24<br/>
25      $('#y').val('');                     // clear y value field<br/>
26    }<br/>
27  });<br/>
28<br/>
29  $('#erase').click(function() {<br/>
30    clear_and_draw_grid();<br/>
31  });</pre>
<p class="listing" id="ch11list07"><em>Listing 11-7: Floating-point line-drawing and erase functions</em></p>
<p class="indent">Let’s try this with a y-coordinate of 15. The result should look like <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>.</p>
<div class="image"><a id="ch11fig11"/><img src="../images/11fig11.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-11: Line drawn using floating-point arithmetic</em></p>
<p class="indent">This looks pretty bad, but if you stand way back, it looks like a line. It’s as close as we can get. This is not just a computer graphics problem, as anyone who does cross-stitching can tell you.</p>
<p class="indent">Although the program we just wrote works fine, it’s not very efficient. It’s performing floating-point multiplication and rounding at every point. That’s at least an order of magnitude slower than integer arithmetic, even on modern machines. We do get some performance from computing the slope once in advance (line 15). It’s a loop invariant, so there’s a good chance that an optimizer (see “<a href="ch08.xhtml#ch08lev1sec10">Optimization</a>” on <a href="ch08.xhtml#page_234">page 234</a>) would do this for you automatically.</p>
<p class="indent">Way back in 1962, when floating-point was cost-prohibitive, Jack Bresenham at IBM came up with a clever way to draw lines without using floating-point arithmetic. Bresenham brought his innovation to the IBM patent office, which didn’t see the value in it and declined to pursue a patent. Good thing, since it turned out to be a fundamental computer graphics algorithm, and the lack of a patent meant that everybody could use it. <span epub:type="pagebreak" id="page_295"/>Bresenham recognized that the line-drawing problem could be approached incrementally. Because we’re calculating <code>y</code> at each successive <code>x</code>, we can just add the slope (line 9 in <a href="ch11.xhtml#ch11list08">Listing 11-8</a>) each time through, which eliminates the multiplication. That’s not something an optimizer is likely to catch; it’s essentially a complex strength-reduction.</p>
<pre> 1  var y = 0;<br/>
 2<br/>
 3  canvas.fillStyle = "rgb(0, 0, 0)";<br/>
 4<br/>
 5  for (var x = 0; x &lt;= width; x++) {         // draw dots on grid<br/>
 6    canvas.beginPath();<br/>
 7    canvas.arc(x, Math.round(y), 0.15, 0, 2 * Math.PI, 0);<br/>
 8    canvas.fill();<br/>
 9    y = y + m;<br/>
10  }</pre>
<p class="listing" id="ch11list08"><em>Listing 11-8: Incrementally calculating <span class="codeitalic">y</span></em></p>
<p class="indent">We need floating-point arithmetic because the slope <img class="middle" src="../images/eq295-01.jpg" alt="Image"/> is a fraction. But the division can be replaced with addition and subtraction. We can have a <em>decision variable</em> <code>d</code> and add Δ<em>y</em> on each iteration. The <code>y</code> value is incremented whenever <code>d</code> ≥ Δ<em>x</em>, and then we subtract Δ<em>x</em> from <code>d</code>.</p>
<p class="indent">There is one last issue: rounding. We want to choose points in the middle of pixels, not at the bottom of them. That’s easy to handle by setting the initial value of <code>d</code> to ½<em>m</em> instead of 0. But we don’t want to introduce a fraction. No problem: we’ll just get rid of the ½ by multiplying it and everything else by 2 using 2Δ<em>y</em> and 2Δ<em>x</em> instead.</p>
<p class="indent">Replace the code that draws the dots on the grid with <a href="ch11.xhtml#ch11list09">Listing 11-9</a>’s “integer-only” version (we have no control over whether JavaScript uses integers internally, unlike in a language like C). Note that this code works only for lines with slopes in the range of 0 to 1. I’ll leave making it work for all slopes as an exercise for you.</p>
<pre> 1  var dx = width;<br/>
 2  var dy = $('#y').val();<br/>
 3  var d = 2 * dy - dx;<br/>
 4  var y = 0;<br/>
 5<br/>
 6  dx *= 2;<br/>
 7  dy *= 2;<br/>
 8<br/>
 9  canvas.fillStyle = "rgb(255, 255, 0)";<br/>
10  canvas.setLineDash([0,0]);<br/>
11<br/>
12  for (var x = 0; x &lt;= width; x++) {<br/>
13    canvas.beginPath();<br/>
14    canvas.arc(x, y, 0.4, 0, 2 * Math.PI, 0);<br/>
15    canvas.stroke();<br/>
16<br/>
17    if (d &gt;= 0) {<br/>
18      y++;<br/>
19      d -= dx;<br/>
<span epub:type="pagebreak" id="page_296"/>20    }<br/>
21    d += dy;<br/>
22  }</pre>
<p class="listing" id="ch11list09"><em>Listing 11-9: Integer line drawing</em></p>
<p class="indent">One interesting question that arises from <a href="ch11.xhtml#ch11list09">Listing 11-9</a> is, why isn’t the decision arithmetic written as shown in <a href="ch11.xhtml#ch11list10">Listing 11-10</a>?</p>
<pre>1  var dy_minus_dx = dy - dx;<br/>
2<br/>
3  if (d &gt;= 0) {<br/>
4    y++;<br/>
5    d -= dy_minus_dx;<br/>
6  }<br/>
7  else {<br/>
8    d += dy;<br/>
9  }</pre>
<p class="listing" id="ch11list10"><em>Listing 11-10: Alternate decision code</em></p>
<p class="indent">At first glance, this approach seems better because there’s only one addition to the decision variable per iteration. <a href="ch11.xhtml#ch11list11">Listing 11-11</a> shows how this might appear in some hypothetical assembly language such as the one from <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>
<pre>        load    d                       load    d<br/>
        cmp     #0                      cmp     #0<br/>
        blt     a                       blt     a<br/>
        load    y                       load    y<br/>
        add     #1                      add     #1<br/>
        store   y                       store   y<br/>
        load    d                       load    d<br/>
        sub     dx_plus_dy              sub     dx<br/>
        bra     b<br/>
a:      add     dy              a:      add     dy<br/>
        store   d                       store   d<br/>
b:      ...                             ...</pre>
<p class="listing" id="ch11list11"><em>Listing 11-11: Alternate decision code assembly language</em></p>
<p class="indent">Notice that the alternate version is one instruction longer than the original. And in most machines, integer addition takes the same amount of time as a branch. Thus, the code we thought would be better is actually one instruction time slower whenever we need to increment <code>y</code>.</p>
<p class="indent">The technique used in Bresenham’s line algorithm can be applied to a large variety of other problems. For example, you can produce a smoothly changing color <em>gradient</em>, such as that shown in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>, by replacing <code>y</code> with a color value.</p>
<span epub:type="pagebreak" id="page_297"/>
<div class="image"><a id="ch11fig12"/><img src="../images/11fig12.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-12: Color gradient</em></p>
<p class="indent">The gradient in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> was generated using the code shown in <a href="ch11.xhtml#ch11list12">Listing 11-12</a> in the document ready function.</p>
<pre> 1  var canvas = $('canvas')[0].getContext('2d');<br/>
 2  var width = $('canvas').attr('width');<br/>
 3  var height = $('canvas').attr('height');<br/>
 4<br/>
 5  canvas.translate(0, height);<br/>
 6  canvas.scale(1, -1);<br/>
 7<br/>
 8  var m = $('#y').val() / width;<br/>
 9<br/>
10  var dx = width;<br/>
11  var dc = 255;<br/>
12  var d = 2 * dc - dx;<br/>
13  var color = 0;<br/>
14<br/>
15  for (var x = 0; x &lt;= width; x++) {<br/>
16    canvas.beginPath();<br/>
17    canvas.strokeStyle = "rgb(" + color + "," + color + "," + color + ")";<br/>
18    canvas.moveTo(x, 0)<br/>
19    canvas.lineTo(x, height);<br/>
20    canvas.stroke();<br/>
21<br/>
22    if (d &gt;= 0) {<br/>
23      color++;<br/>
24      d -= 2 * dx;<br/>
25    }<br/>
26    d += 2 * dc;<br/>
27  }</pre>
<p class="listing" id="ch11list12"><em>Listing 11-12: Color gradient code</em></p>
<h4 class="h4" id="ch11lev2sec5"><span epub:type="pagebreak" id="page_298"/><strong><em>Curves Ahead</em></strong></h4>
<p class="noindent">Integer methods aren’t limited to straight lines. Let’s draw an ellipse. We’ll stick to the simple case of ellipses whose axes are aligned with the coordinate axes and whose center is at the origin. They’re defined by the following equation, where <em>a</em> is one-half the width and <em>b</em> is one-half the height:</p>
<div class="equ-image"><img src="../images/eq298-01.jpg" alt="Image"/></div>
<p class="indent">Assuming that we’re at the solid black point in <a href="ch11.xhtml#ch11fig13">Figure 11-13</a>, we need to decide which of the three possible next points is closest to the ideal ellipse.</p>
<div class="image"><a id="ch11fig13"/><img src="../images/11fig13.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-13: Ellipse decision points</em></p>
<p class="indent">Defining <em>A</em> = <em>b</em><sup>2</sup> and <em>B</em> = <em>a</em><sup>2</sup>, we can rearrange the ellipse equation as <em>Ax</em><sup>2</sup> + <em>By</em><sup>2</sup> – <em>AB</em> = 0. We won’t be able to satisfy this equation most of the time because the points we need to draw on the integer grid aren’t likely to be the same as those on the ideal ellipse. When we’re at (<em>x</em>, <em>y</em>), we want to choose our next point to be the one in which <em>Ax</em><sup>2</sup> + <em>By</em><sup>2</sup> – <em>AB</em> is closest to 0. And we’d like to be able to do it without the seven multiplications in that equation.</p>
<p class="indent">Our approach is to calculate the value of the equation at each of the three possible points and then choose the point where the equation value is closest to 0. In other words, we’ll calculate a distance variable <em>d</em> at each of the three points using <em>d</em> = <em>Ax</em><sup>2</sup> + <em>By</em><sup>2</sup> – <em>AB</em>.</p>
<p class="indent">Let’s start by figuring out how to calculate <em>d</em> at the point (<em>x</em> + 1, <em>y</em>) without the multiplications. We can plug (<em>x</em> + 1) into the equation for <em>x</em>, as follows:</p>
<p class="equation"><em>d</em><sub><em>x</em>+1</sub> = <em>A</em>(<em>x</em> + 1)<sup>2</sup> + <em>By</em><sup>2</sup> – <em>AB</em></p>
<p class="indent">Of course, squaring something is just multiplying it by itself:</p>
<p class="equation"><em>d</em><sub><em>x</em>+1</sub> = <em>A</em>(<em>x</em> + 1)(<em>x</em> + 1) + <em>By</em><sup>2</sup> – <em>AB</em></p>
<p class="indent">Multiplying it all out, we get:</p>
<p class="equation"><em>d</em><sub><em>x</em>+1</sub> = <em>x</em><sup>2</sup> + 2<em>Ax</em> + <em>A</em> + <em>By</em><sup>2</sup> – <em>AB</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_299"/>Now, if we subtract that from the original equation, we see that the difference between the equation at <em>x</em> and <em>x</em> + 1 is:</p>
<p class="equation"><em>dx</em> = 2<em>Ax</em> + <em>A</em></p>
<p class="indent">We can add <em>dx</em> to <em>d</em> to get <em>d<sub>x</sub></em> <sub>+ 1</sub>. That doesn’t quite get us where we want to be, though, because there’s still a multiplication. So let’s evaluate <em>dx</em> at <em>x</em> + 1:</p>
<p class="equation"><em>dx</em><sub><em>x</em>+1</sub> = 2<em>A</em>(<em>x</em> + 1) + <em>A</em></p>
<p class="equation"><em>dx</em><sub><em>x</em>+1</sub> = 2<em>Ax</em> + 2<em>A</em> + <em>A</em></p>
<p class="indent">Just like before, subtraction gives us:</p>
<p class="equation"><em>d</em>2<em>x</em> = 2<em>A</em></p>
<p class="indent">This yields a constant, which makes it easy to calculate <em>d</em> at (<em>x</em> + 1, <em>y</em>) without multiplication by using the intermediates <em>dx</em> and <em>d</em>2<em>x</em>:</p>
<p class="equation">2<em>A</em><sub><em>x</em>+1</sub> = 2<em>Ax</em> + <em>d</em>2<em>x</em></p>
<p class="indent">That gets us the horizontal direction—the vertical is almost identical, except there’s a sign difference since we’re going in the –<em>y</em> direction:</p>
<p class="equation"><em>dy</em> = –2<em>By</em> + <em>B</em></p>
<p class="equation"><em>d</em>2<em>y</em> = 2<em>B</em></p>
<p class="indent">Now that we have all these terms, deciding which of the three points is closest to the ideal curve is simple. We calculate the horizontal difference <em>dh</em> to point (<em>x</em> + 1, <em>y</em>), the vertical difference <em>dv</em> to the point (<em>x</em>, <em>y</em> – 1), and the diagonal difference <em>dd</em> to the point (<em>x</em> + 1, <em>y</em> – 1) and choose the smallest. Note that although <em>dx</em> is always positive, <em>dv</em> and <em>dd</em> can be negative, so we need to take their absolute value before comparing, as shown in <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>.</p>
<p class="indent">Our ellipse-drawing algorithm draws the ellipse only in the first quadrant. That’s okay because there’s another trick that we can use: symmetry. We know that each quadrant of the ellipse looks the same as the first; it’s just flipped horizontally, vertically, or both. We could draw the whole ellipse by drawing (–<em>x</em>, <em>y</em>), (–<em>x</em>, –<em>y</em>), and (<em>x</em>, –<em>y</em>) in addition to drawing (<em>x</em>, <em>y</em>). Note that we could use eight-way symmetry if we were drawing circles.</p>
<span epub:type="pagebreak" id="page_300"/>
<div class="image"><a id="ch11fig14"/><img src="../images/11fig14.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-14: Ellipse-drawing algorithm</em></p>
<p class="indent">This algorithm includes some comparisons that could be simplified, which result from drawing one-quarter of the ellipse. The one-quarter ellipse could be partitioned into two sections at the point where the slope of the curve is 1. By doing so, we’d have one piece of code that only had to decide between horizontal and diagonal movements and another that had to decide between vertical and diagonal movements. Which one got executed first would depend on the values of <em>a</em> and <em>b</em>. But a lot more time is spent inside the loop making decisions than in the setup, so it’s a good trade-off.</p>
<p class="indent">The preceding algorithm has one serious deficiency: because it starts from the half-width (<em>a</em>) and half-height (<em>b</em>), it can draw only ellipses that are odd numbers of pixels in width and height, since the result is 2<em>a</em> wide and 2<em>b</em> high plus 1 for the axes.</p>
<h4 class="h4" id="ch11lev2sec6"><span epub:type="pagebreak" id="page_301"/><strong><em>Polynomials</em></strong></h4>
<p class="noindent">The method we used to draw ellipses by incrementally calculating differences doesn’t scale well beyond conic sections (squared things). That’s because higher-order equations can do strange things, such as change direction several times within the space of a single pixel—which is pretty hard to test for efficiently.</p>
<p class="indent">But incrementally calculating differences can be generalized to any polynomials of the form <em>y</em> = <em>Ax</em><sup>0</sup> + <em>Bx</em><sup>1</sup> + <em>Cx</em><sup>2</sup> + . . . <em>Dx<sup>n</sup></em>. All we have to do is generate <em>n</em> sets of differences so that we start our accumulated additions with a constant. This works because, unlike with the ellipse-drawing code, the polynomials have only a single independent variable. You may remember Charles Babbage’s difference engine from “<a href="ch02.xhtml#ch02lev1sec1">The Case for Digital Computers</a>” on <a href="ch02.xhtml#page_34">page 34</a>. It was designed to do just this: evaluate equations using incremental differences.</p>
<h3 class="h3" id="ch11lev1sec3"><strong>Recursive Subdivision</strong></h3>
<p class="noindent">We touched briefly on <em>recursive subdivision</em> back in “<a href="ch05.xhtml#ch05lev1sec3">Stacks</a>” on <a href="ch05.xhtml#page_122">page 122</a>. It’s a technique with many uses. In this section, we’ll examine how to use it to get by with the minimum amount of work.</p>
<h4 class="h4" id="ch11lev2sec7"><strong><em>Spirals</em></strong></h4>
<p class="noindent">Our line-drawing code can be leveraged for more complicated curves. We can calculate some points and connect them together using lines.</p>
<p class="indent">Your math class has probably covered the measurement of angles in degrees, so you know that there are 360 degrees in a circle. You may not be aware that there are other systems of measurement. A commonly used one is <em>radians</em>. There are 2π radians in a circle. So 360 degrees is 2π radians, 180 degrees is π radians, 90 degrees is π/2 radians, 45 degrees is π/4 radians, and so on. You need to know this because many trigonometric functions available in math libraries, such as the ones in JavaScript, expect angles in radians instead of degrees.</p>
<p class="indent">We’ll use curves drawn in polar coordinates for our examples because they’re pretty. Just in case you haven’t learned this yet, <em>polar coordinates</em> use radius <em>r</em> and angle θ instead of <em>x</em> and <em>y</em>. Conversion to Cartesian coordinates is easy: <em>x</em> = <em>r</em>cosθ and <em>y</em> = <em>r</em>sinθ. Our first example draws a spiral using <em>r</em> = θ × 10; the point that we draw gets farther away from the center as we sweep through the angles. We’ll make the input in degrees because it’s not as intuitive for many people to think in radians. <a href="ch11.xhtml#ch11list13">Listing 11-13</a> shows the body for the controls.</p>
<pre>&lt;canvas width="500" height="500"&gt;&lt;/canvas&gt;<br/>
&lt;div&gt;<br/>
  &lt;label for="degrees"&gt;Degrees: &lt;/label&gt;<br/>
  &lt;input type="text" size="3" id="degrees"/&gt;<br/>
  &lt;button id="draw"&gt;Draw&lt;/button&gt;<br/>
  &lt;button id="erase"&gt;Erase&lt;/button&gt;<br/>
&lt;/div&gt;</pre>
<p class="listing" id="ch11list13"><em>Listing 11-13: Spiral body</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_302"/>We’ll skip the grid here because we need to draw more detail. Because we’re doing polar coordinates, <a href="ch11.xhtml#ch11list14">Listing 11-14</a> puts (0, 0) at the center.</p>
<pre>canvas.scale(1, -1);<br/>
canvas.translate(width / 2, -height / 2);<br/>
<br/>
$('#erase').click(function() {<br/>
  canvas.clearRect(-width, -height, width * 2, height * 2);<br/>
});<br/>
<br/>
$('#draw').click(function() {<br/>
  if (parseFloat($('#degrees').val()) == 0)<br/>
    alert('Degrees must be greater than 0');<br/>
  else {<br/>
    for (var angle = 0; angle &lt; 4 * 360; angle += parseFloat($('#degrees').val())) {<br/>
      var theta = 2 * Math.PI * angle / 360;<br/>
      var r = theta * 10;<br/>
      canvas.beginPath();<br/>
      canvas.arc(r * Math.cos(theta), r * Math.sin(theta), 3, 0, 2 * Math.PI, 0);<br/>
      canvas.fill();<br/>
    }<br/>
  }<br/>
});</pre>
<p class="listing" id="ch11list14"><em>Listing 11-14: Dotted spiral JavaScript</em></p>
<p class="indent">Enter a value of 10 for degrees and click Draw. You should see something like <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>.</p>
<p class="indent">Notice that the dots get farther apart as we get farther from the origin, even though they overlap near the center. We could make the value of degrees small enough that we’d get a good-looking curve, but that means we’d have a lot of points that overlap, which is a lot slower, and it’s difficult to guess the value needed for an arbitrary function.</p>
<p class="indent">Let’s try drawing lines between the points. Swap in <a href="ch11.xhtml#ch11list15">Listing 11-15</a> for the drawing code.</p>
<div class="image"><a id="ch11fig15"/><img src="../images/11fig15.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-15: Dotted spiral</em></p>
<pre>canvas.beginPath();<br/>
canvas.moveTo(0, 0);<br/>
<br/>
for (var angle = 0; angle &lt; 4 * 360; angle += parseFloat($('#degrees').val())) {<br/>
  var theta = 2 * Math.PI * angle / 360;<br/>
  var r = theta * 10;<br/>
  canvas.lineTo(r * Math.cos(theta), r * Math.sin(theta));<br/>
}<br/>
<br/>
canvas.stroke();</pre>
<p class="listing" id="ch11list15"><em>Listing 11-15: Spiral line JavaScript</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_303"/>Enter a value of 20 for degrees and click Draw. <a href="ch11.xhtml#ch11fig16">Figure 11-16</a> shows what you should see.</p>
<p class="indent">Not very pretty. Again, it looks good near the center but gets worse as we progress outward. We need some way to compute more points as needed—which is where our old friend recursive subdivision comes into play. We’re drawing lines using the spiral function between two angles, θ<sub>1</sub> and θ<sub>2</sub>. What we’ll do is have some <em>close enough</em> criterion, and if a pair of points is not close enough, we’ll halve the difference in the angles and try again until we do get close enough. We’ll use the <em>distance formula</em> <img class="middle" src="../images/eq303-01.jpg" alt="Image"/> to find the distance between points, as shown in <a href="ch11.xhtml#ch11list16">Listing 11-16</a>.</p>
<div class="image"><a id="ch11fig16"/><img src="../images/11fig16.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-16: Spiral line</em></p>
<pre>var close_enough = 10;<br/>
<br/>
function<br/>
plot(theta_1, theta_2)<br/>
{<br/>
  var r;<br/>
<br/>
  r = theta_1 * 10;<br/>
  var x1 = r * Math.cos(theta_1);<br/>
  var y1 = r * Math.sin(theta_1);<br/>
<br/>
  r = theta_2 * 10;<br/>
  var x2 = r * Math.cos(theta_2);<br/>
  var y2 = r * Math.sin(theta_2);<br/>
<br/>
  if (Math.sqrt(((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))) &lt; close_enough) {<br/>
    canvas.moveTo(x1, y1);<br/>
    canvas.lineTo(x2, y2);<br/>
  }<br/>
  else {<br/>
    plot(theta_1, theta_1 + (theta_2 - theta_1) / 2);<br/>
    plot(theta_1 + (theta_2 - theta_1) / 2, theta_2);<br/>
  }<br/>
}<br/>
<br/>
$('#draw').click(function() {<br/>
  if (parseFloat($('#degrees').val()) == 0)<br/>
    alert('Degrees must be greater than 0');<br/>
  else {<br/>
    canvas.beginPath();<br/>
<br/>
    for (var angle = 0; angle &lt; 4 * 360; angle += parseFloat($('#degrees').val())) {<br/>
      var old_theta;<br/>
      var theta = 2 * Math.PI * angle / 360;<br/>
<span epub:type="pagebreak" id="page_304"/>      if (angle &gt; 0)<br/>
        plot(old_theta, theta);<br/>
      old_theta = theta;<br/>
    }<br/>
  }<br/>
<br/>
  canvas.stroke();<br/>
});</pre>
<p class="listing" id="ch11list16"><em>Listing 11-16: Recursive spiral line JavaScript</em></p>
<p class="indent">You’ll notice that as long as <code>close_enough</code> is small enough, the size of the increment in degrees doesn’t matter because the code automatically generates as many intermediate angles as needed. Play around with different values for <code>close_enough</code>; maybe add an input field so that it’s easy to do.</p>
<p class="indent">The determination of close enough is very important for certain applications. Though it’s beyond the scope of this book, think about curved objects that you’ve seen in movies. Shining light on them makes them look more realistic. Now imagine a mirrored sphere approximated by some number of flat faces just like the spiral was approximated by line segments. If the flat faces aren’t small enough, it turns into a disco ball (a set of flat surfaces approximating a sphere), which reflects light in a completely different manner.</p>
<h4 class="h4" id="ch11lev2sec8"><strong><em>Constructive Geometry</em></strong></h4>
<p class="noindent"><a href="ch05.xhtml#ch05">Chapter 5</a> briefly mentioned quadtrees and showed how they could represent shapes. They’re an obvious use of recursion because they’re a hierarchical mechanism for dividing up space.</p>
<p class="indent">We can perform Boolean operations on quadtrees. Let’s say we want to design something like the engine gasket in <a href="ch11.xhtml#ch11fig17">Figure 11-17</a>.</p>
<div class="image"><a id="ch11fig17"/><img src="../images/11fig17.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-17: Engine gasket</em></p>
<p class="indent">We’ll need a data structure for a quadtree node, plus two special leaf values—one for 0, which we’re coloring white, and one for 1, which we’re coloring black. <a href="ch11.xhtml#ch11fig18">Figure 11-18</a> shows a structure and the data it represents. Each node can reference four other nodes, which is a good use for pointers in languages such as C.</p>
<span epub:type="pagebreak" id="page_305"/>
<div class="image"><a id="ch11fig18"/><img src="../images/11fig18.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-18: Quadtree node</em></p>
<p class="indent">We don’t need to keep track of the size of a node. All operations start from the root, the size of which is known, and each child node is one-quarter the size of its parent. <a href="ch11.xhtml#ch11fig19">Figure 11-19</a> shows us how to get the value at a location in the tree.</p>
<div class="image"><a id="ch11fig19"/><img src="../images/11fig19.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-19: Get value of (</em>x, y<em>) coordinate in quadtree</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_306"/><a href="ch11.xhtml#ch11fig20">Figure 11-20</a> shows how we would set the value of (that is, make black) an (<em>x</em>, <em>y</em>) coordinate in a quadtree. Note that “done” means “return from the function” since it’s recursive.</p>
<div class="image"><a id="ch11fig20"/><img src="../images/11fig20.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-20: Set value of (</em>x, y<em>) coordinate in quadtree</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_307"/>This is similar to the value-getting code in <a href="ch11.xhtml#ch11fig19">Figure 11-19</a>. At a high level, it descends the tree, subdividing as it goes, until it reaches the 1×1 square for the (<em>x</em>, <em>y</em>) coordinate and sets it to black. Any time it hits a white node, it replaces it with a new node having four white children so there’s a tree to keep descending. On the way back up, any nodes having all black children are replaced by a black node. This happens any time a node with three black children has the fourth set to black, as shown in <a href="ch11.xhtml#ch11fig21">Figure 11-21</a>.</p>
<div class="image"><a id="ch11fig21"/><img src="../images/11fig21.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-21: Coalescing a node</em></p>
<p class="indent">Coalescing nodes not only makes the tree take less memory, but it also makes many operations on the tree faster because it’s not as deep.</p>
<p class="indent">We need a way to clear (that is, make white) the value of an (<em>x</em>, <em>y</em>) coordinate in a quadtree. The answer is fairly similar to the setting algorithm. The differences are that we partition black nodes instead of white ones and we coalesce white nodes instead of black ones.</p>
<p class="indent">We can build some more complicated drawing functions on top of our value-setting function. It’s easy to draw rectangles by invoking the set function for each coordinate. We can do the same for ellipses using the algorithm from “<a href="ch11.xhtml#ch11lev2sec5">Curves Ahead</a>” on <a href="ch11.xhtml#page_298">page 298</a> and symmetry.</p>
<p class="indent">Now for the fun stuff. Let’s create quadtree versions for some of our Boolean logic functions from <a href="ch01.xhtml#ch01">Chapter 1</a>. The NOT function is simple: just descend the tree and replace any black nodes with white ones and vice versa. The AND and OR functions in <a href="ch11.xhtml#ch11fig22">Figure 11-22</a> are more interesting. These algorithms aren’t designed to perform the equivalents of <em>C</em> = <em>a</em> AND <em>b</em> and <em>C</em> = <em>a</em> OR <em>b</em>. Instead, they implement <em>dst</em> &amp;= <em>src</em> and <em>dst</em> |= <em>src</em>, as in the assignment operators found in many languages. The <em>dst</em> operand is the one modified.</p>
<span epub:type="pagebreak" id="page_308"/>
<div class="image"><a id="ch11fig22"/><img src="../images/11fig22.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-22: Quadtree AND and OR functions</em></p>
<p class="indent">Now that we have all these tools, let’s build our gasket. We’ll do it at low resolution so the details are visible. We’ll start with an empty gasket quadtree on the left and a scratch quadtree in the center in which we draw a big circle. The scratch quadtree is OR’d with the gasket, producing the result on the right as shown in <a href="ch11.xhtml#ch11fig23">Figure 11-23</a>. Note how the coalescing keeps the number of subdivisions to a minimum.</p>
<span epub:type="pagebreak" id="page_309"/>
<div class="image"><a id="ch11fig23"/><img src="../images/11fig23.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-23: Gasket, circle, circle OR gasket</em></p>
<p class="indent">Next we’ll make another circle in a different position and combine it with the partially completed gasket, as shown in <a href="ch11.xhtml#ch11fig24">Figure 11-24</a>.</p>
<div class="image"><a id="ch11fig24"/><img src="../images/11fig24.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-24: Adding to the gasket</em></p>
<p class="indent">Continuing on, we’ll make a black rectangle and combine it with the gasket, as shown in <a href="ch11.xhtml#ch11fig25">Figure 11-25</a>.</p>
<div class="image"><a id="ch11fig25"/><img src="../images/11fig25.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-25: Adding the rectangle</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_310"/>The next step is to make a hole. This is accomplished by making a black circle and then inverting it using the NOT operation to make it white. The result is then ANDed with the partially completed gasket, resulting in the hole as seen in <a href="ch11.xhtml#ch11fig26">Figure 11-26</a>.</p>
<div class="image"><a id="ch11fig26"/><img src="../images/11fig26.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-26: ANDing a NOT-hole</em></p>
<p class="indent">It’s getting boring at this point. We need to combine another hole, in the same way as shown in <a href="ch11.xhtml#ch11fig26">Figure 11-26</a>, and then eight smaller holes in a similar fashion. You can see the result in <a href="ch11.xhtml#ch11fig27">Figure 11-27</a>.</p>
<div class="image"><a id="ch11fig27"/><img src="../images/11fig27.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-27: Completed gasket</em></p>
<p class="indent">As you can see, we can use Boolean functions on quadtrees to construct objects with complicated shapes out of simple geometric pieces. Although we used a two-dimensional gasket as our example, this is more commonly done in three dimensions. Twice as many nodes are needed for three dimensions, so the quadtree is extended into an <em>octree</em>, an example of which is shown in <a href="ch11.xhtml#ch11fig28">Figure 11-28</a>.</p>
<p class="indent">Building complex objects in three dimensions using the preceding techniques is called <em>constructive solid geometry</em>. The three-dimensional counterpart to a two-dimensional pixel is called a <em>voxel</em>, which sort of means “volume pixel.”</p>
<span epub:type="pagebreak" id="page_311"/>
<div class="image"><a id="ch11fig28"/><img src="../images/11fig28.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-28: Octree</em></p>
<p class="indent">Octrees are a common storage method for CAT scan and MRI data. These machines generate a stack of 2D slices. It’s a simple matter to peel away layers to obtain cutaway views.</p>
<h4 class="h4" id="ch11lev2sec9"><strong><em>Shifting and Masking</em></strong></h4>
<p class="noindent">One of the downsides of quadtrees is that the data is scattered around memory; they have terrible locality of reference. Just because two squares are next to each other in the tree doesn’t mean they’re anywhere near each other in memory. This becomes a problem when we have to convert data from one memory organization to another. We could always move data 1 bit at a time, but that would involve a large number of memory accesses—which we want to minimize, because they’re slow.</p>
<p class="indent">One task where this situation arises is displaying data. That’s because the display memory organization is determined by the hardware. As mentioned back in “<a href="ch06.xhtml#ch06lev2sec22">Raster Graphics</a>” on <a href="ch06.xhtml#page_180">page 180</a>, each row of the raster is painted one at a time in a particular order. A raster row is called a <em>scan line</em>. The whole collection of scan lines is called a <em>frame buffer</em>.</p>
<p class="indent">Let’s say we want to paint our completed gasket from <a href="ch11.xhtml#ch11fig27">Figure 11-27</a> on a display. For simplicity, we’ll use a monochrome display that has 1 bit for each pixel and uses 16-bit-wide memory. That means the upper-leftmost 16 pixels are in the first word, the next 16 are in the second, and so on.</p>
<p class="indent">The upper-left square in <a href="ch11.xhtml#ch11fig27">Figure 11-27</a> is 4×4 pixels in size and is white, which means we need to be clearing bits in the frame buffer. We’ll use the coordinates and size of the quadtree square to construct a mask, as shown in <a href="ch11.xhtml#ch11fig29">Figure 11-29</a>.</p>
<span epub:type="pagebreak" id="page_312"/>
<div class="image"><a id="ch11fig29"/><img src="../images/11fig29.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-29: AND mask</em></p>
<p class="indent">We can then AND this mask with all the affected rows, costing only two memory accesses per row: one for read and one for write. We would do something similar to set bits in the frame buffer; the mask would have 1s in the area to set, and we would OR instead of AND.</p>
<p class="indent">Another place where this comes into play is when drawing text characters. Most text characters are stored as <em>bitmaps</em>, two-dimensional arrays of bits, as shown in <a href="ch11.xhtml#ch11fig30">Figure 11-30</a>. Character bitmaps are packed together to minimize memory use. That’s how text characters used to be provided; now they come as geometric descriptions. But for performance reasons, they’re often converted into bitmaps before use, and those bitmaps are usually cached on the assumption that characters get reused.</p>
<div class="image"><a id="ch11fig30"/><img src="../images/11fig30.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-30: Bitmap text characters</em></p>
<p class="indent">Let’s replace the character <em>B</em> on the display shown in <a href="ch11.xhtml#ch11fig31">Figure 11-31</a> with a <em>C</em>.</p>
<div class="image"><a id="ch11fig31"/><img src="../images/11fig31.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-31: Bitmap text characters</em></p>
<p class="indent">The <em>C</em> is located in bits 10 through 14 and needs to go into bits 6 through 10. For each row, we need to grab the <em>C</em> and then mask off everything else in the word. Then we need to shift it into the destination position. The destination must be read and the locations that we want to overwrite masked off before combining with the shifted <em>C</em> and being written, as shown in <a href="ch11.xhtml#ch11fig32">Figure 11-32</a>.</p>
<div class="image"><a id="ch11fig32"/><img src="../images/11fig32.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-32: Painting a character</em></p>
<p class="indent">This example uses three memory accesses per row: one to fetch the source, one to fetch the destination, and one to write the result. Doing this bit by bit would take five times that amount.</p>
<p class="indent">Keep in mind that there are often additional complications when the source or destination spans word boundaries.</p>
<h3 class="h3" id="ch11lev1sec4"><span epub:type="pagebreak" id="page_313"/><strong>More Math Avoidance</strong></h3>
<p class="noindent">We discussed some simple ways to avoid expensive math in “<a href="ch11.xhtml#ch11lev1sec2">Integer Methods</a>” on <a href="ch11.xhtml#page_290">page 290</a>. Now that we have the background, let’s talk about a couple of more complicated math-avoidance techniques.</p>
<h4 class="h4" id="ch11lev2sec10"><strong><em>Power Series Approximations</em></strong></h4>
<p class="noindent">Here’s another take on getting close enough. Let’s say we need to generate the sine function because we don’t have hardware that does it for us. One way to do this is with a <em>Taylor series</em>:</p>
<div class="equ-image"><img src="../images/eq313-01.jpg" alt="Image"/></div>
<p class="noindent"><a href="ch11.xhtml#ch11fig33">Figure 11-33</a> shows a sine wave and the Taylor series approximations for different numbers of terms. As you can see, the more terms, the closer the result is to an ideal sine.</p>
<div class="image"><a id="ch11fig33"/><img src="../images/11fig33.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-33: Taylor series for sine</em></p>
<p class="indent">It’s a simple matter to add terms until you get the desired degree of accuracy. It’s also worth noting that fewer terms are needed for angles more acute than 90 degrees, so you can be more efficient by using symmetry for other angles.</p>
<p class="indent">Note that we can reduce the number of multiplications required by initializing a <em>product</em> to <em>x</em>, precomputing –<em>x</em><sup>2</sup>, and multiplying the <em>product</em> by –<em>x</em><sup>2</sup> to get each term. All the denominators are constants that could reside in a small table indexed by the exponent. Also, we don’t have to compute all of the terms. If we need only two digits of accuracy, we can stop when computing more terms doesn’t change those digits.</p>
<h4 class="h4" id="ch11lev2sec11"><strong><em>The CORDIC Algorithm</em></strong></h4>
<p class="noindent">Jack Volder at Convair invented the <em>Coordinate Rotation Digital Computer (CORDIC)</em> algorithm in 1956. CORDIC was invented to replace an analog part of the B-58 bomber navigation system with something more accurate. CORDIC can be used to generate trigonometric and logarithmic functions <span epub:type="pagebreak" id="page_314"/>using integer arithmetic. It was used in the HP-35, the first portable scientific calculator, released in 1972. It was also used in the Intel 80x87 family of floating-point coprocessors.</p>
<p class="indent">The basic idea of CORDIC is illustrated in <a href="ch11.xhtml#ch11fig34">Figure 11-34</a>. Because it’s a unit circle (radius of 1) the x- and y-coordinates of the arrow ends are the cosine and sine of the angle. We want to rotate the arrow from its original position along the x-axis in smaller and smaller steps until we get to the desired angle and then grab the coordinates.</p>
<div class="image"><a id="ch11fig34"/><img src="../images/11fig34.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-34: CORDIC algorithm overview</em></p>
<p class="indent">Let’s say we want sin(57.529°). As you can see, we first try 45 degrees, which isn’t enough, so we take another step of 25.565 degrees, getting us to 71.565 degrees, which is too much. We then go backward by 14.036 degrees, which gets us to our desired 57.529 degrees. We’re clearly performing some sort of subdivision but with weird values for the angles.</p>
<p class="indent">We saw the equations for transformation earlier in “<a href="ch11.xhtml#ch11lev1sec2">Integer Methods</a>,” where we cared only about translation and scaling. The CORDIC algorithm is based on rotation. The following equations, the general form of which you’ve seen, show us how (<em>x</em>, <em>y</em>) is rotated by angle θ to get a new set of coordinates (<em>x′</em>, <em>y′</em>):</p>
<p class="equation"><em>x</em>′ = <em>x</em> × cos(θ) – <em>y</em> × sin(θ)</p>
<p class="equation"><em>y</em>′ = <em>x</em> × sin(θ) + <em>y</em> × cos(θ)</p>
<p class="indent">Although this is mathematically correct, it seems useless because we wouldn’t be discussing an algorithm that generates sines and cosines if they were already available.</p>
<p class="indent">Let’s make it worse before making it better by rewriting the equations in terms of tangents using the trigonometric identity:</p>
<div class="equ-image"><img src="../images/eq314-01.jpg" alt="Image"/></div>
<p class="indent">Because we’re dividing by cos(θ), we need to multiply the result by the same:</p>
<div class="equ-image"><img src="../images/eq314-02.jpg" alt="Image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_315"/>That looks pretty ugly. We’re making a bad situation worse, but that’s because we haven’t talked about the trick, which goes back to the weird angles. It turns out that tan(45°) = 1, tan(26.565°) = ½, and tan(14.036°) = ¼. That sure looks like some simple integer division by 2, or as Maxwell Smart might have said, “the old right shift trick.” It’s a binary search of the tangents of the angles.</p>
<p class="indent">Let’s see how this plays out for the example in <a href="ch11.xhtml#ch11fig34">Figure 11-34</a>. There are three rotations that get us from the original coordinates to the final ones. Keep in mind that, per <a href="ch11.xhtml#ch11fig34">Figure 11-34</a>, <em>x</em><sub>0</sub> = 1 and <em>y</em><sub>0</sub> = 0:</p>
<div class="equ-image"><img src="../images/eq315-01.jpg" alt="Image"/></div>
<p class="indent">Note the sign change in the last set of equations that result from going the other (clockwise) direction; when we’re going clockwise, the sign of the tangent is negative. Plugging the equations for (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) into the equations for (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>) and plugging that into the equations for (<em>x</em><sub>3</sub>, <em>y</em><sub>3</sub>) and then factoring out the cosines (and cleaning out the multiplications by 1) gives us the following:</p>
<div class="equ-image"><img src="../images/eq315-02.jpg" alt="Image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_316"/>So what about those cosines? Skipping the mathematical proof, it turns out that as long as we have enough terms:</p>
<p class="equationc">cos(45°) × cos(26.565°) × cos(–14.036°) × . . . = 0.607252935008881</p>
<p class="indent">That’s a constant, and we like constants. Let’s call it <em>C</em>. We could multiply it at the end like this:</p>
<div class="equ-image"><img src="../images/eq316-01.jpg" alt="Image"/></div>
<p class="indent">But we could save that multiplication by just using the constant for <em>x</em><sub>0</sub>, as shown next. We’ll also eliminate <em>y</em><sub>0</sub>, since it’s 0. It ends up looking like this:</p>
<div class="equ-image"><img src="../images/eq316-02.jpg" alt="Image"/></div>
<p class="indent">If you check, you’ll discover that the values for <em>x</em><sub>3</sub> and <em>y</em><sub>3</sub> are pretty close to the values of the cosine and sine of 57.529 degrees. And that’s with only three terms; more terms gets us closer. Notice that this is all accomplished with addition, subtraction, and division by 2.</p>
<p class="indent">Let’s turn this into a program that gives us a chance to introduce several additional tricks. First, we’ll use a slightly different version of CORDIC called <em>vectoring mode</em>; so far, we’ve been discussing <em>rotation mode</em> because it’s a little easier to understand. We’ve seen that in rotation mode we start with a vector (arrow) along the x-axis and rotate it until it’s at the desired angle. Vectoring mode is sort of the opposite; we start at our desired angle and rotate it until we end up with a vector along the x-axis (angle of 0). Doing it this way means we can just test the sign of the angle to determine the direction of rotation for a step; it saves a comparison between two numbers.</p>
<p class="indent">Second, we’re going to use table lookup. We’ll precompute a table of angles with tangents of 1, ½, ¼, and so on. We only need to do this once. The final algorithm is shown in <a href="ch11.xhtml#ch11fig35">Figure 11-35</a>.</p>
<span epub:type="pagebreak" id="page_317"/>
<div class="image"><a id="ch11fig35"/><img src="../images/11fig35.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-35: CORDIC flowchart</em></p>
<p class="indent">Now let’s write a C program that implements this algorithm using even more tricks. First, we’re going to express our angles in radians instead of in degrees.</p>
<p class="indent">The second trick is related to the first. You may have noticed that we haven’t encountered any numbers greater than 1. We can design our program to work in the first quadrant (between 0 and 90 degrees) and get the others using symmetry. An angle of 90 degrees is π/2, which is ≈ 1.57. Because we don’t have a wide range of numbers, we can use a fixed-point integer system instead of floating-point.</p>
<p class="indent">We’re going to base our sample implementation on 32-bit integers. Because we need a range of ≈ ±1.6, we can make bit 30 be the ones, bit 29 the halves, bit 28 the quarters, bit 27 the eighths, and so on. We’ll use the MSB (bit 31) as the sign bit. We can convert floating-point numbers (as long as they’re in range) to our fixed-point notation by multiplying by our version of 1, which is 0x40000000, and casting (converting) that into integers. Likewise, we can convert our results into floating-point by casting them as such and dividing by 0x40000000.</p>
<p class="indent"><span epub:type="pagebreak" id="page_318"/><a href="ch11.xhtml#ch11list17">Listing 11-17</a> shows the code, which is quite simple.</p>
<pre> 1  const int angles[] = {<br/>
 2    0x3243f6a8, 0x1dac6705, 0x0fadbafc, 0x07f56ea6, 0x03feab76, 0x01ffd55b, 0x00fffaaa, 0x007fff55,<br/>
 3    0x003fffea, 0x001ffffd, 0x000fffff, 0x0007ffff, 0x0003ffff, 0x0001ffff, 0x0000ffff, 0x00007fff,<br/>
 4    0x00003fff, 0x00001fff, 0x00000fff, 0x000007ff, 0x000003ff, 0x000001ff, 0x000000ff, 0x0000007f,<br/>
 5    0x0000003f, 0x0000001f, 0x0000000f, 0x00000008, 0x00000004, 0x00000002, 0x00000001, 0x00000000<br/>
 6  };<br/>
 7<br/>
 8  int angle = (desired_angle_in_degrees / 360 * 2 * 3.14159265358979323846) * 0x40000000;<br/>
 9<br/>
10  int x = (int)(0.6072529350088812561694 * 0x40000000);<br/>
11  int y = 0;<br/>
12<br/>
13  for (int index = 0; index &lt; 32; index++) {<br/>
14    int x_prime;<br/>
15    int y_prime;<br/>
16<br/>
17    if (angle &lt; 0) {<br/>
18      x_prime = x + (y &gt;&gt; index);<br/>
19      y_prime = y - (x &gt;&gt; index);<br/>
20      angle += angles[index];<br/>
21    }<br/>
22    else {<br/>
23      x_prime = x - (y &gt;&gt; index);<br/>
24      y_prime = y + (x &gt;&gt; index);<br/>
25      angle -= angles[index];<br/>
26    }<br/>
27<br/>
28    x = x_prime;<br/>
29    y = y_prime;<br/>
30  }</pre>
<p class="listing" id="ch11list17"><em>Listing 11-17: CORDIC implementation in C</em></p>
<p class="indent">Implementing CORDIC uses many of the goodies in our growing bag of tricks: recursive subdivision, precomputation, table lookup, shifting for power-of-two division, integer fixed-point arithmetic, and symmetry.</p>
<h3 class="h3" id="ch11lev1sec5"><strong>Somewhat Random Things</strong></h3>
<p class="noindent">It’s very difficult to do completely random things on computers because they have to generate random numbers based on some formula, and that makes it repeatable. That kind of “random” is good enough for most computing tasks though, except for cryptography, which we’ll discuss in <span epub:type="pagebreak" id="page_319"/><a href="ch13.xhtml#ch13">Chapter 13</a>. In this section, we’ll explore some approximations based on <em>pseudorandomness</em>. We’re choosing visual examples because they’re interesting and printable.</p>
<h4 class="h4" id="ch11lev2sec12"><strong><em>Space-Filling Curves</em></strong></h4>
<p class="noindent">Italian mathematician Giuseppe Peano (1858–1932) came up with the first example of a <em>space-filling curve</em> in 1890. Three iterations of it are shown in <a href="ch11.xhtml#ch11fig36">Figure 11-36</a>.</p>
<div class="image"><a id="ch11fig36"/><img src="../images/11fig36.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-36: Peano curve</em></p>
<p class="indent">As you can see, the curve is a simple shape that is shrunk and repeated at different orientations. Each time that’s done, it fills more of the space.</p>
<p class="indent">Space-filling curves exhibit <em>self-similarity</em>, which means they look about the same both up close and far away. They’re a subset of something called <em>fractals</em>, which were popularized when Benoit Mandelbrot (1924–2010) published <em>The Fractal Geometry of Nature</em> (W. H. Freeman and Company, 1977). Many natural phenomena are self-similar; for example, a coastline has the same jaggedness when observed from a satellite and from a microscope.</p>
<p class="indent">The term <em>fractal</em> comes from <em>fraction</em>. Geometry includes numerous integer relationships. For example, doubling the length of the sides of a square quadruples its area. But an integer change in lengths in a fractal can change the area by a fractional amount, hence the name.</p>
<p class="indent">The Koch snowflake is an easy-to-generate curve first described in 1904 by Swedish mathematician Helge von Koch (1870–1924). It starts with an equilateral triangle. Each side is divided into thirds, and the center third is replaced by a triangle one-third of the size, with the edge in line with the original side omitted, as shown in <a href="ch11.xhtml#ch11fig37">Figure 11-37</a>.</p>
<div class="image"><a id="ch11fig37"/><img src="../images/11fig37.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-37: Four iterations of the Koch snowflake</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_320"/>You can see that complex and interesting shapes can be generated with a tiny amount of code and recursion. Let’s look at slightly more complex example: the Hilbert curve, first described in 1891 by German mathematician David Hilbert (1862–1943), as shown in <a href="ch11.xhtml#ch11fig38">Figure 11-38</a>.</p>
<div class="image"><a id="ch11fig38"/><img src="../images/11fig38.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-38: Four iterations of the Hilbert curve</em></p>
<p class="indent">The rules for the next iteration of the Hilbert curve are more complicated than for the Koch snowflake, because we don’t do the same thing everywhere. There are four different orientations of the “cup” shape that are replaced by smaller versions, as shown in <a href="ch11.xhtml#ch11fig39">Figure 11-39</a>. There’s both a graphical representation and one using letters for right, up, left, and down. For each iteration, each corner of the shape on the left is replaced with the four shapes on the right (in order) at one-quarter the size of the shape on the left and then connected by straight lines.</p>
<div class="image"><a id="ch11fig39"/><img src="../images/11fig39.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-39: Hilbert curve rules</em></p>
<h4 class="h4" id="ch11lev2sec13"><strong><em>L-Systems</em></strong></h4>
<p class="noindent">The rules in <a href="ch11.xhtml#ch11fig39">Figure 11-39</a> are similar to the regular expressions we saw back in “<a href="ch08.xhtml#ch08lev2sec2">Regular Expressions</a>” on <a href="ch08.xhtml#page_224">page 224</a>, but backward. Instead of defining what patterns are matched, these rules define what patterns can be produced. They’re called <em>L-systems</em> or <em>Lindenmayer systems</em>, after Hungarian botanist Aristid Lindenmayer (1925–1989), who developed them in 1968. Because they define what can be produced, they’re also called <em>production grammars</em>.</p>
<p class="indent">You can see from <a href="ch11.xhtml#ch11fig39">Figure 11-39</a> that replacing an <em>R</em> with the sequence <em>U R R U</em> transforms the leftmost curve in <a href="ch11.xhtml#ch11fig38">Figure 11-38</a> into the one next to it.</p>
<p class="indent">The nice thing about production grammars is that they’re compact and easy to both specify and implement. They can be used to model a lot of phenomena. This became quite the rage when Alvy Ray Smith at Lucasfilm published “Plants, Fractals, and Formal Languages” (SIGGRAPH, 1984); you couldn’t go outside without bumping into L-System-generated shrubbery. Lindenmayer’s work became the basis for much of the computer graphics now seen in movies.</p>
<p class="indent"><span epub:type="pagebreak" id="page_321"/>Let’s make some trees so this book will be carbon-neutral. We have four symbols in our grammar, as shown in <a href="ch11.xhtml#ch11list18">Listing 11-18</a>.</p>
<pre>E draw a line ending at a leaf<br/>
B draw a branch line<br/>
L save position and angle, turn left 45°<br/>
R restore position and angle, turn right 45°</pre>
<p class="listing" id="ch11list18"><em>Listing 11-18: Symbols for tree grammar</em></p>
<p class="indent">In <a href="ch11.xhtml#ch11list19">Listing 11-19</a>, we create a grammar that contains two rules.</p>
<pre>B → B B<br/>
E → B L E R E</pre>
<p class="listing" id="ch11list19"><em>Listing 11-19: Tree grammar rules</em></p>
<p class="indent">You can think of the symbols and rules as a genetic code. <a href="ch11.xhtml#ch11fig40">Figure 11-40</a> shows several iterations of the grammar starting from <em>E</em>. Note that we’re not bothering to draw leaves on the ends of the branches. Also, beyond the first three, the set of symbols that define the tree are too long to show.</p>
<div class="image"><a id="ch11fig40"/><img src="../images/11fig40.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-40: Simple L-system tree</em></p>
<p class="indent">As you can see, we get pretty good-looking trees without much work. L-systems are a great way to generate natural-looking objects.</p>
<p class="indent">Production grammars have been used to generate objects since long before computers. Knitting instructions are production grammars, for example, as shown in <a href="ch11.xhtml#ch11list20">Listing 11-20</a>.</p>
<pre>k = knit<br/>
p = purl<br/>
s = slip first stitch purl wise<br/>
row<sub>1</sub> → s   p  k k p p k k p p  k  p p k k p p k k   p   k k p p k k p p  k  p p k k p p k k   p   k<br/>
row<sub>2</sub> → s   k  p p k k p p k k  p  k k p p k k p p   k   p p k k p p k k  p  k k p p k k p p   k   k<br/>
row<sub>5</sub> → s   p p k k p p k k   p p p k k p p k k   p p p k k p p k k   p p p k k p p k k   p p k<br/>
row<sub>6</sub> → s   k k p p k k p p   k k k p p k k p p   k k k p p k k p p   k k k p p k k p p   k k k<br/>
section → row<sub>1</sub> row<sub>2</sub> row<sub>1</sub> row<sub>2</sub> row<sub>5</sub> row<sub>6</sub> row<sub>5</sub> row<sub>6</sub> row<sub>2</sub> row<sub>2</sub> row<sub>2</sub> row<sub>2</sub> row<sub>6</sub> row<sub>5</sub> row<sub>6</sub> row<sub>5</sub><br/>
scarf → section ...</pre>
<p class="listing" id="ch11list20"><em>Listing 11-20: Production grammar for scarf in <a href="ch11.xhtml#ch11fig41">Figure 11-41</a></em></p>
<p class="indent">Executing the grammar in <a href="ch11.xhtml#ch11list20">Listing 11-20</a> using the knitting needle I/O device for some number of sections yields a scarf, as shown in <a href="ch11.xhtml#ch11fig41">Figure 11-41</a>.</p>
<span epub:type="pagebreak" id="page_322"/>
<div class="image"><a id="ch11fig41"/><img src="../images/11fig41.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-41: Scarf produced by production grammar</em></p>
<h4 class="h4" id="ch11lev2sec14"><strong><em>Going Stochastic</em></strong></h4>
<p class="noindent"><em>Stochastic</em> is a good word to use when you want to sound sophisticated and <em>random</em> just won’t do. Alan Fournier and Don Fussell at the University of Texas at Dallas introduced the notion of adding randomness to computer graphics in 1980. A certain amount of randomness adds variety. For example, <a href="ch11.xhtml#ch11fig42">Figure 11-42</a> shows a stochastic modification of the L-system trees from the last section.</p>
<div class="image"><a id="ch11fig42"/><img src="../images/11fig42.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-42: Stochastic L-system trees</em></p>
<p class="indent">As you can see, it generates a nice set of similar-looking trees. A forest looks more realistic when the trees aren’t all identical.</p>
<p class="indent">Loren Carpenter at Boeing published a paper that pioneered a simple way to generate fractals (“Computer Rendering of Fractal Curves and Surfaces,” SIGGRAPH, 1980). At SIGGRAPH 1983, Carpenter and Mandelbrot engaged in a very heated discussion about whether Carpenter’s results were actually fractals.</p>
<p class="indent">Carpenter left Boeing and continued his work at Lucasfilm. His fractal mountains produced the planet in <em>Star Trek II: The Wrath of Khan</em>. An interesting factoid is that the planet took about six months of computer time to <span epub:type="pagebreak" id="page_323"/>generate. Because it was generated using random numbers, Spock’s coffin ended up flying through the side of the mountain for several frames. Artists had to manually cut a notch in the mountain to fix this.</p>
<p class="indent">Carpenter’s technique was simple. He randomly selected a point on a line and then moved that point a random amount. He recursively repeated this for the two line segments until things were close enough. It’s a bit like adding randomness to the Koch curve generator. <a href="ch11.xhtml#ch11fig43">Figure 11-43</a> shows a few random peaks.</p>
<div class="image"><a id="ch11fig43"/><img src="../images/11fig43.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-43: Fractal mountains</em></p>
<p class="indent">Once again, pretty good for not much work.</p>
<h4 class="h4" id="ch11lev2sec15"><strong><em>Quantization</em></strong></h4>
<p class="noindent">Sometimes we don’t have a choice about approximating and must do the best we can. For example, we may have a color photograph that needs to be printed in a black-and-white newspaper. Let’s look at how we might make this transformation. We’ll use the grayscale image in <a href="ch11.xhtml#ch11fig44">Figure 11-44</a>, since this book isn’t printed in color. Because it’s grayscale, each of the three color components is identical and in the range of 0 to 255.</p>
<div class="image"><a id="ch11fig44"/><img src="../images/11fig44-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-44: Tony Cat</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_324"/>We need to perform a process called <em>quantization</em>, which means taking the colors that we have available in the original image and assigning them to colors in the transformed image. It’s yet another sampling problem, as we have to take an analog (or <em>more</em> analog, in our case) signal and divide it among a fixed set of buckets. How do we map 256 values into 2?</p>
<p class="indent">Let’s start with a simple approach called <em>thresholding</em>. As you might guess from the name, we pick a threshold and assign anything brighter than that to white, and anything darker to black. <a href="ch11.xhtml#ch11list21">Listing 11-21</a> makes anything greater than 127 white, and anything not white is black.</p>
<pre>for (y = 0; y &lt; height; y++)<br/>
  for (x = 0; x &lt; width; x++)<br/>
    if (value_of_pixel_at(x, y) &gt; 127)<br/>
      draw_white_pixel_at(x, y);<br/>
    else<br/>
      draw_black_pixel_at(x, y);</pre>
<p class="listing" id="ch11list21"><em>Listing 11-21: Threshold pseudocode</em></p>
<p class="indent">Running this pseudocode on the image in <a href="ch11.xhtml#ch11fig44">Figure 11-44</a> produces the image in <a href="ch11.xhtml#ch11fig45">Figure 11-45</a>.</p>
<div class="image"><a id="ch11fig45"/><img src="../images/11fig45-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-45: Threshold algorithm</em></p>
<p class="indent">That doesn’t look very good. But there’s not a lot we can do; we could monkey around with the threshold, but that would just give us different bad results. We’ll try to get better results using optical illusions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_325"/>British scientist Henry Talbot (1800–1877) invented <em>halftone printing</em> in the 1850s for just this reason; photography at the time was grayscale, and printing was black and white. Halftone printing broke the image up into dots of varying sizes, as shown in the magnified image on the left in <a href="ch11.xhtml#ch11fig46">Figure 11-46</a>. As you can see on the right, your eye interprets this as shades of gray.</p>
<div class="image"><a id="ch11fig46"/><img src="../images/11fig46.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-46: Halftone pattern</em></p>
<p class="indent">We can’t vary the dot size on a computer screen, but we want the same type of effect. Let’s explore some different ways to accomplish this. We can’t change the characteristics of a single dot that can be either black or white, so we need to adjust the surrounding dots somehow to come up with something that your eye will see as shades of gray. We’re effectively trading off image resolution for the perception of more shades or colors.</p>
<p class="indent">The name for this process is <em>dithering</em>, and it has an amusing origin going back once again to World War II analog computers. Someone noticed that the computers worked better aboard flying airplanes than on the ground. It turns out that the random vibration from the plane engines kept the gears, wheels, cogs, and such from sticking. Vibrating motors were subsequently added to the computers on the ground to make them work better by trembling them. This random vibration was called <em>dither</em>, based on the Middle English verb <em>didderen</em>, meaning “to tremble.” There are many dithering algorithms; we’ll examine only a few here.</p>
<p class="indent">The basic idea is to use a pattern of different thresholds for different pixels. In the mid-1970s, American scientist Bryce Bayer (1929–2012) at Eastman Kodak invented a key technology for digital cameras, the eponymous <em>Bayer filter</em>. The <em>Bayer matrix</em> is a variation that we can use for our purposes. Some examples are shown in <a href="ch11.xhtml#ch11fig47">Figure 11-47</a>.</p>
<span epub:type="pagebreak" id="page_326"/>
<div class="image"><a id="ch11fig47"/><img src="../images/11fig47.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-47: Bayer matrices</em></p>
<p class="indent">These matrices are <em>tiled</em> over the image, meaning they repeat in both the x and y directions, as shown in <a href="ch11.xhtml#ch11fig48">Figure 11-48</a>. Dithering using tiled patterns is called <em>ordered dithering</em>, as there’s a predictable pattern based on position in the image.</p>
<div class="image"><a id="ch11fig48"/><img src="../images/11fig48.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-48: 2×2 Bayer matrix tiling pattern</em></p>
<p class="indent"><a href="ch11.xhtml#ch11list22">Listing 11-22</a> shows the pseudocode for the Bayer matrices from <a href="ch11.xhtml#ch11fig47">Figure 11-47</a>.</p>
<pre>for (y = 0; y &lt; height; y++)<br/>
 for (x = 0; x &lt; width; x++)<br/>
  if (value_of_pixel_at(x, y) &gt; bayer_matrix[y % matrix_size][x % matrix_size])<br/>
    draw_white_pixel_at(x, y);<br/>
  else<br/>
    draw_black_pixel_at(x, y);</pre>
<p class="listing" id="ch11list22"><em>Listing 11-22: Bayer ordered dithering pseudocode</em></p>
<p class="indent">On to the important question: what does Tony Cat think of this? <a href="ch11.xhtml#ch11fig49">Figures 11-49</a> through <a href="ch11.xhtml#ch11fig51">11-51</a> show him dithered using the three matrices just shown.</p>
<span epub:type="pagebreak" id="page_327"/>
<div class="image"><a id="ch11fig49"/><img src="../images/11fig49-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-49: Tony dithered using the 2×2 Bayer matrix</em></p>
<div class="image"><a id="ch11fig50"/><img src="../images/11fig50-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-50: Tony dithered using the 3×3 Bayer matrix</em></p>
<span epub:type="pagebreak" id="page_328"/>
<div class="image"><a id="ch11fig51"/><img src="../images/11fig51-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-51: Tony dithered using the 4×4 Bayer matrix</em></p>
<p class="indent">As you can see, these are somewhat acceptable if you squint, and they improve with larger matrices. Not exactly the cat’s meow, but a lot better than thresholding. Doing more work by using larger matrices yields better results. But the tiling pattern shows through. Plus it can produce really trippy artifacts called <em>moiré</em> patterns for certain images. You might have seen these if you’ve ever grabbed a stack of window screens.</p>
<p class="indent">How can we eliminate some of these screening artifacts? Instead of using a pattern, let’s just compare each pixel to a random number using the pseudocode in <a href="ch11.xhtml#ch11list23">Listing 11-23</a>. The result is shown in <a href="ch11.xhtml#ch11fig52">Figure 11-52</a>.</p>
<pre>for (y = 0; y &lt; height; y++)<br/>
  for (x = 0; x &lt; width; x++)<br/>
    if (value_of_pixel_at(x, y) &gt; random_number_between_0_and_255())<br/>
      draw_white_pixel_at(x, y);<br/>
    else<br/>
      draw_black_pixel_at(x, y);</pre>
<p class="listing" id="ch11list23"><em>Listing 11-23: Random-number dithering pseudocode</em></p>
<span epub:type="pagebreak" id="page_329"/>
<div class="image"><a id="ch11fig52"/><img src="../images/11fig52-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-52: Tony dithered using random numbers</em></p>
<p class="indent">This eliminates the patterning artifacts but is pretty fuzzy, which is not unusual for cats. It’s not as good as the ordered dither.</p>
<p class="indent">The fundamental problem behind all these approaches is that we can only do so much making decisions on a pixel-by-pixel basis. Think about the difference between the original pixel values and the processed ones. There’s a certain amount of <em>error</em> for any pixel that wasn’t black or white in the original. Instead of discarding this error as we’ve done so far, let’s try spreading it around to other pixels in the neighborhood.</p>
<p class="indent">Let’s start with something really simple. We’ll take the error for the current pixel and apply it to the next horizontal pixel. The pseudocode is in <a href="ch11.xhtml#ch11list24">Listing 11-24</a>, and the result is shown in <a href="ch11.xhtml#ch11fig53">Figure 11-53</a>.</p>
<pre>for (y = 0; y &lt; height; y++)<br/>
  for (error = x = 0; x &lt; width; x++)<br/>
    if (value_of_pixel_at(x, y) + error &gt; 127)<br/>
      draw_white_pixel_at(x, y);<br/>
      error = -(value_of_pixel_at(x, y) + error);<br/>
    else<br/>
      draw_black_pixel_at(x, y);<br/>
      error = value_of_pixel_at(x, y) + error;</pre>
<p class="listing" id="ch11list24"><em>Listing 11-24: One-dimensional error propagation pseudocode</em></p>
<span epub:type="pagebreak" id="page_330"/>
<div class="image"><a id="ch11fig53"/><img src="../images/11fig53-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-53: Tony dithered using one-dimensional error propagation</em></p>
<p class="indent">Not great, but not horrible—easily beats thresholding and random numbers and is somewhat comparable to the 2×2 matrix; they each have different types of artifacts. If you think about it, you’ll realize that error propagation is the same decision variable trick that we used earlier for drawing lines and curves.</p>
<p class="indent">American computer scientists Robert Floyd (1936–2001) and Louis Steinberg came up with an approach in the mid-1970s that you can think of as a cross between this error propagation and a Bayer matrix. The idea is to spread the error from a pixel to some surrounding pixels using a set of weights, as shown in <a href="ch11.xhtml#ch11fig54">Figure 11-54</a>.</p>
<div class="image"><a id="ch11fig54"/><img src="../images/11fig54.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-54: Floyd-Steinberg error distribution weights</em></p>
<p class="indent"><a href="ch11.xhtml#ch11list25">Listing 11-25</a> shows the Floyd-Steinberg pseudocode. Note that we have to keep two rows’ worth of error values. We make each of those rows 2 longer than needed and offset the index by 1 so that we don’t have to worry about running off the end when handling the first or last columns.</p>
<span epub:type="pagebreak" id="page_331"/>
<pre>for (y = 0; y &lt; height; y++)<br/>
  errors_a = errors_b;<br/>
  errors_b = 0;<br/>
  this_error = 0;<br/>
<br/>
  for (x = 0; x &lt; width; x++)<br/>
    if (value_of_pixel_at(x, y) &gt; bayer_matrix[y % matrix_size][x % matrix_size])<br/>
      draw_white_pixel_at(x, y);<br/>
      this_error = -(value_of_pixel_at(x, y) + this_error + errors_a[x + 1]);<br/>
    else<br/>
      draw_black_pixel_at(x, y);<br/>
      this_error = value_of_pixel_at(x, y) + this_error + errors_a[x + 1];<br/>
<br/>
    this_error = this_error * 7 / 16;<br/>
<br/>
    errors_b[x] += this_error * 3 / 16;<br/>
    errors_b[x + 1] += this_error * 5 / 16;<br/>
    errors_b[x + 2] += this_error * 1 / 16;</pre>
<p class="listing" id="ch11list25"><em>Listing 11-25: Floyd-Steinberg error propagation code</em></p>
<p class="indent">This is a lot more work, but the results, as shown in <a href="ch11.xhtml#ch11fig55">Figure 11-55</a>, look pretty good. (Note that this is unrelated to the Pink Floyd–Steinberg algorithm that was used to make album covers in the 1970s.)</p>
<div class="image"><a id="ch11fig55"/><img src="../images/11fig55-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-55: Tony dithered using the Floyd-Steinberg algorithm</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_332"/>Post–Floyd-Steinberg, numerous other distribution schemes have been proposed, most of which do more work and distribute the error among more neighboring pixels.</p>
<p class="indent">Let’s try one more approach, this one published by Dutch software engineer Thiadmer Riemersma in 1998. His algorithm does several interesting things. First, it goes back to the approach of affecting only one adjacent pixel. But it keeps track of 16 pixels’ worth of error. It calculates a weighted average so that the most recently visited pixel has more effect than the least recently visited one. <a href="ch11.xhtml#ch11fig56">Figure 11-56</a> shows the weighting curve.</p>
<div class="image"><a id="ch11fig56"/><img src="../images/11fig56.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-56: Riemersma pixel weights</em></p>
<p class="indent">The Riemersma algorithm doesn’t use the typical adjacent pixels grid that we’ve seen before (see <a href="ch11.xhtml#ch11list26">Listing 11-26</a>). Instead, it follows the path of a Hilbert curve, which we saw in <a href="ch11.xhtml#ch11fig38">Figure 11-38</a>.</p>
<pre>for (each pixel along the Hilbert curve)<br/>
  error = weighted average of last 16 pixels<br/>
<br/>
  if (value_of_pixel_at(x, y) + error &gt; 127)<br/>
    draw_white_pixel_at(x, y);<br/>
  else<br/>
    draw_black_pixel_at(x, y);<br/>
<br/>
  remove the oldest weighted error value<br/>
  add the error value from the current pixel</pre>
<p class="listing" id="ch11list26"><em>Listing 11-26: Riemersma error propagation pseudocode</em></p>
<p class="indent">The result is shown in <a href="ch11.xhtml#ch11fig57">Figure 11-57</a>. Still not purr-fect, but at this point we’ve seen enough cats. Try the example code on a gradient such as the one in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>. You’ve learned that there are many different ways to deal with approximation required by real-life circumstances.</p>
<span epub:type="pagebreak" id="page_333"/>
<div class="image"><a id="ch11fig57"/><img src="../images/11fig57-2.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 11-57: Tony dithered using the Riemersma algorithm</em></p>
<h3 class="h3" id="ch11lev1sec6"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, we’ve examined a number of tricks you can use to increase performance and efficiency by avoiding or minimizing computation. As Jim Blinn, one of the giants in the field of computer graphics, said, “A technique is just a trick that you use more than once.” And just as you saw with hardware building blocks, these tricks can be combined to solve complex problems.<span epub:type="pagebreak" id="page_334"/></p>
</body></html>