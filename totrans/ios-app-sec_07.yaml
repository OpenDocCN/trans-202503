- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DEBUGGING WITH LLDB AND FRIENDS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Debugging iOS applications is considered one of Xcode’s strong components. In
    addition to the useful analysis features of DTrace, Xcode has a command line debugger
    with a relatively approachable graphical interface. As part of Apple’s migration
    away from GNU utilities, the default debugger is now lldb,^([1](footnote.html#fn34))
    which provides first-class support for Objective-C. Multithreaded debugging is
    well-supported, and you can even inspect objects from the debugger. The only downside
    is that you’ll have to translate your hard-won knowledge of gdb to a new environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is a vast topic, and there are multiple books on the subject.^([2](footnote.html#fn35))
    This chapter covers the basics for people new to Xcode, along with tips relevant
    to security testing and secure development. I assume you have some familiarity
    with gdb and debuggers in general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Useful Features in lldb**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xcode’s built-in debugger interface is fairly powerful. It has a command line,
    but you can also use the GUI to view and interact with the current thread state,
    annotated assembly, and object details. The GUI includes a central breakpoint
    browser as well, where you can view, enable, and disable breakpoints.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re extremely comfortable using gdb, the LLVM project has a mapping
    of frequently used gdb commands to their lldb equivalents; see* [http://lldb.llvm.org/lldb-gdb.html](http://lldb.llvm.org/lldb-gdb.html).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Breakpoints***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can set breakpoints graphically from Xcode’s lldb interface (see [Figure
    5-1](ch05.html#ch5fig1)), or you can do so from the command line. In addition
    to breaking when the program accesses a particular memory address or C function,
    you can also break on specific Objective-C methods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Xcode’s lldb interface*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the ways you can set breakpoints:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command at ➊ sets one breakpoint on multiple functions, a feature you can
    use to enable and disable groups of functions simultaneously. As shown at ➋, you
    can also break on specific Objective-C instance and class methods—these can be
    also be grouped in a manner similar to the C function calls at ➊. If you want
    to break on all calls to a particular selector/method, use the `--selector` option
    ➌, which will break on any calls to a selector of this name, regardless of what
    class they’re implemented in. Finally, to break on specific C++ methods, simply
    specify `--method` instead of `--name` when defining the breakpoint, as at ➍.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, setting a breakpoint in lldb looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After you set a breakpoint, lldb shows the code you’re breaking on. If you
    like, you can make this even simpler: like gdb, lldb recognizes keywords using
    the shortest matching text. So `*breakpoint*` can be shortened to `*break*`, or
    even `*b*`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In the GUI, you can break on a particular line of code by clicking the number
    in the gutter to the left of the line (see [Figure 5-2](ch05.html#ch5fig2)). Clicking
    again will disable the breakpoint. Alternatively, you can break on lines from
    the lldb CLI using the `--file *filename.m* --line *66*` syntax.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Setting breakpoints on specific lines with the mouse. Deactivated
    breakpoints are shaded a lighter gray.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to create multiple breakpoints, it can be handy to use the `-r`
    flag at the command line to break on functions matching a particular regular expression,
    like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will set a single breakpoint with a number of *locations*. Each location
    can be enabled and disabled, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that enabling and disabling locations works just like a regular breakpoint;
    just use `break disable` and `break enable` and reference the right numeric identifier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '***Navigating Frames and Variables***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve arrived at a breakpoint, you can use lldb to examine the state of
    your program. You can do this via either the command line, as in the other lldb
    examples I’ve shown, or the visual lldb browser, as in [Figure 5-3](ch05.html#ch5fig3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Examining frame variables from the command line and the GUI*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In addition to viewing and manipulating the variables of the current frame,
    you can navigate the program threads and frames of the call stack using the Debug
    Navigator, as shown in [Figure 5-4](ch05.html#ch5fig4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Using the Debug Navigator to switch frames and threads*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Similar to using gdb, you can inspect the call stack of the current thread with
    the `bt` (short for *backtrace*) command (see [Listing 5-1](ch05.html#ch5ex1)).
    Normally, you could also navigate frames using the typical `up`, `down`, and `frame
    select` commands. In some versions of Xcode however, a bug causes the frame to
    immediately revert to the frame selected in the Debug Navigator. In that case,
    you must switch frames manually within the Debug Navigator to inspect them individually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-1: Getting the current call stack with the backtrace command*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: To examine the variables of the current frame, you can use the `frame variable`
    command, as shown in Listing **??**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-2: Using the* `frame variable` *command*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This will give you variable names and arguments of the local stack frame, along
    with their types and memory addresses. You can also use the context menu in the
    graphical debugger to print or edit variable contents; see [Figure 5-5](ch05.html#ch5fig5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `frame select` on its own, you can also see the program’s location
    in the call stack, along with the relevant surrounding lines of code, as in this
    example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](graphics/f05-05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: The variable context menu, showing options for printing variable
    contents, setting watchpoints, and viewing memory contents*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `frame select` command also takes a numeric argument for the stack frame
    you want to inspect, if you’d like to look further up the call stack (see [Listing
    5-3](ch05.html#ch5ex3)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-3: Assembly shown while examining a stack frame*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note that for code outside of your current project, such as other parts of the
    Cocoa API, the source will usually not be available; lldb will instead show you
    the relevant assembly instructions.^([3](footnote.html#fn36))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also inspect the values of objects using lldb’s `po` (short for *print
    object*) command. For example, consider the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `po` on your main window fetches the addresses and attributes of that
    window.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '***Visually Inspecting Objects***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using Xcode 5 or later, you can also hover the mouse over objects
    to inspect the contents, as shown in [Figure 5-6](ch05.html#ch5fig6). If you drill
    down into individual subobjects, you can either view their memory directly ([Figure
    5-7](ch05.html#ch5fig7)) by clicking the **i** button or use the Quick Look “eye”
    button to see the contents of the object represented as a fully rendered image,
    text, or any other data type that OS X’s Quick Look API understands (see [Figure
    5-8](ch05.html#ch5fig8)). This is, in my opinion, pretty badass.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: Inspecting an object while at a breakpoint*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-07.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: Inspecting an object’s contents in memory*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-08.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: Examining the current state of a variable with the Quick Look
    button. In this case, you’re looking at the* `_statusBar` *of the UIApplication
    delegate window, which Xcode will display as an actual image.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '***Manipulating Variables and Properties***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can do more than just view the contents of variables and objects from lldb.
    For example, let’s try breaking on the same line used to test the `frame variable`
    command back in [Listing 5-2](ch05.html#ch5ex2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the debugger reaches this line, imagine you want to examine the contents
    of UITextView’s *text* attribute and change its value before the program continues.
    You can do this with the `expr` command, using traditional Objective-C syntax,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When execution resumes, the value of that text box in the UI should have changed.
    Because lldb doesn’t know the return type of a method called in this way, you
    have to specify the type using `(void)` with the `expr` command. Similarly, if
    you were calling something that returned an `int`, you’d need to explicitly cast
    to that type instead. For simple assignment operations, like `myInteger = 666`
    or similar, as opposed to method calls, simply enter `expr` and the assignment
    as one command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '*When using lldb from the command line in Xcode, the GUI will autocomplete
    object method names, giving you a brief description and their return type. See
    [Figure 5-9](ch05.html#ch5fig9) for an example.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f05-09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: Nifty lldb method name completion in Xcode*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you’re not limited to manipulating objects that are declared
    in your code. You can also manipulate framework classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For this kind of interactive manipulation and interrogation, I often find it
    useful to set a breakpoint on `didReceiveMemoryWarning` in the application delegate
    because this method will be present in every application. When I want to inspect
    the program’s state while running it in the iOS Simulator, I select Hardware →
    Simulate Memory Warning. Once I’ve done my twiddling, I simply continue the application
    with `cont`. You can also do this from the Xcode UI with the Pause Execution button.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '***Breakpoint Actions***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Breakpoint actions* are not well-documented but are quite useful. They allow
    you to create breakpoints that trigger only under certain conditions, and they
    can perform complex actions when these breakpoints are hit. You can set them up
    to automatically resume execution after performing these actions or even have
    them trigger only after a line is hit a certain number of times. Logging and using
    speech synthesis to present program information are the simplest actions you can
    set for a breakpoint, but you can also interrogate objects, read and manipulate
    variables, and so forth. Basically, breakpoint actions can do anything you can
    do from the lldb command line, plus a few other niceties.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through creating a breakpoint action one step at a time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Create a breakpoint by clicking in the breakpoint gutter.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CTRL-click the breakpoint and select **Edit Breakpoint**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add Action**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Automatically continue after evaluating** box.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the simplest type of breakpoint action, simply select the **Log message**
    action. Here, you can print simple messages, along with the breakpoint name and
    hit count (see [Figure 5-10](ch05.html#ch5fig10)). You can ignore the expression
    option because it’s not terribly straightforward to use.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding a simple log message, you can click the **+** button to add another
    action. This time, select **Debugger Command**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you can enter basic lldb expressions—most commonly, using the `po` command
    to print the description of an object. See [Figure 5-11](ch05.html#ch5fig11) for
    an example.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f05-10.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 5-10: Using a breakpoint action to do a simple log entry. In this example,
    you’ll log a message, along with the number of times the breakpoint has been hit,
    using the* `%H` *placeholder.*'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](graphics/f05-11.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 5-11: In addition to simply logging, you can execute an arbitrary lldb
    command. In this case, you’ll use the* `po` *command to print the description
    of the object returned by the* `path` *method.*'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, add a breakpoint condition to specify when the actions you’ve defined
    are executed ([Figure 5-12](ch05.html#ch5fig12)).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f05-12.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 5-12: Two actions and a breakpoint condition. For the condition, you’ll
    ensure that the length of the path is not zero before executing the breakpoint
    action, specifying the return value* `(BOOL)`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try following these steps until you feel comfortable using breakpoint actions,
    and then move on to the next section for some specific ways to apply lldb in a
    security context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Using lldb for Security Analysis**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are all useful tricks, but how do you put them together to find new security
    issues or test security assertions? Let’s take a look at a couple scenarios where
    using the debugger can help you nail down more concrete issues.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '***Fault Injection***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you have an application that uses a custom binary network protocol to marshal
    data between the client and a remote server. This can make it difficult to intercept
    and modify data with an off-the-shelf proxy, but you’d like to determine whether
    malformed data in certain parameters could cause a program to crash. You can also
    manipulate data to make future testing easier.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you can change data, you might want to replace, for example, a randomly
    generated key with one of your choosing. You can do that from within the debugger,
    as shown in [Listing 5-4](ch05.html#ch5ex4). This results in data being encrypted
    with a known key of your choosing, rather than a potentially unprintable blob.
    The following example modifies the app’s crypto key before it gets saved to the
    Keychain so that further communication uses a different key:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-4: Inspecting and changing object values in memory*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, the code prints the variables of the current frame, noting the arguments
    sent to the `addToKeychain:forService:` selector. The key this example is interested
    in is stored in the `item` argument and added to a dictionary. Inspecting these
    (➋ and ➌) reveals the value of the key. The code then alters the Keychain dictionary
    using the `expr` command ➍. At ➎, the program verifies that the new `NSString`
    is now the current value of the key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '***Tracing Data***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you have an application that encrypts data with a master password, it may
    be useful to examine that data before it gets encrypted. It may not always be
    immediately obvious that data will hit the encryption routine by default. Consider
    [Listing 5-5](ch05.html#ch5ex5):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-5: Examining frame variables with lldb*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If you break on the `encrypt:` selector ➋, you can examine the local variables
    using the `frame variable` command ➊. Notice that the output shows both `data`
    and `encData`. The former ➌ is the interesting bit in this example, because that’s
    the data that will be encrypted and returned by the routine. This tracing technique
    can also be used to examine and manipulate data to be sent over the wire, before
    it hits the encryption routines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '***Examining Core Frameworks***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'lldb is also useful for digging in to the weird quirks of Apple’s APIs—I recommend
    you use it when you’re confused by an API’s behavior. For instance, when looking
    into `NSURLCache`, I noticed the behavior in [Listing 5-6](ch05.html#ch5ex6):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: lldb在深入研究Apple的API的奇怪行为时也非常有用——当你对某个API的行为感到困惑时，我建议你使用它。例如，在查看`NSURLCache`时，我注意到在[清单
    5-6](ch05.html#ch5ex6)中的行为：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-6: Some curious behavior of the* `NSURLCache` *API*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：`NSURLCache` API的某些奇怪行为*'
- en: Here, even though I called the `removeAllCachedResponses` method ➊, the current
    disk usage is still 98304 bytes ➋. Alas, it appears that clearing the cache is
    useless. Fear not—you’ll see some solutions to this problem in [Chapter 9](ch09.html#ch09).
    In the meantime, you may want to play around with some of the internals yourself.
    This can help you figure out some of the workings of the iOS platform and give
    you deeper insight into how your application is behaving.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尽管我调用了`removeAllCachedResponses`方法➊，当前的磁盘使用量仍然是98304字节➋。唉，似乎清除缓存是无效的。别担心——你将在[第9章](ch09.html#ch09)看到一些解决方案。与此同时，你可能想自己尝试一些内部机制。这可以帮助你了解iOS平台的一些工作原理，并对你的应用程序行为有更深入的理解。
- en: '**Closing Thoughts**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: All of these debugging and inspection techniques can be useful when trying to
    debug your own application or understand a new codebase quickly. However, you
    may not always have access to the source code of the product you’re working with.
    In these cases, you’ll want to know some basic black-box testing techniques, which
    I will cover in [Chapter 6](ch06.html#ch06).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些调试和检查技巧在调试你自己的应用程序或快速了解一个新代码库时都很有用。然而，你可能并不总是能访问到你正在使用的产品的源代码。在这些情况下，你需要了解一些基本的黑箱测试技巧，我将在[第6章](ch06.html#ch06)中介绍这些技巧。
