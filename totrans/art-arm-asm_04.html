<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">3</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">MEMORY ACCESS AND ORGANIZATION</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><span class="chapterintro_Xref"><a href="chapter1.xhtml">Chapters 1</a></span> and <span class="chapterintro_Xref"><a href="chapter2.xhtml">2</a></span> showed you how to declare and access simple variables in an assembly language program. This chapter fully explains ARM memory access. You’ll learn how to efficiently organize your variable declarations to speed up access to their data. You’ll also learn about the ARM stack and how to manipulate data on it.</p>&#13;
<p class="TX">This chapter discusses several important concepts, including the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Memory organization</li>&#13;
<li class="BL">Memory access and the memory management unit</li>&#13;
<li class="BL">Position-independent executables and address space layout randomization</li>&#13;
<li class="BL">Variable storage and data alignment</li>&#13;
<li class="BL">Endianness (memory byte order)</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>ARM memory addressing modes and address expressions</li>&#13;
<li class="BL">Stack operations, return addresses, and preserving register data</li>&#13;
</ul>&#13;
<p class="TX">This chapter will teach to you make efficient use of your computer’s memory resources.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-42"/><span class="SANS_Futura_Std_Bold_B_11">3.1 Runtime Memory Organization</span></h3>&#13;
<p class="TNI1">A running program uses memory in many ways, depending on the data’s type. Here are some common data classifications you’ll find in an assembly language program:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Code</b>    Memory values that encode machine instructions (also known as the <i>text</i> section under Linux and macOS).</p>&#13;
<p class="RunInPara"><b>Uninitialized static data</b>    An area in memory set aside by the program for uninitialized variables that exist the whole time the program runs; the OS will initialize this storage area to 0s when it loads the program into memory.</p>&#13;
<p class="RunInPara"><b>Initialized static data</b>    A section of memory that also exists the whole time the program runs. However, the OS loads values for all the variables appearing in this section from the program’s executable file, so they have an initial value when the program first begins execution.</p>&#13;
<p class="RunInPara"><b>Read-only data</b>    Similar to initialized static data, insofar as the OS loads initial data for this section of memory from the executable file. However, this section is marked <i>read-only</i> to prevent inadvertent modification of the data. Programs typically place constants and other unchanging data in this section (the code section is also marked read-only by the OS).</p>&#13;
<p class="RunInPara"><b>Heap</b>    This special section of memory is designated to hold dynamically allocated storage. Functions such as C’s <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> are responsible for allocating and deallocating storage in the heap area. Section 4.4.4, <span class="runinpara_Xref">“Pointer Variables and Dynamic Memory Allocation,”</span> on <span class="runinpara_Xref"><a href="chapter4.xhtml#pg_178">page 178</a></span> discusses dynamic storage allocation in greater detail.</p>&#13;
<p class="RunInPara"><b>Stack</b>    In this special section in memory, the program maintains local variables for procedures and functions, program state information, and other transient data. See section 3.9, <span class="runinpara_Xref">“The Push and Pop Operations,”</span> on <span class="runinpara_Xref"><a href="chapter3.xhtml#pg_155">page 155</a></span> for more information about the stack section.</p>&#13;
</div>&#13;
<p class="TX">These are the typical sections you will find in common programs, assembly language or otherwise. Smaller programs won’t use all these sections, though most programs have at least code, stack, and data sections. Complex programs may create additional sections in memory for their own purposes. Some programs may combine several of these sections. For example, many programs will combine the code and read-only sections into the same section in memory (as the data in both sections gets marked as read-only). Some programs combine the uninitialized and initialized data <span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>sections, initializing the uninitialized variables to 0. Combining sections is generally handled by the linker program. See section 3.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_167">page 167</a></span> concerning the GNU linker.</p>&#13;
<p class="TX">Linux and macOS tend to put different types of data into different sections (or <i>segments</i>) of memory. Although it is possible to reconfigure memory to your choice by running the linker and specifying various parameters, one typical organization might be similar to that in <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig3-1" src="../images/Figure3-1.jpg" alt="" width="1211" height="713"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-1: A Linux/macOS example runtime memory organization</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This figure is just an example. Real programs will likely organize memory differently, especially when using address space layout randomization, discussed later in this chapter.</p>&#13;
<p class="TX">The OS reserves the lowest memory addresses. Generally, your application cannot access data (or execute instructions) at these low addresses. One reason the OS reserves this space is to help trap NULL pointer references: if you attempt to access memory location 0x0 (NULL), the OS will generate a <i>segmentation fault</i> (also known as a <i>general protection fault</i>), meaning you’ve accessed a memory location that doesn’t contain valid data.</p>&#13;
<p class="TX">The remaining six areas in the memory map hold different types of data associated with your program. These sections of memory include the stack section, the heap section, the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> (code) section, the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> (read-only data) section, and the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> (uninitialized data) section. Each of these memory sections corresponds to a type of data you can create in your Gas programs. I will describe the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> sections in detail next. (The OS provides the stack and heap sections; you don’t normally declare these two in an assembly language program, so there isn’t anything more to discuss about them here.)</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-49"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.1 The .text Section</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section contains the machine instructions that appear in a Gas program. Gas translates each machine instruction you write into a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>sequence of one or more word values. The CPU interprets these 32-bit word values as machine instructions during program execution.</p>&#13;
<p class="TX">By default, when GCC/Gas/<i>ld</i> links your program, it tells the system that your program can execute instructions and read data from the code segment, but cannot write data to the code segment. The OS will generate a segmentation fault if you attempt to store any data into the code segment.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-50"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.2 The .data Section</span></h4>&#13;
<p class="TNI1">You’ll typically put your variables in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section. In addition to declaring static variables, you can embed lists of data into the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> declaration section. You use the same technique to embed data into your <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section that you use to embed data into the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section: use the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.hword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span>, and so on, directives. Consider the following example:</p>&#13;
<pre id="pre-151"><code>     .data &#13;
bb:  .byte    0 &#13;
     .byte    1,2,3 &#13;
&#13;
u:   .word    1 &#13;
     .dword   5,2,10 &#13;
&#13;
c:   .byte    0 &#13;
     .byte    'a', 'b', 'c', 'd', 'e', 'f' &#13;
&#13;
bn:  .byte    0 &#13;
     .byte    true  // Assumes true is defined as 1 </code></pre>&#13;
<p class="TX">Values that Gas places in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> memory segment by using these directives are written to the segment after the preceding variables. For example, the byte values <span class="SANS_TheSansMonoCd_W5Regular_11">1,2,3</span> are emitted to the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section after <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>’s <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> byte. Because there aren’t any labels associated with these values, you do not have symbolic access to these values in your program. You can use the indexed addressing modes (described later in this chapter) to access these extra values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-51"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.3 Read-Only Data Sections</span></h4>&#13;
<p class="TNI1">Gas does not provide a stand-alone directive for creating sections that hold read-only constants. However, you can easily use the Gas <span class="SANS_TheSansMonoCd_W5Regular_11">.section</span> directive to create a generic read-only constant section as follows:</p>&#13;
<pre id="pre-152"><code>.section .rodata, ""</code></pre>&#13;
<p class="TX">Most programs use the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> identifier, by convention, for read-only data. For example, GCC uses this name for read-only constant sections. You could use any identifier you choose here. For example, I often use the name <span class="SANS_TheSansMonoCd_W5Regular_11">.const</span> for constant sections. However, as GCC uses <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, I’ll stick to that convention in this book. I’ll say more about the <span class="SANS_TheSansMonoCd_W5Regular_11">.section</span> directive a little later; for the time being, note that as long as the second argument is the empty string, Gas will create a read-only data section by using this directive.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata</span> section holds constants, tables, and other data that your program cannot change during execution. This section is similar to the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, with two differences:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section is defined with <span class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata, ""</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>.</li>&#13;
<li class="BL">The system does not allow you to write data to variables in an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> object while the program is running.</li>&#13;
</ul>&#13;
<p class="TX">Here’s an example:</p>&#13;
<pre id="pre-153"><code>         .section  .rodata, ""&#13;
pi:      .single   3.141592653589793 // (rounded) &#13;
e:       .single   2.718281828459045 // (rounded) &#13;
MaxU16:  .hword    65535 &#13;
MaxI16:  .hword    32767 </code></pre>&#13;
<p class="TX">For many purposes, you can treat <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> objects as literal constants. However, because they are actually memory objects, they behave like read-only <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> objects. You cannot use an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> object anywhere a literal constant is allowed. For example, you cannot use them as <i>displacements</i> (constant <i>offsets</i> from a base pointer) in addressing modes (see section 3.6, <span class="Xref">“The ARM Memory Addressing Modes,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_140">page 140</a></span>), in constant expressions, or as immediate values. In practice, you can use them anywhere that reading a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> variable is legal.</p>&#13;
<aside class="box" aria-label="box-10">&#13;
<p class="BH" id="box-10"><span class="SANS_Dogma_OT_Bold_B_11">LINUX VS. MACOS: FORCED CODE ALIGNMENT</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">ARM machine instructions must be aligned on a word (32-bit) boundary. The ARM cannot physically address an instruction that is not so aligned. Therefore, if you insert data into the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section that is not a multiple of 4 bytes long, any instructions following that data will be misaligned. You must always include an</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.align 2</span> <span class="SANS_Futura_Std_Book_11">(or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.balign 4</span><span class="SANS_Futura_Std_Book_11">) directive before any code appearing after data that is not a multiple of 4 bytes long in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The macOS assembler is so paranoid about this that it requires all symbols appearing in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section to be aligned on a 4-byte boundary, and it will generate an error if it encounters a label declaration (</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span><span class="SANS_Futura_Std_Book_11">, where</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">represents any identifier) that is not associated with a word-aligned address. The only way to correct this error is to insert an</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.align 2</span> <span class="SANS_Futura_Std_Book_11">(or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.balign 4</span><span class="SANS_Futura_Std_Book_11">) directive before the label declaration. This can create a problem for certain data declarations in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section. Consider the following code:</span></p>&#13;
<pre id="pre-154"><code>      .align 2 &#13;
bb:   .byte  0 &#13;
c:    .byte  0 </code></pre>&#13;
<p class="BTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/><span class="SANS_Futura_Std_Book_11">The macOS assembler will require both of these symbols to be word-aligned (requiring an</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.align 2</span> <span class="SANS_Futura_Std_Book_11">directive between them), even if you don’t want this. You might, for example, want</span> <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> <span class="SANS_Futura_Std_Book_11">to immediately follow</span> <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> <span class="SANS_Futura_Std_Book_11">in memory. The macOS assembler does not allow this. If you define a label, that label must be aligned on a word boundary.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">One solution is to avoid putting data in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section; just put your read-only constants, such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span><span class="SANS_Futura_Std_Book_11">, in their own section. However, there are good reasons for wanting to put data in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section. In those situations, you’ll have to work around this limitation when writing code for macOS.</span></p>&#13;
</aside>&#13;
<p class="TX">As with the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, you may embed data values in the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.hword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span>, and so on, data declarations. For example:</p>&#13;
<pre id="pre-155"><code>         .section  .rodata, ""&#13;
roArray: .byte     0 &#13;
         .byte     1, 2, 3, 4, 5 &#13;
dwVal:   .dword    1 &#13;
         .dword    0 </code></pre>&#13;
<p class="TX">You can also declare constant values in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. Data values you declare in this section are also read-only objects, as Linux and macOS write-protect the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. If you do place constant declarations in a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, take care to place them in a location that the program will not attempt to execute as code (such as after a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction). Unless you’re using data declarations to manually encode ARM machine instructions (which would be rare and done only by expert programmers), you don’t want your program to attempt to execute data as machine instructions; the result is usually undefined.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Technically, the result of executing data in the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.text</span> <i>section is well defined: the machine will decode whatever bit pattern you place in memory as a machine instruction. However, few people will be able to look at a piece of data and interpret its meaning as a machine instruction.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-52"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.4 The .bss Section</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section requires that you initialize objects, even if you simply place a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> in the operand field. The <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> (block started by symbol) section lets you declare variables that are always uninitialized when the program begins running. This section begins with the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> reserved word and contains variable declarations whose initializers must always be 0. Here is an example:</p>&#13;
<pre id="pre-156"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>             .bss &#13;
UninitUns32: .word  0 &#13;
i:           .word  0 &#13;
character:   .byte  0 &#13;
bb:          .byte  0 </code></pre>&#13;
<p class="TX">The OS will initialize all <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> objects to 0 when it loads your program into memory. However, it’s probably not a good idea to depend on this implicit initialization. If you need an object initialized with 0, declare it in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section and explicitly set it to 0.</p>&#13;
<p class="TX">Annoyingly, Gas requires you to explicitly provide an initializer of 0 when declaring variables in the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section. Good assembly language programmers don’t like doing this, because providing their source code with an explicit value tells the reader that they are expecting that variable to contain that value when the program runs. If the program explicitly isn’t expecting the variable to be initialized, it would be nice to tell the reader that.</p>&#13;
<p class="TX">A very old convention to make this statement is to use the expression <span class="SANS_TheSansMonoCd_W5Regular_11">.-.</span> in the operand field of such declarations. For example:</p>&#13;
<pre id="pre-157"><code>             .bss &#13;
UninitUns32: .word  .-. &#13;
i:           .word  .-. &#13;
character:   .byte  .-. &#13;
bb:          .byte  .-. </code></pre>&#13;
<p class="TX">Gas substitutes the current value of the location counter (see section 3.2, <span class="Xref">“Gas Storage Allocation for Variables,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_131">page 131</a></span>) in place of the period (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>). The expression <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">location_counter</span> minus <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">location_counter</span> is equal to 0, which satisfies the Gas requirements for initializers in the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section. This strange syntax lets the reader know that you’re not explicitly expecting the variable to be initialized with 0 when the program runs.</p>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">.-.</span> is too bizarre for your tastes (or you don’t want to have to type three characters), I’ve often used something like this to get the same results:</p>&#13;
<pre id="pre-158"><code>             .equ   _, 0  // "_" is a legitimate identifier &#13;
             .bss &#13;
UninitUns32: .word  _&#13;
i:           .word  _&#13;
character:   .byte  _&#13;
bb:          .byte  _</code></pre>&#13;
<p class="TX">This book tends to use the <span class="SANS_TheSansMonoCd_W5Regular_11">.-.</span> form (when not explicitly specifying <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>), as there is historical precedence for it. This form has one drawback, however: it does not work for <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> declarations (this is a Gas limitation).</p>&#13;
<p class="TX">Variables you declare in the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section may consume less disk space in the executable file for the program. This is because Gas writes out initial values for <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> objects to the executable file, but it may use a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>compact representation for uninitialized variables you declare in the <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section. Note, however, that this behavior is dependent on the OS version and object-module format.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-53"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.5 The .section Directive</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.section</span> directive allows you to create sections using any name you please (the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section is an example). The syntax for this directive is</p>&#13;
<pre id="pre-159"><code>.section <var>identifier</var>, <var>flags</var> </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">identifier</span> is any legal Gas identifier (it does not have to begin with a period) and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">flags</span> is a string surrounded by quotes. The contents of the string vary by OS, but both Linux and macOS seem to support the following characters:</p>&#13;
<div class="top">&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_11">b</span>    Section is a <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section and will hold uninitialized data. All data declarations must have a <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> initializer.</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_11">x</span>    Section contains executable code.</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_11">w</span>    Section contains writable data.</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_11">a</span>    Section is allocatable (must be present for data sections).</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_11">d</span>    Section is a data section.</p>&#13;
</div>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">flags</span> string may contain zero or more of these characters, though certain flags (such as <span class="SANS_TheSansMonoCd_W5Regular_11">"b"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"x"</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">"d"</span>) are mutually exclusive. If the <span class="SANS_TheSansMonoCd_W5Regular_11">"w"</span> flag is not present in the string, the section will be read-only. Here are some typical <span class="SANS_TheSansMonoCd_W5Regular_11">.section</span> declarations:</p>&#13;
<pre id="pre-160"><code>.section aDataSection, "adw" // Typical data section &#13;
.section .const, ""          // Like .rodata &#13;
.section .code, "x"          // Code section (like .text) </code></pre>&#13;
<p class="TX">Each unique section you define will be given its own block of memory (such as the blocks that appear in <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>). The GNU linker/loader will merge all sections with the same name when assigning them to blocks of memory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-54"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.6 Declaration Sections</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, and other named sections may appear zero or more times in your program. The declaration sections may appear in any order, as the following example demonstrates:</p>&#13;
<pre id="pre-161"><code>            .data&#13;
i_static:   .word     0&#13;
&#13;
            .bss&#13;
i_uninit:   .word     .-.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>            .section  .rodata, ""&#13;
i_readonly: .word     5&#13;
&#13;
            .data&#13;
j:          .word     0&#13;
&#13;
            .section  .rodata, ""&#13;
i2:         .word     9&#13;
&#13;
            .bss&#13;
c:          .byte     .-.&#13;
&#13;
            .bss&#13;
d:          .word     .-.&#13;
&#13;
            .text&#13;
&#13;
<var>Code goes here.</var></code></pre>&#13;
<p class="TX">The sections may appear in an arbitrary order, and a given declaration section may appear more than once in your program. As noted previously, when multiple declaration sections of the same type (for example, the three <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> sections in the preceding example) appear in a declaration section of your program, Gas combines them into a single group, in any order it pleases.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-55"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.7 Memory Access and MMU Pages</span></h4>&#13;
<p class="TNI1">The ARM’s <i>memory management unit (MMU)</i> divides memory into blocks known as <i>pages</i>. The OS is responsible for managing pages in memory, so application programs don’t typically worry about page organization. However, when working with pages in memory, make sure you’re aware of whether the CPU even allows access to a given memory location and whether it is read/write or read-only (write-protected).</p>&#13;
<p class="TX">Each program section appears in memory in contiguous MMU pages. That is, the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section begins at offset 0 in an MMU page and sequentially consumes pages in memory for all the data appearing in that section. The next section in memory (perhaps <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>) begins at offset 0 in the next MMU page following the last page of the previous section. If that previous section (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>) does not consume an integral multiple of 4,096 bytes, padding space will be present between the end of that section’s data and the end of its last page, to guarantee that the next section begins on an MMU page boundary.</p>&#13;
<p class="TX">Each new section starts in its own MMU page because the MMU controls access to memory by using page <i>granularity</i>. For example, the MMU controls whether a page in memory is readable/writable or read-only. For <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> sections, you want the memory to be read-only. For the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, you want to allow reads and writes. Because the MMU can enforce these attributes only on a page-by-page basis, you cannot have <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section information in the same MMU page as an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/>Normally, all this is completely transparent to your code. Data you declare in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>) section is readable and writable, and data in an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section is read-only (<span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> sections are also executable). Beyond placing data in a particular section, you don’t have to worry too much about the page attributes.</p>&#13;
<p class="TX">You do need to worry about MMU page organization in memory in one situation. Sometimes it is convenient to access (read) data beyond the end of a data structure in memory. However, if that data structure is aligned with the end of an MMU page, accessing the next page in memory could be problematic. Some pages in memory are <i>inaccessible</i>; the MMU does not allow reading, writing, or execution to occur on that page. Attempting to do so will generate an ARM <i>segmentation fault</i>. This will typically crash your program, unless you have an exception handler in place to handle segmentation faults. If you have a data access that crosses a page boundary, and the next page in memory is inaccessible, this will crash your program. For example, consider a half-word access to a byte object at the very end of an MMU page, as shown in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig3-2" src="../images/Figure3-2.jpg" alt="" width="1064" height="482"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-2: Half-word access at the end of a memory-management page</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As a general rule, you should never read data beyond the end of a data structure. If for some reason you need to do so, ensure that it is legal to access the next page in memory. It goes without saying that you should never write data beyond the end of a given data structure; this is always incorrect and can create far more problems than just crashing your program (including severe security issues).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-56"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.8 PIE and ASLR</span></h4>&#13;
<p class="TNI1">As noted in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, macOS forces all code to use a position-independent executables (PIE) form. Linux doesn’t absolutely require this, but it allows you to write PIE code if you choose. There are two main reasons for PIE code: shared libraries and security, which were covered in <span class="Xref">“Linux vs. macOS: Position-Independent Executables”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_23">page 23</a></span>. However, as the behavior of PIE code profoundly affects the way you write ARM assembly language, it is worthwhile to spend a little more time discussing PIE, and especially <i>address space layout randomization (ASLR)</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>ASLR is an attempt by the OS to thwart various exploits (hacks) that try to figure out where the code and data reside in an application. Prior to PIE and ASLR, most OSes always loaded the executable code and data to the same address in memory, making it easy for a hacker to patch or otherwise mess with the executable program. By loading the code and data sections into random memory locations, PIE/ASLR make it much more difficult for exploits to tap into the executing code.</p>&#13;
<p class="TX">As a result of ASLR, the layout of an executing program in memory will not actually look like that in <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>. For one given instance of a program execution, it might look something like <a href="chapter3.xhtml#fig3-3">Figure 3-3</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-3" src="../images/Figure3-3.jpg" alt="" width="1211" height="1011"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-3: A possible memory layout for one execution of an application</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, on the next run of the program, the sections will likely be rearranged and placed at different locations in memory.</p>&#13;
<p class="TX">While PIE/ASLR makes it difficult for hackers to exploit your code, it also plays havoc with the ARM’s instruction set. Consider the following (legitimate) ARM <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction:</p>&#13;
<pre id="pre-162"><code>ldr w0, someWordVar  // Assume someWordVar is in .data </code></pre>xs&#13;
<p class="TX">This would normally load the W0 register from the 32-bit variable <span class="SANS_TheSansMonoCd_W5Regular_11">someWordVar</span> found in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section. This particular instruction uses the <i>PC-relative addressing mode</i>, which means that the instruction encodes an offset from the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction to the <span class="SANS_TheSansMonoCd_W5Regular_11">someWordVar</span> variable in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>memory. However, if you assemble this program under macOS, you get the following error:</p>&#13;
<pre id="pre-163"><code>error: unknown AArch64 fixup kind! </code></pre>&#13;
<p class="TX">Under Linux (Ubuntu and Raspberry Pi OS seem to be different; your mileage may vary), you get something like</p>&#13;
<pre id="pre-164"><code>relocation truncated to fit: R_AARCH64_LD_PREL_LO19 against `.data' </code></pre>&#13;
<p class="TX">This is a real ARM64 instruction and <i>should</i> work. In fact</p>&#13;
<pre id="pre-165"><code>ldr reg, =constant </code></pre>&#13;
<p class="Continued1">is just a special form of this instruction, and it does work.</p>&#13;
<p class="TX">The problem is due to the ARM 32-bit instruction length. If you look up the encoding for the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction in the ARM reference manual, you’ll discover that it sets aside 19 bits for the address of the memory location. This turns out to be an <i>offset</i> (a distance in bytes) from the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction (that is, the value of the 19-bit field is added to the PC to get the actual memory address). Because it’s referencing data in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, and everything is word-aligned in the text section, the 19-bit offset is actually a word offset, not a byte offset. This effectively gives the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction another 2 bits (the LO 2 bits will always be 0). This effective 21-bit offset allows the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction to access data at a location ±1MB around the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction.</p>&#13;
<p class="TX">Unfortunately, when accessing data in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, which the OS has been nice enough to place at a random address (probably farther than 1MB away), the 21-bit range of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction won’t be sufficient. This is why Gas complains about attempting to access a variable in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section with the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction. As a bottom line, you can’t use that instruction to directly access data unless that data is also in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section and isn’t more than ±1MB away.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-57"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.1.9 The .pool Section</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> section is a Gas pseudo-section in your program. As noted previously, the following instruction loads a large constant into a register by placing that constant somewhere in memory, then loading the contents of that memory location into the destination register:</p>&#13;
<pre id="pre-166"><code>ldr reg, =largeConstant </code></pre>&#13;
<p class="TX">In other words, this instruction is completely equivalent to either of the following:</p>&#13;
<pre id="pre-167"><code>    ldr x0, a64_bit_constant &#13;
    ldr w0, a32_bit_constant &#13;
     . &#13;
     . &#13;
     . &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>// Somewhere in the .text section that will never &#13;
// be executed as code: &#13;
&#13;
a64_bit_constant: .dword  <var>The_Actual_64bit_Constant_Value</var> &#13;
a32_bit_constant: .word   <var>The_Actual_32bit_Constant_Value</var> </code></pre>&#13;
<p class="TX">Gas automatically figures out an appropriate place to put such constants: near the instructions that reference them but out of the code path.</p>&#13;
<p class="TX">If you’d like to control the placement of these constants in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> directive. Wherever you place this directive in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section (and it must be in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section), Gas will emit the constants it produces. Just make sure that if you put a <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> directive in your code, you place it after an unconditional branch or return instruction so that the program flow won’t attempt to execute that data as machine instructions.</p>&#13;
<p class="TX">Normally, you don’t need to place a <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> directive in your source code, since Gas will do a reasonable job of finding a location to place its data. However, if you intend to also insert data of your own in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, you may want to insert the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> directive and place your data declarations immediately afterward. Note that the data after <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> is part of the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, so you can continue to place machine instructions after the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-43"/><span class="SANS_Futura_Std_Bold_B_11">3.2 Gas Storage Allocation for Variables</span></h3>&#13;
<p class="TNI1">Gas associates a current <i>location counter</i> with each of the declaration sections (<span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, and any other named sections). These location counters initially contain <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. Whenever you declare a variable in one of these sections (or write code in a code section), Gas associates the current value of that section’s location counter with the label and bumps up the value of that location counter by the size of the object you’re declaring.</p>&#13;
<p class="TX">For example, assume that the following is the only <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> declaration section in a program:</p>&#13;
<pre id="pre-168"><code>    .data&#13;
bb: .byte  0        // Location counter = 0, size = 1&#13;
s:  .hword 0        // Location counter = 1, size = 2&#13;
w:  .word  0        // Location counter = 3, size = 4&#13;
d:  .dword 0        // Location counter = 7, size = 8&#13;
q:  .qword 0        // Location counter = 15, size = 16&#13;
                    // Location counter is now 31.</code></pre>&#13;
<p class="TX">Variable declarations listed in a single <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section have contiguous offsets (location counter values) into the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section. Given the preceding declaration, <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> will immediately follow <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> in memory, <span class="SANS_TheSansMonoCd_W5Regular_11">w</span> will immediately follow <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> in memory, <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> will immediately follow <span class="SANS_TheSansMonoCd_W5Regular_11">w</span>, and so on. These offsets aren’t the actual runtime addresses of the variables. At runtime, the system loads each section to a base address in memory. The linker and the OS add the base address of the memory section to each of these location counter values <span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>(normally called <i>displacements</i>, or <i>offsets</i>) to produce the actual memory address of the variables.</p>&#13;
<aside class="box" aria-label="box-11">&#13;
<p class="BH" id="box-11"><span class="SANS_Dogma_OT_Bold_B_11">OBTAINING THE CURRENT LOCATION COUNTER VALUE</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">If you ever want to use the current location counter value in your program, Gas will substitute it for a single period (</span><span class="SANS_TheSansMonoCd_W5Regular_11">.</span><span class="SANS_Futura_Std_Book_11">) wherever a constant is allowed, as in the following example:</span></p>&#13;
<pre id="pre-169"><code>.dword . // Stores the address of this dword in memory</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">You’d normally use the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> <span class="SANS_Futura_Std_Book_11">operator to compute lengths of sections of code, using something like the following:</span></p>&#13;
<pre id="pre-170"><code>lbl:  .byte 0, 1, 2, 3, 4&#13;
lbl2: .hword 55&#13;
size: .word . - lbl</code></pre>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">. - lbl</span> <span class="SANS_Futura_Std_Book_11">expression computes the number of bytes between the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lbl</span> <span class="SANS_Futura_Std_Book_11">symbol and the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> <span class="SANS_Futura_Std_Book_11">label. The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> <span class="SANS_Futura_Std_Book_11">operator returns the location counter value at the beginning of the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span> <span class="SANS_Futura_Std_Book_11">directive and does not include the 4 bytes that</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span> <span class="SANS_Futura_Std_Book_11">will emit to the output file.</span></p>&#13;
</aside>&#13;
<p class="TX">Keep in mind that you may link other modules with your program (for example, from the C stdlib) or even additional <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> sections in the same source file, and the linker has to merge the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> sections. Each individual section (even when it has the same name as another section) has its own location counter that starts from 0 when allocating storage for the variables in the section. Hence, the offset of an individual variable may have little bearing on its final memory address.</p>&#13;
<p class="TX">Gas allocates memory objects you declare in <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> sections in completely different regions of memory. Therefore, you cannot assume that the following three memory objects appear in adjacent memory locations (indeed, they probably will not):</p>&#13;
<pre id="pre-171"><code>    .data&#13;
bb: .byte    0&#13;
&#13;
    .section .rodata, ""&#13;
w:  .word    0x1234&#13;
&#13;
    .bss&#13;
d:  .dword   .-.</code></pre>&#13;
<p class="TX">In fact, Gas will not even guarantee that variables you declare in separate <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> (or other) sections are adjacent in memory, even if there is nothing between the declarations in your code. For example, you cannot assume <span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>whether <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">w</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> are—or aren’t—in adjacent memory locations in the following declarations:</p>&#13;
<pre id="pre-172"><code>    .data&#13;
bb: .byte   0&#13;
&#13;
    .data&#13;
w:  .word   0x1234&#13;
&#13;
    .data&#13;
d:  .dword  0</code></pre>&#13;
<p class="TX">If your code requires these variables to consume adjacent memory locations, you must declare them in the same <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-44"/><span class="SANS_Futura_Std_Bold_B_11">3.3 Little-Endian and Big-Endian Data Organization</span></h3>&#13;
<p class="TNI1">As you learned in section 1.6.2, <span class="Xref">“The Memory Subsystem,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_14">page 14</a></span>, the ARM stores multibyte data types in memory, with the LO byte at the lowest address in memory and the HO byte at the highest address (see <a href="chapter1.xhtml#fig1-6">Figure 1-6</a>). This type of data organization in memory is known as <i>little endian</i>. Little-endian data organization, in which the LO byte comes first and the HO byte comes last, is common in many modern CPUs. It is not, however, the only possible approach.</p>&#13;
<p class="TX"><i>Big-endian</i> data organization reverses the order of the bytes in memory. The HO byte of the data structure appears first, in the lowest memory address, and the LO byte appears in the highest memory address. <a href="chapter3.xhtml#tab3-1">Table 3-1</a> describes the memory organization for half words.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab3-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-1:</span></span> <span class="SANS_Futura_Std_Book_11">Half-Word Object Memory Organization</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Data byte</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Little endian</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Big endian</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0 (LO byte)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1 (HO byte)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter3.xhtml#tab3-2">Table 3-2</a> describes the memory organization for words.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab3-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-2:</span></span> <span class="SANS_Futura_Std_Book_11">Word Object Memory Organization</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Data byte</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Little endian</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Big endian</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TCH"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0 (LO byte)</span></p></td>&#13;
<td class="TCH"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
<td class="TCH"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 3</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3 (HO byte)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 3</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/><a href="chapter3.xhtml#tab3-3">Table 3-3</a> describe the memory organization for double words.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab3-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-3:</span></span> <span class="SANS_Futura_Std_Book_11">Dword Object Memory Organization</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Data byte</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Little endian</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Big endian</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0 (LO byte)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 7</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 6</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 5</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 4</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 3</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 5</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 6</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7 (HO byte)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 7</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">base + 0</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Normally, you wouldn’t be too concerned with big-endian memory organization on an ARM CPU. However, on occasion, you may need to deal with data produced by a different CPU (or by a protocol, such as Transmission Control Protocol/Internet Protocol, or TCP/IP) that uses big-endian organization as its canonical integer format. If you were to load a big-endian value in memory into a CPU register, the value would be incorrect.</p>&#13;
<p class="TX">If you have a 16-bit big-endian value in memory and you load it into a register, its bytes will be swapped. For 16-bit values, you can correct this issue by using the <span class="SANS_TheSansMonoCd_W5Regular_11">rev16</span> instruction, which has the following syntax:</p>&#13;
<pre id="pre-173"><code>rev16 <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span> </code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src</span> are any 32- or 64-bit general-purpose registers (both must be the same size). This instruction will swap the 2 bytes in each of the 16-bit half-words in the source register; that is, this operates on <span class="SANS_TheSansMonoCd_W5Regular_11">hword0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">hword1</span> in a 32-bit register and on <span class="SANS_TheSansMonoCd_W5Regular_11">hword0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hword1</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hword2</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">hword3</span> in a 64-bit register. For example</p>&#13;
<pre id="pre-174"><code>ldr     w1, =0x12345678 &#13;
rev16   w1, w1 </code></pre>&#13;
<p class="Continued1">will produce 0x34127856 in the W1 register, having swapped bytes 0 and 1 as well as bytes 2 and 3.</p>&#13;
<p class="TX">If you have a 32-bit value in a register (32- or 64-bit), you can swap the 4 bytes in that register by using the <span class="SANS_TheSansMonoCd_W5Regular_11">rev32</span> instruction:</p>&#13;
<pre id="pre-175"><code>rev32 <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span> </code></pre>&#13;
<p class="TX">Again, the registers can be 32- or 64-bit, but both must be the same size. In a 32-bit register, this will swap bytes 0 and 3 as well as 1 and 2. In a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>64-bit register, it will swap bytes 0 and 3, 1 and 2, 7 and 4, and 6 and 5 (see <a href="chapter3.xhtml#fig3-4">Figure 3-4</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-4" src="../images/Figure3-4.jpg" alt="" width="1051" height="159"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-4: Operation of the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rev32</span> <span class="SANS_Futura_Std_Book_Oblique_11">instruction</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">rev</span> instruction will swap bytes 7 and 0, 6 and 1, 5 and 2, and 4 and 3 in a 64-bit register (see <a href="chapter3.xhtml#fig3-5">Figure 3-5</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-5" src="../images/Figure3-5.jpg" alt="" width="1051" height="232"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-5: Operation of the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rev</span> <span class="SANS_Futura_Std_Book_Oblique_11">instruction</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">rev</span> instruction accepts only 64-bit registers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-45"/><span class="SANS_Futura_Std_Bold_B_11">3.4 Memory Access</span></h3>&#13;
<p class="TNI1">Section 1.6.2, <span class="Xref">“The Memory Subsystem,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_14">page 14</a></span> describes how the ARM CPU fetches data from memory on the data bus. In an idealized CPU, the data bus is the size of the standard integer registers on the CPU; therefore, you would expect the ARM CPUs to have a 64-bit data bus. In practice, modern CPUs often make the physical data bus connection to main memory much larger in order to improve system performance. The bus brings in large chunks of data from memory in a single operation and places that data in the CPU’s <i>cache</i>, which acts as a buffer between the CPU and physical memory.</p>&#13;
<p class="TX">From the CPU’s point of view, the cache <i>is</i> memory. Therefore, when the remainder of this section discusses memory, it’s generally talking about data sitting in the cache. As the system transparently maps memory accesses into the cache, we can discuss memory as though the cache were not present and discuss the advantages of the cache as necessary.</p>&#13;
<p class="TX">On early processors predating the ARM, memory was arranged as an array of bytes (8-bit machines, such as the Intel 8088), half words (16-bit machines, such as the Intel 8086 and 80286), or words (32-bit machines, such as the 32-bit ARM CPUs). On a 16-bit machine, the LO bit of the address did not physically appear on the address bus. This means the addresses 126 and 127 put the same bit pattern on the address bus (126, with an implicit 0 in bit position 0), as shown in <a href="chapter3.xhtml#fig3-6">Figure 3-6</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/>&#13;
<figure class="IMG"><img class="img7" id="fig3-6" src="../images/Figure3-6.jpg" alt="" width="835" height="519"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-6: The address and data bus for 16-bit processors</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When reading a byte, the CPU uses the LO bit of the address to select the LO byte or HO byte on the data bus. <a href="chapter3.xhtml#fig3-7">Figure 3-7</a> shows the process when accessing a byte at an even address (126 in this figure).</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-7" src="../images/Figure3-7.jpg" alt="" width="844" height="515"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-7: Reading a byte from an even address on a 16-bit CPU</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter3.xhtml#fig3-8">Figure 3-8</a> shows memory access for the byte at an odd address (127 in this figure). Note that in both <a href="chapter3.xhtml#fig3-7">Figures 3-7</a> and <a href="chapter3.xhtml#fig3-8">3-8</a>, the address appearing on the address bus is 126.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-8" src="../images/Figure3-8.jpg" alt="" width="843" height="521"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-8: Reading a byte from an odd address on a 16-bit CPU</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>What happens when this 16-bit CPU wants to access 16 bits of data at an odd address? For example, suppose that in these figures, the CPU reads the word at address 125. When the CPU puts address 125 on the address bus, the LO bit doesn’t physically appear. Therefore, the actual address on the bus is 124. If the CPU were to read the LO 8 bits off the data bus at this point, it would get the data at address 124, not address 125.</p>&#13;
<p class="TX">Fortunately, the CPU is smart enough to figure out what’s going on here: it extracts the data from the HO 8 bits on the data bus and uses this as the LO 8 bits of the data operand. However, the HO 8 bits that the CPU needs are not found on the data bus. The CPU has to initiate a second read operation, placing address 126 on the address bus, to get the HO 8 bits (these will be sitting in the LO 8 bits of the data bus, but the CPU can figure that out). It takes two memory cycles for this read operation to complete. Therefore, the instruction reading the data from memory will take longer to execute than it would have if the data had been read from an address that was an integral multiple of 2 (16-bit alignment).</p>&#13;
<p class="TX">The same problem exists on 32-bit processors, except that the 32-bit data bus allows the CPU to read 4 bytes at a time. Reading a 32-bit value at an address that is not an integral multiple of 4 incurs the same performance penalty. However, accessing a 16-bit operand at an odd address doesn’t always guarantee an extra memory cycle—only addresses that, when divided by 4, have a remainder of 3 incur the penalty. In particular, if you access a 16-bit value (on a 32-bit bus) at an address where the LO 2 bits contain 0b01, the CPU can read the word in a single memory cycle, as shown in <a href="chapter3.xhtml#fig3-9">Figure 3-9</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-9" src="../images/Figure3-9.jpg" alt="" width="842" height="518"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-9: Accessing a word on a 32-bit data bus</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Modern ARM CPUs with cache systems have largely eliminated this problem. As long as the data (1, 2, 4, or 8 bytes in size) is fully within a <i>cache line</i>—a processor-defined number of bytes—no memory cycle penalty occurs for an unaligned access. If the access does cross a cache-line boundary, the CPU will run a little slower while it executes two memory operations to get (or store) the data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/>&#13;
<h3 class="H1" id="sec14"><span id="h1-46"/><span class="SANS_Futura_Std_Bold_B_11">3.5 Gas Support for Data Alignment</span></h3>&#13;
<p class="TNI1">To write fast programs, you must ensure that you properly align data objects in memory. Proper <i>alignment</i> means that the starting address for an object is a multiple of a certain size—usually the size of an object, if the object’s size is a power of 2 for values up to 32 bytes in length. For objects greater than 32 bytes, aligning the object on an 8-, 16-, or 32-byte address boundary is probably sufficient. For objects fewer than 16 bytes, aligning the object at an address that is the next power of 2 greater than or equal to the object’s size is usually fine.</p>&#13;
<p class="TX">As noted in the previous section, accessing data that is not aligned at an appropriate address may require extra time. Therefore, if you want to ensure that your program runs as rapidly as possible, you should try to align data objects according to their size.</p>&#13;
<p class="TX">Data becomes misaligned whenever you allocate storage for different-sized objects in adjacent memory locations. For example, if you declare a byte variable, it will consume 1 byte of storage, and the next variable you declare in that declaration section will have the address of that byte object plus 1. If the byte variable’s address happens to be an even address, the variable following that byte will start at an odd address. If that following variable is a half-word, word, or dword object, its starting address will not be optimal.</p>&#13;
<p class="TX">In this section, we’ll explore ways to ensure that a variable is aligned at an appropriate starting address based on its size. Consider the following Gas variable declarations:</p>&#13;
<pre id="pre-176"><code>    .data &#13;
w:  .word  0 &#13;
bb: .byte  0 &#13;
s:  .hword 0 &#13;
w2: .word  0 &#13;
s2: .hword 0 &#13;
b2: .byte  0 &#13;
dw: .dword 0 </code></pre>&#13;
<p class="TX">The first <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> declaration in a program places its variables at an address that is an even multiple of 4,096 bytes. Whatever variable first appears in that <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> declaration is guaranteed to be aligned on a reasonable address. Each successive variable is allocated at an address that is the sum of the sizes of all the preceding variables, plus the starting address of that <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section.</p>&#13;
<p class="TX">Therefore, assuming Gas allocates the variables in the previous example at a starting address of <span class="SANS_TheSansMonoCd_W5Regular_11">4096</span>, it will allocate them at the following addresses:</p>&#13;
<pre id="pre-177"><code>                     // Start Adrs       Length &#13;
w:    .word   0      //    4096            4 &#13;
bb:   .byte   0      //    4100            1 &#13;
s:    .hword  0      //    4101            2 &#13;
w2:   .word   0      //    4103            4 &#13;
s2:   .hword  0      //    4107            2 &#13;
b2:   .byte   0      //    4109            1 &#13;
dw:   .dword  0      //    4110            8 </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>With the exception of the first variable (which is aligned on a 4KB boundary) and the byte variables (whose alignment doesn’t matter), all these variables are misaligned. The <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">s2</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">w2</span> variables start at odd addresses, and the <span class="SANS_TheSansMonoCd_W5Regular_11">dw</span> variable is aligned on an even address that is not a multiple of 8 (word-aligned but not dword-aligned).</p>&#13;
<p class="TX">An easy way to guarantee that your variables are aligned properly is to put all the dword variables first, the word variables second, the half-word variables third, and the byte variables last in the declaration, as shown here:</p>&#13;
<pre id="pre-178"><code>      .data &#13;
dw:   .dword  0 &#13;
w:    .word   0 &#13;
w2:   .word   0 &#13;
s:    .hword  0 &#13;
s2:   .hword  0 &#13;
bb:   .byte   0 &#13;
b2:   .byte   0 </code></pre>&#13;
<p class="TX">This organization produces the following addresses in memory:</p>&#13;
<pre id="pre-179"><code>                   //  Start Adrs     Length &#13;
dw:    .dword  0   //     4096          8 &#13;
w2:    .word   0   //     4104          4 &#13;
w3:    .word   0   //     4108          4 &#13;
s:     .hword  0   //     4112          2 &#13;
s2:    .hword  0   //     4114          2 &#13;
bb:    .byte   0   //     4116          1 &#13;
b2:    .byte   0   //     4117          1 </code></pre>&#13;
<p class="Continued1">These variables are all aligned at reasonable addresses.</p>&#13;
<p class="TX">Unfortunately, it is rarely possible for you to arrange your variables in this manner. While many technical reasons make this alignment impossible, a good practical reason for not doing this is that it doesn’t let you organize your variable declarations by logical function (that is, you probably want to keep related variables next to one another, regardless of their size).</p>&#13;
<p class="TX">To resolve this problem, Gas provides the <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.balign</span> directives. As noted in section 1.2, <span class="Xref">“The Anatomy of an Assembly Language Program,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_5">page 5</a></span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> argument is a value that will be raised to that power of 2, and the <span class="SANS_TheSansMonoCd_W5Regular_11">.balign</span>’s operand is an integer that must be a power of 2 (1, 2, 4, 8, 16, and so on). These directives ensure that the next memory object will be aligned to the specified size.</p>&#13;
<p class="TX">By default, these directives will pad the data bytes they skip with 0s; in a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, Gas aligns the code by using <span class="SANS_TheSansMonoCd_W5Regular_11">nop</span> (no-operation) instructions. If you would like to use a different padding value, these two directives allow a second operand:</p>&#13;
<pre id="pre-180"><code>.align  pwr2Alignment, padValue &#13;
.balign alignment, padValue </code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>Here, <span class="SANS_TheSansMonoCd_W5Regular_11">padValue</span> must be an 8-bit constant, which these directives will use as the padding value. Gas also allows a third argument, which is the maximum allowable padding; see the Gas documentation for more details.</p>&#13;
<p class="TX">The previous example could be rewritten, using the .<span class="SANS_TheSansMonoCd_W5Regular_11">align</span> directive, as follows:</p>&#13;
<pre id="pre-181"><code>     .data &#13;
     .align  2   // Align on 4-byte boundary. &#13;
w:   .word   0 &#13;
bb:  .byte   0 &#13;
     .align  1   // Align on 2-byte boundary. &#13;
s:   .hword  0 &#13;
     .align  2   // Align on 4-byte boundary. &#13;
w2:  .word   0 &#13;
s2:  .hword  0 &#13;
b2:  .byte   0 &#13;
     .align  3   // Align on 8-byte boundary. &#13;
dw:  .dword  0 </code></pre>&#13;
<p class="TX">If Gas determines that an <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directive’s current address (location counter value) is not an integral multiple of the specified value, Gas will quietly emit extra bytes of padding after the previous variable declaration until the current address in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section is a multiple of the specified value. This makes your data larger by a few bytes, in exchange for faster access to it. Since your data will grow only slightly larger when you use this feature, this is probably a good trade-off.</p>&#13;
<p class="TX">As a general rule, if you want the fastest possible access, choose an alignment value equal to the size of the object you want to align. That is, align half words to even boundaries with an <span class="SANS_TheSansMonoCd_W5Regular_11">.align 1</span> statement, words to 4-byte boundaries with <span class="SANS_TheSansMonoCd_W5Regular_11">.align 2</span>, double words to 8-byte boundaries with <span class="SANS_TheSansMonoCd_W5Regular_11">.align 3</span>, and so on. If the object’s size is not a power of 2, align it to the next higher power of 2.</p>&#13;
<p class="TX">Data alignment isn’t always necessary, since the cache architecture of modern ARM CPUs handles most misaligned data. Use the alignment directives only with variables for which speedy access is absolutely critical.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-47"/><span class="SANS_Futura_Std_Bold_B_11">3.6 The ARM Memory Addressing Modes</span></h3>&#13;
<p class="TNI1">For the most part, the ARM uses a very standard RISC <i>load/store architecture</i>. This means that it accomplishes almost all memory access by using instructions that load registers from memory or store the value held in registers to memory. The load and store instructions access memory by using memory <i>addressing modes</i>, mechanisms the CPU uses to determine the address of a memory location. The ARM memory addressing modes provide flexible access to memory, allowing you to easily access variables, arrays, structs, pointers, and other complex data types. Mastering ARM addressing modes is an important step toward mastering ARM assembly language.</p>&#13;
<p class="TX">In addition to loads and stores, ARM uses <i>atomic instructions</i>. For the most part, these are variations of the load and store instructions, with a few <span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>extra bells and whistles needed for multiprocessing applications. Atomic instructions are beyond the scope of this text; for more information, see the ARM V8 reference manual.</p>&#13;
<p class="TX">Until now, this book has presented only two mechanisms for accessing memory: the register-indirect addressing mode (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">[X0]</span>) introduced in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, and the PC-relative addressing mode discussed in section 3.1.8, <span class="Xref">“PIE and ASLR,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_128">page 128</a></span>. However, the ARM provides more than half a dozen modes (depending on how you count them) for accessing data in memory. The following sections describe each of these modes.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-58"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.1 PC-Relative</span></h4>&#13;
<p class="TNI1">The PC-relative addressing mode is useful only for fetching values from the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, as the other sections will likely fall out of the ±1MB range of this addressing mode. Therefore, it is much easier to directly access constant data in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section than it would be in the <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> section (or another read-only section).</p>&#13;
<p class="TX">A couple of issues arise when using the PC-relative addressing mode in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. First, because the 19-bit offset buried in the 32-bit instruction encoding is shifted left 2 bits to produce a word offset (as discussed earlier), you can load only word and double-word values when using this addressing mode—no bytes or half words. For example, you can access byte and half-word values in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section with the register-indirect addressing mode, but not with the PC-relative addressing mode.</p>&#13;
<p class="TX">When accessing data in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section by using the PC-relative addressing mode, keep the following points in mind:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Under macOS, all labels in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section must be aligned on a 4-byte boundary, even if the data associated with that label doesn’t require such alignment (such as bytes and half words).</li>&#13;
<li class="BL">Data values in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section cannot refer to other sections (for example, pointer constants, discussed in <span class="listbullet_Xref"><a href="chapter4.xhtml">Chapter 4</a></span>). However, such objects can refer to data within the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section itself (this is important for <i>jump tables</i>, covered in <span class="listbullet_Xref"><a href="chapter7.xhtml">Chapter 7</a></span>).</li>&#13;
<li class="BL">The data must reside within ±1MB of the instruction(s) that reference it. For example, you cannot create an array of data that exceeds 1MB.</li>&#13;
<li class="BL">Only word and dword accesses are allowed when using the PC-relative addressing mode.</li>&#13;
<li class="BL">As the data resides in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, it is read-only; you cannot put variables in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</li>&#13;
</ul>&#13;
<p class="TX">To use the PC-relative addressing mode, just reference the label you used to declare the object in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section:</p>&#13;
<pre id="pre-182"><code>         ldr w0, wordVar &#13;
           . &#13;
           . &#13;
           . &#13;
wordVar: .word 12345 </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>Don’t forget that all data declarations you put in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section need to be out of the execution path, preferably in the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> section. (You’ll see an exception to this rule in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> when I discuss passing parameters in the code stream.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-59"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.2 Register-Indirect</span></h4>&#13;
<p class="TNI1">Up to this point, most examples in this book have used the register-indirect addressing mode. <i>Indirect</i> means that the operand is not the actual address, but that the operand’s value specifies the memory address to use. In a register-indirect addressing mode, the value held in the register is the address of the memory location to access. For example, the instruction</p>&#13;
<pre id="pre-183"><code>ldr x0, [x1] </code></pre>&#13;
<p class="Continued1">tells the CPU to load X0’s value from the location whose address is currently in X1. The square brackets around X1 tell Gas to use the register-indirect addressing mode.</p>&#13;
<p class="TX">The ARM has 32 forms of this addressing mode, one for each of the 32 general-purpose 64-bit registers (though X31 is not legal; use SP instead). You cannot specify a 32-bit register in the square brackets when using an indirect addressing mode.</p>&#13;
<p class="TX">Technically, you could load a 64-bit register with an arbitrary numeric value and access that location indirectly by using the register-indirect addressing mode:</p>&#13;
<pre id="pre-184"><code>ldr x1, =12345678 &#13;
ldr x0, [x1]    // Attempts to access location 12345678 </code></pre>&#13;
<p class="TX">Unfortunately (or fortunately, depending on how you look at it), this will probably cause the OS to generate a segmentation fault because it’s not always legal to access arbitrary memory locations. There are better ways to load the address of an object into a register, as you’ll see shortly.</p>&#13;
<p class="TX">You can use the register-indirect addressing modes to access data referenced by a pointer, to step through array data, and, in general, whenever you need to modify an object’s address while your program is running.</p>&#13;
<p class="TX">When using a register-indirect addressing mode, you refer to the value of a variable by its numeric memory address (the value you load into a register) rather than by the name of the variable. This is an example of using an <i>anonymous variable</i>.</p>&#13;
<p class="TX">The <i>aoaa.inc</i> include file provides the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro, which you can use to take the address of a variable and put it into a 64-bit register:</p>&#13;
<pre id="pre-185"><code>lea x1, j </code></pre>&#13;
<p class="TX">After executing this <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> instruction, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">[x1]</span> register-indirect addressing mode to indirectly access the value of <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> (which is how almost every example up to this point has accessed memory). In section 3.8, <span class="Xref">“Getting the Address of a Memory Object,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_153">page 153</a></span>, you’ll see how the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro works.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>&#13;
<h4 class="H2" id="sec18"><span id="h2-60"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.3 Indirect-Plus-Offset</span></h4>&#13;
<p class="TNI1">Consider the following data declaration, similar to other examples given in this book:</p>&#13;
<pre id="pre-186"><code>bVar:  .byte 0, 1, 2, 3 </code></pre>&#13;
<p class="Continued1">If you load X1 with the address of <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span>, you can access that byte (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) by using an instruction such as this:</p>&#13;
<pre id="pre-187"><code>ldrb w1, [x1]   // Load byte at bVar (0) into W1. </code></pre>&#13;
<p class="Continued1">To access the other 3 bytes following that <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> in memory, you can use the <i>indirect-plus-offset</i> addressing mode. Here is the mode’s syntax:</p>&#13;
<pre id="pre-188"><code>[X<var>n</var>|SP, #<var>signed_expression</var>] </code></pre>&#13;
<p class="Continued1"><span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">|SP</span> means X0 to X30 or SP, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">signed_expression</span> is a small integer expression in the range –256 to +255. This particular addressing mode will compute the sum of the address in X<i>n</i> (<i>n</i> = 0 to 30, or SP) with the signed constant and use that as the <i>effective memory address</i> (the memory address to access).</p>&#13;
<p class="TX">For example, if X1 contains the address of <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> from the previous example, the following instruction will fetch the byte just beyond <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> (that is, the byte containing <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> in that example):</p>&#13;
<pre id="pre-189"><code>ldrb  w0, [x1, #1] // Fetch byte at address X1 + 1. </code></pre>&#13;
<p class="TX">Once again, the 32-bit instruction size severely limits the range of this addressing mode (only 9 bits are available for the signed offset). If you need a greater offset, you must explicitly add a value to the address in X1 (perhaps using a different register if you need to maintain the base address in X1). For example, the following code does this using X2 to hold the effective address:</p>&#13;
<pre id="pre-190"><code>add  x2, x1, #2000  // Access location X1 + 2000. &#13;
ldrb w2, [x2] </code></pre>&#13;
<p class="Continued1">This computes <span class="SANS_TheSansMonoCd_W5Regular_11">X2 = X1 + 2000</span> and loads W2 with the word at that address.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-61"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.4 Scaled Indirect-Plus-Offset</span></h4>&#13;
<p class="TNI1">The <i>scaled indirect-plus-offset</i> addressing mode is a somewhat more complex variant of the indirect-plus-offset mode. It incorporates a 12-bit unsigned constant into the instruction encoding that is scaled (multiplied) by 1, 2, 4, or 8, depending on the size of the data transfer. This provides a range extension to the 9-bit signed offset of the indirect-plus-offset mode.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>This addressing mode uses the same syntax as the indirect-plus-offset addressing mode, except that it doesn’t allow signed offsets:</p>&#13;
<pre id="pre-191"><code>[X<var>n</var>|SP, #<var>unsigned_expression</var>] </code></pre>&#13;
<p class="TX">For byte transfers (<span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span>), the unsigned expression can be a value in the range 0 to 0xFFF (4,095). For half-word transfers (<span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span>), the unsigned expression can be a value in the range 0 to 0x1FFE, but the offset must be even. For word transfers (<span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>), the unsigned expression must be in the range 0 to 0x3FFC and must also be divisible by 4. For dword transfers, the unsigned expression must be in the range 0 to 0x7FF8 and must be divisible by 8. As you’ll see in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, these numbers work great for accessing elements of a byte, half-word, word, or double-word array.</p>&#13;
<p class="TX">Generally, the assembler will automatically select between the indirect-plus-offset and scaled indirect-plus-offset addressing modes, based on the value of the offset appearing in the addressing mode. Sometimes the choice might be ambiguous. For example:</p>&#13;
<pre id="pre-192"><code>ldr  w0, [X2, #16] </code></pre>&#13;
<p class="TX">Here, the assembler could choose the scaled or unscaled versions of the addressing mode. Typically, it would choose the scaled form. Its decision shouldn’t matter to your code; either form will load the appropriate word in memory into the W0 register.</p>&#13;
<p class="TX">If, for some reason, you wish to explicitly specify the unscaled addressing mode, you can do so using the <span class="SANS_TheSansMonoCd_W5Regular_11">ldur</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stur</span> instructions (load or store register unscaled).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-62"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.5 Pre-indexed</span></h4>&#13;
<p class="TNI1">The <i>pre-indexed</i> addressing mode is very similar to the indirect-plus-offset addressing mode, insofar as it combines a 64-bit register and a signed 9-bit offset. However, this addressing mode copies the sum of the register and offset into the register before accessing memory. In the end, it accesses the same address as the indirect-plus-offset mode, but once the instruction finishes, the index register points into memory at the indexed location. This mode is useful for stepping through arrays and other data structures by incrementing the register after each access in a loop.</p>&#13;
<p class="TX">Here’s the syntax for the pre-indexed addressing mode:</p>&#13;
<pre id="pre-193"><code>[X<var>n</var>|SP, #<var>signed_expression</var>]!  // X<var>n</var>|SP has the usual meaning. </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">!</span> at the end of this sequence differentiates the pre-indexed addressing mode. As with the indirect-plus-offset mode, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">signed_expression</span> value is limited—in this case, to 9 bits (–256 to +255).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>The following code fragment uses this addressing mode:</p>&#13;
<pre id="pre-194"><code>bVar:  .byte 0, 1, 2, 3 &#13;
         . &#13;
         . &#13;
         . &#13;
        lea  x0, bVar-1  // Initialize with adrs of bVar – 1. &#13;
        mov  x1, 4 &#13;
loop:   ldrb w2, [x0, #1]! &#13;
&#13;
<var>        Do something with the byte in W2.</var> &#13;
&#13;
        subs x1, x1, #1 &#13;
        bne  loop </code></pre>&#13;
<p class="TX">On the first iteration of this loop, the addressing mode adds <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to X0 so that it points at the first byte in the <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> array of 4 bytes. This also leaves X0 pointing at that first byte. On each successful iteration of the loop, X0 is incremented by 1, accessing the next byte in the <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> array.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction will set the Z flag when it decrements X1 down to 0. When that happens, the <span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> (branch if Z = 0) instruction will fall through, terminating the loop.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-63"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.6 Post-Indexed</span></h4>&#13;
<p class="TNI1">The post-indexed addressing mode is very similar to the pre-indexed addressing mode, except it uses the value of the register as the memory address <i>before</i> updating the register with the signed immediate value. Here’s the syntax for the post-indexed addressing mode:</p>&#13;
<pre id="pre-195"><code>[X<var>n</var>|SP], #<var>signed_expression  </var>// X<var>n</var>|SP has the usual meaning. </code></pre>&#13;
<p class="Continued1">Again, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">signed_expression</span> is limited to 9 bits (–256 to +255).</p>&#13;
<p class="TX">The example of the previous section can be rewritten and slightly improved by using the post-indexed addressing mode:</p>&#13;
<pre id="pre-196"><code>bVar:  .byte 0, 1, 2, 3 &#13;
         . &#13;
         . &#13;
         . &#13;
        lea  x0, bVar &#13;
        mov  x1, 4 &#13;
loop:   ldrb w2, [x0], #1 &#13;
&#13;
<var>        Do something with the byte in W2.</var> &#13;
&#13;
        subs x1, x1, #1 &#13;
        bne  loop </code></pre>&#13;
<p class="TX">This example starts with X0 pointing at <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> and ends with X0 pointing at the first byte beyond the (four-element) <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span> array. On the first iteration of this loop, the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction first uses the value in X0, pointing at <span class="SANS_TheSansMonoCd_W5Regular_11">bVar</span>, then increments X0 after fetching the byte where X0 points.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>&#13;
<h4 class="H2" id="sec22"><span id="h2-64"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.6.7 Scaled-Indexed</span></h4>&#13;
<p class="TNI1">The <i>scaled-indexed</i> addressing mode contains two register components (rather than a register and an immediate constant) that form the effective address. The syntax for this mode is the following:</p>&#13;
<pre id="pre-197"><code>[X<var>n</var>|SP, X<var>i</var>] &#13;
[X<var>n</var>|SP, W<var>i</var>, <var>extend</var>] &#13;
[X<var>n</var>|SP, X<var>i</var>, <var>extend</var>] </code></pre>&#13;
<p class="TX">The first form is the easiest to understand: it computes the effective address (EA) by adding the values in X<i>n</i> (or SP) and X<i>i</i>. Generally, X<i>n</i> (or SP) is known as the <i>base address</i>, and the value in X<i>i</i> is the index (which must be X0 to X30 or XZR). The base address is the lowest memory address of an object, and the index is an offset from that base address (much like the immediate constants in the indirect-plus-offset addressing mode). This is just a simple <i>base + index</i> addressing mode: no scaling takes place.</p>&#13;
<aside class="box" aria-label="box-12">&#13;
<p class="BH" id="box-12"><span class="SANS_Dogma_OT_Bold_B_11">WHY XN|SP, NOT X31?</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">As noted in section 1.6, “The ARM64 CPU Architecture,” on <a href="chapter1.xhtml#pg_11">page 11</a>, the stack pointer register, SP, is the same as X31. However, if you try to use X31 as the base register in an addressing mode, Gas will report an error. This is because the ARM64 CPU actually maps two separate registers to X31: SP and XZR (the zero register). You use one of those register names rather than X31.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">In addressing modes, the ARM does not allow you to use XZR as a base register. You can, however, use SP as the base register. Conversely, XZR</span> <span class="SANS_Futura_Std_Book_Oblique_11">is</span> <span class="SANS_Futura_Std_Book_11">allowed as an index register (though it’s somewhat redundant to do so), and SP is not allowed there.</span></p>&#13;
</aside>&#13;
<p class="TX">The base + index form is useful in these situations:</p>&#13;
<ul class="ul">&#13;
<li class="BL">You have a pointer to an array object in a register (X<i>n</i>, the base address), and you want to access an element of that array by using an integer index (typically in a memory variable). In this case, you would load the index into the index register (X<i>i</i>) and use the base + index mode to access the actual element.</li>&#13;
<li class="BL">You want to use the indirect-plus-offset addressing mode, but the offset is outside the range –256 to +255. In this case, you can load the larger offset into X<i>i</i> and use the base + index addressing mode to access the memory location regardless of the offset.</li>&#13;
</ul>&#13;
<p class="TX">The second and third forms of the scaled-indexed addressing mode provide an extension/scaling operation, which is quite useful for indexing into arrays whose element size is larger than a byte. Of these two <span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>scaled-indexed modes, one uses a 32-bit register as the index register, and the other uses a 64-bit register.</p>&#13;
<p class="TX">The 32-bit form is convenient because most of the time indices into an array are held in a 32-bit integer variable. If you load that 32-bit integer into a 32-bit register (W<i>i</i>), you can easily use it as an index into an array with the</p>&#13;
<pre id="pre-198"><code>[X<var>n</var>, W<var>i</var>, <var>extend</var>] </code></pre>&#13;
<p class="Continued1">form of the scaled-indexed addressing mode.</p>&#13;
<p class="TX">Ultimately, all effective addresses turn out to be 64 bits. In particular, when the CPU adds X<i>n</i> and W<i>i</i> together, it must somehow extend the W<i>i</i> index value to 64 bits prior to adding them. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extend</span> operator tells Gas how to extend W<i>i</i> to 64 bits.</p>&#13;
<p class="TX">The simplest forms of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extend</span> are the following:</p>&#13;
<pre id="pre-199"><code>[X<var>n</var>|SP, W<var>i</var>, uxtw] &#13;
[X<var>n</var>|SP, W<var>i</var>, sxtw] </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">|SP, W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">i</span><span class="SANS_TheSansMonoCd_W5Regular_11">, uxtw]</span> form zero-extends W<i>i</i> to 64 bits before adding it to X<i>n</i>, while the <span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">|SP, W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">i</span><span class="SANS_TheSansMonoCd_W5Regular_11">, sxtw]</span> form sign-extends W<i>i</i> to 64 bits before the addition.</p>&#13;
<p class="TX">Another form of the scaled-indexed addressing mode introduces the <i>scaled</i> component. This form allows you to load elements from an array of bytes, half words, words, or dwords scaled by the size of the array element (1, 2, 4, or 8 bytes). These particular forms are not stand-alone addressing modes that can be used with an arbitrary <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction. Instead, each addressing mode form is tied to a specific instruction size. The following is the allowable syntax for the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldrsb</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strb</span> instructions (W<i>d</i> is a 32-bit destination register, and W<i>s</i> is a 32-bit source register):</p>&#13;
<pre id="pre-200"><code>ldrb  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #0]  // #0 is optional; &#13;
ldrb  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #0]  // 0 is default shift. &#13;
ldrb  W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #0] &#13;
&#13;
ldrsb W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #0] &#13;
ldrsb W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #0] &#13;
ldrsb W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #0] &#13;
&#13;
strb  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #0] &#13;
strb  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #0] &#13;
strb  W<var>s</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #0] </code></pre>&#13;
<p class="TX">These forms zero- or sign-extend W<i>i</i> (or X<i>i</i>) and add the result with X<i>n</i> to produce the EA. The previous instructions are equivalent to the following (because the <span class="SANS_TheSansMonoCd_W5Regular_11">#0</span> is optional):</p>&#13;
<pre id="pre-201"><code>ldrb  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw] &#13;
ldrb  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw] &#13;
ldrb  W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>] &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/>ldrsb W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw] &#13;
ldrsb W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw] &#13;
ldrsb W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>] &#13;
&#13;
strb  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw] &#13;
strb  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw] &#13;
strb  W<var>s</var>, [X<var>n</var>|SP, X<var>i</var>] </code></pre>&#13;
<p class="TX">For the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldrsh</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strh</span> instructions, you can specify either the 0 (×1) or 1 (×2) scale factor:</p>&#13;
<pre id="pre-202"><code>ldrh  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #1]  // #0 is also legal, or &#13;
ldrh  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #1]  // no immediate value (which &#13;
ldrh  W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #1]   // defaults to 0). &#13;
&#13;
ldrsh W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #1] &#13;
ldrsh W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #1] &#13;
ldrsh W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #1] &#13;
&#13;
strh  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #1] &#13;
strh  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #1] &#13;
strh  W<var>s</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #1] </code></pre>&#13;
<p class="TX">With a scaling factor of <span class="SANS_TheSansMonoCd_W5Regular_11">#1</span>, these addressing modes compute W<i>i</i> × 2 or X<i>i</i> × 2 (after any zero or sign extension) and then add the result with the value in X<i>n</i> to produce the EA. This scales the EA to access half-word values (2 bytes per array element). If the scaling factor is <span class="SANS_TheSansMonoCd_W5Regular_11">#0</span>, no scaling occurs, as the scaling factor is 2<sup>0</sup>. The preceding code must multiply W<i>i</i> or X<i>i</i> by an appropriate scaling factor, if needed. Loading or storing half words allows a scaling factor of only 0 or 1.</p>&#13;
<p class="TX">For the 32-bit <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction (W<i>d</i> is the destination register) and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction (W<i>s</i> is the 32-bit source register), the allowable scaling factors are 0 (×1) or 2 (×4):</p>&#13;
<pre id="pre-203"><code>ldr  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #2]  // #0 is also legal, or &#13;
ldr  W<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #2]  // no immediate value (which &#13;
ldr  W<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #2]   // defaults to 0). &#13;
&#13;
str  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #2] &#13;
str  W<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #2] &#13;
str  W<var>s</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #2] </code></pre>&#13;
<p class="TX">Finally, for the 64-bit <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions, the allowable scaling factors are 0 (×1) and 3 (×8):</p>&#13;
<pre id="pre-204"><code>ldr  X<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #3]  // #0 is also legal, or &#13;
ldr  X<var>d</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #3]  // no immediate value (which &#13;
ldr  X<var>d</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #3]   // defaults to 0). &#13;
&#13;
str  X<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, sxtw #3] &#13;
str  X<var>s</var>, [X<var>n</var>|SP, W<var>i</var>, uxtw #3] &#13;
str  X<var>s</var>, [X<var>n</var>|SP, X<var>i</var>, lsl #3] </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>You’ll see the main uses for the scaled-indexed addressing modes in the next chapter, when it discusses accessing elements of arrays.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h1-48"/><span class="SANS_Futura_Std_Bold_B_11">3.7 Address Expressions</span></h3>&#13;
<p class="TNI1">Often, when accessing variables and other objects in memory, you will need to access locations immediately before or after a variable rather than at the address of the variable. For example, when accessing an element of an array, or a field of a struct, the exact element or field is probably not at the address of the variable itself. <i>Address expressions</i> provide a mechanism to access memory at an offset from the variable’s address.</p>&#13;
<p class="TX">Consider the following legal Gas syntax for a memory address. This isn’t a new addressing mode but simply an extension of the PC-relative addressing mode:</p>&#13;
<pre id="pre-205"><code><var>varName</var> + <var>offset</var></code></pre>&#13;
<p class="TX">This form computes its effective address by adding the constant offset to the variable’s address. For example, the instruction</p>&#13;
<pre id="pre-206"><code>ldr w0, i + 4</code></pre>&#13;
<p class="Continued1">loads the W0 register with the word in memory that is 4 bytes beyond the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> object (which, presumably, is in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section; see <a href="chapter3.xhtml#fig3-10">Figure 3-10</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig3-10" src="../images/Figure3-10.jpg" alt="" width="1164" height="528"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-10: Using an address expression to access data beyond a variable</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span> value in this example must be a constant (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>). If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Index</span> is a word variable, then <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">varName</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Index</span> is not a legal address expression. If you wish to specify an index that varies at runtime, you must use one of the indirect or scaled-indexed addressing modes. Also remember that the offset in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">varName</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span> is a byte address. This does not properly index into an array of objects unless <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">varName</span> is an array of bytes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The ARM CPU does not allow the use of the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ldrb</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ldrh</span> <i>instructions when using the PC-relative addressing mode. You can only load words or double words when using this addressing mode. Furthermore, because the instructions don’t encode the LO 2 bits of the offset, any offset you specify using an address expression must be a multiple of 4.</i></p>&#13;
<p class="TX">Until this point, the offset in the addressing mode examples has always been a single numeric constant. However, Gas also allows a constant expression anywhere an offset is legal. A <i>constant expression</i> consists of one or more constant terms manipulated by operators such as addition, subtraction, multiplication, division, and a wide variety of others, as shown in <a href="chapter3.xhtml#tab3-4">Table 3-4</a>. Note that operators at the same precedence level are left-associative.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab3-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 3-4:</span></span> <span class="SANS_Futura_Std_Book_11">Gas Constant Expression Operators</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Precedence</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Unary plus (no effect on expression)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Unary minus (negates expression)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Multiplication</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Division</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Shift left</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Shift right</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">|</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Bitwise OR</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Bitwise AND</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">^</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Bitwise XOR</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">!</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Bitwise AND-NOT</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Addition</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Subtraction</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Most address expressions, however, involve only addition, subtraction, multiplication, and sometimes division. Consider the following example:</p>&#13;
<pre id="pre-207"><code>ldr w0, X + 2*4</code></pre>&#13;
<p class="Continued1">This instruction will move the byte at address <span class="SANS_TheSansMonoCd_W5Regular_11">X + 8</span> into the W0 register.</p>&#13;
<p class="TX">The value <span class="SANS_TheSansMonoCd_W5Regular_11">X + 2*4</span> is an address expression that is always computed at compile time, never while the program is running. When Gas encounters the preceding instruction, it calculates</p>&#13;
<pre id="pre-208"><code>2 × 4</code></pre>&#13;
<p class="Continued1">on the spot and adds this result to the base address of <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. Gas encodes this single sum (base address of <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> plus 8) as part of the instruction; it does not emit extra instructions (that would waste time) to compute this sum for you at runtime. Because Gas computes the value of address <span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>expressions at compile time, and therefore Gas cannot know the runtime value of a variable while it is compiling the program, all components of the expression must be constants.</p>&#13;
<p class="TX">Address expressions are useful for accessing the data in memory beyond a variable, particularly when you’ve used directives like <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.hword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span>, and so on in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section to tack on additional values after a data declaration. For example, consider the program in Listing 3-1 that uses address expressions to access the four consecutive words associated with memory object <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> (each word is 4 bytes apart in memory).</p>&#13;
<pre id="pre-209"><code>// Listing3-1.S&#13;
//&#13;
// Demonstrates address expressions&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
saveLR:     .dword      0&#13;
outputVal:  .word       0&#13;
&#13;
ttlStr:     .asciz      "Listing 3-1"&#13;
fmtStr1:    .asciz      "i[0]=%d "&#13;
fmtStr2:    .asciz      "i[1]=%d "&#13;
fmtStr3:    .asciz      "i[2]=%d "&#13;
fmtStr4:    .asciz      "i[3]=%d\n"&#13;
&#13;
            .text&#13;
            .extern     printf&#13;
&#13;
            .align      2&#13;
i:          .word       0, 1, 2, 3&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            .global     getTitle&#13;
getTitle:&#13;
            lea         x0, ttlStr&#13;
            ret&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            .global     asmMain&#13;
asmMain:&#13;
&#13;
// "Magic" instruction offered without&#13;
// explanation at this point:&#13;
&#13;
            sub     sp, sp, #256&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/>// Save LR so we can return to the C++&#13;
// program later:&#13;
&#13;
            lea     x0, saveLR&#13;
            str     lr, [x0]&#13;
&#13;
// Demonstrate the use of address expressions:&#13;
&#13;
            lea     x0, fmtStr1&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ldr     w1, i + 0&#13;
            lea     x2, outputVal&#13;
            str     w1, [x2]&#13;
            vparm2  outputVal&#13;
            bl      printf&#13;
&#13;
            lea     x0, fmtStr2&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ldr     w1, i + 4&#13;
            lea     x2, outputVal&#13;
            str     w1, [x2]&#13;
            vparm2  outputVal&#13;
            bl      printf&#13;
&#13;
            lea     x0, fmtStr3&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     w1, i + 8&#13;
            lea     x2, outputVal&#13;
            str     w1, [x2]&#13;
            vparm2  outputVal&#13;
            bl      printf&#13;
&#13;
            lea     x0, fmtStr4&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> ldr     w1, i + 12&#13;
            lea     x2, outputVal&#13;
            str     w1, [x2]&#13;
            vparm2  outputVal&#13;
            bl      printf&#13;
&#13;
            lea     x0, saveLR&#13;
            ldr     lr, [x0]&#13;
            add     sp, sp, #256&#13;
            ret</code></pre>&#13;
<p class="TX">Loading W1 from location <span class="SANS_TheSansMonoCd_W5Regular_11">i + 0</span> fetches <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> from the word array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Loading W1 from location <span class="SANS_TheSansMonoCd_W5Regular_11">i + 4</span> fetches <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> from the second word in the array, located 4 bytes beyond the first element <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Loading W1 from location <span class="SANS_TheSansMonoCd_W5Regular_11">i + 8</span> fetches <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> from the third word in the array <span class="CodeAnnotation" aria-label="annotation3">❸</span>, located 8 bytes beyond the first element. Loading W1 from location <span class="SANS_TheSansMonoCd_W5Regular_11">i + 12</span> fetches <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> from the fourth word in the array <span class="CodeAnnotation" aria-label="annotation4">❹</span>, located 12 bytes beyond the first element.</p>&#13;
<p class="TX">Here’s the program’s output:</p>&#13;
<pre id="pre-210"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing3-1</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing3-1</span>&#13;
Calling Listing3-1:&#13;
i[0]=0 i[1]=1 i[2]=2 i[3]=3&#13;
Listing3-1 terminated</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/>Because the value at the address of <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, the output displays the four values <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> as though they were array elements. The address expression <span class="SANS_TheSansMonoCd_W5Regular_11">i + 4</span> tells Gas to fetch the word appearing at <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>’s address plus 4. This is the value <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, because the <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span> statement in this program emits the value <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> segment immediately after the (word/4-byte) value <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. Likewise, for <span class="SANS_TheSansMonoCd_W5Regular_11">i + 4</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">i + 8</span>, this program displays the values <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h1-49"/><span class="SANS_Futura_Std_Bold_B_11">3.8 Getting the Address of a Memory Object</span></h3>&#13;
<p class="TNI1">Up to this point, this book has used the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro to obtain the address of a memory object. Now that this chapter has provided the necessary prerequisite information, instead of treating <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> like a black box, it’s time to look behind the curtains to see what this macro is doing for you.</p>&#13;
<p class="TX">The ARM CPU provides two instructions for computing the effective address of a symbol in an assembly language program. The first is <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span>:</p>&#13;
<pre id="pre-211"><code>adr  X<var>d</var>, <var>label</var></code></pre>&#13;
<p class="TX">This instruction loads the 64-bit destination register (X<i>d</i>) with the address of the specified label. Because instruction encodings (operation codes, or <i>opcodes</i>) are limited to 32 bits, a huge caveat is attached to <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span>: it has room for only a 21-bit offset within the opcode, so <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> must be a PC-relative address within ±1MB of the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction. This effectively limits <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> to taking the address of symbols within the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</p>&#13;
<p class="TX">To rectify this situation, the ARM CPU also provides the <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> (address of a page) instruction. This instruction has roughly the same generic syntax as <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span>:</p>&#13;
<pre id="pre-212"><code>adrp X<var>d</var>, <var>label</var></code></pre>&#13;
<p class="TX">The instruction loads the address of the MMU page containing the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> into the destination register. By adding the offset of the label into that page to the value in X<i>d</i>, you can obtain the actual address of the memory object, using code that looks something like this:</p>&#13;
<pre id="pre-213"><code>adrp X<var>d</var>, <var>label</var>&#13;
add  X<var>d</var>, X<var>d</var>, <var>page_offset_of_label</var></code></pre>&#13;
<p class="Continued1">At this point, X<i>d</i> will contain the address of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span>.</p>&#13;
<p class="TX">This scheme has a couple of issues: first, computing the page offset of the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> symbol is done differently in macOS versus Linux. Second, when you use the syntax just given to try the <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> instruction, you’ll find that Gas rejects this on macOS.</p>&#13;
<p class="TX">Let’s first consider the Linux solutions to these problems, as they’re a little simpler than those for macOS. If you’re not creating a PIE application and the symbol is less than ±1MB away, you don’t have to use the <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> instruction. Instead, you can get by with the single <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction. If the data is more than ±1MB from the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span>, you must use the <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> version. If you <span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label="154"/>need to reference a memory object outside the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, you must use the <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">add</span> sequence. Here’s the code to do this:</p>&#13;
<pre id="pre-214"><code>adrp x0, <var>label</var>&#13;
add  x0, x0, :lo12:<var>label</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">:lo12:</span> item is a special operator that tells Gas to extract the LO 12 bits of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span>’s relocatable address; this value is the index into a 4,096-byte memory management page. For more information on this operator, see section 3.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_167">page 167</a></span>. Unfortunately, the macOS assembler uses a completely different syntax to obtain the LO 12 bits of an address; you must use the following instead:</p>&#13;
<pre id="pre-215"><code>adrp x0, <var>label</var>@PAGE&#13;
add  x0, x0, <var>label</var>@PAGEOFF</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro resolves this issue, automatically expanding into the appropriate sequence for whichever OS you’re using.</p>&#13;
<aside class="box" aria-label="box-13">&#13;
<p class="BH" id="box-13"><span class="SANS_Dogma_OT_Bold_B_11">LINUX VS. MACOS: ABSOLUTE ADDRESSES</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Apple’s macOS (and presumably, iOS, iPadOS, and so on) is far more restrictive about what you can and cannot do in a PIE program. Specifically, macOS does not allow any absolute pointers in your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section that reference other sections. Linux, on the other hand, doesn’t have a problem with this at all, in either PIE or non-PIE mode.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">For example, say you’re working in Linux and have the following symbol in your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section:</span></p>&#13;
<pre id="pre-216"><code>var: .word 55</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">You can use the instruction</span></p>&#13;
<pre id="pre-217"><code>ldr x0, =var</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">to load the address of that symbol into X0. If you try to use this instruction in macOS, however, the program will give the following complaint:</span></p>&#13;
<pre id="pre-218"><code>ld: Absolute addressing not allowed in arm64 code but used in&#13;
          'noPrint' referencing 'var'</code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">Likewise, if you put the statement</span></p>&#13;
<pre id="pre-219"><code>ptrToVar: .dword var</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">in your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section somewhere, Linux is perfectly happy with it, but macOS will reject it, using roughly the same message.</span></p>&#13;
<p class="BTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/><span class="SANS_Futura_Std_Book_11">Pointers into the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section from other sections are perfectly acceptable to Gas under macOS. Apparently, Apple thinks that the only way hackers are going to determine your data memory location is by looking for addresses buried in the executable code, while pointers in your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span><span class="SANS_Futura_Std_Book_11">, and other sections are immune to such attacks.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">Ultimately, this means that you’ll need to use the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> <span class="SANS_Futura_Std_Book_11">instruction (or the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> <span class="SANS_Futura_Std_Book_11">macro) to obtain at least your first pointer out of the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section. This makes assembly language programming a touch more difficult under macOS than under Linux. Fortunately, the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> <span class="SANS_Futura_Std_Book_11">macro helps smooth out these issues.</span></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-50"/><span class="SANS_Futura_Std_Bold_B_11">3.9 The Push and Pop Operations</span></h3>&#13;
<p class="TNI1">The ARM maintains a hardware stack in the stack segment of memory (for which the OS reserves the storage). The <i>stack</i> is a dynamic data structure that grows and shrinks according to certain needs of the program. It also stores important information about the program, including local variables, subroutine information, and temporary data.</p>&#13;
<p class="TX">The ARM CPU controls its stack via the SP register. When your program begins execution, the OS initializes SP with the address of the last memory location in the stack memory segment. Data is written to the stack segment by <i>pushing</i> data onto the stack and <i>popping</i> it off the stack.</p>&#13;
<p class="TX">The ARM stack must always be 16-byte aligned—that is, the SP register must always contain a value that is a multiple of 16. If you load the SP register with a value that is not 16-byte aligned, the application will immediately terminate with a bus error fault. One of the stack’s primary purposes is to provide a temporary storage area where you can save things such as register values. You will typically push a register’s value onto the stack, do some work (such as calling a function) that uses the register, and then pop that value off the stack and back into the register when you want to restore its value. However, the general-purpose registers are only 64 bits (8 bytes); pushing a dword value on the stack will not leave it 16-byte aligned, which will crash the system.</p>&#13;
<p class="TX">In this section, I’ll describe how to push and pop register values. Then I’ll present three solutions to the problem of pushing dword values that don’t leave the stack 16-byte aligned: wasting storage; pushing two registers simultaneously; and reserving storage on the stack, then moving the register’s data into this reserved area.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-65"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.1 Using Double Loads and Stores</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span> instruction will load two registers from memory simultaneously. The generic syntax for this instruction is shown here:</p>&#13;
<pre id="pre-220"><code>ldp  X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>mem</var>  // <var>mem</var> is any addressing mode&#13;
ldp  W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>mem</var>  // except PC-relative.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/>The first form will load <span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> from the memory location specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> from the memory location 8 bytes later. The second form will load <span class="SANS_TheSansMonoCd_W5Regular_11">W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> from the specified memory location and <span class="SANS_TheSansMonoCd_W5Regular_11">W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> from the location 4 bytes later.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instruction has a similar syntax; it stores a pair of registers into adjacent memory locations:</p>&#13;
<pre id="pre-221"><code>stp  X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>mem</var>  // Store X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> to mem, X<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> to mem + 8.&#13;
stp  W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>mem</var>  // Store W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> to mem, W<var>d</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> to mem + 4.&#13;
                   // <var>mem</var> is any addressing mode except&#13;
                   // PC-relative.</code></pre>&#13;
<p class="TX">These instructions have many uses. With respect to using the stack, however, the forms that load and store a pair of 64-bit registers will manipulate 16 bytes at a time—exactly what you need when pushing and popping data on the stack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-66"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.2 Executing the Basic Push Operation</span></h4>&#13;
<p class="TNI1">Many CPUs, such as the Intel x86-64, provide an explicit instruction that will push a register onto the stack. Because of the 16-byte stack alignment requirement, you can’t push a single 8-byte register onto the stack (without creating a stack fault). However, if you’re willing to use 16 bytes of space on the stack to hold a single register’s value, you can push that register’s value on the stack with the following instruction:</p>&#13;
<pre id="pre-222"><code>str X<var>s</var>, [sp, #-16]! </code></pre>&#13;
<p class="TX">Remember, the pre-indexed addressing mode will first add –16 to SP and then store X<i>s</i> (the source register) at the new location pointed at by SP. This store operation writes only to the LO 8 bytes of the 16-byte block created by dropping SP down by 16 (wasting the HO 8 bytes). However, this scheme keeps the CPU happy, so you won’t get a bus error.</p>&#13;
<p class="TX">This push operation does the following:</p>&#13;
<pre id="pre-223"><code>SP := SP - 16 &#13;
[SP] := X<var>s</var> </code></pre>&#13;
<p class="TX">For example, assuming that SP contains 0x00FF_FFE0, the instruction</p>&#13;
<pre id="pre-224"><code>str x0, [sp, #-16]! </code></pre>&#13;
<p class="Continued1">will set SP to 0x00FF_FFD0 and store the current value of X0 into memory location 0x00FF_FFD0, as <a href="chapter3.xhtml#fig3-11">Figures 3-11</a> and <a href="chapter3.xhtml#fig3-12">3-12</a> show.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>&#13;
<figure class="IMG"><img class="img7" id="fig3-11" src="../images/Figure3-11.jpg" alt="" width="1101" height="582"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-11: The stack segment before the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">str x0, [sp, #-16]!</span> <span class="SANS_Futura_Std_Book_Oblique_11">operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After the <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction, the stack looks like <a href="chapter3.xhtml#fig3-12">Figure 3-12</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-12" src="../images/Figure3-12.jpg" alt="" width="1121" height="590"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-12: The stack segment after the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">str x0, [sp, #-16]!</span> <span class="SANS_Futura_Std_Book_Oblique_11">operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Although this wastes 8 bytes of space on the stack (shown at addresses 0x00FF_FFD8 through 0x00FF_FFDF), the usage is probably temporary, and the stack space will be reclaimed when the program pops the data off the stack later.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-67"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.3 Executing the Basic Pop Operation</span></h4>&#13;
<p class="TNI1">The pop operation can be handled using the post-indexed addressing mode and a <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction:</p>&#13;
<pre id="pre-225"><code>ldr X<var>d</var>, [sp], #16 </code></pre>&#13;
<p class="TX">This instruction fetches the data from the stack, where SP is pointing, and copies that data into the destination register (X<i>d</i>). When the operation is complete, this instruction adjusts SP by 16, restoring it to its original value (its value before the push operation). <a href="chapter3.xhtml#fig3-13">Figure 3-13</a> shows the stack before the pop operation.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label="158"/>&#13;
<figure class="IMG"><img class="img7" id="fig3-13" src="../images/Figure3-13.jpg" alt="" width="1119" height="578"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-13: Before the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">str</span> <span class="SANS_Futura_Std_Book_Oblique_11">operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter3.xhtml#fig3-14">Figure 3-14</a> shows the stack organization after executing <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-14" src="../images/Figure3-14.jpg" alt="" width="1121" height="578"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-14: After the pop operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Popping a value does not erase the value in memory; it just adjusts the stack pointer so that it points at the next value above the popped value. However, never attempt to access a value you’ve popped off the stack. The next time something is pushed onto the stack, the popped value will be obliterated. Because your code isn’t the only thing that uses the stack (for example, the OS uses the stack to do subroutines), you cannot rely on data remaining in stack memory once you’ve popped it off the stack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2" id="sec29"><span id="h2-68"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.4 Preserving at Least Two Registers</span></h4>&#13;
<p class="TNI1">If you need to preserve at least two registers, you can reclaim the wasted space shown in <a href="chapter3.xhtml#fig3-11">Figures 3-11</a> and <a href="chapter3.xhtml#fig3-12">3-12</a> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instruction rather than <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>. The following code fragment demonstrates how to push and pop both X0 and X7 simultaneously:</p>&#13;
<pre id="pre-226"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>stp  x0, x7, [sp, #-16]!&#13;
 .&#13;
 .   // Use X0 and X7 for other purposes.&#13;
 .&#13;
ldp  x0, x7, [sp], #16  // Restore X0 and X7.</code></pre>&#13;
<p class="TX">The third way to push data on the stack is to drop SP down by a multiple of 16 bytes and then store the value into the stack area by indexing off the SP register. The following code does basically the same thing as the <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span> pair:</p>&#13;
<pre id="pre-227"><code>sub  sp, sp, #16   // Make room for X0 and X7.&#13;
stp  x0, x7, [sp]&#13;
 .&#13;
 .   // Use X0 and X7 for other purposes.&#13;
 .&#13;
ldp  x0, x7, [sp]&#13;
add  sp, sp, #16</code></pre>&#13;
<p class="TX">While this clearly takes more instructions (and, therefore, takes longer to execute), it’s possible to reserve the stack storage only once within a function and reuse that space throughout the execution of the function. You’ll see examples of this in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h4 class="H2" id="sec30"><span id="h2-69"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.5 Preserving Register Values on the Stack</span></h4>&#13;
<p class="TNI1">As you’ve seen in previous examples, the stack is a great place to temporarily preserve registers so they can be used for other purposes. Consider the following program outline:</p>&#13;
<pre id="pre-228"><code><var>Some instructions that use the X20 register.</var>&#13;
&#13;
<var>Some instructions that need to use X20, for a</var>&#13;
<var>different purpose than the above instructions.</var>&#13;
&#13;
<var>Some instructions that need the original value in X20.</var></code></pre>&#13;
<p class="TX">The push and pop operations are perfect for this situation. By inserting a push sequence before the middle sequence, and a pop sequence after the middle sequence, you can preserve the value in X20 across those calculations:</p>&#13;
<pre id="pre-229"><code><var>Some instructions that use the X20 register.</var>&#13;
&#13;
     str x20, [sp, #-16]!&#13;
&#13;
<var>Some instructions that need to use X20, for a</var>&#13;
<var>different purpose than the above instructions.</var>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>     ldr x20, [sp], #16&#13;
&#13;
<var>Some instructions that need the original value in X20.</var></code></pre>&#13;
<p class="TX">This push sequence copies the data computed in the first sequence of instructions onto the stack. Now the middle sequence of instructions can use X20 for any purpose it chooses. After the middle sequence of instructions finishes, the pop sequence restores the value in X20 so the last sequence of instructions can use the original value in X20.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-70"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.9.6 Saving Function Return Addresses on the Stack</span></h4>&#13;
<p class="TNI1">Throughout the example programs up to this point, I’ve preserved the return address appearing in the link register (LR) by using instructions like the following:</p>&#13;
<pre id="pre-230"><code>lea  x0, saveLR&#13;
str  lr, [x0]&#13;
 .&#13;
 .&#13;
 .&#13;
lea  x0, saveLR&#13;
ldr  lr, [x0]&#13;
ret</code></pre>&#13;
<p class="TX">I’ve also mentioned that this is a <i>truly horrible</i> way of preserving the value in LR. It takes six instructions to accomplish (remember, <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> expands into two instructions), making it slower and bulkier than it needs to be. This scheme also creates problems when you have one user-written function calling another: all of a sudden, you need two separate <span class="SANS_TheSansMonoCd_W5Regular_11">saveLR</span> variables, one for each function. In the presence of recursion (see <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>) or, worse, multithreaded code, this mechanism fails completely.</p>&#13;
<p class="TX">Fortunately, saving return addresses in the stack is the perfect solution. The stack’s LIFO structure (see the next section) completely emulates the way (nested) function calls and returns work, and it takes only a single instruction to push LR onto the stack or pop LR off the stack. The earlier code sequence can be easily replaced by:</p>&#13;
<pre id="pre-231"><code>str  lr, [sp, #-16]!&#13;
 .&#13;
 .&#13;
 .&#13;
ldr  lr, [sp], #16&#13;
ret</code></pre>&#13;
<p class="TX">Using the stack to save and restore the LR register is probably the most common use of the stack. <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> discusses managing return addresses and other function-related values in much greater depth.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>&#13;
<h3 class="H1" id="sec32"><span id="h1-51"/><span class="SANS_Futura_Std_Bold_B_11">3.10 Pushing and Popping Stack Data</span></h3>&#13;
<p class="TNI1">You can push more than one value onto the stack without first popping previous values off the stack. However, the stack is a <i>last-in, first-out (LIFO)</i> data structure, so you must be careful in the way you push and pop multiple values.</p>&#13;
<p class="TX">For example, suppose you want to preserve X0 and X1 across a block of instructions. The following code demonstrates the obvious (but incorrect) way to handle this:</p>&#13;
<pre id="pre-232"><code>str  x0, [sp, #-16]!&#13;
str  x1, [sp, #-16]!&#13;
   <var>Code that uses X0 and X1 goes here.</var>&#13;
ldr  x0, [sp], #16&#13;
ldr  x1, [sp], #16</code></pre>&#13;
<p class="TX">Unfortunately, this code will not work properly! <a href="chapter3.xhtml#fig3-15">Figures 3-15</a> through <a href="chapter3.xhtml#fig3-18">3-18</a> show the problem, with each box in these figures representing 8 bytes (note the addresses). Because this code pushes X0 first and X1 second, the stack pointer is left pointing at X1’s value on the stack.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-15" src="../images/Figure3-15.jpg" alt="" width="1014" height="659"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-15: The stack after pushing X0</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter3.xhtml#fig3-16">Figure 3-16</a> shows the stack after pushing the second register (X1).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>&#13;
<figure class="IMG"><img class="img7" id="fig3-16" src="../images/Figure3-16.jpg" alt="" width="1017" height="659"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-16: The stack after pushing X1</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr x0, [sp], #16</span> instruction comes along, it removes the value that was originally in X1 from the stack and places it in X0 (see <a href="chapter3.xhtml#fig3-17">Figure 3-17</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-17" src="../images/Figure3-17.jpg" alt="" width="1074" height="688"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-17: The stack after popping X0</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Likewise, the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr x1, [sp], #16</span> instruction pops the value that was originally in X0 into the X1 register. In the end, this code manages to swap the values in the registers by popping them in the same order that it pushes them (see <a href="chapter3.xhtml#fig3-18">Figure 3-18</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/>&#13;
<figure class="IMG"><img class="img7" id="fig3-18" src="../images/Figure3-18.jpg" alt="" width="1069" height="659"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-18: The stack after popping X1</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To rectify this problem, because the stack is a LIFO data structure, the first thing you must pop is the last thing you push onto the stack. Therefore, <i>always pop values in the reverse order that you push them.</i></p>&#13;
<p class="TX">The correction to the previous code is shown here:</p>&#13;
<pre id="pre-233"><code>str  x0, [sp, #-16]!&#13;
str  x1, [sp, #-16]!&#13;
   <var>Code that uses X0 and X1 goes here.</var>&#13;
ldr  x1, [sp], #16&#13;
ldr  x0, [sp], #16</code></pre>&#13;
<p class="TX">Also remember to <i>always pop exactly the same number of bytes that you push.</i> In general, this means you’ll need exactly the same the number of pushes and pops. If you have too few pops, you will leave data on the stack, which may confuse the running program. If you have too many pops, you will accidentally remove previously pushed data, often with disastrous results.</p>&#13;
<p class="TX">As a corollary, <i>be careful when pushing and popping data within a loop.</i> It’s easy to put the pushes in a loop and leave the pops outside the loop (or vice versa), creating an inconsistent stack. Remember, it’s the execution of the push and pop operations that matters, not the number of push and pop operations that appear in your program. At runtime, the number (and order) of the push operations the program executes must match the number (and reverse order) of the pop operations.</p>&#13;
<p class="TX">Finally, remember that <i>the ARM requires the stack to be aligned on a 16-byte boundary</i>. If you push and pop items on the stack (or use any other instructions that manipulate the stack), make sure that the stack is aligned on a 16-byte boundary before calling any functions or procedures that adhere to the ARM requirements.</p>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-71"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.10.1 Removing Data from the Stack Without Popping It</span></h4>&#13;
<p class="TNI1">You may often discover that you’ve pushed data you no longer need onto the stack. Although you could pop the data into an unused register, there <span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/>is an easier way to remove unwanted data from the stack: simply adjust the value in the SP register to skip over the unwanted data on the stack.</p>&#13;
<p class="TX">Consider the following dilemma (in pseudocode, not actual assembly language):</p>&#13;
<pre id="pre-234"><code>str  x0, [sp, #-16]!  // Push X0. &#13;
str  x1, [sp, #-16]!  // Push X1. &#13;
&#13;
<var>Some code that winds up computing some values we want</var> &#13;
<var>to keep in X0 and X1.</var> &#13;
&#13;
if(<var>Calculation_was_performed</var>) then &#13;
&#13;
      // Whoops, we don't want to pop X0 and X1! &#13;
      // What to do here? &#13;
&#13;
else &#13;
&#13;
      // No calculation, so restore X1, X0. &#13;
&#13;
      ldr  x1, [sp], #16 &#13;
      ldr  x0, [sp], #16 &#13;
&#13;
endif; </code></pre>&#13;
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> section of the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement, this code wants to remove the old values of X0 and X1 without otherwise affecting any registers or memory locations. How can you do this?</p>&#13;
<p class="TX">Because the SP register contains the memory address of the item on the top of the stack, we can remove the item from the top by adding the size of that item to the SP register. In the preceding example, we wanted to remove two dword items from the top. We can easily accomplish this by adding 16 to the stack pointer:</p>&#13;
<pre id="pre-235"><code>str  x0, [sp, #-16]!  // Push X0 &#13;
str  x1, [sp, #-16]!  // Push X1 &#13;
&#13;
<var>Some code that winds up computing some values we want to keep</var> &#13;
<var>into rax and rbx.</var> &#13;
&#13;
if(<var>Calculation_was_performed</var>) then &#13;
&#13;
     // Remove unneeded X0/X1 values &#13;
     // from the stack. &#13;
&#13;
     add  sp, sp, #32 &#13;
&#13;
else &#13;
&#13;
     // No calculation, so restore X1, X0. &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/>     ldr  x1, [sp], #16 &#13;
     ldr  x0, [sp], #16 &#13;
&#13;
endif; </code></pre>&#13;
<p class="TX">Effectively, this code pops the data off the stack without moving it anywhere. This code is faster than two dummy pop operations, because it can remove any number of bytes from the stack with a single <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> instruction.</p>&#13;
<p class="TX">Remember to keep the stack aligned on a quad-word (16-byte) boundary. This means you should always add a constant that is a multiple of 16 to SP when removing data from the stack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h4 class="H2" id="sec34"><span id="h2-72"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">3.10.2 Accessing Data Pushed onto the Stack Without Popping It</span></h4>&#13;
<p class="TNI1">Once in a while, you’ll push data onto the stack and will want to get a copy of that data’s value, or perhaps you’ll want to change that data’s value without actually popping the data off the stack (that is, you wish to pop the data off the stack at a later time). The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">[SP, #±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] addressing mode provides the mechanism for this.</p>&#13;
<p class="TX">Consider the stack after the execution of the following instruction:</p>&#13;
<pre id="pre-236"><code>stp  x0, x1, [sp, #-16]!  // Push X0 and X1. </code></pre>&#13;
<p class="TX">This produces the stack result shown in <a href="chapter3.xhtml#fig3-19">Figure 3-19</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig3-19" src="../images/Figure3-19.jpg" alt="" width="628" height="388"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 3-19: The stack after pushing X0 and X1</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you wanted to access the original X0 value without removing it from the stack, you could cheat by popping the value, then immediately pushing it again. Suppose, however, that you wish to access X1’s old value or another value even farther up the stack. Popping all the intermediate values and then pushing them back onto the stack is problematic at best, impossible at worst.</p>&#13;
<p class="TX">However, as <a href="chapter3.xhtml#fig3-19">Figure 3-19</a> shows, each value pushed on the stack is at a certain offset from the SP register in memory. Therefore, we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">[SP, #±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] addressing mode to gain direct access to the value we are interested in. In the preceding example, you can reload X1 with its original value by using this single instruction:</p>&#13;
<pre id="pre-237"><code>ldr  x1, [sp, #8] </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/>This code copies the 8 bytes starting at memory address SP + 8 into the X1 register. This value just happens to be the previous value of X1 that was pushed onto the stack. You can use this same technique to access other data values you’ve pushed onto the stack.</p>&#13;
<p class="TX">Don’t forget that the offsets of values from SP into the stack change every time you push or pop data. Abusing this feature can create code that is hard to modify; using this feature throughout your code will make it difficult to push and pop other data items between the point where you first push data onto the stack and the point where you decide to access that data again using the <span class="SANS_TheSansMonoCd_W5Regular_11">[SP, #±</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] memory addressing mode.</p>&#13;
<p class="TX">The previous section pointed out how to remove data from the stack by adding a constant to the SP register. That pseudocode example could probably be written more safely as this:</p>&#13;
<pre id="pre-238"><code>stp  x0, x1, [sp, #-16]! &#13;
&#13;
<var>Some code that winds up computing some values we want</var> &#13;
<var>to keep into X0 and X1.</var> &#13;
&#13;
if(Calculation_was_performed) then &#13;
&#13;
     // Overwrite saved values on the stack with &#13;
     // new X0/X1 values (so the pops that &#13;
     // follow won't change the values in X0/X1). &#13;
&#13;
     stp  x0, x1, [sp] &#13;
&#13;
endif; &#13;
ldp  x0, x1, [sp], #16 </code></pre>&#13;
<p class="TX">In this code sequence, the calculated result was stored over the top of the values saved on the stack. Later, when the program pops the values, it loads these calculated values into X0 and X1.</p>&#13;
<aside class="box" aria-label="box-14">&#13;
<p class="BH" id="box-14"><span class="SANS_Dogma_OT_Bold_B_11">THE “MAGIC” INSTRUCTIONS</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">In most of the example programs in this book so far, the following lines of code have appeared in</span> <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> <span class="SANS_Futura_Std_Book_11">(and in other functions):</span></p>&#13;
<pre id="pre-239"><code>// "Magic" instruction offered without&#13;
// explanation at this point:&#13;
&#13;
sub     sp, sp, #256&#13;
 .&#13;
 .&#13;
 .&#13;
add     sp, sp, #256</code></pre>&#13;
<p class="BoxBodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/><span class="SANS_Futura_Std_Book_11">At this point, it should be clearer what this code is doing: reserving storage on the stack (and removing that storage before returning from the function).</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11"><a href="chapter5.xhtml">Chapter 5</a> covers this scheme in greater detail when it discusses local variables and parameter functions. For the time being, just know that the purpose of these statements is to reserve storage on the stack for parameters being passed to the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> <span class="SANS_Futura_Std_Book_11">function via the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">vparmn</span> <span class="SANS_Futura_Std_Book_11">macros.</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h3 class="H1" id="sec35"><span id="h1-52"/><span class="SANS_Futura_Std_Bold_B_11">3.11 Moving On</span></h3>&#13;
<p class="TNI1">This chapter discussed memory organization and access, and how to create and access memory variables on the ARM CPU. It went over problems that can occur when accessing data beyond the end of a data structure that crosses over into a new MMU page, then discussed little- and big-endian memory organizations and how to use the ARM memory addressing modes and address expressions to access those memory objects in multiple ways. You learned how to align data in memory to improve performance, how to obtain the address of a memory object, and the purpose of the ARM stack structure.</p>&#13;
<p class="TX">Thus far, this book has generally employed only basic data types such as different-sized integers, characters, Boolean objects, and floating-point numbers. Fancier data types, such as pointers, arrays, strings, and structs are the subject of the next chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h3 class="H1" id="sec36"><span id="h1-53"/><span class="SANS_Futura_Std_Bold_B_11">3.12 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">See <i><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/gas<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_chapter<wbr/>/as<wbr/>_toc<wbr/>.html</a></i> for details on the GNU assembler.</li>&#13;
<li class="BL">Learn more about the GNU linker at <i><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/ld<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_mono<wbr/>/ld<wbr/>.html</a></i>.</li>&#13;
<li class="BL">For more about the macOS (LLVM) linker, see <i><a href="https://lld.llvm.org">https://<wbr/>lld<wbr/>.llvm<wbr/>.org</a></i>.</li>&#13;
<li class="BL">Visit the ARM developer website at <i><a href="https://developer.arm.com">https://<wbr/>developer<wbr/>.arm<wbr/>.com</a></i> for more on ARM CPUs.</li>&#13;
<li class="BL">Wikipedia offers an explanation of address space layout randomization at <i><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Address<wbr/>_space<wbr/>_layout<wbr/>_randomization</a></i>.</li>&#13;
<li class="BL">To better understand position-independent executables, see <i><a href="https://en.wikipedia.org/wiki/Position-independent_code">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Position<wbr/>-independent<wbr/>_code</a></i>.</li>&#13;
<li class="BL">For information on the <span class="SANS_TheSansMonoCd_W5Regular_11">:lo12:</span> operator, see the “Assembly Expressions” section in the document downloadable from <i><a href="https://developer.arm.com/documentation/100067/0612/armclang-Integrated-Assembler">https://<wbr/>developer<wbr/>.arm<wbr/>.com<wbr/>/documentation<wbr/>/100067<wbr/>/0612<wbr/>/armclang<wbr/>-Integrated<wbr/>-Assembler</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-15">&#13;
<p class="BH" id="box-15"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  The PC-relative addressing mode indexes off which 64-bit register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What does</span> <span class="SANS_Futura_Std_Book_Oblique_11">opcode</span> <span class="SANS_Futura_Std_Book_11">stand for?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What type of data is the PC-relative addressing mode typically used for?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What is the address range of the PC-relative addressing mode?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  In a register-indirect addressing mode, what does the register contain?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  Which of the following registers is valid for use with the register-indirect addressing mode?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  W0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  X0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  XZR</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  SP</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What instruction would you normally use to load the address of a memory object into a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What is an effective address?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  How would you align a variable in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section to an 8-byte boundary?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  What does</span> <span class="SANS_Futura_Std_Book_Oblique_11">MMU</span> <span class="SANS_Futura_Std_Book_11">stand for?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">11.  What is an address expression?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">12.  What is the difference between a big-endian value and a little-endian value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">13.  If W0 contains a 32-bit big-endian value, what instruction could you use to convert it to a little-endian value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">14.  If W0 contains a 16-bit little-endian value, what instruction could you use to convert it to a big-endian value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">15.  If X0 contains a 64-bit big-endian value, what instruction could you use to convert it to a little-endian value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">16.  Explain, step by step, what the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">str x0, [sp, #-16]!</span> <span class="SANS_Futura_Std_Book_11">instruction does.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">17.  Explain, step by step, what the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ldr x0, [sp], #16</span> <span class="SANS_Futura_Std_Book_11">instruction does.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">18.  When using the push and pop operations to preserve registers, you must always pop the registers in the <span aria-hidden="true">________</span> order that you pushed them.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">19.  What does</span> <span class="SANS_Futura_Std_Book_Oblique_11">LIFO</span> <span class="SANS_Futura_Std_Book_11">stand for?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>