- en: E
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answers to Questions
  prefs: []
  type: TYPE_NORMAL
- en: E.1 Answers to Questions in Chapter 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*cmd.exe*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*ml64.exe*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Address, data, and control
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AL, AH, AX, and EAX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BL, BH, BX, and EBX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SIL, SI, and ESI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8B, R8W, and R8D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FLAGS, EFLAGS, or RFLAGS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 2, (b) 4, (c) 16, (d) 32, (e) 8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any 8-bit register and any constant that can be represented with 8 bits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '32'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Destination** | **Constant size** |'
  prefs:
  - PREF_OL
  type: TYPE_TB
- en: '| RAX | 32 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| EAX | 32 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| AX | 16 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| AL | 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| AH | 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| mem[32] | 32 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| mem[64] | 32 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '64'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any memory operand will work, regardless of its size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`call`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ret`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application binary interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) AL, (b) AX, (c) EAX, (d) RAX, (e) XMM0, (f) RAX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX for integer operands, XMM0 for floating-point/vector operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX for integer operands, XMM1 for floating-point/vector operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 for integer operands, XMM2 for floating-point/vector operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 for integer operands, XMM3 for floating-point/vector operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dword` or `sdword`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`qword`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.2 Answers to Questions in Chapter 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 9 × 10³ + 3 × 10² + 8 × 10¹ + 4 × 10⁰ + 5 × 10^(-1) + 7 × 10^(-2) + 6 × 10^(-3)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 10, (b) 12, (c) 7, (d) 9, (e) 3, (f) 15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) A, (b) E, (c) B, (d) D, (e) 2, (f) C, (g) CF, (h) 98D1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 0001_0010_1010_1111, (b) 1001_1011_1110_0111, (c) 0100_1010, (d) 0001_0011_0111_1111,
    (e) 1111_0000_0000_1101, (f) 1011_1110_1010_1101, (g) 0100_1001_0011_1000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 10, (b) 11, (c) 15, (d) 13, (e) 14, (f) 12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 16, (b) 64, (c) 128, (d) 32, (e) 4, (f) 8, (g) 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 2, (b) 4, (c) 8, (d) 16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 16, (b) 256, (c) 65,636, (d) 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 through 7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bit 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bit 31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 0, (b) 0, (c) 0, (d) 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 0, (b) 1, (c) 1, (d) 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 0, (b) 1, (c) 1, (d) 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AND
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NOT
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XOR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`not`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1111_1011'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '0000_0010'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) and (c) and (e)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`neg`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) and (c) and (d)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jmp`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*label:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Carry, overflow, zero, and sign
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JZ
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JA, JAE, JBE, JB, JE, JNE (and the synonyms JNA, JNAE, JNB, JNBE, plus other
    synonyms)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JG, JGE, JL, JLE, JE, JNE (and the synonyms JNG, JNGE, JNL, and JNLE)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ZF = 1 if the result of the shift is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HO bit shifted out of the operand goes into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next-to-HO bit is different from the HO bit *before* the shift, the OF
    will be set; otherwise, it is cleared, though only for 1-bit shifts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SF is set equal to the HO bit of the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ZF = 1 if the result of the shift is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LO bit shifted out of the operand goes into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next-to-HO bit is different from the HO bit *before* the shift, the OF
    will be set; otherwise, it is cleared, but only for 1-bit shifts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SF is always clear after the SHR instruction because a 0 is always shifted
    into the HO bit of the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ZF = 1 if the result of the shift is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LO bit shifted out of the operand goes into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OF is always clear after SAR as it is impossible for the sign to change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SF is set equal to the HO bit of the result, though technically it will
    never change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HO bit shifted out of the operand goes into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn’t affect the ZF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LO bit shifted out of the operand goes into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn’t affect the sign flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiplication by 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Division by 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiplication and division
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract them and see if their difference is less than a small error value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A value that has a 1 bit in the HO mantissa position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 30h through 39h
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apostrophes and quotes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UTF-8, UTF-16, and UTF-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A scalar integer value that represents a single Unicode character
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A block of 65,536 different Unicode characters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.3 Answers to Questions in Chapter 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RIP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operation code, the numeric encoding for a machine instruction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static and scalar variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ±2GB
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address of the memory location to access
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lea`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final address obtained after all addressing mode calculations are completed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1, 2, 4, or 8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2GB total memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the VAR[REG] addressing mode(s) to directly access elements of an
    array using a 64-bit register as an index into the array without first loading
    the address of the array into a separate base register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.data` section can hold initialized data values; the `.data?` section can
    contain only uninitialized variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.code` and `.const`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.data` and `.data?`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An offset into a particular section (for example, `.data`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `some_ID` `label` `some_type` to inform MASM that the following data is
    of type `some_type` when, in fact, it could be another type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MASM will combine them into a single section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `align 8` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Memory management unit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `b` is at an address that is at the last byte in an MMU page and the next
    page is not readable, loading a word from the memory location starting with `b`
    will produce a general protection fault.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A constant expression plus the base address of a variable in memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To coerce the following operand type to a different type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Little-endian values appear in memory with their LO byte at the lowest address
    and the HO byte at the highest address. Big-endian values are the opposite: their
    HO byte appears at the lowest address, and their LO byte appears at the highest
    address in memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xchg al, ah` or `xchg ah, al`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bswap eax`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bswap rax`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) Subtract 8 from RSP, (b) Store the value in RAX at the location pointed
    at by RSP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) Load RAX from the 8 bytes pointed at by RSP, (b) Add 8 to RSP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last in, first out
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the data to and from the stack using the `[RSP ±` `const``]` addressing
    mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Windows ABI requires the stack to be aligned on a 16-byte boundary; pushing
    RAX might make the stack aligned on an 8-byte (but not 16-byte) boundary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.4 Answers to Questions in Chapter 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`imul` `reg``,` `constant`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`imul` `destreg``,` `srcreg``,` `constant`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`imul` `destreg``,` `srcreg`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A symbolic (named) constant for which MASM will substitute the literal constant
    for the name everywhere it appears in the source file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`=`, `equ`, `textequ`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text equates substitute a textual string that can be any text; numeric equates
    must be assigned a numeric constant value that can be represented with a 64-bit
    integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the text delimiters `<` and `>` around the string literal; for example,
    `<"a long string">`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An arithmetic expression whose value MASM can calculate during assembly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lengthof`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The offset into the current section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`this` and `$`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constant expression `$-startingLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a series of (numeric) equates, with each successive equate set to the value
    of the previous equate plus one; for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `typedef` directive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pointer is a variable in memory that holds the address of another object in
    memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the pointer variable into a 64-bit register and use the register-indirect
    addressing mode to reference that address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a `qword` data declaration, or another data type that is 64 bits in size
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `offset` operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) Uninitialized pointers, (b) Using pointers to hold an illegal value, (c)
    Using a pointer after its storage has been freed (dangling pointers), (d) Failing
    to free storage after it is no longer being used (memory leak), (e) Accessing
    indirect data by using the wrong data type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a pointer after its storage has been freed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failing to free storage after you are done using it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An aggregate type composed of smaller data objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sequence of characters ending with a 0 byte (or other 0 value)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A string containing a length value as its first element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A descriptor is a data type containing a pointer (to the character data), string
    length, and possibly other information that describes the string data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A homogenous collection of data elements (all with the same type)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory address of the first element of the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`array byte 10 dup (?)` (as an example)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply fill in the initial values as the operand field of a byte, word, dword,
    or other data declaration directive. Also, you could use a sequence of one or
    more constant values as the `dup` operator operand; for example, `5 dup (2, 3)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) `base_address` `+` `index` `* 4` (4 is the element size), (b) `W[i,j] =`
    `base_address` `+ (i * 8 + j) * 2` (2 is the element size), (c) `R[i,j,k] =` `base_address`
    `+(((i * 4) + j) * 6 + k) * 8` (8 is the element size)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An organization for multidimensional arrays where you store the elements of
    each row in the array in contiguous memory locations and then store each row,
    one after the other, in memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An organization for multidimensional arrays where you store the elements of
    each column in the array in contiguous memory locations and then store each column,
    one after the other, in memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`W word 4 dup (8 dup (?))`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A heterogeneous collection of data elements (each field could have different
    types)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`struct` and `ends`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dot operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A heterogeneous collection of data elements (each field could have different
    types); the offset of each field in the union begins at 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`union` and `ends`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fields of a record and struct appear at successive memory locations within
    the struct (each field has its own block of bytes); the fields of a union overlap
    one another, with each field beginning at offset zero in the union.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An unnamed union whose fields are treated as fields of the enclosing struct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.5 Answers to Questions in Chapter 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It pushes the return address onto the stack (the address of the next instruction
    after the call) and then jumps to the address specified by the operand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops a return address off the stack and moves the address into the RIP register,
    transferring control to the instruction just beyond the call to the current procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After popping the return address, the CPU adds this value to RSP, removing that
    number of bytes of parameters from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address of the instruction just beyond the call to the procedure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespace pollution occurs when so many symbols, identifiers, or names are defined
    in a source file that it becomes difficult to select new, unique names to use
    in that source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put two colons after the name; for example, `id::`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `option noscoped` directive just before the procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `push` instruction to save the register values on the stack upon entry
    into the procedure; then use the `pop` instruction to restore the register values
    immediately before returning from the procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code is difficult to maintain. (A secondary issue, though minor, is that it
    takes more space.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance—because you’re often preserving registers that don’t need to be
    preserved for the calling code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the subroutine attempts to return, it uses the garbage you left on the
    stack as the return address, which usually produces undefined results (a program
    crash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subroutine uses whatever was on the stack prior to the call as the return
    address, with undefined results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A collection of data, including parameters, local variables, the return address,
    and other items, associated with the call (activation) of a procedure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RBP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 8 bytes (64 bits)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '`and rsp, -16`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The section of the source file (usually the body of a procedure) where the symbol
    is visible and usable in the program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the moment storage is allocated for the variable to the point the system
    deallocates that storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables whose storage is automatically allocated upon entry into a block of
    code (usually a procedure) and automatically deallocated upon exiting that block
    of code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon entry into a procedure (or the block of code associated with that automatic
    variable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `textequ` directives or the MASM local directive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var1`: –2; `local2`: –8 (MASM aligns variable on dword boundary); `dVar`:
    –9; `qArray`: –32 (base address of array is the lowest memory address); `rlocal`:
    –40 (base address of array is the lowest memory address); `ptrVar`: –48'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`option prologue:PrologueDef` and `option epilogue:EpilogueDef`. Should also
    supply `option prologue:none` and `option epilogue:none` to turn this off.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before MASM emits any code for the procedure, after all the local directives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wherever a `ret` instruction appears
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual parameter’s value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory address of the actual parameter’s value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX, RDX, R8, and R9 (or smaller subcomponents of these registers)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XMM0, XMM1, XMM2, or XMM3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the stack, above the shadow locations (32 bytes) reserved for the arguments
    passed in the registers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedures are free to modify volatile registers without preserving their values;
    procedures must preserve the values of nonvolatile registers across a procedure
    invocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAX, RCX, RDX, R8, R9, R10, R11, XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, and the
    HO 128 bits of all the YMM and ZMM registers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RBX, RSI, RDI, RBP, RSP, R12, R13, R14, R15, and XMM6–XMM15\. Also, the direction
    flag must be clear upon return from a procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using positive offsets from the RBP register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storage reserved on the stack for parameters the caller passes in the RCX, RDX,
    R8 and R9 registers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`parm1`: RBP + 16; `parm2`: RBP + 24; `parm3`: RBP + 32; `parm4`: RBP + 40'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '`lclVar1`: RBP – 1; `lclVar2`: RBP – 4 (aligned to 2-byte boundary); `lclVar3`:
    RBP – 8; `lclVar4`: RBP – 16'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application binary interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the RAX register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The address of a procedure passed as a parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indirectly. Typically by using a `call` `parm` instruction, where `parm` is
    the procedural parameter, a qword variable containing the address of the procedure.
    You could also load the parameter value into a 64-bit register and indirectly
    call the procedure through that register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate local storage to hold the register values to preserve and move the
    register data into that storage upon procedure entry, and then move the data back
    into the registers just before returning from the procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.6 Answers to Questions in Chapter 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AL for 8-bit operands, AX for 16-bit operands, EAX for 32-bit operands, and
    RAX for 64-bit operands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8-bit `mul` operation: 16 bits; 16-bit `mul` operation: 32 bits; 32-bit `mul`
    operation: 64 bits; 64-bit `mul` operator: 128 bits. The CPU put the products
    at AX for 8×8 products, DX:AX for 16×16 products, EDX:EAX for 32×32 products,
    and RDX:RAX for 64×64 products.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The quotient in AL, AX, EAX, or RAX and the remainder in AH, DX, EDX, or RDX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign-extend AX into DX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zero-extend EAX into EDX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A division by 0 and producing a quotient that will not fit into the accumulator
    register (AL, AX, EAX, or RAX)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By setting the carry and overflow flags
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They scramble the flag; that is, they leave it in an undefined state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The extended-precision `imul` instruction produces a 2 × *n*-bit result, uses
    implied operands (AL, AX, EAX, and RAX), and modifies the AH, DX, EDX, and RDX
    registers. Also, the extended-precision `imul` instruction does not allow constant
    operands, whereas the generic `imul` instruction does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cbw`, `cwd`, `cdq`, and `cqo`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They scramble all the flags, leaving them in an undefined state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the zero flag if the two operands are equal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the carry flag if the first operand is less than the second operand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sign and overflow flags are different if the first operand is less than
    the second operand; they are the same if the first operand is greater than or
    equal to the second operand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An 8-bit register or memory location
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They set the operand to 1 if the condition is true, or to false if the condition
    is not true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `test` instruction is the same as the `and` instruction except it does not
    store the result to the destination (first) operand; it only sets the flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They both set the condition code flags the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply the operand to be tested as the first (destination) operand and an immediate
    constant containing a single 1 bit in the bit position to test. After the test
    instruction, the zero flag will contain the state of the desired bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are some possible, not the only, solutions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x = x + y`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y – z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y * z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y + z * t`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = (y + z) * t`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = -((x*y)/z)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = (y == z) && (t != 0)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are some possible, not the only, solutions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x = x * 2`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y * 5`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is another solution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y * 8`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = x /2`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y / 8`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = z / 10`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = x + y`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y – z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y * z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y + z * t`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = (y + z) * t`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = -((x * y)/z)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = x + y`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y – z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y * z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x = y + z * t`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`b = x < y`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`b = x >= y && x < z`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: E.7 Answers to Questions in Chapter 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `lea` instruction or the `offset` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`option noscoped`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`option scoped`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jmp` `reg`64 and `jmp` `mem`64'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A piece of code that maintains history information in variables or via the program
    counter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the second letter of the jump mnemonic is *n*, remove the *n*; otherwise,
    insert an *n* as the second character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jpo` and `jpe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A short code sequence used to extend the range of a jump or call instruction
    beyond the ±2GB range
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmov``cc``reg``,` `src`, where `cc` is one of the conditional suffixes (which
    follow a conditional jump), `reg` is a 16-, 32-, or 64-bit register, and `src`
    is a source register or memory location that is the same size as `reg`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can conditionally execute a large set of different types of instructions
    by using a conditional jump without the time penalty of a control transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The destination has to be a register, and 8-bit registers are not allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete Boolean evaluation of an expression evaluates all components of the
    expression, even if it is not logically necessary to do so; short-circuit evaluation
    stops as soon as it determines that the expression must be true or false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: E.8 Answers to Questions in Chapter 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You compute *x* = *y* + *z* as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: 'You compute *x* = *y* – *z* as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: 'The conversions are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: 'The conversions are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: 'The conversions are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: 'The conversions are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: E.9 Answers to Questions in Chapter 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '8'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call `qToStr` twice: once with the HO 64 bits and once with the LO 64 bits.
    Then concatenate the two strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fbstp`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the input value is negative, emit a hyphen (`-`) character and negate the
    value; then call the unsigned decimal conversion function. If the number is 0
    or positive, just call the unsigned decimal conversion function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: It will produce the full string required; the `minDigits` parameter specifies
    the minimum string size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: A string containing `fWidth` `#` characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: A character that separates a sequence of characters from other such sequences,
    such as beginning or ending a numeric string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Illegal character on input and numeric overflow during conversion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.10 Answers to Questions in Chapter 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The set of all possible input (parameter) values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The set of all possible function output (return) values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Computes AL = [RBX + AL × 1]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Byte values: domain is the set of all integers in the range 0 to 255, and the
    range is also the set of all integers in the range 0 to 255.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code implementing the functions is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: Modifying input values that are out of a specific range so that they lie within
    the input domain of the function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Main memory is so slow that it might be faster to compute the value than to
    look it up via a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.11 Answers to Questions in Chapter 11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `cpuid` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because Intel and AMD have different feature sets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: EAX = 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECX bit 20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) `_TEXT`, (b) `_DATA`, (c) `_BSS`, (d) `CONST`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PARA` or 16 bytes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: AVX/AVX2/AVX-256/AVX-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A data type within a SIMD register; typically, 1, 2, 4, or 8 bytes wide
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scalar instructions operate on a single piece of data; vector instructions operate,
    simultaneously, on two or more pieces of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 16 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 32 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 64 bytes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movd`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movaps`, `movapd`, and `movdqa`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movups`, `movupd`, and `movdqu`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movhps` or `movhpd`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movddup`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pshufb`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pshufd`, though `pshufb` could also work'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(v)pextrb`, `(v)pextrw`, `(v)pextrd`, or `(v)pextrq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(v)pinsrb`, `(v)pinsrw`, `(v)pinsrd`, or `(v)pinsrq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It takes the bits in the second operand, inverts them, and then logically ANDs
    these inverted bits with the first (destination) operand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pslldq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pslrdq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`psllq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pslrq`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The carry out of the HO bit is lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a vertical addition, the CPU sums values found in the same lane of two separate
    XMM registers; in a horizontal addition, the CPU sums values found in adjacent
    lanes of the same XMM register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the destination XMM register, by storing 0FFh in the corresponding lane of
    the destination XMM register (0 for false)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap the operands of the `pcmpgtq` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It copies the HO bit of each byte in an XMM register into the corresponding
    bit position of a general-purpose 16-bit register; for example, bit 7 of lane
    0 goes into bit 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (a) 4 on SSE, 8 on AVX2, (b) 2 on SSE, 4 on AVX2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`and rax, -16`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pxor xmm0, xmm0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pcmpeqb xmm1, xmm1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`include`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.12 Answers to Questions in Chapter 12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`and`/`andn`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`btr`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`or`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bts`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xor`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`btc`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test`/`and`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bt`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pext`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pdep`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bextr`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bsf`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bsr`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invert the register and use `bsf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invert the register and use `bsr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`popcnt`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.13 Answers to Questions in Chapter 13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile-time language
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the assembly and compilation process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo` (or `%out`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.err`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `=` directive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`!`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It replaces an expression with text representing the value of that compile-time
    expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It replaces a text symbol with the expansion of its text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It concatenates two or more textual strings at assembly time and stores the
    result into a text symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It searches for a substring within a larger string in a MASM text object and
    returns the index of the substring into that object; 0 if the substring does not
    appear in the larger string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the length of a MASM text string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns a substring from a larger MASM text string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`if`, `elseif`, `else`, and `endif`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`while`, `for`, `forc`, and `endm`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`forc`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`macro`, `endm`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the macro’s name where you want the text expansion to occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As operands to the macro directive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify `:req` after the parameter name in the macro operand field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Macro parameters are optional, by default, if they don’t have the `:req` suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `:vararg` suffix after the last macro parameter declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use conditional assembly directives such as `ifb` or `ifnb` to see if the actual
    macro argument is blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `local` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exitm`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `exitm <text>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`opattr`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.14 Answers to Questions in Chapter 14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bytes, words, dwords, and qwords
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movs`, `cmps`, `scas`, `stos`, and `lods`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bytes and words
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RSI, RDI, and RCX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RSI and RDI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX, RSI, and AL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDI and EAX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dir = 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dir = 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the direction flag; alternatively, preserve its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`movs` and `stos`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the source and destination blocks overlap and the source address starts
    at a lower memory address than the destination block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the default condition; you would also clear the direction flag when
    the source and destination blocks overlap and the source address starts at a higher
    memory address than the destination block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Portions of the source block can be replicated in the destination block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`repe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direction flag should be clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, string instructions test RCX prior to the string operation when using a
    repeat prefix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`scasb`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stos`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lods` and `stos`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lods`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the CPU supports SSE 4.2 instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pcmpistri` and `pcmpistrm`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pcmpestri` and `pcmpestrm`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAX holds the `src1` length, and RDX holds the `src2` length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equal any, or possibly, equal range
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equal each
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equal ordered
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pcmp``X``str``Y` instructions always read 16 bytes of memory, even if the
    string is shorter than this, and there is the possibility of an MMU page fault
    when it reads data beyond the end of the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.15 Answers to Questions in Chapter 15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ifndef` and `endif`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assembly of a source file plus any files it includes or indirectly includes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`extern` and `externdef`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`externdef`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`abs`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`proc`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*nmake.exe*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multiple blocks of the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A dependent file is one that the current file depends on for its proper operation;
    the dependent file must be updated and built prior to the compilation and linking
    of the current file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete old object and executable files, and delete other cruft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A collection of object files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: E.16 Answers to Questions in Chapter 16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`/subsystem:console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.masm32.com/](https://www.masm32.com/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It slows the assembly process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/entry:``procedure_name`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MessageBox`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code that surrounds a call to a function and that changes the way you call the
    function (for example, parameter order and location)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__imp_CreateFileA`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__imp_GetLastError`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
