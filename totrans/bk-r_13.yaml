- en: '**11**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**WRITING FUNCTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining a function allows you to reuse a chunk of code without endlessly copying
    and pasting. It also allows other users to use your functions to carry out the
    same computations on their own data or objects. In this chapter, you’ll learn
    about writing your own R functions. You’ll learn how to define and use arguments,
    how to return output from a function, and how to specialize your functions in
    other ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.1 The function Command**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To define a function, use the `function` command and assign the results to an
    object name. Once you’ve done this, you can call the function using that object
    name just like any other built-in or contributed function in the workspace. This
    section will walk you through the basics of function creation and discuss some
    associated issues, such as returning objects and specifying arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.1 Function Creation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A function definition always follows this standard format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `functionname` placeholder can be any valid R object name, which is what
    you’ll ultimately use to call the function. Assign to this `functionname` a call
    to `function`, followed by parentheses with any arguments you want the function
    to have. The pseudocode includes three argument placeholders plus an ellipsis.
    Of course, the number of arguments, their tags, and whether to include an ellipsis
    all depend on the particular function you’re defining. If the function does not
    require any arguments, simply include empty parentheses: `()`. If you do include
    arguments in this definition, note that they are not objects in the workspace
    and they do not have any type or `class` attributes associated with them—they
    are merely a declaration of argument names that will be required by `functionname`.'
  prefs: []
  type: TYPE_NORMAL
- en: When the function is called, it runs the code in the braced area (also called
    the *function body* or *body code*). It can include `if` statements, loops, and
    even other function calls. When encountering an internal function call during
    execution, R follows the search rules discussed in [Chapter 9](ch09.xhtml#ch09).
    In the braced area, you can use `arg1`, `arg2`, and `arg3`, and they are treated
    as objects in the function’s lexical environment.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how those declared arguments are used in the body code, each argument
    may require a certain data type and object structure. If you’re writing functions
    that you intend for others to use, it’s important to have sound documentation
    to say what the function expects.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the function body will include one or more calls to the `return` command.
    When R encounters a `return` statement during execution, the function exits, returning
    control to the user at the command prompt. This mechanism is what allows you to
    pass results from operations in the function back to the user. This output is
    denoted in the pseudocode by `returnobject`, which is typically assigned an object
    created or calculated earlier in the function body. If there is no `return` statement,
    the function will simply return the object created by the last executed expression
    (I’ll discuss this feature more in [Section 11.1.2](ch11.xhtml#ch11lev2sec98)).
  prefs: []
  type: TYPE_NORMAL
- en: It’s time for an example. Let’s take the Fibonacci sequence generator from [Section
    10.3.2](ch10.xhtml#ch10lev2sec96) and turn it into a function in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I’ve named the function `myfib`, and it doesn’t use or require any arguments.
    The body code is identical to the example in [Section 10.3.2](ch10.xhtml#ch10lev2sec96),
    except I’ve added the third line, `cat(fib.a,", ",fib.b,", ",sep="")`, to ensure
    the first two terms, 1 and 1, are also printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can call `myfib` from the console, you have to send the function
    definition there. Highlight the code in the editor and press CTRL-R or ![image](../images/common-02.jpg)-RETURN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This imports the function into the workspace (if you enter `ls()` at the command
    prompt, `"myfib"` will now appear in the list of present objects). This step is
    required anytime you create or modify a function and want to use it from the command
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can call the function from the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It computes and prints the Fibonacci sequence up to 250, just as instructed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Rather than printing a fixed set of terms, let’s add an argument to control
    how many Fibonacci numbers are printed. Consider the following new function, `myfib2`,
    with this modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This version now takes a single argument, `thresh`. In the body code, `thresh`
    acts as a threshold determining when to end the `repeat` procedure, halt printing,
    and complete the function—once a value of `fib.b` that is greater than `thresh`
    is calculated, the `repeat` statement will exit after encountering the call to
    `break`. Therefore, the output printed to the console will be the Fibonacci sequence
    up to and including the first `fib.b` value bigger than `thresh`. This means that
    `thresh` must be supplied as a single numeric value—supplying a character string,
    for example, would make no sense.
  prefs: []
  type: TYPE_NORMAL
- en: After importing the definition of `myfib2` into the console, note the same results
    as given by the original `myfib` when you set `thresh=150`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But now you can print the sequence to any limit you want (this time using positional
    matching to specify the argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Returning Results**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to use the results of a function in future operations (rather than
    just printing output to the console), you need to return content to the user.
    Continuing with the current example, here’s a Fibonacci function that stores the
    sequence in a vector and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First you create the vector `fibseq` and assign it the first two terms of the
    sequence. This vector will ultimately become the `returnobject`. You also create
    a `counter` initialized to `2` to keep track of the current position in `fibseq`.
    Then the function enters a `repeat` statement, which overwrites `fibseq` with
    `c(fibseq,fibseq[counter-1]+fibseq[counter])`. That expression constructs a new
    `fibseq` by appending the sum of the most recent two terms to the contents of
    what is already stored in `fibseq`. For example, with `counter` starting at `2`,
    the first run of this line will sum `fibseq[1]` and `fibseq[2]`, appending the
    result as a third entry onto the original `fibseq`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `counter` is incremented, and the condition is checked. If the most recent
    value of `fibseq[counter]` is not greater than `thresh`, the loop repeats. If
    it is greater, the loop breaks, and you reach the final line of `myfib3`. Calling
    `return` ends the function and passes out the specified `returnobject` (in this
    case, the final contents of `fibseq`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing `myfib3`, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line calls `myfib3` with `thresh` assigned `150`. The output
    is still printed to the screen, but this isn’t the result of the `cat` command
    as it was earlier; it is the `returnobject`. You can assign this `returnobject`
    to a variable, such as `foo`, and `foo` is now just another R object in the global
    environment that you can manipulate. For example, you use it to create `bar` with
    a simple vector subset. This would not have been possible with either `myfib`
    or `myfib2`.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.2 Using return***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If there’s no `return` statement inside a function, the function will end when
    the last line in the body code has been run, at which point it will return the
    most recently assigned or created object in the function. If nothing is created,
    such as in `myfib` and `myfib2` from earlier, the function returns `NULL`. To
    demonstrate this point, enter the following two dummy functions in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `dummy1`, simply assigns four different objects in its lexical
    environment (not the global environment) and doesn’t explicitly return anything.
    On the other hand, `dummy2` creates the same four objects and explicitly returns
    the last one, `dd`. If you import and run the two functions, both provide the
    same return object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A function will end as soon as it evaluates a `return` command, without executing
    any remaining code in the function body. To emphasize this, consider one more
    version of the dummy function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `dummy3` has two calls to return: one in the middle and one at the end.
    But when you import and execute the function, it returns only one value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Executing `dummy3` returns only the object `aa` because only the first instance
    of `return` is executed and the function exits immediately at that point. In the
    current definition of `dummy3`, the last three lines (the assignment of `cc` and
    `dd` and the `return` of `bb`) will never be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Using `return` adds another function call to your code, so technically, it introduces
    a little extra computational expense. Because of this, some argue that `return`
    statements should be avoided unless absolutely necessary. But the additional computational
    cost of the call to `return` is small enough to be negligible for most purposes.
    Plus, `return` statements can make code more readable, making it easier to see
    where the author of a function intends it to complete and precisely what is intended
    to be supplied as output. I’ll use `return` throughout the remainder of this work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write another Fibonacci sequence function, naming it `myfib4`. This function
    should provide an option to perform either the operations available in `myfib2`,
    where the sequence is simply printed to the console, or the operations in `myfib3`,
    where a vector of the sequence is formally returned. Your function should take
    two arguments: the first, `thresh`, should define the limit of the sequence (just
    as in `myfib2` or `myfib3`); the second, `printme`, should be a logical value.
    If `TRUE`, then `myfib4` should just print; if `FALSE`, then `myfib4` should return
    a vector. Confirm the correct results arise from the following calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – `myfib4(thresh=150,printme=TRUE)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – `myfib4(1000000,T)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – `myfib4(150,FALSE)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – `myfib4(1000000,printme=F)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In [Exercise 10.4](ch10.xhtml#ch10exc4) on [page 203](ch10.xhtml#page_203),
    you were tasked with writing a `while` loop to perform integer factorial calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using your factorial `while` loop (or writing one if you didn’t do so earlier),
    write your own R function, `myfac`, to compute the factorial of an integer argument
    `int` (you may assume `int` will always be supplied as a non-negative integer).
    Perform a quick test of the function by computing 5 factorial, which is 120; 12
    factorial, which is 479,001,600; and 0 factorial, which is 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write another version of your factorial function, naming it `myfac2`. This time,
    you may still assume `int` will be supplied as an integer but not that it will
    be non-negative. If negative, the function should return `NaN`. Test `myfac2`
    on the same three values as previously, but also try using `int=-6`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**11.2 Arguments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arguments are an essential part of most R functions. In this section, you’ll
    consider how R evaluates arguments. You’ll also see how to write functions that
    have default argument values, how to make functions handle missing argument values,
    and how to pass extra arguments into an internal function call with ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.1 Lazy Evaluation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An important concept related to handling arguments in many high-level programming
    languages is *lazy evaluation*. Generally, this refers to the fact that expressions
    are evaluated only when they are needed. This applies to arguments in the sense
    that they are accessed and used only at the point they appear in the function
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see exactly how R functions recognize and use arguments during execution.
    As a working example to be used throughout this section, you’ll write a function
    to search through a specified list for matrix objects and attempt to post-multiply
    each with another matrix specified as a second argument (refer back to [Section
    3.3.5](ch03.xhtml#ch03lev2sec33) for details on matrix multiplication). The function
    will store and return the result in a new list. If no matrices are in the supplied
    list or if no appropriate matrices (given the dimensions of the multiplying matrix)
    are present, the function should return a character string informing the user
    of these facts. You can assume that if there are matrices in the specified list,
    they will be numeric. Consider the following function, which I’ll call `multiples1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function takes four arguments, with no default values assigned. The target
    list to search is intended to be supplied to `x`; the post-multiplying matrix
    is supplied to `mat`; and two other arguments, `str1` and `str2`, take character
    strings to return if `x` has no suitable members.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the body code, a vector called `matrix.flags` is created with the `sapply`
    implicit looping function. This applies the function `is.matrix` to the list argument
    `x`. The result is a logical vector of equal length as `x`, with `TRUE` elements
    where the corresponding member of `x` is in fact a matrix. If there are no matrices
    in `x`, the function hits a `return` statement, which exits the function and outputs
    the argument `str1`.
  prefs: []
  type: TYPE_NORMAL
- en: If the function did not exit at that point, this means there are indeed matrices
    in `x`. The next step is to retrieve the matrix member indexes by applying `which`
    to `matrix.flags`. A `counter` is initialized to `0` to keep track of how many
    successful matrix multiplications are carried out, and an empty list (`result`)
    is created to store any results.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you enter a `for` loop. For each member of `indexes`, the loop stores
    the matrix member at that position as `temp` and checks to see whether it’s possible
    to perform post-multiplication of `temp` by the argument `mat` (to perform the
    operation, `ncol(temp)` must equal `nrow(mat)`). If the matrices are compatible,
    `counter` is incremented, and this position of `result` is filled with the relevant
    calculation. If `FALSE`, nothing is done. The indexer, `i`, then takes on the
    next value of `indexes` and repeats until completion.
  prefs: []
  type: TYPE_NORMAL
- en: The final procedure in `multiples1` checks whether the `for` loop actually found
    any compatible matrix products. If no compatibility existed, the braced `if` statement
    code inside the `for` loop would never have been executed, and the `counter` would
    remain set to zero. So, if `counter` is still equal to zero upon completion of
    the loop, the function simply returns the `str2` argument. Otherwise, if compatible
    matrices were found, appropriate results will have been computed, and `multiples1`
    returns the `result` list, which would have at least one member.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to import and then test the function. You’ll use the following three
    list objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll set the argument `mat` to the 2 × 2 identity matrix (post-multiplying
    any appropriate matrix by this will simply return the original matrix), and you’ll
    pass in appropriate string messages for `str1` and `str2`. Here’s how the function
    works on `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The function has returned `result` with the two compatible matrices of `foo`
    (members `[[1]]` and `[[5]]`). Now let’s try it on `bar` using the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the value of `str1` has been returned. The initial check identified
    that there are no matrices in the list supplied to `x`, so the function has exited
    before the `for` loop. Finally, let’s try `baz`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here the value of `str2` was returned. Though there is a matrix in `baz` and
    the `for` loop in the body code of `multiples1` has been executed, the matrix
    is not compatible for post-multiplication by `mat`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the string arguments `str1` and `str2` are used only when the argument
    `x` does not contain a matrix with the appropriate dimensions. When you applied
    `multiples1` to `x=foo`, for example, there was no need to use `str1` or `str2`.
    R evaluates the defined expressions lazily, dictating that argument values are
    sought only at the moment they are required during execution. In this function,
    `str1` and `str2` are required only when the input list doesn’t have suitable
    matrices, so you could lazily ignore providing values for these arguments when
    `x=foo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This returns the same results as before with no problem whatsoever. Attempting
    this with `bar`, on the other hand, doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we are quite rightly chastised by R because it requires the value for `str1`.
    It informs us that the value is missing and there is no default.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.2 Setting Defaults***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous example shows one case where it’s useful to set default values
    for certain arguments. Default argument values are also sensible in many other
    situations, such as when the function has a large number of arguments or when
    arguments have natural values that are used more often than not. Let’s write a
    new version of the `multiples1` function from [Section 11.2.1](ch11.xhtml#ch11lev2sec99),
    `multiples2`, which now includes default values for `str1` and `str2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have given `str1` a default value of `"no valid matrices"` by assigning
    the string value in the formal definition of the arguments. You’ve also set a
    default for `str2` by assigning `str1` to it. If you import and execute this function
    again on the three lists, you no longer need to explicitly provide values for
    those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can now call the function, whatever the outcome, without being required
    to specify every argument in full. If you don’t want to use the default arguments
    in a specific call, you can still specify different values for those arguments
    when calling the function, and those values will overwrite the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.3 Checking for Missing Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `missing` function checks the arguments of a function to see if all required
    arguments have been supplied. It takes an argument tag and returns a single logical
    value of `TRUE` if the specified argument isn’t found. You can use `missing` to
    avoid the error you saw in an earlier call to `multiples1`, when `str1` was required
    but not supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, the `missing` function can be particularly useful in the
    body code. Consider another modification to the example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The only differences between this version and `multiples1` are in the first
    and last `if` statements. The first `if` statement checks whether there are no
    matrices in `x`, in which case it returns a string message. In `multiples1`, that
    message was always `str1`, but now you use another `if` statement with `missing(str1)`
    to see whether the `str1` argument actually has a value first. If not, the function
    returns another character string saying that `str1` was `missing`. A similar alternative
    is defined for `str2`. Here it is once more importing the function and using `foo`,
    `bar`, and `baz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using `missing` this way permits arguments to be left unsupplied in a given
    function call. It is primarily used when it’s difficult to choose a default value
    for a certain argument, yet the function still needs to handle cases when that
    argument isn’t provided. In the current example, it makes more sense to define
    defaults for `str1` and `str2`, as you did for `multiples2`, and avoid the extra
    code required to implement `missing`.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.4 Dealing with Ellipses***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 9.2.5](ch09.xhtml#ch09lev2sec86), I introduced the ellipsis, also
    called dot-dot-dot notation. The ellipsis allows you to pass in extra arguments
    without having to first define them in the argument list, and these arguments
    can then be passed to another function call within the code body. When included
    in a function definition, the ellipsis is often (but not always) placed in the
    last position because it represents a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the `myfib3` function from [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    let’s use the ellipsis to write a function that can plot the specified Fibonacci
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this function, an `if` statement checks to see whether the `plotit` argument
    is `TRUE` (which is the default value). If so, then you call `plot`, passing in
    `1:length(fibseq)` for the *x*-axis coordinates and the Fibonacci numbers themselves
    for the *y*-axis. After these coordinates, you also pass the ellipsis directly
    into `plot`. In this case, the ellipsis represents any additional arguments a
    user might pass in to control the execution of `plot`.
  prefs: []
  type: TYPE_NORMAL
- en: Importing `myfibplot` and executing the following line, the plot in [Figure
    11-1](ch11.xhtml#ch11fig1) pops up in a graphics device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here you used positional matching to assign `150` to `thresh`, leaving the default
    value for the `plotit` argument. The ellipsis is empty in this call.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The default plot produced by a call to* `myfibplot`*, with* `thresh=150`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you didn’t specify otherwise, R has simply followed the default behavior
    of `plot`. You can spruce things up by specifying more plotting options. The following
    line produces the plot in [Figure 11-2](ch11.xhtml#ch11fig2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f11-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: A plot produced by a call to* `myfibplot` *with graphical parameters
    passed in using the ellipsis*'
  prefs: []
  type: TYPE_NORMAL
- en: Here the ellipsis allows you to pass arguments to `plot` through the call to
    `myfibplot`, even though the particular graphical parameters are not explicitly
    defined arguments of `myfibplot`.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipses can be convenient, but they require care. The ambiguous `...` can represent
    any number of mysterious arguments. Good function documentation is key to indicate
    the appropriate usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to unpack the arguments passed in through an ellipsis, you can
    use the `list` function to convert those arguments into a list. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This dummy function simply takes an ellipsis and converts it to a list with
    `x <- list(...)`. This subsequently allows the object `x` to be treated the same
    way as any other list. In this case, you can summarize the object by providing
    its `names` and `class` attributes. Here’s a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Four tagged arguments, `aa`, `bb`, `cc`, and `dd`, are provided as the contents
    of the ellipsis, and they are explicitly identified within `unpackme` by using
    the simple `list(...)` operation. This construction can be useful for identifying
    or extracting specific arguments supplied through `...` in a given call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accruing annual compound interest is a common financial benefit for investors.
    Given a principal investment amount *P*, an interest rate per annum *i* (expressed
    as a percentage), and a frequency of interest paid per year *t*, the final amount
    *F* after *y* years is given as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0231-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Write a function that can compute *F* as per the following notes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Arguments must be present for *P*, *i*, *t*, and *y*. The argument for *t*
    should have a default value of 12.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Another argument giving a logical value that determines whether to `plot`
    the amount *F* at each integer time should be included. For example, if `plotit=TRUE`
    (the default) and *y* is 5 years, the plot should show the amount *F* at *y* =
    1,2,3,4,5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If this function is plotted, the plot should always be a step-plot, so `plot`
    should always be called with `type="s"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If `plotit=FALSE`, the final amount *F* should be returned as a numeric vector
    corresponding to the same integer times, as shown earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – An ellipsis should also be included to control other details of plotting,
    if it takes place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, using your function, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Work out the final amount after a 10-year investment of a principal of $5000,
    at an interest rate of 4.4 percent per annum compounded monthly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Re-create the following step-plot, which shows the result of $100 invested
    at 22.9 percent per annum, compounded monthly, for 20 years:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0232-01.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Perform another calculation based on the same parameters as in (ii), but this
    time, assume the interest is compounded annually. Return and store the results
    as a numeric vector. Then, use `lines` to add a second step-line, corresponding
    to this annually accrued amount, to the plot created previously. Use a different
    color or line type and make use of the `legend` function so the two lines can
    be differentiated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A *quadratic equation* in the variable *x* is often expressed in the following
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*k*[1]*x*² + *k*[2]*x* + *k[3]* = 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, *k*[1], *k*[2], and *k[3]* are constants. Given values for these constants,
    you can attempt to find up to two *real roots*—values of *x* that satisfy the
    equation. Write a function that takes *k*[1], *k*[2], and *k[3]* as arguments
    and finds and returns any solutions (as a numeric vector) in such a situation.
    This is achieved as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Evaluate ![image](../images/f0233-01.jpg). If this is negative, there are
    no solutions, and an appropriate message should be printed to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If ![image](../images/f0233-01.jpg) is zero, then there is one solution, computed
    by −*k*[2]/2*k*[1].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If ![image](../images/f0233-01.jpg) is positive, then there are two solutions,
    given by ![image](../images/f0233-02.jpg) and ![image](../images/f0233-03.jpg).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – No default values are needed for the three arguments, but the function should
    check to see whether any are missing. If so, an appropriate character string message
    should be returned to the user, informing the user that the calculations are not
    possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, test your function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Confirm the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '* 2*x*² − *x* − 5 has roots 1.850781 and −1.350781.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* *x*² + *x* + 1 has no real roots.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attempt to find solutions to the following quadratic equations:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '* 1.3*x*² − 8*x* − 3.13'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* 2.25*x*² − 3*x* + 1'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* 1.4*x*² − 2.2*x* − 5.1'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* −5*x*² + 10.11*x* − 9.9'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your programmed response in the function if one of the arguments is missing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**11.3 Specialized Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll look at three kinds of specialized user-defined R functions.
    First, you’ll look at helper functions, which are designed to be called multiple
    times by another function (and they can even be defined inside the body of a parent
    function). Next, you’ll look at disposable functions, which can be directly defined
    as an argument to another function call. Finally, you’ll look at recursive functions,
    which call themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.3.1 Helper Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is common for R functions to call other functions from within their body
    code. A *helper function* is a general term used to describe functions written
    and used specifically to facilitate the computations carried out by another function.
    They’re a good way to improve the readability of complicated functions.
  prefs: []
  type: TYPE_NORMAL
- en: A helper function can be either defined internally (within another function
    definition) or externally (within the global environment). In this section, you’ll
    see an example of each.
  prefs: []
  type: TYPE_NORMAL
- en: '**Externally Defined**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Building on the `multiples2` function from [Section 11.2.2](ch11.xhtml#ch11lev2sec100),
    here’s a new version that splits the functionality over two separate functions,
    one of which is an externally defined helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you import and execute this code on the sample lists from earlier, it behaves
    the same way as the previous version. All you’ve done here is moved the matrix-checking
    loop to an external function. The `multiples4` function now calls a helper function
    named `multiples_helper_ext`. Once the code in `multiples4` makes sure that there
    are in fact matrices in the list `x` to be checked, it calls `multiples_helper_ext`
    to execute the required loop. This helper function is defined externally, meaning
    that it exists in the global environment for any other function to call, making
    it easier to reuse.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internally Defined**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the helper function is intended to be used for only one particular function,
    it makes more sense to define the helper function internally, within the lexical
    environment of the function that calls it. The fifth version of the matrix multiplication
    function does just that, shifting the definition to within the body code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now the helper function `multiples_helper_int` is defined within `multiples5`.
    That means it’s visible only within the lexical environment as opposed to residing
    in the global environment like `multiples_helper_ext`. It makes sense to internally
    define a helper function when (a) it’s used only by a single parent function,
    and (b) it’s called multiple times within the parent function. (Of course, `multiples5`
    satisfies only (a), and it’s provided here just for the sake of illustration.)
  prefs: []
  type: TYPE_NORMAL
- en: '***11.3.2 Disposable Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, you may need a function that performs a simple, one-line task. For example,
    when you use `apply`, you’ll typically just want to pass in a short, simple function
    as an argument. That’s where *disposable* (or *anonymous*) functions come in—they
    allow you to define a function intended for use in a single instance without explicitly
    creating a new object in your global environment.
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a numeric matrix whose columns you want to repeat twice and then
    sort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfect task for `apply`, which can apply a function to each column
    of the matrix. This function simply has to take in a vector, repeat it, and sort
    the result. Rather than define that short function separately, you can define
    a disposable function right in the argument of `apply` using the `function` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The function is defined in the standard format directly in the call to `apply`.
    This function is defined, called, and then immediately forgotten once `apply`
    is complete. It is disposable in the sense that it exists only for the one instance
    where it is actually used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `function` command this way is a shortcut more than anything else;
    plus, it avoids the unnecessary creation and storage of a function object in the
    global environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.3.3 Recursive Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Recursion* is when a function calls itself. This technique isn’t commonly
    used in statistical analyses, but it pays to be aware of it. This section will
    briefly illustrate what it means for a function to call itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to write a function that takes a single positive integer argument
    `n` and returns the corresponding *n*th term of the Fibonacci sequence (where
    *n* = 1 and *n* = 2 correspond to the initial two terms 1 and 1, respectively).
    Earlier you built up the Fibonacci sequence in an *iterative* fashion by using
    a loop. In a recursive function, instead of using a loop to repeat an operation,
    the function calls itself multiple times. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursive `myfibrec` checks a single `if` statement that defines a *stopping
    condition*. If either `1` or `2` is supplied to the function (requesting the first
    or second Fibonacci number), then `myfibrec` directly returns `1`. Otherwise,
    the function returns the sum of `myfibrec(n-1)` and `myfibrec(n-2)`. That means
    if you call `myfibrec` with `n` greater than `2`, the function generates two more
    calls to `myfibrec`, using `n-1` and `n-2`. The recursion continues until it reaches
    a call for the 1st or 2nd term, triggering the stopping condition, `if(n==1||n==2)`,
    which simply returns `1`. Here’s a sample call that retrieves the fifth Fibonacci
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-3](ch11.xhtml#ch11fig3) shows the structure of this recursive call.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that an accessible stopping rule is critical to any recursive function.
    Without one, recursion will continue indefinitely. For example, the current definition
    of `myfibrec` works as long as the user supplies a positive integer for the argument
    `n`. But if `n` is negative, the stopping rule condition will never be satisfied,
    and the function will recur indefinitely (though R has some automated safeguards
    to help prevent this and should just return an error message rather than getting
    stuck in an infinite loop).
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is a powerful approach, especially when you don’t know ahead of time
    how many times a function needs be called to complete a task. For many sort and
    search algorithms, recursion provides the speediest and most efficient solution.
    But in simpler cases, such as the Fibonacci example here, the recursive approach
    often requires more computational expense than an iterative looping approach.
    For beginners, I recommended sticking with explicit loops unless recursion is
    strictly required.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: A visualization of the recursive calls made to* `myfibrec` *with*
    `n=5`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a list whose members are character string vectors of varying lengths,
    use a disposable function with `lapply` to paste an exclamation mark onto the
    end of each element of each member, with an empty string as the separation character
    (note that the default behavior of `paste` when applied to character vectors is
    to perform the concatenation on each element). Execute your line of code on the
    list given by the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a recursive version of a function implementing the non-negative integer
    factorial operator (see [Exercise 10.4](ch10.xhtml#ch10exc4) on [page 203](ch10.xhtml#page_203)
    for details of the factorial operator). The stopping rule should return the value
    `1` if the supplied integer is `0`. Confirm that your function produces the same
    results as earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5 factorial is 120.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 120 factorial is 479,001,600.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 0 factorial is 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this problem, I’ll introduce the *geometric mean*. The geometric mean is
    a particular measure of centrality, different from the more common arithmetic
    mean. Given *n* observations denoted *x*[1], *x*[2], ..., *x*[n], their geometric
    mean ![image](../images/g.jpg) is computed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0238-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'For example, to find the geometric mean of the data 4.3, 2.1, 2.2, 3.1, calculate
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0239-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: (This is rounded to 1 d.p.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a function named `geolist` that can search through a specified list and
    compute the geometric means of each member per the following guidelines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Your function must define and use an internal helper function that returns
    the geometric mean of a vector argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Assume the list can only have numeric vectors or numeric matrices as its members.
    Your function should contain an appropriate loop to inspect each member in turn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If the member is a vector, compute the geometric mean of that vector, overwriting
    the member with the result, which should be a single number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If the member is a matrix, use an implicit loop to compute the geometric mean
    *of each row* of the matrix, overwriting the member with the results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The final list should be returned to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, as a quick test, check that your function matches the following two calls:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `function` | Function creation | [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    [p. 216](ch11.xhtml#page_216) |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | Function return objects | [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    [p. 219](ch11.xhtml#page_219) |'
  prefs: []
  type: TYPE_TB
- en: '| `missing` | Argument check | [Section 11.2.3](ch11.xhtml#ch11lev2sec101),
    [p. 227](ch11.xhtml#page_227) |'
  prefs: []
  type: TYPE_TB
- en: '| `...` | Ellipsis (as argument) | [Section 11.2.4](ch11.xhtml#ch11lev2sec102),
    [p. 228](ch11.xhtml#page_228) |'
  prefs: []
  type: TYPE_TB
