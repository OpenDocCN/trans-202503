- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**WRITING FUNCTIONS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写函数**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: Defining a function allows you to reuse a chunk of code without endlessly copying
    and pasting. It also allows other users to use your functions to carry out the
    same computations on their own data or objects. In this chapter, you’ll learn
    about writing your own R functions. You’ll learn how to define and use arguments,
    how to return output from a function, and how to specialize your functions in
    other ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数可以让你重复使用一段代码，而无需反复复制粘贴。它还允许其他用户使用你的函数对他们自己的数据或对象执行相同的计算。在本章中，你将学习如何编写自己的R函数。你将了解如何定义和使用参数，如何从函数中返回输出，以及如何以其他方式对函数进行专业化。
- en: '**11.1 The function Command**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.1 函数命令**'
- en: To define a function, use the `function` command and assign the results to an
    object name. Once you’ve done this, you can call the function using that object
    name just like any other built-in or contributed function in the workspace. This
    section will walk you through the basics of function creation and discuss some
    associated issues, such as returning objects and specifying arguments.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个函数，使用`function`命令并将结果赋给一个对象名称。完成此操作后，你可以像使用其他内置或贡献函数一样，通过该对象名称调用该函数。本节将引导你了解函数创建的基础知识，并讨论一些相关问题，例如返回对象和指定参数。
- en: '***11.1.1 Function Creation***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.1.1 函数创建***'
- en: 'A function definition always follows this standard format:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义始终遵循以下标准格式：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `functionname` placeholder can be any valid R object name, which is what
    you’ll ultimately use to call the function. Assign to this `functionname` a call
    to `function`, followed by parentheses with any arguments you want the function
    to have. The pseudocode includes three argument placeholders plus an ellipsis.
    Of course, the number of arguments, their tags, and whether to include an ellipsis
    all depend on the particular function you’re defining. If the function does not
    require any arguments, simply include empty parentheses: `()`. If you do include
    arguments in this definition, note that they are not objects in the workspace
    and they do not have any type or `class` attributes associated with them—they
    are merely a declaration of argument names that will be required by `functionname`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionname`占位符可以是任何有效的R对象名称，最终你将使用它来调用该函数。将`functionname`赋值为`function`的调用，后跟括号，括号内是你希望函数拥有的任何参数。伪代码包括三个参数占位符和一个省略号。当然，参数的数量、标签以及是否包括省略号都取决于你定义的具体函数。如果函数不需要任何参数，只需包含空括号：`()`。如果你确实在这个定义中包含参数，请注意，它们不是工作区中的对象，也没有任何类型或`class`属性—它们仅仅是一个参数名称的声明，这些参数是`functionname`所需要的。'
- en: When the function is called, it runs the code in the braced area (also called
    the *function body* or *body code*). It can include `if` statements, loops, and
    even other function calls. When encountering an internal function call during
    execution, R follows the search rules discussed in [Chapter 9](ch09.xhtml#ch09).
    In the braced area, you can use `arg1`, `arg2`, and `arg3`, and they are treated
    as objects in the function’s lexical environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它会执行大括号区域中的代码（也称为*函数体*或*函数代码*）。它可以包括`if`语句、循环，甚至其他函数调用。在执行过程中遇到内部函数调用时，R会遵循[第9章](ch09.xhtml#ch09)中讨论的搜索规则。在大括号区域中，你可以使用`arg1`、`arg2`和`arg3`，它们会被当作函数词法环境中的对象来处理。
- en: Depending on how those declared arguments are used in the body code, each argument
    may require a certain data type and object structure. If you’re writing functions
    that you intend for others to use, it’s important to have sound documentation
    to say what the function expects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些声明的参数在函数体中的使用方式，每个参数可能需要特定的数据类型和对象结构。如果你编写的是打算供他人使用的函数，确保有完善的文档说明函数的预期要求是非常重要的。
- en: Often, the function body will include one or more calls to the `return` command.
    When R encounters a `return` statement during execution, the function exits, returning
    control to the user at the command prompt. This mechanism is what allows you to
    pass results from operations in the function back to the user. This output is
    denoted in the pseudocode by `returnobject`, which is typically assigned an object
    created or calculated earlier in the function body. If there is no `return` statement,
    the function will simply return the object created by the last executed expression
    (I’ll discuss this feature more in [Section 11.1.2](ch11.xhtml#ch11lev2sec98)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数主体会包含一个或多个`return`命令的调用。当R在执行过程中遇到`return`语句时，函数将退出，将控制权交还给用户的命令提示符。这个机制允许你将函数内部操作的结果返回给用户。这个输出在伪代码中由`returnobject`表示，通常是一个在函数主体中较早创建或计算的对象。如果没有`return`语句，函数将简单地返回最后执行表达式所创建的对象（我将在[第11.1.2节](ch11.xhtml#ch11lev2sec98)中详细讨论这个特性）。
- en: It’s time for an example. Let’s take the Fibonacci sequence generator from [Section
    10.3.2](ch10.xhtml#ch10lev2sec96) and turn it into a function in the editor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候来看一个例子了。我们从[第10.3.2节](ch10.xhtml#ch10lev2sec96)中提取斐波那契数列生成器，并将其转化为编辑器中的一个函数。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I’ve named the function `myfib`, and it doesn’t use or require any arguments.
    The body code is identical to the example in [Section 10.3.2](ch10.xhtml#ch10lev2sec96),
    except I’ve added the third line, `cat(fib.a,", ",fib.b,", ",sep="")`, to ensure
    the first two terms, 1 and 1, are also printed to the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将函数命名为`myfib`，并且它不使用或要求任何参数。代码主体与[第10.3.2节](ch10.xhtml#ch10lev2sec96)中的示例完全相同，唯一不同的是我添加了第三行代码`cat(fib.a,",
    ",fib.b,", ",sep="")`，确保前两个数值1和1也会被打印到屏幕上。
- en: Before you can call `myfib` from the console, you have to send the function
    definition there. Highlight the code in the editor and press CTRL-R or ![image](../images/common-02.jpg)-RETURN.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够从控制台调用`myfib`之前，你需要将函数定义传送到控制台。选中编辑器中的代码并按CTRL-R或![image](../images/common-02.jpg)-RETURN。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This imports the function into the workspace (if you enter `ls()` at the command
    prompt, `"myfib"` will now appear in the list of present objects). This step is
    required anytime you create or modify a function and want to use it from the command
    prompt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将函数导入工作空间（如果你在命令提示符下输入`ls()`，`"myfib"`现在会出现在当前对象列表中）。每次你创建或修改一个函数，并且想要在命令提示符下使用它时，都需要执行这一步骤。
- en: Now you can call the function from the console.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从控制台调用这个函数了。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It computes and prints the Fibonacci sequence up to 250, just as instructed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算并打印出最大为250的斐波那契数列，正如要求的那样。
- en: '**Adding Arguments**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加参数**'
- en: 'Rather than printing a fixed set of terms, let’s add an argument to control
    how many Fibonacci numbers are printed. Consider the following new function, `myfib2`,
    with this modification:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其打印一个固定的数列，让我们添加一个参数来控制打印多少个斐波那契数。考虑下面这个新的函数`myfib2`，它进行了这种修改：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This version now takes a single argument, `thresh`. In the body code, `thresh`
    acts as a threshold determining when to end the `repeat` procedure, halt printing,
    and complete the function—once a value of `fib.b` that is greater than `thresh`
    is calculated, the `repeat` statement will exit after encountering the call to
    `break`. Therefore, the output printed to the console will be the Fibonacci sequence
    up to and including the first `fib.b` value bigger than `thresh`. This means that
    `thresh` must be supplied as a single numeric value—supplying a character string,
    for example, would make no sense.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本现在接受一个单一的参数`thresh`。在代码主体中，`thresh`充当一个阈值，用于决定何时结束`repeat`过程、停止打印并完成函数——一旦计算出的`fib.b`值大于`thresh`，`repeat`语句将在遇到`break`调用时退出。因此，打印到控制台的输出将是包含第一个大于`thresh`的`fib.b`值的斐波那契数列。这意味着`thresh`必须作为单一的数值提供——例如，提供一个字符字符串是没有意义的。
- en: After importing the definition of `myfib2` into the console, note the same results
    as given by the original `myfib` when you set `thresh=150`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将`myfib2`的定义导入控制台后，请注意，当你设置`thresh=150`时，得到的结果与原始`myfib`相同。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But now you can print the sequence to any limit you want (this time using positional
    matching to specify the argument):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，你可以将数列打印到任何你想要的限制（这次使用位置匹配来指定参数）：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Returning Results**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**返回结果**'
- en: 'If you want to use the results of a function in future operations (rather than
    just printing output to the console), you need to return content to the user.
    Continuing with the current example, here’s a Fibonacci function that stores the
    sequence in a vector and returns it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在未来的操作中使用函数的结果（而不是仅仅将输出打印到控制台），你需要将内容返回给用户。继续使用当前的例子，这是一个将序列存储在向量中并返回的斐波那契函数：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First you create the vector `fibseq` and assign it the first two terms of the
    sequence. This vector will ultimately become the `returnobject`. You also create
    a `counter` initialized to `2` to keep track of the current position in `fibseq`.
    Then the function enters a `repeat` statement, which overwrites `fibseq` with
    `c(fibseq,fibseq[counter-1]+fibseq[counter])`. That expression constructs a new
    `fibseq` by appending the sum of the most recent two terms to the contents of
    what is already stored in `fibseq`. For example, with `counter` starting at `2`,
    the first run of this line will sum `fibseq[1]` and `fibseq[2]`, appending the
    result as a third entry onto the original `fibseq`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建了向量`fibseq`并将其赋值为序列的前两个项。最终，这个向量将成为`returnobject`。你还创建了一个`counter`，初始化为`2`，用于跟踪当前在`fibseq`中的位置。然后，函数进入一个`repeat`语句，它通过`c(fibseq,fibseq[counter-1]+fibseq[counter])`来覆盖`fibseq`。这个表达式通过将最近两个项的和添加到`fibseq`的当前内容中，构造出一个新的`fibseq`。例如，当`counter`从`2`开始时，第一次运行这一行会将`fibseq[1]`和`fibseq[2]`相加，并将结果作为第三项添加到原来的`fibseq`中。
- en: Next, `counter` is incremented, and the condition is checked. If the most recent
    value of `fibseq[counter]` is not greater than `thresh`, the loop repeats. If
    it is greater, the loop breaks, and you reach the final line of `myfib3`. Calling
    `return` ends the function and passes out the specified `returnobject` (in this
    case, the final contents of `fibseq`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`counter`被递增，并且检查条件。如果`fibseq[counter]`的最新值不大于`thresh`，循环将继续。如果大于，循环会中断，并且你会到达`myfib3`的最后一行。调用`return`结束函数，并返回指定的`returnobject`（在此情况下，是`fibseq`的最终内容）。
- en: 'After importing `myfib3`, consider the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`myfib3`后，考虑以下代码：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the first line calls `myfib3` with `thresh` assigned `150`. The output
    is still printed to the screen, but this isn’t the result of the `cat` command
    as it was earlier; it is the `returnobject`. You can assign this `returnobject`
    to a variable, such as `foo`, and `foo` is now just another R object in the global
    environment that you can manipulate. For example, you use it to create `bar` with
    a simple vector subset. This would not have been possible with either `myfib`
    or `myfib2`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行调用了`myfib3`并将`thresh`赋值为`150`。输出仍然会打印到屏幕上，但这不是之前通过`cat`命令得到的结果，而是`returnobject`。你可以将这个`returnobject`赋值给一个变量，比如`foo`，此时`foo`就成了全局环境中的另一个R对象，可以进行操作。例如，你可以利用它创建一个简单的向量子集`bar`。这是在使用`myfib`或`myfib2`时无法做到的。
- en: '***11.1.2 Using return***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.1.2 使用 return***'
- en: 'If there’s no `return` statement inside a function, the function will end when
    the last line in the body code has been run, at which point it will return the
    most recently assigned or created object in the function. If nothing is created,
    such as in `myfib` and `myfib2` from earlier, the function returns `NULL`. To
    demonstrate this point, enter the following two dummy functions in the editor:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数内部没有`return`语句，函数会在执行完最后一行代码后结束，此时它会返回函数中最后创建或赋值的对象。如果没有创建任何对象，比如之前的`myfib`和`myfib2`，函数会返回`NULL`。为了说明这一点，请在编辑器中输入以下两个示例函数：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first function, `dummy1`, simply assigns four different objects in its lexical
    environment (not the global environment) and doesn’t explicitly return anything.
    On the other hand, `dummy2` creates the same four objects and explicitly returns
    the last one, `dd`. If you import and run the two functions, both provide the
    same return object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`dummy1`简单地在其词法环境中（而不是全局环境中）赋值了四个不同的对象，并没有显式地返回任何内容。另一方面，`dummy2`创建了相同的四个对象，并显式地返回最后一个对象`dd`。如果你导入并运行这两个函数，它们都会返回相同的对象。
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A function will end as soon as it evaluates a `return` command, without executing
    any remaining code in the function body. To emphasize this, consider one more
    version of the dummy function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数会在评估到`return`命令时立即结束，而不会执行函数体中剩余的任何代码。为了强调这一点，考虑一下另一个版本的示例函数：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, `dummy3` has two calls to return: one in the middle and one at the end.
    But when you import and execute the function, it returns only one value.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dummy3`函数有两个`return`调用：一个在中间，另一个在末尾。但是，当你导入并执行该函数时，它只返回一个值。
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Executing `dummy3` returns only the object `aa` because only the first instance
    of `return` is executed and the function exits immediately at that point. In the
    current definition of `dummy3`, the last three lines (the assignment of `cc` and
    `dd` and the `return` of `bb`) will never be executed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dummy3`只会返回对象`aa`，因为只有第一个`return`语句被执行，函数会立即在这一点退出。在当前定义的`dummy3`中，最后三行（`cc`和`dd`的赋值以及`bb`的`return`）永远不会被执行。
- en: Using `return` adds another function call to your code, so technically, it introduces
    a little extra computational expense. Because of this, some argue that `return`
    statements should be avoided unless absolutely necessary. But the additional computational
    cost of the call to `return` is small enough to be negligible for most purposes.
    Plus, `return` statements can make code more readable, making it easier to see
    where the author of a function intends it to complete and precisely what is intended
    to be supplied as output. I’ll use `return` throughout the remainder of this work.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`return`会向你的代码添加另一个函数调用，因此从技术上讲，它会引入一些额外的计算开销。因此，有人认为，除非绝对必要，否则应避免使用`return`语句。但调用`return`的额外计算成本对于大多数用途来说足够小，可以忽略不计。而且，`return`语句可以使代码更具可读性，更容易看到函数作者打算在哪一处结束函数，并明确希望返回什么作为输出。在剩下的内容中，我将始终使用`return`。
- en: '**Exercise 11.1**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 11.1**'
- en: 'Write another Fibonacci sequence function, naming it `myfib4`. This function
    should provide an option to perform either the operations available in `myfib2`,
    where the sequence is simply printed to the console, or the operations in `myfib3`,
    where a vector of the sequence is formally returned. Your function should take
    two arguments: the first, `thresh`, should define the limit of the sequence (just
    as in `myfib2` or `myfib3`); the second, `printme`, should be a logical value.
    If `TRUE`, then `myfib4` should just print; if `FALSE`, then `myfib4` should return
    a vector. Confirm the correct results arise from the following calls:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写另一个斐波那契数列函数，命名为`myfib4`。该函数应提供一个选项，可以执行`myfib2`中的操作（即仅将序列打印到控制台），或者执行`myfib3`中的操作（即正式返回一个序列向量）。你的函数应接受两个参数：第一个，`thresh`，应定义序列的限制（就像`myfib2`或`myfib3`一样）；第二个，`printme`，应为逻辑值。如果为`TRUE`，则`myfib4`应仅打印；如果为`FALSE`，则`myfib4`应返回一个向量。通过以下调用验证结果是否正确：
- en: – `myfib4(thresh=150,printme=TRUE)`
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – `myfib4(thresh=150,printme=TRUE)`
- en: – `myfib4(1000000,T)`
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – `myfib4(1000000,T)`
- en: – `myfib4(150,FALSE)`
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – `myfib4(150,FALSE)`
- en: – `myfib4(1000000,printme=F)`
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – `myfib4(1000000,printme=F)`
- en: In [Exercise 10.4](ch10.xhtml#ch10exc4) on [page 203](ch10.xhtml#page_203),
    you were tasked with writing a `while` loop to perform integer factorial calculations.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[练习 10.4](ch10.xhtml#ch10exc4)中，[第203页](ch10.xhtml#page_203)要求你编写一个`while`循环来执行整数阶乘计算。
- en: Using your factorial `while` loop (or writing one if you didn’t do so earlier),
    write your own R function, `myfac`, to compute the factorial of an integer argument
    `int` (you may assume `int` will always be supplied as a non-negative integer).
    Perform a quick test of the function by computing 5 factorial, which is 120; 12
    factorial, which is 479,001,600; and 0 factorial, which is 1.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的阶乘`while`循环（如果你之前没有写，可以编写一个），写一个R函数`myfac`，用来计算整数参数`int`的阶乘（你可以假设`int`总是作为非负整数传入）。通过计算5的阶乘（即120）、12的阶乘（即479,001,600）和0的阶乘（即1）来快速测试该函数。
- en: Write another version of your factorial function, naming it `myfac2`. This time,
    you may still assume `int` will be supplied as an integer but not that it will
    be non-negative. If negative, the function should return `NaN`. Test `myfac2`
    on the same three values as previously, but also try using `int=-6`.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写另一个版本的阶乘函数，命名为`myfac2`。这次，你仍然可以假设`int`将作为整数传入，但不能假设它一定是非负数。如果是负数，函数应返回`NaN`。在之前的三个测试值上测试`myfac2`，同时尝试使用`int=-6`。
- en: '**11.2 Arguments**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.2 参数**'
- en: Arguments are an essential part of most R functions. In this section, you’ll
    consider how R evaluates arguments. You’ll also see how to write functions that
    have default argument values, how to make functions handle missing argument values,
    and how to pass extra arguments into an internal function call with ellipses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是大多数R函数中不可或缺的一部分。在这一部分，你将考虑R如何求值参数。你还将看到如何编写具有默认参数值的函数，如何使函数处理缺失的参数值，以及如何通过省略号将额外的参数传递到内部函数调用中。
- en: '***11.2.1 Lazy Evaluation***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.2.1 延迟求值***'
- en: An important concept related to handling arguments in many high-level programming
    languages is *lazy evaluation*. Generally, this refers to the fact that expressions
    are evaluated only when they are needed. This applies to arguments in the sense
    that they are accessed and used only at the point they appear in the function
    body.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 处理许多高级编程语言中参数的一个重要概念是*延迟求值*。通常，这指的是只有在需要时才会对表达式进行求值。这也适用于参数，即它们仅在函数体中出现时才会被访问和使用。
- en: 'Let’s see exactly how R functions recognize and use arguments during execution.
    As a working example to be used throughout this section, you’ll write a function
    to search through a specified list for matrix objects and attempt to post-multiply
    each with another matrix specified as a second argument (refer back to [Section
    3.3.5](ch03.xhtml#ch03lev2sec33) for details on matrix multiplication). The function
    will store and return the result in a new list. If no matrices are in the supplied
    list or if no appropriate matrices (given the dimensions of the multiplying matrix)
    are present, the function should return a character string informing the user
    of these facts. You can assume that if there are matrices in the specified list,
    they will be numeric. Consider the following function, which I’ll call `multiples1`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看R函数在执行过程中如何识别和使用参数。作为本节的工作示例，您将编写一个函数，在指定的列表中搜索矩阵对象，并尝试将每个矩阵与作为第二个参数指定的另一个矩阵进行后乘（有关矩阵乘法的详细信息，请参考[第3.3.5节](ch03.xhtml#ch03lev2sec33)）。该函数将存储并返回结果到一个新列表中。如果提供的列表中没有矩阵，或者没有适合的矩阵（根据乘法矩阵的维度），函数应该返回一个字符字符串，告知用户这些情况。您可以假设，如果指定的列表中有矩阵，它们将是数值型的。考虑以下函数，我称之为`multiples1`：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function takes four arguments, with no default values assigned. The target
    list to search is intended to be supplied to `x`; the post-multiplying matrix
    is supplied to `mat`; and two other arguments, `str1` and `str2`, take character
    strings to return if `x` has no suitable members.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受四个参数，没有默认值。要搜索的目标列表应该传递给`x`；进行后乘的矩阵传递给`mat`；另外两个参数`str1`和`str2`接收字符字符串，如果`x`中没有合适的成员时返回这些字符串。
- en: Inside the body code, a vector called `matrix.flags` is created with the `sapply`
    implicit looping function. This applies the function `is.matrix` to the list argument
    `x`. The result is a logical vector of equal length as `x`, with `TRUE` elements
    where the corresponding member of `x` is in fact a matrix. If there are no matrices
    in `x`, the function hits a `return` statement, which exits the function and outputs
    the argument `str1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码主体内部，创建了一个名为`matrix.flags`的向量，使用`sapply`隐式循环函数。该函数将`is.matrix`应用于列表参数`x`。结果是一个与`x`等长的逻辑向量，`TRUE`元素表示`x`中对应的成员确实是矩阵。如果`x`中没有矩阵，函数会触发`return`语句，退出函数并输出参数`str1`。
- en: If the function did not exit at that point, this means there are indeed matrices
    in `x`. The next step is to retrieve the matrix member indexes by applying `which`
    to `matrix.flags`. A `counter` is initialized to `0` to keep track of how many
    successful matrix multiplications are carried out, and an empty list (`result`)
    is created to store any results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数在那个点没有退出，意味着`x`中确实包含矩阵。接下来的步骤是通过将`which`应用于`matrix.flags`来检索矩阵成员的索引。初始化一个`counter`为`0`，用于跟踪成功执行了多少次矩阵乘法，并创建一个空列表（`result`）用于存储结果。
- en: Next, you enter a `for` loop. For each member of `indexes`, the loop stores
    the matrix member at that position as `temp` and checks to see whether it’s possible
    to perform post-multiplication of `temp` by the argument `mat` (to perform the
    operation, `ncol(temp)` must equal `nrow(mat)`). If the matrices are compatible,
    `counter` is incremented, and this position of `result` is filled with the relevant
    calculation. If `FALSE`, nothing is done. The indexer, `i`, then takes on the
    next value of `indexes` and repeats until completion.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入`for`循环。对于`indexes`中的每个成员，循环会将该位置的矩阵成员存储为`temp`，并检查是否可以将`temp`与参数`mat`进行后乘（为了执行操作，`ncol(temp)`必须等于`nrow(mat)`）。如果矩阵兼容，`counter`增加，并且在`result`的对应位置填充相关计算结果。如果为`FALSE`，则不执行任何操作。索引器`i`然后取`indexes`中的下一个值，并继续重复直到完成。
- en: The final procedure in `multiples1` checks whether the `for` loop actually found
    any compatible matrix products. If no compatibility existed, the braced `if` statement
    code inside the `for` loop would never have been executed, and the `counter` would
    remain set to zero. So, if `counter` is still equal to zero upon completion of
    the loop, the function simply returns the `str2` argument. Otherwise, if compatible
    matrices were found, appropriate results will have been computed, and `multiples1`
    returns the `result` list, which would have at least one member.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiples1`中的最终程序检查`for`循环是否找到了任何兼容的矩阵乘积。如果没有兼容的矩阵，`for`循环内的花括号`if`语句代码将不会执行，且`counter`将保持为零。因此，如果`counter`在循环结束时仍然等于零，函数将简单地返回`str2`参数。否则，如果找到了兼容的矩阵，适当的结果将被计算，并且`multiples1`将返回`result`列表，列表中至少有一个成员。'
- en: 'It’s time to import and then test the function. You’ll use the following three
    list objects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候导入并测试这个函数了。你将使用以下三个列表对象：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll set the argument `mat` to the 2 × 2 identity matrix (post-multiplying
    any appropriate matrix by this will simply return the original matrix), and you’ll
    pass in appropriate string messages for `str1` and `str2`. Here’s how the function
    works on `foo`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把参数`mat`设置为2 × 2的单位矩阵（将任何合适的矩阵与它后乘将只是返回原始矩阵），并为`str1`和`str2`传入适当的字符串消息。以下是该函数在`foo`上的执行方式：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function has returned `result` with the two compatible matrices of `foo`
    (members `[[1]]` and `[[5]]`). Now let’s try it on `bar` using the same arguments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数已经返回了`result`，包含`foo`的两个兼容矩阵（成员`[[1]]`和`[[5]]`）。现在，让我们使用相同的参数尝试它在`bar`上的表现。
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the value of `str1` has been returned. The initial check identified
    that there are no matrices in the list supplied to `x`, so the function has exited
    before the `for` loop. Finally, let’s try `baz`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，返回了`str1`的值。初步检查确认在提供给`x`的列表中没有矩阵，因此函数在`for`循环之前已经退出。最后，让我们尝试`baz`。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here the value of `str2` was returned. Though there is a matrix in `baz` and
    the `for` loop in the body code of `multiples1` has been executed, the matrix
    is not compatible for post-multiplication by `mat`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里返回了`str2`的值。尽管`baz`中有一个矩阵，且`multiples1`的`for`循环体内的代码已经执行，但该矩阵不适合用`mat`进行后乘。
- en: Notice that the string arguments `str1` and `str2` are used only when the argument
    `x` does not contain a matrix with the appropriate dimensions. When you applied
    `multiples1` to `x=foo`, for example, there was no need to use `str1` or `str2`.
    R evaluates the defined expressions lazily, dictating that argument values are
    sought only at the moment they are required during execution. In this function,
    `str1` and `str2` are required only when the input list doesn’t have suitable
    matrices, so you could lazily ignore providing values for these arguments when
    `x=foo`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串参数`str1`和`str2`仅在参数`x`不包含具有适当维度的矩阵时使用。例如，当你将`multiples1`应用于`x=foo`时，根本不需要使用`str1`或`str2`。R会懒惰地评估已定义的表达式，这意味着只有在执行过程中实际需要这些参数时，才会查找其值。在此函数中，`str1`和`str2`仅在输入列表中没有合适的矩阵时才需要，因此，当`x=foo`时，你可以懒惰地忽略为这些参数提供值。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This returns the same results as before with no problem whatsoever. Attempting
    this with `bar`, on the other hand, doesn’t work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的结果相同，完全没有问题。然而，尝试用`bar`来进行此操作则无法成功。
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we are quite rightly chastised by R because it requires the value for `str1`.
    It informs us that the value is missing and there is no default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，R正确地提醒我们需要`str1`的值。它告诉我们该值缺失且没有默认值。
- en: '***11.2.2 Setting Defaults***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.2.2 设置默认值***'
- en: The previous example shows one case where it’s useful to set default values
    for certain arguments. Default argument values are also sensible in many other
    situations, such as when the function has a large number of arguments or when
    arguments have natural values that are used more often than not. Let’s write a
    new version of the `multiples1` function from [Section 11.2.1](ch11.xhtml#ch11lev2sec99),
    `multiples2`, which now includes default values for `str1` and `str2`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个例子展示了在某些情况下设置默认值对于特定参数是有用的。在许多其他情况下，设置默认参数值也是合理的，例如当函数有大量参数时，或者当参数有自然的值并且这些值使用得更频繁时。让我们编写`multiples1`函数的一个新版本，`multiples2`，它现在包含`str1`和`str2`的默认值，参见[第11.2.1节](ch11.xhtml#ch11lev2sec99)。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you have given `str1` a default value of `"no valid matrices"` by assigning
    the string value in the formal definition of the arguments. You’ve also set a
    default for `str2` by assigning `str1` to it. If you import and execute this function
    again on the three lists, you no longer need to explicitly provide values for
    those arguments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你为`str1`提供了一个默认值`"no valid matrices"`，通过在参数的正式定义中为其赋值字符串。你还通过将`str1`赋值给它来为`str2`设置了默认值。如果你再次导入并执行此函数，针对三个列表，你不再需要显式地为这些参数提供值。
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can now call the function, whatever the outcome, without being required
    to specify every argument in full. If you don’t want to use the default arguments
    in a specific call, you can still specify different values for those arguments
    when calling the function, and those values will overwrite the defaults.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论结果如何，你都可以调用该函数，而无需完全指定每个参数。如果你在某次调用中不想使用默认参数，你仍然可以为这些参数指定不同的值，而这些值将覆盖默认值。
- en: '***11.2.3 Checking for Missing Arguments***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.2.3 检查缺失的参数***'
- en: The `missing` function checks the arguments of a function to see if all required
    arguments have been supplied. It takes an argument tag and returns a single logical
    value of `TRUE` if the specified argument isn’t found. You can use `missing` to
    avoid the error you saw in an earlier call to `multiples1`, when `str1` was required
    but not supplied.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`missing`函数检查函数的参数，看看是否所有必需的参数都已提供。它接受一个参数标签，并返回一个逻辑值`TRUE`，如果指定的参数没有找到。你可以使用`missing`来避免在之前调用`multiples1`时看到的错误，当时`str1`是必需的但没有提供。'
- en: 'In some situations, the `missing` function can be particularly useful in the
    body code. Consider another modification to the example function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`missing`函数在代码主体中尤其有用。考虑对示例函数的另一个修改：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only differences between this version and `multiples1` are in the first
    and last `if` statements. The first `if` statement checks whether there are no
    matrices in `x`, in which case it returns a string message. In `multiples1`, that
    message was always `str1`, but now you use another `if` statement with `missing(str1)`
    to see whether the `str1` argument actually has a value first. If not, the function
    returns another character string saying that `str1` was `missing`. A similar alternative
    is defined for `str2`. Here it is once more importing the function and using `foo`,
    `bar`, and `baz`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本和`multiples1`之间的唯一区别在于第一个和最后一个`if`语句。第一个`if`语句检查`x`中是否没有矩阵，在这种情况下返回一条字符串消息。在`multiples1`中，该消息始终是`str1`，但现在你使用另一个`if`语句和`missing(str1)`来检查`str1`参数是否有值。如果没有，函数将返回另一条字符字符串，说明`str1`是“缺失的”。对`str2`也定义了类似的替代方案。这里再次导入该函数并使用`foo`、`bar`和`baz`：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using `missing` this way permits arguments to be left unsupplied in a given
    function call. It is primarily used when it’s difficult to choose a default value
    for a certain argument, yet the function still needs to handle cases when that
    argument isn’t provided. In the current example, it makes more sense to define
    defaults for `str1` and `str2`, as you did for `multiples2`, and avoid the extra
    code required to implement `missing`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用`missing`可以允许在给定的函数调用中不提供某些参数。它主要用于当某个参数很难选择默认值时，但函数仍然需要处理没有提供该参数的情况。在当前示例中，为`str1`和`str2`定义默认值更加合理，正如你为`multiples2`所做的那样，而避免了实现`missing`所需的额外代码。
- en: '***11.2.4 Dealing with Ellipses***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.2.4 处理省略号***'
- en: In [Section 9.2.5](ch09.xhtml#ch09lev2sec86), I introduced the ellipsis, also
    called dot-dot-dot notation. The ellipsis allows you to pass in extra arguments
    without having to first define them in the argument list, and these arguments
    can then be passed to another function call within the code body. When included
    in a function definition, the ellipsis is often (but not always) placed in the
    last position because it represents a variable number of arguments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9.2.5节](ch09.xhtml#ch09lev2sec86)中，我介绍了省略号，也称为点点点符号。省略号允许你传入额外的参数，而不必先在参数列表中定义它们，然后这些参数可以传递给代码主体中的另一个函数调用。当省略号包含在函数定义中时，它通常（但不总是）放在最后一个位置，因为它表示参数的可变数量。
- en: Building on the `myfib3` function from [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    let’s use the ellipsis to write a function that can plot the specified Fibonacci
    numbers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第11.1.1节](ch11.xhtml#ch11lev2sec97)中的`myfib3`函数，让我们使用省略号编写一个可以绘制指定斐波那契数列的函数。
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this function, an `if` statement checks to see whether the `plotit` argument
    is `TRUE` (which is the default value). If so, then you call `plot`, passing in
    `1:length(fibseq)` for the *x*-axis coordinates and the Fibonacci numbers themselves
    for the *y*-axis. After these coordinates, you also pass the ellipsis directly
    into `plot`. In this case, the ellipsis represents any additional arguments a
    user might pass in to control the execution of `plot`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，一个`if`语句检查`plotit`参数是否为`TRUE`（这是默认值）。如果是这样，那么你调用`plot`，传入`1:length(fibseq)`作为*
    x *轴的坐标，斐波那契数列本身作为* y *轴的坐标。在这些坐标之后，你还将省略号直接传递给`plot`。在这种情况下，省略号表示用户可能传递给`plot`的任何其他参数，用以控制图形的执行。
- en: Importing `myfibplot` and executing the following line, the plot in [Figure
    11-1](ch11.xhtml#ch11fig1) pops up in a graphics device.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`myfibplot`并执行以下代码后，图形设备中将弹出图形[图11-1](ch11.xhtml#ch11fig1)。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here you used positional matching to assign `150` to `thresh`, leaving the default
    value for the `plotit` argument. The ellipsis is empty in this call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用位置匹配将`150`分配给`thresh`，并为`plotit`参数保留默认值。此调用中的省略号为空。
- en: '![image](../images/f11-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-01.jpg)'
- en: '*Figure 11-1: The default plot produced by a call to* `myfibplot`*, with* `thresh=150`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：通过调用* `myfibplot` *产生的默认图形，参数为* `thresh=150`'
- en: 'Since you didn’t specify otherwise, R has simply followed the default behavior
    of `plot`. You can spruce things up by specifying more plotting options. The following
    line produces the plot in [Figure 11-2](ch11.xhtml#ch11fig2):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你没有另行指定，R会按照`plot`的默认行为运行。你可以通过指定更多的绘图选项来美化图形。以下代码将生成[图11-2](ch11.xhtml#ch11fig2)中的图形：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![image](../images/f11-02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-02.jpg)'
- en: '*Figure 11-2: A plot produced by a call to* `myfibplot` *with graphical parameters
    passed in using the ellipsis*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：通过调用* `myfibplot` *并使用省略号传递图形参数生成的图形*'
- en: Here the ellipsis allows you to pass arguments to `plot` through the call to
    `myfibplot`, even though the particular graphical parameters are not explicitly
    defined arguments of `myfibplot`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，省略号允许你通过调用`myfibplot`将参数传递给`plot`，即使特定的图形参数并未显式定义为`myfibplot`的参数。
- en: Ellipses can be convenient, but they require care. The ambiguous `...` can represent
    any number of mysterious arguments. Good function documentation is key to indicate
    the appropriate usage.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号可以很方便，但需要小心使用。模糊的`...`可以代表任何数量的神秘参数。良好的函数文档是指示适当用法的关键。
- en: 'If you want to unpack the arguments passed in through an ellipsis, you can
    use the `list` function to convert those arguments into a list. Here’s an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想解包通过省略号传递的参数，可以使用`list`函数将这些参数转换为列表。以下是一个示例：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This dummy function simply takes an ellipsis and converts it to a list with
    `x <- list(...)`. This subsequently allows the object `x` to be treated the same
    way as any other list. In this case, you can summarize the object by providing
    its `names` and `class` attributes. Here’s a sample run:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚拟函数简单地接受一个省略号，并通过`x <- list(...)`将其转换为一个列表。这样，`x`对象就可以像其他列表一样进行处理。在这种情况下，你可以通过提供其`names`和`class`属性来总结该对象。以下是一个示例运行：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Four tagged arguments, `aa`, `bb`, `cc`, and `dd`, are provided as the contents
    of the ellipsis, and they are explicitly identified within `unpackme` by using
    the simple `list(...)` operation. This construction can be useful for identifying
    or extracting specific arguments supplied through `...` in a given call.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 四个带标签的参数，`aa`、`bb`、`cc`和`dd`，作为省略号的内容提供，并通过简单的`list(...)`操作在`unpackme`中显式识别。此结构可用于识别或提取通过`...`在给定调用中传递的特定参数。
- en: '**Exercise 11.2**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 11.2**'
- en: 'Accruing annual compound interest is a common financial benefit for investors.
    Given a principal investment amount *P*, an interest rate per annum *i* (expressed
    as a percentage), and a frequency of interest paid per year *t*, the final amount
    *F* after *y* years is given as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 累积年复利是投资者常见的财务收益。给定一个本金投资额*P*，年利率*i*（以百分比表示），以及每年支付利息的频率*t*，经过*y*年后的最终金额*F*可以通过以下公式计算：
- en: '![image](../images/f0231-01.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0231-01.jpg)'
- en: 'Write a function that can compute *F* as per the following notes:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个函数，按照以下说明计算*F*：
- en: – Arguments must be present for *P*, *i*, *t*, and *y*. The argument for *t*
    should have a default value of 12.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 必须为*P*、*i*、*t*和*y*提供参数。*t*的默认值应为12。
- en: – Another argument giving a logical value that determines whether to `plot`
    the amount *F* at each integer time should be included. For example, if `plotit=TRUE`
    (the default) and *y* is 5 years, the plot should show the amount *F* at *y* =
    1,2,3,4,5.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 另一个参数给出一个逻辑值，用于确定是否应包括在每个整数时间点 `plot` 显示金额 *F*。例如，如果 `plotit=TRUE`（默认值）且 *y*
    为5年，则图表应显示 *F* 在 *y* = 1,2,3,4,5 时的金额。
- en: – If this function is plotted, the plot should always be a step-plot, so `plot`
    should always be called with `type="s"`.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果绘制此函数，图表应始终为步骤图，因此 `plot` 应始终使用 `type="s"`。
- en: – If `plotit=FALSE`, the final amount *F* should be returned as a numeric vector
    corresponding to the same integer times, as shown earlier.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果 `plotit=FALSE`，则应返回最终金额 *F*，作为与前面显示的相同整数时间对应的数值向量。
- en: – An ellipsis should also be included to control other details of plotting,
    if it takes place.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果进行绘图，还应包括省略号以控制其他细节。
- en: 'Now, using your function, do the following:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用你的函数，执行以下操作：
- en: Work out the final amount after a 10-year investment of a principal of $5000,
    at an interest rate of 4.4 percent per annum compounded monthly.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个$5000的本金，在年利率4.4%、按月复利的条件下，10年后的最终金额。
- en: 'Re-create the following step-plot, which shows the result of $100 invested
    at 22.9 percent per annum, compounded monthly, for 20 years:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新绘制以下步骤图，显示在每年22.9%的利率下，按月复利投资$100，持续20年的结果：
- en: '![image](../images/f0232-01.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0232-01.jpg)'
- en: Perform another calculation based on the same parameters as in (ii), but this
    time, assume the interest is compounded annually. Return and store the results
    as a numeric vector. Then, use `lines` to add a second step-line, corresponding
    to this annually accrued amount, to the plot created previously. Use a different
    color or line type and make use of the `legend` function so the two lines can
    be differentiated.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于（ii）中的相同参数，进行另一项计算，但这次假设利息按年复利。返回并存储结果作为数值向量。然后，使用 `lines` 将一个第二条步骤线（对应于按年复利计算的金额）添加到之前创建的图表中。使用不同的颜色或线型，并利用
    `legend` 函数区分两条线。
- en: 'A *quadratic equation* in the variable *x* is often expressed in the following
    form:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x* 的*二次方程*通常以以下形式表示：'
- en: '*k*[1]*x*² + *k*[2]*x* + *k[3]* = 0'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*k*[1]*x*² + *k*[2]*x* + *k[3]* = 0'
- en: 'Here, *k*[1], *k*[2], and *k[3]* are constants. Given values for these constants,
    you can attempt to find up to two *real roots*—values of *x* that satisfy the
    equation. Write a function that takes *k*[1], *k*[2], and *k[3]* as arguments
    and finds and returns any solutions (as a numeric vector) in such a situation.
    This is achieved as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，*k*[1]、*k*[2] 和 *k[3]* 是常数。给定这些常数的值后，你可以尝试找到最多两个*实根*—即满足方程的*x*值。编写一个函数，接受
    *k*[1]、*k*[2] 和 *k[3]* 作为参数，并在这种情况下找到并返回任何解（作为一个数值向量）。实现方法如下：
- en: – Evaluate ![image](../images/f0233-01.jpg). If this is negative, there are
    no solutions, and an appropriate message should be printed to the console.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 评估 ![image](../images/f0233-01.jpg)。如果它为负，则没有解，应在控制台打印适当的消息。
- en: – If ![image](../images/f0233-01.jpg) is zero, then there is one solution, computed
    by −*k*[2]/2*k*[1].
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果 ![image](../images/f0233-01.jpg) 为零，则有一个解，通过 −*k*[2]/2*k*[1] 计算得出。
- en: – If ![image](../images/f0233-01.jpg) is positive, then there are two solutions,
    given by ![image](../images/f0233-02.jpg) and ![image](../images/f0233-03.jpg).
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果 ![image](../images/f0233-01.jpg) 为正，则有两个解，分别由 ![image](../images/f0233-02.jpg)
    和 ![image](../images/f0233-03.jpg) 给出。
- en: – No default values are needed for the three arguments, but the function should
    check to see whether any are missing. If so, an appropriate character string message
    should be returned to the user, informing the user that the calculations are not
    possible.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 不需要为这三个参数提供默认值，但函数应检查是否有任何参数缺失。如果有，则应返回一个适当的字符字符串消息，通知用户无法进行计算。
- en: Now, test your function.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，测试你的函数。
- en: 'Confirm the following:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认以下内容：
- en: '* 2*x*² − *x* − 5 has roots 1.850781 and −1.350781.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 2*x*² − *x* − 5 的根为 1.850781 和 −1.350781。'
- en: '* *x*² + *x* + 1 has no real roots.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* *x*² + *x* + 1 没有实根。'
- en: 'Attempt to find solutions to the following quadratic equations:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试解决以下二次方程的解：
- en: '* 1.3*x*² − 8*x* − 3.13'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 1.3*x*² − 8*x* − 3.13'
- en: '* 2.25*x*² − 3*x* + 1'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 2.25*x*² − 3*x* + 1'
- en: '* 1.4*x*² − 2.2*x* − 5.1'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 1.4*x*² − 2.2*x* − 5.1'
- en: '* −5*x*² + 10.11*x* − 9.9'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* −5*x*² + 10.11*x* − 9.9'
- en: Test your programmed response in the function if one of the arguments is missing.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试当函数的一个参数缺失时，你编写的响应。
- en: '**11.3 Specialized Functions**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**11.3 专门函数**'
- en: In this section, you’ll look at three kinds of specialized user-defined R functions.
    First, you’ll look at helper functions, which are designed to be called multiple
    times by another function (and they can even be defined inside the body of a parent
    function). Next, you’ll look at disposable functions, which can be directly defined
    as an argument to another function call. Finally, you’ll look at recursive functions,
    which call themselves.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解三种特殊的用户自定义R函数。首先，你将了解辅助函数，它们设计为可以被另一个函数多次调用（甚至可以在父函数体内定义）。接下来，你将了解一次性函数，它们可以直接作为另一个函数调用的参数来定义。最后，你将了解递归函数，它们会调用自己。
- en: '***11.3.1 Helper Functions***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.3.1 辅助函数***'
- en: It is common for R functions to call other functions from within their body
    code. A *helper function* is a general term used to describe functions written
    and used specifically to facilitate the computations carried out by another function.
    They’re a good way to improve the readability of complicated functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: R函数在其函数体内调用其他函数是很常见的。*辅助函数*是一个通用术语，用来描述专门编写并用于便捷地执行另一个函数计算的函数。它们是提高复杂函数可读性的好方法。
- en: A helper function can be either defined internally (within another function
    definition) or externally (within the global environment). In this section, you’ll
    see an example of each.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数可以是内部定义的（在另一个函数定义内）或外部定义的（在全局环境中）。在本节中，你将看到每种情况的示例。
- en: '**Externally Defined**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**外部定义**'
- en: 'Building on the `multiples2` function from [Section 11.2.2](ch11.xhtml#ch11lev2sec100),
    here’s a new version that splits the functionality over two separate functions,
    one of which is an externally defined helper function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第11.2.2节](ch11.xhtml#ch11lev2sec100)中的`multiples2`函数，下面是一个新版本，它将功能拆分成两个独立的函数，其中一个是外部定义的辅助函数：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you import and execute this code on the sample lists from earlier, it behaves
    the same way as the previous version. All you’ve done here is moved the matrix-checking
    loop to an external function. The `multiples4` function now calls a helper function
    named `multiples_helper_ext`. Once the code in `multiples4` makes sure that there
    are in fact matrices in the list `x` to be checked, it calls `multiples_helper_ext`
    to execute the required loop. This helper function is defined externally, meaning
    that it exists in the global environment for any other function to call, making
    it easier to reuse.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入并执行这个代码，使用之前的示例列表，它的行为和前一个版本相同。你所做的只是将矩阵检查循环移到了一个外部函数中。`multiples4`函数现在调用一个名为`multiples_helper_ext`的辅助函数。一旦`multiples4`中的代码确认列表`x`中确实有需要检查的矩阵，它就会调用`multiples_helper_ext`来执行所需的循环。这个辅助函数是外部定义的，这意味着它存在于全局环境中，任何其他函数都可以调用它，这使得它更容易重用。
- en: '**Internally Defined**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内部定义**'
- en: If the helper function is intended to be used for only one particular function,
    it makes more sense to define the helper function internally, within the lexical
    environment of the function that calls it. The fifth version of the matrix multiplication
    function does just that, shifting the definition to within the body code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果辅助函数只打算用于一个特定的函数，那么将辅助函数定义在调用它的函数的词法环境内更有意义。矩阵乘法函数的第五个版本正是这样做的，它将定义移到了函数体内。
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now the helper function `multiples_helper_int` is defined within `multiples5`.
    That means it’s visible only within the lexical environment as opposed to residing
    in the global environment like `multiples_helper_ext`. It makes sense to internally
    define a helper function when (a) it’s used only by a single parent function,
    and (b) it’s called multiple times within the parent function. (Of course, `multiples5`
    satisfies only (a), and it’s provided here just for the sake of illustration.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，辅助函数`multiples_helper_int`在`multiples5`内定义。这意味着它仅在词法环境内可见，而不像`multiples_helper_ext`那样存在于全局环境中。当（a）一个辅助函数仅由一个父函数使用，并且（b）它在父函数中被多次调用时，将它定义为内部函数是有意义的。（当然，`multiples5`只满足（a），它在这里仅用于说明。）
- en: '***11.3.2 Disposable Functions***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.3.2 一次性函数***'
- en: Often, you may need a function that performs a simple, one-line task. For example,
    when you use `apply`, you’ll typically just want to pass in a short, simple function
    as an argument. That’s where *disposable* (or *anonymous*) functions come in—they
    allow you to define a function intended for use in a single instance without explicitly
    creating a new object in your global environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能需要一个执行简单、一行任务的函数。例如，当你使用`apply`时，你通常只需要传入一个简短、简单的函数作为参数。这就是*临时*（或*匿名*）函数的用武之地——它们允许你定义一个仅用于单一实例的函数，而无需在全局环境中显式创建一个新对象。
- en: Say you have a numeric matrix whose columns you want to repeat twice and then
    sort.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个数值矩阵，想要将其每列重复两次并进行排序。
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a perfect task for `apply`, which can apply a function to each column
    of the matrix. This function simply has to take in a vector, repeat it, and sort
    the result. Rather than define that short function separately, you can define
    a disposable function right in the argument of `apply` using the `function` command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`apply`的完美任务，`apply`可以将一个函数应用到矩阵的每一列。这个函数只需接受一个向量，重复它，然后对结果进行排序。你无需单独定义这个简短的函数，而是可以在`apply`的参数中使用`function`命令直接定义一个临时函数。
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The function is defined in the standard format directly in the call to `apply`.
    This function is defined, called, and then immediately forgotten once `apply`
    is complete. It is disposable in the sense that it exists only for the one instance
    where it is actually used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数直接在调用`apply`时以标准格式定义。函数被定义、调用，并且在`apply`完成后立即被遗忘。它是临时的，因为它仅存在于实际使用的那个实例中。
- en: Using the `function` command this way is a shortcut more than anything else;
    plus, it avoids the unnecessary creation and storage of a function object in the
    global environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用`function`命令更多的是一种快捷方式；此外，它还避免了在全局环境中不必要地创建和存储一个函数对象。
- en: '***11.3.3 Recursive Functions***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***11.3.3 递归函数***'
- en: '*Recursion* is when a function calls itself. This technique isn’t commonly
    used in statistical analyses, but it pays to be aware of it. This section will
    briefly illustrate what it means for a function to call itself.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是指一个函数调用它自己。这种技术在统计分析中不常用，但了解它仍然很有用。本节将简要说明一个函数如何调用它自己。'
- en: 'Suppose you want to write a function that takes a single positive integer argument
    `n` and returns the corresponding *n*th term of the Fibonacci sequence (where
    *n* = 1 and *n* = 2 correspond to the initial two terms 1 and 1, respectively).
    Earlier you built up the Fibonacci sequence in an *iterative* fashion by using
    a loop. In a recursive function, instead of using a loop to repeat an operation,
    the function calls itself multiple times. Consider the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个函数，接受一个单一的正整数参数`n`并返回相应的*第n项*斐波那契数列（其中*n* = 1和*n* = 2分别对应初始的两个项1和1）。早些时候你通过循环构建了斐波那契数列的*迭代*形式。在递归函数中，函数不使用循环来重复操作，而是多次调用自身。请考虑以下内容：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The recursive `myfibrec` checks a single `if` statement that defines a *stopping
    condition*. If either `1` or `2` is supplied to the function (requesting the first
    or second Fibonacci number), then `myfibrec` directly returns `1`. Otherwise,
    the function returns the sum of `myfibrec(n-1)` and `myfibrec(n-2)`. That means
    if you call `myfibrec` with `n` greater than `2`, the function generates two more
    calls to `myfibrec`, using `n-1` and `n-2`. The recursion continues until it reaches
    a call for the 1st or 2nd term, triggering the stopping condition, `if(n==1||n==2)`,
    which simply returns `1`. Here’s a sample call that retrieves the fifth Fibonacci
    number:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数`myfibrec`检查一个单一的`if`语句，用来定义*停止条件*。如果传递给函数的是`1`或`2`（请求第一个或第二个斐波那契数），那么`myfibrec`会直接返回`1`。否则，函数返回`myfibrec(n-1)`和`myfibrec(n-2)`的和。这意味着，如果你调用`myfibrec`并传入`n`大于`2`，函数将生成两个额外的`myfibrec`调用，分别使用`n-1`和`n-2`。递归会持续直到遇到请求第1项或第2项的调用，触发停止条件`if(n==1||n==2)`，此时函数仅返回`1`。以下是一个示例调用，用于获取第五个斐波那契数：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Figure 11-3](ch11.xhtml#ch11fig3) shows the structure of this recursive call.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-3](ch11.xhtml#ch11fig3)展示了这个递归调用的结构。'
- en: Note that an accessible stopping rule is critical to any recursive function.
    Without one, recursion will continue indefinitely. For example, the current definition
    of `myfibrec` works as long as the user supplies a positive integer for the argument
    `n`. But if `n` is negative, the stopping rule condition will never be satisfied,
    and the function will recur indefinitely (though R has some automated safeguards
    to help prevent this and should just return an error message rather than getting
    stuck in an infinite loop).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何递归函数都需要一个可访问的停止规则。没有停止规则，递归将会无限进行。例如，当前的`myfibrec`函数定义只要用户提供一个正整数作为参数`n`，就能正常工作。但如果`n`是负数，停止规则条件将永远不会满足，函数会无限递归下去（尽管R语言有一些自动化的保护措施来帮助防止这种情况，并应当返回错误消息，而不是陷入无限循环）。
- en: Recursion is a powerful approach, especially when you don’t know ahead of time
    how many times a function needs be called to complete a task. For many sort and
    search algorithms, recursion provides the speediest and most efficient solution.
    But in simpler cases, such as the Fibonacci example here, the recursive approach
    often requires more computational expense than an iterative looping approach.
    For beginners, I recommended sticking with explicit loops unless recursion is
    strictly required.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种强大的方法，特别是当你无法预知函数需要被调用多少次才能完成任务时。对于许多排序和搜索算法，递归提供了最快和最有效的解决方案。但在更简单的情况中，比如这里的斐波那契例子，递归方法往往比迭代循环方法需要更多的计算资源。对于初学者，我建议除非严格要求使用递归，否则最好使用显式的循环。
- en: '![image](../images/f11-03.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-03.jpg)'
- en: '*Figure 11-3: A visualization of the recursive calls made to* `myfibrec` *with*
    `n=5`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：对`myfibrec`函数的递归调用可视化，`n=5`*'
- en: '**Exercise 11.3**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习11.3**'
- en: 'Given a list whose members are character string vectors of varying lengths,
    use a disposable function with `lapply` to paste an exclamation mark onto the
    end of each element of each member, with an empty string as the separation character
    (note that the default behavior of `paste` when applied to character vectors is
    to perform the concatenation on each element). Execute your line of code on the
    list given by the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个包含不同长度字符字符串向量的列表，使用一次性函数与`lapply`将一个感叹号附加到每个元素的末尾，分隔符为空字符串（请注意，`paste`在应用于字符向量时的默认行为是对每个元素进行连接）。在以下列表上执行此代码：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Write a recursive version of a function implementing the non-negative integer
    factorial operator (see [Exercise 10.4](ch10.xhtml#ch10exc4) on [page 203](ch10.xhtml#page_203)
    for details of the factorial operator). The stopping rule should return the value
    `1` if the supplied integer is `0`. Confirm that your function produces the same
    results as earlier.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归版本的函数，实现非负整数阶乘操作符（有关阶乘操作符的详细信息，请参见[练习10.4](ch10.xhtml#ch10exc4)，见[第203页](ch10.xhtml#page_203)）。停止规则应当在提供的整数为`0`时返回`1`。确认你的函数输出与之前的结果相同。
- en: 5 factorial is 120.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5的阶乘是120。
- en: 120 factorial is 479,001,600.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 120的阶乘是479,001,600。
- en: 0 factorial is 1.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0的阶乘是1。
- en: 'For this problem, I’ll introduce the *geometric mean*. The geometric mean is
    a particular measure of centrality, different from the more common arithmetic
    mean. Given *n* observations denoted *x*[1], *x*[2], ..., *x*[n], their geometric
    mean ![image](../images/g.jpg) is computed as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个问题，我将介绍*几何平均数*。几何平均数是一个特定的集中趋势度量，区别于更常见的算术平均数。给定*n*个观察值，分别记作*x*[1]、*x*[2]、...、*x*[n]，它们的几何平均数![image](../images/g.jpg)的计算公式如下：
- en: '![image](../images/f0238-01.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0238-01.jpg)'
- en: 'For example, to find the geometric mean of the data 4.3, 2.1, 2.2, 3.1, calculate
    the following:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要找到数据4.3、2.1、2.2、3.1的几何平均数，可以按以下方式计算：
- en: '![image](../images/f0239-01.jpg)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0239-01.jpg)'
- en: (This is rounded to 1 d.p.)
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （此值已四舍五入至小数点后一位。）
- en: 'Write a function named `geolist` that can search through a specified list and
    compute the geometric means of each member per the following guidelines:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个名为`geolist`的函数，它能够遍历指定的列表，并根据以下指导原则计算每个成员的几何平均数：
- en: – Your function must define and use an internal helper function that returns
    the geometric mean of a vector argument.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 你的函数必须定义并使用一个内部辅助函数，该函数返回向量参数的几何平均数。
- en: – Assume the list can only have numeric vectors or numeric matrices as its members.
    Your function should contain an appropriate loop to inspect each member in turn.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 假设列表的成员只能是数字向量或数字矩阵。你的函数应包含一个适当的循环来依次检查每个成员。
- en: – If the member is a vector, compute the geometric mean of that vector, overwriting
    the member with the result, which should be a single number.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果成员是一个向量，计算该向量的几何平均值，用结果覆盖该成员，结果应该是一个单一的数字。
- en: – If the member is a matrix, use an implicit loop to compute the geometric mean
    *of each row* of the matrix, overwriting the member with the results.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 如果成员是一个矩阵，使用隐式循环计算矩阵*每一行*的几何平均值，并用结果覆盖该成员。
- en: – The final list should be returned to the user.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 最终的列表应返回给用户。
- en: 'Now, as a quick test, check that your function matches the following two calls:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，作为一个快速测试，检查你的函数是否与以下两个调用匹配：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Important Code in This Chapter**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章中的重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简短描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `function` | Function creation | [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    [p. 216](ch11.xhtml#page_216) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `function` | 函数创建 | [第11.1.1节](ch11.xhtml#ch11lev2sec97)，[第216页](ch11.xhtml#page_216)
    |'
- en: '| `return` | Function return objects | [Section 11.1.1](ch11.xhtml#ch11lev2sec97),
    [p. 219](ch11.xhtml#page_219) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 函数返回对象 | [第11.1.1节](ch11.xhtml#ch11lev2sec97)，[第219页](ch11.xhtml#page_219)
    |'
- en: '| `missing` | Argument check | [Section 11.2.3](ch11.xhtml#ch11lev2sec101),
    [p. 227](ch11.xhtml#page_227) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `missing` | 参数检查 | [第11.2.3节](ch11.xhtml#ch11lev2sec101)，[第227页](ch11.xhtml#page_227)
    |'
- en: '| `...` | Ellipsis (as argument) | [Section 11.2.4](ch11.xhtml#ch11lev2sec102),
    [p. 228](ch11.xhtml#page_228) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `...` | 省略号（作为参数） | [第11.2.4节](ch11.xhtml#ch11lev2sec102)，[第228页](ch11.xhtml#page_228)
    |'
