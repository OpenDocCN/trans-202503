<html><head></head><body>
<div class="imagec"><span epub:type="pagebreak" id="page_199"/><img alt="Image" src="../images/common1.jpg"/></div>
<h2 class="h2" id="ch09"><strong>9</strong><br/><strong>ENVIRONMENTAL MADNESS</strong></h2>
<p class="noindent">The Mad Scientist loves to measure things. In this chapter, we’ll follow in the scientist’s footsteps by measuring the temperature. We’ll devise a temperature and light logger that will provide valuable insights into our environmental experiments. Then we’ll create a plant-watering project that uses a small pump to water a houseplant automatically when its soil starts to dry out.</p>
<h3 class="h3" id="ch00lev1sec206"><span epub:type="pagebreak" id="page_200"/><strong>EXPERIMENT 11: MEASURING TEMPERATURE</strong></h3>
<div class="image"><img alt="Image" src="../images/common2.jpg"/></div>
<p class="difficulty"><em>Difficulty: Easy</em></p>
<p class="noindent">Owning no clothes besides lab coats and having skimped on the insulation budget for the Secret Laboratory, the Mad Scientist decided to build a custom heating system. To do this, they needed to know the exact temperature in every room of the lab. Unfortunately, they soon found the measurements taken with their micro:bit were not exact enough.</p>
<p class="indent">The micro:bit has a function named <span class="literal">temperature</span> in both the Blocks and MicroPython code that returns a temperature reading in degrees Celsius. However, the sensor itself is built into the micro:bit’s processor and thus is actually reporting the temperature of the micro:bit’s <em>chip</em>, not the temperature of the micro:bit’s surroundings.</p>
<p class="indent">At normal room temperature of around 20 degrees C (68 degrees F), if the micro:bit hasn’t been running for too long, the sensor gives a fairly accurate reading. However, we can’t be sure whether the temperature reading is correct if the micro:bit’s processor has been busy and started warming up.</p>
<p class="indent">In this experiment, you’ll investigate the difference between the temperature readings of a busy micro:bit and an idle micro:bit.</p>
<h4 class="h4" id="ch00lev1sec207"><strong>What You’ll Need</strong></h4>
<p class="noindent">To do this experiment, you’ll just need two things:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentinb"><strong><span class="blue">USB cable</span></strong></p>
<p class="indent">You may also want a separate thermometer to check your readings against. The only other thing you’ll need is some patience, as you’ll need to leave this program running for half an hour to get good readings.</p>
<h4 class="h4" id="ch00lev1sec208"><span epub:type="pagebreak" id="page_201"/><strong>Construction</strong></h4>
<ol>
<li class="noindent">This project uses Mu’s Plotter feature, which you’ll need Python for, so there’s no Blocks code for this. Find the code at <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em>. The Python file for this experiment is <em>Experiment_11.py</em>. Flash the program onto your micro:bit.. This code will take temperature readings every 20 seconds. It will also initiate micro:bit activity every 10 minutes and then idle for 10 minutes, letting you see the difference in temperature between when the micro:bit is busy and when it’s idle.</li>
<li class="noindent">Open both the REPL and Plotter views of Mu and press <strong>Reset</strong> on the micro:bit to start the reading process. A new temperature reading, and an indication as to whether the micro:bit has been busy or idle, are logged to the Plotter and REPL every 20 seconds. The busy/idle status of the micro:bit flips every 10 minutes. <a href="ch09.xhtml#ch9fig1">Figure 9-1</a> shows the result of logging the data for 40 minutes.</li>
</ol>
<div class="image" id="ch9fig1"><img alt="Image" src="../images/09fig01.jpg"/></div>
<p class="figcap"><em>Figure 9-1: Plotting temperature readings and processor activity</em></p>
<p class="indent">The blue line shows the temperature reported by the <span class="literal">temperature</span> function, and the green line indicates whether the <span epub:type="pagebreak" id="page_202"/>micro:bit is busy or idle. When busy, the micro:bit turns on the display and its radio interface, and it displays the message <span class="literal">Busy</span> over and over.</p>
<p class="indent">As you can see from <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>, when the micro:bit is in busy mode, the reported temperature rises by about 3 degrees C. When it goes back to idle mode, the temperature drops. Note that the temperature in the room, as measured by a separate thermometer, remained at 20.0 degrees C throughout the experiment.</p>
<h4 class="h4" id="ch00lev1sec209"><strong>Code</strong></h4>
<p class="noindent">The MicroPython code for the experiment needs to do two things: flip the busy state (held in the variable <span class="literal">busy</span>) of the micro:bit every 10 minutes and report the temperature every 20 seconds.</p>
<h5 class="h5" id="ch00lev1sec210"><strong>Setting the Variables</strong></h5>
<p class="noindent">Our code uses the variables <span class="literal">last_busy_flip</span> and <span class="literal">last_log_time</span> to record the last time these two things (flip and log) happened:</p>
<div class="programs1">busy <span class="purple">=</span> <span class="green">False</span><br/>last_busy_flip <span class="purple">=</span> <span class="blue1">0</span><br/>busy_period <span class="purple">=</span> <span class="blue1">600000</span><br/>last_log_time <span class="purple">=</span> <span class="blue1">0</span><br/>log_period <span class="purple">=</span> <span class="blue1">20000</span></div>
<p class="indent">The variable <span class="literal">busy_period</span> specifies the time in milliseconds between each flip between the busy and idle state; 600,000 milliseconds is equal to 600 seconds, which is 10 minutes. The variable <span class="literal">log_period</span> holds the time between temperature reports; 20,000 milliseconds is equal to 20 seconds. The code <span class="literal">busy = False</span> means the micro:bit starts off idle.</p>
<h5 class="h5" id="ch00lev1sec211"><strong>Making It Busy</strong></h5>
<p class="noindent">If the micro:bit is in busy mode, both the display and radio are turned on and the message <span class="literal">Busy</span> is displayed. Otherwise, the radio and display are off.</p>
<div class="programs1"><span epub:type="pagebreak" id="page_203"/><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> busy<span class="purple">:</span><br/>     <span class="blue"><span class="ent">➊</span></span> display<span class="purple">.</span>on<span class="purple">()</span><br/>     <span class="blue"><span class="ent">➋</span></span> radio<span class="purple">.</span>on<span class="purple">()</span><br/>        display<span class="purple">.</span>show<span class="purple">(</span><span class="red1">"Busy"</span><span class="purple">)</span><br/>    <span class="green">else</span><span class="purple">:</span><br/>        display<span class="purple">.</span>off<span class="purple">()</span><br/>        radio<span class="purple">.</span>off<span class="purple">()</span><br/>    now <span class="purple">=</span> running_time<span class="purple">()</span><br/>    <span class="green">if</span> now <span class="purple">&gt;</span> last_busy_flip <span class="purple">+</span> busy_period<span class="purple">:</span><br/>        busy <span class="purple">=</span> <span class="green">not</span> busy<br/>        last_busy_flip <span class="purple">=</span> now<br/>    now <span class="purple">=</span> running_time<span class="purple">()</span><br/>    <span class="green">if</span> now <span class="purple">&gt;</span> last_log_time <span class="purple">+</span> log_period<span class="purple">:</span><br/>        <span class="blue1">print</span><span class="purple">((</span>temperature<span class="purple">(),</span> busy <span class="purple">*</span> <span class="blue1">10</span><span class="purple">))</span><br/>        last_log_time <span class="purple">=</span> now</div>
<p class="indent">In a <span class="literal">while</span> loop, we say that if the <span class="literal">busy</span> variable is <span class="literal">True</span>, the micro:bit should turn the display <span class="blue"><span class="ent">➊</span></span> and radio <span class="blue"><span class="ent">➋</span></span> on. Otherwise, they should be switched off.</p>
<p class="indent">Then we have two tests to see whether either a flip of the busy status or a log to the REPL and Plotter are due: the code checks the current runtime against the values in the <span class="literal">busy_period</span> and <span class="literal">log_period</span> variables.</p>
<p class="indent">To easily see when the processor is busy on the same plot as the temperature (<a href="ch09.xhtml#ch9fig1">Figure 9-1</a>), we multiply the <span class="literal">True</span> or <span class="literal">False</span> Boolean value of <span class="literal">busy</span> by 10. Python allows us to do this! Rather than reporting an error, Python interprets <span class="literal">False</span> as 0 and <span class="literal">True</span> as 1. Because Python treats the Boolean values as numbers, it lets us multiply them. Then, instead of being either 0 or 1, the value is plotted as either 0 or 10.</p>
<h4 class="h4" id="ch00lev1sec212"><strong>How It Works: Why Does a Processor Heat Up?</strong></h4>
<p class="noindent">A processor chip, like the one used by micro:bit, contains tens or even hundreds of thousands of <em>transistors</em>. These transistors are electronic switches that are in either an on or off state (represented by 1 and 0 in binary). Transistors use a very small amount of current when they are in a particular state (either on or off), but require a small amount of additional energy to change states. This is why, when doing something processor intensive, your computer fans will rev up—they’re removing the excess heat generated by the large amount of switching.</p>
<p class="indent"><span epub:type="pagebreak" id="page_204"/>A busy processor is a warmer processor. But other things can affect the processor temperature, too. In this experiment, the LEDs used by the display give off a little heat, as does switching the radio on and off. So, even though our definition of <span class="literal">busy</span> is a little misleading because it includes turning the radio and display on and off, the idea that the micro:bit’s temperature readings are influenced by what the micro:bit happens to be doing still stands.</p>
<h3 class="h3" id="ch00lev1sec213"><strong>PROJECT: TEMPERATURE AND LIGHT LOGGER</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Medium</em></p>
<p class="noindent">As a hopeless perfectionist and incorrigible botanist, the Mad Scientist wanted a way to measure the ideal location for all the plants in the laboratory. And so a logger of temperature and light was born.</p>
<p class="indent">In Experiment 7, we wrote acceleration readings into a file for later analysis. In that case, we wanted to take readings immediately. Here, we want to log values over a period of time, say over the course of a day.</p>
<div class="image"><img alt="Image" src="../images/f0204-01.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_205"/><a href="ch09.xhtml#ch9fig2">Figure 9-2</a> shows the completed project. As you can see, we have built it into a transparent food container to protect it from the elements, in case we want to use it outdoors.</p>
<div class="image" id="ch9fig2"><img alt="Image" src="../images/09fig02.jpg"/></div>
<p class="figcap"><em>Figure 9-2: A temperature and light logger</em></p>
<p class="indent">You could use this logger to carry out a survey of your yard and determine the best place to grow different plants.</p>
<h4 class="h4" id="ch00lev1sec214"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you’ll need the following items:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">Monk Makes Sensor for micro:bit</span></strong> Another temperature and light sensor would work as well.</p>
<p class="noindentin"><strong><span class="blue">4 × Alligator clip cables</span></strong></p>
<p class="noindentin"><strong><span class="blue">AAA battery pack</span></strong></p>
<p class="noindentin"><strong><span class="blue">Transparent plastic food container</span></strong> This is essential if you want to use the project outdoors. The container should be big enough to house the project, including the battery pack.</p>
<h4 class="h4" id="ch00lev1sec215"><span epub:type="pagebreak" id="page_206"/><strong>Construction</strong></h4>
<ol>
<li class="noindent">This project uses the micro:bit’s local filesystem, which is not available in Blocks code yet. Therefore, this project can be done only in Python. Find the code at <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em>. The Python file for this experiment is <em>ch_09_Logger.py</em>. Flash the program onto your micro:bit.</li>
<li class="noindent">Connect the micro:bit to the sensor board, as shown in <a href="ch09.xhtml#ch9fig3">Figure 9-3</a>.
<div class="image" id="ch9fig3"><img alt="Image" src="../images/09fig03.jpg"/></div>
<p class="figcap"><em>Figure 9-3: Connecting the micro:bit to the Monk Makes Sensor</em></p></li>
<li class="noindent">Place everything into the food container, making sure that the sensor and micro:bit are at the top, near the lid. Fitting the alligator clips from the back of the boards will help.</li>
<li class="noindent">Turn on the battery pack. When you’re ready to start logging, press button <strong>A</strong> and then put the lid on the container. The display will change to show a single dot.</li>
<li class="noindent">The logger can hold about 2,000 readings, so at a rate of one sample per second, it can run for 33 hours before running out of memory. This is about how long a set of AAA batteries should last.
<p class="indent"><span epub:type="pagebreak" id="page_207"/>When you’re ready to stop the readings, press button <strong>A</strong> again. You can then connect the micro:bit to your computer and use Mu’s <em>Files</em> feature to transfer the file <em>data.txt</em> onto your computer, just as you did in Experiment 7 back in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p></li>
<li class="noindent">To make sense of the data, you’ll probably want to import it into a spreadsheet and draw some charts like the one in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>. See Experiment 7 in <a href="ch05.xhtml#ch05">Chapter 5</a> for an example of importing data from the <em>data.txt</em> file into Google Sheets.</li>
</ol>
<div class="image" id="ch9fig4"><img alt="Image" src="../images/09fig04.jpg"/></div>
<p class="figcap"><em>Figure 9-4: Charting temperature and light</em></p>
<p class="indent">In <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>, the steep drop of the line in the light chart indicates the nightfall.</p>
<h4 class="h4" id="ch00lev1sec216"><span epub:type="pagebreak" id="page_208"/><strong>Code</strong></h4>
<p class="noindent">For this project, we’ll need to import the os library, which we’ll use to delete any data file that might already be on the micro:bit. We do this to make space for our new readings. We’ll also need <span class="literal">log</span> from the math library to write the code that calculates the temperature. <em>Log</em> (or <em>logarithm</em>) is a mathematical concept used in the Steinhart-Hart equation that converts the resistance measurement of a thermistor to a temperature. If you are into math, you might like to read more about logarithms here: <em><a href="https://www.mathsisfun.com/algebra/logarithms.html">https://www.mathsisfun.com/algebra/logarithms.html</a></em>.</p>
<h5 class="h5" id="ch00lev1sec217"><strong>Setting the Variables</strong></h5>
<p class="noindent">The code for this project waits for button A to be pressed and then repeatedly takes readings first of temperature then of the light level. Both readings are then written to a file so that when the logging is finished, they can be transferred a computer.</p>
<div class="programs1">sample_period <span class="purple">=</span> <span class="blue1">60000</span><br/>filename <span class="purple">=</span> <span class="red1">'data.txt'</span><br/>temp_pin <span class="purple">=</span> pin1<br/>light_pin <span class="purple">=</span> pin2<br/><br/>last_sample_time <span class="purple">=</span> <span class="blue1">0</span><br/>recording <span class="purple">=</span> <span class="green">False</span><br/>display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>NO<span class="purple">)</span></div>
<p class="indent">We set the variable <span class="literal">sample_period</span> to 60000 milliseconds, or 1 minute. This period tells the micro:bit to take a recording once a minute. By default, the recorded data will be saved into a file called <em>data.txt</em>. You can change the name of this file by changing the value of the <span class="literal">filename</span> variable.</p>
<p class="indent">We tell the micro:bit which two pins are connected to the temperature and light outputs of the sensor board in the <span class="literal">temp_pin</span> and <span class="literal">light_pin</span> variables. In the <span class="literal">last_sample_time</span> variable, we store the last time a reading of the environment was recorded.</p>
<p class="indent">We use the variable <span class="literal">recording</span> to keep track of the whether the project is recording or not recording. This variable is toggled between <span class="literal">True</span> and <span class="literal">False</span> every time button A is pressed.</p>
<h5 class="h5" id="ch00lev1sec218"><span epub:type="pagebreak" id="page_209"/><strong>Reading the Temperature</strong></h5>
<p class="noindent">We create the function <span class="literal">read_c</span> to read the temperature. This involves quite a lot of math.</p>
<div class="programs1"><span class="green">def</span> <span class="blue1">read_c</span><span class="purple">():</span><br/>    r0 <span class="purple">=</span> <span class="blue1">100000.0</span><br/>    r2 <span class="purple">=</span> <span class="blue1">100000.0</span><br/>    b <span class="purple">=</span> <span class="blue1">4250.0</span><br/>    v33 <span class="purple">=</span> <span class="blue1">3.3</span> <span class="ash"># actual result is independent of this value</span><br/>    V <span class="purple">=</span> temp_pin.read_analog<span class="purple">() *</span> v33 <span class="purple">/</span> <span class="blue1">1023.0</span><br/>    R <span class="purple">=</span> r2 <span class="purple">* (</span>v33 <span class="purple">-</span> V<span class="purple">) /</span> V<br/>    t0 <span class="purple">=</span> <span class="blue1">273.15</span> <span class="ash"># 0 deg C in K</span><br/>    t25 <span class="purple">=</span> t0 <span class="purple">+</span> <span class="blue1">25.0</span> <span class="ash"># 25 deg C in K</span><br/>    <span class="ash"># Steinhart-Hart equation (google it)</span><br/>    inv_T <span class="purple">=</span> <span class="blue1">1</span><span class="purple">/</span>t25 <span class="purple">+</span> <span class="blue1">1</span><span class="purple">/</span>b <span class="purple">*</span> log<span class="purple">(</span>R<span class="purple">/</span>r0<span class="purple">)</span><br/>    T <span class="purple">= (</span><span class="blue1">1</span><span class="purple">/</span>inv_T <span class="purple">-</span> t0<span class="purple">)</span><br/>    <span class="green">return</span> <span class="blue1">round</span><span class="purple">(</span>T<span class="purple">,</span> <span class="blue1">1</span><span class="purple">)</span></div>
<p class="indent">We won’t go into the math in detail, but it’s here in case you want to look through it.</p>
<p class="indent">This function measures the voltage at the <span class="literal">temp_pin</span> (pin 1) and uses that to calculate the temperature in degrees Celsius. See “How It Works: Sensors” on <a href="ch09.xhtml#page_211">page 211</a> for more information on how this works.</p>
<p class="indent">If you want your temperatures in Fahrenheit, use the function <span class="literal">read_f</span>, which calls <span class="literal">read_c</span> and converts the temperature to Fahrenheit:</p>
<div class="programs1"><span class="green">def</span> <span class="blue1">read_f</span><span class="purple">(</span><span class="green">self</span><span class="purple">):</span><br/>    <span class="green">return</span> read_c<span class="purple">() *</span> <span class="blue1">9</span><span class="purple">/</span><span class="blue1">5</span> <span class="purple">+</span> <span class="blue1">32</span></div>
<h5 class="h5" id="ch00lev1sec219"><strong>Reading the Light Level</strong></h5>
<p class="noindent">The temperature readings are in units of Celsius or Fahrenheit. However, the light level is not expressed in any specific units. The light readings are just the direct analog readings from pin 2. In effect, we have defined our own units. You can give them a name if you like, perhaps <em>lightiness</em>?</p>
<p class="indent">Measuring light intensity in its standard unit of lux is difficult with this kind of sensor. But if you have a calibrated lux <span epub:type="pagebreak" id="page_210"/>meter, you could carry out your own experiment to compare Lux and <em>lightiness</em> under different levels of illumination.</p>
<h5 class="h5" id="ch00lev1sec220"><strong>The while Loop</strong></h5>
<p class="noindent">The main <span class="literal">while</span> loop (at the end of the code if you are following along in Mu) checks for a press of button A, toggling <span class="literal">recording</span> between <span class="literal">True</span> and <span class="literal">False</span> whenever the button is pressed. When recording starts, a single dot is displayed, and we delete the existing data file with <span class="literal">os.remove</span>. The <span class="literal">remove</span> command is contained within a <span class="literal">try: except:</span> Python structure. This makes sure that if an error occurs, probably because the data file isn’t there and can’t be deleted, the error is ignored and doesn’t crash the program. After we remove the old file, the new file is opened with a mode of <span class="literal">w</span> for writing.</p>
<p class="indent">When button A is pressed again, the <span class="literal">NO</span> image is displayed and the file closed.</p>
<p class="indent">In the main <span class="literal">while</span> loop, there is also an <span class="literal">if</span> block that writes the readings from the light and temperature sensors to the file as long as <span class="literal">recording</span> is <span class="literal">True</span> and enough time has elapsed since the <span class="literal">last_sample_time</span>.</p>
<div class="programs1"><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> button_a<span class="purple">.</span>was_pressed<span class="purple">():</span><br/>        recording <span class="purple">=</span> <span class="green">not</span> recording<br/>        <span class="green">if</span> recording<span class="purple">:</span><br/>            display<span class="purple">.</span>show<span class="purple">(</span><span class="red1">"</span><span class="red1">."</span><span class="purple">)</span><br/>            <span class="green">try</span><span class="purple">:</span><br/>                os<span class="purple">.</span>remove<span class="purple">(</span>filename<span class="purple">)</span><br/>            <span class="green">except</span><span class="purple">:</span><br/>                <span class="green">pass</span><br/>            fs <span class="purple">=</span> <span class="blue1">open</span><span class="purple">(</span>filename<span class="purple">,</span> <span class="red1">'w'</span><span class="purple">)</span><br/>        <span class="green">else</span><span class="purple">:</span><br/>            display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>NO<span class="purple">)</span><br/>            fs<span class="purple">.</span>close<span class="purple">()</span><br/>    now <span class="purple">=</span> running_time<span class="purple">()</span><br/>    <span class="green">if</span> now <span class="purple">&gt;</span> last_sample_time <span class="purple">+</span> sample_period<span class="purple">:</span><br/>        last_sample_time <span class="purple">=</span> now<br/>        <span class="green">if</span> recording<span class="purple">:</span><br/>            temp <span class="purple">=</span> read_c<span class="purple">()</span><br/>            light <span class="purple">=</span> light_pin<span class="purple">.</span>read_analog<span class="purple">()</span><br/>            fs<span class="purple">.</span>write<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>temp<span class="purple">) +</span> <span class="red1">"</span><span class="red1">,"</span> <span class="purple">+</span> <span class="blue1">str</span><span class="purple">(</span>light<span class="purple">))</span><br/>            fs<span class="purple">.</span>write<span class="purple">(</span><span class="red1">'\n'</span><span class="purple">)</span></div>
<h4 class="h4" id="ch00lev1sec221"><span epub:type="pagebreak" id="page_211"/><strong>How It Works: Sensors</strong></h4>
<p class="noindent"><em>Thermistors</em> are a special type of resistor (see the lie detector project in <a href="ch08.xhtml#ch08">Chapter 8</a>) whose resistance changes as the temperature changes. The type of thermistor used in the Monk Makes Sensor for micro:bit is an <em>NTC (negative temperature coefficient)</em>. The <em>negative</em> part means that when the temperature increases, the resistance decreases. We use the resistance to measure the temperature.</p>
<p class="indent">Our thermistor sensor measures temperature as electrical resistance. However, a micro:bit cannot measure resistance directly. Instead, resistance must first be converted into a voltage, and this can then be read by the micro:bit pin that’s acting as an analog input. To do this, we need to use a voltage divider as we did in the lie detector project of <a href="ch08.xhtml#ch08">Chapter 8</a>. However, this time a thermistor, rather than someone’s skin, will provide the variable resistance (<a href="ch09.xhtml#ch9fig5">Figure 9-5</a>). Note that the Monk Makes Sensor for micro:bit board has the 100kΩ resistor built in.</p>
<div class="image" id="ch9fig5"><img alt="Image" src="../images/09fig05.jpg"/></div>
<p class="figcap"><em>Figure 9-5: Schematic diagram for using a thermistor to measure temperature</em></p>
<p class="indent">A thermistor’s resistance does not change every time there is a difference of some number of ohms, indicating a change of one degree. As you saw in the code earlier, the formula for calculating a thermistor’s resistance is complicated, involving the use of logarithms.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_212"/>When you buy a thermistor, it will specify two parameters:</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  The resistance of the thermistor at 25 degrees C (called <span class="literal">r0</span> in our code and equal to 100kΩ for the sensor board)</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  A constant called <span class="literal">beta</span>, or sometimes just <span class="literal">B</span>, that is different for different thermistors (In our code, this is called <span class="literal">b</span>. For the thermistor on the sensor board, <span class="literal">b</span> is 4,250. The value of <span class="literal">beta</span> will always be specified on the datasheet for the thermistor.)</p>
<p class="indent">You can see how the calculation is made in the code. If you want to know more about this formula, search online for “Steinhart-Hart equation.”</p>
<p class="indent">Because the voltage at pin 1 depends on the ratio of the resistance of the thermistor to the fixed resistor, it is independent of the supply voltage. This is just as well, because the 3V connector of the micro:bit can be anything from 3.3V down to about 2V, depending how you are powering the micro:bit and how fresh the batteries are. This is why you will see the comment in the <span class="literal">read_c</span> function explaining that the variable <span class="literal">v33</span> (3.3V) has no effect. In fact, it cancels out in the math. It is included only to make the math a bit easier to follow.</p>
<h3 class="h3" id="ch00lev1sec222"><strong>PROJECT: AUTOMATIC PLANT WATERER</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Hard</em></p>
<p class="noindent">Ever busy with conferences that take them away from the Secret Lab, the Mad Scientist has devised this automatic plant waterer. The project monitors the resistance of the soil to determine how wet it is. If the soil gets too dry, it turns on a water pump. Pressing button A gives a readout of the soil dryness, and pressing button B acts as a test, running the pump for 10 seconds.</p>
<div class="image" id="ch9fig6"><span epub:type="pagebreak" id="page_213"/><img alt="Image" src="../images/09fig06.jpg"/></div>
<p class="figcap"><em>Figure 9-6: The automatic plant waterer project</em></p>
<h4 class="h4" id="ch00lev1sec223"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you’ll need the following items. See the <a href="app01.xhtml">appendix</a> for more information on where to find these.</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">Relay board for micro:bit</span></strong> To switch the pump on and off (You could also use a motor controller such as the Kitroniks board that we used in the rover project of <a href="ch06.xhtml#ch06">Chapter 6</a>.)</p>
<p class="noindentin"><strong><span class="blue">12V aquarium metering pump</span></strong> These pumps are slow but reliable.</p>
<p class="noindentin"><strong><span class="blue">Tubing and connectors</span></strong> To transfer the water from the reservoir to the plant pot</p>
<p class="noindentin"><strong><span class="blue">Large plastic bottle</span></strong> To serve as a water reservoir for the plant</p>
<p class="noindentin"><strong><span class="blue">12V power supply for the pump</span></strong> 12V at 1 amp or more</p>
<p class="noindentin"><span epub:type="pagebreak" id="page_214"/><strong><span class="blue">USB power supply for the micro:bit or a Monk Makes Power for micro:bit and AC adapter</span></strong> This is a long-term project, so you don’t really want to be running it from batteries. See the <a href="app01.xhtml">appendix</a> for long-term micro:bit power options.</p>
<p class="noindentin"><strong><span class="blue">1kΩ resistor</span></strong></p>
<p class="noindentin"><strong><span class="blue">Female DC barrel jack to screw terminal adapter</span></strong> To connect the relay and battery to the pump’s power supply</p>
<p class="noindentin"><strong><span class="blue">7 × Alligator clip cables</span></strong> To connect the nails to the micro:bit</p>
<p class="noindentin"><strong><span class="blue">Fold-back binder clips</span></strong> To keep the watering tube in place</p>
<p class="noindentin"><strong><span class="blue">2 × 5-inch nails</span></strong> To be used as electrodes in the plant pot (Note that 6-inch nails also work just fine. Galvanized (zinc-coated) nails are best because they don’t rust.)</p>
<p class="noindentin"><strong><span class="blue">Potted plant</span></strong></p>
<div class="image"><img alt="Image" src="../images/f0214-01.jpg"/></div>
<p class="indent">The pump you need is a <em>peristaltic pump</em>, sometimes called a <em>dosing pump</em>. You can find one on eBay for a few dollars. These pumps usually come with short inlet and outlet tubes that you’ll need to extend so they can reach from the water reservoir to the pot. They are generally 4 mm in diameter, a common size for garden irrigation systems. You can find such tubing and <span epub:type="pagebreak" id="page_215"/>connectors at eBay, a hardware store, a tropical fish store, or a garden center.</p>
<p class="indent">You’ll need longer alligator clip cables to connect the micro:bit to the nails. A good size would be about 1 foot (30 cm).</p>
<p class="indent">The water reservoir can be anything that will contain a reasonable volume of water (an old milk container would do fine).</p>
<h4 class="h4" id="ch00lev1sec224"><strong>Construction</strong></h4>
<p class="noindent">You’ll need to take extra care when building this project, as it has both an electronic and mechanical component. What’s more, it pumps water around, so if you don’t connect the pipes correctly, you could cause quite a mess in your Secret Lab!</p>
<p class="indent"><a href="ch09.xhtml#ch9fig7">Figure 9-7</a> shows how the electronics are connected to give you an idea of what you are aiming for as you follow the step-by-step instructions.</p>
<div class="image" id="ch9fig7"><img alt="Image" src="../images/09fig07.jpg"/></div>
<p class="figcap"><em>Figure 9-7: Wiring for the automatic plant waterer project</em></p>
<ol>
<li class="noindent"><span epub:type="pagebreak" id="page_216"/>Open <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> and click the link for <strong>Plant Waterer</strong>. Click <strong>Download</strong> and then copy the hex file onto your micro:bit. If you get stuck on this, head back to <a href="ch01.xhtml#ch01">Chapter 1</a>, where the process of transferring programs to your micro:bit is explained in full. The Python version of the code is in <em>ch_09_Plant_Waterer.py</em>.</li>
<li class="noindent">Wrap the 1kΩ resistor’s wires around pins 1 and 2 of the micro:bit.</li>
<li class="noindent">Using <a href="ch09.xhtml#ch9fig7">Figure 9-7</a> as a reference, wire up the alligator clips to the micro:bit, relay board, barrel jack, and pump. Don’t attach the yellow and green cables to the nails or connect the tubes to the pump just yet. To get the alligator clips to attach to the screw terminal ends of the DC barrel jack adapter, use a screwdriver to fully open the screw terminals. If your alligator clip jaws are too big to fit into the screw terminal holes, you can fit straightened-out paper clips into the screw terminals and then clip the alligator clips onto those.</li>
<li class="noindent">Plug the 12V power adapter into the barrel jack adapter and then press button <strong>B</strong> on your micro:bit. You should hear the pump run for 10 seconds and then stop. If it doesn’t do this, double-check your wiring.</li>
<li class="noindent">Push the nails into the soil of the plant pots spaced about 3 or 4 inches (8 to 10 cm) apart. Leave enough of the nail above the soil that you can attach the green and yellow alligator clips, as shown in <a href="ch09.xhtml#ch9fig8">Figure 9-8</a>.
<div class="image" id="ch9fig8"><img alt="Image" src="../images/09fig08.jpg"/></div>
<p class="figcap"><em>Figure 9-8: Positioning the nails in the soil</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_217"/>Now, press button <strong>A</strong> on your micro:bit, and a number should scroll across the screen. This is a measure of the dryness of the soil. The drier the soil, the higher the number. Try adding a little water to the pot, wait for a few seconds, and then press button <strong>A</strong> again. You should see the number decrease. Don’t make the soil too wet, though, as it will take ages to dry out again and you won’t get to see the plant waterer in action.
<p class="indent">You now need to give the plant the right amount of water. You may need to consult someone with a green thumb who knows about your particular plant. Once you’ve found out how moist your plant’s soil should be, keep adding small doses of water until the soil is damp enough. Then press button <strong>A</strong> and make a note of the number. This is your target dryness for the automatic plant waterer.</p></li>
<li class="noindent">We’re now ready for the wet part of this project. Start by measuring out suitable lengths of tubing from the pump. You want enough tubing that you can put one length through the top of the reservoir bottle and have it reach the bottom and the other will reach from the pump into the plant pot. Before attaching the tubing, you need to find out which nozzle of the pump is the <em>inlet</em> and which is the <em>outlet</em>. To do this, press button <strong>B</strong> and put a finger over each of the pump’s tubes. You will feel the inlet pump sucking at your fingertip. Make a note of which tube is which.
<p class="indent">Use the tube connectors to attach these lengths of tubing to the pump’s short tubes.</p></li>
<li class="noindent">Clip the binder clips onto the side of the pot and push the tubing through the handles of the clip, as shown in <a href="ch09.xhtml#ch9fig9">Figure 9-9</a>.
<div class="image" id="ch9fig9"><span epub:type="pagebreak" id="page_218"/><img alt="Image" src="../images/09fig09.jpg"/></div>
<p class="figcap"><em>Figure 9-9: Securing the tube to the plant’s pot</em></p></li>
<li class="noindent">Fill up the reservoir bottle and push the extended inlet tube into the bottle, down to the bottom.</li>
<li class="noindent">Test the pump by pressing button <strong>B</strong> a couple of times. If the water finds its way to the pot without any dripping or leakage, the waterer is almost ready to go. If not, find and seal the leaks by adjusting the connections.</li>
<li class="noindent">The final step before you can let your plant waterer do its mundane work, leaving you free for more adventurous tasks, is to adjust the value of <span class="literal">dry_threshold</span>. Set <span class="literal">dry_threshold</span> to the value you recorded in step 6 and then flash the program onto your micro:bit again.</li>
</ol>
<h4 class="h4" id="ch00lev1sec225"><strong>Code</strong></h4>
<p class="noindent">The code for this project is quite complex. As well as monitoring the soil’s moisture content, it also has to handle button presses and make sure that the pump doesn’t get too carried away and flood the lab.</p>
<h5 class="h5" id="ch00lev1sec226"><strong>Blocks Code</strong></h5>
<p class="noindent">Here is the Blocks code for the project.</p>
<div class="image"><span epub:type="pagebreak" id="page_219"/><img alt="Image" src="../images/f0219-01.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_220"/>In the <span class="literal">on start</span> block, we define three variables:</p>
<p class="noindentint"><span class="blue"><span class="literal"><span class="codestrong1">dry_threshold</span></span></span> We put our value from step 6 here. If the plant gets dryer than this value, it will be watered.</p>
<p class="noindentin"><span class="blue"><span class="literal"><span class="codestrong1">on_time_ms</span></span></span> This is the amount of time (in milliseconds) that the pump will run when watering. Keeping this value small (say 10 seconds) will keep the plant from being overwatered. It will also prevent accidents that might result in minor flooding!</p>
<p class="noindentinb"><span class="blue"><span class="literal"><span class="codestrong1">check_period_ms</span></span></span> The water needs a little time to spread throughout the pot and evenly wet the soil. This variable sets the delay between each dryness check. By default, it’s set to 3,600,000 (1 hour in milliseconds).</p>
<p class="indent">If we have an <span class="literal">on_time_ms</span> value of 10, the maximum watering time the plant can receive in one day is 24 × 10 seconds or 4 minutes. With this kind of pump, it will receive about a pint (500 mL) of water. That’s quite a lot, but if you have a really big pot, you may need to decrease <span class="literal">check_period_ms</span> or increase <span class="literal">on_time_ms</span> to allow the plant to get even more water. We’ll discuss this further in “Things to Try” on <a href="ch09.xhtml#page_222">page 222</a>.</p>
<p class="indent">Besides these three variables, we have two functions, <span class="literal">check_dryness</span> and <span class="literal">water_the_plant</span>. The <span class="literal">check_dryness</span> function updates the <span class="literal">dryness</span> variable with a new soil reading from pin 2. Notice that this function also turns on pin 1, but just while the reading is being taken. We’ll explain why in “How It Works: Measuring Soil Dampness” on <a href="ch09.xhtml#page_222">page 222</a>.</p>
<p class="indent">The <span class="literal">water_the_plant</span> function turns on pin 0 to activate the relay, turns on the pump for the time specified in <span class="literal">on_time_ms</span>, and displays the down arrow on the micro:bit to indicate that watering is in progress (a bit like it’s raining).</p>
<p class="indent">With the <span class="literal">forever</span> loop, we first check whether sufficient time has elapsed since the last check (by default 1 hour). If enough time has passed, the loop calls <span class="literal">check_dryness</span> and compares this reading to the <span class="literal">dry_threshold</span>. If the pot is too dry, <span class="literal">water_the_plant</span> is called.</p>
<p class="indent">Now that the check is complete, the <span class="literal">dont_water_until</span> variable is set to the current time plus the <span class="literal">check_period_ms</span> to schedule the next check. The <span class="literal">dryness</span> is then shown on the display using the <span class="literal">plot bar graph of</span> block. The higher the level of LEDs on the <span epub:type="pagebreak" id="page_221"/>display, the drier the soil is and the closer it is to being given more water.</p>
<p class="indent">Then we have the code that checks whether button A is pressed and reacts appropriately. This code calls <span class="literal">check_dryness</span> and then displays it before showing the bar graph again. The handler for button B calls <span class="literal">water_the_plant</span> and then displays the <span class="literal">dryness</span> level.</p>
<h5 class="h5" id="ch00lev1sec227"><strong>MicroPython Code</strong></h5>
<p class="noindent">Here is the MicroPython version of the code:</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><br/>dryness <span class="purple">=</span> <span class="blue1">0</span><br/>dry_threshold <span class="purple">=</span> <span class="blue1">500</span><br/>on_time_ms <span class="purple">=</span> <span class="blue1">10000</span><br/>check_period_ms <span class="purple">=</span> <span class="blue1">3600000</span><br/>dont_check_until <span class="purple">=</span> <span class="blue1">0</span><br/><br/><span class="green">def</span> <span class="blue1">water_the_plant</span><span class="purple">():</span><br/>    pin0<span class="purple">.</span>write_digital<span class="purple">(</span><span class="blue1">1</span><span class="purple">)</span><br/>    display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>ARROW_S<span class="purple">)</span><br/>    sleep<span class="purple">(</span>on_time_ms<span class="purple">)</span><br/>    pin0<span class="purple">.</span>write_digital<span class="purple">(</span><span class="blue1">0</span><span class="purple">)</span><br/><br/><span class="green">def</span> <span class="blue1">check_dryness</span><span class="purple">():</span><br/>    <span class="green">global</span> dryness<br/>    pin1<span class="purple">.</span>write_digital<span class="purple">(</span><span class="blue1">1</span><span class="purple">)</span><br/>    dryness <span class="purple">=</span> pin2<span class="purple">.</span>read_analog<span class="purple">()</span><br/>    pin1<span class="purple">.</span>write_digital<span class="purple">(</span><span class="blue1">1</span><span class="purple">)</span><br/><br/><span class="green">def</span> <span class="blue1">bargraph</span><span class="purple">(</span>a<span class="purple">):</span><br/>    display<span class="purple">.</span>clear<span class="purple">()</span><br/>    <span class="green">for</span> y <span class="green">in</span> <span class="blue1">range</span><span class="purple">(</span><span class="blue1">0</span><span class="purple">,</span> <span class="blue1">5</span><span class="purple">):</span><br/>        <span class="green">if</span> a <span class="purple">&gt;</span> y<span class="purple">:</span><br/>            <span class="green">for</span> x <span class="green">in</span> <span class="blue1">range</span><span class="purple">(</span><span class="blue1">0</span><span class="purple">,</span> <span class="blue1">5</span><span class="purple">):</span><br/>                display<span class="purple">.</span>set_pixel<span class="purple">(</span>x<span class="purple">,</span> <span class="blue1">4</span><span class="purple">-</span>y<span class="purple">,</span> <span class="blue1">9</span><span class="purple">)</span><br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> button_a<span class="purple">.</span>was_pressed<span class="purple">():</span><br/>        check_dryness<span class="purple">()</span><br/>        display<span class="purple">.</span>scroll<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>dryness<span class="purple">))</span><br/>        bargraph<span class="purple">(</span>dryness <span class="purple">/</span> <span class="blue1">200</span><span class="purple">)</span><br/><span epub:type="pagebreak" id="page_222"/>    <span class="green">if</span> button_b<span class="purple">.</span>was_pressed<span class="purple">():</span><br/>        water_the_plant<span class="purple">()</span><br/>        check_dryness<span class="purple">()</span><br/>        bargraph<span class="purple">(</span>dryness <span class="purple">/</span> <span class="blue1">200</span><span class="purple">)</span><br/>    <span class="green">if</span> running_time<span class="purple">() &gt;</span> dont_check_until<span class="purple">:</span><br/>        check_dryness<span class="purple">()</span><br/>        <span class="green">if</span> dryness <span class="purple">&gt;</span> dry_threshold<span class="purple">:</span><br/>            water_the_plant<span class="purple">()</span><br/>        dont_check_until <span class="purple">=</span> running_time<span class="purple">() +</span> check_period_ms<br/>        bargraph<span class="purple">(</span>dryness <span class="purple">/</span> <span class="blue1">200</span><span class="purple">)</span></div>
<p class="indent">Because MicroPython has no equivalent of the <span class="literal">plot bar graph of</span> block, we use the <span class="literal">bargraph</span> function from the Shout-o-meter in <a href="ch02.xhtml#ch02">Chapter 2</a> to display the <span class="literal">dryness</span> level.</p>
<h4 class="h4" id="ch00lev1sec228"><strong>Things to Try</strong></h4>
<p class="noindent">Because the plant waterer keeps the moisture level of the plant more or less constant, you can measure the amount of water the plant is using by seeing how much water has left the reservoir.</p>
<p class="indent">Use a measuring cup when you refill the reservoir bottle and log how much water you need to fill it back up. Once you know how much water your plant typically needs per day, you can work out how long your reservoir should last before it needs a refill. This will be very important if you want to keep your plant alive when you go on vacation.</p>
<h4 class="h4" id="ch00lev1sec229"><strong>How It Works: Measuring Soil Dampness</strong></h4>
<p class="noindent">Impure water (such as water in soil) has a much lower electrical resistance than air. In other words, the dryer the soil, the higher its electrical resistance, and the more water in the soil, the lower its resistance. By measuring the resistance between the two nails, we can measure the dryness of the soil.</p>
<p class="indent">If you look back at <a href="ch09.xhtml#ch9fig7">Figure 9-7</a>, you can see that there is a resistor between pins 1 and 2. To make it easier to see what is going on, another way of visualizing the schematic is shown in <a href="ch09.xhtml#ch9fig10">Figure 9-10</a>.</p>
<div class="image" id="ch9fig10"><span epub:type="pagebreak" id="page_223"/><img alt="Image" src="../images/09fig10.jpg"/></div>
<p class="figcap"><em>Figure 9-10: Schematic for measuring soil resistance</em></p>
<p class="indent">Notice that the diagram in <a href="ch09.xhtml#ch9fig10">Figure 9-10</a> is almost identical to the one in <a href="ch08.xhtml#ch8fig4">Figure 8-4</a> on <a href="ch08.xhtml#page_198">page 198</a>, where we were measuring skin resistance (rather than soil resistance) in the lie detector project. The one big difference is that rather than being connected permanently to 3V, the top of the fixed 1kΩ resistor is connected to pin 1. When we take a measurement of the soil dryness, we first set pin 1 high (to 3V) to take the reading and then set the pin back to 0V.</p>
<p class="indent">The reason for using Pin 1 instead of the 3V connection is that we want to allow electricity to flow through the soil only intermittently. If the resistor were attached to 3V, an electric current would always be flowing through the soil, messing up the readings and speeding up corrosion of the nails. This process is known as <em>electrolysis</em>. By only turning on pin 1 for the brief time that we take a reading, we avoid this problem.</p>
<h3 class="h3" id="ch00lev1sec230"><strong>SUMMARY</strong></h3>
<p class="noindent">In this chapter, we explored how to measure temperature, created a temperature and light level data logger, and created an automatic plant waterer. In the next chapter, we’ll see how the Mad Scientist uses the micro:bit’s built-in radio library.<span epub:type="pagebreak" id="page_224"/></p>
</body></html>