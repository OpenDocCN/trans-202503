- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 32 OBJECT-ORIENTED DESIGN
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32 面向对象设计
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: 'In preceding chapters, I’ve explored many topics that aren’t typically associated
    with Batch from booleans to hash tables, with many others in between. In this
    chapter, I’ll tackle the holy grail of Batch user-built tools: object-oriented
    design.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我探讨了许多通常与Batch无关的主题，从布尔值到哈希表，还有很多其他内容。在这一章中，我将处理Batch用户自建工具的圣杯：面向对象设计。
- en: After explaining the difference between procedural and object-oriented coding,
    I’ll lay out the four pillars of object-oriented programming. Then I’ll present
    a fully functional model of Batch object-oriented design, complete with bat files
    representing parent, intermediate, and child objects. After you’ve learned how
    to invoke the object-oriented code, I’ll share many recommendations and analyze
    how well this model satisfies the basic tenets of object-oriented design.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了过程式编码和面向对象编码的区别后，我将介绍面向对象编程的四大支柱。接着，我会展示一个完整功能的Batch面向对象设计模型，其中包含代表父对象、中间对象和子对象的bat文件。在你学会如何调用面向对象的代码后，我将分享许多建议并分析这个模型如何满足面向对象设计的基本原则。
- en: Procedural vs. Object-Oriented Coding
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过程式与面向对象编程
- en: In the very early days of computers, all coding was *procedural*—that is, all
    programs consisted of a series of computational steps. The methodology is still
    very much in existence with possibly more than a trillion lines of such code still
    in use and many more written every day. By default, variables are accessed globally
    in procedural code. Sometimes many hundreds of variables are defined in a section
    near the beginning of a program, and at other times, such as in Batch, they come
    into being when first referenced. Even when an internal routine or procedure is
    invoked, the set of active and available variables doesn’t change. Certain measures
    can often be invoked to limit scope, such as the setlocal discussed in [Chapter
    3](chapter3.xhtml), but in procedural coding, a variable typically can be set
    or reset anywhere in what is often a very large program file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，所有的编码都是*过程式的*——也就是说，所有程序由一系列计算步骤组成。这个方法论至今仍然存在，可能有超过一万亿行这样的代码仍在使用，每天还有更多新的代码被编写出来。在过程式代码中，变量默认是全局访问的。有时，程序开头的一部分会定义数百个变量，而在其他时候，比如在批处理程序中，变量是在首次引用时创建的。即使调用了一个内部例程或过程，活动和可用的变量集合也不会改变。通常可以采取一些措施来限制作用域，比如[第3章](chapter3.xhtml)中讨论的setlocal，但在过程式编码中，变量通常可以在程序文件的任何地方被设置或重置，这些文件通常非常庞大。
- en: Before long, some smart people came up with the concept of *object-oriented
    programming (OOP)*, where the code is broken into small, easy-to-manage *objects*,
    each containing data in the form of variables and executable code in the form
    of methods. A *method* is similar to an internal routine in Batch; it can be invoked,
    and when it completes its execution, control is returned to the point of the call,
    but a method can also be called externally; that is, code inside another program
    file can call the method directly. Regardless of the source of the call, the method
    accepts well-defined inputs and returns equally well-defined outputs. However,
    most of the data inside a method is typically inaccessible from elsewhere in the
    program file and especially from other program files.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，一些聪明的人提出了*面向对象编程（OOP）*的概念，在这种方法中，代码被分解成小的、易于管理的*对象*，每个对象包含变量形式的数据和方法形式的可执行代码。*方法*类似于批处理中的内部例程；它可以被调用，当它完成执行时，控制权会返回到调用点，但方法也可以被外部调用；即，其他程序文件中的代码可以直接调用该方法。不管调用的来源是什么，方法都接受明确定义的输入并返回同样明确定义的输出。然而，方法内部的大多数数据通常无法从程序文件的其他地方访问，尤其是从其他程序文件中。
- en: The compartmentalization of the code into individual objects streamlines the
    logic and guards against the unintended consequence of some portion of the code
    adversely affecting another portion. Additionally, if one of these objects is
    of use in a different context, it can easily be used by both processes without
    modification or duplication. An equivalently useful portion of a procedural program
    might end up being copied and pasted into another program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的模块化将其分解为独立的对象，从而简化了逻辑并防止了代码某一部分对其他部分产生不良影响。此外，如果其中一个对象在不同的上下文中有用，它可以在不修改或重复的情况下被两个进程轻松使用。一个等效有用的过程式程序部分可能最终被复制并粘贴到另一个程序中。
- en: If I were to construct a list of great personal irritants—and for the sake of
    brevity, I’ll limit this to work/coding-related peeves—atop my jeremiad is procedural
    code disguised as object-oriented code. Certain languages and frameworks are designed
    to support each coding paradigm. Java and C# are object-oriented languages; COBOL
    and Batch are procedural languages. But contrary to what many believe, it isn’t
    that simple; procedural code can easily be written in Java, and with some work,
    object-oriented principles can be implemented in Batch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The Four Pillars
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any coding language that purports to be object-oriented must fully support the
    four pillars of object-oriented programming. Languages considered to be object-oriented
    implement these in different ways, but they all have built-in mechanisms to guide
    the coder into writing code with these four characteristics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The first pillar is *abstraction*, which simplifies the code’s interface with
    the outside world. It shows only the necessary or relevant features to the user,
    while shielding the implementation details and any information irrelevant to the
    functionality’s use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This segues into the second pillar, *encapsulation*, which restricts access
    to certain methods and variables in an object, wrapping up data and code into
    multiple small units. Data hiding, or treating some variables and methods as private,
    is a significant part of this pillar. Another significant part is simply the act
    of creating compact, readable, and reusable modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance*, the third pillar, allows for the creation of a base or parent
    object. Then derived objects can use the parent object while extending it to fit
    the more specific needs of the child. The classic example is a base or parent
    object of an Animal, defining all that is common throughout the animal kingdom.
    Then intermediate objects defined as Reptile and Mammal can inherit data and routines
    from the Animal object and add to it information about their respective zoological
    classes. Then objects of Cat, Rat, and even Bat can inherit from the Mammal object,
    which is already inheriting from the Animal object. More than 1,000 child objects,
    one for each bat species on the planet, can then inherit from the Bat object.
    Finally, each of the inheriting objects can use the data and code in its parent
    objects for its own use.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The fourth pillar, *polymorphism*, which means the condition of occurring in
    several different forms, derives literally from the Greek words meaning *many
    forms*. This allows a call to a routine to behave differently in different situations.
    Reusable code is always awesome, but this pillar takes the concept of reuse to
    its zenith. A method in the parent object might be invoked by multiple child objects,
    where each invocation is unique to the child.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In the pages ahead, I’ll attempt to mimic these four pillars of abstraction,
    encapsulation, inheritance, and polymorphism.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Batch Object-Oriented Design
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter is about Batch object-oriented design and not Batch object-oriented
    programming for two reasons. First, and more trivially, BOOP is a horrible acronym,
    reminiscent of the noise one might make when affectionately poking a baby’s nose.
    BOOD isn’t much better, but I do have a Brilliant Acronym Team (or BAT) diligently
    working on something batter ... sorry, something better.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解的是 Batch 面向对象设计，而不是 Batch 面向对象编程，原因有两个。首先，更琐碎的一点是，BOOP 是一个糟糕的缩写，让人联想到在亲切地戳宝宝鼻子时发出的声音。BOOD
    也不怎么样，但我确实有一个“辉煌缩写团队”（Brilliant Acronym Team，简称 BAT）正在努力做一些更好的……抱歉，是更棒的事情。
- en: Far more important, Batch has none of the built-in features that are intrinsic
    to more modern languages that implement object-oriented programming. I’ll demonstrate
    how to mimic each of its four pillars, and the level of success in creating object-oriented
    bat files may very well surprise many, but I’ll craft some of its functionality
    more completely than other functionality. True object-oriented programming won’t
    be possible in Batch, but I encourage you to incorporate these design elements,
    in whole or in part, in the design of your Batch code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更为重要的是，Batch 没有实现面向对象编程（OOP）所固有的内建特性，这些特性在更现代的编程语言中得到了实现。我将展示如何模拟其四个支柱，并且创建面向对象的批处理文件的成功程度可能会让许多人感到惊讶，但我会比其他功能更完整地构建一些其功能。真正的面向对象编程在
    Batch 中是不可能实现的，但我鼓励你在 Batch 代码的设计中，完全或部分地融入这些设计元素。
- en: In Batch, a variable cannot be defined as public or private; in fact, variables
    can’t be defined at all. There is no keyword to invoke inheritance found in other
    languages, such as “extends” or “implements.” In OOP, a child object can override
    methods in the parent object; you’ll soon see how to perform many of these tasks
    in Batch, but they won’t be done automatically. Remember that this is a language
    without booleans, floats, the while and do...while commands, the and and or operators,
    arrays, and hash tables. I’ve demonstrated how to build all of those things with
    the tools at hand (and I’ll do the same with stacks and queues in [Chapter 33](chapter33.xhtml)),
    so it should be of little surprise that Batch has nothing off the shelf for anything
    like object-oriented programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Batch 中，变量不能被定义为公有或私有；事实上，变量根本无法定义。没有像“extends”或“implements”这样的关键字来调用继承。面向对象编程（OOP）中，子对象可以覆盖父对象的方法；你很快就会看到如何在
    Batch 中执行这些任务，但它们不会自动完成。请记住，这是一个没有布尔值、浮动值、while 和 do...while 命令、以及 and 和 or 运算符、数组和哈希表的语言。我已经演示了如何利用手头的工具构建所有这些功能（并且在[第33章](chapter33.xhtml)中我将以同样的方式演示堆栈和队列的构建），所以应该不会让人感到惊讶，Batch
    并没有现成的面向对象编程功能。
- en: However, object-oriented principles can be used, and should be used, regardless
    of the provided toolkit. Someone coding in an “object-oriented language” can easily
    define excessive class-level variables, make all data items public, and put the
    lion’s share of the code into a “god object” (a single object that does too much
    and is too big to be managed efficiently). But regardless of the coding language,
    this design with large modules and excessive global variables is essentially procedural
    coding. More modern languages have object-oriented guardrails, but guardrails
    can be breached.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，面向对象的原则是可以使用的，而且应该被使用，不论提供了什么样的工具集。在“面向对象语言”中编程的人，往往会轻易地定义过多的类级别变量，将所有数据项设置为公有，并将大部分代码放入一个“上帝对象”（一个做得太多且太大，无法高效管理的单一对象）中。但无论是什么编程语言，这种设计模式——大模块和过多的全局变量——本质上还是过程式编程。更现代的语言提供了面向对象的护栏，但这些护栏是可以突破的。
- en: Conversely, there’s an expectation among many that Batch coders should create
    only large uninteresting modules. But while Batch procedural code is the standard,
    there’s no Batch police requiring it. When object-oriented programming or design
    is thought of as a technique and not as a characteristic associated with only
    some languages, scales will fall from your eyes as if on the road to Damascus.
    Batch doesn’t possess the sturdy guardrails offered elsewhere, but you can craft
    object-oriented techniques using any coding language, just as it’s more than possible
    to reach the summit driving up a mountain road with shear drops. The infrastructure
    or plumbing might not exist in Batch and not everything will be possible, but
    the elegance of object-oriented design in Batch offers the same benefits realized
    in other languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，许多人认为批处理程序员应该只创建大型、无趣的模块。但尽管批处理过程式代码是标准做法，却没有“批处理警察”强制要求它。当面向对象编程或设计被视为一种技术，而不是仅与某些语言相关的特征时，你会恍若顿悟，仿佛走在前往大马士革的路上。批处理并没有其他语言所提供的坚固护栏，但你可以使用任何编程语言来打造面向对象的技术，就像即使在悬崖峭壁的山路上开车也完全有可能到达山顶。批处理中可能没有基础设施或管道，也不是所有事情都能实现，但批处理中的面向对象设计的优雅性提供了与其他语言相同的好处。
- en: Classes and Objects
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类与对象
- en: One of the differences between OOP and Batch object-oriented design is that
    traditionally each module or file is defined as a *class*, and an *object* is
    an instantiation of that class. Instantiating an object is much like defining
    a variable. Just as a variable can be defined as a string or as an integer in
    many languages, an object is instantiated to be one specific instance of a class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程与批处理面向对象设计之间的一个区别是，传统上每个模块或文件被定义为一个 *class*，而 *object* 是该类的一个实例化。实例化一个对象就像定义一个变量一样。就像在许多语言中，变量可以定义为字符串或整数，实例化对象就是将其定义为类的一个具体实例。
- en: To demonstrate, imagine again a class defined as *Bat*, representing all flying
    nocturnal mammals, where each species of bat would have its own class inheriting
    from *Bat*. One such species is the Madagascan fruit bat, and its class might
    be defined as a *MadFruitBat*. This class represents all bats of this one species,
    and it can be instantiated many times, each time representing one specific creature.
    A cave containing 500 Madagascan fruit bats could be populated with 500 objects,
    each one an instantiation of the *MadFruitBat* class individually named for a
    particular bat.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设定义了一个类 *Bat*，表示所有飞行的夜行哺乳动物，其中每个蝙蝠物种都有自己的类，从 *Bat* 类继承。其中一个物种是马达加斯加果蝠，其类可能定义为
    *MadFruitBat*。这个类表示所有属于该物种的蝙蝠，并且它可以被实例化多次，每次代表一个特定的个体。一个包含500只马达加斯加果蝠的洞穴可以被填充为500个对象，每一个都是
    *MadFruitBat* 类的一个实例，且每个实例会为特定的蝙蝠命名。
- en: This is where Batch has its first object-oriented limitation. Remember that
    this is a language without the ability to define variables as strings and integers.
    Obviously then, a variable can’t be defined or instantiated as a data type corresponding
    to a class module. In Batch, the distinction between classes and objects doesn’t
    exist. A module or bat file is itself an object. It doesn’t have to be instantiated,
    nor can it be instantiated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是批处理（Batch）首次遇到面向对象限制的地方。记住，这是一种无法定义变量为字符串或整数的语言。显然，因此，变量不能被定义或实例化为与类模块相对应的数据类型。在批处理中，类与对象之间的区别是不存在的。模块或批处理文件本身就是一个对象。它不需要实例化，也无法实例化。
- en: For this reason, the word *class* isn’t part of the Batch object-oriented design
    vernacular. I’ll soon share bat files that are fully constituted objects, each
    one ready to be invoked, and I’ll be referring to them as *objects*. The Madagascan
    fruit bat defined as the *MadFruitBat* class in OOP would be the *MadFruitBat.bat*
    object bat file in Batch. To implement the 500 individual Madagascan fruit bats,
    you would need to create a small bat file for each, and each would inherit from
    *MadFruitBat.bat*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，*class* 这个词并不是批处理面向对象设计术语的一部分。我很快会分享一些完全构成对象的批处理文件，每一个都可以被调用，我将把它们称作
    *objects*。在面向对象编程（OOP）中定义的马达加斯加果蝠类（*MadFruitBat*）将会是批处理中的 *MadFruitBat.bat* 对象批处理文件。为了实现500只马达加斯加果蝠，你需要为每只果蝠创建一个小的批处理文件，每个文件都继承自
    *MadFruitBat.bat*。
- en: Actually, *oMadFruitBat.bat* is a better name for the object bat file. To distinguish
    an object bat file from its more pedestrian brethren, I always prepend its name
    with a lowercase *o* as a visual cue. The *obj* text also works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，*oMadFruitBat.bat* 是对象 bat 文件的更好名称。为了区分对象 bat 文件与其他常见的 bat 文件，我总是在它的名字前加上小写字母
    *o* 作为视觉提示。*obj* 文字也可以使用。
- en: Batch Object-Oriented Design Model
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理面向对象设计模型
- en: The best way of describing object-oriented design is with an example or model.
    I’ll lay out here the broad strokes of the example of Batch object-oriented design
    that I present in this chapter. Then I’ll show the parent object with examples
    of intermediate and child objects, all the while explaining the object-oriented
    concepts implemented in each module. In the next section, “Executing Object-Oriented
    Batch,” I’ll discuss exactly how to invoke this model, and in a later section,
    “The Four Pillars in Batch,” I’ll explore how closely this model mimics each of
    the central concepts of object-oriented principles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 描述面向对象设计的最佳方式是通过示例或模型。接下来我将简要介绍本章中展示的批处理面向对象设计的示例。然后，我将展示父对象，并附上中间对象和子对象的示例，同时解释每个模块中实现的面向对象概念。在接下来的部分“执行面向对象的批处理”中，我将详细讨论如何调用这个模型，而在后续部分“批处理中的四大支柱”中，我将探讨这个模型如何紧密模仿面向对象原则的核心概念。
- en: At the top of the pyramid is the base or parent object. Other objects inherit
    from it, but it’s the one object in this model that doesn’t inherit from another
    object. Beneath the parent are the intermediate objects that inherit directly
    from the parent object. Other intermediate objects can inherit from the first
    level of intermediate objects, culminating in child objects at the bottom of the
    pyramid. Intermediate and child objects are both called *derived objects* because
    they inherit or are derived from another object. (Technically, an intermediate
    object is also a child object because it is a child of another object, but I use
    the term *child* for what might more accurately be called a “childless child object.”)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶部是基类或父对象。其他对象从它继承，但它是这个模型中唯一一个不从其他对象继承的对象。在父对象下方是直接继承自父对象的中间对象。其他中间对象可以从第一级中间对象继承，最终在金字塔底部形成子对象。中间对象和子对象都被称为
    *派生对象*，因为它们继承或来源于其他对象。（从技术上讲，中间对象也是一个子对象，因为它是另一个对象的子对象，但我使用“子对象”一词来描述那些可能更准确地称为“无子对象”的对象。）
- en: 'In this chapter’s Batch object-oriented design model, Movie is the parent object
    to dozens of different film genre objects, such as SciFi, RomCom, and Action,
    although only two are shown: Comedy and Drama. Individual movies are their own
    specific object, each one inheriting from a particular genre object. More than
    two million movies have been released, but I’m showing only three here, two of
    which are the greatest movies ever released, and *The Godfather* is a great film
    as well. The objects that I’ll present in this chapter, I’ve marked with an asterisk
    in [Figure 32-1](#fig32-1).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的批处理面向对象设计模型中，电影是父对象，派生出了许多不同的电影类型对象，如科幻片、浪漫喜剧和动作片，虽然这里只展示了喜剧和剧情两种类型。每部电影都是一个特定的对象，每部电影从某个特定的类型对象继承而来。全球发布的电影超过两百万部，但在这里我只展示了三部，其中两部是有史以来最伟大的电影，*教父*
    也是一部伟大的电影。我将在本章中展示的对象，在[图32-1](#fig32-1)中已用星号标注。
- en: '![](../images/fig32-1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig32-1.jpg)'
- en: 'Figure 32-1: Parent, intermediate, and child objects'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-1：父对象、中间对象和子对象
- en: The Movie object contains data and methods that are common to all movies, or
    are at least the defaults for all movies. (Echoing the parlance of OOP, I’ll use
    the term *method* in place of *routine* from this point forward.) The Comedy and
    Drama objects each inherit from the Movie object and extend it, defining data
    and methods particular to each genre. The individual movie objects inherit from
    the genre objects, and thus indirectly from the Movie object, and contain detailed
    data about their specific flick. (Each arrow extends from the derived object to
    its parent object.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 电影对象包含所有电影共有的数据和方法，或者至少是所有电影的默认数据和方法。（借用面向对象编程的术语，从这一点起我将使用 *方法* 来代替 *例程* 一词。）喜剧和剧情对象各自继承自电影对象，并对其进行扩展，定义了与每个类型特有的数据和方法。个别电影对象继承自类型对象，因此间接地继承自电影对象，并包含有关其特定电影的详细数据。（每条箭头表示从派生对象到其父对象的继承关系。）
- en: But this isn’t a rigid hierarchy. A movie franchise object such as StarTrek
    could inherit from the SciFi genre object (neither is shown), and the individual
    *Star Trek* movies could be child objects of the movie franchise object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是一个严格的层次结构。像 StarTrek 这样的电影系列对象可以继承自科幻类型对象（两者都未显示），而个别的 *Star Trek* 电影则可以作为电影系列对象的子对象。
- en: More important, all objects are bat files. The Movie object in its most concrete
    form is the *oMovie.bat* bat file, and the Comedy object is the *oComedy.bat*
    bat file. Likewise, one of the child objects will be *oBigLebowski.bat*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，所有对象都是 bat 文件。Movie 对象最具体的形式是 *oMovie.bat* bat 文件，而 Comedy 对象是 *oComedy.bat*
    bat 文件。同样，子对象之一将是 *oBigLebowski.bat*。
- en: Some object-oriented languages offer multiple inheritance; that is, a derived
    object can inherit from two or more different objects. For instance, the Dramedy
    object might inherit from both the Comedy and Drama objects. While that is theoretically
    possible even in Batch, I’m restricting this model to single inheritance, so the
    Dramedy object is just another genre object inheriting from the Movie object,
    and individual dramedies will then inherit from the Dramedy object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向对象的语言提供多重继承；也就是说，一个派生对象可以继承自两个或更多不同的对象。例如，Dramedy 对象可能同时继承自 Comedy 和 Drama
    对象。虽然即使在 Batch 中从理论上讲也是可能的，但我将此模型限制为单一继承，因此 Dramedy 对象只是继承自 Movie 对象的另一种类型对象，个别的
    dramedy 将继承自 Dramedy 对象。
- en: The Parent Object
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 父对象
- en: Once all of this makes sense conceptually, you’ll want to see everything in
    action. Starting with the base or parent object, [Listing 32-1](#Lis32-1) shows
    the contents of *oMovie.bat*. Note that this and the other object bat file don’t
    start with a setlocal command because they’ll always be called from other bat
    files that contain the command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些概念变得清晰，你就会想看看一切是如何运作的。从基本或父对象开始，[列表 32-1](#Lis32-1) 显示了 *oMovie.bat* 的内容。请注意，这个和其他对象的
    bat 文件不会以 setlocal 命令开头，因为它们总是从包含该命令的其他 bat 文件中调用。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 32-1: The base or parent object, oMovie.bat'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 32-1：基本或父对象，oMovie.bat
- en: There are many interesting pieces of this object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有很多有趣的部分。
- en: Hiding Methods
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐藏方法
- en: Encapsulation, one of OOP’s pillars, includes the hiding of methods. By default,
    all methods of a bat file are hidden because there’s no built-in means of creating
    multiple entry points into a bat file; when a bat file executes, it starts at
    the top every time. Hence, the task here isn’t to hide certain methods but to
    make certain methods publicly accessible, while leaving the others hidden.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 封装，面向对象编程（OOP）的支柱之一，包括隐藏方法。默认情况下，bat 文件的所有方法都是隐藏的，因为没有内置的方式可以创建多个入口点进入 bat 文件；当
    bat 文件执行时，每次都会从顶部开始。因此，这里的任务不是隐藏某些方法，而是使某些方法公开可访问，同时保持其他方法隐藏。
- en: 'The for command ❶ acts as a “traffic cop”; it contains a list of the bat file’s
    public methods as its input: Constructor, DispInfo, Set, and Get. The if command
    inside its code block compares the first parameter received, meth, to this list.
    If it matches one of the methods listed, the parameter, prepended with a colon,
    becomes the argument of the call command ❷, and we pass the remaining parameters
    as additional arguments.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: for 命令 ❶ 充当“交通警察”；它包含了 bat 文件的公共方法列表作为输入：构造函数（Constructor）、显示信息（DispInfo）、设置（Set）和获取（Get）。它代码块中的
    if 命令将收到的第一个参数 meth 与此列表进行比较。如果它与列表中的某个方法匹配，则该参数（在前面加上冒号）将成为调用命令 ❷ 的参数，剩余的参数将作为附加参数传递。
- en: Upon its completion of the called method, control immediately returns to the
    calling bat file via the goto :eof command ❸ at the end of the for loop. Notice
    that the last method ❾ isn’t on the list. As its name suggests, it’s a private
    method, callable exclusively from methods inside the object. If a calling bat
    file tries to invoke any other method not on the list or some text that isn’t
    even a method, the code writes out an abort message ❹ and exits the entire process
    after a pause. (More robust error handling would be preferrable, but this works
    as a demonstration.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用方法完成后，控制通过 goto :eof 命令 ❸ 立即返回到调用的 bat 文件，该命令位于 for 循环的末尾。注意，最后一个方法 ❾ 不在列表中。顾名思义，它是一个私有方法，只能从对象内部的方法中调用。如果一个调用的
    bat 文件尝试调用任何不在列表中的其他方法，或者是一些根本不是方法的文本，代码将输出一个中止消息 ❹ 并在暂停后退出整个进程。（更强大的错误处理会更好，但这足以作为演示。）
- en: Constructor
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数
- en: When coding in a language with object-oriented guardrails, the act of instantiating
    an object automatically calls the constructor method belonging to the class. In
    fact, it isn’t even possible to call the other public methods until you’ve invoked
    the constructor. The constructor might set some variables or open a file or two,
    but its general purpose is to set up the object so you can use it going forward.
    This model mimics this behavior with the :Constructor method ❺ near the top of
    every Batch object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在有面向对象约束的编程语言中，实例化一个对象时会自动调用该类所属的构造方法。事实上，甚至在调用构造方法之前，无法调用其他公共方法。构造方法可能会设置一些变量或打开一些文件，但其一般目的是设置对象，以便你可以在后续使用它。这个模型通过每个批处理对象顶部的
    :Constructor 方法❺模拟了这一行为。
- en: This constructor method of the parent object simply sets two variables to defaults
    so that the majority of the individual movie objects won’t have to set them. The
    vast majority of movies released in the past several decades were shot in color
    and on 35-millimeter gauge film. This particular constructor accepts only one
    parameter, the movie title, so for one film in particular, the two set commands
    assign the values of 35mm and color to the variables defined as gauge{The Big
    Lebowski} and clrOrBW{The Big Lebowski}, respectively. The variable names have
    spaces, and if that’s a problem for any reason, you can remove them with the replacement
    syntax, as long as you do so consistently.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个父对象的构造方法只是将两个变量设置为默认值，这样大多数单独的电影对象就不需要再次设置它们。过去几十年发布的大多数电影都是彩色拍摄并使用35毫米胶片拍摄的。这个构造方法只接受一个参数，即电影标题，所以对于一部特定的电影，两个设置命令分别将
    35mm 和 color 的值赋给分别定义为 gauge{The Big Lebowski} 和 clrOrBW{The Big Lebowski} 的变量。这些变量名有空格，如果因为某些原因这造成了问题，你可以使用替换语法去掉空格，只要这样做时保持一致。
- en: We’ll also want variables for the plot, year of release, and other characteristics,
    but these clearly don’t have defaults, so we’ll set them elsewhere. However, you’ll
    soon see how the object for a 70-millimeter black-and-white film will be able
    to override these default values set in the parent object constructor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为情节、上映年份以及其他特性设置变量，但这些显然没有默认值，因此我们会在其他地方设置它们。不过，你很快会看到，70毫米黑白电影的对象将能够覆盖在父对象构造方法中设置的默认值。
- en: Setters and Getters
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置器和获取器
- en: In strict object-oriented coding, classes typically have many setter and getter
    methods; that is, for each defined data item one method sets and another method
    gets its value. For instance, there might be a pair of methods to get and set
    the gauge and another pair for the plot, and so on. But due to delayed expansion
    and Batch’s lack of defined data types, we can consolidate all of the setter methods
    into a single :Set method ❻, and we can handle all of the getter methods with
    a solitary :Get method ❼.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格的面向对象编程中，类通常会有许多 setter 和 getter 方法；也就是说，对于每个定义的数据项，一个方法设置它，另一个方法获取它的值。例如，可能会有一对方法用于获取和设置计量仪表，还有一对方法用于情节，等等。但由于延迟扩展和批处理缺乏定义的数据类型，我们可以将所有的
    setter 方法合并成一个单一的 :Set 方法❻，并且我们可以通过一个单独的 :Get 方法❼来处理所有的 getter 方法。
- en: 'The :Set method has a single line of interesting code that a calling bat file
    can use to set any variable for the object. It’s a set command using three parameters:
    the characteristic being set is %~1, the value being assigned is %~2, and the
    movie title is %~3. The variable name being set is a combination of the first
    and last parameters: %~1{%~3}.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: :Set 方法包含一行有趣的代码，调用的批处理文件可以用来为对象设置任何变量。这是一个使用三个参数的设置命令：被设置的特性是 %~1，赋值的内容是 %~2，而电影标题是
    %~3。要设置的变量名是第一个和最后一个参数的组合：%~1{%~3}。
- en: 'To demonstrate how this works, you can invoke the :Set method with the following
    call command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个是如何工作的，你可以通过以下调用命令来调用 :Set 方法：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of this call sets the value of the plot in the second argument to
    the plot{Groundhog Day} variable, but notice that there’s no explicit call to
    the :Set method to be found in this bat file. I’ll eventually show how to make
    this call from outside of this parent bat file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次调用的结果将把第二个参数中的情节值设置为 plot{Groundhog Day} 变量，但注意在这个批处理文件中并没有显式地调用 :Set 方法。我稍后会展示如何从这个父级批处理文件外部进行此调用。
- en: 'The :Get method flips the assignment around, returning the value in lieu of
    assigning it. The parameters for the setter and getter methods are the same with
    the notable exception that the second one for the getter is the name of the variable
    to which we assign the plot, instead of the plot itself. Conveniently, resolving
    the other two parameters inside of exclamation marks extracts the value of the
    plot as part of the assignment: !%~1{%~3}!.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one possible invocation of the method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This returns the plotVar variable set to the value A day repeats ad infinitum
    or the same string we passed to the :Set method earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to miss how sublime this really is. Yet again, delayed expansion offers
    us a useful and elegant solution not available in most languages. Astonishingly,
    an object with dozens of variables needs only one setter and one getter method.
    In at least one small facet, Batch offers a better solution than traditional object-oriented
    languages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: App-Specific Public Methods
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In traditional OOP, constructors are a must, and setters and getters are ubiquitous,
    but there are usually other public methods specific to an application, and I’ve
    included one example of just such a method in the *oMovie.bat* object. The :DispInfo
    method ❽ displays detailed information about a film to the console. A series of
    echo commands in the method write the movie title and several other pieces of
    data to the console. For instance, its first line mentions the movie itself and
    details the year of release, whether it’s color or black and white, and the gauge.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: These last two variables are set in the constructor, but the variable for the
    year and others aren’t. In fact, their only mention in the parent bat file is
    here. (I’ll share their origins before long, but it has something to do with inheritance.)
    Regardless of where this data comes from, this one method displays information
    for any movie object that is derived directly or indirectly from this object.
    That’s polymorphism.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If variables such as plot{Groundhog Day} remind you of hash table elements,
    that’s because they are in fact elements of hash tables ([Chapter 29](chapter29.xhtml)).
    You don’t need to understand the data structure to understand this model, but
    after executing the logic to build 17 plots for 17 different movies, the plot
    hash table contains 17 elements.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The Intermediate Object
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this model, the genre objects are all intermediate objects, with the *oComedy.bat*
    object being one example. It’s a child of *oMovie.bat*, but it also has children
    of its own, two of which are shown in [Figure 32-1](#fig32-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 32-2](#Lis32-2) shows the complete bat file object for *oComedy.bat*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 32-2: The intermediate object, oComedy.bat'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, this looks to be structured much like the parent object, but there
    are differences. The very first line defines another bat file, and immediately
    after the traffic cop is a call command instead of an abort. The constructor also
    calls another bat file, and the setter and getter methods are missing along with
    the method to display information about a movie.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict object-oriented languages have reserved words and syntax allowing one
    object to seamlessly inherit from another. Not to be confused with Batch, this
    is how a child class would use the extends keyword to inherit from a parent in
    Java:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Batch, without similar built-in syntax, we do it quite differently. The first
    statement in the *oComedy.bat* object defines the parent object bat file from
    which it inherits, namely, *oMovie.bat* ❶, which is also the object it extends.
    Then the traffic cop, looking much like the one in the parent object, has its
    own list of public methods maintained in the for command ❷. If the first parameter
    matches either of the two public methods in the list, the call command invokes
    it ❸. But where the parent class aborts when the method to be invoked isn’t public,
    the child object instead calls the parent class defined by extends, passing the
    same arguments along ❹. That’s inheritance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: An intermediate (and child) object can define its own methods not already in
    the parent object. It can also inherit the methods from the parent object by doing
    nothing more than what I’ve already shown. If the first parameter isn’t in the
    list of public methods, this bat file becomes a simple pass-through as it makes
    the identical call to the parent object ❹. The %* syntax ensures that the same
    parameter list received by this bat is the argument list passed to the parent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We’ll soon be able to call the important methods in the parent object (:DispInfo,
    :Set, and :Get) with the Batch inheritance just described. Elegantly, all of the
    genre objects and their children can easily use these methods. Not only does the
    intermediate object not have to reproduce them, but it doesn’t even need to mention
    them. And what happens when someone errantly passes this object a method not made
    public here or by its parent? The intermediate object passes it along, and the
    parent performs the error handling for all its children in one place.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: This object does more than inherit methods from the parent. The constructor
    offers an example of *extending* a method already defined in the parent object.
    There is a :Constructor method in the parent, but the inheritance set up with
    the traffic cop doesn’t call it. Instead, the intermediate object’s :Constructor
    method ❺ supersedes it, but this doesn’t mean that we never invoke the parent
    constructor logic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The very first line of the :Constructor method calls the parent object to invoke
    its method of the same name, that is, its constructor. This is another built-in
    feature of traditional object-oriented languages that we must mimic. After calling
    the parent’s constructor, the derived object’s constructor puts its own spin on
    the data. Remember that the *oMovie.bat* object defined the movie as color and
    35mm in its constructor. Here the *oComedy.bat* object accepts those two values
    and also defines the genre as Comedy ❻. As we’ll soon see, its child objects will
    extend this even further.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: :Constructor方法的第一行调用父对象以调用其同名的方法，即构造函数。这是传统面向对象语言的另一个内置特性，我们必须模仿。在调用父类构造函数之后，派生对象的构造函数对数据进行处理。记住，*oMovie.bat*对象在其构造函数中将电影定义为色彩和35mm格式。这里，*oComedy.bat*对象接受这两个值，并将类型定义为喜剧❻。正如我们将很快看到的，它的子对象将进一步扩展这一点。
- en: Finally, notice two aptly named methods, one public ❼ and one private ❾. The
    private method isn’t listed in the traffic cop, so we can invoke it explicitly
    only from somewhere inside this bat file, such as from inside the public method
    ❽.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意两个恰如其名的方法，一个是公共的❼，另一个是私有的❾。私有方法没有列出在交通警察中，因此我们只能在此bat文件内部的某个地方显式调用它，例如从公共方法❽内部。
- en: The Child Objects
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子对象
- en: Finally, we come to the objects for the individual movies. [Listing 32-3](#Lis32-3)
    is the entire bat file for one movie object, *oBigLebowski.bat*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了每部电影的对象。[清单32-3](#Lis32-3)是一个电影对象的完整bat文件，*oBigLebowski.bat*。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 32-3: The child object, oBigLebowski.bat'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单32-3：子对象，oBigLebowski.bat
- en: The traffic cop ❸ at the top of this child object looks much like the one from
    the intermediate object, but it now extends the *oComedy.bat* object ❶, and the
    new title variable ❷ defines the movie. We’re passing the title to its parent
    object as the final argument ❹, where it’s used to set variables such as gauge{The
    Big Lebowski} in *oMovie.bat* and genre{The Big Lebowski} in *oComedy.bat*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子对象中的交通警察❸看起来很像中间对象中的交通警察，但它现在扩展了*oComedy.bat*对象❶，并且新的标题变量❷定义了电影。我们将标题作为最终参数❹传递给其父对象，在那里它被用来设置变量，例如在*oMovie.bat*中的gauge{The
    Big Lebowski}和在*oComedy.bat*中的genre{The Big Lebowski}。
- en: This child object has only one public method and no private methods, but it
    could easily have multiples of either type. (Since there’s only one entry in the
    list of public methods, we could remove the for command and leave just an if command.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子对象只有一个公共方法，没有私有方法，但它可以很容易地有多个任何类型的方法。（由于公共方法列表中只有一个条目，我们可以去掉for命令，只保留if命令。）
- en: The :Constructor method ❺ is even more interesting than the constructor in the
    intermediate object. It first calls the constructor of its parent, *oComedy.bat*
    ❻, and we’ve already seen that the constructor in the intermediate object will
    in turn call the constructor of its parent, *oMovie.bat*. Both parents set a variable
    or two before returning control to the constructor of the individual movie object
    where it sets everything that’s particular to its actual movie, such as the plot,
    star, and cast ❼.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: :Constructor方法❺比中间对象中的构造函数更有趣。它首先调用其父类的构造函数，即*oComedy.bat*❻，而我们已经看到中间对象中的构造函数将依次调用其父类的构造函数，即*oMovie.bat*。两个父类在返回控制权给单个电影对象的构造函数之前，都会设置一个或两个变量，在该构造函数中，设置与实际电影相关的所有内容，例如剧情、明星和演员阵容❼。
- en: We can now set up similar object bat files for other movies. Notice the differences
    and similarities between the previous object and the following object, *oLifeOfBrian.bat*,
    which contains data and a constructor method for another great film in [Listing
    32-4](#Lis32-4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为其他电影设置类似的对象bat文件。请注意之前的对象与以下对象之间的异同，*oLifeOfBrian.bat*，它包含了另一部伟大电影的数据和构造方法，见[清单32-4](#Lis32-4)。
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 32-4: The child object, oLifeOfBrian.bat'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单32-4：子对象，oLifeOfBrian.bat
- en: Both constructors are setting the plot, star, members of the cast, language,
    year of release, and country, but this one is also setting troupe{%title%} ❶.
    *The Life of Brian* was created by a comedy troupe, but this variable doesn’t
    apply to most other comedies. Each constructor is unique to a particular move
    and bat file; while it should define a certain set of variables in this model,
    it can contain additional logic pertinent to its movie, as the object demonstrates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两个构造函数都在设置剧情、明星、演员阵容、语言、上映年份和国家，但这个还在设置troupe{%title%}❶。*The Life of Brian*是由一个喜剧团体创作的，但这个变量不适用于大多数其他喜剧。每个构造函数对于特定的电影和bat文件都是独特的；虽然它应该在这个模型中定义一组特定的变量，但它可以包含与其电影相关的额外逻辑，正如该对象所展示的。
- en: I more than hinted earlier that you can override variables defined in the parent’s
    constructor in the child, and the child’s constructor is where that happens. For
    instance, the constructor in *oRagingBull.bat* would reset the clrOrBW{Raging
    Bull} variable to Black and White. Likewise, for a movie shot in something other
    than 35mm, such as digital, we can reset the gauge in the child’s constructor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of object-oriented design is the ability of a child object to
    override methods defined in a parent class. You’ve seen methods inherited and
    extended. The constructor just discussed is a great example of extending a method.
    Now imagine that method without the call to its like-named method in its parent.
    That’s a *method override*. The child object will never call the public method
    in its parent object because the child has overridden it with a method of its
    own.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s consider one last child object with this as the title
    variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If DispInfo is in the list of public methods defined for this particular child
    object, the coder of this object could add the following method to the bat file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A comment stating that this method is an override isn’t required, but it’s good
    form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this method doesn’t invoke a corresponding method in its parent
    class. It simply writes a few lines of commentary, followed by a blank line, and
    does nothing more. It has completely superseded or overridden the like-named method
    in the parent class. Unlike other movies, this title won’t see the plot, cast,
    and other information written to the console as we’ve seen for other movies using
    the :DispInfo method in *oMovie.bat*. The author of this bat file obviously felt
    that something special was needed for the informational display for such a singular
    film. (Please, no hate mail; the original trilogy was fine, even better than fine.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Executing Object-Oriented Batch
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve created the *oMovie.bat* parent object and the *oComedy.bat* intermediate
    object that extends or inherits from the parent. In theory, we could create more
    intermediate (or genre) objects and more than two million child objects for individual
    movies, but before us we have two child object bat files representing two comedies,
    each extending the *oComedy.bat* object. Finally, we can execute this object-oriented
    code. If nothing else, you can use the *Test.bat* file mentioned in [Chapter 31](chapter31.xhtml),
    but you need to place all calls to this code into a bat file not already in the
    model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementing code calls only the child objects; the parent and intermediate
    objects are called only from their children. Let’s start with these four commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that you must call the constructor before you can call any other method
    in an object. These first two commands are the Batch equivalent of instantiating
    objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We first call *oBigLebowski.bat*, and its traffic cop invokes its :Constructor
    method; as we’ve already seen, that constructor invokes the constructor method
    in its parent object, *oComedy.bat*, which invokes the corresponding method in
    its parent, *oMovie.bat*. Each of the three bat files contributes to the creation
    of the nine variables that describe this movie. Immediately after that, we do
    the same with *oLifeOfBrian.bat* to create a second set of movie variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The constructors don’t generate any output, but the last two call commands display
    the information shown in [Listing 32-5](#Lis32-5) to the console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 32-5: Output from two DispInfo calls using two different child objects'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The third command calls *oBigLebowski.bat*, passing DispInfo as its only argument.
    This child object doesn’t find a public method named :DispInfo, so the inheritance
    kicks in with a call to its parent, *oComedy.bat*, where the method also doesn’t
    exist. Once again because of inheritance, we call the base object, *oMovie.bat*,
    where we finally find and execute the public method. It displays a concise summary
    of information about *The Big Lebowski* to the console in seven lines of text.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The final command also shares a wealth of information, but about a different
    movie, because it calls the *oLifeOfBrian.bat* object. We are ultimately invoking
    the exact same method, :DispInfo, in the exact same object, *oMovie.bat*, but
    notice the stark differences in the output. The output describes two entirely
    different movies. That’s polymorphism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch has one critical and fairly unique characteristic that lends itself to
    the implementation of polymorphism: delayed expansion. Resolving variables is
    straightforward in most coding languages, but Batch allows you to resolve one
    or more variables to create a variable name that can then itself be resolved.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Both sets of output come from the :DispInfo method in the parent object *oMovie.bat*
    ([Listing 32-1](#Lis32-1)). Taking just one variable as an example, delayed expansion
    first resolves the parameter embedded in !plot{%~1}! to be the movie title. In
    our first call, this results in !plot{The Big Lebowski}!, which then resolves
    to the plot of that movie. The second time through, this exact same code results
    in !plot{The Life of Brian}!, which resolves to a very different plot. This is
    Batch polymorphism at its finest.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Whoever wrote the *oBigLebowski.bat* object left an Academy Award–winning actor
    off the cast list. The late Philip Seymour Hoffman had a relatively small role
    as the title character’s smug toady of a personal assistant, Brandt, but he played
    it with a brilliance and nuance that foretold greater roles. The following two
    commands add him to the current cast:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument of both call commands is the name of the method to be invoked,
    and the second argument is the type of variable pertinent to the call, which is
    cast in both instances. The first command will Get the current cast members, returning
    the value as the contents of the lebowCast variable. The second command will Set
    (or reset) the list of current cast members to the just-returned value concatenated
    with Mr. Hoffman’s full name. If you were to invoke the *oBigLebowski.bat* object
    again with the DispInfo argument, you’d see all four actors included in the cast
    as opposed to the three in [Listing 32-5](#Lis32-5).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep this complex example as comprehendible as possible, I’ve resisted the
    mention of some possible tweaks, up until now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: I shared that strict OOP dictates that you must invoke the constructor before
    you can use an object. This model leaves that restriction to the honor system,
    but you can remedy the issue with an “instantiated” switch. First, the child constructor
    would set the switch when it executes. Then you could interrogate that switch
    before any attempt to invoke a public method, throwing an abort if it hasn’t yet
    been set. This is almost certainly overkill, but it wouldn’t be difficult (or
    elegant). I prefer the honor system here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: I never used the comedy troupe variable set for the Monty Python film, but you
    can define a :DispInfo method in the *oLifeOfBrian.bat* object to extend the like-name
    method from *oMovie.bat*. After the child calls to inherit the display performed
    by its parent (or parent’s parent), it can append a similar line for the troupe.
    Even better yet, since a troupe applies only to some comedies, the new method
    could go into the *oComedy.bat* object, where you’d display the troupe only if
    it exists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The most significant element of OOP that we haven’t successfully duplicated
    in Batch is data hiding. When a variable is set, it’s available in the environment
    until it’s reassigned or the process ceases, and there’s no realistic means of
    preventing its reassignment by some other code. We can use the setlocal and endlocal
    commands to hide variables, but after the execution of the endlocal command, the
    variables will be lost into the ether. As I mentioned in [Chapter 16](chapter16.xhtml),
    variables can survive an endlocal command, but doing so would make them available
    globally, and that doesn’t lend itself to “data hiding.” We could hide the variables
    in a temporary file and restore them the next time through the code, but this
    most definitely is overkill.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Not being able to declare private variables is a limitation that precludes the
    ability to make a Batch object available to a great number of users, as is the
    case with other languages. But let’s take a step back to gain some perspective.
    Making an object generally available for the masses is not part of the design
    I’m positing; this is Batch, and there’s no realistic infrastructure for something
    on that type of scale anyway.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: I’m suggesting the building of objects for use by oneself and maybe a small
    group of friends or co-workers working on the same network. This isn’t something
    you’d want to make callable from a web service. Thus, the only real ramification
    of not being able to hide data is that a small cohort of coders must be aware
    that they shouldn’t step on the variables used in certain objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Batch object-oriented design is a methodology that I highly recommend. You might
    not implement it as extensively as in the model that I’ve presented here, nor
    should you. (More on this in the next and final chapter.) Even just portions of
    this methodology may very well be useful to you. Even without the use of inheritance,
    you can write a module with polymorphic code that behaves differently based on
    the caller. A simplified version of inheritance might rely on one central bat
    file for a few important tasks. Just writing small and reusable modules is redolent
    of object-oriented design and is an enormous step forward.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The Four Pillars in Batch
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve already seen that in this Batch model we’ve been able to simulate many
    of the characteristics of OOP surprisingly well. Let’s step through each of the
    four pillars one more time, detailing how close we’ve actually come to our goal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction, the first pillar, simplifies the code’s interface, shows only the
    necessary or relevant features, and shields implementation details. Take another
    look at the two complete child objects in Listings 32-3 and 32-4\. The methods
    to get and set variables, along with the method to display movie information,
    have all been abstracted away. Other than the logic at the top of each object
    listing public methods and handling the inheritance, there’s really just a single
    method, the constructor, and everything in it is pertinent to the object. Abstraction
    in Batch object-oriented design gets high marks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Smaller, more plentiful modules present a superior design regardless of the
    language or coding methodology. Each file has a distinct purpose, and the code
    is more maintainable and extensible. The model I’ve shown in this chapter lends
    itself to writing short, compact, and reusable code modules, and this is one of
    three components that define the second pillar, encapsulation, along with data
    and method hiding. Method hiding is trivial in Batch; in fact, we had to do some
    work to expose public methods. Data hiding, however, isn’t supported at all in
    this model. All of the variables set for all of the different movies float around
    the environment for anyone to modify at any time. Two out of three is a passing
    grade.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Examples of inheritance, the third pillar, are strewn throughout the previous
    pages. Child objects are inheriting constructors from intermediate objects, which
    in turn inherit the same from parent objects. The method for displaying information
    to the console and the setter and getter methods are all quality examples of inheritance.
    We coded them once in the parent object for use by up to two million child objects.
    I’ve even demonstrated how to override a method in a child object. We need a bit
    of redundant code at the top of each bat file to make this work, but this model
    clearly scores near the top of its class when it comes to inheritance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The fourth pillar, polymorphism, allows code to behave differently in different
    situations, with the method displaying movie information being a prime example
    of this functionality. We use a single method in a single bat file to write the
    unique information for a couple million movies—and two of those variables displayed
    were originally set in the parent object’s polymorphic constructor. The setter
    and getter method take this a step further. Traditional OOP requires a pair of
    these methods for each and every defined variable. In this model, a single setter
    and a single getter handle all variables for each and every individual movie object.
    Batch polymorphism is what many students call a *curve buster*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave it to you, the reader, to give this model a final grade. I’ll concede
    that due to the lack of data hiding, the mark of an A is out of reach, but I hope
    not too far out of reach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Was Batch designed as an object-oriented language? Not a chance. Is it possible
    to build much of object-oriented design—that is, abstraction, encapsulation, inheritance,
    and polymorphism—in bat files? Absolutely. Can Batch object-oriented design achieve
    the efficiency and scale of other languages? No. After reading this chapter, how
    many Batch coders will propose an enterprise-wide object-oriented project to their
    employer? Not many. If that number is greater than zero, how many will still be
    employed in three months? Most assuredly none. How many coders will try to incorporate
    elements of Batch object-oriented design into their code? Hard to say, but I’m
    hoping for quite a few.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-oriented design is this book’s dénouement, so why is this merely the
    penultimate chapter of the book? In the next and final chapter, I’ll introduce
    two data structures: stacks and queues. But I’ll also use these data structures
    as an opportunity to further demonstrate object-oriented design, because this
    discussion is far from complete. The model I’ve detailed in this chapter implements
    every possible object-oriented design principle, but it isn’t how I usually code
    Batch objects. It’s better to use only what’s needed and not what isn’t. When
    building stacks and queues in the next chapter, you’ll see real-world objects
    for each, and I’ll also share some final thoughts about Batch object-oriented
    design.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
