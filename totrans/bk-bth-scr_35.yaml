- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 32 OBJECT-ORIENTED DESIGN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In preceding chapters, I’ve explored many topics that aren’t typically associated
    with Batch from booleans to hash tables, with many others in between. In this
    chapter, I’ll tackle the holy grail of Batch user-built tools: object-oriented
    design.'
  prefs: []
  type: TYPE_NORMAL
- en: After explaining the difference between procedural and object-oriented coding,
    I’ll lay out the four pillars of object-oriented programming. Then I’ll present
    a fully functional model of Batch object-oriented design, complete with bat files
    representing parent, intermediate, and child objects. After you’ve learned how
    to invoke the object-oriented code, I’ll share many recommendations and analyze
    how well this model satisfies the basic tenets of object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural vs. Object-Oriented Coding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the very early days of computers, all coding was *procedural*—that is, all
    programs consisted of a series of computational steps. The methodology is still
    very much in existence with possibly more than a trillion lines of such code still
    in use and many more written every day. By default, variables are accessed globally
    in procedural code. Sometimes many hundreds of variables are defined in a section
    near the beginning of a program, and at other times, such as in Batch, they come
    into being when first referenced. Even when an internal routine or procedure is
    invoked, the set of active and available variables doesn’t change. Certain measures
    can often be invoked to limit scope, such as the setlocal discussed in [Chapter
    3](chapter3.xhtml), but in procedural coding, a variable typically can be set
    or reset anywhere in what is often a very large program file.
  prefs: []
  type: TYPE_NORMAL
- en: Before long, some smart people came up with the concept of *object-oriented
    programming (OOP)*, where the code is broken into small, easy-to-manage *objects*,
    each containing data in the form of variables and executable code in the form
    of methods. A *method* is similar to an internal routine in Batch; it can be invoked,
    and when it completes its execution, control is returned to the point of the call,
    but a method can also be called externally; that is, code inside another program
    file can call the method directly. Regardless of the source of the call, the method
    accepts well-defined inputs and returns equally well-defined outputs. However,
    most of the data inside a method is typically inaccessible from elsewhere in the
    program file and especially from other program files.
  prefs: []
  type: TYPE_NORMAL
- en: The compartmentalization of the code into individual objects streamlines the
    logic and guards against the unintended consequence of some portion of the code
    adversely affecting another portion. Additionally, if one of these objects is
    of use in a different context, it can easily be used by both processes without
    modification or duplication. An equivalently useful portion of a procedural program
    might end up being copied and pasted into another program.
  prefs: []
  type: TYPE_NORMAL
- en: If I were to construct a list of great personal irritants—and for the sake of
    brevity, I’ll limit this to work/coding-related peeves—atop my jeremiad is procedural
    code disguised as object-oriented code. Certain languages and frameworks are designed
    to support each coding paradigm. Java and C# are object-oriented languages; COBOL
    and Batch are procedural languages. But contrary to what many believe, it isn’t
    that simple; procedural code can easily be written in Java, and with some work,
    object-oriented principles can be implemented in Batch.
  prefs: []
  type: TYPE_NORMAL
- en: The Four Pillars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any coding language that purports to be object-oriented must fully support the
    four pillars of object-oriented programming. Languages considered to be object-oriented
    implement these in different ways, but they all have built-in mechanisms to guide
    the coder into writing code with these four characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The first pillar is *abstraction*, which simplifies the code’s interface with
    the outside world. It shows only the necessary or relevant features to the user,
    while shielding the implementation details and any information irrelevant to the
    functionality’s use.
  prefs: []
  type: TYPE_NORMAL
- en: This segues into the second pillar, *encapsulation*, which restricts access
    to certain methods and variables in an object, wrapping up data and code into
    multiple small units. Data hiding, or treating some variables and methods as private,
    is a significant part of this pillar. Another significant part is simply the act
    of creating compact, readable, and reusable modules.
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance*, the third pillar, allows for the creation of a base or parent
    object. Then derived objects can use the parent object while extending it to fit
    the more specific needs of the child. The classic example is a base or parent
    object of an Animal, defining all that is common throughout the animal kingdom.
    Then intermediate objects defined as Reptile and Mammal can inherit data and routines
    from the Animal object and add to it information about their respective zoological
    classes. Then objects of Cat, Rat, and even Bat can inherit from the Mammal object,
    which is already inheriting from the Animal object. More than 1,000 child objects,
    one for each bat species on the planet, can then inherit from the Bat object.
    Finally, each of the inheriting objects can use the data and code in its parent
    objects for its own use.'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth pillar, *polymorphism*, which means the condition of occurring in
    several different forms, derives literally from the Greek words meaning *many
    forms*. This allows a call to a routine to behave differently in different situations.
    Reusable code is always awesome, but this pillar takes the concept of reuse to
    its zenith. A method in the parent object might be invoked by multiple child objects,
    where each invocation is unique to the child.
  prefs: []
  type: TYPE_NORMAL
- en: In the pages ahead, I’ll attempt to mimic these four pillars of abstraction,
    encapsulation, inheritance, and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Batch Object-Oriented Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter is about Batch object-oriented design and not Batch object-oriented
    programming for two reasons. First, and more trivially, BOOP is a horrible acronym,
    reminiscent of the noise one might make when affectionately poking a baby’s nose.
    BOOD isn’t much better, but I do have a Brilliant Acronym Team (or BAT) diligently
    working on something batter ... sorry, something better.
  prefs: []
  type: TYPE_NORMAL
- en: Far more important, Batch has none of the built-in features that are intrinsic
    to more modern languages that implement object-oriented programming. I’ll demonstrate
    how to mimic each of its four pillars, and the level of success in creating object-oriented
    bat files may very well surprise many, but I’ll craft some of its functionality
    more completely than other functionality. True object-oriented programming won’t
    be possible in Batch, but I encourage you to incorporate these design elements,
    in whole or in part, in the design of your Batch code.
  prefs: []
  type: TYPE_NORMAL
- en: In Batch, a variable cannot be defined as public or private; in fact, variables
    can’t be defined at all. There is no keyword to invoke inheritance found in other
    languages, such as “extends” or “implements.” In OOP, a child object can override
    methods in the parent object; you’ll soon see how to perform many of these tasks
    in Batch, but they won’t be done automatically. Remember that this is a language
    without booleans, floats, the while and do...while commands, the and and or operators,
    arrays, and hash tables. I’ve demonstrated how to build all of those things with
    the tools at hand (and I’ll do the same with stacks and queues in [Chapter 33](chapter33.xhtml)),
    so it should be of little surprise that Batch has nothing off the shelf for anything
    like object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: However, object-oriented principles can be used, and should be used, regardless
    of the provided toolkit. Someone coding in an “object-oriented language” can easily
    define excessive class-level variables, make all data items public, and put the
    lion’s share of the code into a “god object” (a single object that does too much
    and is too big to be managed efficiently). But regardless of the coding language,
    this design with large modules and excessive global variables is essentially procedural
    coding. More modern languages have object-oriented guardrails, but guardrails
    can be breached.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, there’s an expectation among many that Batch coders should create
    only large uninteresting modules. But while Batch procedural code is the standard,
    there’s no Batch police requiring it. When object-oriented programming or design
    is thought of as a technique and not as a characteristic associated with only
    some languages, scales will fall from your eyes as if on the road to Damascus.
    Batch doesn’t possess the sturdy guardrails offered elsewhere, but you can craft
    object-oriented techniques using any coding language, just as it’s more than possible
    to reach the summit driving up a mountain road with shear drops. The infrastructure
    or plumbing might not exist in Batch and not everything will be possible, but
    the elegance of object-oriented design in Batch offers the same benefits realized
    in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the differences between OOP and Batch object-oriented design is that
    traditionally each module or file is defined as a *class*, and an *object* is
    an instantiation of that class. Instantiating an object is much like defining
    a variable. Just as a variable can be defined as a string or as an integer in
    many languages, an object is instantiated to be one specific instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, imagine again a class defined as *Bat*, representing all flying
    nocturnal mammals, where each species of bat would have its own class inheriting
    from *Bat*. One such species is the Madagascan fruit bat, and its class might
    be defined as a *MadFruitBat*. This class represents all bats of this one species,
    and it can be instantiated many times, each time representing one specific creature.
    A cave containing 500 Madagascan fruit bats could be populated with 500 objects,
    each one an instantiation of the *MadFruitBat* class individually named for a
    particular bat.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Batch has its first object-oriented limitation. Remember that
    this is a language without the ability to define variables as strings and integers.
    Obviously then, a variable can’t be defined or instantiated as a data type corresponding
    to a class module. In Batch, the distinction between classes and objects doesn’t
    exist. A module or bat file is itself an object. It doesn’t have to be instantiated,
    nor can it be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the word *class* isn’t part of the Batch object-oriented design
    vernacular. I’ll soon share bat files that are fully constituted objects, each
    one ready to be invoked, and I’ll be referring to them as *objects*. The Madagascan
    fruit bat defined as the *MadFruitBat* class in OOP would be the *MadFruitBat.bat*
    object bat file in Batch. To implement the 500 individual Madagascan fruit bats,
    you would need to create a small bat file for each, and each would inherit from
    *MadFruitBat.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, *oMadFruitBat.bat* is a better name for the object bat file. To distinguish
    an object bat file from its more pedestrian brethren, I always prepend its name
    with a lowercase *o* as a visual cue. The *obj* text also works.
  prefs: []
  type: TYPE_NORMAL
- en: Batch Object-Oriented Design Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way of describing object-oriented design is with an example or model.
    I’ll lay out here the broad strokes of the example of Batch object-oriented design
    that I present in this chapter. Then I’ll show the parent object with examples
    of intermediate and child objects, all the while explaining the object-oriented
    concepts implemented in each module. In the next section, “Executing Object-Oriented
    Batch,” I’ll discuss exactly how to invoke this model, and in a later section,
    “The Four Pillars in Batch,” I’ll explore how closely this model mimics each of
    the central concepts of object-oriented principles.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the pyramid is the base or parent object. Other objects inherit
    from it, but it’s the one object in this model that doesn’t inherit from another
    object. Beneath the parent are the intermediate objects that inherit directly
    from the parent object. Other intermediate objects can inherit from the first
    level of intermediate objects, culminating in child objects at the bottom of the
    pyramid. Intermediate and child objects are both called *derived objects* because
    they inherit or are derived from another object. (Technically, an intermediate
    object is also a child object because it is a child of another object, but I use
    the term *child* for what might more accurately be called a “childless child object.”)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter’s Batch object-oriented design model, Movie is the parent object
    to dozens of different film genre objects, such as SciFi, RomCom, and Action,
    although only two are shown: Comedy and Drama. Individual movies are their own
    specific object, each one inheriting from a particular genre object. More than
    two million movies have been released, but I’m showing only three here, two of
    which are the greatest movies ever released, and *The Godfather* is a great film
    as well. The objects that I’ll present in this chapter, I’ve marked with an asterisk
    in [Figure 32-1](#fig32-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig32-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 32-1: Parent, intermediate, and child objects'
  prefs: []
  type: TYPE_NORMAL
- en: The Movie object contains data and methods that are common to all movies, or
    are at least the defaults for all movies. (Echoing the parlance of OOP, I’ll use
    the term *method* in place of *routine* from this point forward.) The Comedy and
    Drama objects each inherit from the Movie object and extend it, defining data
    and methods particular to each genre. The individual movie objects inherit from
    the genre objects, and thus indirectly from the Movie object, and contain detailed
    data about their specific flick. (Each arrow extends from the derived object to
    its parent object.)
  prefs: []
  type: TYPE_NORMAL
- en: But this isn’t a rigid hierarchy. A movie franchise object such as StarTrek
    could inherit from the SciFi genre object (neither is shown), and the individual
    *Star Trek* movies could be child objects of the movie franchise object.
  prefs: []
  type: TYPE_NORMAL
- en: More important, all objects are bat files. The Movie object in its most concrete
    form is the *oMovie.bat* bat file, and the Comedy object is the *oComedy.bat*
    bat file. Likewise, one of the child objects will be *oBigLebowski.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: Some object-oriented languages offer multiple inheritance; that is, a derived
    object can inherit from two or more different objects. For instance, the Dramedy
    object might inherit from both the Comedy and Drama objects. While that is theoretically
    possible even in Batch, I’m restricting this model to single inheritance, so the
    Dramedy object is just another genre object inheriting from the Movie object,
    and individual dramedies will then inherit from the Dramedy object.
  prefs: []
  type: TYPE_NORMAL
- en: The Parent Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once all of this makes sense conceptually, you’ll want to see everything in
    action. Starting with the base or parent object, [Listing 32-1](#Lis32-1) shows
    the contents of *oMovie.bat*. Note that this and the other object bat file don’t
    start with a setlocal command because they’ll always be called from other bat
    files that contain the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 32-1: The base or parent object, oMovie.bat'
  prefs: []
  type: TYPE_NORMAL
- en: There are many interesting pieces of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding Methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Encapsulation, one of OOP’s pillars, includes the hiding of methods. By default,
    all methods of a bat file are hidden because there’s no built-in means of creating
    multiple entry points into a bat file; when a bat file executes, it starts at
    the top every time. Hence, the task here isn’t to hide certain methods but to
    make certain methods publicly accessible, while leaving the others hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'The for command ❶ acts as a “traffic cop”; it contains a list of the bat file’s
    public methods as its input: Constructor, DispInfo, Set, and Get. The if command
    inside its code block compares the first parameter received, meth, to this list.
    If it matches one of the methods listed, the parameter, prepended with a colon,
    becomes the argument of the call command ❷, and we pass the remaining parameters
    as additional arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon its completion of the called method, control immediately returns to the
    calling bat file via the goto :eof command ❸ at the end of the for loop. Notice
    that the last method ❾ isn’t on the list. As its name suggests, it’s a private
    method, callable exclusively from methods inside the object. If a calling bat
    file tries to invoke any other method not on the list or some text that isn’t
    even a method, the code writes out an abort message ❹ and exits the entire process
    after a pause. (More robust error handling would be preferrable, but this works
    as a demonstration.)
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When coding in a language with object-oriented guardrails, the act of instantiating
    an object automatically calls the constructor method belonging to the class. In
    fact, it isn’t even possible to call the other public methods until you’ve invoked
    the constructor. The constructor might set some variables or open a file or two,
    but its general purpose is to set up the object so you can use it going forward.
    This model mimics this behavior with the :Constructor method ❺ near the top of
    every Batch object.
  prefs: []
  type: TYPE_NORMAL
- en: This constructor method of the parent object simply sets two variables to defaults
    so that the majority of the individual movie objects won’t have to set them. The
    vast majority of movies released in the past several decades were shot in color
    and on 35-millimeter gauge film. This particular constructor accepts only one
    parameter, the movie title, so for one film in particular, the two set commands
    assign the values of 35mm and color to the variables defined as gauge{The Big
    Lebowski} and clrOrBW{The Big Lebowski}, respectively. The variable names have
    spaces, and if that’s a problem for any reason, you can remove them with the replacement
    syntax, as long as you do so consistently.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also want variables for the plot, year of release, and other characteristics,
    but these clearly don’t have defaults, so we’ll set them elsewhere. However, you’ll
    soon see how the object for a 70-millimeter black-and-white film will be able
    to override these default values set in the parent object constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Setters and Getters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In strict object-oriented coding, classes typically have many setter and getter
    methods; that is, for each defined data item one method sets and another method
    gets its value. For instance, there might be a pair of methods to get and set
    the gauge and another pair for the plot, and so on. But due to delayed expansion
    and Batch’s lack of defined data types, we can consolidate all of the setter methods
    into a single :Set method ❻, and we can handle all of the getter methods with
    a solitary :Get method ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'The :Set method has a single line of interesting code that a calling bat file
    can use to set any variable for the object. It’s a set command using three parameters:
    the characteristic being set is %~1, the value being assigned is %~2, and the
    movie title is %~3. The variable name being set is a combination of the first
    and last parameters: %~1{%~3}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this works, you can invoke the :Set method with the following
    call command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result of this call sets the value of the plot in the second argument to
    the plot{Groundhog Day} variable, but notice that there’s no explicit call to
    the :Set method to be found in this bat file. I’ll eventually show how to make
    this call from outside of this parent bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The :Get method flips the assignment around, returning the value in lieu of
    assigning it. The parameters for the setter and getter methods are the same with
    the notable exception that the second one for the getter is the name of the variable
    to which we assign the plot, instead of the plot itself. Conveniently, resolving
    the other two parameters inside of exclamation marks extracts the value of the
    plot as part of the assignment: !%~1{%~3}!.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one possible invocation of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This returns the plotVar variable set to the value A day repeats ad infinitum
    or the same string we passed to the :Set method earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to miss how sublime this really is. Yet again, delayed expansion offers
    us a useful and elegant solution not available in most languages. Astonishingly,
    an object with dozens of variables needs only one setter and one getter method.
    In at least one small facet, Batch offers a better solution than traditional object-oriented
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: App-Specific Public Methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In traditional OOP, constructors are a must, and setters and getters are ubiquitous,
    but there are usually other public methods specific to an application, and I’ve
    included one example of just such a method in the *oMovie.bat* object. The :DispInfo
    method ❽ displays detailed information about a film to the console. A series of
    echo commands in the method write the movie title and several other pieces of
    data to the console. For instance, its first line mentions the movie itself and
    details the year of release, whether it’s color or black and white, and the gauge.
  prefs: []
  type: TYPE_NORMAL
- en: These last two variables are set in the constructor, but the variable for the
    year and others aren’t. In fact, their only mention in the parent bat file is
    here. (I’ll share their origins before long, but it has something to do with inheritance.)
    Regardless of where this data comes from, this one method displays information
    for any movie object that is derived directly or indirectly from this object.
    That’s polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If variables such as plot{Groundhog Day} remind you of hash table elements,
    that’s because they are in fact elements of hash tables ([Chapter 29](chapter29.xhtml)).
    You don’t need to understand the data structure to understand this model, but
    after executing the logic to build 17 plots for 17 different movies, the plot
    hash table contains 17 elements.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Intermediate Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this model, the genre objects are all intermediate objects, with the *oComedy.bat*
    object being one example. It’s a child of *oMovie.bat*, but it also has children
    of its own, two of which are shown in [Figure 32-1](#fig32-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 32-2](#Lis32-2) shows the complete bat file object for *oComedy.bat*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 32-2: The intermediate object, oComedy.bat'
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, this looks to be structured much like the parent object, but there
    are differences. The very first line defines another bat file, and immediately
    after the traffic cop is a call command instead of an abort. The constructor also
    calls another bat file, and the setter and getter methods are missing along with
    the method to display information about a movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict object-oriented languages have reserved words and syntax allowing one
    object to seamlessly inherit from another. Not to be confused with Batch, this
    is how a child class would use the extends keyword to inherit from a parent in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In Batch, without similar built-in syntax, we do it quite differently. The first
    statement in the *oComedy.bat* object defines the parent object bat file from
    which it inherits, namely, *oMovie.bat* ❶, which is also the object it extends.
    Then the traffic cop, looking much like the one in the parent object, has its
    own list of public methods maintained in the for command ❷. If the first parameter
    matches either of the two public methods in the list, the call command invokes
    it ❸. But where the parent class aborts when the method to be invoked isn’t public,
    the child object instead calls the parent class defined by extends, passing the
    same arguments along ❹. That’s inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: An intermediate (and child) object can define its own methods not already in
    the parent object. It can also inherit the methods from the parent object by doing
    nothing more than what I’ve already shown. If the first parameter isn’t in the
    list of public methods, this bat file becomes a simple pass-through as it makes
    the identical call to the parent object ❹. The %* syntax ensures that the same
    parameter list received by this bat is the argument list passed to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll soon be able to call the important methods in the parent object (:DispInfo,
    :Set, and :Get) with the Batch inheritance just described. Elegantly, all of the
    genre objects and their children can easily use these methods. Not only does the
    intermediate object not have to reproduce them, but it doesn’t even need to mention
    them. And what happens when someone errantly passes this object a method not made
    public here or by its parent? The intermediate object passes it along, and the
    parent performs the error handling for all its children in one place.
  prefs: []
  type: TYPE_NORMAL
- en: This object does more than inherit methods from the parent. The constructor
    offers an example of *extending* a method already defined in the parent object.
    There is a :Constructor method in the parent, but the inheritance set up with
    the traffic cop doesn’t call it. Instead, the intermediate object’s :Constructor
    method ❺ supersedes it, but this doesn’t mean that we never invoke the parent
    constructor logic.
  prefs: []
  type: TYPE_NORMAL
- en: The very first line of the :Constructor method calls the parent object to invoke
    its method of the same name, that is, its constructor. This is another built-in
    feature of traditional object-oriented languages that we must mimic. After calling
    the parent’s constructor, the derived object’s constructor puts its own spin on
    the data. Remember that the *oMovie.bat* object defined the movie as color and
    35mm in its constructor. Here the *oComedy.bat* object accepts those two values
    and also defines the genre as Comedy ❻. As we’ll soon see, its child objects will
    extend this even further.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice two aptly named methods, one public ❼ and one private ❾. The
    private method isn’t listed in the traffic cop, so we can invoke it explicitly
    only from somewhere inside this bat file, such as from inside the public method
    ❽.
  prefs: []
  type: TYPE_NORMAL
- en: The Child Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we come to the objects for the individual movies. [Listing 32-3](#Lis32-3)
    is the entire bat file for one movie object, *oBigLebowski.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 32-3: The child object, oBigLebowski.bat'
  prefs: []
  type: TYPE_NORMAL
- en: The traffic cop ❸ at the top of this child object looks much like the one from
    the intermediate object, but it now extends the *oComedy.bat* object ❶, and the
    new title variable ❷ defines the movie. We’re passing the title to its parent
    object as the final argument ❹, where it’s used to set variables such as gauge{The
    Big Lebowski} in *oMovie.bat* and genre{The Big Lebowski} in *oComedy.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: This child object has only one public method and no private methods, but it
    could easily have multiples of either type. (Since there’s only one entry in the
    list of public methods, we could remove the for command and leave just an if command.)
  prefs: []
  type: TYPE_NORMAL
- en: The :Constructor method ❺ is even more interesting than the constructor in the
    intermediate object. It first calls the constructor of its parent, *oComedy.bat*
    ❻, and we’ve already seen that the constructor in the intermediate object will
    in turn call the constructor of its parent, *oMovie.bat*. Both parents set a variable
    or two before returning control to the constructor of the individual movie object
    where it sets everything that’s particular to its actual movie, such as the plot,
    star, and cast ❼.
  prefs: []
  type: TYPE_NORMAL
- en: We can now set up similar object bat files for other movies. Notice the differences
    and similarities between the previous object and the following object, *oLifeOfBrian.bat*,
    which contains data and a constructor method for another great film in [Listing
    32-4](#Lis32-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 32-4: The child object, oLifeOfBrian.bat'
  prefs: []
  type: TYPE_NORMAL
- en: Both constructors are setting the plot, star, members of the cast, language,
    year of release, and country, but this one is also setting troupe{%title%} ❶.
    *The Life of Brian* was created by a comedy troupe, but this variable doesn’t
    apply to most other comedies. Each constructor is unique to a particular move
    and bat file; while it should define a certain set of variables in this model,
    it can contain additional logic pertinent to its movie, as the object demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: I more than hinted earlier that you can override variables defined in the parent’s
    constructor in the child, and the child’s constructor is where that happens. For
    instance, the constructor in *oRagingBull.bat* would reset the clrOrBW{Raging
    Bull} variable to Black and White. Likewise, for a movie shot in something other
    than 35mm, such as digital, we can reset the gauge in the child’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of object-oriented design is the ability of a child object to
    override methods defined in a parent class. You’ve seen methods inherited and
    extended. The constructor just discussed is a great example of extending a method.
    Now imagine that method without the call to its like-named method in its parent.
    That’s a *method override*. The child object will never call the public method
    in its parent object because the child has overridden it with a method of its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s consider one last child object with this as the title
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If DispInfo is in the list of public methods defined for this particular child
    object, the coder of this object could add the following method to the bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A comment stating that this method is an override isn’t required, but it’s good
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this method doesn’t invoke a corresponding method in its parent
    class. It simply writes a few lines of commentary, followed by a blank line, and
    does nothing more. It has completely superseded or overridden the like-named method
    in the parent class. Unlike other movies, this title won’t see the plot, cast,
    and other information written to the console as we’ve seen for other movies using
    the :DispInfo method in *oMovie.bat*. The author of this bat file obviously felt
    that something special was needed for the informational display for such a singular
    film. (Please, no hate mail; the original trilogy was fine, even better than fine.)
  prefs: []
  type: TYPE_NORMAL
- en: Executing Object-Oriented Batch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve created the *oMovie.bat* parent object and the *oComedy.bat* intermediate
    object that extends or inherits from the parent. In theory, we could create more
    intermediate (or genre) objects and more than two million child objects for individual
    movies, but before us we have two child object bat files representing two comedies,
    each extending the *oComedy.bat* object. Finally, we can execute this object-oriented
    code. If nothing else, you can use the *Test.bat* file mentioned in [Chapter 31](chapter31.xhtml),
    but you need to place all calls to this code into a bat file not already in the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementing code calls only the child objects; the parent and intermediate
    objects are called only from their children. Let’s start with these four commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you must call the constructor before you can call any other method
    in an object. These first two commands are the Batch equivalent of instantiating
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: We first call *oBigLebowski.bat*, and its traffic cop invokes its :Constructor
    method; as we’ve already seen, that constructor invokes the constructor method
    in its parent object, *oComedy.bat*, which invokes the corresponding method in
    its parent, *oMovie.bat*. Each of the three bat files contributes to the creation
    of the nine variables that describe this movie. Immediately after that, we do
    the same with *oLifeOfBrian.bat* to create a second set of movie variables.
  prefs: []
  type: TYPE_NORMAL
- en: The constructors don’t generate any output, but the last two call commands display
    the information shown in [Listing 32-5](#Lis32-5) to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 32-5: Output from two DispInfo calls using two different child objects'
  prefs: []
  type: TYPE_NORMAL
- en: The third command calls *oBigLebowski.bat*, passing DispInfo as its only argument.
    This child object doesn’t find a public method named :DispInfo, so the inheritance
    kicks in with a call to its parent, *oComedy.bat*, where the method also doesn’t
    exist. Once again because of inheritance, we call the base object, *oMovie.bat*,
    where we finally find and execute the public method. It displays a concise summary
    of information about *The Big Lebowski* to the console in seven lines of text.
  prefs: []
  type: TYPE_NORMAL
- en: The final command also shares a wealth of information, but about a different
    movie, because it calls the *oLifeOfBrian.bat* object. We are ultimately invoking
    the exact same method, :DispInfo, in the exact same object, *oMovie.bat*, but
    notice the stark differences in the output. The output describes two entirely
    different movies. That’s polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch has one critical and fairly unique characteristic that lends itself to
    the implementation of polymorphism: delayed expansion. Resolving variables is
    straightforward in most coding languages, but Batch allows you to resolve one
    or more variables to create a variable name that can then itself be resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: Both sets of output come from the :DispInfo method in the parent object *oMovie.bat*
    ([Listing 32-1](#Lis32-1)). Taking just one variable as an example, delayed expansion
    first resolves the parameter embedded in !plot{%~1}! to be the movie title. In
    our first call, this results in !plot{The Big Lebowski}!, which then resolves
    to the plot of that movie. The second time through, this exact same code results
    in !plot{The Life of Brian}!, which resolves to a very different plot. This is
    Batch polymorphism at its finest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whoever wrote the *oBigLebowski.bat* object left an Academy Award–winning actor
    off the cast list. The late Philip Seymour Hoffman had a relatively small role
    as the title character’s smug toady of a personal assistant, Brandt, but he played
    it with a brilliance and nuance that foretold greater roles. The following two
    commands add him to the current cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of both call commands is the name of the method to be invoked,
    and the second argument is the type of variable pertinent to the call, which is
    cast in both instances. The first command will Get the current cast members, returning
    the value as the contents of the lebowCast variable. The second command will Set
    (or reset) the list of current cast members to the just-returned value concatenated
    with Mr. Hoffman’s full name. If you were to invoke the *oBigLebowski.bat* object
    again with the DispInfo argument, you’d see all four actors included in the cast
    as opposed to the three in [Listing 32-5](#Lis32-5).
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep this complex example as comprehendible as possible, I’ve resisted the
    mention of some possible tweaks, up until now.
  prefs: []
  type: TYPE_NORMAL
- en: I shared that strict OOP dictates that you must invoke the constructor before
    you can use an object. This model leaves that restriction to the honor system,
    but you can remedy the issue with an “instantiated” switch. First, the child constructor
    would set the switch when it executes. Then you could interrogate that switch
    before any attempt to invoke a public method, throwing an abort if it hasn’t yet
    been set. This is almost certainly overkill, but it wouldn’t be difficult (or
    elegant). I prefer the honor system here.
  prefs: []
  type: TYPE_NORMAL
- en: I never used the comedy troupe variable set for the Monty Python film, but you
    can define a :DispInfo method in the *oLifeOfBrian.bat* object to extend the like-name
    method from *oMovie.bat*. After the child calls to inherit the display performed
    by its parent (or parent’s parent), it can append a similar line for the troupe.
    Even better yet, since a troupe applies only to some comedies, the new method
    could go into the *oComedy.bat* object, where you’d display the troupe only if
    it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant element of OOP that we haven’t successfully duplicated
    in Batch is data hiding. When a variable is set, it’s available in the environment
    until it’s reassigned or the process ceases, and there’s no realistic means of
    preventing its reassignment by some other code. We can use the setlocal and endlocal
    commands to hide variables, but after the execution of the endlocal command, the
    variables will be lost into the ether. As I mentioned in [Chapter 16](chapter16.xhtml),
    variables can survive an endlocal command, but doing so would make them available
    globally, and that doesn’t lend itself to “data hiding.” We could hide the variables
    in a temporary file and restore them the next time through the code, but this
    most definitely is overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Not being able to declare private variables is a limitation that precludes the
    ability to make a Batch object available to a great number of users, as is the
    case with other languages. But let’s take a step back to gain some perspective.
    Making an object generally available for the masses is not part of the design
    I’m positing; this is Batch, and there’s no realistic infrastructure for something
    on that type of scale anyway.
  prefs: []
  type: TYPE_NORMAL
- en: I’m suggesting the building of objects for use by oneself and maybe a small
    group of friends or co-workers working on the same network. This isn’t something
    you’d want to make callable from a web service. Thus, the only real ramification
    of not being able to hide data is that a small cohort of coders must be aware
    that they shouldn’t step on the variables used in certain objects.
  prefs: []
  type: TYPE_NORMAL
- en: Batch object-oriented design is a methodology that I highly recommend. You might
    not implement it as extensively as in the model that I’ve presented here, nor
    should you. (More on this in the next and final chapter.) Even just portions of
    this methodology may very well be useful to you. Even without the use of inheritance,
    you can write a module with polymorphic code that behaves differently based on
    the caller. A simplified version of inheritance might rely on one central bat
    file for a few important tasks. Just writing small and reusable modules is redolent
    of object-oriented design and is an enormous step forward.
  prefs: []
  type: TYPE_NORMAL
- en: The Four Pillars in Batch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve already seen that in this Batch model we’ve been able to simulate many
    of the characteristics of OOP surprisingly well. Let’s step through each of the
    four pillars one more time, detailing how close we’ve actually come to our goal.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction, the first pillar, simplifies the code’s interface, shows only the
    necessary or relevant features, and shields implementation details. Take another
    look at the two complete child objects in Listings 32-3 and 32-4\. The methods
    to get and set variables, along with the method to display movie information,
    have all been abstracted away. Other than the logic at the top of each object
    listing public methods and handling the inheritance, there’s really just a single
    method, the constructor, and everything in it is pertinent to the object. Abstraction
    in Batch object-oriented design gets high marks.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller, more plentiful modules present a superior design regardless of the
    language or coding methodology. Each file has a distinct purpose, and the code
    is more maintainable and extensible. The model I’ve shown in this chapter lends
    itself to writing short, compact, and reusable code modules, and this is one of
    three components that define the second pillar, encapsulation, along with data
    and method hiding. Method hiding is trivial in Batch; in fact, we had to do some
    work to expose public methods. Data hiding, however, isn’t supported at all in
    this model. All of the variables set for all of the different movies float around
    the environment for anyone to modify at any time. Two out of three is a passing
    grade.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of inheritance, the third pillar, are strewn throughout the previous
    pages. Child objects are inheriting constructors from intermediate objects, which
    in turn inherit the same from parent objects. The method for displaying information
    to the console and the setter and getter methods are all quality examples of inheritance.
    We coded them once in the parent object for use by up to two million child objects.
    I’ve even demonstrated how to override a method in a child object. We need a bit
    of redundant code at the top of each bat file to make this work, but this model
    clearly scores near the top of its class when it comes to inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth pillar, polymorphism, allows code to behave differently in different
    situations, with the method displaying movie information being a prime example
    of this functionality. We use a single method in a single bat file to write the
    unique information for a couple million movies—and two of those variables displayed
    were originally set in the parent object’s polymorphic constructor. The setter
    and getter method take this a step further. Traditional OOP requires a pair of
    these methods for each and every defined variable. In this model, a single setter
    and a single getter handle all variables for each and every individual movie object.
    Batch polymorphism is what many students call a *curve buster*.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave it to you, the reader, to give this model a final grade. I’ll concede
    that due to the lack of data hiding, the mark of an A is out of reach, but I hope
    not too far out of reach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Was Batch designed as an object-oriented language? Not a chance. Is it possible
    to build much of object-oriented design—that is, abstraction, encapsulation, inheritance,
    and polymorphism—in bat files? Absolutely. Can Batch object-oriented design achieve
    the efficiency and scale of other languages? No. After reading this chapter, how
    many Batch coders will propose an enterprise-wide object-oriented project to their
    employer? Not many. If that number is greater than zero, how many will still be
    employed in three months? Most assuredly none. How many coders will try to incorporate
    elements of Batch object-oriented design into their code? Hard to say, but I’m
    hoping for quite a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-oriented design is this book’s dénouement, so why is this merely the
    penultimate chapter of the book? In the next and final chapter, I’ll introduce
    two data structures: stacks and queues. But I’ll also use these data structures
    as an opportunity to further demonstrate object-oriented design, because this
    discussion is far from complete. The model I’ve detailed in this chapter implements
    every possible object-oriented design principle, but it isn’t how I usually code
    Batch objects. It’s better to use only what’s needed and not what isn’t. When
    building stacks and queues in the next chapter, you’ll see real-world objects
    for each, and I’ll also share some final thoughts about Batch object-oriented
    design.'
  prefs: []
  type: TYPE_NORMAL
