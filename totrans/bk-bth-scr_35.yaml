- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 32 OBJECT-ORIENTED DESIGN
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32 面向对象设计
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: 'In preceding chapters, I’ve explored many topics that aren’t typically associated
    with Batch from booleans to hash tables, with many others in between. In this
    chapter, I’ll tackle the holy grail of Batch user-built tools: object-oriented
    design.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我探讨了许多通常与Batch无关的主题，从布尔值到哈希表，还有很多其他内容。在这一章中，我将处理Batch用户自建工具的圣杯：面向对象设计。
- en: After explaining the difference between procedural and object-oriented coding,
    I’ll lay out the four pillars of object-oriented programming. Then I’ll present
    a fully functional model of Batch object-oriented design, complete with bat files
    representing parent, intermediate, and child objects. After you’ve learned how
    to invoke the object-oriented code, I’ll share many recommendations and analyze
    how well this model satisfies the basic tenets of object-oriented design.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了过程式编码和面向对象编码的区别后，我将介绍面向对象编程的四大支柱。接着，我会展示一个完整功能的Batch面向对象设计模型，其中包含代表父对象、中间对象和子对象的bat文件。在你学会如何调用面向对象的代码后，我将分享许多建议并分析这个模型如何满足面向对象设计的基本原则。
- en: Procedural vs. Object-Oriented Coding
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过程式与面向对象编程
- en: In the very early days of computers, all coding was *procedural*—that is, all
    programs consisted of a series of computational steps. The methodology is still
    very much in existence with possibly more than a trillion lines of such code still
    in use and many more written every day. By default, variables are accessed globally
    in procedural code. Sometimes many hundreds of variables are defined in a section
    near the beginning of a program, and at other times, such as in Batch, they come
    into being when first referenced. Even when an internal routine or procedure is
    invoked, the set of active and available variables doesn’t change. Certain measures
    can often be invoked to limit scope, such as the setlocal discussed in [Chapter
    3](chapter3.xhtml), but in procedural coding, a variable typically can be set
    or reset anywhere in what is often a very large program file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，所有的编码都是*过程式的*——也就是说，所有程序由一系列计算步骤组成。这个方法论至今仍然存在，可能有超过一万亿行这样的代码仍在使用，每天还有更多新的代码被编写出来。在过程式代码中，变量默认是全局访问的。有时，程序开头的一部分会定义数百个变量，而在其他时候，比如在批处理程序中，变量是在首次引用时创建的。即使调用了一个内部例程或过程，活动和可用的变量集合也不会改变。通常可以采取一些措施来限制作用域，比如[第3章](chapter3.xhtml)中讨论的setlocal，但在过程式编码中，变量通常可以在程序文件的任何地方被设置或重置，这些文件通常非常庞大。
- en: Before long, some smart people came up with the concept of *object-oriented
    programming (OOP)*, where the code is broken into small, easy-to-manage *objects*,
    each containing data in the form of variables and executable code in the form
    of methods. A *method* is similar to an internal routine in Batch; it can be invoked,
    and when it completes its execution, control is returned to the point of the call,
    but a method can also be called externally; that is, code inside another program
    file can call the method directly. Regardless of the source of the call, the method
    accepts well-defined inputs and returns equally well-defined outputs. However,
    most of the data inside a method is typically inaccessible from elsewhere in the
    program file and especially from other program files.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，一些聪明的人提出了*面向对象编程（OOP）*的概念，在这种方法中，代码被分解成小的、易于管理的*对象*，每个对象包含变量形式的数据和方法形式的可执行代码。*方法*类似于批处理中的内部例程；它可以被调用，当它完成执行时，控制权会返回到调用点，但方法也可以被外部调用；即，其他程序文件中的代码可以直接调用该方法。不管调用的来源是什么，方法都接受明确定义的输入并返回同样明确定义的输出。然而，方法内部的大多数数据通常无法从程序文件的其他地方访问，尤其是从其他程序文件中。
- en: The compartmentalization of the code into individual objects streamlines the
    logic and guards against the unintended consequence of some portion of the code
    adversely affecting another portion. Additionally, if one of these objects is
    of use in a different context, it can easily be used by both processes without
    modification or duplication. An equivalently useful portion of a procedural program
    might end up being copied and pasted into another program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的模块化将其分解为独立的对象，从而简化了逻辑并防止了代码某一部分对其他部分产生不良影响。此外，如果其中一个对象在不同的上下文中有用，它可以在不修改或重复的情况下被两个进程轻松使用。一个等效有用的过程式程序部分可能最终被复制并粘贴到另一个程序中。
- en: If I were to construct a list of great personal irritants—and for the sake of
    brevity, I’ll limit this to work/coding-related peeves—atop my jeremiad is procedural
    code disguised as object-oriented code. Certain languages and frameworks are designed
    to support each coding paradigm. Java and C# are object-oriented languages; COBOL
    and Batch are procedural languages. But contrary to what many believe, it isn’t
    that simple; procedural code can easily be written in Java, and with some work,
    object-oriented principles can be implemented in Batch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要列出一些个人的重大烦恼——为了简洁起见，我将把范围限制在与工作/编码相关的烦心事——在我愤懑的清单上，排在最前的是伪装成面向对象代码的过程式代码。某些语言和框架是专门为支持每种编码范式设计的。Java和C#是面向对象语言；COBOL和Batch是过程式语言。但与许多人的看法相反，事情并没有那么简单；过程式代码可以很容易地在Java中编写，而经过一些努力，面向对象的原则也可以在Batch中实现。
- en: The Four Pillars
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四大支柱
- en: Any coding language that purports to be object-oriented must fully support the
    four pillars of object-oriented programming. Languages considered to be object-oriented
    implement these in different ways, but they all have built-in mechanisms to guide
    the coder into writing code with these four characteristics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何声称是面向对象的编程语言，都必须完全支持面向对象编程的四大支柱。被认为是面向对象的语言以不同的方式实现这些支柱，但它们都有内置的机制，引导程序员编写具有这四个特征的代码。
- en: The first pillar is *abstraction*, which simplifies the code’s interface with
    the outside world. It shows only the necessary or relevant features to the user,
    while shielding the implementation details and any information irrelevant to the
    functionality’s use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一大支柱是*抽象*，它简化了代码与外部世界的接口。它只向用户展示必要或相关的特性，同时屏蔽实现细节和任何与功能使用无关的信息。
- en: This segues into the second pillar, *encapsulation*, which restricts access
    to certain methods and variables in an object, wrapping up data and code into
    multiple small units. Data hiding, or treating some variables and methods as private,
    is a significant part of this pillar. Another significant part is simply the act
    of creating compact, readable, and reusable modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了第二大支柱——*封装*，它限制了对对象中某些方法和变量的访问，将数据和代码封装成多个小单元。数据隐藏，或者将某些变量和方法视为私有，是这一支柱的重要组成部分。另一个重要部分就是创建紧凑、易读且可重用模块的行为。
- en: '*Inheritance*, the third pillar, allows for the creation of a base or parent
    object. Then derived objects can use the parent object while extending it to fit
    the more specific needs of the child. The classic example is a base or parent
    object of an Animal, defining all that is common throughout the animal kingdom.
    Then intermediate objects defined as Reptile and Mammal can inherit data and routines
    from the Animal object and add to it information about their respective zoological
    classes. Then objects of Cat, Rat, and even Bat can inherit from the Mammal object,
    which is already inheriting from the Animal object. More than 1,000 child objects,
    one for each bat species on the planet, can then inherit from the Bat object.
    Finally, each of the inheriting objects can use the data and code in its parent
    objects for its own use.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承*，第三大支柱，允许创建基础或父对象。然后，派生对象可以在扩展父对象以满足子对象的更具体需求时使用它。经典的例子是一个“动物”作为基础或父对象，定义了整个动物王国中共同的特征。然后，作为“爬行动物”和“哺乳动物”的中介对象可以从“动物”对象继承数据和程序，并在此基础上添加各自的生物学分类信息。接着，“猫”、“鼠标”甚至“蝙蝠”对象可以从“哺乳动物”对象继承，而“哺乳动物”对象又继承自“动物”对象。然后，地球上每一种蝙蝠物种都可以从“蝙蝠”对象继承。最终，每个继承的对象都可以使用其父对象中的数据和代码。'
- en: The fourth pillar, *polymorphism*, which means the condition of occurring in
    several different forms, derives literally from the Greek words meaning *many
    forms*. This allows a call to a routine to behave differently in different situations.
    Reusable code is always awesome, but this pillar takes the concept of reuse to
    its zenith. A method in the parent object might be invoked by multiple child objects,
    where each invocation is unique to the child.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第四大支柱，*多态*，意味着以多种不同形式出现的状态，字面上源自希腊语，意为*多种形式*。这使得调用一个例程在不同情况下表现得不同。可重用的代码总是很棒的，但这一支柱将重用的概念推向了巅峰。父对象中的方法可能会被多个子对象调用，而每次调用对每个子对象来说都是独特的。
- en: In the pages ahead, I’ll attempt to mimic these four pillars of abstraction,
    encapsulation, inheritance, and polymorphism.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我将尝试模仿这四大支柱：抽象、封装、继承和多态。
- en: Batch Object-Oriented Design
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Batch 面向对象设计
- en: This chapter is about Batch object-oriented design and not Batch object-oriented
    programming for two reasons. First, and more trivially, BOOP is a horrible acronym,
    reminiscent of the noise one might make when affectionately poking a baby’s nose.
    BOOD isn’t much better, but I do have a Brilliant Acronym Team (or BAT) diligently
    working on something batter ... sorry, something better.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解的是 Batch 面向对象设计，而不是 Batch 面向对象编程，原因有两个。首先，更琐碎的一点是，BOOP 是一个糟糕的缩写，让人联想到在亲切地戳宝宝鼻子时发出的声音。BOOD
    也不怎么样，但我确实有一个“辉煌缩写团队”（Brilliant Acronym Team，简称 BAT）正在努力做一些更好的……抱歉，是更棒的事情。
- en: Far more important, Batch has none of the built-in features that are intrinsic
    to more modern languages that implement object-oriented programming. I’ll demonstrate
    how to mimic each of its four pillars, and the level of success in creating object-oriented
    bat files may very well surprise many, but I’ll craft some of its functionality
    more completely than other functionality. True object-oriented programming won’t
    be possible in Batch, but I encourage you to incorporate these design elements,
    in whole or in part, in the design of your Batch code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更为重要的是，Batch 没有实现面向对象编程（OOP）所固有的内建特性，这些特性在更现代的编程语言中得到了实现。我将展示如何模拟其四个支柱，并且创建面向对象的批处理文件的成功程度可能会让许多人感到惊讶，但我会比其他功能更完整地构建一些其功能。真正的面向对象编程在
    Batch 中是不可能实现的，但我鼓励你在 Batch 代码的设计中，完全或部分地融入这些设计元素。
- en: In Batch, a variable cannot be defined as public or private; in fact, variables
    can’t be defined at all. There is no keyword to invoke inheritance found in other
    languages, such as “extends” or “implements.” In OOP, a child object can override
    methods in the parent object; you’ll soon see how to perform many of these tasks
    in Batch, but they won’t be done automatically. Remember that this is a language
    without booleans, floats, the while and do...while commands, the and and or operators,
    arrays, and hash tables. I’ve demonstrated how to build all of those things with
    the tools at hand (and I’ll do the same with stacks and queues in [Chapter 33](chapter33.xhtml)),
    so it should be of little surprise that Batch has nothing off the shelf for anything
    like object-oriented programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Batch 中，变量不能被定义为公有或私有；事实上，变量根本无法定义。没有像“extends”或“implements”这样的关键字来调用继承。面向对象编程（OOP）中，子对象可以覆盖父对象的方法；你很快就会看到如何在
    Batch 中执行这些任务，但它们不会自动完成。请记住，这是一个没有布尔值、浮动值、while 和 do...while 命令、以及 and 和 or 运算符、数组和哈希表的语言。我已经演示了如何利用手头的工具构建所有这些功能（并且在[第33章](chapter33.xhtml)中我将以同样的方式演示堆栈和队列的构建），所以应该不会让人感到惊讶，Batch
    并没有现成的面向对象编程功能。
- en: However, object-oriented principles can be used, and should be used, regardless
    of the provided toolkit. Someone coding in an “object-oriented language” can easily
    define excessive class-level variables, make all data items public, and put the
    lion’s share of the code into a “god object” (a single object that does too much
    and is too big to be managed efficiently). But regardless of the coding language,
    this design with large modules and excessive global variables is essentially procedural
    coding. More modern languages have object-oriented guardrails, but guardrails
    can be breached.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，面向对象的原则是可以使用的，而且应该被使用，不论提供了什么样的工具集。在“面向对象语言”中编程的人，往往会轻易地定义过多的类级别变量，将所有数据项设置为公有，并将大部分代码放入一个“上帝对象”（一个做得太多且太大，无法高效管理的单一对象）中。但无论是什么编程语言，这种设计模式——大模块和过多的全局变量——本质上还是过程式编程。更现代的语言提供了面向对象的护栏，但这些护栏是可以突破的。
- en: Conversely, there’s an expectation among many that Batch coders should create
    only large uninteresting modules. But while Batch procedural code is the standard,
    there’s no Batch police requiring it. When object-oriented programming or design
    is thought of as a technique and not as a characteristic associated with only
    some languages, scales will fall from your eyes as if on the road to Damascus.
    Batch doesn’t possess the sturdy guardrails offered elsewhere, but you can craft
    object-oriented techniques using any coding language, just as it’s more than possible
    to reach the summit driving up a mountain road with shear drops. The infrastructure
    or plumbing might not exist in Batch and not everything will be possible, but
    the elegance of object-oriented design in Batch offers the same benefits realized
    in other languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，许多人认为批处理程序员应该只创建大型、无趣的模块。但尽管批处理过程式代码是标准做法，却没有“批处理警察”强制要求它。当面向对象编程或设计被视为一种技术，而不是仅与某些语言相关的特征时，你会恍若顿悟，仿佛走在前往大马士革的路上。批处理并没有其他语言所提供的坚固护栏，但你可以使用任何编程语言来打造面向对象的技术，就像即使在悬崖峭壁的山路上开车也完全有可能到达山顶。批处理中可能没有基础设施或管道，也不是所有事情都能实现，但批处理中的面向对象设计的优雅性提供了与其他语言相同的好处。
- en: Classes and Objects
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类与对象
- en: One of the differences between OOP and Batch object-oriented design is that
    traditionally each module or file is defined as a *class*, and an *object* is
    an instantiation of that class. Instantiating an object is much like defining
    a variable. Just as a variable can be defined as a string or as an integer in
    many languages, an object is instantiated to be one specific instance of a class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程与批处理面向对象设计之间的一个区别是，传统上每个模块或文件被定义为一个 *class*，而 *object* 是该类的一个实例化。实例化一个对象就像定义一个变量一样。就像在许多语言中，变量可以定义为字符串或整数，实例化对象就是将其定义为类的一个具体实例。
- en: To demonstrate, imagine again a class defined as *Bat*, representing all flying
    nocturnal mammals, where each species of bat would have its own class inheriting
    from *Bat*. One such species is the Madagascan fruit bat, and its class might
    be defined as a *MadFruitBat*. This class represents all bats of this one species,
    and it can be instantiated many times, each time representing one specific creature.
    A cave containing 500 Madagascan fruit bats could be populated with 500 objects,
    each one an instantiation of the *MadFruitBat* class individually named for a
    particular bat.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设定义了一个类 *Bat*，表示所有飞行的夜行哺乳动物，其中每个蝙蝠物种都有自己的类，从 *Bat* 类继承。其中一个物种是马达加斯加果蝠，其类可能定义为
    *MadFruitBat*。这个类表示所有属于该物种的蝙蝠，并且它可以被实例化多次，每次代表一个特定的个体。一个包含500只马达加斯加果蝠的洞穴可以被填充为500个对象，每一个都是
    *MadFruitBat* 类的一个实例，且每个实例会为特定的蝙蝠命名。
- en: This is where Batch has its first object-oriented limitation. Remember that
    this is a language without the ability to define variables as strings and integers.
    Obviously then, a variable can’t be defined or instantiated as a data type corresponding
    to a class module. In Batch, the distinction between classes and objects doesn’t
    exist. A module or bat file is itself an object. It doesn’t have to be instantiated,
    nor can it be instantiated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是批处理（Batch）首次遇到面向对象限制的地方。记住，这是一种无法定义变量为字符串或整数的语言。显然，因此，变量不能被定义或实例化为与类模块相对应的数据类型。在批处理中，类与对象之间的区别是不存在的。模块或批处理文件本身就是一个对象。它不需要实例化，也无法实例化。
- en: For this reason, the word *class* isn’t part of the Batch object-oriented design
    vernacular. I’ll soon share bat files that are fully constituted objects, each
    one ready to be invoked, and I’ll be referring to them as *objects*. The Madagascan
    fruit bat defined as the *MadFruitBat* class in OOP would be the *MadFruitBat.bat*
    object bat file in Batch. To implement the 500 individual Madagascan fruit bats,
    you would need to create a small bat file for each, and each would inherit from
    *MadFruitBat.bat*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，*class* 这个词并不是批处理面向对象设计术语的一部分。我很快会分享一些完全构成对象的批处理文件，每一个都可以被调用，我将把它们称作
    *objects*。在面向对象编程（OOP）中定义的马达加斯加果蝠类（*MadFruitBat*）将会是批处理中的 *MadFruitBat.bat* 对象批处理文件。为了实现500只马达加斯加果蝠，你需要为每只果蝠创建一个小的批处理文件，每个文件都继承自
    *MadFruitBat.bat*。
- en: Actually, *oMadFruitBat.bat* is a better name for the object bat file. To distinguish
    an object bat file from its more pedestrian brethren, I always prepend its name
    with a lowercase *o* as a visual cue. The *obj* text also works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，*oMadFruitBat.bat* 是对象 bat 文件的更好名称。为了区分对象 bat 文件与其他常见的 bat 文件，我总是在它的名字前加上小写字母
    *o* 作为视觉提示。*obj* 文字也可以使用。
- en: Batch Object-Oriented Design Model
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理面向对象设计模型
- en: The best way of describing object-oriented design is with an example or model.
    I’ll lay out here the broad strokes of the example of Batch object-oriented design
    that I present in this chapter. Then I’ll show the parent object with examples
    of intermediate and child objects, all the while explaining the object-oriented
    concepts implemented in each module. In the next section, “Executing Object-Oriented
    Batch,” I’ll discuss exactly how to invoke this model, and in a later section,
    “The Four Pillars in Batch,” I’ll explore how closely this model mimics each of
    the central concepts of object-oriented principles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 描述面向对象设计的最佳方式是通过示例或模型。接下来我将简要介绍本章中展示的批处理面向对象设计的示例。然后，我将展示父对象，并附上中间对象和子对象的示例，同时解释每个模块中实现的面向对象概念。在接下来的部分“执行面向对象的批处理”中，我将详细讨论如何调用这个模型，而在后续部分“批处理中的四大支柱”中，我将探讨这个模型如何紧密模仿面向对象原则的核心概念。
- en: At the top of the pyramid is the base or parent object. Other objects inherit
    from it, but it’s the one object in this model that doesn’t inherit from another
    object. Beneath the parent are the intermediate objects that inherit directly
    from the parent object. Other intermediate objects can inherit from the first
    level of intermediate objects, culminating in child objects at the bottom of the
    pyramid. Intermediate and child objects are both called *derived objects* because
    they inherit or are derived from another object. (Technically, an intermediate
    object is also a child object because it is a child of another object, but I use
    the term *child* for what might more accurately be called a “childless child object.”)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶部是基类或父对象。其他对象从它继承，但它是这个模型中唯一一个不从其他对象继承的对象。在父对象下方是直接继承自父对象的中间对象。其他中间对象可以从第一级中间对象继承，最终在金字塔底部形成子对象。中间对象和子对象都被称为
    *派生对象*，因为它们继承或来源于其他对象。（从技术上讲，中间对象也是一个子对象，因为它是另一个对象的子对象，但我使用“子对象”一词来描述那些可能更准确地称为“无子对象”的对象。）
- en: 'In this chapter’s Batch object-oriented design model, Movie is the parent object
    to dozens of different film genre objects, such as SciFi, RomCom, and Action,
    although only two are shown: Comedy and Drama. Individual movies are their own
    specific object, each one inheriting from a particular genre object. More than
    two million movies have been released, but I’m showing only three here, two of
    which are the greatest movies ever released, and *The Godfather* is a great film
    as well. The objects that I’ll present in this chapter, I’ve marked with an asterisk
    in [Figure 32-1](#fig32-1).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的批处理面向对象设计模型中，电影是父对象，派生出了许多不同的电影类型对象，如科幻片、浪漫喜剧和动作片，虽然这里只展示了喜剧和剧情两种类型。每部电影都是一个特定的对象，每部电影从某个特定的类型对象继承而来。全球发布的电影超过两百万部，但在这里我只展示了三部，其中两部是有史以来最伟大的电影，*教父*
    也是一部伟大的电影。我将在本章中展示的对象，在[图32-1](#fig32-1)中已用星号标注。
- en: '![](../images/fig32-1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig32-1.jpg)'
- en: 'Figure 32-1: Parent, intermediate, and child objects'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-1：父对象、中间对象和子对象
- en: The Movie object contains data and methods that are common to all movies, or
    are at least the defaults for all movies. (Echoing the parlance of OOP, I’ll use
    the term *method* in place of *routine* from this point forward.) The Comedy and
    Drama objects each inherit from the Movie object and extend it, defining data
    and methods particular to each genre. The individual movie objects inherit from
    the genre objects, and thus indirectly from the Movie object, and contain detailed
    data about their specific flick. (Each arrow extends from the derived object to
    its parent object.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 电影对象包含所有电影共有的数据和方法，或者至少是所有电影的默认数据和方法。（借用面向对象编程的术语，从这一点起我将使用 *方法* 来代替 *例程* 一词。）喜剧和剧情对象各自继承自电影对象，并对其进行扩展，定义了与每个类型特有的数据和方法。个别电影对象继承自类型对象，因此间接地继承自电影对象，并包含有关其特定电影的详细数据。（每条箭头表示从派生对象到其父对象的继承关系。）
- en: But this isn’t a rigid hierarchy. A movie franchise object such as StarTrek
    could inherit from the SciFi genre object (neither is shown), and the individual
    *Star Trek* movies could be child objects of the movie franchise object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是一个严格的层次结构。像 StarTrek 这样的电影系列对象可以继承自科幻类型对象（两者都未显示），而个别的 *Star Trek* 电影则可以作为电影系列对象的子对象。
- en: More important, all objects are bat files. The Movie object in its most concrete
    form is the *oMovie.bat* bat file, and the Comedy object is the *oComedy.bat*
    bat file. Likewise, one of the child objects will be *oBigLebowski.bat*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，所有对象都是 bat 文件。Movie 对象最具体的形式是 *oMovie.bat* bat 文件，而 Comedy 对象是 *oComedy.bat*
    bat 文件。同样，子对象之一将是 *oBigLebowski.bat*。
- en: Some object-oriented languages offer multiple inheritance; that is, a derived
    object can inherit from two or more different objects. For instance, the Dramedy
    object might inherit from both the Comedy and Drama objects. While that is theoretically
    possible even in Batch, I’m restricting this model to single inheritance, so the
    Dramedy object is just another genre object inheriting from the Movie object,
    and individual dramedies will then inherit from the Dramedy object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向对象的语言提供多重继承；也就是说，一个派生对象可以继承自两个或更多不同的对象。例如，Dramedy 对象可能同时继承自 Comedy 和 Drama
    对象。虽然即使在 Batch 中从理论上讲也是可能的，但我将此模型限制为单一继承，因此 Dramedy 对象只是继承自 Movie 对象的另一种类型对象，个别的
    dramedy 将继承自 Dramedy 对象。
- en: The Parent Object
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 父对象
- en: Once all of this makes sense conceptually, you’ll want to see everything in
    action. Starting with the base or parent object, [Listing 32-1](#Lis32-1) shows
    the contents of *oMovie.bat*. Note that this and the other object bat file don’t
    start with a setlocal command because they’ll always be called from other bat
    files that contain the command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些概念变得清晰，你就会想看看一切是如何运作的。从基本或父对象开始，[列表 32-1](#Lis32-1) 显示了 *oMovie.bat* 的内容。请注意，这个和其他对象的
    bat 文件不会以 setlocal 命令开头，因为它们总是从包含该命令的其他 bat 文件中调用。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 32-1: The base or parent object, oMovie.bat'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 32-1：基本或父对象，oMovie.bat
- en: There are many interesting pieces of this object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有很多有趣的部分。
- en: Hiding Methods
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐藏方法
- en: Encapsulation, one of OOP’s pillars, includes the hiding of methods. By default,
    all methods of a bat file are hidden because there’s no built-in means of creating
    multiple entry points into a bat file; when a bat file executes, it starts at
    the top every time. Hence, the task here isn’t to hide certain methods but to
    make certain methods publicly accessible, while leaving the others hidden.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 封装，面向对象编程（OOP）的支柱之一，包括隐藏方法。默认情况下，bat 文件的所有方法都是隐藏的，因为没有内置的方式可以创建多个入口点进入 bat 文件；当
    bat 文件执行时，每次都会从顶部开始。因此，这里的任务不是隐藏某些方法，而是使某些方法公开可访问，同时保持其他方法隐藏。
- en: 'The for command ❶ acts as a “traffic cop”; it contains a list of the bat file’s
    public methods as its input: Constructor, DispInfo, Set, and Get. The if command
    inside its code block compares the first parameter received, meth, to this list.
    If it matches one of the methods listed, the parameter, prepended with a colon,
    becomes the argument of the call command ❷, and we pass the remaining parameters
    as additional arguments.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: for 命令 ❶ 充当“交通警察”；它包含了 bat 文件的公共方法列表作为输入：构造函数（Constructor）、显示信息（DispInfo）、设置（Set）和获取（Get）。它代码块中的
    if 命令将收到的第一个参数 meth 与此列表进行比较。如果它与列表中的某个方法匹配，则该参数（在前面加上冒号）将成为调用命令 ❷ 的参数，剩余的参数将作为附加参数传递。
- en: Upon its completion of the called method, control immediately returns to the
    calling bat file via the goto :eof command ❸ at the end of the for loop. Notice
    that the last method ❾ isn’t on the list. As its name suggests, it’s a private
    method, callable exclusively from methods inside the object. If a calling bat
    file tries to invoke any other method not on the list or some text that isn’t
    even a method, the code writes out an abort message ❹ and exits the entire process
    after a pause. (More robust error handling would be preferrable, but this works
    as a demonstration.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用方法完成后，控制通过 goto :eof 命令 ❸ 立即返回到调用的 bat 文件，该命令位于 for 循环的末尾。注意，最后一个方法 ❾ 不在列表中。顾名思义，它是一个私有方法，只能从对象内部的方法中调用。如果一个调用的
    bat 文件尝试调用任何不在列表中的其他方法，或者是一些根本不是方法的文本，代码将输出一个中止消息 ❹ 并在暂停后退出整个进程。（更强大的错误处理会更好，但这足以作为演示。）
- en: Constructor
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数
- en: When coding in a language with object-oriented guardrails, the act of instantiating
    an object automatically calls the constructor method belonging to the class. In
    fact, it isn’t even possible to call the other public methods until you’ve invoked
    the constructor. The constructor might set some variables or open a file or two,
    but its general purpose is to set up the object so you can use it going forward.
    This model mimics this behavior with the :Constructor method ❺ near the top of
    every Batch object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在有面向对象约束的编程语言中，实例化一个对象时会自动调用该类所属的构造方法。事实上，甚至在调用构造方法之前，无法调用其他公共方法。构造方法可能会设置一些变量或打开一些文件，但其一般目的是设置对象，以便你可以在后续使用它。这个模型通过每个批处理对象顶部的
    :Constructor 方法❺模拟了这一行为。
- en: This constructor method of the parent object simply sets two variables to defaults
    so that the majority of the individual movie objects won’t have to set them. The
    vast majority of movies released in the past several decades were shot in color
    and on 35-millimeter gauge film. This particular constructor accepts only one
    parameter, the movie title, so for one film in particular, the two set commands
    assign the values of 35mm and color to the variables defined as gauge{The Big
    Lebowski} and clrOrBW{The Big Lebowski}, respectively. The variable names have
    spaces, and if that’s a problem for any reason, you can remove them with the replacement
    syntax, as long as you do so consistently.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个父对象的构造方法只是将两个变量设置为默认值，这样大多数单独的电影对象就不需要再次设置它们。过去几十年发布的大多数电影都是彩色拍摄并使用35毫米胶片拍摄的。这个构造方法只接受一个参数，即电影标题，所以对于一部特定的电影，两个设置命令分别将
    35mm 和 color 的值赋给分别定义为 gauge{The Big Lebowski} 和 clrOrBW{The Big Lebowski} 的变量。这些变量名有空格，如果因为某些原因这造成了问题，你可以使用替换语法去掉空格，只要这样做时保持一致。
- en: We’ll also want variables for the plot, year of release, and other characteristics,
    but these clearly don’t have defaults, so we’ll set them elsewhere. However, you’ll
    soon see how the object for a 70-millimeter black-and-white film will be able
    to override these default values set in the parent object constructor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为情节、上映年份以及其他特性设置变量，但这些显然没有默认值，因此我们会在其他地方设置它们。不过，你很快会看到，70毫米黑白电影的对象将能够覆盖在父对象构造方法中设置的默认值。
- en: Setters and Getters
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置器和获取器
- en: In strict object-oriented coding, classes typically have many setter and getter
    methods; that is, for each defined data item one method sets and another method
    gets its value. For instance, there might be a pair of methods to get and set
    the gauge and another pair for the plot, and so on. But due to delayed expansion
    and Batch’s lack of defined data types, we can consolidate all of the setter methods
    into a single :Set method ❻, and we can handle all of the getter methods with
    a solitary :Get method ❼.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格的面向对象编程中，类通常会有许多 setter 和 getter 方法；也就是说，对于每个定义的数据项，一个方法设置它，另一个方法获取它的值。例如，可能会有一对方法用于获取和设置计量仪表，还有一对方法用于情节，等等。但由于延迟扩展和批处理缺乏定义的数据类型，我们可以将所有的
    setter 方法合并成一个单一的 :Set 方法❻，并且我们可以通过一个单独的 :Get 方法❼来处理所有的 getter 方法。
- en: 'The :Set method has a single line of interesting code that a calling bat file
    can use to set any variable for the object. It’s a set command using three parameters:
    the characteristic being set is %~1, the value being assigned is %~2, and the
    movie title is %~3. The variable name being set is a combination of the first
    and last parameters: %~1{%~3}.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: :Set 方法包含一行有趣的代码，调用的批处理文件可以用来为对象设置任何变量。这是一个使用三个参数的设置命令：被设置的特性是 %~1，赋值的内容是 %~2，而电影标题是
    %~3。要设置的变量名是第一个和最后一个参数的组合：%~1{%~3}。
- en: 'To demonstrate how this works, you can invoke the :Set method with the following
    call command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个是如何工作的，你可以通过以下调用命令来调用 :Set 方法：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of this call sets the value of the plot in the second argument to
    the plot{Groundhog Day} variable, but notice that there’s no explicit call to
    the :Set method to be found in this bat file. I’ll eventually show how to make
    this call from outside of this parent bat file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次调用的结果将把第二个参数中的情节值设置为 plot{Groundhog Day} 变量，但注意在这个批处理文件中并没有显式地调用 :Set 方法。我稍后会展示如何从这个父级批处理文件外部进行此调用。
- en: 'The :Get method flips the assignment around, returning the value in lieu of
    assigning it. The parameters for the setter and getter methods are the same with
    the notable exception that the second one for the getter is the name of the variable
    to which we assign the plot, instead of the plot itself. Conveniently, resolving
    the other two parameters inside of exclamation marks extracts the value of the
    plot as part of the assignment: !%~1{%~3}!.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: :Get方法将赋值操作反转，返回值代替赋值操作。setter和getter方法的参数相同，唯一值得注意的区别是getter的第二个参数是我们赋值给plot的变量名，而不是plot本身。方便的是，在感叹号内解析其他两个参数时，将提取plot的值作为赋值的一部分：!%~1{%~3}!。
- en: 'Here’s one possible invocation of the method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该方法的一种可能调用：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This returns the plotVar variable set to the value A day repeats ad infinitum
    or the same string we passed to the :Set method earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回将plotVar变量设置为值A的结果，表示一天重复无穷或我们之前传递给:Set方法的相同字符串。
- en: It’s easy to miss how sublime this really is. Yet again, delayed expansion offers
    us a useful and elegant solution not available in most languages. Astonishingly,
    an object with dozens of variables needs only one setter and one getter method.
    In at least one small facet, Batch offers a better solution than traditional object-oriented
    languages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忽视这背后真正的微妙之处。再一次，延迟扩展为我们提供了一个在大多数语言中都无法获得的有用且优雅的解决方案。令人吃惊的是，一个拥有数十个变量的对象只需要一个setter和一个getter方法。在至少某个小的方面，Batch比传统的面向对象语言提供了更好的解决方案。
- en: App-Specific Public Methods
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用程序特定的公共方法
- en: In traditional OOP, constructors are a must, and setters and getters are ubiquitous,
    but there are usually other public methods specific to an application, and I’ve
    included one example of just such a method in the *oMovie.bat* object. The :DispInfo
    method ❽ displays detailed information about a film to the console. A series of
    echo commands in the method write the movie title and several other pieces of
    data to the console. For instance, its first line mentions the movie itself and
    details the year of release, whether it’s color or black and white, and the gauge.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程中，构造函数是必需的，setter和getter是无处不在的，但通常还有其他应用程序特定的公共方法，我在*oMovie.bat*对象中就包含了一个这样的例子。:DispInfo方法❽将电影的详细信息显示到控制台。该方法中的一系列echo命令将电影标题和其他几项数据写入控制台。例如，它的第一行提到电影本身，并详细介绍了上映年份、是否为彩色或黑白影片以及胶片规格。
- en: These last two variables are set in the constructor, but the variable for the
    year and others aren’t. In fact, their only mention in the parent bat file is
    here. (I’ll share their origins before long, but it has something to do with inheritance.)
    Regardless of where this data comes from, this one method displays information
    for any movie object that is derived directly or indirectly from this object.
    That’s polymorphism.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个最后的变量是在构造函数中设置的，但年份变量和其他变量并没有设置。事实上，它们在父bat文件中唯一的提及就在这里。（我很快会分享它们的来源，但这与继承有关。）无论这些数据来自何处，这个方法可以为任何直接或间接派生自该对象的电影对象显示信息。这就是多态性。
- en: NOTE
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If variables such as plot{Groundhog Day} remind you of hash table elements,
    that’s because they are in fact elements of hash tables ([Chapter 29](chapter29.xhtml)).
    You don’t need to understand the data structure to understand this model, but
    after executing the logic to build 17 plots for 17 different movies, the plot
    hash table contains 17 elements.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果像plot{Groundhog Day}这样的变量让你想起哈希表元素，那是因为它们实际上就是哈希表的元素（见[第29章](chapter29.xhtml)）。你不需要理解数据结构就能理解这个模型，但在执行逻辑以为17部不同电影构建17个情节之后，plot哈希表包含了17个元素。*'
- en: The Intermediate Object
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中间对象
- en: In this model, the genre objects are all intermediate objects, with the *oComedy.bat*
    object being one example. It’s a child of *oMovie.bat*, but it also has children
    of its own, two of which are shown in [Figure 32-1](#fig32-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，所有的类型对象都是中间对象，*oComedy.bat*对象就是其中一个例子。它是*oMovie.bat*的子类，但它也有自己的子对象，其中两个在[图32-1](#fig32-1)中显示。
- en: '[Listing 32-2](#Lis32-2) shows the complete bat file object for *oComedy.bat*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表32-2](#Lis32-2)展示了完整的bat文件对象，*oComedy.bat*即为其中之一。'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 32-2: The intermediate object, oComedy.bat'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表32-2：中间对象，oComedy.bat
- en: At a glance, this looks to be structured much like the parent object, but there
    are differences. The very first line defines another bat file, and immediately
    after the traffic cop is a call command instead of an abort. The constructor also
    calls another bat file, and the setter and getter methods are missing along with
    the method to display information about a movie.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，这看起来和父对象的结构很相似，但也有不同之处。第一行定义了另一个批处理文件，紧接着交通警察之后的是一个调用命令，而不是中止命令。构造函数还调用了另一个批处理文件，并且设置器和获取器方法都缺失了，还有用于显示电影信息的方法也不存在。
- en: 'Strict object-oriented languages have reserved words and syntax allowing one
    object to seamlessly inherit from another. Not to be confused with Batch, this
    is how a child class would use the extends keyword to inherit from a parent in
    Java:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的面向对象语言有保留字和语法，允许一个对象无缝地继承另一个对象。与 Batch 不同，这就是子类如何使用 extends 关键字来继承 Java 中父类的方法：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Batch, without similar built-in syntax, we do it quite differently. The first
    statement in the *oComedy.bat* object defines the parent object bat file from
    which it inherits, namely, *oMovie.bat* ❶, which is also the object it extends.
    Then the traffic cop, looking much like the one in the parent object, has its
    own list of public methods maintained in the for command ❷. If the first parameter
    matches either of the two public methods in the list, the call command invokes
    it ❸. But where the parent class aborts when the method to be invoked isn’t public,
    the child object instead calls the parent class defined by extends, passing the
    same arguments along ❹. That’s inheritance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Batch 中，没有类似的内建语法，我们的做法是完全不同的。*oComedy.bat* 对象中的第一条语句定义了它继承的父对象批处理文件，即 *oMovie.bat*
    ❶，它也是它扩展的对象。然后，交通警察看起来和父对象中的差不多，维护着自己在 for 命令中的公共方法列表❷。如果第一个参数与列表中的两个公共方法匹配，调用命令就会调用它❸。但在父类中，如果要调用的方法不是公共的，它会中止，而子对象则会调用通过
    extends 定义的父类，传递相同的参数❹。这就是继承。
- en: An intermediate (and child) object can define its own methods not already in
    the parent object. It can also inherit the methods from the parent object by doing
    nothing more than what I’ve already shown. If the first parameter isn’t in the
    list of public methods, this bat file becomes a simple pass-through as it makes
    the identical call to the parent object ❹. The %* syntax ensures that the same
    parameter list received by this bat is the argument list passed to the parent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 中介（和子）对象可以定义父对象中尚未定义的方法。它还可以通过执行我已经展示的操作，继承父对象的方法。如果第一个参数不在公共方法列表中，这个批处理文件就成为一个简单的透传，因为它会做相同的调用传递给父对象❹。%*
    语法确保了这个批处理文件接收到的参数列表就是传递给父对象的参数列表。
- en: We’ll soon be able to call the important methods in the parent object (:DispInfo,
    :Set, and :Get) with the Batch inheritance just described. Elegantly, all of the
    genre objects and their children can easily use these methods. Not only does the
    intermediate object not have to reproduce them, but it doesn’t even need to mention
    them. And what happens when someone errantly passes this object a method not made
    public here or by its parent? The intermediate object passes it along, and the
    parent performs the error handling for all its children in one place.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就能通过刚才描述的批处理继承方法调用父对象中的重要方法（:DispInfo、:Set 和 :Get）。优雅的是，所有的类型对象及其子对象都可以轻松地使用这些方法。中介对象不仅不需要重现这些方法，甚至无需提及它们。如果有人错误地将一个未在此处或父对象中公开的方法传递给这个对象，会发生什么呢？中介对象会将其传递下去，父对象会在一个地方处理所有子对象的错误。
- en: This object does more than inherit methods from the parent. The constructor
    offers an example of *extending* a method already defined in the parent object.
    There is a :Constructor method in the parent, but the inheritance set up with
    the traffic cop doesn’t call it. Instead, the intermediate object’s :Constructor
    method ❺ supersedes it, but this doesn’t mean that we never invoke the parent
    constructor logic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象不仅继承了父对象的方法。构造函数展示了如何*扩展*父对象中已经定义的方法。父对象中有一个 :Constructor 方法，但是通过交通警察设置的继承方式并不会调用它。相反，中介对象的
    :Constructor 方法❺ 会覆盖它，但这并不意味着我们永远不会调用父对象的构造函数逻辑。
- en: The very first line of the :Constructor method calls the parent object to invoke
    its method of the same name, that is, its constructor. This is another built-in
    feature of traditional object-oriented languages that we must mimic. After calling
    the parent’s constructor, the derived object’s constructor puts its own spin on
    the data. Remember that the *oMovie.bat* object defined the movie as color and
    35mm in its constructor. Here the *oComedy.bat* object accepts those two values
    and also defines the genre as Comedy ❻. As we’ll soon see, its child objects will
    extend this even further.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: :Constructor方法的第一行调用父对象以调用其同名的方法，即构造函数。这是传统面向对象语言的另一个内置特性，我们必须模仿。在调用父类构造函数之后，派生对象的构造函数对数据进行处理。记住，*oMovie.bat*对象在其构造函数中将电影定义为色彩和35mm格式。这里，*oComedy.bat*对象接受这两个值，并将类型定义为喜剧❻。正如我们将很快看到的，它的子对象将进一步扩展这一点。
- en: Finally, notice two aptly named methods, one public ❼ and one private ❾. The
    private method isn’t listed in the traffic cop, so we can invoke it explicitly
    only from somewhere inside this bat file, such as from inside the public method
    ❽.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意两个恰如其名的方法，一个是公共的❼，另一个是私有的❾。私有方法没有列出在交通警察中，因此我们只能在此bat文件内部的某个地方显式调用它，例如从公共方法❽内部。
- en: The Child Objects
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子对象
- en: Finally, we come to the objects for the individual movies. [Listing 32-3](#Lis32-3)
    is the entire bat file for one movie object, *oBigLebowski.bat*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了每部电影的对象。[清单32-3](#Lis32-3)是一个电影对象的完整bat文件，*oBigLebowski.bat*。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 32-3: The child object, oBigLebowski.bat'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单32-3：子对象，oBigLebowski.bat
- en: The traffic cop ❸ at the top of this child object looks much like the one from
    the intermediate object, but it now extends the *oComedy.bat* object ❶, and the
    new title variable ❷ defines the movie. We’re passing the title to its parent
    object as the final argument ❹, where it’s used to set variables such as gauge{The
    Big Lebowski} in *oMovie.bat* and genre{The Big Lebowski} in *oComedy.bat*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子对象中的交通警察❸看起来很像中间对象中的交通警察，但它现在扩展了*oComedy.bat*对象❶，并且新的标题变量❷定义了电影。我们将标题作为最终参数❹传递给其父对象，在那里它被用来设置变量，例如在*oMovie.bat*中的gauge{The
    Big Lebowski}和在*oComedy.bat*中的genre{The Big Lebowski}。
- en: This child object has only one public method and no private methods, but it
    could easily have multiples of either type. (Since there’s only one entry in the
    list of public methods, we could remove the for command and leave just an if command.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子对象只有一个公共方法，没有私有方法，但它可以很容易地有多个任何类型的方法。（由于公共方法列表中只有一个条目，我们可以去掉for命令，只保留if命令。）
- en: The :Constructor method ❺ is even more interesting than the constructor in the
    intermediate object. It first calls the constructor of its parent, *oComedy.bat*
    ❻, and we’ve already seen that the constructor in the intermediate object will
    in turn call the constructor of its parent, *oMovie.bat*. Both parents set a variable
    or two before returning control to the constructor of the individual movie object
    where it sets everything that’s particular to its actual movie, such as the plot,
    star, and cast ❼.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: :Constructor方法❺比中间对象中的构造函数更有趣。它首先调用其父类的构造函数，即*oComedy.bat*❻，而我们已经看到中间对象中的构造函数将依次调用其父类的构造函数，即*oMovie.bat*。两个父类在返回控制权给单个电影对象的构造函数之前，都会设置一个或两个变量，在该构造函数中，设置与实际电影相关的所有内容，例如剧情、明星和演员阵容❼。
- en: We can now set up similar object bat files for other movies. Notice the differences
    and similarities between the previous object and the following object, *oLifeOfBrian.bat*,
    which contains data and a constructor method for another great film in [Listing
    32-4](#Lis32-4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为其他电影设置类似的对象bat文件。请注意之前的对象与以下对象之间的异同，*oLifeOfBrian.bat*，它包含了另一部伟大电影的数据和构造方法，见[清单32-4](#Lis32-4)。
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 32-4: The child object, oLifeOfBrian.bat'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单32-4：子对象，oLifeOfBrian.bat
- en: Both constructors are setting the plot, star, members of the cast, language,
    year of release, and country, but this one is also setting troupe{%title%} ❶.
    *The Life of Brian* was created by a comedy troupe, but this variable doesn’t
    apply to most other comedies. Each constructor is unique to a particular move
    and bat file; while it should define a certain set of variables in this model,
    it can contain additional logic pertinent to its movie, as the object demonstrates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两个构造函数都在设置剧情、明星、演员阵容、语言、上映年份和国家，但这个还在设置troupe{%title%}❶。*The Life of Brian*是由一个喜剧团体创作的，但这个变量不适用于大多数其他喜剧。每个构造函数对于特定的电影和bat文件都是独特的；虽然它应该在这个模型中定义一组特定的变量，但它可以包含与其电影相关的额外逻辑，正如该对象所展示的。
- en: I more than hinted earlier that you can override variables defined in the parent’s
    constructor in the child, and the child’s constructor is where that happens. For
    instance, the constructor in *oRagingBull.bat* would reset the clrOrBW{Raging
    Bull} variable to Black and White. Likewise, for a movie shot in something other
    than 35mm, such as digital, we can reset the gauge in the child’s constructor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经暗示过，你可以在子类中重写父类构造函数中定义的变量，而这一操作发生在子类的构造函数中。例如，*oRagingBull.bat* 中的构造函数会将`clrOrBW{Raging
    Bull}`变量重置为黑白。类似地，对于采用非35mm格式拍摄的电影，比如数字格式，我们可以在子类的构造函数中重置该参数。
- en: Another feature of object-oriented design is the ability of a child object to
    override methods defined in a parent class. You’ve seen methods inherited and
    extended. The constructor just discussed is a great example of extending a method.
    Now imagine that method without the call to its like-named method in its parent.
    That’s a *method override*. The child object will never call the public method
    in its parent object because the child has overridden it with a method of its
    own.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计的另一个特性是子对象能够重写父类中定义的方法。你已经看到了方法的继承和扩展。刚才讨论的构造函数就是扩展方法的一个很好的例子。现在想象一下，如果没有调用父类中同名的方法，这就是一个*方法重写*。子对象永远不会调用父类中的公共方法，因为子类已经用自己的方法重写了它。
- en: 'To demonstrate, let’s consider one last child object with this as the title
    variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们最后考虑一个子对象，它的标题变量如下：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If DispInfo is in the list of public methods defined for this particular child
    object, the coder of this object could add the following method to the bat file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`DispInfo`在此特定子对象的公共方法列表中，编写此对象的程序员可以将以下方法添加到批处理文件中：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A comment stating that this method is an override isn’t required, but it’s good
    form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 声明该方法是重写的方法并不是必需的，但这样做是良好的编码习惯。
- en: Notice that this method doesn’t invoke a corresponding method in its parent
    class. It simply writes a few lines of commentary, followed by a blank line, and
    does nothing more. It has completely superseded or overridden the like-named method
    in the parent class. Unlike other movies, this title won’t see the plot, cast,
    and other information written to the console as we’ve seen for other movies using
    the :DispInfo method in *oMovie.bat*. The author of this bat file obviously felt
    that something special was needed for the informational display for such a singular
    film. (Please, no hate mail; the original trilogy was fine, even better than fine.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该方法并没有调用其父类中对应的方法。它只是写了几行注释，接着是一个空行，什么也没有做。它完全取代或重写了父类中同名的方法。与其他电影不同，这个标题不会像我们在使用`:DispInfo`方法的其他电影中看到的那样，将情节、演员阵容和其他信息输出到控制台中。这个批处理文件的作者显然觉得，为如此独特的电影的显示信息需要一些特别的处理。（请不要发恨信；原版三部曲很好，甚至比好还要好。）
- en: Executing Object-Oriented Batch
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行面向对象批处理
- en: We’ve created the *oMovie.bat* parent object and the *oComedy.bat* intermediate
    object that extends or inherits from the parent. In theory, we could create more
    intermediate (or genre) objects and more than two million child objects for individual
    movies, but before us we have two child object bat files representing two comedies,
    each extending the *oComedy.bat* object. Finally, we can execute this object-oriented
    code. If nothing else, you can use the *Test.bat* file mentioned in [Chapter 31](chapter31.xhtml),
    but you need to place all calls to this code into a bat file not already in the
    model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`*oMovie.bat*`父对象和`*oComedy.bat*`中介对象，后者扩展或继承自父对象。理论上，我们可以创建更多的中介（或类型）对象，以及超过两百万个子对象用于个别电影，但眼前我们只有两个子对象的批处理文件，分别代表两部喜剧片，每部都扩展了`*oComedy.bat*`对象。最后，我们可以执行这段面向对象的代码。如果没有其他方法，你可以使用[第31章](chapter31.xhtml)中提到的`*Test.bat*`文件，但你需要将所有调用这段代码的操作放入一个不在模型中的批处理文件。
- en: 'The implementing code calls only the child objects; the parent and intermediate
    objects are called only from their children. Let’s start with these four commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现代码只调用子对象；父类和中介类对象仅通过其子类来调用。让我们从这四个命令开始：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that you must call the constructor before you can call any other method
    in an object. These first two commands are the Batch equivalent of instantiating
    objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，必须先调用构造函数，才能调用对象中的其他方法。这前两个命令是批处理中实例化对象的等效操作。
- en: We first call *oBigLebowski.bat*, and its traffic cop invokes its :Constructor
    method; as we’ve already seen, that constructor invokes the constructor method
    in its parent object, *oComedy.bat*, which invokes the corresponding method in
    its parent, *oMovie.bat*. Each of the three bat files contributes to the creation
    of the nine variables that describe this movie. Immediately after that, we do
    the same with *oLifeOfBrian.bat* to create a second set of movie variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用*oBigLebowski.bat*，它的交通警察调用了其:Constructor方法；正如我们已经看到的，那个构造函数又调用了其父对象*oComedy.bat*中的构造方法，再由*oComedy.bat*调用其父对象*oMovie.bat*中的相应方法。每个bat文件都为描述这部电影的九个变量的创建做出了贡献。接着，我们对*oLifeOfBrian.bat*执行相同的操作，创建第二组电影变量。
- en: The constructors don’t generate any output, but the last two call commands display
    the information shown in [Listing 32-5](#Lis32-5) to the console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不会生成任何输出，但最后两个调用命令会将[示例32-5](#Lis32-5)中显示的信息输出到控制台。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 32-5: Output from two DispInfo calls using two different child objects'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例32-5：使用两个不同子对象的两个DispInfo调用的输出
- en: The third command calls *oBigLebowski.bat*, passing DispInfo as its only argument.
    This child object doesn’t find a public method named :DispInfo, so the inheritance
    kicks in with a call to its parent, *oComedy.bat*, where the method also doesn’t
    exist. Once again because of inheritance, we call the base object, *oMovie.bat*,
    where we finally find and execute the public method. It displays a concise summary
    of information about *The Big Lebowski* to the console in seven lines of text.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个命令调用了*oBigLebowski.bat*，并将DispInfo作为唯一参数传入。这个子对象没有找到名为:DispInfo的公共方法，因此继承机制启动，调用它的父对象*oComedy.bat*，但该方法在*oComedy.bat*中也不存在。由于继承，再次调用基类对象*oMovie.bat*，最终找到了并执行了该公共方法。它会将关于*The
    Big Lebowski*的简要信息，以七行文本的形式显示在控制台上。
- en: The final command also shares a wealth of information, but about a different
    movie, because it calls the *oLifeOfBrian.bat* object. We are ultimately invoking
    the exact same method, :DispInfo, in the exact same object, *oMovie.bat*, but
    notice the stark differences in the output. The output describes two entirely
    different movies. That’s polymorphism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的命令也提供了大量信息，但关于的是另一部电影，因为它调用了*oLifeOfBrian.bat*对象。我们最终调用的是完全相同的方法:DispInfo，且在完全相同的对象*oMovie.bat*中，但请注意输出结果的显著差异。输出描述了两部完全不同的电影。这就是多态性。
- en: 'Batch has one critical and fairly unique characteristic that lends itself to
    the implementation of polymorphism: delayed expansion. Resolving variables is
    straightforward in most coding languages, but Batch allows you to resolve one
    or more variables to create a variable name that can then itself be resolved.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理具有一个至关重要且相当独特的特性，有助于实现多态性：延迟展开。在大多数编程语言中，解析变量是直接的，但批处理允许你解析一个或多个变量，以创建一个变量名，然后该变量名本身也可以被解析。
- en: Both sets of output come from the :DispInfo method in the parent object *oMovie.bat*
    ([Listing 32-1](#Lis32-1)). Taking just one variable as an example, delayed expansion
    first resolves the parameter embedded in !plot{%~1}! to be the movie title. In
    our first call, this results in !plot{The Big Lebowski}!, which then resolves
    to the plot of that movie. The second time through, this exact same code results
    in !plot{The Life of Brian}!, which resolves to a very different plot. This is
    Batch polymorphism at its finest.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两组输出都来自父对象*oMovie.bat*中的:DispInfo方法（[示例32-1](#Lis32-1)）。以一个变量为例，延迟展开首先将嵌入的参数!plot{%~1}!解析为电影标题。在第一次调用中，这会得到!plot{The
    Big Lebowski}!，然后解析为该电影的情节。第二次调用时，完全相同的代码会得到!plot{The Life of Brian}!，这时解析为完全不同的情节。这就是批处理的多态性表现。
- en: 'Whoever wrote the *oBigLebowski.bat* object left an Academy Award–winning actor
    off the cast list. The late Philip Seymour Hoffman had a relatively small role
    as the title character’s smug toady of a personal assistant, Brandt, but he played
    it with a brilliance and nuance that foretold greater roles. The following two
    commands add him to the current cast:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编写*oBigLebowski.bat*对象的人在演员名单中遗漏了一位奥斯卡获奖演员。已故的菲利普·塞默·霍夫曼在电影中扮演了一个相对较小的角色，他是标题角色的傲慢私人助理Brandt，但他以精湛的演技和细腻的表现力预示着未来更大的角色。以下两个命令将他加入当前的演员名单：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument of both call commands is the name of the method to be invoked,
    and the second argument is the type of variable pertinent to the call, which is
    cast in both instances. The first command will Get the current cast members, returning
    the value as the contents of the lebowCast variable. The second command will Set
    (or reset) the list of current cast members to the just-returned value concatenated
    with Mr. Hoffman’s full name. If you were to invoke the *oBigLebowski.bat* object
    again with the DispInfo argument, you’d see all four actors included in the cast
    as opposed to the three in [Listing 32-5](#Lis32-5).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 两个调用命令的第一个参数是要调用的方法名称，第二个参数是与调用相关的变量类型，并且在这两种情况下都会进行类型转换。第一个命令会获取当前的演员阵容，并将其作为lebowCast变量的内容返回。第二个命令会将当前演员阵容的列表设置（或重置）为刚刚返回的值，并附加上霍夫曼先生的全名。如果你再次调用*oBigLebowski.bat*对象，并传入DispInfo参数，你将看到演员阵容中包含四位演员，而不是[示例32-5](#Lis32-5)中列出的三位。
- en: Recommendations
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐
- en: To keep this complex example as comprehendible as possible, I’ve resisted the
    mention of some possible tweaks, up until now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个复杂的例子尽可能易于理解，我一直没有提到一些可能的调整，直到现在。
- en: I shared that strict OOP dictates that you must invoke the constructor before
    you can use an object. This model leaves that restriction to the honor system,
    but you can remedy the issue with an “instantiated” switch. First, the child constructor
    would set the switch when it executes. Then you could interrogate that switch
    before any attempt to invoke a public method, throwing an abort if it hasn’t yet
    been set. This is almost certainly overkill, but it wouldn’t be difficult (or
    elegant). I prefer the honor system here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾分享过严格的OOP要求在使用对象之前必须先调用构造函数。这个模型将这一限制留给了自律系统，但你可以通过一个“实例化”开关来解决这个问题。首先，子对象的构造函数在执行时会设置这个开关。然后，在尝试调用公共方法之前，你可以检查这个开关，如果它还没有被设置，则抛出一个中止错误。这几乎肯定是大材小用，但实现起来既不困难也不优雅。我更倾向于这里使用自律系统。
- en: I never used the comedy troupe variable set for the Monty Python film, but you
    can define a :DispInfo method in the *oLifeOfBrian.bat* object to extend the like-name
    method from *oMovie.bat*. After the child calls to inherit the display performed
    by its parent (or parent’s parent), it can append a similar line for the troupe.
    Even better yet, since a troupe applies only to some comedies, the new method
    could go into the *oComedy.bat* object, where you’d display the troupe only if
    it exists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未在《蒙提·派森》电影中使用过喜剧团体的变量集，但你可以在*oLifeOfBrian.bat*对象中定义一个:DispInfo方法，以扩展来自*oMovie.bat*的同名方法。子对象在调用以继承父对象（或父对象的父对象）执行的显示方法后，它可以为喜剧团体附加类似的行。更好的是，由于喜剧团体只适用于某些喜剧类，新的方法可以放入*oComedy.bat*对象中，在那里只有在团体存在时才会显示。
- en: The most significant element of OOP that we haven’t successfully duplicated
    in Batch is data hiding. When a variable is set, it’s available in the environment
    until it’s reassigned or the process ceases, and there’s no realistic means of
    preventing its reassignment by some other code. We can use the setlocal and endlocal
    commands to hide variables, but after the execution of the endlocal command, the
    variables will be lost into the ether. As I mentioned in [Chapter 16](chapter16.xhtml),
    variables can survive an endlocal command, but doing so would make them available
    globally, and that doesn’t lend itself to “data hiding.” We could hide the variables
    in a temporary file and restore them the next time through the code, but this
    most definitely is overkill.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中最重要的元素是我们未能在Batch中成功复制的数据隐藏。当设置一个变量时，它会在环境中存在，直到重新赋值或进程终止，而且没有现实的手段来防止它被其他代码重新赋值。我们可以使用setlocal和endlocal命令来隐藏变量，但在执行endlocal命令后，这些变量会消失。正如我在[第16章](chapter16.xhtml)中提到的，变量可以在endlocal命令后存活，但这样做会使它们变为全局变量，这就违背了“数据隐藏”的原则。我们可以将变量隐藏在临时文件中，并在下一次通过代码时恢复它们，但这无疑是大材小用。
- en: Not being able to declare private variables is a limitation that precludes the
    ability to make a Batch object available to a great number of users, as is the
    case with other languages. But let’s take a step back to gain some perspective.
    Making an object generally available for the masses is not part of the design
    I’m positing; this is Batch, and there’s no realistic infrastructure for something
    on that type of scale anyway.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 无法声明私有变量是一个限制，这使得Batch对象无法像其他语言那样广泛适用于众多用户。但是，让我们退一步来看一下整体情况。将一个对象普遍提供给大众并不是我所设计的目标；这是Batch语言，并且无论如何也没有实际的基础设施来支持那种规模的应用。
- en: I’m suggesting the building of objects for use by oneself and maybe a small
    group of friends or co-workers working on the same network. This isn’t something
    you’d want to make callable from a web service. Thus, the only real ramification
    of not being able to hide data is that a small cohort of coders must be aware
    that they shouldn’t step on the variables used in certain objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议构建面向自己使用的对象，可能是与少数朋友或同事在同一网络上合作时使用。这并不是你希望从 Web 服务中调用的东西。因此，无法隐藏数据的唯一实际后果是，少数开发人员必须意识到他们不应该干扰某些对象中使用的变量。
- en: Batch object-oriented design is a methodology that I highly recommend. You might
    not implement it as extensively as in the model that I’ve presented here, nor
    should you. (More on this in the next and final chapter.) Even just portions of
    this methodology may very well be useful to you. Even without the use of inheritance,
    you can write a module with polymorphic code that behaves differently based on
    the caller. A simplified version of inheritance might rely on one central bat
    file for a few important tasks. Just writing small and reusable modules is redolent
    of object-oriented design and is an enormous step forward.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 批量面向对象设计是一种我强烈推荐的方法论。你可能不会像我在这里展示的模型那样广泛地实现它，也不应该这样做。（更多内容将在下一章和最后一章讨论。）即使只采用该方法论的一部分，对你来说也可能非常有用。即便没有使用继承，你也可以编写一个具有多态性的模块，它会根据调用者的不同而表现出不同的行为。继承的简化版本可能依赖于一个中央的批处理文件来执行一些重要任务。仅仅编写小型且可重用的模块，就能带有面向对象设计的气息，且是一个巨大的进步。
- en: The Four Pillars in Batch
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量中的四大支柱
- en: You’ve already seen that in this Batch model we’ve been able to simulate many
    of the characteristics of OOP surprisingly well. Let’s step through each of the
    four pillars one more time, detailing how close we’ve actually come to our goal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了，在这个批量模型中，我们能够出奇地好地模拟面向对象编程（OOP）的许多特征。让我们再仔细看看四个支柱，详细说明我们实际上距离目标有多近。
- en: Abstraction, the first pillar, simplifies the code’s interface, shows only the
    necessary or relevant features, and shields implementation details. Take another
    look at the two complete child objects in Listings 32-3 and 32-4\. The methods
    to get and set variables, along with the method to display movie information,
    have all been abstracted away. Other than the logic at the top of each object
    listing public methods and handling the inheritance, there’s really just a single
    method, the constructor, and everything in it is pertinent to the object. Abstraction
    in Batch object-oriented design gets high marks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象，作为第一个支柱，简化了代码的接口，只展示必要或相关的特性，并且隐藏了实现细节。再看一下列表 32-3 和 32-4 中的两个完整的子对象。获取和设置变量的方法，以及显示电影信息的方法，都已经被抽象化了。除了每个对象顶部列出公共方法并处理继承的逻辑外，实际上只有一个方法，即构造函数，且其中的所有内容都与该对象相关。批量面向对象设计中的抽象获得了很高的评价。
- en: Smaller, more plentiful modules present a superior design regardless of the
    language or coding methodology. Each file has a distinct purpose, and the code
    is more maintainable and extensible. The model I’ve shown in this chapter lends
    itself to writing short, compact, and reusable code modules, and this is one of
    three components that define the second pillar, encapsulation, along with data
    and method hiding. Method hiding is trivial in Batch; in fact, we had to do some
    work to expose public methods. Data hiding, however, isn’t supported at all in
    this model. All of the variables set for all of the different movies float around
    the environment for anyone to modify at any time. Two out of three is a passing
    grade.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更小、更丰富的模块呈现了更优的设计，无论使用什么语言或编码方法。每个文件都有明确的目的，代码更加易于维护和扩展。我在本章中展示的模型有助于编写简短、紧凑且可重用的代码模块，这也是定义第二个支柱——封装的三个组成部分之一，另外两个组成部分是数据和方法隐藏。在批量中，方法隐藏是微不足道的；实际上，我们不得不做一些工作来暴露公共方法。然而，在这个模型中，数据隐藏根本不被支持。所有为不同电影设置的变量都在环境中浮动，任何人都可以随时修改它们。三项中的两项已经及格。
- en: Examples of inheritance, the third pillar, are strewn throughout the previous
    pages. Child objects are inheriting constructors from intermediate objects, which
    in turn inherit the same from parent objects. The method for displaying information
    to the console and the setter and getter methods are all quality examples of inheritance.
    We coded them once in the parent object for use by up to two million child objects.
    I’ve even demonstrated how to override a method in a child object. We need a bit
    of redundant code at the top of each bat file to make this work, but this model
    clearly scores near the top of its class when it comes to inheritance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的示例，第三个支柱，散布在前面的页面中。子对象继承了中介对象的构造函数，而中介对象又继承了父对象的构造函数。显示信息到控制台的方法，以及设置器和获取器方法，都是继承的典型例子。我们在父对象中编写了一次这些方法，供多达两百万个子对象使用。我甚至展示了如何在子对象中重写一个方法。为了使其工作，我们在每个
    bat 文件的顶部需要一些冗余代码，但在继承方面，这个模型显然在同类中名列前茅。
- en: The fourth pillar, polymorphism, allows code to behave differently in different
    situations, with the method displaying movie information being a prime example
    of this functionality. We use a single method in a single bat file to write the
    unique information for a couple million movies—and two of those variables displayed
    were originally set in the parent object’s polymorphic constructor. The setter
    and getter method take this a step further. Traditional OOP requires a pair of
    these methods for each and every defined variable. In this model, a single setter
    and a single getter handle all variables for each and every individual movie object.
    Batch polymorphism is what many students call a *curve buster*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个支柱，多态，允许代码在不同情况下表现出不同的行为，显示电影信息的方法就是这一功能的一个典型示例。我们在一个单一的 bat 文件中使用单一的方法，写入几百万部电影的独特信息——其中显示的两个变量最初是在父对象的多态构造函数中设置的。设置器和获取器方法更进一步推动了这一过程。传统的面向对象编程（OOP）要求为每个已定义的变量提供一对这样的设置器和获取器方法。在这个模型中，一个设置器和一个获取器处理每个电影对象的所有变量。批处理的多态性是许多学生称之为*曲线破坏者*的东西。
- en: I’ll leave it to you, the reader, to give this model a final grade. I’ll concede
    that due to the lack of data hiding, the mark of an A is out of reach, but I hope
    not too far out of reach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把最终评分留给你，读者。我承认，由于缺乏数据隐藏，A 的分数是无法达到的，但我希望它并不太遥不可及。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Was Batch designed as an object-oriented language? Not a chance. Is it possible
    to build much of object-oriented design—that is, abstraction, encapsulation, inheritance,
    and polymorphism—in bat files? Absolutely. Can Batch object-oriented design achieve
    the efficiency and scale of other languages? No. After reading this chapter, how
    many Batch coders will propose an enterprise-wide object-oriented project to their
    employer? Not many. If that number is greater than zero, how many will still be
    employed in three months? Most assuredly none. How many coders will try to incorporate
    elements of Batch object-oriented design into their code? Hard to say, but I’m
    hoping for quite a few.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理语言是作为面向对象的语言设计的吗？绝对不是。那么，是否可以在 bat 文件中构建面向对象设计的大部分内容——即抽象、封装、继承和多态？完全可以。批处理的面向对象设计能否达到其他语言的效率和规模？不能。在阅读完本章之后，多少批处理程序员会向他们的雇主提出一个全公司的面向对象项目？不多。如果这个数字大于零，那么有多少人能在三个月后继续留在公司？毫无疑问，没人能留下来。多少程序员会尝试将批处理面向对象设计的元素融入他们的代码中？很难说，但我希望能有不少人。
- en: 'Object-oriented design is this book’s dénouement, so why is this merely the
    penultimate chapter of the book? In the next and final chapter, I’ll introduce
    two data structures: stacks and queues. But I’ll also use these data structures
    as an opportunity to further demonstrate object-oriented design, because this
    discussion is far from complete. The model I’ve detailed in this chapter implements
    every possible object-oriented design principle, but it isn’t how I usually code
    Batch objects. It’s better to use only what’s needed and not what isn’t. When
    building stacks and queues in the next chapter, you’ll see real-world objects
    for each, and I’ll also share some final thoughts about Batch object-oriented
    design.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计是本书的结局部分，那么为什么它仅仅是本书的倒数第二章呢？在接下来的最后一章，我将介绍两种数据结构：栈和队列。但我也将利用这些数据结构作为进一步展示面向对象设计的机会，因为这部分讨论远未完成。我在本章中详细描述的模型实现了所有可能的面向对象设计原则，但它并不是我通常编写批处理对象的方式。最好只使用所需的内容，而不是不需要的内容。在下一章构建栈和队列时，你将看到每种数据结构对应的实际对象，我还会分享一些关于批处理面向对象设计的最终想法。
