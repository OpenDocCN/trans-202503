## **9**

**BORDER AND BOX EFFECTS**

![Image](graphics/common-01.jpg)

The ability to add borders to page elements has been around, almost unchanged, since the days of CSS1\. What developers *wanted* to do with borders, however, outstripped what they *could* do with them years ago. Adding border effects like rounded corners or shadows has probably been responsible for more extraneous empty markup elements than almost anything else in the web development world. Things that should have been simple often involved some incredibly complex workarounds.

The second part of our look at the Backgrounds and Borders Module explores new methods of decorating elements without extra markup. You’ll learn how to make rounded corners, use images for borders, and add drop shadows.

### **Giving Your Borders Rounded Corners**

Since the earliest days of the Web, designers have been putting rounded corners on page elements. That they’ve had no way to create them without using images seems crazy. To create a box of flexible width with four rounded corners has meant creating four images and adding at least two extra nonsemantic elements, which made maintaining a website much harder than it needed to be.

But no more. The Backgrounds and Borders Module introduces a way to round the corners of your elements using CSS alone. Each corner is treated as a quarter ellipse, which is defined by a curve that is drawn between a point on the *x*-axis and a point on the *y*-axis (you may remember those from [Chapter 6](ch06.html#ch06)). [Figure 9-1](ch09.html#ch09fig1) illustrates this more clearly.

A quarter ellipse can be *regular*, which means the length along both axes is the same, or *irregular*, which means the length along each axis is different. [Figure 9-2](ch09.html#ch09fig2) shows examples of both.

![Image](graphics/f09-01.jpg)

*Figure 9-1: A quarter ellipse made by the curve between lengths on the* x-*and* y*-axes*

![Image](graphics/f09-02.jpg)

*Figure 9-2: A regular curve (left) has identical values on both axes; an irregular curve has different values on each axis.*

CSS3 defines these curves using the `border-radius` property. With this property, you can define the radius of the quarter ellipse simply, using the following syntax:

```
E { border-v-h-radius: x y; }
```

In this syntax, `*v*` is a keyword value of `top` or `bottom`; `*h*` is a keyword value of `left` or `right`; and the `*x*` and `*y*` values are lengths along the axes that define the curve of the quarter ellipse. That sounds like a mouthful, but here’s an example that should make it clearer:

```
div { border-top-right-radius: 20px 20px; }
```

This syntax will round the top-right corner of a `div` element with a radius of 20px horizontally and vertically, which is a regular curve.

In fact, for regular curves, `border-radius` lets you simplify even further by leaving out either the `*x*` or the `*y*` value; if one value is not specified, both are assumed to be equal. So if you want to apply that radius to each corner of your element, you use this code:

```
div {
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    border-bottom-left-radius: 20px; }
```

To create a shape with irregular rounded corners, you just use different values on the individual properties:

```
div {
    border-top-left-radius: 10px 20px;
    border-top-right-radius: 10px 20px;
    border-bottom-right-radius: 10px 20px;
    border-bottom-left-radius: 10px 20px;
}
```

You can compare the two different code examples in [Figure 9-3](ch09.html#ch09fig3): the shape on the left uses the first snippet and has four regular curved corners, and on the right is the result of the second snippet with four (equal) irregular corners.

![Image](graphics/f09-03.jpg)

*Figure 9-3: Two elements, one with regular rounded corners (left) and one with irregular corners (right)*

#### ***The border-radius Shorthand***

If having to write a different property for each corner strikes you as quite repetitive, you’ll be happy to learn that a shorthand property is available. As with `border-width`, `margin`, and `padding`, you can specify one, two, three, or four values. Where those values refer to sides, however, the `border-radius` values refer to corners, starting at the top left:

```
E { border-radius: [top-left] [top-right] [bottom-right] [bottom-left]; }
E { border-radius: [top-left] [top-right & bottom-left] [bottom-right]; }
E { border-radius: [top-left & bottom-right] [top-right & bottom-left]; }
E { border-radius: [top-left & top-right & bottom-right & bottom-left]; }
```

So if I want to apply a value of 20px to the top-left and top-right corners of a `div`, and 10px to the bottom-right and bottom-left corners, here’s the code I use:

```
div { border-radius: 20px 20px 10px 10px; }
```

**NOTE**
*Using the shorthand syntax like this only creates regular rounded corners; I’ll cover the shorthand for irregular corners momentarily.*

To illustrate the shorthand property in action, I’ll apply rules to three elements, each time with a different set of values:

```
.radius-1 { border-radius: 0 20px; }
.radius-2 { border-radius: 0 10px 20px; }
.radius-3 { border-radius: 0 0 20px 20px; }
```

You can see the results in [Figure 9-4](ch09.html#ch09fig4). The first (left) box has two values for `border-radius`: The top-left and bottom-right corners have a value of 0, so are square, but the top-right and bottom-left are rounded with a radius of 20px. The second (middle) box has three values: The top-left corner is once again square, but now the top-right and bottom-left corners have a 10px radius, and the bottom-right corner has a value of 20px. Finally, the third (right) box has four values: The top-left and top-right corners have a value of 0, so are squared, whereas the bottom-right and bottom-left have radii of 20px.

![Image](graphics/f09-04.jpg)

*Figure 9-4: Effects of different values for the* `*border-radius*` *shorthand property*

You can also use the shorthand syntax with irregular curves. To achieve this effect, you list the values separated by a slash (`/`):

```
border-radius: { horizontal-radius / vertical-radius; }
```

Each side of the slash can contain between one and four values, as with the shorthand for regular curves. This means, for example, you could have one value for the horizontal radius and four separate values for the vertical radii. Again, I’ll illustrate what this looks like with some examples:

```
.radius-1 { border-radius: 20px / 10px; }
.radius-2 { border-radius: 20px / 10px 20px; }
.radius-3 { border-radius: 10px 20px 20px / 20px 10px; }
```

[Figure 9-5](ch09.html#ch09fig5) shows the results. The first (left) box has four equal corners of 20px horizontal and a 10px vertical radius. The second (middle) box has two corners of 20px/10px and two of 20px/20px. The third (right) box has a top-left corner of 10px/20px, a top-right and a bottom-left corner of 20px/10px, and a bottom-right corner of 20px/20px.

![Image](graphics/f09-05.jpg)

*Figure 9-5: Irregular rounded corners produced with the* `*border-radius*` *shorthand property*

#### ***Using Percentage Values***

The examples so far in this chapter use length units, but you can also define `border-radius` using a percentage value, which is the percentage of the length of the side of the element it’s applied to. You’ll find this especially handy if you want to make a perfect circle in CSS: A square element with four equal curves of half of each side creates a perfectly round element.

The next example shows two elements with the same percentage `borderradius` value (50%) applied to each corner. Both have the same height, but one is twice as wide as the other:

```
div {
    border-radius: 50%;
    height: 100px;
    }
.ellipse { width: 200px; }
.circle { width: 100px; }
```

The result is shown in [Figure 9-6](ch09.html#ch09fig6). The element on the left has the wider length, so the rounding of the corners creates an ellipse. On the right, the element has equal height and width, resulting in a perfect sphere.

![Image](graphics/f09-06.jpg)

*Figure 9-6: Percentage values on* `*border-radius*` *create an ellipse (left) and a circle (right).*

### **Using Images for Borders**

Another common way to style elements is to use background images as decorative borders. With CSS2, however, you had no way to achieve this, and you had to use a lot of extra markup to get the desired effect, with a subsequent penalty on semantics and maintainability. CSS3 introduces a series of properties that provide a simple syntax to apply decorative borders.

#### ***border-image-source***

The first property, `border-image-source`, sets the source of the image that will be used for the border—but you probably guessed that. It takes a single value, which is an image data type; for most browsers that’s only the `url()` function. Here’s an example of `border-image-source`:

```
E { border-image-source: url('foo.png'); }
```

**NOTE**
*This property should also accept gradient functions (see [Chapter 11](ch11.html#ch11)) as values, but currently only Chrome and Firefox support that use.*

#### ***border-image-slice***

Once you have the source of the image for the border, you need to slice it. The `border-image-slice` property accepts between one and four values, each of which maps to a side of an element, similar to `margin`, `padding`, `border-radius`, and so on. These values are used to set a distance from each edge of the image, marking the area used to “frame” the element.

I’m aware that’s probably a little confusing, so I’ll explain with an example. Take a look at this code:

```
E { border-image-slice: 34; }
```

Note here that no units are used on the number value. The number serves two purposes: for bitmap images (such as JPG or PNG), the units are pixel values; but for vector images (such as SVG), they are coordinate values. You could also use percentage values as an alternative.

In my example code, I provided only a single value, which sets the area I want to slice: 34px from the top, right, bottom, and left. Take a look at [Figure 9-7](ch09.html#ch09fig7), which shows how this value is used to divide the source image into nine segments: four corners (c1, c2, and so on), four sides (known as *slices*—slice1, slice2, and so on), and the central fill. Each of these slices will be placed onto the border of a target element in the equivalent positions.

With the source image and slices defined, now I just have to set a border on the element to apply a border image. The image will be applied to the area created by the border, so in the following code example, I define a 34px border on the top and bottom, and 10px on the left and right.

```
E {
   border: 34px 10px;
   border-image-slice: 34;
   border-image-source: url('foo.png');
}
```

![Image](graphics/f09-07.jpg)

*Figure 9-7: Where the specified values in* `*border-image*` *will slice the image*

You can see in [Figure 9-8](ch09.html#ch09fig8) how this code is applied: the top and bottom image slices have the same height as the top and bottom borders, so the image is applied at its natural height, whereas the left and right slices are applied to borders that are less than half their width, so the image is squashed to fit. The corner slices are distorted to fit the two different dimensions.

![Image](graphics/f09-08.jpg)

*Figure 9-8: Here, 34px image slices are applied to a border of 34px horizontally and 10px vertically.*

The default behavior of border images is to use only the slices and corners on the border, leaving the center of the element blank for its own background properties to be shown. The `border-image-slice` property has an optional keyword value of `fill`, however; if the `fill` keyword is included, the area of the image inside the slices will be applied over the background of the element in the appropriate place.

```
E { border-image-slice: value fill; }
```

[Figure 9-9](ch09.html#ch09fig9) shows a comparison of an element with a border image, with and without the `fill` keyword.

**NOTE**
*Filling the element with* `*border-image-slice*` *means you have no control over the fill sizing and can leave it quite distorted, so consider carefully if you want to use this rather than* `*background-image*`.

![Image](graphics/f09-09.jpg)

*Figure 9-9: Left to right: the source image, applied as a border image, and with the* `*fill*` *keyword value*

#### ***border-image-width***

As you saw in [Figure 9-8](ch09.html#ch09fig8), border image slices are stretched or condensed to fit the width of the element’s border; for example, if the element has a border that’s 10px wide but your slices are 40px wide, each slice will be condensed to a quarter of its height or width in order to fit. You can control this by using the `border-image-width` property:

```
E { border-image-width: value; }
```

Like `border-width` or `border-image-slice`, the *value* here can actually be up to four values, to match the sides of the element, and each can be a length, a percentage, or a unitless number.

The `*value*` creates a “virtual” border on the element, by which I mean it has no impact on page layout or flow; unlike `border-width`, the border that `*value*` creates is visual only and has no effect on the box model. To illustrate the difference, take a look at this code:

```
E { border-width: 34px; }
F {
  border-width: 1px;
  border-image-width: 34px; }
E, F {
  border-image-slice: 34;
  border-image-source: url('foo.png'); }
```

You can see how this compares in [Figure 9-10](ch09.html#ch09fig10): The element on the left has a border of 34px on each side and no explicit `border-image-width` value, so the text content starts inside the border as you’d expect; the element on the right, however, has only a 1px border but a `border-image-width` value of 34px. Although the image slices are applied in the same way, the text content sits over the top of the “virtual” border in the element on the right.

![Image](graphics/f09-10.jpg)

*Figure 9-10: Comparing a* `*border-width*` *value of 34px (left) with a* `*border-image-width*` *value of 34px (right)*

If you use a unitless number it acts as a multiplier of an existing `border-width` value; in the following code, the `border-image-width` will be equivalent to 20px:

```
E {
  border-width: 10px;
  border-image-width: 2;
}
```

#### ***border-image-outset***

By default, a border image starts displaying from the outside of the border box, moving in toward the content box; but you can change this default behavior by outsetting the image to start from outside the border box. You do this with the `border-image-outset` property, which takes (the by now customary) four possible length values, one for each side. For example, to outset the border image by 10px from the top and bottom and 5px from the left and right, you use this rule:

```
E { border-image-outset: 15px 30px; }
```

You can see a comparison of this in [Figure 9-11](ch09.html#ch09fig11); the element on the left has the default `border-image-outset` value of 0, whereas the element on the right has the value shown in the code example; although each has an identical box size, the border image on the right is greatly outset from the content (and even overlaps the element on the left).

![Image](graphics/f09-11.jpg)

*Figure 9-11: The element on the right has an outset border image.*

#### ***border-image-repeat***

One more property is related to border images: `border-image-repeat`. This property controls how the image fits the length of each side between the corners:

```
E { border-image-repeat: keyword; }
```

It accepts one of three keyword values: `stretch` (the default), `repeat`, and `round`. All of the example illustrations so far in this chapter used the default value (`stretch`), where the image slice is stretched to fill the length of the border. Using `repeat` applies the slice at its natural length, repeating the slice until it fills the length of the border it is applied to; so the slice could be cut off if it didn’t fit into the length a whole number of times. The final value, `round`, behaves like `repeat` except it scales the slice up or down to best fit the length of the border, without being cut off.

That’s easier done than said, so you can see the difference in these three values in [Figure 9-12](ch09.html#ch09fig12). These three elements have the same values applied to all of the `border-image` properties, except for `border-image-repeat`. For this property, the first element has the default value, `stretch`; the second, `repeat`; and the final element, `round`.

![Image](graphics/f09-12.jpg)

*Figure 9-12: Different* `*border-image-repeat*` *values: (from left to right)* `*stretch*`, `*repeat*`, `*round*`

I said a few paragraphs ago that `border-image-repeat` accepts one of three keyword values, but that’s not actually correct; I only said it to make the subsequent explanation a little clearer. I hope you can forgive me for misleading you. In fact, you can use two of the three keyword values on the property; the first controls horizontal repetition, the second, vertical. So if you want to stretch your element along the top and bottom borders and round it along the left and right, you use this rule:

```
E { border-image-repeat: stretch round; }
```

#### ***The border-image Shorthand Property***

To save time and keystrokes, you can use the `border-image` shorthand for all of the properties just described. The syntax looks like this:

```
E { border-image: source slice / width / outset repeat; }
```

The following code example shows all of the individual properties applied to an element and then the same properties applied to another element using the shorthand property:

```
E {
  border-image-source: url('foo.png');
  border-image-slice: 25 10 fill;
  border-image-width: 25px 10px;
  border-image-outset: 5px;
  border-image-repeat: round; }
F { border-image: url('foo.png') 25 10 fill / 25px 10px / 5px round; }
```

That’s quite the space saver.

#### ***Browser Support***

All of the `border-image` properties in this section are supported in Chrome, Firefox, Safari 6+, and Internet Explorer 11+. Some older browsers—notably mobile Safari 5.1 and below, and the stock browser in Android 4.3 and below—do support border images, but only using the `border-image` shorthand and, even then, without the `border-image-width` and `border-image-outset` properties.

### **Drop Shadows**

In [Chapter 6](ch06.html#ch06), we looked at a way to add drop shadows to text with the `text-shadow` property, but CSS3 also has a method for adding shadows to box elements. You use the `box-shadow` property; the syntax is similar to that of `text-shadow`:

```
E { box-shadow: inset horizontal vertical blur-radius spread color; }
```

The first value, `inset`, is an optional keyword that sets whether the shadow sits inside or outside of the element. I explain this in more detail in the next section; for now, all you need to know is that if `inset` is not specified, the shadow sits outside the element. The next two values are, just as with `text-shadow`, lengths that set the `*horizontal*` and `*vertical*` distance of the shadow from the box; if you want to have a shadow, these values are required.

The next value sets the `*blur-radius*` and is another length value and, again, works exactly as in `text-shadow`. Then you have `*spread*`, yet another length value, which sets the distance the shadow spreads. A positive length makes the shadow larger than its element, and a negative length makes it smaller. Both `*blur-radius*` and `*spread*` are optional.

Finally you have the `*color*` value, also optional, which, if left unspecified, defaults to the inherited color (usually black).

Now I’ll put these together in an example. The next code snippet creates a dark-gray shadow outside of the element, positioned at a distance of 4px, both horizontally and vertically, with a blur radius of 3px:

```
div { box-shadow: 4px 4px 3px #666; }
```

In the next code snippet, I demonstrate further examples of the effects of different values on the `box-shadow` property. The results are shown in [Figure 9-13](ch09.html#ch09fig13).

```
.shadow-one { box-shadow: 4px 4px; }
.shadow-two { box-shadow: 4px 4px 3px; }
.shadow-three { box-shadow: 12px 12px 2px -6px; }
.shadow-four { box-shadow: #999 4px -4px 2px 0; }
.shadow-five { box-shadow:
    #999 4px -4px 2px 0,
    -4px 4px 2px;
}
```

![Image](graphics/f09-13.jpg)

*Figure 9-13: The effects of using different values for the* `*box-shadow*` *property*

The elements in the code correspond to the boxes in [Figure 9-13](ch09.html#ch09fig13), moving from left to right. The first is the simplest shadow, simply distanced 4px both horizontally and vertically from the element, using the inherited color. The second has the same distance values as the first but also adds a blur radius of 3px to soften the shadow’s edges. The third has a distance of 12px along both axes but a negative spread value (−6px), which makes the shadow smaller than its box. The fourth example has a medium gray–colored shadow with a negative vertical distance, meaning the shadow falls above the element instead of below it.

The fifth box has two shadows applied to it, with each set of values separated by a comma. The first value set is the same as in the fourth box, and the second makes a black (or inherited color) shadow with a negative horizontal distance, causing the shadow to fall to the left of the box.

### **Inset Shadows**

I briefly mentioned the optional `inset` keyword at the beginning of the previous section. If present, this keyword draws a shadow on the interior of the box, but it also has the effect of “flipping” the shadow to the other side of the box. What I mean is that where a regular—that is, *outset*—shadow with positive *x* and *y* values would appear at the bottom right of the box, an inset shadow would appear at the top left.

To illustrate, I’ll use the same code as for the previous example but add the `inset` keyword to each one:

```
.shadow-one { box-shadow: inset 4px 4px; }
.shadow-two { box-shadow: inset 4px 4px 3px; }
.shadow-three { box-shadow: inset 12px 12px 2px -6px; }
.shadow-four { box-shadow: inset #999 4px -4px 2px 0; }
.shadow-five { box-shadow:
    inset #999 4px -4px 2px 0,
    inset -4px 4px 2px;
}
```

The result is shown in [Figure 9-14](ch09.html#ch09fig14), and as you can see, it’s almost the inverse of [Figure 9-13](ch09.html#ch09fig13); all offset, blur radius, and color values are the same, but the shadows now appear on the interior of the boxes, and in the opposite corners.

![Image](graphics/f09-14.jpg)

*Figure 9-14: Inset shadows*

The `box-shadow` property is broadly implemented, with unprefixed support in IE9+ and all other modern browsers. The `-webkit-` prefix is required for older versions of Safari for iOS and the stock Android browser.

### **Summary**

I mentioned at the beginning of the previous chapter that the Backgrounds and Borders Module became a priority for the W3C because of the clamor from web developers. The new properties it introduces are extremely handy for removing extraneous elements used as containers for purely visual styling from markup, giving developers finer control over the way pages are presented. With a multitude of new background and border properties at our disposal, creating websites that can be viewed at many different sizes and resolutions is going to be much easier, and our sites will be more suited to the cross-platform ideal of the age.

In the next chapter, I continue with the theme of page decoration, as we take a look at the new color and opacity controls that CSS3 provides.

### **Border and Box Effects: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| `border-radius` | Yes | Yes | Yes | Yes |
| `border-image` | Yes | Yes | Yes | IE11 |
| `box-shadow` | Yes | Yes | Yes | Yes |