<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="27" id="Page_27"/>2</span><br/>
<span class="ChapterTitle">Working with Preexisting Images</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c02-0001" class="HeadProject"><span><span epub:type="pagebreak" title="28" id="Page_28"/>Sketch 13: Loading and Displaying an Image</span></h2>
<p class="BodyFirst">Images are everywhere in cyberspace, and even people without explicit computer skills know the names of the image formats, or at least the file suffixes: GIF, JPEG, BMP, PNG, and so on. Each of these sequences of letters is symbolic of a different way of storing images in computer form, and each has specific pros and cons for different purposes. GIF images were developed for use on the early internet, and they can have transparent color as well as the ability to store animations. The JPEG (or JPG) format is used by almost all digital cameras, and it compresses pictures into relatively few bytes. </p>
<p>You should recognize the importance of images and how complex a task it is to read data from one of these file formats. A program to read most GIF files would require more than a thousand lines of code. The fact that Processing provides an easy-to-use facility to read, display, and write images is one of its many advantages over other programming languages. </p>
<p>Processing has a type that represents an image, much as an integer is represented by the <code>int</code> type, and the system can read an image file into a variable with one call to a function. The type is <code>PImage</code> (short for <em>Processing Image</em>), and the function is <code>loadImage()</code>. For the image to load, it should be saved in the same folder as the sketch file, or in a subfolder called <em>data</em>.</p>
<h3 id="h2-501645c02-0001">Example A</h3>
<p class="BodyFirst">Let’s assume that an image file named <em>image.jpg</em> exists and that we want to read this image and display it in the sketch window. The first thing to do is declare a <code>PImage</code> variable, <code>im</code>, into which we’ll place the image <span class="CodeAnnotation" aria-label="annotation1">1</span>. Inside of <code>setup()</code>, we will create a sketch window (using <code>size()</code>) and read the image. The following statement reads the image and assigns it to the variable <code>im</code>:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation2">2</span> im = loadImage ("image.jpg");</code></pre>
<p class="BodyContinued">Now the image data is stored in some internal form in the variable <code>im</code>.</p>
<p>Displaying the image is done from the <code>draw()</code> function, although it could be done in this instance from <code>setup()</code> as well. The Processing system gives us a function named <code>image()</code> that will draw a <code>PImage</code> into the sketch window at a particular (<em>x</em>, <em>y</em>) location (specifying the location of the upper-left corner of the image). The following call draws the image so that its upper-left corner corresponds to the window’s upper-left corner:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation3">3</span> image (im, 0, 0);</code></pre>
<h3 id="h2-501645c02-0002">Example B</h3>
<p class="BodyFirst">This program is the same as Example A, but it draws the image at location <code>(150, 30)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Now the image is more neatly displayed in the available space.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The type <code>PImage</code> is defined by Processing but is a little different in detail from types like <code>int</code> and <code>float</code>. In fact, <code>PImage</code> is something called a <span class="KeyTerm">class</span>, and we can make our own classes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<p class="BoxCodeLabel">Example A</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> PImage im;

void setup ()
{
  size (640, 480);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> im = loadImage ("image.jpg");   
}

void draw ()
{
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> image (im, 0, 0);
}</code></pre>
<span epub:type="pagebreak" title="29" id="Page_29"/><figure class="graphic"><img src="Images/g13001.png" alt="g13001" width="521" height="407"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>PImage im;

void setup ()
{
  size (640, 480);
  im = loadImage ("image.jpg");
}

void draw ()
{
<span class="CodeAnnotation" aria-label="annotation1">1</span> image (im, 150, 30);  
}</code></pre>
<figure class="graphic"><img src="Images/g13002.png" alt="g13002" width="521" height="393"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0002" class="HeadProject"><span><span epub:type="pagebreak" title="30" id="Page_30"/>Sketch 14: Images—Theory and Practice</span></h2>
<p class="BodyFirst">Images are used often in the visual arts, and Processing was designed for artists, so it’s no surprise that images are pretty easy to use in the program. There are some basic things you need to know, though.</p>
<p>One is that for an image to be used on a computer, it must be <span class="KeyTerm">digitized</span>; that is, it must be turned into numbers. If an image was not created by a computer in the first place, then it has to be scanned or photographed, and each location on the original image must be given a number indicating the color seen there. The result is a two-dimensional array of numbers, each of which represents the color at a specific location. Each small area of an image is considered to be uniform in color, even if it’s not, so the most prominent color is selected to represent the entire area. This color is stored at the corresponding (<em>x</em>, <em>y</em>) location in the internal representation, and it’s called a <span class="KeyTerm">picture element</span>, or <span class="KeyTerm">pixel</span> for short. The complete collection of these pixels is an approximation of the original image. <span class="KeyTerm">Drawing</span> an image on screen means setting the pixels on a portion of the computer screen to match those in the image. This is what the <code>image()</code> function does in Processing.</p>
<p>Images are most often thought of as being <em>N</em>×<em>M</em> pixels in size, where <em>N</em> is the number of rows and <em>M</em> is the number of columns. The total number of pixels in such an image is <em>N</em>×<em>M</em>.</p>
<p>The <code>PImage</code> data type offers programmers a variety of ways to access the pixels in an image and manipulate them. Properties of an image can be accessed using “.” (dot) notation. For a <code>PImage</code> variable named <code>myImage</code>, for example, we have the following properties:</p>
<pre><code>myImage.width   // Width of the image, in pixels
myImage.height  // Height of the image, in pixels</code></pre>
<p>We often wish to create a graphics area that is the same size as a particular image, but the <code>size()</code> function in <code>setup()</code> can only use constants to set the window size. To get around this, we can add <code>surface.setResizable(true)</code> to <code>setup()</code>. It lets us resize the graphics area while the sketch is running with a call to <code>surface.setSize()</code>, which can use non-constants like <code>myImage.width</code>.</p>
<p>Individual pixel values can be accessed using functions that return or set colors based on (<em>x, y</em>) coordinates:</p>
<pre><code>myImage.get(x,y);                  // Returns the color of the pixel at column x and row y
myImage.set(x,y, color(255,0,0))   // Sets the pixel at (x,y) to red</code></pre>
<p>If we simply call <code>get()</code> or <code>set()</code> with no image specified, Processing assumes that the image being referenced is whatever is being displayed in the sketch window. </p>
<h3 id="h2-501645c02-0003">Example A</h3>
<p class="BodyFirst">This sketch reads an image file and checks to see if it was read in successfully <span class="CodeAnnotation" aria-label="annotation1">1</span>; if not, the program is ended by calling the function named <code>exit()</code>. The <code>loadImage()</code> function returns a special value named <code>null</code> if the image could not be read, so that can be used as an indicator that the image file, for example, was not found. If the image is okay, the program sets the size of the sketch window to be the same size as that image, using the image’s <code>width</code> and <code>height</code> properties <span class="CodeAnnotation" aria-label="annotation2">2</span>. When the <code>setup()</code> function displays the image, it will fill the entire window.</p>
<h3 id="h2-501645c02-0004">Example B</h3>
<p class="BodyFirst">The second sketch does not call <code>exit()</code> if the image file can’t be opened. Instead, it displays an error message in the graphics window <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<p class="BoxCodeLabel">Example A</p>
<pre><code>PImage img;                 // The image to be loaded
String name = "image.jpg";  // Name of the image file

void setup () 
{
  size (100,100);
  surface.setResizable(true);
  img = loadImage ("image.jpg");
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (img == null)
  {
    println ("File image.jpg is missing.");
    exit();
  }
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> surface.setSize(img.width, img.height);
}


void draw()
{
  image (img, 0, 0);  // Display the image
}</code></pre>
<span epub:type="pagebreak" title="31" id="Page_31"/><figure class="graphic"><img src="Images/g14001.png" alt="g14001" width="419" height="315"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>// Display error message if the image is not read in.

PImage img;                      // The image to be loaded

void setup ()
{
  fill(0);
  size (400,200);
  surface.setResizable(true);
  img = loadImage ("image.jpg"); // Load the original image
  if (img == null)
  {
    background(255,0,0);
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> text ("Error: Image file not found", 100, 100);
  }
  else surface.setSize(img.width, img.height);
}

void draw() 
{
  if (img !=null) image (img, 0, 0); // Display the image
}</code></pre>
<figure class="graphic"><img src="Images/g14002.png" alt="g14002" width="693" height="276"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0003" class="HeadProject"><span><span epub:type="pagebreak" title="32" id="Page_32"/>Sketch 15: Manipulating Images I—Aspect Ratio</span></h2>
<p class="BodyFirst">In the previous sketch we used the size of an image to define the size of the sketch window. It’s also possible to change the size of an image so that it fits into an existing space. The <code>resize()</code> function, part of the <code>PImage</code> data type, can be used to specify a new size for an image. It does not make a copy but resizes the <code>PImage</code> itself. Here’s an example call to this function:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> img.resize (w, h);</code></pre>
<p>This call will cause the image stored in the <code>img</code> variable to be expanded or contracted to be <code>w</code> pixels wide by <code>h</code> pixels high. </p>
<h3 id="h2-501645c02-0005">Example A</h3>
<p class="BodyFirst">In the first example, we scale the image to be the size of the window, which is 240×480. Note that the image has been distorted, squashed from the sides and made taller. Also note that all of the work is done in <code>setup()</code>, and <code>draw()</code> has no code.</p>
<p>Any image has an <span class="KeyTerm">aspect ratio</span>, which is the relationship between the width and height of the image. It is often expressed as <em>w</em>:<em>h</em>. For example, 16:9 would be the aspect ratio of an image that had 16 pixels in the x-direction (width) for every 9 pixels in the y-direction (height). The aspect ratio is sometimes expressed as a fraction, dividing the height into the width, so the ratio of 16:9 would be written as 1.8 in this way. The reason that the image in Example A looks odd is that the aspect ratio has been changed by forcing the image to fit into an arbitrary rectangle.</p>
<h3 id="h2-501645c02-0006">Example B</h3>
<p class="BodyFirst">This sketch draws an image into a window, scaling it so that the aspect ratio remains intact. The first thing to be done is to compute the aspect ratio of the original image:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> aspect = (float)w/(float)h;</code></pre>
<p>We use <code>float</code> variables here because the aspect ratio will be a fraction. When we place an image into a fixed space, its largest dimension (height or width) determines the overall size of the image within the window. We’ll adjust the largest side of the image to exactly fit the corresponding side of the window <span class="CodeAnnotation" aria-label="annotation2">2</span>, whether that means making the image larger or smaller. The other dimension of the image is kept proportional to this new scaled value. So if the image is taller than it is wide, we will map the height of the image to the height of the window:</p>
<pre><code>h = height;</code></pre>
<p class="BodyContinued">and the width will be in proportion to the original aspect ratio (converted to an integer):</p>
<pre><code>w = (int)(h*aspect);</code></pre>
<p>Now the image can be resized for display:</p>
<pre><code>img.resize (w, h);</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<p class="BoxCodeLabel"><span epub:type="pagebreak" title="33" id="Page_33"/>Example A</p>
<pre><code>PImage img;               

void setup ()
{
  img = loadImage ("image.jpg");  
  size (240, 480);     // Fixed size window        
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> img.resize (240, 480);
  image (img, 0, 0);
}

void draw ()
{ }</code></pre>
<figure class="graphic"><img src="Images/g15001.png" alt="g15001" width="255" height="509"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>PImage img;
int w, h;
float aspect = 1.0;

void setup ()
{
  img = loadImage ("image.jpg");
  size (540, 480);
  w = img.width; h = img.height;
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> aspect = (float)w/(float)h;

  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (w &gt; h)
  {
    w = width;
    h = (int)((float)w/aspect);
  } else
  {
    h = height;
    w = (int)(h*aspect);
  }
  img.resize (w, h);
  image (img, (width - w)/2, (height-h)/2);
}

void draw () { }</code></pre>
<figure class="graphic"><img src="Images/g15002.png" alt="g15002" width="406" height="540"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0004" class="HeadProject"><span><span epub:type="pagebreak" title="34" id="Page_34"/>Sketch 16: Manipulating Images II—Cropping</span></h2>
<p class="BodyFirst"><span class="KeyTerm">Cropping</span> an image refers to the removal of some outer parts. You could think of it more generally as the selection of an arbitrary rectangular sub-image. We crop images to make a more appealing image or to remove extraneous material. In Paint or Photoshop we use the mouse, clicking first on the desired upper-left corner of the cropped image, then dragging the mouse to the desired new lower-right corner, and releasing the button. All parts of the image outside of the selected rectangle will be discarded. This sketch will crop an image and optionally expand the cropped region to fill the entire image window. </p>
<p>First the image is read in and the sketch window is resized to fit the image. The <code>draw()</code> function displays the image (named <code>img</code>) centered in the window using the following code <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>image (img, (width-img.width)/2, (height-img.height)/2);</code></pre>
<p>If the image has not been cropped, <code>width-img.width</code> will be 0, and the call will be <code>image(img, 0, 0)</code>. Otherwise the image will be smaller than the window, and (<code>width-img.width)/2</code> will be the number of pixels needed on the left to center the cropped image. The same is done for height, which places the image in the center of the window. </p>
<p>When the mouse button is pressed (<code>mousePressed()</code>), the cropping process starts, using the point where the cursor is, which is saved as <code>x0</code> and <code>y0</code>. Then a rectangle is drawn from this location to the current mouse coordinates, implementing a rubber band rectangle <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>When the mouse button is released, the mouse coordinates are evaluated to ensure that the current <code>mouseX</code> and <code>mouseY</code> represent the lower-right corner of the crop box; in other words, make sure that <code>mouseX</code> is bigger than it was when the mouse button was pressed, and the same for <code>mouseY</code>. If not, the values of <code>x0</code> and <code>y0</code> are swapped with the values of <code>mouseX</code> and <code>mouseY</code>. Then we create a cropped image with the <code>get()</code> function, using the upper-left and lower-right coordinates <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>sub = get(x0, y0, (mouseX-x0), (mouseY-y0));</code></pre>
<p>The <code>get()</code> function returns a rectangular region of an image specified by a coordinate pair, a width, and a height. In the preceding call (<code>x0</code>, <code>y0</code>) are the upper-left coordinates, the width is the distance between the <code>mouseX</code> value and the upper-left <em>x</em> value, and the height is the distance between <code>mouseY</code> and the upper-left <em>y</em> value. In this case, <code>get()</code> is using the image displayed in the sketch window as the original.</p>
<p>The sub-image returned by the <code>get()</code> function becomes the current image to be displayed in <code>draw()</code> (the variable <code>img</code>) centered in the window <span class="CodeAnnotation" aria-label="annotation5">5</span>. </p>
<p>A new idea in this sketch is the test to see which mouse button was pressed. In the <code>mouseReleased()</code> function, this statement tests for the right mouse button:</p>
<pre><code>if (mouseButton == RIGHT) sub.resize (width, height);</code></pre>
<p class="BodyContinued">If that was the one released, the sub-image is rescaled to fit the window. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span> we resize the graphics window to be the size of the image, as we’ve done before.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage img;
boolean flag = false;
PImage sub;
int x0=0, y0=0;


void setup ()
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> size (100, 100);
  surface.setResizable(true);
  img = loadImage ("image.jpg");
  surface.setSize(img.width, img.height);}

void draw ()
{
  background (200, 200, 200);   // White background
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> image (img, (width-img.width)/2, (height-img.height)/2);

  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> if (flag)                     // If a mouse button is down then x0,y0 are defined
  {                             // Draw a rectangle from (x0,y0) to the mouse cursor
    noFill(); stroke(200);
    rect (x0, y0, (mouseX-x0), (mouseY-y0));  // Draw rectangle
  }
}
void mousePressed ()
{
  flag = true;
  x0 = mouseX; y0 = mouseY;
}

// Mouse button released. Select the sub-image that lies in the rectangle
// and rescale it; replace current display image with the new cropped one.
void mouseReleased ()
{
  int t;
  flag = false;
  if (x0 &gt; mouseX) { t = mouseX; mouseX = x0; x0 = t; }
  if (y0 &gt; mouseY) { t = mouseY; mouseY = y0; y0 = t; }
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> sub = get(x0, y0, (mouseX-x0), (mouseY-y0));
  if ((mouseX-x0 &gt; 0) &amp;&amp; (mouseY-y0 &gt; 0))
  {
    if (mouseButton == RIGHT) sub.resize (width, height);
    <span class="CodeAnnotationHang" aria-label="annotation5">5</span> img = sub;
  }
}</code></pre>
<span epub:type="pagebreak" title="35" id="Page_35"/><figure class="graphic"><img src="Images/g16001.png" alt="g16001" width="349" height="330"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0005" class="HeadProject"><span><span epub:type="pagebreak" title="36" id="Page_36"/>Sketch 17: Manipulating Images III—Magnifier</span></h2>
<p class="BodyFirst">Some computers have a “magnifying glass” object that is controlled by the mouse and displays a close-up (magnified) view of a part of the screen. It allows people with a minor visual impairment to see things more clearly, and it allows everyone to get a better look at menus and other screen-based objects. </p>
<p>Magnification is done by increasing the size of each pixel in the original image. If each pixel in the original becomes four pixels (in a square) in the new image, then the size of the new image will be double that of the original, giving the appearance of a magnified version, as shown in <a href="#figure17-1" id="figureanchor17-1">Figure 17-1</a>. The image will contain no more detail than the original; it will just be easier to see.</p>
<figure>
<img src="Images/f17001.png" alt="f17001" class="" width="581" height="554"/>
<figcaption><p><a id="figure17-1">Figure 17-1</a>: Magnifying an image</p></figcaption>
</figure>
<p>Implementing a magnifying glass is a simple matter using the functions that Processing provides. First we display the target image and use the techniques discussed in previous sketches to select a rectangular region in the sketch window to be magnified. By pressing the mouse button, the user selects a square beginning at the mouse coordinates with a size of 50×50 <span class="CodeAnnotation" aria-label="annotation1">1</span>. The Processing functions <code>mousePressed()</code> and <code>mouseReleased()</code> are called when the button is pressed and released <span class="CodeAnnotation" aria-label="annotation3">3</span>, and we use these functions to set a flag variable named <code>mag</code>. If <code>mag</code> is set, we copy the selected part of the original image into another <code>PImage</code> named <code>sub</code> using the <code>get()</code> function. The copied image is then resized to be 100×100 pixels using the <code>resize()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>sub.resize (100,100);</code></pre>
<p>Taking a 50×50 image and making it 100×100 effectively doubles its size. Now the resized image is drawn on the screen at the location from which it was copied, more or less. The new image is larger than the extracted one, so the new position is approximate, and some pixels from the original will be hidden behind the new, larger copy.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="37" id="Page_37"/>PImage img;            // Original image
boolean mag = false;   // Has the mouse been pressed?
PImage sub;            // Smaller, magnified image


void setup ()
{
  
  size (100,100);
  surface.setResizable(true);
  img = loadImage ("image.jpg");  
  surface.setSize(img.width, img.height);
}

void draw ()
{
  background (200, 200, 200);     
  image (img, 0, 0);  // Display the image

  if (mag)            // If the mouse is being pressed, 
                      // compute and display 
  {                   // a rectangular and magnified region 
                      // with mouse at UL
    stroke(200);
    noFill();
    rect (mouseX, mouseY, 100, 100);     // Outline the magnified region
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> sub = get(mouseX, mouseY, 50, 50);   // Get the sub-image
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> sub.resize (100,100);                // Double its size
    image (sub, mouseX, mouseY);         // Draw the sub-image
  }
}

// Set the flag 'mag' when the mouse button is pressed.
<span class="CodeAnnotation" aria-label="annotation3">3</span> void mousePressed ()
{
  mag = true;
}

// Clear the flag 'mag' when the mouse button is released.
void mouseReleased ()
{
  mag = false;
}</code></pre>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0006" class="HeadProject"><span><span epub:type="pagebreak" title="38" id="Page_38"/>Sketch 18: Rotation</span></h2>
<p class="BodyFirst">When rotating something, we always need to specify an <span class="KeyTerm">axis of rotation</span>, which in two dimensions is a <em>point</em> and an <span class="KeyTerm">angle</span>. A rotation is specified using a call to the function <code>rotate()</code>,</p>
<pre><code>rotate(angle);</code></pre>
<p class="BodyContinued">where <code>angle</code> is specified in <span class="KeyTerm">radians</span>. A circle contains 2π radians and also 360 degrees, so to convert from degrees to radians means multiplying the degrees by 3.14159/180.0, or by using the Processing function <code>radians(x)</code>. The point (axis) about which the rotation will take place is the origin of the window’s coordinate system, (0, 0), by default. It is the upper-left corner of the window, and the rotation will be <em>clockwise</em> about this point. </p>
<p>When a rotation is specified, all things drawn from that point on will be rotated. Calling <code>rotate()</code> again rotates by a further angle. Turning off the rotation is not possible as such, but a call to <code>rotate (-angle)</code> will undo the call to <code>rotate(angle)</code>.</p>
<h3 id="h2-501645c02-0007">Example A</h3>
<p class="BodyFirst">The first example draws a figure illustrating rotations. A horizontal line is drawn and labeled <span class="CodeAnnotation" aria-label="annotation1">1</span>, followed by a line that is rotated by 10 degrees <span class="CodeAnnotation" aria-label="annotation2">2</span> and then by one rotated by 20 degrees <span class="CodeAnnotation" aria-label="annotation3">3</span>. To avoid having the text rotated, the rotation is “undone” (rotated by the negative angle) before drawing the text labels.</p>
<h3 id="h2-501645c02-0008">Example B</h3>
<p class="BodyFirst">A line is drawn from the origin. It has a small ball on the end. This line is rotated from 0 to 90 degrees in small steps, with each step displayed within <code>draw()</code> because the line and ball are drawn there. When the line is rotating clockwise, the angle is incremented by 0.01 radians each time <code>draw()</code> is called <span class="CodeAnnotation" aria-label="annotation1">1</span>. When the line becomes vertical and further rotation would take it out of the field of view, the change in angle for each frame (variable <code>d</code>) is changed to <code>-d </code><span class="CodeAnnotation" aria-label="annotation2">2</span>. Now the line rotates back to its original position, and at that point (0 degrees) the value of <code>d</code> is changed to become positive again. The object, which looks like a pendulum, bounces between 90 degrees and 0 degrees.</p>
<p>The rotation angle is reset to 0 each time <code>draw()</code> is called.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<p class="BoxCodeLabel">Example A</p>
<pre><code>float d2r = 3.14159/180.0;
void setup ()
{
  size (400, 400);
  noFill();
  stroke(255);
  ellipse (0,0,280,280);
  stroke(0); 
  fill(0);
  
<span class="CodeAnnotationHang" aria-label="annotation1">1</span>   line (100, 100, 200, 100);
  text ("0 degrees", 210, 100);
  
<span class="CodeAnnotationHang" aria-label="annotation2">2</span>   rotate (radians(10));
  line (100, 100, 200, 100);
  rotate (-10*d2r);
  text ("10 degrees", 190, 140);
  
<span class="CodeAnnotationHang" aria-label="annotation3">3</span>   rotate (20*d2r);
  line (100, 100, 200, 100);
  rotate (-20*d2r);
  text ("20 degrees", 165, 180);
}</code></pre>
<span epub:type="pagebreak" title="39" id="Page_39"/><figure class="graphic"><img src="Images/g18001.png" alt="g18001" width="493" height="493"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>float angle = 0.0,  d = 0.01; 

void setup ()
{
  size (150, 130);
  stroke(0); 
}

void draw ()
{
  background (200);
  rotate (angle);
  line (0, 0, 50, 0);
  ellipse (50, 0, 3, 3);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> angle += d;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (angle &gt; 1.6) d = -d;
  else if (angle &lt; 0.0) d = -d;
}</code></pre>
<figure class="graphic"><img src="Images/g18002.png" alt="g18002" width="239" height="728"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0007" class="HeadProject"><span><span epub:type="pagebreak" title="40" id="Page_40"/>Sketch 19: Rotating About Any Point—Translation</span></h2>
<p class="BodyFirst">Being able to rotate objects is essential, but only being able to rotate about the upper-left corner of the screen is inconvenient. Rotation about an object’s center is what we usually want, but it requires knowledge of the object. Objects can be complex things in graphics; an object might be just a circle or square, or it might be a building or a car. Processing cannot be expected to know what an object is or where the center might be. However, Processing makes it possible to move the center of rotation to any coordinate we choose, using the <code>translate()</code> function.</p>
<p><code>translate()</code> takes an x- and a y-coordinate and changes the origin to that location for all future drawing. The following example moves the origin to the location (100, 200) in the window, which now becomes the coordinate (0, 0):</p>
<pre><code>translate (100, 200);</code></pre>
<p class="BodyContinued">The word <span class="KeyTerm">translate</span> means, in mathematical terms, to <em>reposition</em>, so a translation involves changing the position of an object. If we translate the origin to (50, 50) and then draw a circle at (0, 0), the circle will appear at window coordinates (50, 50) on the screen. Further circles will be drawn relative to window coordinates (50, 50).</p>
<p>Because rotations always use (0, 0) as the axis, this means we can set the axis to any coordinates we like and rotate an object about any point.</p>
<h3 id="h2-501645c02-0009">Example A</h3>
<p class="BodyFirst">As a basic example, we’ll draw a circle at (0, 0) using the <code>ellipse()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> and then call <code>translate()</code> to change the origin to (50, 50). A second call to <code>ellipse()</code> that is exactly the same as the first draws the circle at screen coordinates (50, 50). A further <code>ellipse()</code> call drawing a circle at (30, 40) draws the circle at screen coordinates (80, 90); that is, (30, 40) relative to the new origin at (50, 50).</p>
<h3 id="h2-501645c02-0010">Example B</h3>
<p class="BodyFirst">In this sketch we rotate a line about its center. The process is to <code>translate()</code> to the center of the line, in this case (150, 100) <span class="CodeAnnotation" aria-label="annotation1">1</span>; rotate by the current angle <span class="CodeAnnotation" aria-label="annotation2">2</span>; and then draw the line. The coordinates of the line must reflect the fact that the origin is the line’s center, not one end. Because the center of the line is at (150, 100), the line should be drawn from −50 to +50 in the x-direction so as to be 100 pixels long. The translated coordinates of the start would be (150 − 50, 200 − 100 − 0), or (100, 100). The coordinates of the endpoint will simply be 100 pixels further in x, or (200, 100). A small circle is drawn at the midpoint (origin) so that it can be seen. </p>
<p>The rotation angle increases each time <code>draw()</code> is called <span class="CodeAnnotation" aria-label="annotation3">3</span>. Since the line is drawn each time <code>draw()</code> is called, the image shows a slowly rotating line.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<p class="BoxCodeLabel">Example A</p>
<pre><code>// Translate a circle
void setup ()
{
  size (300, 200);
  stroke(0); 
  fill(200, 100, 50);
}

void draw ()
{
  background (200);
<span class="CodeAnnotationHang" aria-label="annotation1">1</span>   ellipse (0, 0, 10, 10); 
  translate (50, 50);
  ellipse (0, 0, 10, 10);
  ellipse (30, 40, 10, 10);
}</code></pre>
<span epub:type="pagebreak" title="41" id="Page_41"/><figure class="graphic"><img src="Images/g19001.png" alt="g19001" width="527" height="352"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>// Rotate a line about its origin
float angle = 0.0;

void setup ()
{
  size (300, 200);
  stroke(0); 
  fill(0);
}

void draw ()
{
  background (200);
<span class="CodeAnnotationHang" aria-label="annotation1">1</span>   translate (150, 100);
<span class="CodeAnnotationHang" aria-label="annotation2">2</span>   rotate (angle);
  ellipse (0, 0, 3, 3);
  line (-50, 0, 50, 0);
  translate (-150, -100);
<span class="CodeAnnotationHang" aria-label="annotation3">3</span>   angle += .01;
}</code></pre>
<figure class="graphic"><img src="Images/g19002.png" alt="g19002" width="457" height="885"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0008" class="HeadProject"><span><span epub:type="pagebreak" title="42" id="Page_42"/>Sketch 20: Rotating an Image</span></h2>
<p class="BodyFirst">Rotation and translation can be applied to complex objects as well as simple lines and circles. In particular, we can rotate images about arbitrary points by any angle.</p>
<p>There can be a problem in determining how to place the image so that it lies entirely on the screen. Images are rectangular, and rotating them increases their width or height. If we don’t place the image properly within the window, one or more corners could rotate out of the window’s boundaries, as shown in <a href="#figure20-1" id="figureanchor20-1">Figure 20-1</a>.</p>
<figure>
<img src="Images/g20001a.png" alt="g20001a" class="keyline" width="320" height="431"/>
<figcaption><p><a id="figure20-1">Figure 20-1</a>: Rotating an image out of the window’s boundaries</p></figcaption>
</figure>
<p>The top pair of images shows the result of rotating an image that was displayed in the upper-left corner of the window. Rotating by 45 degrees moves half of the image off of the screen. The bottom pair of images shows what can happen when an image is rotated about its center without a large enough window: the corners of the image are cut off.</p>
<p>This sketch displays a continuously rotating image. The image is read in, and the window size is set to <em>double</em> the image size in each dimension <span class="CodeAnnotation" aria-label="annotation1">1</span>. The <code>draw()</code> function translates the origin to the center of the image and then rotates the image by <code>angle</code> and displays it, thus rotating the image about its own center <span class="CodeAnnotation" aria-label="annotation2">2</span>. The value of <code>angle</code> is then increased by a tiny amount for the next time <code>draw()</code> is called <span class="CodeAnnotation" aria-label="annotation3">3</span>. The image appears in the center of the window and appears to rotate.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage img;         // Image to rotate
float angle = 0.0;  // Angle of rotation

void setup ()
{
  size (100,100);
  surface.setResizable(true);
  img = loadImage ("image.jpg");  
<span class="CodeAnnotationHang" aria-label="annotation1">1</span>   surface.setSize(img.width*2, img.height*2);
}

void draw()
{
  background(200);                         // White background
  translate(img.width, img.height);        // Move image to origin
<span class="CodeAnnotationHang" aria-label="annotation2">2</span>   rotate(angle);                           // Rotate
  translate (-img.width, -img.height);     // Move back
  image (img, img.width/2, img.height/2);  // Draw
<span class="CodeAnnotationHang" aria-label="annotation3">3</span>   angle = angle + 0.01;                    // Increment angle
}</code></pre>
<span epub:type="pagebreak" title="43" id="Page_43"/><figure class="graphic"><img src="Images/g20001.png" alt="g20001" width="574" height="738"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0009" class="HeadProject"><span><span epub:type="pagebreak" title="44" id="Page_44"/>Sketch 21: Getting the Value of a Pixel</span></h2>
<p class="BodyFirst">While developing Sketch 14, we discussed how to get a pixel value from a <code>PImage</code> using the <code>get()</code> function. We can get the color value of the pixel at (<code>x</code>, <code>y</code>) in a <code>PImage</code> named <code>im</code> as follows:</p>
<pre><code>color c;
PImage im;
c = im.get (x, y);</code></pre>
<p class="BodyContinued">The picture currently being displayed in the sketch window has a privileged position because it can be accessed without using a variable. A pixel value on the screen can be obtained by simply calling <code>get()</code>:</p>
<pre><code>c = get (x, y);</code></pre>
<p>We can therefore get the color of the pixel at the current mouse position with</p>
<pre><code>c = get (mouseX, mouseY);</code></pre>
<p>This sketch loads an image and allows the user to click any pixel to see its color, which will be displayed on the right side of the screen as a colored bar and as RGB values in text form. First the sketch loads an image and sizes the window to fit it, with an extra region on the right side. In <code>draw()</code> it displays the image with a background color of (200, 200, 200) <span class="CodeAnnotation" aria-label="annotation1">1</span>; when the mouse button is pressed, it assigns the pixel value (color) at the <code>mouseX</code>, <code>mouseY</code> coordinates to the color variable <code>c</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>; then it displays the color on the right side of the image and the RGB values as text at the upper-right corner of the screen <span class="CodeAnnotation" aria-label="annotation2">2</span>. Whenever the mouse button is clicked, the color value displayed will change.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Another way to describe a color is with the <span class="KeyTerm">HSB system</span>, in which the three color values represent the hue, saturation, and brightness. <span class="KeyTerm">Hue</span> is the actual color, such as red or blue. <span class="KeyTerm">Saturation</span> indicates the intensity of the color. <span class="KeyTerm">Brightness</span> indicates a value of light. Changing to HSB mode in Processing is done by calling <code>colorMode (HSB, 256)</code>, for example, in which each of <code>H</code>, <code>S</code>, and <code>B</code> have values between 0 and 255. The call <code>colorMode</code> <code>(RGB, 256)</code> would return to the default RGB coordinates.</p>

<p class="continued">No matter what the color mode is, the function <code>hue(c)</code>, when <code>c </code>is a color, will return the hue value. The functions <code>saturation(c)</code> and <code>brightness(c)</code> yield the other two HSB components.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code><span epub:type="pagebreak" title="45" id="Page_45"/>PImage img; 
color c;

void setup ()
{
  size(200, 200);
  surface.setResizable(true);
  img = loadImage ("image.jpg");
  surface.setSize(img.width+55, img.height);
  c =  color (200, 200, 200);     // Default background
}

void draw()
{
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> background (c);
  image (img, 0, 0);
  if (red(c) != 200)
  {
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> text ("R="+red(c), img.width+2, 20);
    text ("G="+green(c), img.width+2, 35);
    text ("B="+blue(c), img.width+2, 50);
  }
}

void mousePressed ()
{
  if (mouseX &gt; img.width)
    c = color(200, 200, 200);
  else
  <span class="CodeAnnotation" aria-label="annotation3">3</span> c = get (mouseX, mouseY);
}</code></pre>
<figure class="graphic"><img src="Images/g21001.png" alt="g21001" width="464" height="320"/></figure>
<figure class="graphic"><img src="Images/g21002.png" alt="g21002" width="464" height="320"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0010" class="HeadProject"><span><span epub:type="pagebreak" title="46" id="Page_46"/>Sketch 22: Setting and Changing the Values of Pixels</span></h2>
<p class="BodyFirst">Pixel values in an image, including the drawing area, can be changed using the <code>set()</code> function. We specify a pixel location using coordinates and identify the color to draw at that point. For example,</p>
<pre><code>set (i,j, color(255, 255, 0));</code></pre>
<p class="BodyContinued">This sets the pixel in the graphics area at location (<code>i</code>,<code>j</code>) to yellow, or RGB (255, 255, 0). If the coordinates lie outside of the window, the pixel will be drawn but will not be visible.</p>
<p>We can set a color for <em>all</em> pixels in the window using the <code>background()</code> function: </p>
<pre><code>background (255, 100, 40) </code></pre>
<p>This call fills the sketch window with orange.</p>
<h3 id="h2-501645c02-0011">Example A</h3>
<p class="BodyFirst">Setting all pixels in the window without using the <code>background()</code> function requires a <span class="KeyTerm">loop</span><em>—</em>two nested loops, in fact. The first loop examines all pixels in the horizontal direction; that is, all pixels in a specified row. The second loop looks at all possible values of <code>i</code>, which is to say all rows. The first loop is nested within the second so that all pixels in all rows are modified:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> for (i=0; i&lt;width; i++)
  for (j=0; j&lt;height; j++)
    set(i,j, color(255, 100, 40));</code></pre>
<p>This sets all pixels in the sketch window to orange.</p>
<h3 id="h2-501645c02-0012">Example B</h3>
<p class="BodyFirst">The pixel values of an image can be modified before the image is displayed in the sketch window. Not only can the color be replaced, but a pixel value can be changed more subtly to a variation of what is already there. This example first loads and displays an image. When the program detects a button press with <code>mousePressed()</code>, it sets the flag <code>grey</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which indicates that the image on the screen is to be modified, pixel by pixel, in a loop like that of the previous example. In this case, we replace the RGB value of each pixel on the screen with its brightness value <span class="CodeAnnotation" aria-label="annotation1">1</span>, and the result is a grey image showing no color. When the mouse button is released (<code>mouseReleased()</code>), the program clears the flag (sets it to <code>false</code>), and the image is displayed in color again <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<p class="BoxCodeLabel">Example A</p>
<pre><code>void setup ()
{
  size (400, 300);
}

void draw ()
{
  int i,j;
  
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> for (i=0; i&lt;width; i++)
    for (j=0; j&lt;height; j++)
      set (i,j, color(255, 100, 40));
}</code></pre>
<span epub:type="pagebreak" title="47" id="Page_47"/><figure class="graphic"><img src="Images/g22001.png" alt="g22001" width="442" height="332"/></figure>
<p class="BoxCodeLabel">Example B</p>
<pre><code>PImage img;
color c1, c2, c;
boolean grey = false;

void setup ()
{
  size(200, 200);
  surface.setResizable(true);
  img = loadImage ("image.jpg");
  surface.setSize(img.width, img.height);
  c =  color (200, 200, 200);     // Default background
}
void draw ()
{
  int i,j;
  color c1, c2;
  background (200);    
  image (img, 0, 0);  
  if (mousePressed)
  {
    for (i=0; i&lt;width; i++)
      for (j=0; j&lt;height; j++)
      {
        c1 = get (i,j);
        <span class="CodeAnnotationHang" aria-label="annotation1">1</span> c2 = (int)brightness(c1);
        set (i,j,color(c2,c2,c2));
      }
  }
}
<span class="CodeAnnotationCode" aria-label="annotation2">2</span>   void mousePressed () {  grey = true; } 
<span class="CodeAnnotationCode" aria-label="annotation3">3</span>   void mouseReleased () {  grey = false; }</code></pre>
<figure class="graphic"><img src="Images/g22002.png" alt="g22002" width="443" height="333"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0011" class="HeadProject"><span><span epub:type="pagebreak" title="48" id="Page_48"/>Sketch 23: Changing the Values of Pixels—Thresholding</span></h2>
<p class="BodyFirst">The act of <span class="KeyTerm">thresholding</span> an image changes the color value of each pixel to either black or white, depending on the original color or brightness. Thresholding creates a <span class="KeyTerm">binary</span> image: each pixel can be thought of as being either <em>on</em> or <em>off</em>. Why do this? Some images have content that is fundamentally binary: a scan of a page of text has black characters on a white background. In other cases, it is a way to simplify an image so that we can perform other operations, such as detecting edges or faces. Thresholding an image of red blood cells might facilitate counting them, for example.</p>
<p>Thresholding an image is a two-step process. First we determine a threshold value—one that retains the required features of the image. We usually do this by examining all of the pixels in the image and computing a value using some statistical formula. A threshold value is a number between 0 and 255; all pixel brightness values smaller than the threshold will be set to black (0), and those greater will be set to white (255). The second step is looking at all of the pixels and actually applying the threshold.</p>
<p>To address the second step first, applying the threshold is a simple matter of looking at each pixel and deciding whether it is less than or greater than <code>threshold</code>. We<b> </b>assign the pixel value to the variable <code>g</code>, extract the brightness, and then test it:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (g&lt;threshold) g = black;
  else g = white;</code></pre>
<p class="BodyContinued">The value <code>black</code> is the color (0, 0, 0), and <code>white</code> is (255, 255, 255).</p>
<p>In this sketch, we will determine the threshold manually, using the mouse position. This is the horizontal position of the mouse as a percentage of the total window width:</p>
<pre><code>mouseX/width</code></pre>
<p class="BodyContinued">If we multiply this fraction by 255, we get a value between 0 and 255 <span class="CodeAnnotation" aria-label="annotation1">1</span> that is in proportion to how far to the right the mouse is. We’ll use this value as a threshold. When the mouse is on the left side of the window, the threshold will be small and most of the image will be white; when the mouse is on the right, the threshold will be large and the image will be largely black. </p>
<p>If the <code>draw()</code> function calculates and applies the threshold, it will be dynamic, and we can watch the image change as the mouse moves.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When calculating a threshold from pixel values, we could select the average pixel level as the threshold; the implication here is that half of the pixels would be black and half white. However, this is not a good threshold for text, because many more pixels in a text image will be white than will be black. There are many algorithms for thresholding images, but there is no best one in general.</p>
<p class="continued">We could also threshold each color value separately to create interesting images, with each color either full on or full off.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage img;
int threshold;
color black = color(0, 0, 0);
color white = color (255, 255, 255);

void setup ()
{
  size(200, 200);
  surface.setResizable(true);
  img = loadImage ("image.jpg"); 
  surface.setSize(img.width, img.height);
  threshold = 128;
}

void draw ()
{
  color c;
  int i,j,g;

  background(200);
  image (img, 0, 0);
  
  threshold = (int)((<span class="CodeAnnotationCode" aria-label="annotation1">1</span>(float)mouseX/(float)width) * 255);
  for (i=0; i&lt;width; i++)
    for (j=0; j&lt;height; j++)
    {
      c = get (i,j);
      g = (int)brightness(c);
      <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (g&lt;threshold) g = black;
      else g = white;
      set (i,j,g);
    }
}</code></pre>

<span epub:type="pagebreak" title="49" id="Page_49"/><figure class="graphic"><img src="Images/g23001.png" alt="g23001" width="314" height="287"/></figure>
<figure class="graphic"><img src="Images/g23002.png" alt="g23002" width="314" height="287"/></figure>
<figure class="graphic"><img src="Images/g23003.png" alt="g23003" width="314" height="287"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0012" class="HeadProject"><span><span epub:type="pagebreak" title="50" id="Page_50"/>Sketch 24: User-Defined Functions</span></h2>
<p class="BodyFirst">Up to this point, we have been using drawing functions provided by the Processing system: <code>ellipse()</code>, <code>line()</code>, <code>mousePressed()</code>, and so on. We have not analyzed the concept of functions much, partly because it appears fairly obvious what is going on. However, if we wish to create our own functions, there are some things we need to understand.</p>
<p>A <span class="KeyTerm">function</span> is a name given to a collection of code. When the name of the function is used in a statement, that function is said to be <span class="KeyTerm">invoked</span> or <span class="KeyTerm">called</span>, and the code within the function is executed. This means that functions can be executed from many different places without repeating the code itself, merely by calling it. </p>
<p>A function can return a value: we’ve used such functions before. For example, <code>color()</code> and <code>get()</code> return colors and pixel values. Functions that do not return a value are said to return <code>void</code>, and that’s the reason for the word <code>void</code> in front of <code>setup()</code> and <code>draw()</code>. They are functions that do not return a value.</p>
<p>To create a new function, we must follow the same syntax as <code>setup()</code> and <code>draw()</code>: we write the return type, the function name, parentheses, and then the function body in curly brackets. For example:</p>
<pre><code>void newFunctionA ()            int newFunctionB ()
{                               {
  <var>code                            code</var>
                                  return <var>value</var>;
}                               }</code></pre>
<p>Above, <code>newFunctionA()</code> does not return a value, and it is called or invoked using the function call <code>newFunctionA();</code>.<code> newFunctionB()</code> returns an integer value and must have a <code>return</code> statement indicating the value to be returned. This type of function is called as if it were part of an expression:</p>
<pre><code>a = newFunctionB();
x = newFunctionB()*2 + 1;</code></pre>
<p>There can be more than one <code>return</code> statement in a function, but only one will be executed, because once a function returns, no other code in the function can execute.</p>
<p>Functions may have <span class="KeyTerm">parameters</span> or <span class="KeyTerm">arguments</span>, values that are given to the function when it is called. When calling the function <code>color()</code>, we list three values in the parentheses: red, green, and blue. These variables are specifically <span class="KeyTerm">passed</span> for use by the function, and their values are available to do calculations within the function. </p>
<p>Let’s make a function that calculates the distance between two points, (x0, y0) and (x1, y1):</p>
<pre><code>float distance (int x0, int y0, int x1, int y1)</code></pre>
<p>The arguments to the function are named <code>x0</code>, <code>y0</code>, <code>x1</code>, and <code>y1</code>, and they have types, in this case integer (<code>int</code>). The arguments are used to calculate the distance between the points (x0, y0) and (x1, y1) as follows:</p>
<figure class="graphic">
<img src="Images/C02eq001.png" alt="C02eq001" width="252" height="40"/></figure>

<p>This sketch uses two mouse clicks to determine the points: (x0, y0) <span class="CodeAnnotation" aria-label="annotation2">2</span> and (x1, y1) <span class="CodeAnnotation" aria-label="annotation3">3</span>. It draws a marker at each point and displays the distance between them as a text message at the bottom of the window <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code>int x0 = -1, y0 = -1; 
int x1 = -1, y1 = -1;
boolean ok = false;

void setup ()
{
  size (300, 300);   
}

void draw ()
{
  background(200);
  fill (100, 255, 40); 
  if (x0 &gt;= 0)
    ellipse (x0, y0, 5, 5);
  if (x1 &gt;= 0)
    ellipse (x1, y1, 5, 5);
  if (ok)
  {
    fill (0);
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> text ("Distance is "+distance(x0,y0,x1,y1), 100, 250);
  }
}

float distance (int x0, int y0, int x1, int y1)
{ 
  float d;
  
  d = (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1);
  d = sqrt(d);
  return d;
}

void mousePressed ()
{
  if (x0 &lt; 0) 
  {
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> x0 = mouseX; y0 = mouseY;
  } else if (x1 &lt; 0)
  {
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> x1 = mouseX; y1 = mouseY;
    ok = true;
  }
}</code></pre>
<span epub:type="pagebreak" title="51" id="Page_51"/><figure class="graphic"><img src="Images/g24001.png" alt="g24001" width="427" height="427"/></figure>
<figure class="graphic"><img src="Images/g024002.png" alt="g024002" width="427" height="427"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0013" class="HeadProject"><span><span epub:type="pagebreak" title="52" id="Page_52"/>Sketch 25: Elements of Programming Style</span></h2>
<p class="BodyFirst"><span class="KeyTerm">Style</span> in a program refers to aspects of the code that don’t usually impact the execution but that do have an effect on how other people read, modify, or repair it. </p>
<p>For example, there is a way to place human-readable text within a program for other programmers to read. Any text that follows a pair of slashes is called a <span class="KeyTerm">comment</span>, and it is ignored by Processing, as is any text in between the symbols <code>/*</code> and <code>*/</code>, which delineate comments that can span many lines. Programs should have relevant comments embedded within the code to explain what is going on to any human beings looking at it. Comments should be clear, offer an explanation, and never simply repeat the code itself. The nature of the comments in a program is one aspect of what we call <span class="KeyTerm">programming</span> <span class="KeyTerm">style</span>.</p>
<p>Another aspect of style is the use of <span class="KeyTerm">indentation</span> to convey structure. There is no single correct way to indent, but the standard shown in the sketches in this book has certain consistent features. For example, the “{” and “}” characters used to enclose blocks of code always line up with each other vertically so that the blocks are easy to identify. The only exception is when they are on the same line:</p>
<pre><code>if (x0 &lt; 0) 
{
  x0 = mouseX; 
  y0 = mouseY;
}</code></pre>
<p>In other books, you might see another style:</p>
<pre><code>if (x0 &lt; 0)  {
  x0 = mouseX; 
  y0 = mouseY;
}</code></pre>
<p>The location of brackets doesn’t matter to the programming language’s compiler, but a programmer should be consistent.</p>
<p>Variables should have meaningful names. The variables <code>x0</code> and <code>y0</code> above represent  x- and y-coordinates, so the names make sense. A variable named <code>pixelCount</code> should contain a count of pixels. It is pretty easy to give variables good names, and doing so does not impact how fast the code is or how much memory it requires in order to execute.</p>
<p>Numeric constants should be named like variables so that the purpose of the constant can be inferred from the name. A perfect example is <code>PI</code> instead of 3.1415. A program should contain very few if any numerical constants, and names should be used instead. Consider the following code:</p>
<pre><code>r = d*0.01745;</code></pre>
<p>The number 0.01745 is meaningless to most people. Now consider this:</p>
<pre><code>r = d *2*PI/360.0;</code></pre>
<p>This is better. Two times PI/360 is the conversion between radians and degrees. Best would be</p>
<pre><code>radians = degrees * degrees_to_radians;</code></pre>
<p class="BodyContinued">where <code>degrees_to_radians</code> equals <code>0.01745</code>. Now anyone reading the code can easily see what is happening.</p>
<p><span epub:type="pagebreak" title="53" id="Page_53"/>The code in this sketch does the same thing as the previous sketch, but it shows better style. Note, though, that it takes more space on the screen—this is typical, and it’s why these rules are not followed all of the time, even in this book (where it’s important for the text to fit on a single page). </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int x0 = -1, y0 = -1;              / The first pixel clicked on
int x1 = -1, y1 = -1;              // The second pixel clicked on
color beige = color(200,200,200);  // Background
color black = color(0,0,0);        // The color black (text)
color green = color (100,255,40);  // Circle color
boolean bothPixelsSet = false;     // Mouse clicked twice?
int textX=100, textY=250;          // Where to draw the distance
int circleSize = 5;                // Size of the circles at the click points

void setup ()                      // Set up a 300x300 window
{  size (300, 300);   }
void draw()
{
  background(beige);               // Fill the window with beige
  fill (green);                    // Objects will be filled with green
  if (x0 &gt;= 0)                     // x0 &gt;= 0 means it has been set
     ellipse (x0, y0, circleSize, circleSize);
  if (x1 &gt;= 0)                     // x1 &gt;= 0 means it has been set
     ellipse (x1, y1, circleSize, circleSize);
  if (bothPixelsSet)
  {
    fill (black);                  // Set text color
    text ("Distance is "+distance(x0,y0,x1,y1), textX, textY);
  }
}
// Compute the distance between two points 
float distance (int x0, int y0, int x1, int y1)
{ 
  float d;
  d =sqrt( (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));
  return d;
}
// Mouse is released when a point is defined
void mouseReleased ()
{
  if (x0 &lt; 0)                      // First click has not been made
  {  x0 = mouseX; y0 = mouseY;
  } else if (x1 &lt; 0)               // This is the second click
  {   x1 = mouseX; y1 = mouseY;
      bothPixelsSet = true;
  }
}</code></pre>
<figure class="graphic"><img src="Images/g25001.png" alt="g25001" width="335" height="335"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c02-0014" class="HeadProject"><span><span epub:type="pagebreak" title="54" id="Page_54"/>Sketch 26: Duplicating Images—More Functions</span></h2>
<p class="BodyFirst">The purpose of this sketch is to give you some ideas about how to organize code into functions properly. This program will read an image, make a copy, and increase the brightness of the copy. The brighter version will be displayed when a mouse button is pressed. </p>
<p>The first function is named <code>brighten()</code>. It is passed an image (named <code>img</code>) and an integer value (named <code>val</code>) as parameters. Its purpose is to increase the brightness value in an image by a specified amount. It does this by extracting the HSB value from each pixel in turn in a nested loop <span class="CodeAnnotation" aria-label="annotation2">2</span>, adding the amount <code>val</code> to the brightness portion, and saving the pixel back in the image. This is the essential code <span class="CodeAnnotation" aria-label="annotation3">3</span>:</p>
<pre><code>// Extract the HSB values from the pixel at (i,j)
c = img.get(i,j);
// Add val to the brightness and save again.
img.set (i,j, color(hue(c), saturation(c), brightness(c)+val));</code></pre>
<p>We will use a new feature in <code>draw()</code>. Processing provides us with a variable named <code>mousePressed</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> that is <code>true</code> if a mouse button is depressed and <code>false</code> otherwise, and this can be used in place of the <code>mousePressed()</code> callback function in very simple cases. In this instance, we display the brightness-enhanced image when the mouse button is pressed, and the original otherwise.</p>
<pre><code>if (mousePressed) image (img2, 0, 0);
  else image (img1, 0, 0);</code></pre>
<p>The second function in this sketch makes a copy of the original image. We define the duplicate function as follows: </p>
<pre><code>PImage duplicate (PImage from)</code></pre>
<p>According to the definition of this function, the function takes an image as an argument and returns an image. In fact, it returns a new image that is a copy of the one passed in. The Processing-supplied function that creates a new image is named <code>createImage()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, and it has this form:</p>
<pre><code>createImage (width, height, RGB);</code></pre>
<p>The width and height should be self-explanatory; the constant <code>RGB</code> specifies the form of the image, which in this case is RGB color. The image returned by <code>CreateImage</code> is <span class="KeyTerm">uninitialized</span>, having pixels with unknown values, so after creating an image the same size as the one passed in, our <code>duplicate()</code> function sets each pixel in the new image to the value of the corresponding pixel in the original, with a standard nested loop.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Alternatives to the <code>RGB</code> parameter for <code>createImage(</code><code>)</code> are <code>ARGB</code> and <code>ALPHA</code>. Look them up. All of the constants refer to <span class="KeyTerm">color formats</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>PImage img1, img2;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  img1 = loadImage ("image.jpg");
  surface.setSize(img1.width, img1.height);
  img2 = duplicate (img1);
  colorMode (HSB);
  brighten(img2, 60);
}

void draw()
{
  background (128); // Grey background
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> if (mousePressed) image (img2, 0, 0);
  else image (img1, 0, 0);
}

void brighten (PImage img, int val)
{
  color c;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;img.width; i++)
    for (int j=0; j&lt;img.height; j++)
    {
      <span class="CodeAnnotationHang" aria-label="annotation3">3</span> c = img.get(i,j);
      img.set (i, j, color(hue(c), saturation(c), brightness(c)+val));
    }
}

PImage duplicate (PImage from)
{
  PImage newImage;
  color pixel;
  if (from == null) return from;
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> newImage = createImage (from.width, from.height, RGB);
  for (int i=0; i&lt;from.width; i++)
    for (int j=0; j&lt;from.height; j++)
    {
      pixel = from.get (i,j);
      newImage.set(i,j,pixel);
    }
  return newImage;
}</code></pre>
<span epub:type="pagebreak" title="55" id="Page_55"/><figure class="graphic"><img src="Images/g26001.png" alt="g26001" width="367" height="275"/></figure>
<figure class="graphic"><img src="Images/g26002.png" alt="g26002" width="348" height="261"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>