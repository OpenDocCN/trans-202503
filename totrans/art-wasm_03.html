<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="45" id="Page_45"/>3</span><br/>
<span class="ChapterTitle">Functions and Tables</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, we explore functions in WebAssembly: how and when we should import functions from JavaScript or a different WebAssembly module and how to export WebAssembly functions to the embedding environment and call those functions from JavaScript. You’ll learn about tables in WebAssembly and how to call functions defined in tables. We also examine the performance implications of calling functions that we define inside and outside of the WebAssembly module.</p>
<p>A WebAssembly module interacts with the embedding environment using imported and exported functions. We must import functions from the embedding environment for WebAssembly to use and export functions for a web page to call. We can also write functions from within the WebAssembly module to export to the embedding environment using an <code/><span epub:type="pagebreak" title="46" id="Page_46"/>export statement. Otherwise, functions are by default contained for use only within the module.</p>
<p>Function calls will always result in some lost computing cycles. But it’s necessary to know that a WebAssembly module will lose <em>more </em>cycles when calling an imported JavaScript function than when calling a function defined inside your WebAssembly module.</p>
<h2 id="h1-501737c03-0001">When to Call Functions from WAT</h2>
<p class="BodyFirst">Every function we’ve defined up to this point includes the <code>(export)</code> expression to export the function so JavaScript can call it. However, not every function should use <code>export</code>. Every call to a WebAssembly function from JavaScript incurs an overhead cost, so you generally wouldn’t export WAT functions that do only small tasks. Small functions that don’t use many computing cycles might be better kept in the JavaScript to reduce overhead. Make sure your WAT code does as much as possible before returning to JavaScript; smaller functions shouldn’t use <code>export</code>.</p>
<p>The WAT functions most suited for exporting are those that loop over and process a lot of data. We recommend using many WAT functions in the early versions of your code to aid in the debugging process. Stepping through your WAT code in a debugger is easier to follow when your code is broken into many small functions. Chapter 10 covers debugging WebAssembly code in detail. As you tune your code for performance, you might decide to remove some of these functions by placing their code inline wherever the function had been called. Any internal function that’s called thousands of times from your exported WebAssembly function is a good candidate for moving inline. Chapter 9 covers performance tuning in detail. </p>
<h2 id="h1-501737c03-0002">Writing an is_prime Function</h2>
<p class="BodyFirst">We’ve already seen examples of exporting functions to JavaScript in previous chapters, but those functions were terrible candidates for WebAssembly performance improvement because they didn’t do a whole lot. Here we’ll write an intentionally slow algorithm to determine whether an input is a prime number. This function is a good candidate for creation in WebAssembly and improved performance over JavaScript because it involves a significant number of calculations. Create an <em>is_prime.js</em> file and an <em>is_prime.wat</em> file to start creating this app.</p>
<h3 id="h2-501737c03-0001">Passing Parameters</h3>
<p class="BodyFirst">Let’s start with the basics. First, we create a module, and then create a function inside that module that can be exported as <code>is_prime</code>. This function takes a single 32-bit integer parameter and returns a 32-bit integer that is <code>1</code> if the number passed in is prime and <code>0</code> if it’s not. Place the code in <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a> in the <em>is_prime.wat</em> file.</p>
<span epub:type="pagebreak" title="47" id="Page_47"/>
<pre><code>(module
  (func (<span class="CodeAnnotationCode" aria-label="annotation1">1</span>export "is_prime") (<span class="CodeAnnotationCode" aria-label="annotation2">2</span>param $n i32) (<span class="CodeAnnotationCode" aria-label="annotation3">3</span>result i32)
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.const 0 <span class="LiteralGray">;; remove later</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: WebAssembly <code>is_prime</code> function stub</p>
<p>We export this function to JavaScript as <code>is_prime</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. JavaScript passes in a single parameter <code>param</code> <code>$n</code> as an <code>i32</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. When complete, the function returns a 32-bit integer to JavaScript <span class="CodeAnnotation" aria-label="annotation3">3</span>. To compile, this function expects to find a 32-bit integer on the stack when the function completes, so we add the line <code>i32.const</code><code> 0</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Without this line, the compiler will throw an error when we run <code>wat2wasm</code> because it’s expecting to return a number when the function completes, and it needs that number to be on the stack when the function ends.</p>
<p>This function is set for export alone and is not labelled for internal use. The <code>(func</code><code>)</code> expression begins with an <code>export</code> expression, not a <code>$is_prime</code> label. If we wanted to call this function from within the WebAssembly module or from the JavaScript, we would label it as shown in <a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a>.</p>
<pre><code>(func <span class="CodeAnnotationCode" aria-label="annotation1">1</span>$is_prime (export "is_prime") (param $n i32) (result i32)</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: Exporting the function</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Truthiness</h2>
<p class="BoxBodyFirst">The <code>$i</code><code>s_prime</code><code> </code><span class="CodeAnnotation" aria-label="annotation1">1</span> function should return an <code>i32</code> to the calling JavaScript, but we know that on the JavaScript end, what we really want is a boolean value of <code>true</code> or <code>false</code>. However, WebAssembly currently doesn’t have a boolean type. Instead, it uses an <code>i32</code> that must be interpreted by JavaScript as <code>true</code> or <code>false</code>. For non-boolean variables, JavaScript uses a concept not common to all programming languages called <em>truthy,</em> which means kinda true but not strictly true. Whenever you want a value that’s returned from WebAssembly to evaluate to a boolean, it’s good practice to use the JavaScript <code>!!</code> operator, which forces the value <code>0</code> to a boolean false and any other number will be coerced to true.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501737c03-0002">Creating Internal Functions</h3>
<p class="BodyFirst">Let’s add a little more code to the <em>is_prime.wat </em>file. No prime numbers are even except for the number 2, so we’ll write a function that checks whether the input number is even by looking at the last bit in the integer. All odd numbers have a 1 in the integer’s lowest order bit. <a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a> shows the code for the <code>$even_check</code> function that we’ll add to the <em>is_prime.wat</em> file.</p>
<span epub:type="pagebreak" title="48" id="Page_48"/>
<p class="CodeLabel"><b>is_prime.wat (part 1 of 4)</b></p>
<pre><code>(module
<span class="LiteralGray">  ;; add the $even_check function to the top of the module</span>
  (func $even_check (<span class="CodeAnnotationCode" aria-label="annotation1">1</span>param $n i32) (result i32)
     local.get $n
     i32.const 2
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.rem_u   <span class="LiteralGray">;; if you take the remainder of a division by 2</span>
     i32.const 0 <span class="LiteralGray">;; even numbers will have a remainder 0</span>
   <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.eq      <span class="LiteralGray">;; $n % 2 == 0</span>
 )
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: Defining the <code>$even_check</code> function</p>
<p>The <code>$even_check</code> function takes a single parameter <code>$n</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and will return a value of <code>1</code> if <code>$n</code> is even and <code>0 </code>if <code>$n</code> is odd. We use the remainder operation <code>i32.rem_u</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which divides <code>$n</code> by 2 and finds the remainder. An even number will have a remainder of 0, so we compare the remainder returned from <code>i32.rem_u</code> with 0 using an <code>i32.eq</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> expression. </p>
<p>Now let’s create another simple function to handle the exception case if the number being passed in is 2, which is the only even prime number. It takes a single parameter and returns a <code>1</code> (true) if the number passed in is 2 or <code>0</code> (false) if it isn’t. We’ll call this function <code>$eq_2</code>, as shown in <a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a>.</p>
<p class="CodeLabel"><b>is_prime.wat (part 2 of 4)</b></p>
<pre><code>...
<span class="LiteralGray">;; add the $eq_2 function after $even_check</span>
(func $eq_2 (param $n i32) (result i32)
  local.get $n
  i32.const 2
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.eq    <span class="LiteralGray">;; returns 1 if $n == 2</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: The <code>$eq_2</code> function checks whether the value passed in is 2.</p>
<p>We use <code>i32.eq</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to determine whether <code>$n</code> has a value of <code>2</code>, return <code>1</code> if it does, and return <code>0</code> if it doesn’t. Writing the <code>$eq_2</code> function is overkill, but because we’re demonstrating how calling functions work, another example couldn’t hurt.</p>
<p>In <a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a>, we add a <code>$multiple_check</code> function that checks whether the first parameter <code>$n</code> is a multiple of the second parameter <code>$m</code>. If the input number has multiples, it means it’s divisible and therefore cannot be prime.</p>
<p class="CodeLabel"><b>is_prime.wat (part 3 of 4)</b></p>
<pre><code>...
<span class="LiteralGray">;; add $multiple_check after $eq_2</span>
  (func $multiple_check (param $n i32) (param $m i32) (result i32)
   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.get $n
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.get $m
   <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.rem_u     <span class="LiteralGray">;; get the remainder of $n / $m</span>
     i32.const 0   <span class="LiteralGray">;; I want to know if the remainder is 0</span>
   <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.eq        <span class="LiteralGray">;; that will tell us if $n is a multiple of $m</span>
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Defining a <code>$multiple_check</code> function that checks whether <code>$n</code> is a multiple of <code>$m</code></p>
<p><span epub:type="pagebreak" title="49" id="Page_49"/>The <code>$multiple_check</code> function takes in two parameters, an integer <code>$n</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and a second integer <code>$m</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, and checks whether <code>$n</code> is a multiple of <code>$m</code>. To do this, we get the remainder of <code>$n / $m</code> using <code>i32.rem_u</code><code/><span class="CodeAnnotation" aria-label="annotation 3"> 3</span> and then check whether that remainder is <code>0</code> using <code>i32.eq</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. If the remainder is <code>0</code>, the <code>$multiple_check </code>function returns <code>1</code>. If the remainder is anything else, the <code>$multiple_check </code>returns <code>0</code>.</p>
<h3 id="h2-501737c03-0003">Adding the is_prime Function</h3>
<p class="BodyFirst">Now that we have all the internal functions defined, let’s change the definition of the <code>is_prime</code> exported function so it returns <code>1</code> if the number passed in is prime and <code>0</code> if it’s not. <a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a> shows the new version of the <code>is_prime</code> function.</p>
<p class="CodeLabel"><b>is_prime.wat (part 4 of 4)</b></p>
<pre><code>...
<span class="LiteralGray">  ;; add the is_prime exported function after $multiple_check</span>
  (func (export "is_prime") (param $n i32) (result i32)
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (local $i i32)
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (if (i32.eq (local.get $n) (i32.const 1)) <span class="LiteralGray">;; 1 is not prime</span>
      (then
        i32.const 0
        return
      ))
    (if (call $eq_2 (local.get $n)) <span class="LiteralGray">;; check to see if $n is 2</span>
      (then
        i32.const 1 <span class="LiteralGray">;; 2 is prime</span>
        return
      )
    )

  (block $not_prime
    (call $even_check (local.get $n))
    br_if $not_prime <span class="LiteralGray">;; even numbers are not prime (except 2)</span>
    
    (local.set $i (i32.const 1))

    (loop $prime_test_loop
     
      (local.tee $i (i32.add (local.get $i) (i32.const 2) ) ) <span class="LiteralGray">;; $i += 2</span>
      local.get $n  <span class="LiteralGray">;; stack = [$n, $i]</span>
     
      i32.ge_u <span class="LiteralGray">;; $i &gt;= $n</span>
      if  <span class="LiteralGray">;; if $i &gt;= $n, $n is prime</span>
        i32.const 1
        return
      end

      (call $multiple_check (local.get $n) (local.get $i))
      br_if $not_prime    <span class="LiteralGray">;; if $n is a multiple of $i this is not prime</span>
      br $prime_test_loop <span class="LiteralGray">;; branch back to top of loop</span>
    ) <span class="LiteralGray">;; end of $prime_test_loop loop</span>
  )  <span class="LiteralGray">;; end of $not_prime block</span>
<span epub:type="pagebreak" title="50" id="Page_50"/>  i32.const 0 <span class="LiteralGray">;; return false</span>
  )
) <span class="LiteralGray">;; end of module</span></code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: The <code>$is_prime</code> function definition</p>
<p>Before we added the code in <a href="#listing3-6">Listing 3-6</a>, the <code>is_prime </code>function didn’t actually test for prime numbers. Previously, it always returned <code>0</code> (to be interpreted as false). Now that we’ve coded the <code>is_prime</code> function, it will return <code>1</code> if the number passed in is prime and <code>0</code> if it’s not. At the beginning of this function, we create a local variable <code>$i</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which we use later as a loop counter. We check whether <code>$n</code> is <code>1</code> and <code>return 0</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> if it is because the number one isn’t a prime number. We then eliminate half of the numbers by checking whether the number is 2, or even. If the number is 2, it’s prime; if it’s even but not 2, it’s not prime. We divide the number by every odd number from 3 to <code>$n-1</code>. If <code>$n</code> is evenly divisible by any of those numbers, it’s not prime. If it’s not evenly divisible by any of those numbers, it’s prime. The <code>$is_prime</code> function is rather large, so we’ll review it a piece at a time.</p>
<p><a href="#listing3-7" id="listinganchor3-7">Listing 3-7</a> is the portion of the code that tests whether the number is 2.</p>
<pre><code>...
 <span class="LiteralGray"> ;; the beginning of the $is_prime function in <a href="#listing3-6">listing 3-6</a></span>
  (if <span class="CodeAnnotationCode" aria-label="annotation1">1</span>(call $eq_2 (local.get $n)) <span class="LiteralGray">;; check to see if $n is 2</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (then
       i32.const 1 <span class="LiteralGray">;; 2 is prime</span>
       return
     )
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: The <code>$eq_2</code> number check from <code>$is_prime</code> in <a href="#listing3-6">Listing 3-6</a></p>
<p>The <code>if</code> statement calls the <code>$eq_2</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function defined earlier and passes it <code>$n</code>. If the value of <code>$n</code> is <code>2</code>, this function returns <code>1</code>; if not, it returns <code>0</code>. The <code>then</code> expression <span class="CodeAnnotation" aria-label="annotation2">2</span> runs if the value returned by the call is <code>1</code>, indicating that the number is prime.</p>
<p>Then we begin a block of code called <code>$not_prime</code>. If at any time the number is determined not to be a prime number, we exit this block, causing the function to exit with a return value of <code>0</code>, denoting the input isn’t prime. <a href="#listing3-8" id="listinganchor3-8">Listing 3-8</a> shows the beginning of that <code>block</code>.</p>
<pre><code>...
 <span class="LiteralGray"> ;; code from the $is_prime function in <a href="#listing3-6">listing 3-6</a></span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (block $not_prime
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $even_check (local.get $n))
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> br_if $not_prime <span class="LiteralGray">;; even numbers are not prime (except 2)</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>:  If the number is even, jump to <code>$not_prime</code>; from <code>$is_prime</code> in <a href="#listing3-6">Listing 3-6</a></p>
<p><span epub:type="pagebreak" title="51" id="Page_51"/>This block first calls <code>$even_check</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to see whether the number is even. Because we verified earlier that this number isn’t 2, any other even number wouldn’t be a prime. If <code>$even_check</code> returns <code>1</code>, the code leaves the <code>$not_prime</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> block using the <code>br_if</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> statement.</p>
<p>Next, <a href="#listing3-9" id="listinganchor3-9">Listing 3-9</a> begins the loop that checks the numbers that <code>$n</code> might be divisible by.</p>
<pre><code>...
 <span class="LiteralGray"> ;; code from the $is_prime function in <a href="#listing3-6">listing 3-6</a></span>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (local.set $i (i32.const 1))

  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (loop $prime_test_loop
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (local.tee $i
      (<span class="CodeAnnotationCode" aria-label="annotation4">4</span>i32.add (local.get $i) (i32.const 2) ) ) <span class="LiteralGray">;; $i += 2</span>
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.get $n   <span class="LiteralGray">;; stack = [$n, $i]</span>

     <span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.ge_u        <span class="LiteralGray">;; $i &gt;= $n</span>
     <span class="CodeAnnotationCode" aria-label="annotation7">7</span> if              <span class="LiteralGray">;; if $i &gt;= $n, $n is prime</span>
         i32.const 1
         return
       end
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-9">Listing 3-9</a>: Prime number test loop; from <code>$is_prime</code> in <a href="#listing3-6">Listing 3-6</a></p>
<p>Right before the loop, we set the value of <code>$i</code> to <code>1</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> because we’re looping over odd values when we increment through the loop. We call the loop<code> $prime_test_loop</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> so when we branch to <code>$prime_test_loop</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, it jumps back to that label. We use the <code>local.tee</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> command in combination with an <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> command to increment the value of <code>$i</code> by <code>2</code> (because we’re only testing odd numbers) and leave the value calculated by <code>i32.add</code> on the stack when <code>$i</code> is set. The <code>local.tee</code> command is like the <code>local.set</code> command in that it sets the value of the variable you pass to it to the value on top of the stack. The difference is that <code>local.set</code> pops that value off the top of the stack, whereas <code>local.tee</code> leaves the value on it. We want to keep the new value for <code>$i</code> on the stack to compare its value with <code>$n</code>, which we push onto the stack in the next line using a <code>local.get</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> expression.</p>
<p>The <code>i32.ge_u</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> expression pulls the last two values off the stack and checks whether the value we had in <code>$i</code> is greater than or equal to the value in <code>$n</code> (because a number can’t be divisible by a number greater than it) and assumes these integers are unsigned (because negative numbers can’t be prime). If this evaluates to true, the expression pushes <code>1</code> onto the stack, and if false, pushes <code>0</code> onto the stack.</p>
<p>The <code>if</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> statement that follows pulls one value off the stack and then executes the code between the <code>if</code> and <code>end</code> statements if the value pulled off the stack isn’t <code>0</code>. The upshot is, if <code>$i</code> is greater than or equal to <code>$n</code>, the number is prime. That means we only execute the code between the <code>if</code> and <code>end</code> statements if we incremented <code>$i</code> until its value is greater than or equal to <code>$n</code> without having ever found a number that evenly divides <code>$n</code>.</p>
<p><a href="#listing3-10" id="listinganchor3-10">Listing 3-10</a> shows the code that checks whether <code>$i</code> evenly divides <code>$n</code>, which would mean <code>$n</code> isn’t prime.</p>
<span epub:type="pagebreak" title="52" id="Page_52"/>
<pre><code>...
 <span class="LiteralGray"> ;; code from the $is_prime function in <a href="#listing3-6">listing 3-6</a></span>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $multiple_check (local.get $n) (local.get $i))
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> br_if $not_prime    <span class="LiteralGray">;; if $n is a multiple of $i this is not prime</span>
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> br $prime_test_loop <span class="LiteralGray">;; branch back to top of loop</span>
    ) <span class="LiteralGray">;; end of $prime_test_loop loop</span>
  )  <span class="LiteralGray">;; end of $not_prime block</span>
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.const 0 <span class="LiteralGray">;; return false</span>
  )</code></pre>
<p class="CodeListingCaption"><a id="listing3-10">Listing 3-10</a>: Call <code>$multiple_check</code> inside the prime test loop; from <code>$is_prime</code> in <a href="#listing3-6">Listing 3-6</a></p>
<p>The <code>call</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> expression at the beginning calls <code>$multiple_check</code>, passing it <code>$n</code> and <code>$i</code>. That returns <code>1</code> if <code>$n</code> is evenly divisible by <code>$i</code> and <code>0</code> if it’s not. If the value returned is <code>1</code>, the <code>br_if</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> statement jumps to the end of the <code>$not_prime</code> block, causing the <code>is_prime</code> function to return <code>0</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> (false). If <code>$multiple_check</code> returns <code>0</code>, we branch back to the top of the <code>loop</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. We do this to continue testing numbers until <code>$i</code> is greater than <code>$n</code>, or we find a <code>$i</code> where <code>$n</code> is evenly divisible by <code>$i</code>.</p>
<p>With all of our WAT code written, we can use <code>wat2wasm</code> to compile our WebAssembly module:</p>
<pre><code>wat2wasm is_prime.wat</code></pre>
<h3 id="h2-501737c03-0004">The JavaScript</h3>
<p class="BodyFirst">Once you’ve compiled the WebAssembly module, create a JavaScript file named <em>is_prime.js </em>and add the code in <a href="#listing3-11" id="listinganchor3-11">Listing 3-11</a> to load and call the WebAssembly <code>is_prime</code> function.</p>
<p class="CodeLabel"><b>is_prime.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/is_prime.wasm');
const value = parseInt(process.argv[2]);

(async () =&gt; {
  const obj =
    await WebAssembly.instantiate(new Uint8Array(bytes));
  if(<span class="CodeAnnotationCode" aria-label="annotation1">1</span>!!obj.instance.exports.is_prime(value)) {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> console.log(`
      ${value} is prime!
    `);
  }
  else {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> console.log(`
      ${value} is NOT prime
    `);
  }
})();</code></pre>
<p class="CodeListingCaption"><a id="listing3-11">Listing 3-11</a>: The <em>is_prime.js</em> file calls the <code>is_prime</code> WebAssembly function.</p>
<p><span epub:type="pagebreak" title="53" id="Page_53"/>When the <code>is_prime </code>function is called, passing in the value taken from a command line argument, the <code>!!</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> operator coerces the value from an integer into a true or false boolean value. If the value returned is <code>true</code>, we log out a message stating that the value is prime <span class="CodeAnnotation" aria-label="annotation2">2</span>. If the value returned is <code>false</code>, the message indicates that the value isn’t prime <span class="CodeAnnotation" aria-label="annotation3">3</span>. Now we can run the JavaScript function using <code>node</code> like this to check if 7 is a prime number:</p>
<pre><code>node is_prime.js 7</code></pre>
<p>Here’s the output you should see.</p>
<pre><code>      7 is prime!</code></pre>
<p>We’ve created several functions in our WebAssembly module that we use to check whether or not a number is prime. You should now be familiar with the basics of creating functions and calling those functions from within a WAT module.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Accessing the Stack from a Function</h2>
<p class="BoxBodyFirst">When the running code is inside a function, the <code>wat2wasm</code> compiler will throw an error if the code attempts to pop a value off the stack that your function didn’t push on. Here’s a small WebAssembly module that attempts to pop a value off the stack that was placed on it by the calling function (<a href="#listing3-12" id="listinganchor3-12">Listing 3-12</a>).</p>
<pre><code><span class="LiteralGray">;; wat2wasm will fail</span>
(module
  (func $inner
    (result i32)
    (local $l i32)
    <span class="LiteralGray">;; 99 is on the stack in the calling function</span>
    local.set $l 
         
    i32.const 2
  )
  (func (export "main")
   (result i32)
  
    i32.const 99 <span class="LiteralGray">;; push 99 onto stack - [99] </span><span class="CodeAnnotation" aria-label="annotation1">1</span>
    call $inner  <span class="LiteralGray">;; 99 is on the stack here </span><span class="CodeAnnotation" aria-label="annotation2">2</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing3-12">Listing 3-12</a>: WAT can only access stack variables added in the current function.</p>
<p>The <code>main</code> function first pushes <code>99</code> onto the stack <span class="CodeAnnotation" aria-label="annotation1">1</span>. When we call the function labeled <code>$inner</code>, the value of <code>99</code> is on the stack <span class="CodeAnnotation" aria-label="annotation2">2</span>. The first statement is <code>$inner</code> is <code>local.set</code>, which requires at least one item be on the stack when the statement is called. However, <code>wat2wasm</code> doesn’t care that you pushed an <span epub:type="pagebreak" title="54" id="Page_54"/>item onto the stack before calling the <code>$inner</code> function. If you fail to define a parameter, <code>wat2wasm</code> assumes that you don’t have something on the stack and throws an error. If you want a function to have access to a variable, you need to create a parameter when you define the function. You don’t have access to data on the stack put there by the calling function. You must pass in variables as parameters.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501737c03-0003">Declaring an Imported Function</h2>
<p class="BodyFirst">In this section, we’ll look at declaring functions as imports in more detail. We’ll need to import the <code>"print_string"</code> function from JavaScript, as shown in <a href="#listing3-13" id="listinganchor3-13">Listing 3-13</a>. </p>
<pre><code>(import "env" "print_string" (func $print_string( param i32 )))</code></pre>
<p class="CodeListingCaption"><a id="listing3-13">Listing 3-13</a>: Declaring an imported function <code>print_string</code></p>
<p>The <code>import</code> statement in <a href="#listing3-13">Listing 3-13</a> tells the module to import an object called <code>print_string </code>passed inside an object called <code>env</code>. These names must correspond with the names in the JavaScript code. Within the JavaScript, you can call the object anything you like, but once you name it in the JavaScript, you must use the same name when you import it into WebAssembly.</p>
<p><a href="#listing3-14" id="listinganchor3-14">Listing 3-14</a> shows what the import object looked like in the <em>helloworld.js</em> file.</p>
<p class="CodeLabel"><b>helloworld.js</b></p>
<pre><code>let importObject = {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> env: {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> buffer: memory,
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> start_string: start_string_index,
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> print_string: function(str_len) {
      const bytes = new Uint8Array( memory.buffer,
                                   start_string_index, str_len );
      const log_string = new TextDecoder('utf8').decode(bytes);
      console.log(log_string);
  }
}
};</code></pre>
<p class="CodeListingCaption"><a id="listing3-14">Listing 3-14</a>: Defining the <code>importObject</code></p>
<p>In the <code>"hello world" </code>app, we use a memory <code>buffer</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to set string data. We also let the WebAssembly module know the location of the string data (<code>start_string</code>) <span class="CodeAnnotation" aria-label="annotation3">3</span> inside the memory buffer. We put both objects inside an object called <code>env</code> to separate it from the JavaScript function. We then create the <code>print_string</code> function <span class="CodeAnnotation" aria-label="annotation4">4</span> inside the <code>env</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> object as the JavaScript callback that prints a string from linear memory. At the time of this writing, there isn’t a standardized convention for naming objects inside the <code/><span epub:type="pagebreak" title="55" id="Page_55"/>importObject. We’ve chosen the <code>env</code> object to represent objects related to the embedded environment and for the function callbacks, but you can organize the <code>importObject</code> in any way you like.</p>
<h3 id="h2-501737c03-0005">JavaScript Numbers</h3>
<p class="BodyFirst">When you create a JavaScript callback function, the only data type that function can receive is a JavaScript number. If you look at the <code>print_string</code> function we created in the <code>"hello world"</code> application, it passed a single variable. That variable is <code>str_len</code>, and it’s the byte length of the string displayed in the console. Unfortunately, only numbers can be passed as parameters to JavaScript functions. <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> explains in detail what to do to pass other kinds of data back to JavaScript.</p>
<h3 id="h2-501737c03-0006">Passing Data Types</h3>
<p class="BodyFirst">WebAssembly can pass three of the four main data types back to functions imported from JavaScript: they include 32-bit integers, 32-bit floating-point numbers, and 64-bit floating-point numbers. At the time of this writing, you can’t pass 64-bit integers to a JavaScript function. The BigInt WebAssembly proposal will change this when it’s implemented. Until then, you must choose the data type you want to convert it to and perform the conversion inside the WebAssembly module. If you pass a 32-bit integer or floating-point number to JavaScript, JavaScript converts it to a 64-bit float, which is the native JavaScript number type.</p>
<h3 id="h2-501737c03-0007">Objects in WAT</h3>
<p class="BodyFirst">WAT doesn’t support object-oriented programming (OOP). Creating classes and objects using WAT could potentially be accomplished using a combination of data structures, the function table, and indirect function execution, but that is beyond the scope of this book. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, we’ll explore how to create more sophisticated data structures within linear memory that will allow you to group the data together into linear memory in a way that is similar to using a <em>struct</em> in C/C++. Unfortunately, implementing OOP features, such as object methods, class inheritance, and polymorphism, are beyond what we can accomplish in this book.</p>
<h2 id="h1-501737c03-0004">Performance Implications of External Function Calls</h2>
<p class="BodyFirst">In this section, we’ll explore the performance implications of calling imported and exported functions. When you call a JavaScript function in WAT, you lose some cycles to overhead. This number isn’t extremely large, but if you execute an external JavaScript function in a loop that iterates 4,000,000 times, it can add up. To get an idea of the kind of performance hit an application suffers from calls to JavaScript versus internal WebAssembly function calls, we created a WebAssembly test module. It executes a simple increment 4,000,000 times in an external JavaScript function and 4,000,000 times in a WebAssembly function in the same module. <span epub:type="pagebreak" title="56" id="Page_56"/>Because the code does very little, most of the difference in execution time can be attributed to the overhead of calling an external JavaScript function. Calling an internal WebAssembly function executed four to eight times faster on Chrome than internal WebAssembly calls and two to two and a half times faster in Firefox than internal calls. In our tests, Chrome performed worse than Firefox when crossing the JavaScript/WebAssembly boundary.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	These tests only give rough approximations. They were conducted on a Windows PC and don’t necessarily reflect overall performance differences. Different versions of the browsers may also give different results.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Let’s walk through this performance test. You first need to create a new WAT file. Create an empty file and name it <em>func_perform.wat</em>. Then open the file and create a module with one import and one global variable, as shown in <a href="#listing3-15" id="listinganchor3-15">Listing 3-15</a>.</p>
<p class="CodeLabel"><b>func_perform.wat (part 1 of 4)</b></p>
<pre><code>(module
<span class="LiteralGray">  ;; external call to a JavaScript function</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "js" "external_call" (func $external_call (result i32)))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $i (mut i32) (i32.const 0)) <span class="LiteralGray">;; global for internal function</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-15">Listing 3-15</a>: Importing a JavaScript <code>external_call</code> function</p>
<p>The <code>import</code> expression <span class="CodeAnnotation" aria-label="annotation1">1</span> will import a function we’ll define in the JavaScript. That function will return a value to the WebAssembly module. The <code>global</code> expression <span class="CodeAnnotation" aria-label="annotation2">2</span> creates a mutable global variable with an initial value of <code>0</code>. In general, it’s considered bad practice to use mutable global variables, but this code is only intended as a means to test the difference in performance between a WebAssembly and JavaScript function call.</p>
<p>After we define the global variable, we define the WebAssembly function we’ll be calling 4,000,000 times, as shown in <a href="#listing3-16" id="listinganchor3-16">Listing 3-16</a>.</p>
<p class="CodeLabel"><b>func_perform.wat (part 2 of 4)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func $internal_call (result i32) <span class="LiteralGray">;; returns an i32 to calling function</span>
    global.get $i
    i32.const 1
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> global.set $i  <span class="LiteralGray">;; The first 4 lines of code in the function increments $i</span>

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> global.get $i  <span class="LiteralGray">;; $i is then returned to the calling function</span>
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-16">Listing 3-16</a>: Internal call to the WebAssembly function</p>
<p>The function <code>$internal_call</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> returns a 32-bit value to the calling function, which will be the incremented value of the <code>$i</code> global variable. All this function does is increment the value of <code>$i</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and then push it back on to the stack <span class="CodeAnnotation" aria-label="annotation3">3</span> to return it to the calling function.</p>
<p><span epub:type="pagebreak" title="57" id="Page_57"/>Next, we need to create a function that JavaScript can call with an <code>export</code> expression. This function needs to call the <code>$internal_call</code> function 4,000,000 times. <a href="#listing3-17" id="listinganchor3-17">Listing 3-17</a> shows the code for that external function.</p>
<p class="CodeLabel"><b>func_perform.wat (part 3 of 4)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func (export "wasm_call") <span class="LiteralGray">;; function "wasm_call" exported for JavaScript</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (loop $again             <span class="LiteralGray">;; $again loop</span>
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> call $internal_call    <span class="LiteralGray">;; call $internal_call WASM function</span>
      i32.const 4_000_000
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.le_u	            <span class="LiteralGray">;; is the value in $i &lt;= 4,000,000?</span>
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> br_if $again           <span class="LiteralGray">;; if so repeat the loop</span>
    )
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-17">Listing 3-17</a>: Four million calls to an internal function</p>
<p>This function <span class="CodeAnnotation" aria-label="annotation1">1</span> is exported to be called from the JavaScript code. It has a simple loop labeled <code>$again </code><span class="CodeAnnotation" aria-label="annotation2">2</span> that will call the <code>$internal_call</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span> 4,000,000 times. The loop does this by comparing the value returned by <code>$internal_call</code> (the value in the global <code>$i</code>) to <code>4_000_000</code>. If the value of <code>$i</code> is less than 4,000,000 (<code>i32.le_u</code>) <span class="CodeAnnotation" aria-label="annotation4">4</span>, it branches back to the beginning of the <code>$again</code> loop <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<p>Now that we have a function that will test the internal call to the WebAssembly function, in <a href="#listing3-18" id="listinganchor3-18">Listing 3-18</a> we create an almost identical function that will make a call to an external JavaScript function.</p>
<p class="CodeLabel"><b>func_perform.wat (part 4 of 4)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func (export "js_call")
    (loop $again
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $external_call) <span class="LiteralGray">;; calls the imported $external_call function</span>
      i32.const 4_000_000
      i32.le_u     <span class="LiteralGray">;; is the value returned by $external_call &lt;= 4,000,000?</span>
      br_if $again <span class="LiteralGray">;; if so, branch to the beginning of the loop</span>
    )
  )
)   <span class="LiteralGray">;; end of module </span><span class="CodeAnnotationCode" aria-label="annotation3">3</span></code></pre>
<p class="CodeListingCaption"><a id="listing3-18">Listing 3-18</a>: Four million calls to an external JavaScript function</p>
<p>There are only two differences between this function and the one in <a href="#listing3-19" id="listinganchor3-19">Listing 3-19</a>. The first is the name of the function we export, <code>"js_call"</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which calls the imported <code>$external_call</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function. The second is that we put a closing parenthesis at the end to close the <code>module</code> expression <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Once you’ve finished creating <em>func_perform.wat</em>, compile it into a WebAssembly module using the following command:</p>
<pre><code>wat2wasm func_perform.wat</code></pre>
<p>Now compile this module with <code>wat2wasm</code>. Then create an empty JavaScript file named <em>func_perform.js.</em> This JavaScript will load and call our WebAssembly module. Add the JavaScript in <a href="#listing3-19">Listing 3-19</a>.</p>
<span epub:type="pagebreak" title="58" id="Page_58"/>
<p class="CodeLabel"><b>func_perform.js (part 1 of 2)</b></p>
<pre><code>  const fs = require('fs');
  const bytes = fs.readFileSync(__dirname + '/func_perform.wasm');

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> let i = 0;
  let importObject = {
  js: {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> external_call: function () { <span class="LiteralGray">// The imported JavaScript function</span>
      i++;
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> return i; <span class="LiteralGray">// increment i variable and return it</span>
    }
  }
};
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-19">Listing 3-19</a>: The <code>external_call</code> function defined in the JavaScript <code>importObject</code></p>
<p>We declare the variable <code>i</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and initialize its value to <code>0</code>. Inside <code>importObject</code> we create a function <code>"external_call"</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> which we imported into the WebAssembly earlier. The only thing this function does is increment and then return the value in <code>i</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Next, we need to instantiate the <em>func_perform.wasm</em> module and execute <code>wasm_call</code> and <code>js_call</code>, as shown in <a href="#listing3-20" id="listinganchor3-20">Listing 3-20</a>.</p>
<p class="CodeLabel"><b>func_perform.js (part 2 of 2)</b></p>
<pre><code>...
(async () =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> const obj = await WebAssembly.instantiate(new Uint8Array(bytes),
                                            importObject);
  <span class="LiteralGray">// destructure wasm_call and js_call from obj.instance.exports</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> ({ wasm_call, js_call } = obj.instance.exports);

  let start = Date.now();
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> wasm_call();  <span class="LiteralGray">// call wasm_call from WebAssembly module</span>
  let time = Date.now() - start;
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> console.log('wasm_call time=' + time); <span class="LiteralGray">// execution time in ms</span>

  start = Date.now();
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> js_call();   <span class="LiteralGray">// call js_call from WebAssembly module</span>
  time = Date.now() - start;
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> console.log('js_call time=' + time); <span class="LiteralGray">// execution time in milliseconds</span>
})();</code></pre>
<p class="CodeListingCaption"><a id="listing3-20">Listing 3-20</a>: Asynchronous IIFE definition inside JavaScript</p>
<p>Like the other apps in this book so far, we must instantiate the <em>func_perform.wasm</em> module <span class="CodeAnnotation" aria-label="annotation1">1</span> in the JavaScript. We use the JavaScript destructuring syntax to create the <code>wasm_call</code> and <code>js_call</code> functions <span class="CodeAnnotation" aria-label="annotation2">2</span>. This destructuring is an ECMAScript 2015 syntax that’s convenient for pulling multiple variables out of an object. Alternatively, you could set <code>wasm_call</code> and <code>js_call</code> variables to the values in <code>obj.instance.exports</code>.</p>
<p>After retrieving the functions from the WebAssembly module, we call <code>wasm_call</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and log the time it took to execute in milliseconds <span class="CodeAnnotation" aria-label="annotation4">4</span> to the <span epub:type="pagebreak" title="59" id="Page_59"/>console. Next, we call the <code>js_call</code> function <span class="CodeAnnotation" aria-label="annotation5">5</span> and log <span class="CodeAnnotation" aria-label="annotation6">6</span> the time it took to execute. </p>
<p>Run the JavaScript using node like so:</p>
<pre><code>node func_perform.js</code></pre>
<p>You should see something like this output logged to the console.</p>
<pre><code>wasm_call time=7
js_call time=32</code></pre>
<p>It took 7 milliseconds to call the WebAssembly function 4,000,000 times and 32 milliseconds for JavaScript. This might seem like a large difference, but a 25-millisecond difference spread over 4,000,000 calls is actually pretty small. If this function is only being called once per frame, the difference is trivial. However, if you have a loop that executes hundreds or thousands of times per frame render, it might be worth considering arranging your code differently for performance reasons. In the next section, we’ll look at function tables and their performance.</p>
<h2 id="h1-501737c03-0005">Function Tables</h2>
<p class="BodyFirst">JavaScript can set variables to functions, allowing an application to dynamically swap functions at runtime. WebAssembly doesn’t have this feature, but it does have <em>tables</em>, which at the time of this writing can only hold functions. For that reason, we’ll refer to them as <em>function tables</em>, although there are plans to support other types in the future. Function tables allow WebAssembly to dynamically swap functions at runtime, which allows compilers to support features such as function pointers and OOP virtual functions. For example, C/C++ programs use WebAssembly tables to implement function pointers. Currently, tables only support the <code>anyfunc</code> type (<code>anyfunc</code> is a generic WebAssembly function type), but in the future they might support JavaScript objects and DOM elements as well. Unlike import objects, JavaScript and WebAssembly can dynamically change tables at runtime. There is a performance cost to calling a function from a table rather than through an import because a function table entry must be called indirectly. Let’s compare the performance of functions called through a table and those called directly.</p>
<h3 id="h2-501737c03-0008">Creating a Function Table in WAT</h3>
<p class="BodyFirst">In this section, we’ll create and export a simple function table in WAT. We’ll build a module with four functions; two of which are imported from JavaScript, and two are defined inside the WebAssembly module. These functions will be very simple because the goal is to compare the performance of table function execution to a direct import. Create a new file named <em>table_export.wat</em> and enter the code in <a href="#listing3-21" id="listinganchor3-21">Listing 3-21</a>.</p>
<span epub:type="pagebreak" title="60" id="Page_60"/>
<p class="CodeLabel"><b>table_export.wat</b></p>
<pre><code>(module
  <span class="LiteralGray">;; javascript increment function</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "js" "increment" (func $js_increment (result i32)))
  <span class="LiteralGray">;; javascript decrement function</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "js" "decrement" (func $js_decrement (result i32)))

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (table $tbl (export "tbl") 4 anyfunc) <span class="LiteralGray">;; exported table with 4 functions</span>

  (global $i (mut i32) (i32.const 0))

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (func $increment (export "increment") (result i32)
 <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (global.set $i (i32.add (global.get $i) (i32.const 1))) <span class="LiteralGray">;; $i++</span>
    global.get $i
 )

<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (func $decrement (export "decrement") (result i32)
 <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (global.set $i (i32.sub (global.get $i) (i32.const 1))) <span class="LiteralGray">;; $i--</span>
   global.get $i
 )

 <span class="LiteralGray">;; populate the table</span>
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> (elem (i32.const 0) $js_increment $js_decrement $increment $decrement)
)</code></pre>
<p class="CodeListingCaption"><a id="listing3-21">Listing 3-21</a>: Exporting functions in a table</p>
<p>Two imports are in this module: a JavaScript <code>increment</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> and a JavaScript <code>decrement</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>. However, you cannot add a JavaScript function to a function table from within JavaScript. There is a <code>WebAssembly.Table</code> function set that allows you to set functions in a table, only with a function defined in a WebAssembly module. We can work around this restriction by importing the JavaScript function into a WebAssembly module and adding it to the table there.</p>
<p>The <code>table</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> expression creates the table and names it <code>$tbl</code>, which we can reference within the WAT code. We export <code>$tb1</code> and tell <code>table</code> the expression that there are four objects in this table of type <code>anyfunc</code> (currently the only type of table object supported). We then create two WebAssembly functions: the <code>$increment</code> function <span class="CodeAnnotation" aria-label="annotation4">4</span> sets the value of the global <code>$i</code> to <code>$i</code>+1 <span class="CodeAnnotation" aria-label="annotation5">5</span> and the <code>$decrement</code> function <span class="CodeAnnotation" aria-label="annotation6">6</span> sets the value of <code>$i</code> to <code>$i</code>-1 <span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<p>The last thing we do in this module is set the values in the table using the <code>elem</code> expression <span class="CodeAnnotation" aria-label="annotation8">8</span>. As its first parameter, the <code>elem</code> expression takes the index of the first element we set. We set all four elements, so we use <code>(i32.const</code><code> 0)</code> because the first parameter is the starting index we want to update. We then follow that parameter with the four function variables we want in the table.</p>
<p>Alternatively, if we only wanted to set the first two items in the table, we wouldn’t need to pass in all four function names and would do this:</p>
<pre><code>(elem (i32.const 0) $js_increment $js_decrement) <span class="LiteralGray">;; set first 2 table func</span></code></pre>
<p><span epub:type="pagebreak" title="61" id="Page_61"/>To set the second two items, we would change the value of the first parameter to let the expression know we’re starting with the third item in the table, as shown here:</p>
<pre><code>(elem (i32.const 2) $increment $decrement) <span class="LiteralGray">;; set table items 3 and 4</span></code></pre>
<p>The first parameter of the <code>elem</code> statement in <a href="#listing3-21">Listing 3-21</a> is an index of <code>0</code>, similar to an array. When you’ve finished adding this code, compile <em>table_export.wat</em> into <em>table_export.wasm</em> using the <code>wat2wasm</code> command.</p>
<h4 id="h3-501737c03-0001">Sharing a Table Between Modules</h4>
<p class="BodyFirst">Now that we have a <em>table_export.wasm</em>, let’s create a second WebAssembly file that shares the same table. Create a new WAT file named <em>table_test.wat</em>. We’ll begin the new WebAssembly module with a series of <code>import</code> statements and a <code>type</code> definition expression, as shown in <a href="#listing3-22" id="listinganchor3-22">Listing 3-22</a>.</p>
<p class="CodeLabel"><b>table_test.wat (part 1 of 3)</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "js" "tbl" (table $tbl 4 anyfunc))
<span class="LiteralGray">    ;; import increment function</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "js" "increment" (func $increment (result i32)))
<span class="LiteralGray">    ;; import decrement function</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (import "js" "decrement" (func $decrement (result i32)))

<span class="LiteralGray">   ;; import wasm_increment function</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (import "js" "wasm_increment" (func $wasm_increment (result i32)))
<span class="LiteralGray">   ;; import wasm_decrement function</span>
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (import "js" "wasm_decrement" (func $wasm_decrement (result i32)))

<span class="LiteralGray">   ;; table function type definitions all i32 and take no parameters</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (type $returns_i32 (func (result i32)))
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-22">Listing 3-22</a>: Function imports in the WebAssembly module</p>
<p>The first <code>import</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> imports the table, with four <code>anyfunc</code><code> </code>functions, in the <em>table_export.wat</em> file. Next, we import the JavaScript functions <code>increment</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>decrement</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which we’ll use to compare the performance of imported JavaScript functions against JavaScript functions defined in tables.</p>
<p>We then import the <code>wasm_increment</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and <code>wasm_decrement</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> functions defined in the <em>table_export.wat</em> file in the table. With this we can test the performance of a <code>call_indirect</code> to a table element with a call to the same function imported directly with an <code>import</code> statement.</p>
<p>The last expression is a <code>type</code> expression <span class="CodeAnnotation" aria-label="annotation6">6</span> which defines the signature of the functions in the table. I have to provide this <code>$returns_i32</code> type as a static parameter to <code>call_indirect</code>. We can expect that <code>call_indirect</code> will be slower than <code>call</code> because the type of the indirectly called function must be dynamically checked to match this provided type.</p>
<p><span epub:type="pagebreak" title="62" id="Page_62"/>Now, let’s use the code in <a href="#listing3-23" id="listinganchor3-23">Listing 3-23</a> to define four global variables that we’ll use to index into the function table.</p>
<p class="CodeLabel"><b>table_test.wat (part 2 of 3)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $inc_ptr i32 (i32.const 0))<span class="LiteralGray"> ;; JS increment function table index</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $dec_ptr i32 (i32.const 1)) <span class="LiteralGray">;; JS decrement function table index</span>

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (global $wasm_inc_ptr i32 (i32.const 2))<span class="LiteralGray"> ;; WASM increment function index</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (global $wasm_dec_ptr i32 (i32.const 3))<span class="LiteralGray"> ;; WASM decrement function index</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-23">Listing 3-23</a>: Global variable function table indexes</p>
<p>These four global variables are indexes into the function table and give us an easier way to keep track of which index corresponds to which function. The <code>$inc_ptr</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>$dec_ptr</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> variables point to the JavaScript <code>increment</code> and <code>decrement</code> functions, and <code>$wasm_inc_ptr</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>$wasm_dec_ptr</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> point to the WebAssembly versions of the <code>increment</code> and <code>decrement</code> functions in the table.</p>
<h4 id="h3-501737c03-0002">Defining the Test Functions</h4>
<p class="BodyFirst">With the imports and globals defined, we’ll define the four test functions. All of these functions will do the same task using different methods: they’ll call an <code>increment</code> function 4,000,000 times from a <code>loop</code> and then call a <code>decrement</code> function 4,000,000 times. One function will call the functions indirectly from the imported table; one will call them directly from an <code>import</code>; one will call a WebAssembly version from a table; and the last will call the <code>increment</code> and <code>decrement</code> functions from a direct <code>import</code>. In the end, we should be able to compare the performance of calling JavaScript functions through a table or directly, as well as compare the performance of calling a WebAssembly module function directly or through a table.</p>
<p><a href="#listing3-24" id="listinganchor3-24">Listing 3-24</a> shows the four function definitions.</p>
<p class="CodeLabel"><b>table_test.wat (part 3 of 3)</b></p>
<pre><code><span class="LiteralGray">;; Test performance of an indirect table call of JavaScript functions</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func (export "js_table_test")
    (loop $inc_cycle
      <span class="LiteralGray">;; indirect call to JavaScript increment function</span>
      (call_indirect (type $returns_i32) (global.get $inc_ptr))
      i32.const 4_000_000
      i32.le_u  <span class="LiteralGray">;; is the value returned by call to $inc_ptr &lt;= 4,000,000?</span>
      br_if $inc_cycle <span class="LiteralGray">;; if so, loop</span>
    )

    (loop $dec_cycle
      <span class="LiteralGray">;; indirect call to JavaScript decrement function</span>
      (call_indirect (type $returns_i32) (global.get $dec_ptr))
      i32.const 4_000_000
      i32.le_u  <span class="LiteralGray">;; is the value returned by call to $dec_ptr &lt;= 4,000,000?</span>
      br_if $dec_cycle <span class="LiteralGray">;; if so, loop</span>
    )
  )

<span epub:type="pagebreak" title="63" id="Page_63"/><span class="LiteralGray">;; Test performance of direct call to JavaScript functions</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (func (export "js_import_test")
    (loop $inc_cycle
      call $increment  <span class="LiteralGray">;; direct call to JavaScript increment function</span>
      i32.const 4_000_000
      i32.le_u  <span class="LiteralGray">;; is the value returned by call to $increment&lt;=4,000,000?</span>
      br_if $inc_cycle<span class="LiteralGray"> ;; if so, loop</span>
    )

    (loop $dec_cycle
      call $decrement  <span class="LiteralGray">;; direct call to JavaScript decrement function</span>
      i32.const 4_000_000
      i32.le_u  <span class="LiteralGray">;; is the value returned by call to $decrement&lt;=4,000,000?</span>
      br_if $dec_cycle <span class="LiteralGray">;; if so, loop</span>
    )
  )

<span class="LiteralGray">  ;; Test performance of an indirect table call to WASM functions</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (func (export "wasm_table_test")
    (loop $inc_cycle
    <span class="LiteralGray">  ;; indirect call to WASM increment function</span>
     (call_indirect (type $returns_i32) (global.get $wasm_inc_ptr))
     i32.const 4_000_000
     i32.le_u  <span class="LiteralGray">;; is the value returned by call to $wasm_inc_ptr&lt;=4,000,000?</span>
     br_if $inc_cycle <span class="LiteralGray">;; if so, loop</span>
    )

    (loop $dec_cycle
      <span class="LiteralGray">;; indirect call to WASM decrement function</span>
      (call_indirect (type $returns_i32) (global.get $wasm_dec_ptr))
      i32.const 4_000_000
      i32.le_u  <span class="LiteralGray">;; is the value returned by call to $wasm_dec_ptr&lt;=4,000,000?</span>
      br_if $dec_cycle <span class="LiteralGray">;; if so, loop</span>
    )
  )

<span class="LiteralGray">  ;; Test performance of direct call to WASM functions</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (func (export "wasm_import_test")
    (loop $inc_cycle
      call $wasm_increment  <span class="LiteralGray">;; direct call to WASM increment function</span>
      i32.const 4_000_000
      i32.le_u
      br_if $inc_cycle
    )

    (loop $dec_cycle
      call $wasm_decrement  <span class="LiteralGray">;; direct call to WASM decrement function</span>
      i32.const 4_000_000
      i32.le_u
      br_if $dec_cycle
    )
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing3-24">Listing 3-24</a>: Performance testing</p>
<p><span epub:type="pagebreak" title="64" id="Page_64"/>The first function we define for <code>export</code> is <code>js_table_test</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. This function runs 8,000,000 indirect calls to simple JavaScript functions. The function following <code>js_table_test</code> is <code>js_import_test</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The <code>js_import_test</code> function calls the same functions <code>js_table_test</code> does. However, it does it directly from an <code>import</code>. This allows us to compare the performance of 8,000,000 runs of the same function with and without the use of a table. The other two functions, <code>wasm_table_test</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>wasm_import_test</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, are the same as the <code>js</code> versions of those functions but call WebAssembly module functions instead of JavaScript functions.</p>
<p>Once you’ve created your <em>table_test.wasm</em> file, create a new JavaScript file named <em>table.js </em>and add the code in <a href="#listing3-25" id="listinganchor3-25">Listing 3-25</a>.</p>
<p class="CodeLabel"><b>table.js (part 1 of 4)</b></p>
<pre><code>const fs = require('fs');
const export_bytes = fs.readFileSync(__dirname+'/table_export.wasm');
const test_bytes = fs.readFileSync(__dirname + '/table_test.wasm');

let i = 0;
let increment = () =&gt; {
  i++;
  return i;
}
let decrement = () =&gt; {
  i--;
  return i;
}
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-25">Listing 3-25</a>: JavaScript <code>increment</code> and <code>decrement</code> functions</p>
<p>We’ll test these functions by calling them directly using an <code>import</code> and indirectly using a table.</p>
<h4 id="h3-501737c03-0003">Creating the WebAssembly importObject in JavaScript</h4>
<p class="BodyFirst">Now we need an <code>importObject</code> that we’ll use for both of the WebAssembly modules. This object defines all of the functions, values, and tables we want to pass from the JavaScript into a WebAssembly module. In <a href="#listing3-27" id="listinganchor3-27">Listing 3-27</a>, we’ll also use it to pass a table from one WebAssembly module to another. We’ll initially set the <code>tbl</code>, <code>wasm_decrement</code>, and <code>wasm_increment</code> objects to <code>null</code> because they’re not yet being used by the <em>table_export.wasm</em> module. But they’ll be needed when we load the <em>table_test.wasm</em> module. <a href="#listing3-26" id="listinganchor3-26">Listing 3-26</a> shows the <code>importObject</code>.</p>
<p class="CodeLabel"><b>table.js (part 2 of 4)</b></p>
<pre><code>...
const importObject = {
  js: {
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> tbl: null, <span class="LiteralGray">// tbl is initially null and is set for the second WASM module</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> increment: increment, <span class="LiteralGray">// JavaScript increment function</span>
    decrement: decrement, <span class="LiteralGray">// JavaScript decrement function</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> wasm_increment: null, <span class="LiteralGray">// Initially null, set to function by second module</span>
<span epub:type="pagebreak" title="65" id="Page_65"/>    wasm_decrement: null  <span class="LiteralGray">// Initially null, set to function by second module</span>
  }
};
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-26">Listing 3-26</a>: JavaScript <code>importObject</code></p>
<p>At this point, the <code>tbl</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> value we pass in through the <code>importObject</code> is <code>null</code>, because it’s created in the <em>table_export.wasm</em> module, and we’ll need to initialize that value with the table exported from <em>table_export.wasm</em>. The <code>increment</code> and <code>decrement</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> functions were defined earlier in the JavaScript. We haven’t defined the <code>wasm_increment</code> and <code>wasm_decrement</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> functions yet because we’ll need to put them into the <code>import</code> function after they’re created in <em>table_export.wasm</em>.</p>
<h4 id="h3-501737c03-0004">Instantiating the WebAssembly Modules</h4>
<p class="BodyFirst">Now let’s look at how to instantiate the two WebAssembly modules in <a href="#listing3-27">Listing 3-27</a>.</p>
<p class="CodeLabel"><b>table.js (part 3 of 4)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (async () =&gt; {
  <span class="LiteralGray">// instantiate the module that uses a function table</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> let table_exp_obj = await WebAssembly.instantiate(
      new Uint8Array(export_bytes), importObject);

<span class="LiteralGray">  // set the tbl variable to the exported table</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> importObject.js.tbl = table_exp_obj.instance.exports.tbl;

  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> importObject.js.wasm_increment =
      table_exp_obj.instance.exports.increment;
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> importObject.js.wasm_decrement =
      table_exp_obj.instance.exports.decrement;
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> let obj = await WebAssembly.instantiate(
              new Uint8Array(test_bytes), importObject);
...</code></pre>
<p class="CodeListingCaption"><a id="listing3-27">Listing 3-27</a>: Instantiating a WebAssembly module in asynchronous IIFE</p>
<p>As we’ve done previously, we use an asynchronous IIFE <span class="CodeAnnotation" aria-label="annotation1">1</span> to instantiate the WebAssembly modules. However, now we instantiate two WebAssembly modules instead of just a single module to demonstrate how we can share functions and function tables between WebAssembly modules. When we instantiate the <em>table_export.wasm</em> module, we put the WebAssembly object into a variable called <code>table_exp_obj</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. In the past we’ve put all the WebAssembly module objects into a variable called <code>obj</code>, but because we’re using more than one module in this app, we need more specific names.</p>
<p>We use the <code>table_exp_obj</code> to set the <code>tbl</code> variable <span class="CodeAnnotation" aria-label="annotation3">3</span>, defined earlier in the <code>importObject</code>, to the function table created in the <em>table_export.wasm</em> module. Next, we set the <code>wasm_increment</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and <code>wasm_decrement</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> variables in the <code>importObject</code>. Then we instantiate the <em>table_test.wasm</em> module <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p><span epub:type="pagebreak" title="66" id="Page_66"/>The last block of code in this section, in <a href="#listing3-28" id="listinganchor3-28">Listing 3-28</a>, performs the test and measures the time in milliseconds each test took to run.</p>
<p class="CodeLabel"><b>table.js (part 4 of 4)</b></p>
<pre><code>...
  <span class="LiteralGray">// use destructuring syntax to create JS functions from exports</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> ({ js_table_test, js_import_test,
     wasm_table_test, wasm_import_test } = obj.instance.exports);

  i = 0; <span class="LiteralGray">// i variable must be reinitialized to 0</span>
  let start = Date.now(); <span class="LiteralGray">// get starting timestamp</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> js_table_test();        <span class="LiteralGray">// run function that tests JS table calls</span>
  let time = Date.now() - start; <span class="LiteralGray">// find out how much time it took to run</span>
  console.log('js_table_test time=' + time);

  i = 0; <span class="LiteralGray">// i must be reinitialized to 0</span>
  start = Date.now(); <span class="LiteralGray">// get starting timestamp</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> js_import_test();   <span class="LiteralGray">// run function that tests JS direct import calls</span>
  time = Date.now() - start;
  console.log('js_import_test time=' + time);

  i = 0; <span class="LiteralGray">// i must be reinitialized to 0</span>
  start = Date.now(); <span class="LiteralGray">// get starting timestamp</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> wasm_table_test();  <span class="LiteralGray">// run function that tests WASM table calls</span>
  time = Date.now() - start; <span class="LiteralGray">// find out how much time it took to run</span>
  console.log('wasm_table_test time=' + time);

  i = 0; <span class="LiteralGray">// i must be reinitialized to 0</span>
  start = Date.now(); <span class="LiteralGray">// get starting timestamp</span>
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> wasm_import_test(); <span class="LiteralGray">// run function that tests WASM direct import calls</span>
  time = Date.now() - start; <span class="LiteralGray">// find out how much time it took to run</span>
  console.log('wasm_import_test time=' + time);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing3-28">Listing 3-28</a>: Calling the WebAssembly functions and recording the execution time</p>
<p>We use the JavaScript destructuring syntax to create four variables <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>{js_table_test, js_import_test, wasm_table_test, wasm_import_test}</code>, from the <code>obj.instance.exports</code> object’s attributes. This is just a handy way to create all four of these function variables at once and set them to the functions of the same name exported by the WebAssembly module.</p>
<p>Then we run each of the functions one by one using <code>node</code>, like this:</p>
<pre><code>node table.js</code></pre>
<p>Here are the four lines you should see displayed to the console that show the <code>js_table_test</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, <code>js_import_test</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, <code>wasm_table_test</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, and <code>wasm_import_test</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> runtime:</p>
<pre><code>js_table_test time=67
js_import_test time=60
wasm_table_test time=25
wasm_import_test time=20</code></pre>
<p><span epub:type="pagebreak" title="67" id="Page_67"/>The line displaying the <code>js_import_test</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> runtime shows that for this run, calling the JavaScript through an <code>import</code> executed about 10 percent faster than calling the same function using a table. Although this might not seem like a tremendous difference, it depends on your application’s needs.</p>
<p>We then see the time in milliseconds it takes to call similar WebAssembly versions of the <code>increment</code> and <code>decrement</code> functions. This difference is a bit more significant: the table call takes about 25 percent longer than the direct <code>import</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you get inconsistent test results, you might want to increase the number of runs from 4,000,000 to 20,000,000 or more. Four million worked well for us here, but results will vary based on your computer hardware.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In this section, you learned how to share functions and function tables between different WebAssembly modules. You also learned the difference between calling a function directly from an <code>import</code> and calling one indirectly through a table, and the performance implications of calling a function using a table. Understanding how functions are called, imported, exported, and used in function tables are fundamental features of the language you’ll need to understand before you master WebAssembly development.</p>
<h2 id="h1-501737c03-0006">Summary</h2>
<p class="BodyFirst">In this chapter, we examined calling WebAssembly functions from JavaScript and JavaScript functions from WebAssembly. We covered what the performance implications of each type of call are. We also created an app that tests for prime numbers to demonstrate the kind of function that it makes sense to create in a WebAssembly module. We looked at passing parameters to functions defined in WebAssembly and how to create functions in WebAssembly that won’t be available to JavaScript. We looked into what it takes to create functions that manipulate strings within WebAssembly and how to access those strings from JavaScript. We dove further into data types in WebAssembly and how they translate into data types in JavaScript. We reviewed tables and how to use them to indirectly call WebAssembly and JavaScript functions, including WebAssembly functions created in a second module. We also spent time investigating the performance implications of using tables and functions created in a second WebAssembly module. In the next chapter, we’ll explore using WAT for low-level programming.</p>
</section>
</div></body></html>