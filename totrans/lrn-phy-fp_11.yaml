- en: '10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DESCRIBING MOTION IN THREE DIMENSIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](ch04.xhtml), we reviewed one-dimensional kinematics, describing
    quantities like velocity and acceleration with real numbers. In this chapter,
    we’ll look at three-dimensional kinematics, describing velocity and acceleration
    as vectors. Haskell does not have a built-in type for vectors, but it does have
    powerful facilities for making your own types, which we’ll use to create a `Vec`
    type for vectors. Before deciding how to implement the `Vec` type, we’ll take
    a careful look at the meaning and use of vectors in physics so we can produce
    an implementation that aligns well with how we think and write about vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Three-Dimensional Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notion of a three-dimensional vector is essential in physics. In physics,
    vectors are geometric objects used to describe quantities that have a magnitude
    and a direction in space. They are best thought of as arrows in which the length
    of the arrow represents the magnitude and the arrow points in some direction.
    Living on the surface of the earth as we do, directions can sometimes be described
    briefly in words, such as “up,” “north,” and so on. We can only ever specify the
    direction of a vector relative to some object, such as the earth; there is no
    universal or absolute notion of direction.
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed one-dimensional motion in [Chapter 4](ch04.xhtml), we did
    it in the context of an air track that came already marked in meters. The markings
    on the air track amount to a coordinate system in one dimension. A *coordinate
    system* is a method for describing position in terms of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Nature does not typically grant us a coordinate system to use; instead, we choose
    the coordinate system we want to use. In three dimensions, this amounts to choosing
    a location and orientation for a set of three mutually perpendicular directions.
    Along each direction (let’s call them *x*, *y*, and *z*), we make (real or imaginary)
    marks, in meters. The place where *x* = *y* = *z* = 0 is called the *origin* of
    the coordinate system. Once we have chosen a coordinate system, a position can
    be described by three numbers (*x*, *y*, and *z*), indicating the (positive or
    negative) distance from the origin in each direction.
  prefs: []
  type: TYPE_NORMAL
- en: To describe motion in three dimensions, we usually need to introduce a coordinate
    system. But the laws of physics shouldn’t depend on any particular coordinate
    system. They should work with whatever coordinate system we want to use. Vectors
    are geometric objects; along with the laws of physics, vectors have an existence
    apart from any coordinate system. Vectors allow various operations we can describe
    without a coordinate system. We’ll give geometric (coordinate-free) descriptions
    of the important properties and operations of vectors and then show how the same
    operations appear once we have introduced a coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the various vector operations, I want to write the code
    that must exist at the top of the source code file for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line turns on compiler warnings, which is a good idea to help avoid
    some common mistakes that are legal code but may not mean what you think they
    mean. If there are warnings, you will see them when you load the file.
  prefs: []
  type: TYPE_NORMAL
- en: The next line gives the code in this chapter a module name so that this code
    can be imported into another source code file later. The module name `SimpleVec`
    must match the name of the file that contains it, so the filename should be *SimpleVec.hs*.
    The remaining lines specify precedence levels and associativities for the operators
    we define later in the chapter. The precedence levels are numbers from 0 to 9,
    described in [Chapter 1](ch01.xhtml), that determine which operators act first
    in an expression with multiple operators. The keyword `infixl` is for an operator
    with left associativity, while `infixr` is for right associativity.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate-Free Vectors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have this code at the top of our file and have a basic idea of what
    vectors are, let’s look some of their geometric properties. We’ll give the geometric
    definitions for vector addition, scalar multiplication, vector subtraction, the
    dot product, the cross product, and the derivative of a vector-valued function
    of a real number. If you’re interested, the book *Modern Classical Physics* [**[6](bib.xhtml#bib6)**]
    by Kip Thorne and Roger Blandford gives an elegant motivation for the coordinate-free,
    geometric view of vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Vector Addition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can combine two vectors using what we’ll call *vector addition*. Geometrically,
    we define the sum of two vectors to be the vector that points from the tail of
    the first to the tip of the second when the two vectors are placed tip-to-tail.
    You can see from [Figure 10-1](ch10.xhtml#ch10fig1) that the order in which they
    are placed tip-to-tail does not matter; consequently, vector addition is commutative
    (**A** + **B** = **B** + **A**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/131fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Vector addition. The vector **A** + **B** is the sum of vectors
    **A** and **B**.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Physicists need to know whether a symbol stands for a number or a vector; thus,
    the theory of Newtonian mechanics (and most other theories in physics) invites
    us to think in terms of types. The mathematical notation that physicists typically
    use to indicate a vector is syntactic and identifies a vector by a boldface symbol.
    In Haskell, the distinction between numbers and vectors is not syntactic; names
    for each are simply identifiers that begin with a lowercase letter. In Haskell,
    the distinction between numbers and vectors is semantic and is captured by the
    type of the value: `R` for numbers and `Vec` for vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematical notation, we use the same + sign for vector addition that we
    use for addition of numbers, even though vectors and numbers are very different
    things and it makes no sense to add a vector to a number. In Haskell, we’ll use
    a different symbol (`^+^`) for vector addition than we do for number addition.
    If `a` and `b` are vectors (we write `a :: Vec` to say that `a` has type `Vec`),
    then `a ^+^ b` will be their vector sum. At the end of the chapter, we’ll show
    how to define the `Vec` type and the `^+^` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we introduce new operators for vector addition, subtraction,
    and scalar multiplication. An alternative path, which we do not follow, would
    be to expand the definitions of addition (`+`), subtraction (`-`), and multiplication
    (`*`) so they work for vectors as well as numbers. The Haskell language is certainly
    powerful enough to do this. The reason we don’t follow this course is that we
    prefer to have simple, concrete types for our vector operations, rather than types
    involving type classes. The names, such as `^+^`, that we use for the new operators
    are borrowed from Conal Elliott’s `vector-space` package [**[7](bib.xhtml#bib7)**],
    a more sophisticated and general way of dealing with vectors than we present here.*'
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Scaling a Vector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define scaling a vector by a number (also called *scalar multiplication*
    or multiplying a number by a vector) as follows: if the number is positive, we
    multiply the magnitude of the vector by the number and leave the direction of
    the vector unchanged. If the number is negative, we multiply the magnitude of
    the vector by the absolute value of the number and flip the direction of the vector.
    If the number is 0, the result is the zero vector.'
  prefs: []
  type: TYPE_NORMAL
- en: We define division of a vector **A** by a number *m* to be scalar multiplication
    of the vector by the reciprocal of *m*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/132equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Figure 10-2](ch10.xhtml#ch10fig2), we show the results of scaling a vector
    by 2, – 1, and – 1/2\. Scaling by a positive number multiplies the length of the
    vector, keeping the direction the same. Scaling by a negative number multiples
    the vector’s length and flips its direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/133fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Scalar multiplication. Scaling **A** by 2, –1, and –1/2 results
    in 2 **A**, –**A**, and –**A**/2, respectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical notation, we use the same juxtaposition of symbols (placing
    a number beside a vector) for scalar multiplication that we use for multiplication
    of numbers, even though the operation is different. Similarly, we use the same
    sign (/) for dividing a vector by a number, even though the operation is different.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, we’ll use different symbols for scalar multiplication than we do
    for number multiplication, and a different symbol for division of a vector by
    a number than we use for division of a number by a number. If `m` is a number
    and `a` is a vector, then `m *^ a` and `a ^* m` each mean the scaling of `a` by
    `m`. Note that the caret sign is closer to the vector in each case. To divide
    `a` by `m`, we write `a ^/ m`.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Vector Subtraction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to combine two vectors is with what we’ll call *vector subtraction*.
    The difference of two vectors is defined to be the vector that points from the
    tip of the first to the tip of the second when the two vectors are placed tail-to-tail.
    [Figure 10-3](ch10.xhtml#ch10fig3) shows that the difference of two vectors is
    equal to the sum of one vector and the opposite of the other vector. In symbols,
    **B** – **A** = **B** + (–**A**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/133fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Vector subtraction. The vector **B** – **A** is the difference
    of vectors **B** and **A**.*'
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical notation, we use the same sign (–) for vector subtraction that
    we use for subtraction of numbers, even though vectors and numbers are very different
    things. In Haskell, if `a` and `b` are vectors, we’ll define `a ^-^ b` to be their
    vector difference.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Dot Product
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are (at least) two important products of vectors in physics. One is the
    *dot product*, or *inner product*. The dot product of two vectors is a scalar,
    or number. Here’s the geometric definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A · B** = *AB* cos θ'
  prefs: []
  type: TYPE_NORMAL
- en: In this equation, *θ* is the angle between the two vectors when they are placed
    tail-to-tail, and we use the standard notation of allowing an italic symbol to
    stand for the magnitude of the vector whose boldface symbol has the same letter.
    In other words, *A* = |**A**| and *B* = |**B**|.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-4](ch10.xhtml#ch10fig4) shows that the dot product of two vectors
    is the product of the magnitude of one vector (*B* or *A*) and the projection
    of the second vector onto the first (*A* cos *θ* or *B cos θ*, respectively).
    Note that the projection will be negative when *θ* > 90^∘.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/134fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: The dot product of two vectors is the product of the magnitude
    of one vector and the projection of the second vector onto the first.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the dot product is commutative: **A ⋅B = B ⋅A**. Also, the dot
    product is related to the magnitude of a vector.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A · A** = |A|² cos (0) = |**A**|² = *A*²'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/134equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dot product distributes over a vector sum.
  prefs: []
  type: TYPE_NORMAL
- en: '**C · (A + B) = C · A + C · B**'
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, if `a` and `b` are vectors, then `a <.> b` will be their dot product.
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Cross Product
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *cross product* of two vectors is the vector whose magnitude is given by
  prefs: []
  type: TYPE_NORMAL
- en: '|**A** × **B**| = *AB* sin θ'
  prefs: []
  type: TYPE_NORMAL
- en: and whose direction is perpendicular to both **A** and **B**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-5](ch10.xhtml#ch10fig5) shows the plane containing vectors **A**
    and **B**. To find the direction of **A** × **B**, imagine rotating vector **A**
    about its tail through an angle less than 180^∘ until it aligns with vector **B**.
    If counterclockwise rotation is required to carry this out, the direction of **A**
    × **B** is out of the page. If instead clockwise rotation is required, the direction
    of **A** × **B** is into the page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/135fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Cross product. The vector ***A**** × ****B*** points out of the
    page. The vector **B*** × ****A*** points into the page.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For **A** and **B** in [Figure 10-5](ch10.xhtml#ch10fig5), the vector **A**
    × **B** points out of the page and the vector **B** × **A** points into the page.
    The cross product is anti-commutative: **A** × **B** = –**B** × **A**. Note also
    that the cross product of any vector with itself is 0\. The magnitude of the cross
    product gives the area of the parallelogram formed by the two vectors when two
    additional parallel sides are added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cross product distributes over a vector sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C** × **(A + B)** = **C** × **A** + **C** × **B**'
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, if `a` and `b` are vectors, we’ll define `a >< b` to be their cross
    product. (The operator `><` is supposed to look like a cross product.)
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: '*If you are interested in mathematical innovations, the geometric product is
    more sophisticated than the dot and cross products, but it contains the essence
    of both. The book* Geometric Algebra for Physicists [**[8](bib.xhtml#bib8)**]
    *by Chris Doran and Anthony Lasenby is a nice introduction. The book* Space-Time
    Algebra [**[9](bib.xhtml#bib9)**] *by David Hestenes is another great resource.*'
  prefs: []
  type: TYPE_NORMAL
- en: Derivative of a Vector-Valued Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose **V** is a function that takes one real variable (such as time) as input
    and gives a vector (such as velocity) as output. Because we can subtract vectors,
    and because we can divide a vector by a number, we can define the derivative of
    a vector-valued function of a real number. In Haskell, the type of such a function
    is `R -> Vec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The derivative of **V**, denoted *D***V**, **V**’, or ![Image](Images/v-dot.jpg),
    is the function of one variable defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/135equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the leftmost minus sign is a subtraction of vectors. We are using
    the same *D* symbol for the derivative of a vector-valued function that we used
    for the derivative of a number-valued function.
  prefs: []
  type: TYPE_NORMAL
- en: The vector derivative takes a vector-valued function of one variable (a function
    with type `R -> Vec`) as input and provides a vector-valued function of one variable
    as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The type `(R -> Vec) -> R -> Vec` is the same as the type `(R -> Vec) ->` `(R
    -> Vec)`. Here is a vector derivative in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Like the function `derivative` from [Chapter 4](ch04.xhtml), this numerical
    derivative does not take a limit but instead uses a small interval `dt`, supplied
    by the user of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-1](ch10.xhtml#ch10tab1) shows a comparison of mathematical notation
    with Haskell notation for the vector operations we’ve introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Comparison of Mathematical Notation with Haskell Notation for
    Vector Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Math notation** | **Haskell notation** | **Haskell type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *t* | `t` | `R` |'
  prefs: []
  type: TYPE_TB
- en: '| *m* | `m` | `R` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | `a` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **B** | `b` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **V** | `v` | `R -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **V**(*t*) | `v t` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** + **B** | `a ^+^ b` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| *m* **A** | `m *^ a` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** *m* | `a ^* m` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **A**/*m* | `a ^/ m` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** – **B** | `a ^-^ b` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** ⋅ **B** | `a <.> b` | `R` |'
  prefs: []
  type: TYPE_TB
- en: '| **A** × **B** | `a >< b` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| *D***V** | `vecDerivative 0.01 v` | `R -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| *D***V**(*t*) | `vecDerivative 0.01 v t` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Image](Images/e0136-01.jpg) | `vecDerivative 0.01 v t` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: Let’s move on and see what happens with vectors when we introduce a coordinate
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We choose a coordinate system by choosing a location and orientation for a set
    of three mutually perpendicular directions. We define **î** to be a vector with
    magnitude 1 that points in the direction of increasing *x*. A vector with magnitude
    1 is also known as a *unit vector*. Vectors augmented with a hat are unit vectors.
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a coordinate system along with coordinate
    unit vectors in each coordinate direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/137fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: A right-handed coordinate system. The z-axis is to be imagined
    as coming out of the page.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because ![Image](Images/icap.jpg) has magnitude 1, we know that ![Image](Images/e0137-02.jpg).
    Similarly, we define ![Image](Images/jcap.jpg) to be a unit vector that points
    in the direction of increasing *y*, and we define ![Image](Images/kcap.jpg) to
    be a unit vector that points in the direction of increasing *z*. The reason they
    are called ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg), and ![Image](Images/kcap.jpg)
    goes back to William Rowan Hamilton and his quaternions. (Search for the William
    Rowan Hamilton video by A Capella Science for a wonderful musical biography of
    this mathematical physicist, set to a tune written for a political figure with
    the same last name.) Because ![Image](Images/icap.jpg) and ![Image](Images/jcap.jpg)
    are perpendicular, we know that ![Image](Images/e0137-03.jpg). By similar reasoning,
    we can find the dot products of all the coordinate unit vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/137equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because the cross product of any vector with itself is 0, we know that ![Image](Images/e0137-04.jpg).
    Because the three directions of our coordinate system are mutually perpendicular,
    we know that ![Image](Images/e0137-05.jpg). To resolve the sign ambiguity, we
    usually agree to use a *right-handed coordinate system*, which means that ![Image](Images/e0137-06.jpg).
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a right-handed coordinate system. By
    similar reasoning, we can find the cross products of all the coordinate unit vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we have a coordinate system and the coordinate unit vectors it gives rise
    to, we can “break a vector into components.” Any vector **A** can be expressed
    as a *linear combination* of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg). A linear combination of vectors means a number
    times the first, plus a number times the second, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We call *A[x]* the *x* component of **A**, and similarly for *y* and *z*. The
    collection of the three numbers *A[x]*, *A[y]*, and *A[z]* is called the *components*
    of **A** with respect to the coordinate system. By dotting the equation above
    by ![Image](Images/icap.jpg), we get an expression for *A[x]* in terms of ![Image](Images/icap.jpg)
    and **A**. We can do the same for *A[y]* and *A[z]*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Haskell code at the end of the chapter defines a default coordinate system
    you can use. The default coordinate system provides coordinate unit vectors `iHat`,
    `jHat`, and `kHat` that play the role of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the vector operations introduced above in a geometric way and
    see how they look with a coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Addition with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The components of a sum are the sums of the components. If **C** = **A** + **B**,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ04a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and similarly for the y- and z-components. If **C** = **A** + **B**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Haskell, this is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can think of the caret on each side of the plus sign as a reminder that
    there is a vector on the left and a vector on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Scaling with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If **C** = *m***A**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and similarly for the y- and z-components. If **C** = *m***A**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To scale a vector, we can use the `*^` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the caret goes on the right of the asterisk because the vector is
    on the right. You can multiply a `Vec` on the left by an `R` on the right with
    the `^*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the vector is on the left, the caret is on the left. Similarly, we can
    divide by an `R` with the `^/` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Vector Subtraction with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If **C** = **A** – **B**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and similarly for the *y* and *z* components. If **C** = **A** – **B**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We say “the components of a difference are the differences of the components.”
    The first use of the word *difference* refers to vector difference, while the
    second use refers to number difference. If `a` and `b` are vectors, then `xComp
    (a ^-^ b)` and `xComp a - xComp b` evaluate to the same number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of vector subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Dot Product with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the dot product along with Equation 10.2 to simplify the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/140equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we know the components of two vectors **A** and **B**, Equation 10.8 gives
    a handy way to find their dot product.
  prefs: []
  type: TYPE_NORMAL
- en: You can take the dot product of two `Vec`s with the `<.>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Cross Product with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the cross product along with Equation 10.3 to simplify the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/140equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we know the components of two vectors **A** and **B**, Equation 10.9 gives
    a good way to find their cross product.
  prefs: []
  type: TYPE_NORMAL
- en: You can take the cross product of two `Vec`s with the `><` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you need the components of a vector, you can get them with the `xComp` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are also functions `yComp` and `zComp`.
  prefs: []
  type: TYPE_NORMAL
- en: The unary minus sign (`-`) will not work to negate a vector, but you can negate
    a vector with `negateV`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Derivative with Coordinate Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose **V** is a vector-valued function of one real variable. If **W** = *D***V**,
    then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/140equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and similarly for the y- and z-components. If **W** = *D***V**, then
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/141equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of a vector-valued function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we cannot write the x-component of this vector-valued function in
    the most obvious way, namely `xComp v1`. This would produce a type error because
    `xComp` takes a `Vec` as input, not a function `R -> Vec`. What we really mean
    when we talk about the x-component of a vector-valued function is the scalar-valued
    function that takes an input `t`, applies the vector-valued function, and returns
    the x-component. In Haskell, the x-component of a vector-valued function can be
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In words, Equation 10.10 says that the x-component of the derivative is the
    same as the derivative of the x-component. In Haskell, the same equations say
    that the x-component of the (vector) derivative
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as the (scalar) derivative of the x-component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can check this in GHCi for a particular vector-valued function evaluated
    at a particular value of the independent variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We defined the scalar derivative in [Chapter 4](ch04.xhtml) and repeat it here
    for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 10-2](ch10.xhtml#ch10tab2) shows the types of the vector functions and
    expressions we’ve been working with.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-2:** Expressions and Functions for Working with Vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `zeroV` | `::` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `iHat` | `::` | `Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^+^)` | `::` | `Vec -> Vec -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^-^)` | `::` | `Vec -> Vec -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(*^)` | `::` | `R -> Vec -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^*)` | `::` | `Vec -> R -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(^/)` | `::` | `Vec -> R -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(<.>)` | `::` | `Vec -> Vec -> R` |'
  prefs: []
  type: TYPE_TB
- en: '| `(><)` | `::` | `Vec -> Vec -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `negateV` | `::` | `Vec -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `magnitude` | `::` | `Vec -> R` |'
  prefs: []
  type: TYPE_TB
- en: '| `xComp` | `::` | `Vec -> R` |'
  prefs: []
  type: TYPE_TB
- en: '| `vec` | `::` | `R -> R -> R -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: '| `sumV` | `::` | `[Vec] -> Vec` |'
  prefs: []
  type: TYPE_TB
- en: Now that we’ve seen some of the key properties of vectors in both geometric
    and coordinate settings, let’s take a look at how vectors get used to describe
    kinematics in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Kinematics in 3D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The essential quantities of kinematics are time, position, velocity, and acceleration.
    Time will continue to be a real number, as it was in [Chapter 4](ch04.xhtml).
    Velocity and acceleration we’ll now treat as vectors, using the `Vec` type that
    we’ll define at the end of the chapter. What about position?
  prefs: []
  type: TYPE_NORMAL
- en: Position is really not a vector. It doesn’t make sense to add positions, nor
    does it make sense to scale a position by a number. However, subtracting positions
    does make sense, and it produces a displacement vector from one position to the
    other. In [Chapter 22](ch22.xhtml), we’ll create a proper type for position, which
    allows us to use Cartesian, cylindrical, and spherical coordinates to describe
    positions. However, our aims are more modest at the moment and simplicity suggests
    that we use the `Vec` type for position, even though we just gave some reasons
    not to. Displacement is certainly a vector, so we can think of a vector-valued
    position as a displacement from the origin of the default coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the following type synonyms in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use the type `PosVec` to denote the type of a position when position is being
    represented by a vector. This will keep us from confusing it with the `Position`
    type we’ll define in [Chapter 22](ch22.xhtml), which, again, is not a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Position, Velocity, and Acceleration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a particular motion of an object, we define **r** to be the function that
    associates with each time *t* the position at which the object is located at time
    *t*. We say that **r**(*t*) is the position of the object at time *t*.
  prefs: []
  type: TYPE_NORMAL
- en: The velocity function for an object is the derivative of its position function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that Equation 10.11 is an equality of functions, the instantaneous velocity
    function on the left of the equality, and the derivative of the position function
    on the right. Equation 10.11 can be written in Haskell as the function `velFromPos`,
    which takes a small time step and position function to return a velocity function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the definition, the function `velFromPos` is just the vector
    derivative we defined earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When two functions are equal, they give equal results for equal inputs, so we
    can also write
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for any time *t*. The righthand side is the function *D***r** evaluated at time
    *t*. We can think of the derivative operator as taking the entire position function
    as input and returning the velocity function as output. It’s also common to see
    the notation
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to define velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Speed* is the magnitude of the velocity vector. *Acceleration* is defined
    to be the rate at which velocity changes. We define **a** to be the function that
    associates with each time *t* the rate at which the velocity is changing at time
    *t*. In the language of calculus, we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: to define acceleration. Equation 10.14 can be encoded in a function `accFrom`
    `Vel` that produces an acceleration function from a velocity function. Again,
    this function is just the vector derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the velocity happens to be constant, say **v[0]**, we can integrate both
    sides of Equation 10.11 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '**v**[0]*t* = **r**(*t*) – *r*(0)'
  prefs: []
  type: TYPE_NORMAL
- en: If velocity is constant, position is a linear function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**r**(*t*) = **v**[0]*t* + **r**(0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the corresponding Haskell code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The CV at the end of the name is an abbreviation for constant velocity.
  prefs: []
  type: TYPE_NORMAL
- en: If the acceleration happens to be constant, say **a**[0], we can integrate both
    sides of Equation 10.14 or 10.15 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '**a**[0]*t* = **v**(*t*) – **v**(0)'
  prefs: []
  type: TYPE_NORMAL
- en: If acceleration is constant, velocity is a linear function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I like to call Equation 10.16 the *velocity-time equation* for constant acceleration
    because it gives the velocity **v**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0] and initial velocity **v**(0). Here
    is the Haskell code for Equation 10.16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The CA at the end of the name is an abbreviation for constant acceleration.
    We can integrate both sides of Equation 10.16 to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If acceleration is constant, position is a quadratic function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I like to call Equation 10.17 the *position-time equation* for constant acceleration
    because it gives the position **r**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0], initial position **r**(0), and initial
    velocity **v**(0). Here is the Haskell code for Equation 10.17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Equations 10.16 and 10.17 are known as *constant acceleration equations*. They
    are used over and over again in a typical introductory physics course. Later we’ll
    learn some techniques to deal with situations in which acceleration is not constant.
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced the definitions of velocity and acceleration in the three-dimensional
    vector setting, we can now look at how acceleration is composed of two qualitatively
    different components.
  prefs: []
  type: TYPE_NORMAL
- en: Two Components of Acceleration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If at any moment the velocity of an object is 0, any acceleration the object
    has serves to give the object some velocity in the direction of the acceleration.
    If, on the other hand, **v**(*t*)≠0, the relative directions of velocity and acceleration
    determine the qualitative motion of the object. In everyday speech, people often
    use the word *acceleration* to mean increase in speed. However, in physics, acceleration
    means change in velocity per unit tine, and velocity can change in either magnitude
    or direction. In physics, acceleration is responsible not only for increases in
    speed but for decreases in speed and changes in direction.
  prefs: []
  type: TYPE_NORMAL
- en: If **v**(*t*)≠0, we can decompose the acceleration into a component parallel
    to the velocity and a component perpendicular to the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since **v**(*t*)≠0, we can define a unit vector in the direction of the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The parallel and perpendicular components of acceleration are given by the
    following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are Haskell functions that calculate the parallel and perpendicular components
    of acceleration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The parallel component **a**[∥](*t*) is also called the *tangential component*
    of acceleration, and it’s responsible for the change in speed of the object. The
    perpendicular component **a**[⊥](*t*) is also called the *radial* or *transverse
    component* of acceleration, and it’s responsible for the change in direction of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product of velocity and acceleration depends on the angle between them
    and thus contains useful information. Let’s take the time derivative of the square
    of the speed *v*^((*t*)2) = **v**(*t*) ⋅**v**(*t*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/146equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the dot product of velocity and acceleration controls how the
    speed changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dot product** | **Effect on speed** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) > 0 | Speed increases |'
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) = 0 | Speed remains constant |'
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) < 0 | Speed decreases |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, *v* stands for the speed function, which is a different convention
    from [Chapter 4](ch04.xhtml) where *v* was the one-dimensional velocity function.
    One-dimensional velocity can be negative, but speed can’t.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-7](ch10.xhtml#ch10fig7) shows how the relative direction of velocity
    and acceleration controls the qualitative behavior of an object’s motion.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/146equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: The relative directions of velocity and acceleration determine
    the qualitative motion of an object.*'
  prefs: []
  type: TYPE_NORMAL
- en: When acceleration has a component in the direction of velocity, an object speeds
    up. When acceleration has a component opposite the direction of velocity, an object
    slows down. When acceleration has only a component perpendicular to the velocity,
    an object maintains its speed. No coordinate system is necessary to make these
    conclusions; this aspect of the qualitative behavior of motion is purely geometric.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen how the tangential component of acceleration is related to speeding
    up and slowing down. We can make an even stronger statement: the rate of change
    of speed is directly related to the tangential component.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here is the rate of change of speed as a Haskell function. Given the velocity
    and acceleration of an object, this function returns the rate at which speed is
    increasing, with a negative result meaning that speed is decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The magnitude of the tangential component of acceleration equals the magnitude
    of the rate of change in speed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If there is a transverse component of acceleration, it causes the object to
    turn (in other words, to change direction). We can calculate a radius of curvature
    for this turning motion. [Figure 10-8](ch10.xhtml#ch10fig8) shows the trajectory
    of a particle with speed *v*(*t*) and transverse acceleration *a*[⊥](*t*). Over
    a small interval of time *Δt*, the particle will move forward a distance *v*(*t*)Δ*t*
    and in a perpendicular direction a distance *a*[⊥](*t*)Δ^(*t*2)/2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Determination of a radius of curvature from transverse acceleration*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-8](ch10.xhtml#ch10fig8) gives a way to find an expression for the
    radius of curvature in terms of the speed and the transverse acceleration. Here
    we write down the Pythagorean theorem for the right triangle in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Expanding this equation and taking the limit as Δ*t* → 0, which discards the
    term proportional to Δ*t*⁴, we arrive at the following equation for the radius
    of curvature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a Haskell function that computes the (instantaneous) radius of curvature
    of an object’s motion from the object’s velocity and acceleration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we wish, we can invert Equation 10.22 to give an expression for the transverse
    acceleration in terms of the radius of curvature *R*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see from Equations 10.21 and 10.23, the tangential component of acceleration
    controls the change in speed, and the radial component of acceleration controls
    the change in direction.
  prefs: []
  type: TYPE_NORMAL
- en: Projectile Motion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the very first uses to which vectors are typically put in physics is
    the study of projectile motion. A projectile is any object thrown, launched, or
    shot near the surface of the earth. The problem is to predict its motion *after*
    the throwing, launching, or shooting force is gone; in fact, rather than speak
    of the launching force, we instead assume that the action of launching simply
    gives the projectile some initial velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the presence of Earth’s gravity that makes projectile motion interesting.
    Physics offers four theories of gravity, three of which we will discuss in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: Gravity causes objects near Earth’s surface to accelerate. An object near Earth’s
    surface that is allowed to move or fall freely will accelerate toward the center
    of the earth at a rate of about 9.81 m/s².
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is a force produced by the earth on objects near its surface. We engage
    with this view of gravity in [Chapters 15](ch15.xhtml) and [16](ch16.xhtml) after
    we’ve started mechanics and discussed the ideas of force, mass, and Newton’s second
    law. The Haskell function `earthSurfaceGravity` in [Chapter 16](ch16.xhtml) describes
    this force of gravity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is a force between any two objects with mass. This is called Newton’s
    law of universal gravitation. We discuss it in [Chapters 16](ch16.xhtml) and [19](ch19.xhtml)
    and describe it with the Haskell function `universalGravity` after we have introduced
    Newton’s third law.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is the curvature of spacetime. This is Einstein’s general theory of
    relativity. We will not get to it in this book. The book `Gravitation` [**[10](bib.xhtml#bib10)**]
    by Charles Misner, Kip Thorne, and John Wheeler is an excellent introduction to
    general relativity. *Functional Differential Geometry* [**[11](bib.xhtml#bib11)**]
    by Gerald Sussman and Jack Wisdom looks at general relativity from a computational
    point of view, describing it with the functional programming language Scheme.
    Other introductions to general relativity by Rindler [**[12](bib.xhtml#bib12)**],
    Carroll [**[13](bib.xhtml#bib13)**], and Schutz [**[14](bib.xhtml#bib14)**] are
    also recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each theory in this list is more sophisticated than the previous theory. In
    that sense, the later theories are “more correct” than the earlier ones, although
    the earlier ones are often more useful since they are simpler and easier to apply.
    General relativity, in particular, while beautiful and accurate, is rather nontrivial
    to apply and to calculate with.
  prefs: []
  type: TYPE_NORMAL
- en: Some physicists may not agree that the first two theories on my list deserve
    to be called theories, arguing that they are instead approximations to Newton’s
    law of universal gravitation applicable to simple situations. It is not my concern
    to argue whether the first two deserve to be called theories; the important point
    is that they are different ways to incorporate gravity into our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to approach projectile motion, and the one we’ll follow in
    this chapter, is based on theory 1\. We assume the projectile accelerates only
    because of Earth’s gravitational attraction; therefore, the projectile’s acceleration
    is given by the acceleration of gravity, **g**, which is a vector pointing toward
    the center of the earth with magnitude 9.81 m/s².
  prefs: []
  type: TYPE_NORMAL
- en: Because the acceleration of gravity is constant, we can use the position-time
    equation, Equation 10.17, to give an expression for position as a function of
    time for a projectile.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/149equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the z-direction is up and we use SI units, the following function returns
    position as a function of time, where `r0` is the initial position of the projectile
    and `v0` is the initial velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In Exercise 10.5, you are asked to write a function `projectileVel` that returns
    the velocity of a projectile as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: Projectile motion with air resistance requires theory 2 because we view air
    resistance and gravity on an equal footing by seeing them both as forces. To the
    extent that projectile motion occurs near Earth’s surface, it rarely requires
    theories 3 or 4, which would produce only the slightest difference in results
    for a substantial increase in computation complexity. Theory 3 will have other
    uses, like satellite motion, that we’ll see in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen projectile motion as one early application of vectors, let’s turn
    to the project of creating the vector data type we have been using.
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Own Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell has a sophisticated and flexible type system. One of the language features
    that makes the type system so powerful is the ability to create your own types.
  prefs: []
  type: TYPE_NORMAL
- en: In discussing pattern matching in [Chapters 3](ch03.xhtml) and [5](ch05.xhtml),
    we noted that each type has one or more data constructors to construct values
    of that type. In making our own data type, we must provide one or more brand new
    data constructors as ways of constructing values of our new data type.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at making a new data type with a single data constructor before
    turning to making a new data type with multiple data constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Single Data Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml), we used the `type` keyword to make type synonyms.
    In a type synonym, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: the compiler regards the types `R` and `Double` as interchangeable. In [Chapter
    4](ch04.xhtml), the types `Time`, `Velocity`, `R`, and `Double` were all interchangeable.
    This was convenient, but it does not empower the Haskell type checker to help
    the code writer avoid confusing a `Time` with a `Velocity` or using a `Velocity`
    where a `Time` was expected.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `data` keyword to define new types that are not interchangeable with
    any existing types. Time and mass are each described by a real number in physics,
    but we should never provide a mass in an equation that calls for a time. Let’s
    define a new data type `Mass` that holds a real number but cannot be confused
    with `R` or any other existing data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We use the `data` keyword to define a new data type. We give the name of the
    new data type, `Mass` in this case, after the `data` keyword, followed by an equal
    sign. To the right of the equal sign we give a data constructor, `Mass` in this
    case, followed by the information our new data type contains, in this case `R`.
    The name of the new data type and the name of the data constructor can be the
    same or different. In this case, they have the same name, but they are different
    things. In defining data types with a single constructor, it’s common to use the
    same name for the data constructor that we use for the type, but it’s not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a new data type is not an instance of any type classes. Since it’s
    common to want a new data type to be an instance of some of the standard type
    classes, such as `Eq` and `Show`, Haskell provides a `deriving` keyword that attempts
    to make the new type an instance of the type classes listed.
  prefs: []
  type: TYPE_NORMAL
- en: To construct a value with type `Mass`, we use the data constructor `Mass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ask for the type of this value, GHCi will tell us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In GHCi’s response, the `Mass` on the left of the double colon is the data constructor,
    and the `Mass` on the right of the double colon is the data type.
  prefs: []
  type: TYPE_NORMAL
- en: The data constructor itself has a function type. It takes an `R` as input and
    returns a `Mass` as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are asking GHCi for the type of the data constructor, not the type of the
    type, which wouldn’t make any sense. Again, the `Mass` on the left of the double
    colon is the data constructor, and the `Mass` on the right of the double colon
    is the data type.
  prefs: []
  type: TYPE_NORMAL
- en: If we now accidentally supply a `Mass` in a place where an `R` is called for,
    the type checker will give us a type error, helping us to identify our mistake
    rather than silently doing the wrong thing.
  prefs: []
  type: TYPE_NORMAL
- en: We can provide more than a single piece of information under the data constructor.
    In [Chapter 9](ch09.xhtml) we used a list of pairs to hold grade information.
    Let’s define a new data type called `Grade` that holds a `String` and an `Int`,
    representing the name of a person and their grade on some assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We give the data constructor the same name as the type and simply list the types
    of information that are to be contained in the new data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of grades for a few people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To construct a value of type `Grade`, we use the data constructor `Grade`, followed
    by a `String` and an `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the type of the data constructor `Grade`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: we see that it takes a `String` and an `Int` as input and returns a `Grade`
    as output. As before, the `Grade` on the left of the double colon is the data
    constructor, and the `Grade` on the right of the double colon is the data type.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative syntax for defining a new data type, called *record
    syntax*, that gives names to each of the pieces of data under a constructor. Let’s
    define a new data type called `GradeRecord` that is essentially the same as the
    type `Grade` but uses record syntax for its definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To use record syntax, we enclose the names and types of each piece of information
    in curly braces after the data constructor. Use of record syntax automatically
    creates a new function for each named piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function `name` takes a `GradeRecord` as input and returns the `String`
    that holds the name in that `GradeRecord`. The function `grade` takes a `GradeRecord`
    as input and returns the `Int` that holds the grade in that `GradeRecord`. By
    default, the names `name` and `grade` are placed in the global namespace so they
    may not be reused as names for fields in another data type. This default behavior
    is simple but too constraining in some situations, so the language option `DuplicateRecordFields`
    is available to override this default behavior, although we will not explore it
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If we use record syntax to define our new data type, there are two ways to construct
    a value of that type. First, we can use the same syntax we used for the type `Grade`
    above, simply giving the data constructor followed by a `String` and an `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Second, we can use record syntax to construct a value of type `GradeRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we use curly braces and give the pieces of information by name rather than
    by position.
  prefs: []
  type: TYPE_NORMAL
- en: The decision on whether to use record syntax should be based on the usefulness
    of having names to describe the pieces of data that the new type holds. If you
    don’t need the names, you should use the basic syntax. If the names seem useful,
    record syntax is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to define a new data type with a single data constructor. Now
    let’s look at data types with more than one data constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Data Constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Prelude type `Bool` has two data constructors, `False` and `True`, as we
    saw when we did pattern matching on `Bool`. Neither of the data constructors contains
    any information beyond the name of the constructor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define a new data type called `MyBool` that works the same way `Bool`
    does. We need a fresh name because `Bool` is already defined in the Prelude.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We begin with the `data` keyword as before, followed by the name `MyBool` of
    our new data type. On the right of the equal sign, we give the first data constructor,
    which we call `MyFalse`, then a vertical bar, and then the second data constructor
    `MyTrue`. We need fresh names for the data constructors because the names `False`
    and `True` are already taken.
  prefs: []
  type: TYPE_NORMAL
- en: The vertical bar in the definition can be read as “or,” in the sense that a
    value of type `MyBool` is either `MyFalse` or `MyTrue`.
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the new data type `MyBool`, we can ask about the type of `MyFalse`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: and we are not surprised to find that it has type `MyBool`.
  prefs: []
  type: TYPE_NORMAL
- en: When we have multiple data constructors, they usually have different names from
    the data type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define our own version of `Maybe`, called `MyMaybe`. Recall from [Chapter
    9](ch09.xhtml) that `Maybe` is a type constructor, which means that it takes a
    type as input to produce a new type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The type variable `a` stands for any type. The fact that we are using a type
    variable after `MyMaybe` in this data type definition makes `MyMaybe` a type constructor
    rather than a type. Here we have two data constructors, but unlike for the type
    `MyBool`, the data constructor `MyJust` contains some information, namely a value
    of type `a`. A value of type `MyMaybe a` is either `MyNothing` or `MyJust x` for
    some `x :: a`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the types of the data constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For comparison, we can look at the types of the Prelude data constructors for
    `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We see that `Nothing` is not even a function but just a value of type `Maybe
    a`. On the other hand, `Just` is a function that takes a value of type `a` and
    returns a value of type `Maybe a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 19](ch19.xhtml), when we’re talking about systems of particles,
    we’ll define a new data type called `Force` that has two constructors: one for
    an external force and one for an internal force.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve talked about how to define a new data type, let’s move on to
    define the `Vec` type we’ve been using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a New Data Type for 3D Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell does not come with a built-in type for vectors, so we have to define
    it ourselves. In the beginning of this chapter, we looked at how vectors are defined
    and used in physics. With this knowledge, we’ll turn to the question of how to
    implement three-dimensional vectors in Haskell. The new type must hold three real
    numbers, for the three components of a vector in some coordinate system, or something
    equivalent. We have several options.
  prefs: []
  type: TYPE_NORMAL
- en: Possible Implementations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s consider some possible implementations for the type `Vec` before making
    a final choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Use a List'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could use a list of real numbers to hold the three components of a vector.
    A type synonym for this definition would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This type of vector can hold all possible triples of real numbers. The trouble
    with this definition is that the type can also hold lists of real numbers that
    don’t have a length of three. This potential type doesn’t match our requirements
    as nicely as we would like; it’s a little too big, given that the empty list or
    a list of two real numbers would satisfy the type checker as a legitimate value
    of this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: Use a Tuple'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A better option would be to choose a triple of real numbers. A type synonym
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is a better match for our requirements because this type guarantees that
    there must be three components. The only downside to this option is the possible
    confusion of a triple representing the three components of a vector with a triple
    representing three other numbers, such as the spherical coordinates of a position.
    Since option 2 uses a type synonym, the type checker could not help us catch an
    accidental use of our new vector type in a place where some other triple of real
    numbers is called for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: Make a New Data Type'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A third option is to define a new data type for `Vec` that cannot be confused
    with any other data type, even if the other data type is essentially a collection
    of three real numbers like `Vec`. We want a fundamental concept in physics, like
    the three-dimensional vector, to be reflected in the type system so the type system
    can help us keep things straight in a way that respects how we think about the
    subject. This is the option we’ll pursue next.
  prefs: []
  type: TYPE_NORMAL
- en: Data Type Definition for Vec
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is our data type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We decide to use the same name `Vec` for the data constructor we used for the
    type. We use record syntax because that automatically produces functions `xComp`,
    `yComp`, and `zComp` for the three components of a vector. We ask the compiler,
    through the `deriving` keyword, to create an instance of `Eq` for the new `Vec`
    data type. However, we do not ask for an automatic instance of `Show` because
    we want to define that manually.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll show how to make the type `Vec` an instance of type class `Show`.
    The general way to make a type an instance of a type class is with the `instance`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After the `instance` keyword, we give the type class, then the type to be an
    instance of that type class, and then the keyword `where`, before giving definitions
    for the functions owned by the type class.
  prefs: []
  type: TYPE_NORMAL
- en: Starting on the second line, we define the functions owned by the type class,
    and we say how they are supposed to work for the specific case of the type in
    question, `Vec` in this case. The only function that needs to be defined in an
    instance of `Show` is the function `show`, which describes how to turn a `Vec`
    into a `String` so it can be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Our way of showing a vector begins with the string `"vec "`, followed by each
    of the three components in turn. The function `showDouble` does the work of turning
    each real number into a string.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `show` function inside the instance definition must be
    indented with respect to the `instance` keyword. Any other functions that get
    defined inside the instance definition must be indented by the same amount.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually two other functions owned by type class `Show`, called `showsPrec`
    and `showList`, but these will get default definitions if we don’t define them,
    which we didn’t earlier. Using `:i Show` in GHCi gives a list of the functions
    owned by type class `Show`, along with which functions *must* be defined in an
    instance definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function `showDouble`, used earlier in the function `show`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The type `Double` is already an instance of `Show`, as noted in [Chapter 8](ch08.xhtml),
    so the function `show` is already available to turn a `Double` into a `String`.
    Our function `showDouble` uses the function `show` and simply encloses negative
    numbers in parentheses. The reason for enclosing negative components in parentheses
    is so the way a `Vec` gets shown is a legitimate expression for the `Vec`, meaning
    it can be used as input wherever a `Vec` is called for. To carry out this plan
    for having an expression like `vec 3.1 (-4.2) 5.0` accepted as a legitimate value
    of type `Vec`, we need a `vec` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This `vec` function does the same thing that the data constructor `Vec` does.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just use the data constructor `Vec` to form and show our vectors, thus
    eliminating the need to define a `Show` instance for `Vec` and define the function
    `vec`? This is indeed a possibility, and not a bad one. The main reason I did
    not do it is that I wanted to use record syntax, and the automatically generated
    `Show` instance obtained by using the `deriving` keyword would have used record
    syntax to show the vector. This in itself is unproblematic, but when we get into
    lists of vectors, or lists of tuples of vectors, we will want a brief way to show
    our vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell has traditionally favored that what can be shown can also be read. The
    `Read` type class is for types that can be read from a `String`, and it serves
    as a sort of inverse to the `Show` type class for types that can be shown as a
    `String`. This is the reason why the `Show` instance looks just like the application
    of the `vec` function to three components.
  prefs: []
  type: TYPE_NORMAL
- en: Vec Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are unit vectors in the x-, y-, and z-directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We give the zero vector the special name `zeroV`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The unary minus sign will not work in front of a vector, so we define a function
    `negateV` that returns the additive inverse of a vector (the negative of the vector).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Vector addition and subtraction are just the addition and subtraction of the
    corresponding Cartesian components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It’ll be useful to have a function that adds a whole list of vectors. We’ll
    use this function when we do numeric integrals of vector-valued functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The function foldr is defined in the Prelude. The definition of sumV is written
    in point-free style, which means it is short for `sumV vs = foldr (^+^)` `zeroV
    vs`. Roughly speaking, foldr takes a binary operator (`(^+^)` in this case), an
    initial value, and a list of values, and “folds” the initial value and an element
    from the list into an accumulated value, after which it continues to fold the
    accumulated value with the next element of the list to form a new accumulated
    value until the list is gone and the final accumulated value is returned. It’s
    a fairly powerful function, but here it’s used just to keep adding the members
    of the list until there are no more.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to multiply three-dimensional vectors. The first is scalar
    multiplication, in which we multiply a number by a vector or a vector by a number.
    We use `(*^)` and `(^*)` for scalar multiplication. The first takes a number on
    the left and a vector on the right. The second takes a vector on the left and
    a number on the right. The vector always goes next to the caret symbol. The second
    vector multiplication method is the dot product. We use `(<.>)` for the dot product.
    The third vector multiplication method is the cross product. We use `(><)` for
    the cross product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the definitions for the three vector multiplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first two definitions are for scalar multiplication. If the vector is to
    the right of the number, we use the operator with the caret on the right. If the
    vector is to the left of the number, we use the operator with the caret on the
    left. In either case, the definition says that scalar multiplication is carried
    out by multiplying each Cartesian component by the scaling number. The dot product
    is defined via Equation 10.8\. The cross product is defined via Equation 10.9.
  prefs: []
  type: TYPE_NORMAL
- en: We can also divide a vector by a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define a `magnitude` function to take the magnitude of a vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This completes our data type definition for the new data type `Vec`, along with
    supporting functions that allow us to write about vectors in the way we think
    about them and use them in physics.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed kinematics in three spatial dimensions. In three dimensions,
    time is represented by a real number while velocity and acceleration are represented
    by vectors. Position is not truly a vector, but in this chapter we keep it simple
    and regard position as the displacement vector from the origin of some preferred
    or default coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors are fundamentally geometric entities; to use numbers to describe the
    components of a vector, we must introduce a coordinate system. In any situation
    in which an object is moving, we can decompose the acceleration into a component
    parallel to the velocity and a component perpendicular to the velocity. This decomposition
    is coordinate independent.
  prefs: []
  type: TYPE_NORMAL
- en: With a system for vectors in place, we are now in a position to do all the projectile
    motion problems we ever wanted to do. We showed Haskell’s facility for defining
    our own data types, and we used that system to implement the `Vec` type for three-dimensional
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 10.1.** Translate the following mathematical definitions into Haskell
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a) ![Image](Images/e0159-01.jpg) | (Use `v0` in Haskell for `**v**[0]`.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| (b) ![Image](Images/e0159-02.jpg) | (Use `v1` for `**v**[1]`.) |'
  prefs: []
  type: TYPE_TB
- en: '| (c) ![Image](Images/e0159-03.jpg) | (Use `v` for **v**.) |'
  prefs: []
  type: TYPE_TB
- en: '| (d) ![Image](Images/e0159-04.jpg) | (Use `r` for **r**.) |'
  prefs: []
  type: TYPE_TB
- en: '| (e) ![Image](Images/e0159-05.jpg) | (Use `x` for *x*.) |'
  prefs: []
  type: TYPE_TB
- en: What are the Haskell types of v0, v1, v, r, and x?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.2.** Write an integration function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: for vector-valued functions of a real variable that is similar to the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: that we wrote in [Chapter 6](ch06.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.3.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: that returns the maximum z-component for projectile motion in which the initial
    position and the initial velocity of an object are given. Assume gravity acts
    in the negative z-direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.4.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: that, given an initial velocity and a constant acceleration, returns a function
    giving speed as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.5.** In the spirit of the function `projectilePos`, write a type
    signature and function definition for a function `projectileVel` that computes
    the velocity of a projectile at a given time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.6.** Define a new type `Vec2D` for two-dimensional vectors. Then
    define functions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: that find the magnitude and angle of a two-dimensional vector and construct
    a two-dimensional vector from a magnitude and angle. You may want to use the `atan`
    or `atan2` functions, which we discussed in [Chapter 1](ch01.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.7.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: that computes the projection of a vector into the xy plane. For example, `xyProj
    (vec 6 9 7)` should evaluate to `vec 6 9 0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.8.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: that returns a triple (*v*, *θ*, *ϕ*) for a vector **v** in which
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, `magAngles (vec (-1) (-2) (-3))` should evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 10.9.** The velocity and acceleration of a ball launched from the
    ground are'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where **v**[0] is the initial velocity of the ball and **g** is the acceleration
    of gravity. Suppose a ball is launched from the ground with an initial speed of
    25 m/s at an angle 52^∘ above horizontal. Choose a coordinate system and define
    a constant
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: for the acceleration of gravity near Earth’s surface. It should be 9.8 m/s²
    toward the center of the earth. Next, define a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: that gives the velocity of the ball as a function of time. Now define a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: that gives the rate of change of the speed of the ball as a function of time.
    You may want to use `speedRateChange` for this. At what point in the ball’s motion
    is the rate of change of its speed equal to zero? Is its velocity zero at that
    point? Is its acceleration zero at that point? Use `plotFunc` from [Chapter 7](ch07.xhtml)
    to make a graph of the rate of change of the speed of the ball as a function of
    time over the four seconds it is in the air.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.10.** Consider a particle in uniform circular motion. If we choose
    our coordinate system so that the motion takes place in the xy-plane with the
    origin at the center of the circle, we can write the position of the particle
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *R* is the radius of the circle and *ω* is the angular velocity of the
    motion. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This particle in uniform circular motion has a speed *v*[*UCM*] (*t*) = *ωR*,
    which does not depend on time. The constant speed is what we mean by the word
    “uniform.”
  prefs: []
  type: TYPE_NORMAL
- en: For a uniform circular motion with *R* = 2 m and *ω* = 6 rad/s, encode the position,
    velocity, and acceleration of the particle in Haskell. Use `aParallel` to confirm
    that the tangential component of acceleration is 0 at several different times.
    Use `aPerp` to confirm that the magnitude of the radial component of acceleration
    is [*v*[UCM] (*t*)]²/*R* = ^(*ω*2)*R*, again at several different times.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.11.** Consider a particle in nonuniform circular motion on a
    circle with radius *R*. If we choose our coordinate system so that the motion
    takes place in the xy-plane with the origin at the center of the circle, we can
    write the position of the particle as'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *θ*(*t*) describes the angle the particle makes with the x-axis as a function
    of time. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This particle in circular motion has speed *v*[NCM] (*t*) = *R* |*Dθ*(*t*)|,
    which will depend on time unless *Dθ*(*t*) is constant. The magnitude of the particle’s
    tangential acceleration is *R* |^(*D*2)*θ*(*t*)| and the magnitude of its radial
    acceleration is [*v*[NCM] (*t*)]²/*R* = *R*[*Dθ*(*t*)]².
  prefs: []
  type: TYPE_NORMAL
- en: Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: that takes a radius *R*, a function *θ*, and a time *t* as input and returns
    a position vector as output.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this exercise is to confirm that, even in nonuniform circular
    motion, the magnitude of a particle’s radial component of acceleration is equal
    to the square of its speed divided by the radius of the circle. The following
    function finds the radial component of acceleration for any particle whose position
    can be given as function of time. Its first input is a small time interval to
    use for numerical derivatives. Its second input is the position function for the
    particle, and its third input is time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: For a radius *R* = 2 m and
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/163equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: use `aPerpFromPosition` to find the radial component of acceleration at *t*
    = 2 seconds. Then find the speed of the particle at that time. Finally, show that
    the magnitude of the radial component is equal to the square of its speed divided
    by the radius of the circle.
  prefs: []
  type: TYPE_NORMAL
