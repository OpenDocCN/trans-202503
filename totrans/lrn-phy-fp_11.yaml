- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DESCRIBING MOTION IN THREE DIMENSIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](ch04.xhtml), we reviewed one-dimensional kinematics, describing
    quantities like velocity and acceleration with real numbers. In this chapter,
    we’ll look at three-dimensional kinematics, describing velocity and acceleration
    as vectors. Haskell does not have a built-in type for vectors, but it does have
    powerful facilities for making your own types, which we’ll use to create a `Vec`
    type for vectors. Before deciding how to implement the `Vec` type, we’ll take
    a careful look at the meaning and use of vectors in physics so we can produce
    an implementation that aligns well with how we think and write about vectors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Three-Dimensional Vectors
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notion of a three-dimensional vector is essential in physics. In physics,
    vectors are geometric objects used to describe quantities that have a magnitude
    and a direction in space. They are best thought of as arrows in which the length
    of the arrow represents the magnitude and the arrow points in some direction.
    Living on the surface of the earth as we do, directions can sometimes be described
    briefly in words, such as “up,” “north,” and so on. We can only ever specify the
    direction of a vector relative to some object, such as the earth; there is no
    universal or absolute notion of direction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed one-dimensional motion in [Chapter 4](ch04.xhtml), we did
    it in the context of an air track that came already marked in meters. The markings
    on the air track amount to a coordinate system in one dimension. A *coordinate
    system* is a method for describing position in terms of numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Nature does not typically grant us a coordinate system to use; instead, we choose
    the coordinate system we want to use. In three dimensions, this amounts to choosing
    a location and orientation for a set of three mutually perpendicular directions.
    Along each direction (let’s call them *x*, *y*, and *z*), we make (real or imaginary)
    marks, in meters. The place where *x* = *y* = *z* = 0 is called the *origin* of
    the coordinate system. Once we have chosen a coordinate system, a position can
    be described by three numbers (*x*, *y*, and *z*), indicating the (positive or
    negative) distance from the origin in each direction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: To describe motion in three dimensions, we usually need to introduce a coordinate
    system. But the laws of physics shouldn’t depend on any particular coordinate
    system. They should work with whatever coordinate system we want to use. Vectors
    are geometric objects; along with the laws of physics, vectors have an existence
    apart from any coordinate system. Vectors allow various operations we can describe
    without a coordinate system. We’ll give geometric (coordinate-free) descriptions
    of the important properties and operations of vectors and then show how the same
    operations appear once we have introduced a coordinate system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the various vector operations, I want to write the code
    that must exist at the top of the source code file for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line turns on compiler warnings, which is a good idea to help avoid
    some common mistakes that are legal code but may not mean what you think they
    mean. If there are warnings, you will see them when you load the file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The next line gives the code in this chapter a module name so that this code
    can be imported into another source code file later. The module name `SimpleVec`
    must match the name of the file that contains it, so the filename should be *SimpleVec.hs*.
    The remaining lines specify precedence levels and associativities for the operators
    we define later in the chapter. The precedence levels are numbers from 0 to 9,
    described in [Chapter 1](ch01.xhtml), that determine which operators act first
    in an expression with multiple operators. The keyword `infixl` is for an operator
    with left associativity, while `infixr` is for right associativity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate-Free Vectors
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have this code at the top of our file and have a basic idea of what
    vectors are, let’s look some of their geometric properties. We’ll give the geometric
    definitions for vector addition, scalar multiplication, vector subtraction, the
    dot product, the cross product, and the derivative of a vector-valued function
    of a real number. If you’re interested, the book *Modern Classical Physics* [**[6](bib.xhtml#bib6)**]
    by Kip Thorne and Roger Blandford gives an elegant motivation for the coordinate-free,
    geometric view of vectors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Vector Addition
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can combine two vectors using what we’ll call *vector addition*. Geometrically,
    we define the sum of two vectors to be the vector that points from the tail of
    the first to the tip of the second when the two vectors are placed tip-to-tail.
    You can see from [Figure 10-1](ch10.xhtml#ch10fig1) that the order in which they
    are placed tip-to-tail does not matter; consequently, vector addition is commutative
    (**A** + **B** = **B** + **A**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/131fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Vector addition. The vector **A** + **B** is the sum of vectors
    **A** and **B**.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Physicists need to know whether a symbol stands for a number or a vector; thus,
    the theory of Newtonian mechanics (and most other theories in physics) invites
    us to think in terms of types. The mathematical notation that physicists typically
    use to indicate a vector is syntactic and identifies a vector by a boldface symbol.
    In Haskell, the distinction between numbers and vectors is not syntactic; names
    for each are simply identifiers that begin with a lowercase letter. In Haskell,
    the distinction between numbers and vectors is semantic and is captured by the
    type of the value: `R` for numbers and `Vec` for vectors.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematical notation, we use the same + sign for vector addition that we
    use for addition of numbers, even though vectors and numbers are very different
    things and it makes no sense to add a vector to a number. In Haskell, we’ll use
    a different symbol (`^+^`) for vector addition than we do for number addition.
    If `a` and `b` are vectors (we write `a :: Vec` to say that `a` has type `Vec`),
    then `a ^+^ b` will be their vector sum. At the end of the chapter, we’ll show
    how to define the `Vec` type and the `^+^` operator.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we introduce new operators for vector addition, subtraction,
    and scalar multiplication. An alternative path, which we do not follow, would
    be to expand the definitions of addition (`+`), subtraction (`-`), and multiplication
    (`*`) so they work for vectors as well as numbers. The Haskell language is certainly
    powerful enough to do this. The reason we don’t follow this course is that we
    prefer to have simple, concrete types for our vector operations, rather than types
    involving type classes. The names, such as `^+^`, that we use for the new operators
    are borrowed from Conal Elliott’s `vector-space` package [**[7](bib.xhtml#bib7)**],
    a more sophisticated and general way of dealing with vectors than we present here.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Definition of Scaling a Vector
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We define scaling a vector by a number (also called *scalar multiplication*
    or multiplying a number by a vector) as follows: if the number is positive, we
    multiply the magnitude of the vector by the number and leave the direction of
    the vector unchanged. If the number is negative, we multiply the magnitude of
    the vector by the absolute value of the number and flip the direction of the vector.
    If the number is 0, the result is the zero vector.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We define division of a vector **A** by a number *m* to be scalar multiplication
    of the vector by the reciprocal of *m*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/132equ01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: In [Figure 10-2](ch10.xhtml#ch10fig2), we show the results of scaling a vector
    by 2, – 1, and – 1/2\. Scaling by a positive number multiplies the length of the
    vector, keeping the direction the same. Scaling by a negative number multiples
    the vector’s length and flips its direction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/133fig01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Scalar multiplication. Scaling **A** by 2, –1, and –1/2 results
    in 2 **A**, –**A**, and –**A**/2, respectively.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical notation, we use the same juxtaposition of symbols (placing
    a number beside a vector) for scalar multiplication that we use for multiplication
    of numbers, even though the operation is different. Similarly, we use the same
    sign (/) for dividing a vector by a number, even though the operation is different.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, we’ll use different symbols for scalar multiplication than we do
    for number multiplication, and a different symbol for division of a vector by
    a number than we use for division of a number by a number. If `m` is a number
    and `a` is a vector, then `m *^ a` and `a ^* m` each mean the scaling of `a` by
    `m`. Note that the caret sign is closer to the vector in each case. To divide
    `a` by `m`, we write `a ^/ m`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，我们为标量乘法使用与数字乘法不同的符号，为向量除以数字使用与数字除以数字不同的符号。如果 `m` 是一个数字，`a` 是一个向量，那么
    `m *^ a` 和 `a ^* m` 都表示将 `a` 按 `m` 缩放。注意，在这两种情况下，插入符号都离向量更近。要将 `a` 除以 `m`，我们写作
    `a ^/ m`。
- en: Geometric Definition of Vector Subtraction
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量相减的几何定义
- en: Another way to combine two vectors is with what we’ll call *vector subtraction*.
    The difference of two vectors is defined to be the vector that points from the
    tip of the first to the tip of the second when the two vectors are placed tail-to-tail.
    [Figure 10-3](ch10.xhtml#ch10fig3) shows that the difference of two vectors is
    equal to the sum of one vector and the opposite of the other vector. In symbols,
    **B** – **A** = **B** + (–**A**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种组合两个向量的方法是我们所称的*向量相减*。两个向量的差定义为当两个向量尾对尾摆放时，从第一个向量的尖端指向第二个向量尖端的向量。[图 10-3](ch10.xhtml#ch10fig3)显示了两个向量的差等于一个向量与另一个向量的相反数之和。用符号表示，**B**
    - **A** = **B** + (–**A**)。
- en: '![Image](Images/133fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/133fig02.jpg)'
- en: '*Figure 10-3: Vector subtraction. The vector **B** – **A** is the difference
    of vectors **B** and **A**.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：向量相减。向量**B** - **A**是向量**B**和**A**的差。*'
- en: In mathematical notation, we use the same sign (–) for vector subtraction that
    we use for subtraction of numbers, even though vectors and numbers are very different
    things. In Haskell, if `a` and `b` are vectors, we’ll define `a ^-^ b` to be their
    vector difference.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表示中，我们使用相同的符号（–）来表示向量相减，就像我们用相同的符号表示数字相减一样，尽管向量和数字是非常不同的东西。在 Haskell 中，如果
    `a` 和 `b` 是向量，我们将定义 `a ^-^ b` 为它们的向量差。
- en: Geometric Definition of Dot Product
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点积的几何定义
- en: 'There are (at least) two important products of vectors in physics. One is the
    *dot product*, or *inner product*. The dot product of two vectors is a scalar,
    or number. Here’s the geometric definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，向量有（至少）两种重要的积。一个是*点积*，或*内积*。两个向量的点积是一个标量，或数字。以下是它的几何定义：
- en: '**A · B** = *AB* cos θ'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**A · B** = *AB* cos θ'
- en: In this equation, *θ* is the angle between the two vectors when they are placed
    tail-to-tail, and we use the standard notation of allowing an italic symbol to
    stand for the magnitude of the vector whose boldface symbol has the same letter.
    In other words, *A* = |**A**| and *B* = |**B**|.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*θ* 是当两个向量尾对尾摆放时它们之间的角度，我们使用标准符号，即让斜体符号表示与粗体符号具有相同字母的向量的大小。换句话说，*A* =
    |**A**| 和 *B* = |**B**|。
- en: '[Figure 10-4](ch10.xhtml#ch10fig4) shows that the dot product of two vectors
    is the product of the magnitude of one vector (*B* or *A*) and the projection
    of the second vector onto the first (*A* cos *θ* or *B cos θ*, respectively).
    Note that the projection will be negative when *θ* > 90^∘.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch10fig4)显示了两个向量的点积是一个向量的大小（*B* 或 *A*）与第二个向量在第一个向量上的投影（*A*
    cos *θ* 或 *B cos θ*）的乘积。请注意，当 *θ* > 90^∘ 时，投影将为负。'
- en: '![Image](Images/134fig01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/134fig01.jpg)'
- en: '*Figure 10-4: The dot product of two vectors is the product of the magnitude
    of one vector and the projection of the second vector onto the first.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：两个向量的点积是一个向量的大小与第二个向量在第一个向量上的投影的乘积。*'
- en: 'Notice that the dot product is commutative: **A ⋅B = B ⋅A**. Also, the dot
    product is related to the magnitude of a vector.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点积是可交换的：**A ⋅B = B ⋅A**。此外，点积与向量的大小有关。
- en: '**A · A** = |A|² cos (0) = |**A**|² = *A*²'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**A · A** = |A|² cos (0) = |**A**|² = *A*²'
- en: Therefore,
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '![Image](Images/134equ01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/134equ01.jpg)'
- en: The dot product distributes over a vector sum.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点积对向量和分配。
- en: '**C · (A + B) = C · A + C · B**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**C · (A + B) = C · A + C · B**'
- en: In Haskell, if `a` and `b` are vectors, then `a <.> b` will be their dot product.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，如果 `a` 和 `b` 是向量，那么 `a <.> b` 将是它们的点积。
- en: Geometric Definition of Cross Product
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 叉积的几何定义
- en: The *cross product* of two vectors is the vector whose magnitude is given by
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量的*叉积*是一个向量，其大小由下式给出
- en: '|**A** × **B**| = *AB* sin θ'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|**A** × **B**| = *AB* sin θ'
- en: and whose direction is perpendicular to both **A** and **B**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其方向与向量**A**和**B**都垂直。
- en: '[Figure 10-5](ch10.xhtml#ch10fig5) shows the plane containing vectors **A**
    and **B**. To find the direction of **A** × **B**, imagine rotating vector **A**
    about its tail through an angle less than 180^∘ until it aligns with vector **B**.
    If counterclockwise rotation is required to carry this out, the direction of **A**
    × **B** is out of the page. If instead clockwise rotation is required, the direction
    of **A** × **B** is into the page.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](ch10.xhtml#ch10fig5)展示了包含向量**A**和**B**的平面。为了找到**A** × **B**的方向，想象将向量**A**绕其尾部旋转一个小于
    180^∘的角度，直到它与向量**B**对齐。如果需要逆时针旋转来完成这一动作，那么**A** × **B**的方向是指向页面外。如果需要顺时针旋转，则**A**
    × **B**的方向是指向页面内。'
- en: '![Image](Images/135fig01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/135fig01.jpg)'
- en: '*Figure 10-5: Cross product. The vector ***A**** × ****B*** points out of the
    page. The vector **B*** × ****A*** points into the page.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：叉积。向量 ***A**** × ****B*** 指向页面外。向量 **B*** × ****A*** 指向页面内。*'
- en: 'For **A** and **B** in [Figure 10-5](ch10.xhtml#ch10fig5), the vector **A**
    × **B** points out of the page and the vector **B** × **A** points into the page.
    The cross product is anti-commutative: **A** × **B** = –**B** × **A**. Note also
    that the cross product of any vector with itself is 0\. The magnitude of the cross
    product gives the area of the parallelogram formed by the two vectors when two
    additional parallel sides are added.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图 10-5](ch10.xhtml#ch10fig5)中的**A**和**B**，向量**A** × **B**指向页面外，而向量**B** ×
    **A**指向页面内。叉积是反交换的：**A** × **B** = –**B** × **A**。还要注意，任何向量与其自身的叉积为 0。叉积的大小给出了由这两个向量所形成的平行四边形的面积，当加入两个额外的平行边时。
- en: 'The cross product distributes over a vector sum:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积对向量和分配：
- en: '**C** × **(A + B)** = **C** × **A** + **C** × **B**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**C** × **(A + B)** = **C** × **A** + **C** × **B**'
- en: In Haskell, if `a` and `b` are vectors, we’ll define `a >< b` to be their cross
    product. (The operator `><` is supposed to look like a cross product.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，如果`a`和`b`是向量，我们将定义`a >< b`为它们的叉积。（操作符`><`的设计应该像叉积运算符。）
- en: NOTE
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are interested in mathematical innovations, the geometric product is
    more sophisticated than the dot and cross products, but it contains the essence
    of both. The book* Geometric Algebra for Physicists [**[8](bib.xhtml#bib8)**]
    *by Chris Doran and Anthony Lasenby is a nice introduction. The book* Space-Time
    Algebra [**[9](bib.xhtml#bib9)**] *by David Hestenes is another great resource.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对数学创新感兴趣，几何积比点积和叉积更为复杂，但它包含了两者的精髓。Chris Doran 和 Anthony Lasenby 所著的书《几何代数物理学入门》[**[8](bib.xhtml#bib8)**]
    是一本很好的入门书。David Hestenes 所著的《时空代数》[**[9](bib.xhtml#bib9)**] 是另一本很棒的参考书。*'
- en: Derivative of a Vector-Valued Function
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量值函数的导数
- en: Suppose **V** is a function that takes one real variable (such as time) as input
    and gives a vector (such as velocity) as output. Because we can subtract vectors,
    and because we can divide a vector by a number, we can define the derivative of
    a vector-valued function of a real number. In Haskell, the type of such a function
    is `R -> Vec`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**V**是一个函数，它接受一个实数变量（如时间）作为输入，并输出一个向量（如速度）。因为我们可以做向量减法，并且可以将向量除以一个数，所以我们可以定义实数值函数的向量导数。在
    Haskell 中，这样的函数类型是`R -> Vec`。
- en: 'The derivative of **V**, denoted *D***V**, **V**’, or ![Image](Images/v-dot.jpg),
    is the function of one variable defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**的导数，记作*D**V**、**V**’或 ![Image](Images/v-dot.jpg)，是一个一元函数，定义如下：'
- en: '![Image](Images/135equ01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/135equ01.jpg)'
- en: Notice that the leftmost minus sign is a subtraction of vectors. We are using
    the same *D* symbol for the derivative of a vector-valued function that we used
    for the derivative of a number-valued function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最左边的减号表示向量的减法。我们使用相同的*D*符号来表示向量值函数的导数，就像我们表示数值函数导数时使用的符号一样。
- en: The vector derivative takes a vector-valued function of one variable (a function
    with type `R -> Vec`) as input and provides a vector-valued function of one variable
    as output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量导数接受一个一元向量值函数（类型为`R -> Vec`）作为输入，并输出一个一元向量值函数。
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The type `(R -> Vec) -> R -> Vec` is the same as the type `(R -> Vec) ->` `(R
    -> Vec)`. Here is a vector derivative in Haskell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`(R -> Vec) -> R -> Vec`与类型`(R -> Vec) ->` `(R -> Vec)`是相同的。下面是 Haskell 中的向量导数：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like the function `derivative` from [Chapter 4](ch04.xhtml), this numerical
    derivative does not take a limit but instead uses a small interval `dt`, supplied
    by the user of the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第 4 章](ch04.xhtml)中的`derivative`函数一样，这个数值导数并不取极限，而是使用一个由函数用户提供的小间隔`dt`。
- en: '[Table 10-1](ch10.xhtml#ch10tab1) shows a comparison of mathematical notation
    with Haskell notation for the vector operations we’ve introduced.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-1](ch10.xhtml#ch10tab1) 显示了我们介绍的向量运算中，数学符号与 Haskell 符号的对比。'
- en: '**Table 10-1:** Comparison of Mathematical Notation with Haskell Notation for
    Vector Operations'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** 数学符号与 Haskell 符号在向量运算中的比较'
- en: '| **Math notation** | **Haskell notation** | **Haskell type** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **数学符号** | **Haskell 符号** | **Haskell 类型** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *t* | `t` | `R` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| *t* | `t` | `R` |'
- en: '| *m* | `m` | `R` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *m* | `m` | `R` |'
- en: '| **A** | `a` | `Vec` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **A** | `a` | `Vec` |'
- en: '| **B** | `b` | `Vec` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **B** | `b` | `Vec` |'
- en: '| **V** | `v` | `R -> Vec` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **V** | `v` | `R -> Vec` |'
- en: '| **V**(*t*) | `v t` | `Vec` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **V**(*t*) | `v t` | `Vec` |'
- en: '| **A** + **B** | `a ^+^ b` | `Vec` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **A** + **B** | `a ^+^ b` | `Vec` |'
- en: '| *m* **A** | `m *^ a` | `Vec` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| *m* **A** | `m *^ a` | `Vec` |'
- en: '| **A** *m* | `a ^* m` | `Vec` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **A** *m* | `a ^* m` | `Vec` |'
- en: '| **A**/*m* | `a ^/ m` | `Vec` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **A**/*m* | `a ^/ m` | `Vec` |'
- en: '| **A** – **B** | `a ^-^ b` | `Vec` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **A** – **B** | `a ^-^ b` | `Vec` |'
- en: '| **A** ⋅ **B** | `a <.> b` | `R` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **A** ⋅ **B** | `a <.> b` | `R` |'
- en: '| **A** × **B** | `a >< b` | `Vec` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **A** × **B** | `a >< b` | `Vec` |'
- en: '| *D***V** | `vecDerivative 0.01 v` | `R -> Vec` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *D***V** | `vecDerivative 0.01 v` | `R -> Vec` |'
- en: '| *D***V**(*t*) | `vecDerivative 0.01 v t` | `Vec` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *D***V**(*t*) | `vecDerivative 0.01 v t` | `Vec` |'
- en: '| ![Image](Images/e0136-01.jpg) | `vecDerivative 0.01 v t` | `Vec` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/e0136-01.jpg) | `vecDerivative 0.01 v t` | `Vec` |'
- en: Let’s move on and see what happens with vectors when we introduce a coordinate
    system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看当引入坐标系统时，向量会发生什么变化。
- en: Coordinate Systems
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坐标系统
- en: We choose a coordinate system by choosing a location and orientation for a set
    of three mutually perpendicular directions. We define **î** to be a vector with
    magnitude 1 that points in the direction of increasing *x*. A vector with magnitude
    1 is also known as a *unit vector*. Vectors augmented with a hat are unit vectors.
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a coordinate system along with coordinate
    unit vectors in each coordinate direction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择一个位置和方向来选择坐标系统，这样可以定义三个互相垂直的方向。我们定义 **î** 为一个大小为 1，指向增加的 *x* 方向的向量。大小为
    1 的向量也被称为 *单位向量*。带帽的向量是单位向量。[图 10-6](ch10.xhtml#ch10fig6) 显示了一个坐标系统，并标出每个坐标方向的坐标单位向量。
- en: '![Image](Images/137fig01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/137fig01.jpg)'
- en: '*Figure 10-6: A right-handed coordinate system. The z-axis is to be imagined
    as coming out of the page.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：一个右手坐标系统。z 轴被想象为从页面中突出。*'
- en: Because ![Image](Images/icap.jpg) has magnitude 1, we know that ![Image](Images/e0137-02.jpg).
    Similarly, we define ![Image](Images/jcap.jpg) to be a unit vector that points
    in the direction of increasing *y*, and we define ![Image](Images/kcap.jpg) to
    be a unit vector that points in the direction of increasing *z*. The reason they
    are called ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg), and ![Image](Images/kcap.jpg)
    goes back to William Rowan Hamilton and his quaternions. (Search for the William
    Rowan Hamilton video by A Capella Science for a wonderful musical biography of
    this mathematical physicist, set to a tune written for a political figure with
    the same last name.) Because ![Image](Images/icap.jpg) and ![Image](Images/jcap.jpg)
    are perpendicular, we know that ![Image](Images/e0137-03.jpg). By similar reasoning,
    we can find the dot products of all the coordinate unit vectors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![图片](Images/icap.jpg) 的大小为 1，我们知道 ![图片](Images/e0137-02.jpg)。类似地，我们定义 ![图片](Images/jcap.jpg)
    为一个单位向量，指向增加的 *y* 方向，我们定义 ![图片](Images/kcap.jpg) 为一个单位向量，指向增加的 *z* 方向。它们之所以被称为
    ![图片](Images/icap.jpg)、![图片](Images/jcap.jpg) 和 ![图片](Images/kcap.jpg)，可以追溯到威廉·罗恩·汉密尔顿（William
    Rowan Hamilton）和他的四元数。（可以查找 A Capella Science 的《William Rowan Hamilton》视频，了解这位数学物理学家的精彩音乐传记，配乐是为同名的政治人物写的。）由于
    ![图片](Images/icap.jpg) 和 ![图片](Images/jcap.jpg) 是垂直的，我们知道 ![图片](Images/e0137-03.jpg)。通过类似的推理，我们可以找到所有坐标单位向量的点积。
- en: '![Image](Images/137equ01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/137equ01.jpg)'
- en: Because the cross product of any vector with itself is 0, we know that ![Image](Images/e0137-04.jpg).
    Because the three directions of our coordinate system are mutually perpendicular,
    we know that ![Image](Images/e0137-05.jpg). To resolve the sign ambiguity, we
    usually agree to use a *right-handed coordinate system*, which means that ![Image](Images/e0137-06.jpg).
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a right-handed coordinate system. By
    similar reasoning, we can find the cross products of all the coordinate unit vectors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Once we have a coordinate system and the coordinate unit vectors it gives rise
    to, we can “break a vector into components.” Any vector **A** can be expressed
    as a *linear combination* of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg). A linear combination of vectors means a number
    times the first, plus a number times the second, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: We call *A[x]* the *x* component of **A**, and similarly for *y* and *z*. The
    collection of the three numbers *A[x]*, *A[y]*, and *A[z]* is called the *components*
    of **A** with respect to the coordinate system. By dotting the equation above
    by ![Image](Images/icap.jpg), we get an expression for *A[x]* in terms of ![Image](Images/icap.jpg)
    and **A**. We can do the same for *A[y]* and *A[z]*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: The Haskell code at the end of the chapter defines a default coordinate system
    you can use. The default coordinate system provides coordinate unit vectors `iHat`,
    `jHat`, and `kHat` that play the role of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg), respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the vector operations introduced above in a geometric way and
    see how they look with a coordinate system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Vector Addition with Coordinate Components
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The components of a sum are the sums of the components. If **C** = **A** + **B**,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ04a.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: and similarly for the y- and z-components. If **C** = **A** + **B**, then
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/138equ04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: In Haskell, this is
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can think of the caret on each side of the plus sign as a reminder that
    there is a vector on the left and a vector on the right.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Vector Scaling with Coordinate Components
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If **C** = *m***A**, then
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: and similarly for the y- and z-components. If **C** = *m***A**, then
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: To scale a vector, we can use the `*^` operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the caret goes on the right of the asterisk because the vector is
    on the right. You can multiply a `Vec` on the left by an `R` on the right with
    the `^*` operator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the vector is on the left, the caret is on the left. Similarly, we can
    divide by an `R` with the `^/` operator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Vector Subtraction with Coordinate Components
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If **C** = **A** – **B**, then
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: and similarly for the *y* and *z* components. If **C** = **A** – **B**, then
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/139equ04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: We say “the components of a difference are the differences of the components.”
    The first use of the word *difference* refers to vector difference, while the
    second use refers to number difference. If `a` and `b` are vectors, then `xComp
    (a ^-^ b)` and `xComp a - xComp b` evaluate to the same number.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说“差的分量是分量的差”。第一次使用“差”一词指的是向量差，而第二次使用则指的是数值差。如果`a`和`b`是向量，那么`xComp (a ^-^ b)`和`xComp
    a - xComp b`会得到相同的数值。
- en: 'Here is an example of vector subtraction:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个向量减法的例子：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dot Product with Coordinate Components
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点积与坐标分量
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the dot product along with Equation 10.2 to simplify the result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**A**和**B**是向量。给定一个坐标系，我们可以使用方程10.4将每个向量表示为分量，然后利用点积的分配律以及方程10.2来简化结果。
- en: '![Image](Images/140equ01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ01.jpg)'
- en: If we know the components of two vectors **A** and **B**, Equation 10.8 gives
    a handy way to find their dot product.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道两个向量**A**和**B**的分量，方程10.8提供了一种方便的方法来求它们的点积。
- en: You can take the dot product of two `Vec`s with the `<.>` operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`<.>`运算符来计算两个`Vec`的点积。
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Cross Product with Coordinate Components
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 叉积与坐标分量
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the cross product along with Equation 10.3 to simplify the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**A**和**B**是向量。给定一个坐标系，我们可以使用方程10.4将每个向量表示为分量，然后利用叉积的分配律和方程10.3来简化结果。
- en: '![Image](Images/140equ02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ02.jpg)'
- en: If we know the components of two vectors **A** and **B**, Equation 10.9 gives
    a good way to find their cross product.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道两个向量**A**和**B**的分量，方程10.9提供了一种很好的方法来求它们的叉积。
- en: You can take the cross product of two `Vec`s with the `><` operator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`><`运算符来计算两个`Vec`的叉积。
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you need the components of a vector, you can get them with the `xComp` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个向量的分量，可以使用`xComp`函数来获取。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are also functions `yComp` and `zComp`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有函数`yComp`和`zComp`。
- en: The unary minus sign (`-`) will not work to negate a vector, but you can negate
    a vector with `negateV`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一元负号(`-`)不能用于取反一个向量，但你可以使用`negateV`来取反一个向量。
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Derivative with Coordinate Components
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 坐标分量的导数
- en: Suppose **V** is a vector-valued function of one real variable. If **W** = *D***V**,
    then
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**V**是一个单一实变量的向量值函数。如果**W** = *D***V**，那么
- en: '![Image](Images/140equ03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ03.jpg)'
- en: and similarly for the y- and z-components. If **W** = *D***V**, then
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对y分量和z分量同样适用。如果**W** = *D***V**，那么
- en: '![Image](Images/141equ01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/141equ01.jpg)'
- en: 'Here is an example of a vector-valued function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个向量值函数的例子：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that we cannot write the x-component of this vector-valued function in
    the most obvious way, namely `xComp v1`. This would produce a type error because
    `xComp` takes a `Vec` as input, not a function `R -> Vec`. What we really mean
    when we talk about the x-component of a vector-valued function is the scalar-valued
    function that takes an input `t`, applies the vector-valued function, and returns
    the x-component. In Haskell, the x-component of a vector-valued function can be
    written as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能以最直观的方式写出这个向量值函数的x分量，即`xComp v1`。这样会产生类型错误，因为`xComp`接受的是`Vec`类型作为输入，而不是一个函数`R
    -> Vec`。我们真正的意思是，当我们讨论一个向量值函数的x分量时，指的是一个标量值函数，它接受一个输入`t`，应用向量值函数并返回x分量。在Haskell中，向量值函数的x分量可以按以下方式写出：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In words, Equation 10.10 says that the x-component of the derivative is the
    same as the derivative of the x-component. In Haskell, the same equations say
    that the x-component of the (vector) derivative
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字表达，方程10.10表示导数的x分量与x分量的导数相同。在Haskell中，相同的方程表示向量导数的x分量。
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'is the same as the (scalar) derivative of the x-component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与（标量）导数的x分量相同：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can check this in GHCi for a particular vector-valued function evaluated
    at a particular value of the independent variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GHCi中检查一个特定的向量值函数在特定自变量值下的计算结果。
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We defined the scalar derivative in [Chapter 4](ch04.xhtml) and repeat it here
    for convenience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.xhtml)中定义了标量导数，这里为了方便再次提及。
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Table 10-2](ch10.xhtml#ch10tab2) shows the types of the vector functions and
    expressions we’ve been working with.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格10-2](ch10.xhtml#ch10tab2)显示了我们正在使用的向量函数和表达式的类型。'
- en: '**Table 10-2:** Expressions and Functions for Working with Vectors'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Type** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `zeroV` | `::` | `Vec` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `iHat` | `::` | `Vec` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `(^+^)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `(^-^)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `(*^)` | `::` | `R -> Vec -> Vec` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `(^*)` | `::` | `Vec -> R -> Vec` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `(^/)` | `::` | `Vec -> R -> Vec` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `(<.>)` | `::` | `Vec -> Vec -> R` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `(><)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `negateV` | `::` | `Vec -> Vec` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `magnitude` | `::` | `Vec -> R` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `xComp` | `::` | `Vec -> R` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `vec` | `::` | `R -> R -> R -> Vec` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `sumV` | `::` | `[Vec] -> Vec` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: Now that we’ve seen some of the key properties of vectors in both geometric
    and coordinate settings, let’s take a look at how vectors get used to describe
    kinematics in three dimensions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Kinematics in 3D
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The essential quantities of kinematics are time, position, velocity, and acceleration.
    Time will continue to be a real number, as it was in [Chapter 4](ch04.xhtml).
    Velocity and acceleration we’ll now treat as vectors, using the `Vec` type that
    we’ll define at the end of the chapter. What about position?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Position is really not a vector. It doesn’t make sense to add positions, nor
    does it make sense to scale a position by a number. However, subtracting positions
    does make sense, and it produces a displacement vector from one position to the
    other. In [Chapter 22](ch22.xhtml), we’ll create a proper type for position, which
    allows us to use Cartesian, cylindrical, and spherical coordinates to describe
    positions. However, our aims are more modest at the moment and simplicity suggests
    that we use the `Vec` type for position, even though we just gave some reasons
    not to. Displacement is certainly a vector, so we can think of a vector-valued
    position as a displacement from the origin of the default coordinate system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the following type synonyms in this chapter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the type `PosVec` to denote the type of a position when position is being
    represented by a vector. This will keep us from confusing it with the `Position`
    type we’ll define in [Chapter 22](ch22.xhtml), which, again, is not a vector.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Defining Position, Velocity, and Acceleration
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a particular motion of an object, we define **r** to be the function that
    associates with each time *t* the position at which the object is located at time
    *t*. We say that **r**(*t*) is the position of the object at time *t*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The velocity function for an object is the derivative of its position function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Note that Equation 10.11 is an equality of functions, the instantaneous velocity
    function on the left of the equality, and the derivative of the position function
    on the right. Equation 10.11 can be written in Haskell as the function `velFromPos`,
    which takes a small time step and position function to return a velocity function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the definition, the function `velFromPos` is just the vector
    derivative we defined earlier in the chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: When two functions are equal, they give equal results for equal inputs, so we
    can also write
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ02.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: for any time *t*. The righthand side is the function *D***r** evaluated at time
    *t*. We can think of the derivative operator as taking the entire position function
    as input and returning the velocity function as output. It’s also common to see
    the notation
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ03.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: to define velocity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '*Speed* is the magnitude of the velocity vector. *Acceleration* is defined
    to be the rate at which velocity changes. We define **a** to be the function that
    associates with each time *t* the rate at which the velocity is changing at time
    *t*. In the language of calculus, we can write'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: or
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/143equ05.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: to define acceleration. Equation 10.14 can be encoded in a function `accFrom`
    `Vel` that produces an acceleration function from a velocity function. Again,
    this function is just the vector derivative.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the velocity happens to be constant, say **v[0]**, we can integrate both
    sides of Equation 10.11 to obtain
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**v**[0]*t* = **r**(*t*) – *r*(0)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: If velocity is constant, position is a linear function of time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**r**(*t*) = **v**[0]*t* + **r**(0)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the corresponding Haskell code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The CV at the end of the name is an abbreviation for constant velocity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: If the acceleration happens to be constant, say **a**[0], we can integrate both
    sides of Equation 10.14 or 10.15 to obtain
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**a**[0]*t* = **v**(*t*) – **v**(0)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If acceleration is constant, velocity is a linear function of time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'I like to call Equation 10.16 the *velocity-time equation* for constant acceleration
    because it gives the velocity **v**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0] and initial velocity **v**(0). Here
    is the Haskell code for Equation 10.16:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The CA at the end of the name is an abbreviation for constant acceleration.
    We can integrate both sides of Equation 10.16 to obtain
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: If acceleration is constant, position is a quadratic function of time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/144equ03.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'I like to call Equation 10.17 the *position-time equation* for constant acceleration
    because it gives the position **r**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0], initial position **r**(0), and initial
    velocity **v**(0). Here is the Haskell code for Equation 10.17:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Equations 10.16 and 10.17 are known as *constant acceleration equations*. They
    are used over and over again in a typical introductory physics course. Later we’ll
    learn some techniques to deal with situations in which acceleration is not constant.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced the definitions of velocity and acceleration in the three-dimensional
    vector setting, we can now look at how acceleration is composed of two qualitatively
    different components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Two Components of Acceleration
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If at any moment the velocity of an object is 0, any acceleration the object
    has serves to give the object some velocity in the direction of the acceleration.
    If, on the other hand, **v**(*t*)≠0, the relative directions of velocity and acceleration
    determine the qualitative motion of the object. In everyday speech, people often
    use the word *acceleration* to mean increase in speed. However, in physics, acceleration
    means change in velocity per unit tine, and velocity can change in either magnitude
    or direction. In physics, acceleration is responsible not only for increases in
    speed but for decreases in speed and changes in direction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: If **v**(*t*)≠0, we can decompose the acceleration into a component parallel
    to the velocity and a component perpendicular to the velocity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Since **v**(*t*)≠0, we can define a unit vector in the direction of the velocity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ02.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'The parallel and perpendicular components of acceleration are given by the
    following equations:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/145equ03.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Here are Haskell functions that calculate the parallel and perpendicular components
    of acceleration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The parallel component **a**[∥](*t*) is also called the *tangential component*
    of acceleration, and it’s responsible for the change in speed of the object. The
    perpendicular component **a**[⊥](*t*) is also called the *radial* or *transverse
    component* of acceleration, and it’s responsible for the change in direction of
    the object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product of velocity and acceleration depends on the angle between them
    and thus contains useful information. Let’s take the time derivative of the square
    of the speed *v*^((*t*)2) = **v**(*t*) ⋅**v**(*t*):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/146equ01.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the dot product of velocity and acceleration controls how the
    speed changes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dot product** | **Effect on speed** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) > 0 | Speed increases |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) = 0 | Speed remains constant |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| **v**(*t*) ⋅**a**(*t*) < 0 | Speed decreases |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: In this chapter, *v* stands for the speed function, which is a different convention
    from [Chapter 4](ch04.xhtml) where *v* was the one-dimensional velocity function.
    One-dimensional velocity can be negative, but speed can’t.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-7](ch10.xhtml#ch10fig7) shows how the relative direction of velocity
    and acceleration controls the qualitative behavior of an object’s motion.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/146equ02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: The relative directions of velocity and acceleration determine
    the qualitative motion of an object.*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: When acceleration has a component in the direction of velocity, an object speeds
    up. When acceleration has a component opposite the direction of velocity, an object
    slows down. When acceleration has only a component perpendicular to the velocity,
    an object maintains its speed. No coordinate system is necessary to make these
    conclusions; this aspect of the qualitative behavior of motion is purely geometric.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen how the tangential component of acceleration is related to speeding
    up and slowing down. We can make an even stronger statement: the rate of change
    of speed is directly related to the tangential component.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147equ01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: Here is the rate of change of speed as a Haskell function. Given the velocity
    and acceleration of an object, this function returns the rate at which speed is
    increasing, with a negative result meaning that speed is decreasing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The magnitude of the tangential component of acceleration equals the magnitude
    of the rate of change in speed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147equ02.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: If there is a transverse component of acceleration, it causes the object to
    turn (in other words, to change direction). We can calculate a radius of curvature
    for this turning motion. [Figure 10-8](ch10.xhtml#ch10fig8) shows the trajectory
    of a particle with speed *v*(*t*) and transverse acceleration *a*[⊥](*t*). Over
    a small interval of time *Δt*, the particle will move forward a distance *v*(*t*)Δ*t*
    and in a perpendicular direction a distance *a*[⊥](*t*)Δ^(*t*2)/2.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/147fig01.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Determination of a radius of curvature from transverse acceleration*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-8](ch10.xhtml#ch10fig8) gives a way to find an expression for the
    radius of curvature in terms of the speed and the transverse acceleration. Here
    we write down the Pythagorean theorem for the right triangle in the figure:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Expanding this equation and taking the limit as Δ*t* → 0, which discards the
    term proportional to Δ*t*⁴, we arrive at the following equation for the radius
    of curvature:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ02.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Here is a Haskell function that computes the (instantaneous) radius of curvature
    of an object’s motion from the object’s velocity and acceleration:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we wish, we can invert Equation 10.22 to give an expression for the transverse
    acceleration in terms of the radius of curvature *R*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/148equ03.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: As we see from Equations 10.21 and 10.23, the tangential component of acceleration
    controls the change in speed, and the radial component of acceleration controls
    the change in direction.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Projectile Motion
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the very first uses to which vectors are typically put in physics is
    the study of projectile motion. A projectile is any object thrown, launched, or
    shot near the surface of the earth. The problem is to predict its motion *after*
    the throwing, launching, or shooting force is gone; in fact, rather than speak
    of the launching force, we instead assume that the action of launching simply
    gives the projectile some initial velocity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the presence of Earth’s gravity that makes projectile motion interesting.
    Physics offers four theories of gravity, three of which we will discuss in this
    book:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Gravity causes objects near Earth’s surface to accelerate. An object near Earth’s
    surface that is allowed to move or fall freely will accelerate toward the center
    of the earth at a rate of about 9.81 m/s².
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is a force produced by the earth on objects near its surface. We engage
    with this view of gravity in [Chapters 15](ch15.xhtml) and [16](ch16.xhtml) after
    we’ve started mechanics and discussed the ideas of force, mass, and Newton’s second
    law. The Haskell function `earthSurfaceGravity` in [Chapter 16](ch16.xhtml) describes
    this force of gravity.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is a force between any two objects with mass. This is called Newton’s
    law of universal gravitation. We discuss it in [Chapters 16](ch16.xhtml) and [19](ch19.xhtml)
    and describe it with the Haskell function `universalGravity` after we have introduced
    Newton’s third law.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gravity is the curvature of spacetime. This is Einstein’s general theory of
    relativity. We will not get to it in this book. The book `Gravitation` [**[10](bib.xhtml#bib10)**]
    by Charles Misner, Kip Thorne, and John Wheeler is an excellent introduction to
    general relativity. *Functional Differential Geometry* [**[11](bib.xhtml#bib11)**]
    by Gerald Sussman and Jack Wisdom looks at general relativity from a computational
    point of view, describing it with the functional programming language Scheme.
    Other introductions to general relativity by Rindler [**[12](bib.xhtml#bib12)**],
    Carroll [**[13](bib.xhtml#bib13)**], and Schutz [**[14](bib.xhtml#bib14)**] are
    also recommended.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each theory in this list is more sophisticated than the previous theory. In
    that sense, the later theories are “more correct” than the earlier ones, although
    the earlier ones are often more useful since they are simpler and easier to apply.
    General relativity, in particular, while beautiful and accurate, is rather nontrivial
    to apply and to calculate with.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Some physicists may not agree that the first two theories on my list deserve
    to be called theories, arguing that they are instead approximations to Newton’s
    law of universal gravitation applicable to simple situations. It is not my concern
    to argue whether the first two deserve to be called theories; the important point
    is that they are different ways to incorporate gravity into our calculations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to approach projectile motion, and the one we’ll follow in
    this chapter, is based on theory 1\. We assume the projectile accelerates only
    because of Earth’s gravitational attraction; therefore, the projectile’s acceleration
    is given by the acceleration of gravity, **g**, which is a vector pointing toward
    the center of the earth with magnitude 9.81 m/s².
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Because the acceleration of gravity is constant, we can use the position-time
    equation, Equation 10.17, to give an expression for position as a function of
    time for a projectile.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/149equ01.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'If the z-direction is up and we use SI units, the following function returns
    position as a function of time, where `r0` is the initial position of the projectile
    and `v0` is the initial velocity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Exercise 10.5, you are asked to write a function `projectileVel` that returns
    the velocity of a projectile as a function of time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Projectile motion with air resistance requires theory 2 because we view air
    resistance and gravity on an equal footing by seeing them both as forces. To the
    extent that projectile motion occurs near Earth’s surface, it rarely requires
    theories 3 or 4, which would produce only the slightest difference in results
    for a substantial increase in computation complexity. Theory 3 will have other
    uses, like satellite motion, that we’ll see in later chapters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Having seen projectile motion as one early application of vectors, let’s turn
    to the project of creating the vector data type we have been using.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Own Data Type
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell has a sophisticated and flexible type system. One of the language features
    that makes the type system so powerful is the ability to create your own types.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In discussing pattern matching in [Chapters 3](ch03.xhtml) and [5](ch05.xhtml),
    we noted that each type has one or more data constructors to construct values
    of that type. In making our own data type, we must provide one or more brand new
    data constructors as ways of constructing values of our new data type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at making a new data type with a single data constructor before
    turning to making a new data type with multiple data constructors.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Single Data Constructor
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml), we used the `type` keyword to make type synonyms.
    In a type synonym, such as
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the compiler regards the types `R` and `Double` as interchangeable. In [Chapter
    4](ch04.xhtml), the types `Time`, `Velocity`, `R`, and `Double` were all interchangeable.
    This was convenient, but it does not empower the Haskell type checker to help
    the code writer avoid confusing a `Time` with a `Velocity` or using a `Velocity`
    where a `Time` was expected.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We use the `data` keyword to define new types that are not interchangeable with
    any existing types. Time and mass are each described by a real number in physics,
    but we should never provide a mass in an equation that calls for a time. Let’s
    define a new data type `Mass` that holds a real number but cannot be confused
    with `R` or any other existing data type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use the `data` keyword to define a new data type. We give the name of the
    new data type, `Mass` in this case, after the `data` keyword, followed by an equal
    sign. To the right of the equal sign we give a data constructor, `Mass` in this
    case, followed by the information our new data type contains, in this case `R`.
    The name of the new data type and the name of the data constructor can be the
    same or different. In this case, they have the same name, but they are different
    things. In defining data types with a single constructor, it’s common to use the
    same name for the data constructor that we use for the type, but it’s not necessary.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: By default, a new data type is not an instance of any type classes. Since it’s
    common to want a new data type to be an instance of some of the standard type
    classes, such as `Eq` and `Show`, Haskell provides a `deriving` keyword that attempts
    to make the new type an instance of the type classes listed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: To construct a value with type `Mass`, we use the data constructor `Mass`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we ask for the type of this value, GHCi will tell us the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In GHCi’s response, the `Mass` on the left of the double colon is the data constructor,
    and the `Mass` on the right of the double colon is the data type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The data constructor itself has a function type. It takes an `R` as input and
    returns a `Mass` as output.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are asking GHCi for the type of the data constructor, not the type of the
    type, which wouldn’t make any sense. Again, the `Mass` on the left of the double
    colon is the data constructor, and the `Mass` on the right of the double colon
    is the data type.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: If we now accidentally supply a `Mass` in a place where an `R` is called for,
    the type checker will give us a type error, helping us to identify our mistake
    rather than silently doing the wrong thing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: We can provide more than a single piece of information under the data constructor.
    In [Chapter 9](ch09.xhtml) we used a list of pairs to hold grade information.
    Let’s define a new data type called `Grade` that holds a `String` and an `Int`,
    representing the name of a person and their grade on some assignment.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We give the data constructor the same name as the type and simply list the types
    of information that are to be contained in the new data type.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of grades for a few people:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To construct a value of type `Grade`, we use the data constructor `Grade`, followed
    by a `String` and an `Int`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the type of the data constructor `Grade`,
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: we see that it takes a `String` and an `Int` as input and returns a `Grade`
    as output. As before, the `Grade` on the left of the double colon is the data
    constructor, and the `Grade` on the right of the double colon is the data type.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative syntax for defining a new data type, called *record
    syntax*, that gives names to each of the pieces of data under a constructor. Let’s
    define a new data type called `GradeRecord` that is essentially the same as the
    type `Grade` but uses record syntax for its definition.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To use record syntax, we enclose the names and types of each piece of information
    in curly braces after the data constructor. Use of record syntax automatically
    creates a new function for each named piece of information.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function `name` takes a `GradeRecord` as input and returns the `String`
    that holds the name in that `GradeRecord`. The function `grade` takes a `GradeRecord`
    as input and returns the `Int` that holds the grade in that `GradeRecord`. By
    default, the names `name` and `grade` are placed in the global namespace so they
    may not be reused as names for fields in another data type. This default behavior
    is simple but too constraining in some situations, so the language option `DuplicateRecordFields`
    is available to override this default behavior, although we will not explore it
    in this book.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: If we use record syntax to define our new data type, there are two ways to construct
    a value of that type. First, we can use the same syntax we used for the type `Grade`
    above, simply giving the data constructor followed by a `String` and an `Int`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Second, we can use record syntax to construct a value of type `GradeRecord`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we use curly braces and give the pieces of information by name rather than
    by position.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The decision on whether to use record syntax should be based on the usefulness
    of having names to describe the pieces of data that the new type holds. If you
    don’t need the names, you should use the basic syntax. If the names seem useful,
    record syntax is a good choice.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to define a new data type with a single data constructor. Now
    let’s look at data types with more than one data constructor.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Data Constructors
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Prelude type `Bool` has two data constructors, `False` and `True`, as we
    saw when we did pattern matching on `Bool`. Neither of the data constructors contains
    any information beyond the name of the constructor itself.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define a new data type called `MyBool` that works the same way `Bool`
    does. We need a fresh name because `Bool` is already defined in the Prelude.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We begin with the `data` keyword as before, followed by the name `MyBool` of
    our new data type. On the right of the equal sign, we give the first data constructor,
    which we call `MyFalse`, then a vertical bar, and then the second data constructor
    `MyTrue`. We need fresh names for the data constructors because the names `False`
    and `True` are already taken.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The vertical bar in the definition can be read as “or,” in the sense that a
    value of type `MyBool` is either `MyFalse` or `MyTrue`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the new data type `MyBool`, we can ask about the type of `MyFalse`,
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: and we are not surprised to find that it has type `MyBool`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: When we have multiple data constructors, they usually have different names from
    the data type itself.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define our own version of `Maybe`, called `MyMaybe`. Recall from [Chapter
    9](ch09.xhtml) that `Maybe` is a type constructor, which means that it takes a
    type as input to produce a new type.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The type variable `a` stands for any type. The fact that we are using a type
    variable after `MyMaybe` in this data type definition makes `MyMaybe` a type constructor
    rather than a type. Here we have two data constructors, but unlike for the type
    `MyBool`, the data constructor `MyJust` contains some information, namely a value
    of type `a`. A value of type `MyMaybe a` is either `MyNothing` or `MyJust x` for
    some `x :: a`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the types of the data constructors.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For comparison, we can look at the types of the Prelude data constructors for
    `Maybe`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We see that `Nothing` is not even a function but just a value of type `Maybe
    a`. On the other hand, `Just` is a function that takes a value of type `a` and
    returns a value of type `Maybe a`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 19](ch19.xhtml), when we’re talking about systems of particles,
    we’ll define a new data type called `Force` that has two constructors: one for
    an external force and one for an internal force.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve talked about how to define a new data type, let’s move on to
    define the `Vec` type we’ve been using in this chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Defining a New Data Type for 3D Vectors
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell does not come with a built-in type for vectors, so we have to define
    it ourselves. In the beginning of this chapter, we looked at how vectors are defined
    and used in physics. With this knowledge, we’ll turn to the question of how to
    implement three-dimensional vectors in Haskell. The new type must hold three real
    numbers, for the three components of a vector in some coordinate system, or something
    equivalent. We have several options.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Possible Implementations
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s consider some possible implementations for the type `Vec` before making
    a final choice.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Use a List'
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could use a list of real numbers to hold the three components of a vector.
    A type synonym for this definition would look like the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This type of vector can hold all possible triples of real numbers. The trouble
    with this definition is that the type can also hold lists of real numbers that
    don’t have a length of three. This potential type doesn’t match our requirements
    as nicely as we would like; it’s a little too big, given that the empty list or
    a list of two real numbers would satisfy the type checker as a legitimate value
    of this type.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: Use a Tuple'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A better option would be to choose a triple of real numbers. A type synonym
    would look like the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a better match for our requirements because this type guarantees that
    there must be three components. The only downside to this option is the possible
    confusion of a triple representing the three components of a vector with a triple
    representing three other numbers, such as the spherical coordinates of a position.
    Since option 2 uses a type synonym, the type checker could not help us catch an
    accidental use of our new vector type in a place where some other triple of real
    numbers is called for.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: Make a New Data Type'
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A third option is to define a new data type for `Vec` that cannot be confused
    with any other data type, even if the other data type is essentially a collection
    of three real numbers like `Vec`. We want a fundamental concept in physics, like
    the three-dimensional vector, to be reflected in the type system so the type system
    can help us keep things straight in a way that respects how we think about the
    subject. This is the option we’ll pursue next.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Data Type Definition for Vec
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is our data type definition:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We decide to use the same name `Vec` for the data constructor we used for the
    type. We use record syntax because that automatically produces functions `xComp`,
    `yComp`, and `zComp` for the three components of a vector. We ask the compiler,
    through the `deriving` keyword, to create an instance of `Eq` for the new `Vec`
    data type. However, we do not ask for an automatic instance of `Show` because
    we want to define that manually.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll show how to make the type `Vec` an instance of type class `Show`.
    The general way to make a type an instance of a type class is with the `instance`
    keyword.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After the `instance` keyword, we give the type class, then the type to be an
    instance of that type class, and then the keyword `where`, before giving definitions
    for the functions owned by the type class.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Starting on the second line, we define the functions owned by the type class,
    and we say how they are supposed to work for the specific case of the type in
    question, `Vec` in this case. The only function that needs to be defined in an
    instance of `Show` is the function `show`, which describes how to turn a `Vec`
    into a `String` so it can be shown.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Our way of showing a vector begins with the string `"vec "`, followed by each
    of the three components in turn. The function `showDouble` does the work of turning
    each real number into a string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `show` function inside the instance definition must be
    indented with respect to the `instance` keyword. Any other functions that get
    defined inside the instance definition must be indented by the same amount.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: There are actually two other functions owned by type class `Show`, called `showsPrec`
    and `showList`, but these will get default definitions if we don’t define them,
    which we didn’t earlier. Using `:i Show` in GHCi gives a list of the functions
    owned by type class `Show`, along with which functions *must* be defined in an
    instance definition.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function `showDouble`, used earlier in the function `show`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The type `Double` is already an instance of `Show`, as noted in [Chapter 8](ch08.xhtml),
    so the function `show` is already available to turn a `Double` into a `String`.
    Our function `showDouble` uses the function `show` and simply encloses negative
    numbers in parentheses. The reason for enclosing negative components in parentheses
    is so the way a `Vec` gets shown is a legitimate expression for the `Vec`, meaning
    it can be used as input wherever a `Vec` is called for. To carry out this plan
    for having an expression like `vec 3.1 (-4.2) 5.0` accepted as a legitimate value
    of type `Vec`, we need a `vec` function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `vec` function does the same thing that the data constructor `Vec` does.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Why not just use the data constructor `Vec` to form and show our vectors, thus
    eliminating the need to define a `Show` instance for `Vec` and define the function
    `vec`? This is indeed a possibility, and not a bad one. The main reason I did
    not do it is that I wanted to use record syntax, and the automatically generated
    `Show` instance obtained by using the `deriving` keyword would have used record
    syntax to show the vector. This in itself is unproblematic, but when we get into
    lists of vectors, or lists of tuples of vectors, we will want a brief way to show
    our vectors.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Haskell has traditionally favored that what can be shown can also be read. The
    `Read` type class is for types that can be read from a `String`, and it serves
    as a sort of inverse to the `Show` type class for types that can be shown as a
    `String`. This is the reason why the `Show` instance looks just like the application
    of the `vec` function to three components.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Vec Functions
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are unit vectors in the x-, y-, and z-directions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We give the zero vector the special name `zeroV`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The unary minus sign will not work in front of a vector, so we define a function
    `negateV` that returns the additive inverse of a vector (the negative of the vector).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Vector addition and subtraction are just the addition and subtraction of the
    corresponding Cartesian components.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It’ll be useful to have a function that adds a whole list of vectors. We’ll
    use this function when we do numeric integrals of vector-valued functions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The function foldr is defined in the Prelude. The definition of sumV is written
    in point-free style, which means it is short for `sumV vs = foldr (^+^)` `zeroV
    vs`. Roughly speaking, foldr takes a binary operator (`(^+^)` in this case), an
    initial value, and a list of values, and “folds” the initial value and an element
    from the list into an accumulated value, after which it continues to fold the
    accumulated value with the next element of the list to form a new accumulated
    value until the list is gone and the final accumulated value is returned. It’s
    a fairly powerful function, but here it’s used just to keep adding the members
    of the list until there are no more.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to multiply three-dimensional vectors. The first is scalar
    multiplication, in which we multiply a number by a vector or a vector by a number.
    We use `(*^)` and `(^*)` for scalar multiplication. The first takes a number on
    the left and a vector on the right. The second takes a vector on the left and
    a number on the right. The vector always goes next to the caret symbol. The second
    vector multiplication method is the dot product. We use `(<.>)` for the dot product.
    The third vector multiplication method is the cross product. We use `(><)` for
    the cross product.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the definitions for the three vector multiplications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first two definitions are for scalar multiplication. If the vector is to
    the right of the number, we use the operator with the caret on the right. If the
    vector is to the left of the number, we use the operator with the caret on the
    left. In either case, the definition says that scalar multiplication is carried
    out by multiplying each Cartesian component by the scaling number. The dot product
    is defined via Equation 10.8\. The cross product is defined via Equation 10.9.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We can also divide a vector by a scalar.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, we define a `magnitude` function to take the magnitude of a vector.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This completes our data type definition for the new data type `Vec`, along with
    supporting functions that allow us to write about vectors in the way we think
    about them and use them in physics.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed kinematics in three spatial dimensions. In three dimensions,
    time is represented by a real number while velocity and acceleration are represented
    by vectors. Position is not truly a vector, but in this chapter we keep it simple
    and regard position as the displacement vector from the origin of some preferred
    or default coordinate system.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Vectors are fundamentally geometric entities; to use numbers to describe the
    components of a vector, we must introduce a coordinate system. In any situation
    in which an object is moving, we can decompose the acceleration into a component
    parallel to the velocity and a component perpendicular to the velocity. This decomposition
    is coordinate independent.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: With a system for vectors in place, we are now in a position to do all the projectile
    motion problems we ever wanted to do. We showed Haskell’s facility for defining
    our own data types, and we used that system to implement the `Vec` type for three-dimensional
    vectors.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 10.1.** Translate the following mathematical definitions into Haskell
    definitions:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '| (a) ![Image](Images/e0159-01.jpg) | (Use `v0` in Haskell for `**v**[0]`.)
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| (b) ![Image](Images/e0159-02.jpg) | (Use `v1` for `**v**[1]`.) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| (c) ![Image](Images/e0159-03.jpg) | (Use `v` for **v**.) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| (d) ![Image](Images/e0159-04.jpg) | (Use `r` for **r**.) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| (e) ![Image](Images/e0159-05.jpg) | (Use `x` for *x*.) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: What are the Haskell types of v0, v1, v, r, and x?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.2.** Write an integration function'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: for vector-valued functions of a real variable that is similar to the function
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: that we wrote in [Chapter 6](ch06.xhtml).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.3.** Write a function'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: that returns the maximum z-component for projectile motion in which the initial
    position and the initial velocity of an object are given. Assume gravity acts
    in the negative z-direction.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.4.** Write a function'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: that, given an initial velocity and a constant acceleration, returns a function
    giving speed as a function of time.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.5.** In the spirit of the function `projectilePos`, write a type
    signature and function definition for a function `projectileVel` that computes
    the velocity of a projectile at a given time.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.6.** Define a new type `Vec2D` for two-dimensional vectors. Then
    define functions'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: that find the magnitude and angle of a two-dimensional vector and construct
    a two-dimensional vector from a magnitude and angle. You may want to use the `atan`
    or `atan2` functions, which we discussed in [Chapter 1](ch01.xhtml).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.7.** Define a function'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: that computes the projection of a vector into the xy plane. For example, `xyProj
    (vec 6 9 7)` should evaluate to `vec 6 9 0`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.8.** Define a function'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: that returns a triple (*v*, *θ*, *ϕ*) for a vector **v** in which
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ01.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'For example, `magAngles (vec (-1) (-2) (-3))` should evaluate to:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Exercise 10.9.** The velocity and acceleration of a ball launched from the
    ground are'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ02.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: where **v**[0] is the initial velocity of the ball and **g** is the acceleration
    of gravity. Suppose a ball is launched from the ground with an initial speed of
    25 m/s at an angle 52^∘ above horizontal. Choose a coordinate system and define
    a constant
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: for the acceleration of gravity near Earth’s surface. It should be 9.8 m/s²
    toward the center of the earth. Next, define a function
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: that gives the velocity of the ball as a function of time. Now define a function
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: that gives the rate of change of the speed of the ball as a function of time.
    You may want to use `speedRateChange` for this. At what point in the ball’s motion
    is the rate of change of its speed equal to zero? Is its velocity zero at that
    point? Is its acceleration zero at that point? Use `plotFunc` from [Chapter 7](ch07.xhtml)
    to make a graph of the rate of change of the speed of the ball as a function of
    time over the four seconds it is in the air.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.10.** Consider a particle in uniform circular motion. If we choose
    our coordinate system so that the motion takes place in the xy-plane with the
    origin at the center of the circle, we can write the position of the particle
    as'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/161equ03.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: where *R* is the radius of the circle and *ω* is the angular velocity of the
    motion. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ01.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ02.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: This particle in uniform circular motion has a speed *v*[*UCM*] (*t*) = *ωR*,
    which does not depend on time. The constant speed is what we mean by the word
    “uniform.”
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: For a uniform circular motion with *R* = 2 m and *ω* = 6 rad/s, encode the position,
    velocity, and acceleration of the particle in Haskell. Use `aParallel` to confirm
    that the tangential component of acceleration is 0 at several different times.
    Use `aPerp` to confirm that the magnitude of the radial component of acceleration
    is [*v*[UCM] (*t*)]²/*R* = ^(*ω*2)*R*, again at several different times.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.11.** Consider a particle in nonuniform circular motion on a
    circle with radius *R*. If we choose our coordinate system so that the motion
    takes place in the xy-plane with the origin at the center of the circle, we can
    write the position of the particle as'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ03.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: where *θ*(*t*) describes the angle the particle makes with the x-axis as a function
    of time. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ04.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/162equ05.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
- en: This particle in circular motion has speed *v*[NCM] (*t*) = *R* |*Dθ*(*t*)|,
    which will depend on time unless *Dθ*(*t*) is constant. The magnitude of the particle’s
    tangential acceleration is *R* |^(*D*2)*θ*(*t*)| and the magnitude of its radial
    acceleration is [*v*[NCM] (*t*)]²/*R* = *R*[*Dθ*(*t*)]².
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Write a function
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: that takes a radius *R*, a function *θ*, and a time *t* as input and returns
    a position vector as output.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this exercise is to confirm that, even in nonuniform circular
    motion, the magnitude of a particle’s radial component of acceleration is equal
    to the square of its speed divided by the radius of the circle. The following
    function finds the radial component of acceleration for any particle whose position
    can be given as function of time. Its first input is a small time interval to
    use for numerical derivatives. Its second input is the position function for the
    particle, and its third input is time.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: For a radius *R* = 2 m and
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/163equ01.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
- en: use `aPerpFromPosition` to find the radial component of acceleration at *t*
    = 2 seconds. Then find the speed of the particle at that time. Finally, show that
    the magnitude of the radial component is equal to the square of its speed divided
    by the radius of the circle.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
