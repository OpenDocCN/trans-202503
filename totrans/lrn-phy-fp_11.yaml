- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: DESCRIBING MOTION IN THREE DIMENSIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 描述三维中的运动
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: In [Chapter 4](ch04.xhtml), we reviewed one-dimensional kinematics, describing
    quantities like velocity and acceleration with real numbers. In this chapter,
    we’ll look at three-dimensional kinematics, describing velocity and acceleration
    as vectors. Haskell does not have a built-in type for vectors, but it does have
    powerful facilities for making your own types, which we’ll use to create a `Vec`
    type for vectors. Before deciding how to implement the `Vec` type, we’ll take
    a careful look at the meaning and use of vectors in physics so we can produce
    an implementation that aligns well with how we think and write about vectors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中，我们回顾了一维运动学，使用实数来描述速度和加速度等量。在本章中，我们将讨论三维运动学，将速度和加速度描述为向量。Haskell
    没有内置的向量类型，但它有强大的工具来创建自定义类型，我们将使用这些工具来创建一个 `Vec` 类型的向量。在决定如何实现 `Vec` 类型之前，我们将仔细研究向量在物理学中的意义和用途，以便能够实现一个与我们思考和写作向量的方式相符的实现。
- en: Three-Dimensional Vectors
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三维向量
- en: The notion of a three-dimensional vector is essential in physics. In physics,
    vectors are geometric objects used to describe quantities that have a magnitude
    and a direction in space. They are best thought of as arrows in which the length
    of the arrow represents the magnitude and the arrow points in some direction.
    Living on the surface of the earth as we do, directions can sometimes be described
    briefly in words, such as “up,” “north,” and so on. We can only ever specify the
    direction of a vector relative to some object, such as the earth; there is no
    universal or absolute notion of direction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 三维向量的概念在物理学中至关重要。在物理学中，向量是用来描述具有大小和方向的量的几何对象。向量最好被看作是箭头，其中箭头的长度代表大小，箭头指向某个方向。像我们一样生活在地球表面时，方向有时可以简要地用词语来描述，比如“向上”、“向北”等等。我们只能相对于某个物体（如地球）来指定向量的方向；没有普遍的或绝对的方向概念。
- en: When we discussed one-dimensional motion in [Chapter 4](ch04.xhtml), we did
    it in the context of an air track that came already marked in meters. The markings
    on the air track amount to a coordinate system in one dimension. A *coordinate
    system* is a method for describing position in terms of numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第4章](ch04.xhtml)讨论一维运动时，我们是以一个已经按米标定的空气轨道为背景的。空气轨道上的标记相当于一维坐标系。*坐标系* 是一种用数字描述位置的方法。
- en: Nature does not typically grant us a coordinate system to use; instead, we choose
    the coordinate system we want to use. In three dimensions, this amounts to choosing
    a location and orientation for a set of three mutually perpendicular directions.
    Along each direction (let’s call them *x*, *y*, and *z*), we make (real or imaginary)
    marks, in meters. The place where *x* = *y* = *z* = 0 is called the *origin* of
    the coordinate system. Once we have chosen a coordinate system, a position can
    be described by three numbers (*x*, *y*, and *z*), indicating the (positive or
    negative) distance from the origin in each direction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自然界通常不会提供给我们一个坐标系来使用；相反，我们选择我们想要使用的坐标系。在三维空间中，这相当于选择一个位置和三个互相垂直方向的方向。沿着每个方向（我们称之为
    *x*、*y* 和 *z*），我们做（真实的或假想的）标记，以米为单位。*x* = *y* = *z* = 0 的地方被称为坐标系的 *原点*。一旦我们选择了坐标系，位置就可以通过三个数字（*x*、*y*
    和 *z*）来描述，表示每个方向上从原点出发的（正或负）距离。
- en: To describe motion in three dimensions, we usually need to introduce a coordinate
    system. But the laws of physics shouldn’t depend on any particular coordinate
    system. They should work with whatever coordinate system we want to use. Vectors
    are geometric objects; along with the laws of physics, vectors have an existence
    apart from any coordinate system. Vectors allow various operations we can describe
    without a coordinate system. We’ll give geometric (coordinate-free) descriptions
    of the important properties and operations of vectors and then show how the same
    operations appear once we have introduced a coordinate system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述三维中的运动，我们通常需要引入一个坐标系。但物理定律不应依赖于任何特定的坐标系，它们应该适用于我们想要使用的任何坐标系。向量是几何对象；与物理定律一起，向量具有独立于任何坐标系的存在。向量允许我们进行各种操作，我们可以在没有坐标系的情况下描述这些操作。我们将提供向量重要属性和操作的几何（无坐标）描述，然后展示在引入坐标系后这些操作是如何表现出来的。
- en: 'Before we get into the various vector operations, I want to write the code
    that must exist at the top of the source code file for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入各种向量运算之前，我想写出本章源代码文件顶部必须存在的代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line turns on compiler warnings, which is a good idea to help avoid
    some common mistakes that are legal code but may not mean what you think they
    mean. If there are warnings, you will see them when you load the file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行启用了编译器警告，这是一个好主意，有助于避免一些常见的错误，这些错误可能是合法的代码，但可能并不是你认为的那样。如果有警告，加载文件时你会看到它们。
- en: The next line gives the code in this chapter a module name so that this code
    can be imported into another source code file later. The module name `SimpleVec`
    must match the name of the file that contains it, so the filename should be *SimpleVec.hs*.
    The remaining lines specify precedence levels and associativities for the operators
    we define later in the chapter. The precedence levels are numbers from 0 to 9,
    described in [Chapter 1](ch01.xhtml), that determine which operators act first
    in an expression with multiple operators. The keyword `infixl` is for an operator
    with left associativity, while `infixr` is for right associativity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行给本章中的代码提供了一个模块名称，以便稍后可以将该代码导入到另一个源代码文件中。模块名称`SimpleVec`必须与包含该代码的文件名匹配，因此文件名应该是*SimpleVec.hs*。其余的行指定了我们稍后在本章中定义的操作符的优先级和结合性。优先级是从0到9的数字，描述了在多个操作符的表达式中哪个操作符先执行，详见[第1章](ch01.xhtml)。关键字`infixl`用于具有左结合性的操作符，而`infixr`用于右结合性操作符。
- en: Coordinate-Free Vectors
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无坐标向量
- en: Now that we have this code at the top of our file and have a basic idea of what
    vectors are, let’s look some of their geometric properties. We’ll give the geometric
    definitions for vector addition, scalar multiplication, vector subtraction, the
    dot product, the cross product, and the derivative of a vector-valued function
    of a real number. If you’re interested, the book *Modern Classical Physics* [**[6](bib.xhtml#bib6)**]
    by Kip Thorne and Roger Blandford gives an elegant motivation for the coordinate-free,
    geometric view of vectors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在文件顶部写好了这段代码，并且对向量有了基本的了解，让我们来看看它们的一些几何性质。我们将给出向量加法、标量乘法、向量减法、点积、叉积以及实数函数的向量值导数的几何定义。如果你感兴趣的话，Kip
    Thorne和Roger Blandford的《现代经典物理学》*Modern Classical Physics* [**[6](bib.xhtml#bib6)**]一书为无坐标的几何视角提供了优雅的动机。
- en: Geometric Definition of Vector Addition
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量加法的几何定义
- en: We can combine two vectors using what we’ll call *vector addition*. Geometrically,
    we define the sum of two vectors to be the vector that points from the tail of
    the first to the tip of the second when the two vectors are placed tip-to-tail.
    You can see from [Figure 10-1](ch10.xhtml#ch10fig1) that the order in which they
    are placed tip-to-tail does not matter; consequently, vector addition is commutative
    (**A** + **B** = **B** + **A**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们所称的*向量加法*来合并两个向量。从几何角度看，我们定义两个向量的和为一个向量，这个向量从第一个向量的尾部指向第二个向量的顶端，当两个向量按尾对尾的方式排列时。你可以从[图10-1](ch10.xhtml#ch10fig1)中看到，向量的尾端到顶端的排列顺序并不重要；因此，向量加法是可交换的（**A**
    + **B** = **B** + **A**）。
- en: '![Image](Images/131fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/131fig01.jpg)'
- en: '*Figure 10-1: Vector addition. The vector **A** + **B** is the sum of vectors
    **A** and **B**.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：向量加法。向量**A** + **B**是向量**A**和**B**的和。*'
- en: 'Physicists need to know whether a symbol stands for a number or a vector; thus,
    the theory of Newtonian mechanics (and most other theories in physics) invites
    us to think in terms of types. The mathematical notation that physicists typically
    use to indicate a vector is syntactic and identifies a vector by a boldface symbol.
    In Haskell, the distinction between numbers and vectors is not syntactic; names
    for each are simply identifiers that begin with a lowercase letter. In Haskell,
    the distinction between numbers and vectors is semantic and is captured by the
    type of the value: `R` for numbers and `Vec` for vectors.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学家需要知道一个符号是表示数字还是向量；因此，牛顿力学的理论（以及物理学中的大多数其他理论）促使我们从类型的角度思考。物理学家通常使用的数学符号表示向量是语法性的，通过粗体符号来标识向量。在Haskell中，数字和向量之间的区别不是语法上的；它们的名称只是以小写字母开头的标识符。在Haskell中，数字和向量之间的区别是语义上的，并通过值的类型来表达：`R`代表数字，`Vec`代表向量。
- en: 'In mathematical notation, we use the same + sign for vector addition that we
    use for addition of numbers, even though vectors and numbers are very different
    things and it makes no sense to add a vector to a number. In Haskell, we’ll use
    a different symbol (`^+^`) for vector addition than we do for number addition.
    If `a` and `b` are vectors (we write `a :: Vec` to say that `a` has type `Vec`),
    then `a ^+^ b` will be their vector sum. At the end of the chapter, we’ll show
    how to define the `Vec` type and the `^+^` operator.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在数学符号中，我们使用与数字加法相同的+符号表示向量加法，尽管向量和数字是截然不同的事物，将向量与数字相加是没有意义的。在 Haskell 中，我们会为向量加法使用与数字加法不同的符号（`^+^`）。如果`a`和`b`是向量（我们写`a
    :: Vec`来表示`a`的类型是`Vec`），那么`a ^+^ b`将是它们的向量和。章末我们会展示如何定义`Vec`类型和`^+^`运算符。'
- en: NOTE
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: '*In this chapter, we introduce new operators for vector addition, subtraction,
    and scalar multiplication. An alternative path, which we do not follow, would
    be to expand the definitions of addition (`+`), subtraction (`-`), and multiplication
    (`*`) so they work for vectors as well as numbers. The Haskell language is certainly
    powerful enough to do this. The reason we don’t follow this course is that we
    prefer to have simple, concrete types for our vector operations, rather than types
    involving type classes. The names, such as `^+^`, that we use for the new operators
    are borrowed from Conal Elliott’s `vector-space` package [**[7](bib.xhtml#bib7)**],
    a more sophisticated and general way of dealing with vectors than we present here.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这一章中，我们引入了用于向量加法、减法和标量乘法的新运算符。一种替代的路径是扩展加法（`+`）、减法（`-`）和乘法（`*`）的定义，使其既适用于向量也适用于数字。Haskell
    语言完全能够实现这一点。我们没有选择这种方法的原因是，我们更倾向于为向量操作定义简单、具体的类型，而不是涉及类型类的类型。我们为新运算符使用的名称，如`^+^`，借用了Conal
    Elliott的`vector-space`包[**[7](bib.xhtml#bib7)**]，这是处理向量的一种比我们这里介绍的更复杂、更通用的方法。*'
- en: Geometric Definition of Scaling a Vector
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量缩放的几何定义
- en: 'We define scaling a vector by a number (also called *scalar multiplication*
    or multiplying a number by a vector) as follows: if the number is positive, we
    multiply the magnitude of the vector by the number and leave the direction of
    the vector unchanged. If the number is negative, we multiply the magnitude of
    the vector by the absolute value of the number and flip the direction of the vector.
    If the number is 0, the result is the zero vector.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义将一个向量缩放为一个数字（也叫做*标量乘法*或将数字乘以向量）如下：如果数字为正，我们将向量的大小乘以该数字，并保持向量的方向不变。如果数字为负，我们将向量的大小乘以该数字的绝对值，并翻转向量的方向。如果数字为
    0，结果是零向量。
- en: We define division of a vector **A** by a number *m* to be scalar multiplication
    of the vector by the reciprocal of *m*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义将向量**A**除以数字*m*为将向量乘以*m*的倒数，即标量乘法。
- en: '![Image](Images/132equ01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/132equ01.jpg)'
- en: In [Figure 10-2](ch10.xhtml#ch10fig2), we show the results of scaling a vector
    by 2, – 1, and – 1/2\. Scaling by a positive number multiplies the length of the
    vector, keeping the direction the same. Scaling by a negative number multiples
    the vector’s length and flips its direction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-2](ch10.xhtml#ch10fig2)中，我们展示了按 2、–1 和 –1/2 缩放一个向量的结果。按正数缩放会增加向量的长度，保持方向不变；按负数缩放会增加向量的长度并翻转方向。
- en: '![Image](Images/133fig01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/133fig01.jpg)'
- en: '*Figure 10-2: Scalar multiplication. Scaling **A** by 2, –1, and –1/2 results
    in 2 **A**, –**A**, and –**A**/2, respectively.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：标量乘法。将**A**按 2、–1 和 –1/2 缩放，分别得到 2**A**、–**A** 和 –**A**/2。*'
- en: In mathematical notation, we use the same juxtaposition of symbols (placing
    a number beside a vector) for scalar multiplication that we use for multiplication
    of numbers, even though the operation is different. Similarly, we use the same
    sign (/) for dividing a vector by a number, even though the operation is different.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学符号中，我们对于标量乘法使用与数字相乘相同的符号（将一个数字放在向量旁边），尽管这两个操作是不同的。类似地，我们用相同的符号（/）表示将向量除以数字，尽管这两个操作也是不同的。
- en: In Haskell, we’ll use different symbols for scalar multiplication than we do
    for number multiplication, and a different symbol for division of a vector by
    a number than we use for division of a number by a number. If `m` is a number
    and `a` is a vector, then `m *^ a` and `a ^* m` each mean the scaling of `a` by
    `m`. Note that the caret sign is closer to the vector in each case. To divide
    `a` by `m`, we write `a ^/ m`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，我们为标量乘法使用与数字乘法不同的符号，为向量除以数字使用与数字除以数字不同的符号。如果 `m` 是一个数字，`a` 是一个向量，那么
    `m *^ a` 和 `a ^* m` 都表示将 `a` 按 `m` 缩放。注意，在这两种情况下，插入符号都离向量更近。要将 `a` 除以 `m`，我们写作
    `a ^/ m`。
- en: Geometric Definition of Vector Subtraction
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量相减的几何定义
- en: Another way to combine two vectors is with what we’ll call *vector subtraction*.
    The difference of two vectors is defined to be the vector that points from the
    tip of the first to the tip of the second when the two vectors are placed tail-to-tail.
    [Figure 10-3](ch10.xhtml#ch10fig3) shows that the difference of two vectors is
    equal to the sum of one vector and the opposite of the other vector. In symbols,
    **B** – **A** = **B** + (–**A**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种组合两个向量的方法是我们所称的*向量相减*。两个向量的差定义为当两个向量尾对尾摆放时，从第一个向量的尖端指向第二个向量尖端的向量。[图 10-3](ch10.xhtml#ch10fig3)显示了两个向量的差等于一个向量与另一个向量的相反数之和。用符号表示，**B**
    - **A** = **B** + (–**A**)。
- en: '![Image](Images/133fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/133fig02.jpg)'
- en: '*Figure 10-3: Vector subtraction. The vector **B** – **A** is the difference
    of vectors **B** and **A**.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：向量相减。向量**B** - **A**是向量**B**和**A**的差。*'
- en: In mathematical notation, we use the same sign (–) for vector subtraction that
    we use for subtraction of numbers, even though vectors and numbers are very different
    things. In Haskell, if `a` and `b` are vectors, we’ll define `a ^-^ b` to be their
    vector difference.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表示中，我们使用相同的符号（–）来表示向量相减，就像我们用相同的符号表示数字相减一样，尽管向量和数字是非常不同的东西。在 Haskell 中，如果
    `a` 和 `b` 是向量，我们将定义 `a ^-^ b` 为它们的向量差。
- en: Geometric Definition of Dot Product
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点积的几何定义
- en: 'There are (at least) two important products of vectors in physics. One is the
    *dot product*, or *inner product*. The dot product of two vectors is a scalar,
    or number. Here’s the geometric definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，向量有（至少）两种重要的积。一个是*点积*，或*内积*。两个向量的点积是一个标量，或数字。以下是它的几何定义：
- en: '**A · B** = *AB* cos θ'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**A · B** = *AB* cos θ'
- en: In this equation, *θ* is the angle between the two vectors when they are placed
    tail-to-tail, and we use the standard notation of allowing an italic symbol to
    stand for the magnitude of the vector whose boldface symbol has the same letter.
    In other words, *A* = |**A**| and *B* = |**B**|.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*θ* 是当两个向量尾对尾摆放时它们之间的角度，我们使用标准符号，即让斜体符号表示与粗体符号具有相同字母的向量的大小。换句话说，*A* =
    |**A**| 和 *B* = |**B**|。
- en: '[Figure 10-4](ch10.xhtml#ch10fig4) shows that the dot product of two vectors
    is the product of the magnitude of one vector (*B* or *A*) and the projection
    of the second vector onto the first (*A* cos *θ* or *B cos θ*, respectively).
    Note that the projection will be negative when *θ* > 90^∘.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch10fig4)显示了两个向量的点积是一个向量的大小（*B* 或 *A*）与第二个向量在第一个向量上的投影（*A*
    cos *θ* 或 *B cos θ*）的乘积。请注意，当 *θ* > 90^∘ 时，投影将为负。'
- en: '![Image](Images/134fig01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/134fig01.jpg)'
- en: '*Figure 10-4: The dot product of two vectors is the product of the magnitude
    of one vector and the projection of the second vector onto the first.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：两个向量的点积是一个向量的大小与第二个向量在第一个向量上的投影的乘积。*'
- en: 'Notice that the dot product is commutative: **A ⋅B = B ⋅A**. Also, the dot
    product is related to the magnitude of a vector.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点积是可交换的：**A ⋅B = B ⋅A**。此外，点积与向量的大小有关。
- en: '**A · A** = |A|² cos (0) = |**A**|² = *A*²'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**A · A** = |A|² cos (0) = |**A**|² = *A*²'
- en: Therefore,
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '![Image](Images/134equ01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/134equ01.jpg)'
- en: The dot product distributes over a vector sum.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点积对向量和分配。
- en: '**C · (A + B) = C · A + C · B**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**C · (A + B) = C · A + C · B**'
- en: In Haskell, if `a` and `b` are vectors, then `a <.> b` will be their dot product.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，如果 `a` 和 `b` 是向量，那么 `a <.> b` 将是它们的点积。
- en: Geometric Definition of Cross Product
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 叉积的几何定义
- en: The *cross product* of two vectors is the vector whose magnitude is given by
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量的*叉积*是一个向量，其大小由下式给出
- en: '|**A** × **B**| = *AB* sin θ'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|**A** × **B**| = *AB* sin θ'
- en: and whose direction is perpendicular to both **A** and **B**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其方向与向量**A**和**B**都垂直。
- en: '[Figure 10-5](ch10.xhtml#ch10fig5) shows the plane containing vectors **A**
    and **B**. To find the direction of **A** × **B**, imagine rotating vector **A**
    about its tail through an angle less than 180^∘ until it aligns with vector **B**.
    If counterclockwise rotation is required to carry this out, the direction of **A**
    × **B** is out of the page. If instead clockwise rotation is required, the direction
    of **A** × **B** is into the page.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](ch10.xhtml#ch10fig5)展示了包含向量**A**和**B**的平面。为了找到**A** × **B**的方向，想象将向量**A**绕其尾部旋转一个小于
    180^∘的角度，直到它与向量**B**对齐。如果需要逆时针旋转来完成这一动作，那么**A** × **B**的方向是指向页面外。如果需要顺时针旋转，则**A**
    × **B**的方向是指向页面内。'
- en: '![Image](Images/135fig01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/135fig01.jpg)'
- en: '*Figure 10-5: Cross product. The vector ***A**** × ****B*** points out of the
    page. The vector **B*** × ****A*** points into the page.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：叉积。向量 ***A**** × ****B*** 指向页面外。向量 **B*** × ****A*** 指向页面内。*'
- en: 'For **A** and **B** in [Figure 10-5](ch10.xhtml#ch10fig5), the vector **A**
    × **B** points out of the page and the vector **B** × **A** points into the page.
    The cross product is anti-commutative: **A** × **B** = –**B** × **A**. Note also
    that the cross product of any vector with itself is 0\. The magnitude of the cross
    product gives the area of the parallelogram formed by the two vectors when two
    additional parallel sides are added.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图 10-5](ch10.xhtml#ch10fig5)中的**A**和**B**，向量**A** × **B**指向页面外，而向量**B** ×
    **A**指向页面内。叉积是反交换的：**A** × **B** = –**B** × **A**。还要注意，任何向量与其自身的叉积为 0。叉积的大小给出了由这两个向量所形成的平行四边形的面积，当加入两个额外的平行边时。
- en: 'The cross product distributes over a vector sum:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积对向量和分配：
- en: '**C** × **(A + B)** = **C** × **A** + **C** × **B**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**C** × **(A + B)** = **C** × **A** + **C** × **B**'
- en: In Haskell, if `a` and `b` are vectors, we’ll define `a >< b` to be their cross
    product. (The operator `><` is supposed to look like a cross product.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，如果`a`和`b`是向量，我们将定义`a >< b`为它们的叉积。（操作符`><`的设计应该像叉积运算符。）
- en: NOTE
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are interested in mathematical innovations, the geometric product is
    more sophisticated than the dot and cross products, but it contains the essence
    of both. The book* Geometric Algebra for Physicists [**[8](bib.xhtml#bib8)**]
    *by Chris Doran and Anthony Lasenby is a nice introduction. The book* Space-Time
    Algebra [**[9](bib.xhtml#bib9)**] *by David Hestenes is another great resource.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对数学创新感兴趣，几何积比点积和叉积更为复杂，但它包含了两者的精髓。Chris Doran 和 Anthony Lasenby 所著的书《几何代数物理学入门》[**[8](bib.xhtml#bib8)**]
    是一本很好的入门书。David Hestenes 所著的《时空代数》[**[9](bib.xhtml#bib9)**] 是另一本很棒的参考书。*'
- en: Derivative of a Vector-Valued Function
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量值函数的导数
- en: Suppose **V** is a function that takes one real variable (such as time) as input
    and gives a vector (such as velocity) as output. Because we can subtract vectors,
    and because we can divide a vector by a number, we can define the derivative of
    a vector-valued function of a real number. In Haskell, the type of such a function
    is `R -> Vec`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**V**是一个函数，它接受一个实数变量（如时间）作为输入，并输出一个向量（如速度）。因为我们可以做向量减法，并且可以将向量除以一个数，所以我们可以定义实数值函数的向量导数。在
    Haskell 中，这样的函数类型是`R -> Vec`。
- en: 'The derivative of **V**, denoted *D***V**, **V**’, or ![Image](Images/v-dot.jpg),
    is the function of one variable defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**的导数，记作*D**V**、**V**’或 ![Image](Images/v-dot.jpg)，是一个一元函数，定义如下：'
- en: '![Image](Images/135equ01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/135equ01.jpg)'
- en: Notice that the leftmost minus sign is a subtraction of vectors. We are using
    the same *D* symbol for the derivative of a vector-valued function that we used
    for the derivative of a number-valued function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最左边的减号表示向量的减法。我们使用相同的*D*符号来表示向量值函数的导数，就像我们表示数值函数导数时使用的符号一样。
- en: The vector derivative takes a vector-valued function of one variable (a function
    with type `R -> Vec`) as input and provides a vector-valued function of one variable
    as output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量导数接受一个一元向量值函数（类型为`R -> Vec`）作为输入，并输出一个一元向量值函数。
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The type `(R -> Vec) -> R -> Vec` is the same as the type `(R -> Vec) ->` `(R
    -> Vec)`. Here is a vector derivative in Haskell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`(R -> Vec) -> R -> Vec`与类型`(R -> Vec) ->` `(R -> Vec)`是相同的。下面是 Haskell 中的向量导数：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like the function `derivative` from [Chapter 4](ch04.xhtml), this numerical
    derivative does not take a limit but instead uses a small interval `dt`, supplied
    by the user of the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第 4 章](ch04.xhtml)中的`derivative`函数一样，这个数值导数并不取极限，而是使用一个由函数用户提供的小间隔`dt`。
- en: '[Table 10-1](ch10.xhtml#ch10tab1) shows a comparison of mathematical notation
    with Haskell notation for the vector operations we’ve introduced.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-1](ch10.xhtml#ch10tab1) 显示了我们介绍的向量运算中，数学符号与 Haskell 符号的对比。'
- en: '**Table 10-1:** Comparison of Mathematical Notation with Haskell Notation for
    Vector Operations'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** 数学符号与 Haskell 符号在向量运算中的比较'
- en: '| **Math notation** | **Haskell notation** | **Haskell type** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **数学符号** | **Haskell 符号** | **Haskell 类型** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *t* | `t` | `R` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| *t* | `t` | `R` |'
- en: '| *m* | `m` | `R` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *m* | `m` | `R` |'
- en: '| **A** | `a` | `Vec` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **A** | `a` | `Vec` |'
- en: '| **B** | `b` | `Vec` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **B** | `b` | `Vec` |'
- en: '| **V** | `v` | `R -> Vec` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **V** | `v` | `R -> Vec` |'
- en: '| **V**(*t*) | `v t` | `Vec` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **V**(*t*) | `v t` | `Vec` |'
- en: '| **A** + **B** | `a ^+^ b` | `Vec` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **A** + **B** | `a ^+^ b` | `Vec` |'
- en: '| *m* **A** | `m *^ a` | `Vec` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| *m* **A** | `m *^ a` | `Vec` |'
- en: '| **A** *m* | `a ^* m` | `Vec` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **A** *m* | `a ^* m` | `Vec` |'
- en: '| **A**/*m* | `a ^/ m` | `Vec` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **A**/*m* | `a ^/ m` | `Vec` |'
- en: '| **A** – **B** | `a ^-^ b` | `Vec` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **A** – **B** | `a ^-^ b` | `Vec` |'
- en: '| **A** ⋅ **B** | `a <.> b` | `R` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **A** ⋅ **B** | `a <.> b` | `R` |'
- en: '| **A** × **B** | `a >< b` | `Vec` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **A** × **B** | `a >< b` | `Vec` |'
- en: '| *D***V** | `vecDerivative 0.01 v` | `R -> Vec` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *D***V** | `vecDerivative 0.01 v` | `R -> Vec` |'
- en: '| *D***V**(*t*) | `vecDerivative 0.01 v t` | `Vec` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *D***V**(*t*) | `vecDerivative 0.01 v t` | `Vec` |'
- en: '| ![Image](Images/e0136-01.jpg) | `vecDerivative 0.01 v t` | `Vec` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](Images/e0136-01.jpg) | `vecDerivative 0.01 v t` | `Vec` |'
- en: Let’s move on and see what happens with vectors when we introduce a coordinate
    system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看当引入坐标系统时，向量会发生什么变化。
- en: Coordinate Systems
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坐标系统
- en: We choose a coordinate system by choosing a location and orientation for a set
    of three mutually perpendicular directions. We define **î** to be a vector with
    magnitude 1 that points in the direction of increasing *x*. A vector with magnitude
    1 is also known as a *unit vector*. Vectors augmented with a hat are unit vectors.
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a coordinate system along with coordinate
    unit vectors in each coordinate direction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择一个位置和方向来选择坐标系统，这样可以定义三个互相垂直的方向。我们定义 **î** 为一个大小为 1，指向增加的 *x* 方向的向量。大小为
    1 的向量也被称为 *单位向量*。带帽的向量是单位向量。[图 10-6](ch10.xhtml#ch10fig6) 显示了一个坐标系统，并标出每个坐标方向的坐标单位向量。
- en: '![Image](Images/137fig01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/137fig01.jpg)'
- en: '*Figure 10-6: A right-handed coordinate system. The z-axis is to be imagined
    as coming out of the page.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：一个右手坐标系统。z 轴被想象为从页面中突出。*'
- en: Because ![Image](Images/icap.jpg) has magnitude 1, we know that ![Image](Images/e0137-02.jpg).
    Similarly, we define ![Image](Images/jcap.jpg) to be a unit vector that points
    in the direction of increasing *y*, and we define ![Image](Images/kcap.jpg) to
    be a unit vector that points in the direction of increasing *z*. The reason they
    are called ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg), and ![Image](Images/kcap.jpg)
    goes back to William Rowan Hamilton and his quaternions. (Search for the William
    Rowan Hamilton video by A Capella Science for a wonderful musical biography of
    this mathematical physicist, set to a tune written for a political figure with
    the same last name.) Because ![Image](Images/icap.jpg) and ![Image](Images/jcap.jpg)
    are perpendicular, we know that ![Image](Images/e0137-03.jpg). By similar reasoning,
    we can find the dot products of all the coordinate unit vectors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![图片](Images/icap.jpg) 的大小为 1，我们知道 ![图片](Images/e0137-02.jpg)。类似地，我们定义 ![图片](Images/jcap.jpg)
    为一个单位向量，指向增加的 *y* 方向，我们定义 ![图片](Images/kcap.jpg) 为一个单位向量，指向增加的 *z* 方向。它们之所以被称为
    ![图片](Images/icap.jpg)、![图片](Images/jcap.jpg) 和 ![图片](Images/kcap.jpg)，可以追溯到威廉·罗恩·汉密尔顿（William
    Rowan Hamilton）和他的四元数。（可以查找 A Capella Science 的《William Rowan Hamilton》视频，了解这位数学物理学家的精彩音乐传记，配乐是为同名的政治人物写的。）由于
    ![图片](Images/icap.jpg) 和 ![图片](Images/jcap.jpg) 是垂直的，我们知道 ![图片](Images/e0137-03.jpg)。通过类似的推理，我们可以找到所有坐标单位向量的点积。
- en: '![Image](Images/137equ01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/137equ01.jpg)'
- en: Because the cross product of any vector with itself is 0, we know that ![Image](Images/e0137-04.jpg).
    Because the three directions of our coordinate system are mutually perpendicular,
    we know that ![Image](Images/e0137-05.jpg). To resolve the sign ambiguity, we
    usually agree to use a *right-handed coordinate system*, which means that ![Image](Images/e0137-06.jpg).
    [Figure 10-6](ch10.xhtml#ch10fig6) shows a right-handed coordinate system. By
    similar reasoning, we can find the cross products of all the coordinate unit vectors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何向量与自身的叉积为0，所以我们知道![Image](Images/e0137-04.jpg)。由于坐标系的三个方向是互相垂直的，我们知道![Image](Images/e0137-05.jpg)。为了消除符号歧义，我们通常同意使用*右手坐标系*，这意味着![Image](Images/e0137-06.jpg)。[图10-6](ch10.xhtml#ch10fig6)展示了一个右手坐标系。通过类似的推理，我们可以求出所有坐标单位向量的叉积。
- en: '![Image](Images/138equ01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/138equ01.jpg)'
- en: Once we have a coordinate system and the coordinate unit vectors it gives rise
    to, we can “break a vector into components.” Any vector **A** can be expressed
    as a *linear combination* of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg). A linear combination of vectors means a number
    times the first, plus a number times the second, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个坐标系，并且它所衍生出的坐标单位向量，我们就可以“将一个向量分解为分量”。任何向量**A**都可以表示为![Image](Images/icap.jpg)、![Image](Images/jcap.jpg)和![Image](Images/kcap.jpg)的*线性组合*。向量的线性组合意味着第一个向量乘以一个数，第二个向量乘以另一个数，依此类推。
- en: '![Image](Images/138equ02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/138equ02.jpg)'
- en: We call *A[x]* the *x* component of **A**, and similarly for *y* and *z*. The
    collection of the three numbers *A[x]*, *A[y]*, and *A[z]* is called the *components*
    of **A** with respect to the coordinate system. By dotting the equation above
    by ![Image](Images/icap.jpg), we get an expression for *A[x]* in terms of ![Image](Images/icap.jpg)
    and **A**. We can do the same for *A[y]* and *A[z]*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称* A[x]*为**A**的*x*分量，对*y*和*z*也如此。*A[x]*、*A[y]*和*A[z]*这三个数字的集合被称为**A**相对于坐标系的*分量*。通过对上面的方程进行点积运算，得到一个关于*
    A[x]*的表达式，该表达式涉及![Image](Images/icap.jpg)和**A**。我们可以对*A[y]*和*A[z]*做同样的处理。
- en: '![Image](Images/138equ03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/138equ03.jpg)'
- en: The Haskell code at the end of the chapter defines a default coordinate system
    you can use. The default coordinate system provides coordinate unit vectors `iHat`,
    `jHat`, and `kHat` that play the role of ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg),
    and ![Image](Images/kcap.jpg), respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 章节末的Haskell代码定义了一个默认坐标系，你可以使用它。该默认坐标系提供了坐标单位向量`iHat`、`jHat`和`kHat`，它们分别充当![Image](Images/icap.jpg)、![Image](Images/jcap.jpg)和![Image](Images/kcap.jpg)的角色。
- en: Let’s revisit the vector operations introduced above in a geometric way and
    see how they look with a coordinate system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几何的角度重新审视上面介绍的向量运算，看看它们在坐标系下是什么样子的。
- en: Vector Addition with Coordinate Components
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量加法与坐标分量
- en: The components of a sum are the sums of the components. If **C** = **A** + **B**,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 和分量相加一样，和分量的求和就是各分量的求和。如果**C** = **A** + **B**，
- en: '![Image](Images/138equ04a.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/138equ04a.jpg)'
- en: and similarly for the y- and z-components. If **C** = **A** + **B**, then
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对y分量和z分量也同样适用。如果**C** = **A** + **B**，那么
- en: '![Image](Images/138equ04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/138equ04.jpg)'
- en: In Haskell, this is
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，这是
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can think of the caret on each side of the plus sign as a reminder that
    there is a vector on the left and a vector on the right.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将加号两边的插入符号看作是一个提醒，表示左边是向量，右边也是向量。
- en: Vector Scaling with Coordinate Components
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量的坐标分量缩放
- en: If **C** = *m***A**, then
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**C** = *m* **A**，那么
- en: '![Image](Images/139equ01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/139equ01.jpg)'
- en: and similarly for the y- and z-components. If **C** = *m***A**, then
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对y分量和z分量同样适用。如果**C** = *m* **A**，那么
- en: '![Image](Images/139equ02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/139equ02.jpg)'
- en: To scale a vector, we can use the `*^` operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放一个向量，我们可以使用`*^`操作符。
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the caret goes on the right of the asterisk because the vector is
    on the right. You can multiply a `Vec` on the left by an `R` on the right with
    the `^*` operator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，插入符号位于星号的右边，因为向量位于右侧。你可以使用`^*`操作符将`Vec`左侧的向量与右侧的`R`相乘。
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the vector is on the left, the caret is on the left. Similarly, we can
    divide by an `R` with the `^/` operator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量在左侧，插入符号也在左侧。同样，我们可以使用`^/`操作符除以`R`。
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Vector Subtraction with Coordinate Components
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向量减法与坐标分量
- en: If **C** = **A** – **B**, then
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**C** = **A** – **B**，那么
- en: '![Image](Images/139equ03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/139equ03.jpg)'
- en: and similarly for the *y* and *z* components. If **C** = **A** – **B**, then
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对*y*和*z*分量也同样适用。如果**C** = **A** – **B**，那么
- en: '![Image](Images/139equ04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/139equ04.jpg)'
- en: We say “the components of a difference are the differences of the components.”
    The first use of the word *difference* refers to vector difference, while the
    second use refers to number difference. If `a` and `b` are vectors, then `xComp
    (a ^-^ b)` and `xComp a - xComp b` evaluate to the same number.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说“差的分量是分量的差”。第一次使用“差”一词指的是向量差，而第二次使用则指的是数值差。如果`a`和`b`是向量，那么`xComp (a ^-^ b)`和`xComp
    a - xComp b`会得到相同的数值。
- en: 'Here is an example of vector subtraction:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个向量减法的例子：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dot Product with Coordinate Components
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点积与坐标分量
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the dot product along with Equation 10.2 to simplify the result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**A**和**B**是向量。给定一个坐标系，我们可以使用方程10.4将每个向量表示为分量，然后利用点积的分配律以及方程10.2来简化结果。
- en: '![Image](Images/140equ01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ01.jpg)'
- en: If we know the components of two vectors **A** and **B**, Equation 10.8 gives
    a handy way to find their dot product.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道两个向量**A**和**B**的分量，方程10.8提供了一种方便的方法来求它们的点积。
- en: You can take the dot product of two `Vec`s with the `<.>` operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`<.>`运算符来计算两个`Vec`的点积。
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Cross Product with Coordinate Components
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 叉积与坐标分量
- en: Suppose **A** and **B** are vectors. Given a coordinate system, we can express
    each vector in components using Equation 10.4 and then use the distributive property
    of the cross product along with Equation 10.3 to simplify the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**A**和**B**是向量。给定一个坐标系，我们可以使用方程10.4将每个向量表示为分量，然后利用叉积的分配律和方程10.3来简化结果。
- en: '![Image](Images/140equ02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ02.jpg)'
- en: If we know the components of two vectors **A** and **B**, Equation 10.9 gives
    a good way to find their cross product.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道两个向量**A**和**B**的分量，方程10.9提供了一种很好的方法来求它们的叉积。
- en: You can take the cross product of two `Vec`s with the `><` operator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`><`运算符来计算两个`Vec`的叉积。
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you need the components of a vector, you can get them with the `xComp` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个向量的分量，可以使用`xComp`函数来获取。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are also functions `yComp` and `zComp`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有函数`yComp`和`zComp`。
- en: The unary minus sign (`-`) will not work to negate a vector, but you can negate
    a vector with `negateV`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一元负号(`-`)不能用于取反一个向量，但你可以使用`negateV`来取反一个向量。
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Derivative with Coordinate Components
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 坐标分量的导数
- en: Suppose **V** is a vector-valued function of one real variable. If **W** = *D***V**,
    then
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**V**是一个单一实变量的向量值函数。如果**W** = *D***V**，那么
- en: '![Image](Images/140equ03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/140equ03.jpg)'
- en: and similarly for the y- and z-components. If **W** = *D***V**, then
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对y分量和z分量同样适用。如果**W** = *D***V**，那么
- en: '![Image](Images/141equ01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/141equ01.jpg)'
- en: 'Here is an example of a vector-valued function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个向量值函数的例子：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that we cannot write the x-component of this vector-valued function in
    the most obvious way, namely `xComp v1`. This would produce a type error because
    `xComp` takes a `Vec` as input, not a function `R -> Vec`. What we really mean
    when we talk about the x-component of a vector-valued function is the scalar-valued
    function that takes an input `t`, applies the vector-valued function, and returns
    the x-component. In Haskell, the x-component of a vector-valued function can be
    written as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能以最直观的方式写出这个向量值函数的x分量，即`xComp v1`。这样会产生类型错误，因为`xComp`接受的是`Vec`类型作为输入，而不是一个函数`R
    -> Vec`。我们真正的意思是，当我们讨论一个向量值函数的x分量时，指的是一个标量值函数，它接受一个输入`t`，应用向量值函数并返回x分量。在Haskell中，向量值函数的x分量可以按以下方式写出：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In words, Equation 10.10 says that the x-component of the derivative is the
    same as the derivative of the x-component. In Haskell, the same equations say
    that the x-component of the (vector) derivative
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 用文字表达，方程10.10表示导数的x分量与x分量的导数相同。在Haskell中，相同的方程表示向量导数的x分量。
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'is the same as the (scalar) derivative of the x-component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与（标量）导数的x分量相同：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can check this in GHCi for a particular vector-valued function evaluated
    at a particular value of the independent variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GHCi中检查一个特定的向量值函数在特定自变量值下的计算结果。
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We defined the scalar derivative in [Chapter 4](ch04.xhtml) and repeat it here
    for convenience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.xhtml)中定义了标量导数，这里为了方便再次提及。
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Table 10-2](ch10.xhtml#ch10tab2) shows the types of the vector functions and
    expressions we’ve been working with.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格10-2](ch10.xhtml#ch10tab2)显示了我们正在使用的向量函数和表达式的类型。'
- en: '**Table 10-2:** Expressions and Functions for Working with Vectors'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-2：** 用于操作向量的表达式和函数'
- en: '| **Expression** |  | **Type** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `zeroV` | `::` | `Vec` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `zeroV` | `::` | `Vec` |'
- en: '| `iHat` | `::` | `Vec` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `iHat` | `::` | `Vec` |'
- en: '| `(^+^)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `(^+^)` | `::` | `Vec -> Vec -> Vec` |'
- en: '| `(^-^)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `(^-^)` | `::` | `Vec -> Vec -> Vec` |'
- en: '| `(*^)` | `::` | `R -> Vec -> Vec` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `(*^)` | `::` | `R -> Vec -> Vec` |'
- en: '| `(^*)` | `::` | `Vec -> R -> Vec` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `(^*)` | `::` | `Vec -> R -> Vec` |'
- en: '| `(^/)` | `::` | `Vec -> R -> Vec` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `(^/)` | `::` | `Vec -> R -> Vec` |'
- en: '| `(<.>)` | `::` | `Vec -> Vec -> R` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `(<.>)` | `::` | `Vec -> Vec -> R` |'
- en: '| `(><)` | `::` | `Vec -> Vec -> Vec` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `(><)` | `::` | `Vec -> Vec -> Vec` |'
- en: '| `negateV` | `::` | `Vec -> Vec` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `negateV` | `::` | `Vec -> Vec` |'
- en: '| `magnitude` | `::` | `Vec -> R` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `magnitude` | `::` | `Vec -> R` |'
- en: '| `xComp` | `::` | `Vec -> R` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `xComp` | `::` | `Vec -> R` |'
- en: '| `vec` | `::` | `R -> R -> R -> Vec` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `vec` | `::` | `R -> R -> R -> Vec` |'
- en: '| `sumV` | `::` | `[Vec] -> Vec` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `sumV` | `::` | `[Vec] -> Vec` |'
- en: Now that we’ve seen some of the key properties of vectors in both geometric
    and coordinate settings, let’s take a look at how vectors get used to describe
    kinematics in three dimensions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了向量在几何和坐标设置中的一些关键性质，接下来我们来看看向量如何用于描述三维空间中的运动学。
- en: Kinematics in 3D
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三维运动学
- en: The essential quantities of kinematics are time, position, velocity, and acceleration.
    Time will continue to be a real number, as it was in [Chapter 4](ch04.xhtml).
    Velocity and acceleration we’ll now treat as vectors, using the `Vec` type that
    we’ll define at the end of the chapter. What about position?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学的基本量是时间、位置、速度和加速度。时间将继续作为实数，就像在[第4章](ch04.xhtml)中一样。速度和加速度我们现在将作为向量处理，使用在本章末尾定义的`Vec`类型。那么位置呢？
- en: Position is really not a vector. It doesn’t make sense to add positions, nor
    does it make sense to scale a position by a number. However, subtracting positions
    does make sense, and it produces a displacement vector from one position to the
    other. In [Chapter 22](ch22.xhtml), we’ll create a proper type for position, which
    allows us to use Cartesian, cylindrical, and spherical coordinates to describe
    positions. However, our aims are more modest at the moment and simplicity suggests
    that we use the `Vec` type for position, even though we just gave some reasons
    not to. Displacement is certainly a vector, so we can think of a vector-valued
    position as a displacement from the origin of the default coordinate system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 位置实际上并不是向量。将位置相加是没有意义的，也没有意义通过数值来缩放位置。然而，减去位置是有意义的，这会产生从一个位置到另一个位置的位移向量。在[第22章](ch22.xhtml)中，我们将创建一个适合的类型来表示位置，这将允许我们使用笛卡尔坐标系、圆柱坐标系和球坐标系来描述位置。然而，目前我们的目标更为简朴，简单性表明我们应该使用`Vec`类型来表示位置，尽管我们刚才提到了一些不这样做的理由。位移显然是一个向量，因此我们可以将一个向量值的位置视为从默认坐标系原点的位移。
- en: 'We’ll use the following type synonyms in this chapter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用以下类型同义词：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the type `PosVec` to denote the type of a position when position is being
    represented by a vector. This will keep us from confusing it with the `Position`
    type we’ll define in [Chapter 22](ch22.xhtml), which, again, is not a vector.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类型`PosVec`来表示位置的类型，当位置由向量表示时。这将避免我们将其与[第22章](ch22.xhtml)中定义的`Position`类型混淆，后者不是向量。
- en: Defining Position, Velocity, and Acceleration
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义位置、速度和加速度
- en: For a particular motion of an object, we define **r** to be the function that
    associates with each time *t* the position at which the object is located at time
    *t*. We say that **r**(*t*) is the position of the object at time *t*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物体的特定运动，我们定义**r**为一个函数，它将每个时间点*t*与物体在该时刻的位置相关联。我们说**r**(*t*)是物体在时间*t*的位置信息。
- en: The velocity function for an object is the derivative of its position function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的速度函数是其位置函数的导数。
- en: '![Image](Images/143equ01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/143equ01.jpg)'
- en: Note that Equation 10.11 is an equality of functions, the instantaneous velocity
    function on the left of the equality, and the derivative of the position function
    on the right. Equation 10.11 can be written in Haskell as the function `velFromPos`,
    which takes a small time step and position function to return a velocity function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方程式10.11是一个函数等式，左边是瞬时速度函数，右边是位置函数的导数。方程式10.11可以用Haskell编写为`velFromPos`函数，它接受一个小的时间步长和位置函数，返回一个速度函数。
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the definition, the function `velFromPos` is just the vector
    derivative we defined earlier in the chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义中可以看出，`velFromPos`函数就是我们之前在本章定义的向量导数。
- en: When two functions are equal, they give equal results for equal inputs, so we
    can also write
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个函数相等时，它们在相等的输入下给出相等的结果，所以我们也可以写成
- en: '![Image](Images/143equ02.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/143equ02.jpg)'
- en: for any time *t*. The righthand side is the function *D***r** evaluated at time
    *t*. We can think of the derivative operator as taking the entire position function
    as input and returning the velocity function as output. It’s also common to see
    the notation
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何时间 *t*，右边是函数 *D***r** 在时间 *t* 时的值。我们可以把导数运算符看作是将整个位置函数作为输入，返回速度函数作为输出。也常见使用符号
- en: '![Image](Images/143equ03.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/143equ03.jpg)'
- en: to define velocity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 用来定义速度。
- en: '*Speed* is the magnitude of the velocity vector. *Acceleration* is defined
    to be the rate at which velocity changes. We define **a** to be the function that
    associates with each time *t* the rate at which the velocity is changing at time
    *t*. In the language of calculus, we can write'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度* 是速度向量的大小。*加速度* 被定义为速度变化的速率。我们定义 **a** 为一个函数，它与每个时间 *t* 相关联，表示在时间 *t* 时速度变化的速率。在微积分的语言中，我们可以写作'
- en: '![Image](Images/143equ04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/143equ04.jpg)'
- en: or
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '![Image](Images/143equ05.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/143equ05.jpg)'
- en: to define acceleration. Equation 10.14 can be encoded in a function `accFrom`
    `Vel` that produces an acceleration function from a velocity function. Again,
    this function is just the vector derivative.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义加速度，方程 10.14 可以通过函数 `accFrom` `Vel` 来编码，该函数根据速度函数生成加速度函数。再说一遍，这个函数只是向量的导数。
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the velocity happens to be constant, say **v[0]**, we can integrate both
    sides of Equation 10.11 to obtain
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度恰好是常数，比如 **v[0]**，我们可以对方程 10.11 的两边进行积分，得到
- en: '**v**[0]*t* = **r**(*t*) – *r*(0)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**v**[0]*t* = **r**(*t*) – *r*(0)'
- en: If velocity is constant, position is a linear function of time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度是常数，位置是时间的线性函数。
- en: '**r**(*t*) = **v**[0]*t* + **r**(0)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**r**(*t*) = **v**[0]*t* + **r**(0)'
- en: 'Here is the corresponding Haskell code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的 Haskell 代码：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The CV at the end of the name is an abbreviation for constant velocity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 名称末尾的 CV 是常速（constant velocity）的缩写。
- en: If the acceleration happens to be constant, say **a**[0], we can integrate both
    sides of Equation 10.14 or 10.15 to obtain
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度恰好是常数，比如 **a**[0]，我们可以对方程 10.14 或 10.15 的两边进行积分，得到
- en: '**a**[0]*t* = **v**(*t*) – **v**(0)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**[0]*t* = **v**(*t*) – **v**(0)'
- en: If acceleration is constant, velocity is a linear function of time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度是常数，速度是时间的线性函数。
- en: '![Image](Images/144equ01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/144equ01.jpg)'
- en: 'I like to call Equation 10.16 the *velocity-time equation* for constant acceleration
    because it gives the velocity **v**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0] and initial velocity **v**(0). Here
    is the Haskell code for Equation 10.16:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把方程 10.16 称为 *恒定加速度下的速度-时间方程*，因为它给出了任何时间 *t* 下物体的速度 **v**(*t*)，前提是我们知道恒定加速度
    **a**[0] 和初始速度 **v**(0)。这是方程 10.16 的 Haskell 代码：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The CA at the end of the name is an abbreviation for constant acceleration.
    We can integrate both sides of Equation 10.16 to obtain
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 名称末尾的 CA 是恒定加速度（constant acceleration）的缩写。我们可以对方程 10.16 的两边进行积分，得到
- en: '![Image](Images/144equ02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/144equ02.jpg)'
- en: If acceleration is constant, position is a quadratic function of time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加速度是常数，位置是时间的二次函数。
- en: '![Image](Images/144equ03.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/144equ03.jpg)'
- en: 'I like to call Equation 10.17 the *position-time equation* for constant acceleration
    because it gives the position **r**(*t*) of an object at any time *t*, provided
    we know the constant acceleration **a**[0], initial position **r**(0), and initial
    velocity **v**(0). Here is the Haskell code for Equation 10.17:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把方程 10.17 称为 *恒定加速度下的位置-时间方程*，因为它给出了任何时间 *t* 下物体的位置 **r**(*t*)，前提是我们知道恒定加速度
    **a**[0]、初始位置 **r**(0) 和初始速度 **v**(0)。这是方程 10.17 的 Haskell 代码：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Equations 10.16 and 10.17 are known as *constant acceleration equations*. They
    are used over and over again in a typical introductory physics course. Later we’ll
    learn some techniques to deal with situations in which acceleration is not constant.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 10.16 和 10.17 被称为 *恒定加速度方程*。它们在典型的入门物理课程中反复使用。稍后我们将学习一些应对加速度不恒定情况的技巧。
- en: Having introduced the definitions of velocity and acceleration in the three-dimensional
    vector setting, we can now look at how acceleration is composed of two qualitatively
    different components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维向量空间中引入了速度和加速度的定义后，我们现在可以看看加速度是如何由两个质的不同的分量组成的。
- en: Two Components of Acceleration
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加速度的两个分量
- en: If at any moment the velocity of an object is 0, any acceleration the object
    has serves to give the object some velocity in the direction of the acceleration.
    If, on the other hand, **v**(*t*)≠0, the relative directions of velocity and acceleration
    determine the qualitative motion of the object. In everyday speech, people often
    use the word *acceleration* to mean increase in speed. However, in physics, acceleration
    means change in velocity per unit tine, and velocity can change in either magnitude
    or direction. In physics, acceleration is responsible not only for increases in
    speed but for decreases in speed and changes in direction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体在任何时刻的速度为0，物体所具有的任何加速度都用于赋予物体沿加速度方向的速度。另一方面，如果**v**(*t*)≠0，速度和加速度的相对方向决定了物体的定性运动。在日常语言中，人们常用*加速度*来表示速度的增加。然而，在物理学中，加速度是单位时间内速度的变化，速度可以在大小或方向上发生变化。在物理学中，加速度不仅负责速度的增加，还负责速度的减少和方向的变化。
- en: If **v**(*t*)≠0, we can decompose the acceleration into a component parallel
    to the velocity and a component perpendicular to the velocity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**v**(*t*)≠0，我们可以将加速度分解为与速度平行的分量和与速度垂直的分量。
- en: '![Image](Images/145equ01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/145equ01.jpg)'
- en: Since **v**(*t*)≠0, we can define a unit vector in the direction of the velocity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**v**(*t*)≠0，我们可以定义一个沿速度方向的单位向量。
- en: '![Image](Images/145equ02.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/145equ02.jpg)'
- en: 'The parallel and perpendicular components of acceleration are given by the
    following equations:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度的平行分量和垂直分量由以下方程给出：
- en: '![Image](Images/145equ03.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/145equ03.jpg)'
- en: 'Here are Haskell functions that calculate the parallel and perpendicular components
    of acceleration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是计算加速度平行分量和垂直分量的Haskell函数：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The parallel component **a**[∥](*t*) is also called the *tangential component*
    of acceleration, and it’s responsible for the change in speed of the object. The
    perpendicular component **a**[⊥](*t*) is also called the *radial* or *transverse
    component* of acceleration, and it’s responsible for the change in direction of
    the object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 平行分量**a**[∥](*t*)也称为加速度的*切向分量*，它负责物体速度的变化。垂直分量**a**[⊥](*t*)也称为*径向*或*横向分量*，它负责物体方向的变化。
- en: 'The dot product of velocity and acceleration depends on the angle between them
    and thus contains useful information. Let’s take the time derivative of the square
    of the speed *v*^((*t*)2) = **v**(*t*) ⋅**v**(*t*):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和加速度的点积取决于它们之间的角度，因此包含有用的信息。我们来对速度平方的时间导数* v*^(*t*)^2 = **v**(*t*) ⋅**v**(*t*)进行计算：
- en: '![Image](Images/146equ01.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/146equ01.jpg)'
- en: 'We can see that the dot product of velocity and acceleration controls how the
    speed changes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，速度和加速度的点积控制了速度的变化：
- en: '| **Dot product** | **Effect on speed** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **点积** | **对速度的影响** |'
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **v**(*t*) ⋅**a**(*t*) > 0 | Speed increases |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **v**(*t*) ⋅**a**(*t*) > 0 | 速度增加 |'
- en: '| **v**(*t*) ⋅**a**(*t*) = 0 | Speed remains constant |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **v**(*t*) ⋅**a**(*t*) = 0 | 速度保持恒定 |'
- en: '| **v**(*t*) ⋅**a**(*t*) < 0 | Speed decreases |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **v**(*t*) ⋅**a**(*t*) < 0 | 速度减小 |'
- en: In this chapter, *v* stands for the speed function, which is a different convention
    from [Chapter 4](ch04.xhtml) where *v* was the one-dimensional velocity function.
    One-dimensional velocity can be negative, but speed can’t.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，*v*表示速度函数，这与[第4章](ch04.xhtml)中的不同约定，在第4章中，*v*是一个维度的速度函数。一维速度可以为负，但速度不可以为负。
- en: '[Figure 10-7](ch10.xhtml#ch10fig7) shows how the relative direction of velocity
    and acceleration controls the qualitative behavior of an object’s motion.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-7](ch10.xhtml#ch10fig7)显示了速度和加速度的相对方向如何控制物体运动的定性行为。'
- en: '![Image](Images/146equ02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/146equ02.jpg)'
- en: '*Figure 10-7: The relative directions of velocity and acceleration determine
    the qualitative motion of an object.*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：速度和加速度的相对方向决定了物体的定性运动。*'
- en: When acceleration has a component in the direction of velocity, an object speeds
    up. When acceleration has a component opposite the direction of velocity, an object
    slows down. When acceleration has only a component perpendicular to the velocity,
    an object maintains its speed. No coordinate system is necessary to make these
    conclusions; this aspect of the qualitative behavior of motion is purely geometric.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当加速度在速度方向上有分量时，物体会加速。当加速度在与速度方向相反的方向上有分量时，物体会减速。当加速度只有与速度垂直的分量时，物体保持其速度。为了得出这些结论，不需要使用坐标系统；这种运动定性行为的特点纯粹是几何学的。
- en: 'We’ve seen how the tangential component of acceleration is related to speeding
    up and slowing down. We can make an even stronger statement: the rate of change
    of speed is directly related to the tangential component.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了切向加速度分量与加速和减速之间的关系。我们可以做出更强的陈述：速度变化率与切向分量直接相关。
- en: '![Image](Images/147equ01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/147equ01.jpg)'
- en: Here is the rate of change of speed as a Haskell function. Given the velocity
    and acceleration of an object, this function returns the rate at which speed is
    increasing, with a negative result meaning that speed is decreasing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Haskell函数，用于表示速度变化率。给定物体的速度和加速度，该函数返回速度变化的速率，负值表示速度在减小。
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The magnitude of the tangential component of acceleration equals the magnitude
    of the rate of change in speed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 切向加速度分量的大小等于速度变化率的大小。
- en: '![Image](Images/147equ02.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/147equ02.jpg)'
- en: If there is a transverse component of acceleration, it causes the object to
    turn (in other words, to change direction). We can calculate a radius of curvature
    for this turning motion. [Figure 10-8](ch10.xhtml#ch10fig8) shows the trajectory
    of a particle with speed *v*(*t*) and transverse acceleration *a*[⊥](*t*). Over
    a small interval of time *Δt*, the particle will move forward a distance *v*(*t*)Δ*t*
    and in a perpendicular direction a distance *a*[⊥](*t*)Δ^(*t*2)/2.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在横向加速度分量，它会导致物体发生转向（换句话说，改变方向）。我们可以计算这个转向运动的曲率半径。[图 10-8](ch10.xhtml#ch10fig8)展示了一个具有速度*v*（*t*）和横向加速度*a*[⊥]（*t*）的粒子轨迹。在一个小的时间间隔*Δt*内，粒子会沿前进方向移动*v*（*t*）Δ*t*的距离，并在垂直方向上移动*a*[⊥]（*t*）Δ^(*t*²)/2的距离。
- en: '![Image](Images/147fig01.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/147fig01.jpg)'
- en: '*Figure 10-8: Determination of a radius of curvature from transverse acceleration*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：从横向加速度确定曲率半径*'
- en: '[Figure 10-8](ch10.xhtml#ch10fig8) gives a way to find an expression for the
    radius of curvature in terms of the speed and the transverse acceleration. Here
    we write down the Pythagorean theorem for the right triangle in the figure:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-8](ch10.xhtml#ch10fig8)提供了一种方法，用于根据速度和横向加速度找到曲率半径的表达式。这里我们写出图中直角三角形的勾股定理：'
- en: '![Image](Images/148equ01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/148equ01.jpg)'
- en: 'Expanding this equation and taking the limit as Δ*t* → 0, which discards the
    term proportional to Δ*t*⁴, we arrive at the following equation for the radius
    of curvature:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 展开此方程并在Δ*t* → 0时求极限，舍去与Δ*t*⁴成正比的项，我们得到以下曲率半径的方程：
- en: '![Image](Images/148equ02.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/148equ02.jpg)'
- en: 'Here is a Haskell function that computes the (instantaneous) radius of curvature
    of an object’s motion from the object’s velocity and acceleration:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Haskell函数，它根据物体的速度和加速度计算物体运动的（瞬时）曲率半径：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we wish, we can invert Equation 10.22 to give an expression for the transverse
    acceleration in terms of the radius of curvature *R*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以反转方程式10.22，从而得到一个以曲率半径*R*为变量的横向加速度表达式。
- en: '![Image](Images/148equ03.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/148equ03.jpg)'
- en: As we see from Equations 10.21 and 10.23, the tangential component of acceleration
    controls the change in speed, and the radial component of acceleration controls
    the change in direction.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如从方程式10.21和10.23中看到的，切向加速度分量控制速度变化，而径向加速度分量控制方向变化。
- en: Projectile Motion
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抛体运动
- en: One of the very first uses to which vectors are typically put in physics is
    the study of projectile motion. A projectile is any object thrown, launched, or
    shot near the surface of the earth. The problem is to predict its motion *after*
    the throwing, launching, or shooting force is gone; in fact, rather than speak
    of the launching force, we instead assume that the action of launching simply
    gives the projectile some initial velocity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，向量的最初用途之一通常是研究抛体运动。抛体是指任何被抛出、发射或射出的物体，且这些物体通常接近地球表面。问题在于预测物体在投掷、发射或射击力消失后的运动；事实上，我们不再谈论发射力，而是假设发射过程仅仅赋予抛体某个初始速度。
- en: 'It is the presence of Earth’s gravity that makes projectile motion interesting.
    Physics offers four theories of gravity, three of which we will discuss in this
    book:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正是地球的重力使得抛体运动变得有趣。物理学提供了四种重力理论，其中三种我们将在本书中讨论：
- en: Gravity causes objects near Earth’s surface to accelerate. An object near Earth’s
    surface that is allowed to move or fall freely will accelerate toward the center
    of the earth at a rate of about 9.81 m/s².
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重力使得靠近地球表面的物体发生加速。一个在地球表面附近被允许自由移动或下落的物体，会以大约9.81 m/s²的速率加速朝地球中心方向运动。
- en: Gravity is a force produced by the earth on objects near its surface. We engage
    with this view of gravity in [Chapters 15](ch15.xhtml) and [16](ch16.xhtml) after
    we’ve started mechanics and discussed the ideas of force, mass, and Newton’s second
    law. The Haskell function `earthSurfaceGravity` in [Chapter 16](ch16.xhtml) describes
    this force of gravity.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重力是地球对其表面附近物体产生的一种力。在我们开始学习力学并讨论力、质量和牛顿第二定律的概念后，我们将在[第15章](ch15.xhtml)和[第16章](ch16.xhtml)中探讨这一重力观念。[第16章](ch16.xhtml)中的
    Haskell 函数 `earthSurfaceGravity` 描述了这种重力。
- en: Gravity is a force between any two objects with mass. This is called Newton’s
    law of universal gravitation. We discuss it in [Chapters 16](ch16.xhtml) and [19](ch19.xhtml)
    and describe it with the Haskell function `universalGravity` after we have introduced
    Newton’s third law.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重力是任何两个有质量的物体之间的力。这就是牛顿的万有引力定律。我们将在[第16章](ch16.xhtml)和[第19章](ch19.xhtml)中讨论它，并通过
    Haskell 函数 `universalGravity` 来描述它，前提是我们已经介绍了牛顿的第三定律。
- en: Gravity is the curvature of spacetime. This is Einstein’s general theory of
    relativity. We will not get to it in this book. The book `Gravitation` [**[10](bib.xhtml#bib10)**]
    by Charles Misner, Kip Thorne, and John Wheeler is an excellent introduction to
    general relativity. *Functional Differential Geometry* [**[11](bib.xhtml#bib11)**]
    by Gerald Sussman and Jack Wisdom looks at general relativity from a computational
    point of view, describing it with the functional programming language Scheme.
    Other introductions to general relativity by Rindler [**[12](bib.xhtml#bib12)**],
    Carroll [**[13](bib.xhtml#bib13)**], and Schutz [**[14](bib.xhtml#bib14)**] are
    also recommended.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重力是时空的弯曲。这是爱因斯坦的广义相对论。我们在本书中不会深入讨论这一点。由 Charles Misner、Kip Thorne 和 John Wheeler
    合著的《引力》[**[10](bib.xhtml#bib10)**] 是广义相对论的优秀入门书籍。Gerald Sussman 和 Jack Wisdom
    的《功能微分几何》[**[11](bib.xhtml#bib11)**] 从计算角度探讨广义相对论，并用函数式编程语言 Scheme 描述它。Rindler
    [**[12](bib.xhtml#bib12)**]、Carroll [**[13](bib.xhtml#bib13)**] 和 Schutz [**[14](bib.xhtml#bib14)**]
    等人对广义相对论的其他介绍也是值得推荐的。
- en: Each theory in this list is more sophisticated than the previous theory. In
    that sense, the later theories are “more correct” than the earlier ones, although
    the earlier ones are often more useful since they are simpler and easier to apply.
    General relativity, in particular, while beautiful and accurate, is rather nontrivial
    to apply and to calculate with.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的每一个理论都比前一个理论更为复杂。从这个意义上讲，后来的理论比早期的“更为正确”，尽管早期的理论通常更有用，因为它们更简单，更容易应用。尤其是广义相对论，虽然优美且准确，但应用和计算起来相当复杂。
- en: Some physicists may not agree that the first two theories on my list deserve
    to be called theories, arguing that they are instead approximations to Newton’s
    law of universal gravitation applicable to simple situations. It is not my concern
    to argue whether the first two deserve to be called theories; the important point
    is that they are different ways to incorporate gravity into our calculations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物理学家可能不同意将我列出的前两个理论称为“理论”，他们认为它们只是牛顿万有引力定律在简单情况下的近似。至于是否该将前两个称为“理论”，并不是我关注的问题；重要的是，它们是将重力纳入我们计算中的不同方式。
- en: The simplest way to approach projectile motion, and the one we’ll follow in
    this chapter, is based on theory 1\. We assume the projectile accelerates only
    because of Earth’s gravitational attraction; therefore, the projectile’s acceleration
    is given by the acceleration of gravity, **g**, which is a vector pointing toward
    the center of the earth with magnitude 9.81 m/s².
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 处理抛射物运动的最简单方法，也是我们在本章中采用的方法，是基于理论 1。我们假设抛射物仅因地球的引力而加速；因此，抛射物的加速度由重力加速度 **g**
    给出，它是一个指向地球中心的矢量，大小为 9.81 m/s²。
- en: Because the acceleration of gravity is constant, we can use the position-time
    equation, Equation 10.17, to give an expression for position as a function of
    time for a projectile.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重力加速度是恒定的，我们可以使用位置-时间方程式，即方程 10.17，来表示一个抛射物的位置与时间的关系。
- en: '![Image](Images/149equ01.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/149equ01.jpg)'
- en: 'If the z-direction is up and we use SI units, the following function returns
    position as a function of time, where `r0` is the initial position of the projectile
    and `v0` is the initial velocity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 z 轴指向上方，并且我们使用国际单位制，以下函数将返回位置与时间的关系，其中 `r0` 是抛射物的初始位置，`v0` 是初始速度：
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Exercise 10.5, you are asked to write a function `projectileVel` that returns
    the velocity of a projectile as a function of time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习 10.5 中，你需要编写一个函数 `projectileVel`，该函数返回抛射物的速度与时间的关系。
- en: Projectile motion with air resistance requires theory 2 because we view air
    resistance and gravity on an equal footing by seeing them both as forces. To the
    extent that projectile motion occurs near Earth’s surface, it rarely requires
    theories 3 or 4, which would produce only the slightest difference in results
    for a substantial increase in computation complexity. Theory 3 will have other
    uses, like satellite motion, that we’ll see in later chapters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有空气阻力的抛体运动需要理论2，因为我们将空气阻力和重力视为平等的两种力。抛体运动发生在地球表面附近时，通常不需要理论3或4，这样做只会在大幅增加计算复杂度的情况下，产生微小的结果差异。理论3将在后面的章节中应用于其他用途，如卫星运动。
- en: Having seen projectile motion as one early application of vectors, let’s turn
    to the project of creating the vector data type we have been using.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到抛体运动作为向量早期应用的例子之后，让我们来探讨一下我们一直在使用的向量数据类型的创建。
- en: Making Your Own Data Type
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你自己的数据类型
- en: Haskell has a sophisticated and flexible type system. One of the language features
    that makes the type system so powerful is the ability to create your own types.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell拥有一个复杂而灵活的类型系统。使得该类型系统如此强大的语言特性之一，就是能够创建你自己的类型。
- en: In discussing pattern matching in [Chapters 3](ch03.xhtml) and [5](ch05.xhtml),
    we noted that each type has one or more data constructors to construct values
    of that type. In making our own data type, we must provide one or more brand new
    data constructors as ways of constructing values of our new data type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论[第3章](ch03.xhtml)和[第5章](ch05.xhtml)中的模式匹配时，我们提到每个类型都有一个或多个数据构造器，用于构造该类型的值。在创建我们自己的数据类型时，我们必须提供一个或多个全新的数据构造器，作为构造我们新数据类型的值的方式。
- en: We’ll first look at making a new data type with a single data constructor before
    turning to making a new data type with multiple data constructors.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先会看如何通过一个单一数据构造器来创建一个新的数据类型，然后再讲解如何使用多个数据构造器来创建新数据类型。
- en: Single Data Constructor
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单一数据构造器
- en: In [Chapter 4](ch04.xhtml), we used the `type` keyword to make type synonyms.
    In a type synonym, such as
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)中，我们使用了`type`关键字来创建类型同义词。在类型同义词中，例如
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the compiler regards the types `R` and `Double` as interchangeable. In [Chapter
    4](ch04.xhtml), the types `Time`, `Velocity`, `R`, and `Double` were all interchangeable.
    This was convenient, but it does not empower the Haskell type checker to help
    the code writer avoid confusing a `Time` with a `Velocity` or using a `Velocity`
    where a `Time` was expected.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将类型`R`和`Double`视为可互换。在[第4章](ch04.xhtml)中，类型`Time`、`Velocity`、`R`和`Double`都是可互换的。这虽然很方便，但却没有让Haskell类型检查器帮助代码编写者避免将`Time`与`Velocity`混淆，或者在需要`Time`的地方使用`Velocity`。
- en: We use the `data` keyword to define new types that are not interchangeable with
    any existing types. Time and mass are each described by a real number in physics,
    but we should never provide a mass in an equation that calls for a time. Let’s
    define a new data type `Mass` that holds a real number but cannot be confused
    with `R` or any other existing data type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`data`关键字来定义新的类型，这些类型与任何现有类型不可互换。时间和质量在物理学中都由实数描述，但我们绝不应该在需要时间的方程中提供质量。让我们定义一个新的数据类型`Mass`，它包含一个实数，但不能与`R`或任何其他现有数据类型混淆。
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use the `data` keyword to define a new data type. We give the name of the
    new data type, `Mass` in this case, after the `data` keyword, followed by an equal
    sign. To the right of the equal sign we give a data constructor, `Mass` in this
    case, followed by the information our new data type contains, in this case `R`.
    The name of the new data type and the name of the data constructor can be the
    same or different. In this case, they have the same name, but they are different
    things. In defining data types with a single constructor, it’s common to use the
    same name for the data constructor that we use for the type, but it’s not necessary.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`data`关键字来定义一个新的数据类型。在`data`关键字后，我们给出新数据类型的名称，在这个例子中是`Mass`，接着是一个等号。在等号右侧，我们给出一个数据构造器，在这个例子中是`Mass`，然后是我们新数据类型包含的信息，这里是`R`。新数据类型的名称和数据构造器的名称可以相同也可以不同。在这个例子中，它们名称相同，但代表的事物不同。在定义单一构造器的数据类型时，通常会使用与类型相同的名称作为数据构造器的名称，但这并不是必须的。
- en: By default, a new data type is not an instance of any type classes. Since it’s
    common to want a new data type to be an instance of some of the standard type
    classes, such as `Eq` and `Show`, Haskell provides a `deriving` keyword that attempts
    to make the new type an instance of the type classes listed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个新数据类型不是任何类型类的实例。由于通常希望新数据类型成为一些标准类型类的实例，如`Eq`和`Show`，Haskell提供了一个`deriving`关键字，尝试使新类型成为列出类型类的实例。
- en: To construct a value with type `Mass`, we use the data constructor `Mass`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个类型为`Mass`的值，我们使用数据构造器`Mass`。
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we ask for the type of this value, GHCi will tell us the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求这个值的类型，GHCi将告诉我们以下内容：
- en: '[PRE31]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In GHCi’s response, the `Mass` on the left of the double colon is the data constructor,
    and the `Mass` on the right of the double colon is the data type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在GHCi的响应中，双冒号左边的`Mass`是数据构造器，双冒号右边的`Mass`是数据类型。
- en: The data constructor itself has a function type. It takes an `R` as input and
    returns a `Mass` as output.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 数据构造器本身具有函数类型。它接受一个`R`作为输入，并返回一个`Mass`作为输出。
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are asking GHCi for the type of the data constructor, not the type of the
    type, which wouldn’t make any sense. Again, the `Mass` on the left of the double
    colon is the data constructor, and the `Mass` on the right of the double colon
    is the data type.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求的是数据构造器的类型，而不是类型的类型，这没有任何意义。同样，双冒号左边的`Mass`是数据构造器，双冒号右边的`Mass`是数据类型。
- en: If we now accidentally supply a `Mass` in a place where an `R` is called for,
    the type checker will give us a type error, helping us to identify our mistake
    rather than silently doing the wrong thing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在不小心在需要`R`的地方提供了一个`Mass`，类型检查器将给我们一个类型错误，帮助我们识别错误，而不是默默地执行错误的操作。
- en: We can provide more than a single piece of information under the data constructor.
    In [Chapter 9](ch09.xhtml) we used a list of pairs to hold grade information.
    Let’s define a new data type called `Grade` that holds a `String` and an `Int`,
    representing the name of a person and their grade on some assignment.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在数据构造器下提供多个信息。在[第9章](ch09.xhtml)中，我们使用了一个由对组成的列表来保存成绩信息。让我们定义一个新的数据类型`Grade`，它包含一个`String`和一个`Int`，表示一个人的名字和他们在某项任务上的成绩。
- en: '[PRE33]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We give the data constructor the same name as the type and simply list the types
    of information that are to be contained in the new data type.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给数据构造器取与类型相同的名字，并简单列出新数据类型中将包含的信息类型。
- en: 'Here is a list of grades for a few people:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是几个人的成绩列表：
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To construct a value of type `Grade`, we use the data constructor `Grade`, followed
    by a `String` and an `Int`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个类型为`Grade`的值，我们使用数据构造器`Grade`，后跟一个`String`和一个`Int`。
- en: If we look at the type of the data constructor `Grade`,
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看数据构造器`Grade`的类型，
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: we see that it takes a `String` and an `Int` as input and returns a `Grade`
    as output. As before, the `Grade` on the left of the double colon is the data
    constructor, and the `Grade` on the right of the double colon is the data type.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它接受一个`String`和一个`Int`作为输入，并返回一个`Grade`作为输出。像之前一样，双冒号左边的`Grade`是数据构造器，双冒号右边的`Grade`是数据类型。
- en: There is an alternative syntax for defining a new data type, called *record
    syntax*, that gives names to each of the pieces of data under a constructor. Let’s
    define a new data type called `GradeRecord` that is essentially the same as the
    type `Grade` but uses record syntax for its definition.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新数据类型还有一种替代语法，叫做*记录语法*，它为构造器下的每个数据项命名。让我们定义一个新的数据类型`GradeRecord`，它本质上与`Grade`类型相同，但使用记录语法进行定义。
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To use record syntax, we enclose the names and types of each piece of information
    in curly braces after the data constructor. Use of record syntax automatically
    creates a new function for each named piece of information.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用记录语法，我们在数据构造器后用大括号括起每个信息的名称和类型。使用记录语法会自动为每个命名的信息创建一个新函数。
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function `name` takes a `GradeRecord` as input and returns the `String`
    that holds the name in that `GradeRecord`. The function `grade` takes a `GradeRecord`
    as input and returns the `Int` that holds the grade in that `GradeRecord`. By
    default, the names `name` and `grade` are placed in the global namespace so they
    may not be reused as names for fields in another data type. This default behavior
    is simple but too constraining in some situations, so the language option `DuplicateRecordFields`
    is available to override this default behavior, although we will not explore it
    in this book.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`name`接受一个`GradeRecord`作为输入，并返回`GradeRecord`中保存的`String`类型的名字。函数`grade`接受一个`GradeRecord`作为输入，并返回`GradeRecord`中保存的`Int`类型的成绩。默认情况下，`name`和`grade`这两个名称会被放入全局命名空间，因此不能在另一个数据类型中重复使用作为字段名。这种默认行为虽然简单，但在某些情况下过于限制，因此可以通过语言选项`DuplicateRecordFields`来覆盖这个默认行为，尽管我们在本书中不会探讨这个选项。
- en: If we use record syntax to define our new data type, there are two ways to construct
    a value of that type. First, we can use the same syntax we used for the type `Grade`
    above, simply giving the data constructor followed by a `String` and an `Int`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用记录语法来定义我们的新数据类型，那么有两种方式可以构造该类型的值。首先，我们可以使用和上面定义`Grade`类型时相同的语法，简单地给出数据构造器，然后跟上一个`String`和一个`Int`。
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Second, we can use record syntax to construct a value of type `GradeRecord`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以使用记录语法来构造`GradeRecord`类型的值。
- en: '[PRE39]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we use curly braces and give the pieces of information by name rather than
    by position.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用大括号，并按名称而不是按位置给出数据项。
- en: The decision on whether to use record syntax should be based on the usefulness
    of having names to describe the pieces of data that the new type holds. If you
    don’t need the names, you should use the basic syntax. If the names seem useful,
    record syntax is a good choice.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用记录语法的决定应该基于为新类型中的数据元素提供名称的实用性。如果不需要名称，应该使用基本语法。如果名称看起来很有用，那么使用记录语法是一个不错的选择。
- en: We’ve seen how to define a new data type with a single data constructor. Now
    let’s look at data types with more than one data constructor.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用单个数据构造器定义新数据类型。现在让我们来看看包含多个数据构造器的数据类型。
- en: Multiple Data Constructors
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个数据构造器
- en: The Prelude type `Bool` has two data constructors, `False` and `True`, as we
    saw when we did pattern matching on `Bool`. Neither of the data constructors contains
    any information beyond the name of the constructor itself.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude类型`Bool`有两个数据构造器，`False`和`True`，正如我们在对`Bool`进行模式匹配时看到的。没有任何数据构造器包含除构造器本身名称以外的其他信息。
- en: Let’s define a new data type called `MyBool` that works the same way `Bool`
    does. We need a fresh name because `Bool` is already defined in the Prelude.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个新的数据类型，叫做`MyBool`，它的工作方式和`Bool`相同。我们需要一个新的名字，因为`Bool`已经在Prelude中定义过了。
- en: '[PRE40]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We begin with the `data` keyword as before, followed by the name `MyBool` of
    our new data type. On the right of the equal sign, we give the first data constructor,
    which we call `MyFalse`, then a vertical bar, and then the second data constructor
    `MyTrue`. We need fresh names for the data constructors because the names `False`
    and `True` are already taken.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像以前一样从`data`关键字开始，接着是我们新数据类型的名称`MyBool`。在等号的右边，我们给出第一个数据构造器，称为`MyFalse`，然后是竖线，再接着是第二个数据构造器`MyTrue`。我们需要为数据构造器取新的名字，因为`False`和`True`已经被占用了。
- en: The vertical bar in the definition can be read as “or,” in the sense that a
    value of type `MyBool` is either `MyFalse` or `MyTrue`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的竖线可以理解为“或者”，也就是说，`MyBool`类型的值要么是`MyFalse`，要么是`MyTrue`。
- en: Having defined the new data type `MyBool`, we can ask about the type of `MyFalse`,
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了新的数据类型`MyBool`后，我们可以查询`MyFalse`的类型。
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: and we are not surprised to find that it has type `MyBool`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不感到惊讶，发现它的类型是`MyBool`。
- en: When we have multiple data constructors, they usually have different names from
    the data type itself.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个数据构造器时，它们通常与数据类型本身有不同的名称。
- en: Let’s define our own version of `Maybe`, called `MyMaybe`. Recall from [Chapter
    9](ch09.xhtml) that `Maybe` is a type constructor, which means that it takes a
    type as input to produce a new type.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们自己的`Maybe`版本，叫做`MyMaybe`。回顾[第9章](ch09.xhtml)，`Maybe`是一个类型构造器，意味着它接受一个类型作为输入，以生成一个新类型。
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The type variable `a` stands for any type. The fact that we are using a type
    variable after `MyMaybe` in this data type definition makes `MyMaybe` a type constructor
    rather than a type. Here we have two data constructors, but unlike for the type
    `MyBool`, the data constructor `MyJust` contains some information, namely a value
    of type `a`. A value of type `MyMaybe a` is either `MyNothing` or `MyJust x` for
    some `x :: a`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '类型变量`a`代表任何类型。我们在这个数据类型定义中使用类型变量`a`后缀的`MyMaybe`使得`MyMaybe`成为一个类型构造器，而不是一个类型。这里我们有两个数据构造函数，但与`MyBool`类型不同的是，数据构造函数`MyJust`包含了一些信息，即一个`a`类型的值。`MyMaybe
    a`类型的值要么是`MyNothing`，要么是`MyJust x`，其中`x :: a`。'
- en: Let’s look at the types of the data constructors.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下数据构造函数的类型。
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For comparison, we can look at the types of the Prelude data constructors for
    `Maybe`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，我们可以查看`Maybe`类型的Prelude数据构造函数的类型。
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We see that `Nothing` is not even a function but just a value of type `Maybe
    a`. On the other hand, `Just` is a function that takes a value of type `a` and
    returns a value of type `Maybe a`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Nothing`甚至不是一个函数，它只是`Maybe a`类型的一个值。另一方面，`Just`是一个函数，它接受一个`a`类型的值并返回一个`Maybe
    a`类型的值。
- en: 'In [Chapter 19](ch19.xhtml), when we’re talking about systems of particles,
    we’ll define a new data type called `Force` that has two constructors: one for
    an external force and one for an internal force.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19章](ch19.xhtml)中，当我们讨论粒子系统时，我们将定义一个名为`Force`的新数据类型，它有两个构造函数：一个用于外力，一个用于内力。
- en: Now that we’ve talked about how to define a new data type, let’s move on to
    define the `Vec` type we’ve been using in this chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何定义新的数据类型，现在让我们继续定义我们在本章中使用的`Vec`类型。
- en: Defining a New Data Type for 3D Vectors
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为三维向量定义一个新的数据类型
- en: Haskell does not come with a built-in type for vectors, so we have to define
    it ourselves. In the beginning of this chapter, we looked at how vectors are defined
    and used in physics. With this knowledge, we’ll turn to the question of how to
    implement three-dimensional vectors in Haskell. The new type must hold three real
    numbers, for the three components of a vector in some coordinate system, or something
    equivalent. We have several options.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell并没有内建向量类型，因此我们必须自己定义它。在本章的开始，我们看到了物理中如何定义和使用向量。凭借这些知识，我们将讨论如何在Haskell中实现三维向量。这个新类型必须存储三个实数，用于表示某坐标系中向量的三个分量，或者等效的东西。我们有几个选择。
- en: Possible Implementations
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可能的实现方式
- en: Let’s consider some possible implementations for the type `Vec` before making
    a final choice.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出最终选择之前，让我们考虑一下`Vec`类型的几种可能实现。
- en: 'Option 1: Use a List'
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项 1：使用列表
- en: 'We could use a list of real numbers to hold the three components of a vector.
    A type synonym for this definition would look like the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个实数列表来存储向量的三个分量。这个定义的类型同义词如下所示：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This type of vector can hold all possible triples of real numbers. The trouble
    with this definition is that the type can also hold lists of real numbers that
    don’t have a length of three. This potential type doesn’t match our requirements
    as nicely as we would like; it’s a little too big, given that the empty list or
    a list of two real numbers would satisfy the type checker as a legitimate value
    of this type.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的向量可以存储所有可能的实数三元组。这个定义的问题在于，它的类型也可以存储不是三个元素的实数列表。这个潜在的类型与我们的需求不完全匹配，它有点太大，因为空列表或包含两个实数的列表会被类型检查器视为该类型的合法值。
- en: 'Option 2: Use a Tuple'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项 2：使用元组
- en: 'A better option would be to choose a triple of real numbers. A type synonym
    would look like the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是选择一个实数的三元组。类型同义词如下所示：
- en: '[PRE46]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a better match for our requirements because this type guarantees that
    there must be three components. The only downside to this option is the possible
    confusion of a triple representing the three components of a vector with a triple
    representing three other numbers, such as the spherical coordinates of a position.
    Since option 2 uses a type synonym, the type checker could not help us catch an
    accidental use of our new vector type in a place where some other triple of real
    numbers is called for.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项更符合我们的需求，因为这个类型保证必须有三个组件。这个选项唯一的缺点是，三元组可能会引起混淆——它代表的是向量的三个分量，而不是代表其他三个数字的三元组，比如位置的球面坐标。由于选项
    2 使用了类型同义词，类型检查器无法帮助我们捕捉到在需要其他三个实数的地方错误使用了我们新的向量类型。
- en: 'Option 3: Make a New Data Type'
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选项 3：创建一个新数据类型
- en: A third option is to define a new data type for `Vec` that cannot be confused
    with any other data type, even if the other data type is essentially a collection
    of three real numbers like `Vec`. We want a fundamental concept in physics, like
    the three-dimensional vector, to be reflected in the type system so the type system
    can help us keep things straight in a way that respects how we think about the
    subject. This is the option we’ll pursue next.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择是为`Vec`定义一个新的数据类型，该类型与任何其他数据类型不会混淆，即使其他数据类型本质上是由三个实数组成的，像`Vec`一样。我们希望像三维向量这样的物理基本概念能在类型系统中得到体现，这样类型系统就能帮助我们保持事物的清晰，尊重我们对学科的理解。这是我们接下来要追求的选项。
- en: Data Type Definition for Vec
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Vec`的数据类型定义'
- en: 'Here is our data type definition:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的数据类型定义：
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We decide to use the same name `Vec` for the data constructor we used for the
    type. We use record syntax because that automatically produces functions `xComp`,
    `yComp`, and `zComp` for the three components of a vector. We ask the compiler,
    through the `deriving` keyword, to create an instance of `Eq` for the new `Vec`
    data type. However, we do not ask for an automatic instance of `Show` because
    we want to define that manually.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用相同的名称`Vec`作为我们为该类型使用的数据构造器。我们使用记录语法，因为这会自动为向量的三个分量生成函数`xComp`、`yComp`和`zComp`。我们通过`deriving`关键字请求编译器为新的`Vec`数据类型创建一个`Eq`实例。然而，我们并没有请求自动生成`Show`实例，因为我们希望手动定义它。
- en: Next, we’ll show how to make the type `Vec` an instance of type class `Show`.
    The general way to make a type an instance of a type class is with the `instance`
    keyword.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何将类型`Vec`变成类型类`Show`的实例。使类型成为类型类实例的一般方法是使用`instance`关键字。
- en: '[PRE48]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After the `instance` keyword, we give the type class, then the type to be an
    instance of that type class, and then the keyword `where`, before giving definitions
    for the functions owned by the type class.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在`instance`关键字后，我们给出类型类，接着是要成为该类型类实例的类型，然后是`where`关键字，再给出类型类拥有的函数的定义。
- en: Starting on the second line, we define the functions owned by the type class,
    and we say how they are supposed to work for the specific case of the type in
    question, `Vec` in this case. The only function that needs to be defined in an
    instance of `Show` is the function `show`, which describes how to turn a `Vec`
    into a `String` so it can be shown.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二行开始，我们定义了类型类拥有的函数，并说明它们在特定类型（在本例中是`Vec`）的情况下应该如何工作。在`Show`的实例中，唯一需要定义的函数是`show`，它描述了如何将`Vec`转换为`String`以便显示。
- en: Our way of showing a vector begins with the string `"vec "`, followed by each
    of the three components in turn. The function `showDouble` does the work of turning
    each real number into a string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显示一个向量的方式是从字符串`"vec "`开始，接着依次显示三个分量。函数`showDouble`负责将每个实数转换为字符串。
- en: The definition of the `show` function inside the instance definition must be
    indented with respect to the `instance` keyword. Any other functions that get
    defined inside the instance definition must be indented by the same amount.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例定义中，`show`函数的定义必须相对于`instance`关键字缩进。任何在实例定义中定义的其他函数也必须进行相同程度的缩进。
- en: There are actually two other functions owned by type class `Show`, called `showsPrec`
    and `showList`, but these will get default definitions if we don’t define them,
    which we didn’t earlier. Using `:i Show` in GHCi gives a list of the functions
    owned by type class `Show`, along with which functions *must* be defined in an
    instance definition.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，类型类`Show`还有两个其他函数，分别是`showsPrec`和`showList`，但如果我们不定义它们，它们会自动获得默认定义，正如我们之前所做的那样。在GHCi中使用`:i
    Show`可以列出类型类`Show`拥有的函数，以及哪些函数*必须*在实例定义中定义。
- en: 'Here is the function `showDouble`, used earlier in the function `show`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前在函数`show`中使用的函数`showDouble`：
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The type `Double` is already an instance of `Show`, as noted in [Chapter 8](ch08.xhtml),
    so the function `show` is already available to turn a `Double` into a `String`.
    Our function `showDouble` uses the function `show` and simply encloses negative
    numbers in parentheses. The reason for enclosing negative components in parentheses
    is so the way a `Vec` gets shown is a legitimate expression for the `Vec`, meaning
    it can be used as input wherever a `Vec` is called for. To carry out this plan
    for having an expression like `vec 3.1 (-4.2) 5.0` accepted as a legitimate value
    of type `Vec`, we need a `vec` function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`Double`已经是`Show`的一个实例，如[第 8 章](ch08.xhtml)所述，因此`show`函数已经可以将`Double`转换为`String`。我们的`showDouble`函数使用`show`函数，并简单地将负数用括号括起来。将负数成分括在括号中的原因是，这样显示出来的`Vec`的形式是一个合法的表达式，意味着它可以在需要`Vec`的地方作为输入。为了实现像`vec
    3.1 (-4.2) 5.0`这样的表达式被接受为`Vec`类型的合法值，我们需要一个`vec`函数。
- en: '[PRE50]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `vec` function does the same thing that the data constructor `Vec` does.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`vec`函数和数据构造函数`Vec`做的事情是一样的。
- en: Why not just use the data constructor `Vec` to form and show our vectors, thus
    eliminating the need to define a `Show` instance for `Vec` and define the function
    `vec`? This is indeed a possibility, and not a bad one. The main reason I did
    not do it is that I wanted to use record syntax, and the automatically generated
    `Show` instance obtained by using the `deriving` keyword would have used record
    syntax to show the vector. This in itself is unproblematic, but when we get into
    lists of vectors, or lists of tuples of vectors, we will want a brief way to show
    our vectors.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用数据构造函数`Vec`来构建和显示我们的向量，从而省去为`Vec`定义`Show`实例和定义`vec`函数的需求呢？这确实是一种可行的做法，而且并不差。之所以没有这样做，主要是因为我想使用记录语法，而通过使用`deriving`关键字自动生成的`Show`实例会使用记录语法来显示向量。这本身没有问题，但当我们处理向量的列表或向量元组的列表时，我们将需要一种简洁的方式来显示向量。
- en: Haskell has traditionally favored that what can be shown can also be read. The
    `Read` type class is for types that can be read from a `String`, and it serves
    as a sort of inverse to the `Show` type class for types that can be shown as a
    `String`. This is the reason why the `Show` instance looks just like the application
    of the `vec` function to three components.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 传统上倾向于能够显示的东西也能被读取。`Read`类型类用于那些可以从`String`中读取的类型，它作为`Show`类型类的逆操作，后者用于那些可以显示为`String`的类型。这也是为什么`Show`实例看起来就像是将`vec`函数应用于三个分量的原因。
- en: Vec Functions
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Vec 函数
- en: 'Here are unit vectors in the x-, y-, and z-directions:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 x、y 和 z 方向的单位向量：
- en: '[PRE51]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We give the zero vector the special name `zeroV`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将零向量命名为`zeroV`。
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The unary minus sign will not work in front of a vector, so we define a function
    `negateV` that returns the additive inverse of a vector (the negative of the vector).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一元负号在向量前是无法使用的，因此我们定义了一个函数`negateV`，它返回一个向量的加法逆元（即该向量的负向量）。
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Vector addition and subtraction are just the addition and subtraction of the
    corresponding Cartesian components.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的加法和减法只是对应笛卡尔分量的加法和减法。
- en: '[PRE54]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It’ll be useful to have a function that adds a whole list of vectors. We’ll
    use this function when we do numeric integrals of vector-valued functions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可以添加整个向量列表的函数会很有用。当我们做向量值函数的数值积分时，将会用到这个函数。
- en: '[PRE55]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The function foldr is defined in the Prelude. The definition of sumV is written
    in point-free style, which means it is short for `sumV vs = foldr (^+^)` `zeroV
    vs`. Roughly speaking, foldr takes a binary operator (`(^+^)` in this case), an
    initial value, and a list of values, and “folds” the initial value and an element
    from the list into an accumulated value, after which it continues to fold the
    accumulated value with the next element of the list to form a new accumulated
    value until the list is gone and the final accumulated value is returned. It’s
    a fairly powerful function, but here it’s used just to keep adding the members
    of the list until there are no more.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 函数foldr在Prelude中已定义。`sumV`的定义采用点自由样式，这意味着它是`sumV vs = foldr (^+^)` `zeroV vs`的简写。大致来说，foldr接受一个二元操作符（这里是`(^+^)`）、一个初始值和一个值的列表，并将初始值与列表中的一个元素“折叠”成一个累积值，接着继续将累积值与下一个元素折叠，直到列表耗尽并返回最终的累积值。它是一个相当强大的函数，但这里的作用仅仅是不断地将列表中的成员相加，直到没有更多元素为止。
- en: There are three ways to multiply three-dimensional vectors. The first is scalar
    multiplication, in which we multiply a number by a vector or a vector by a number.
    We use `(*^)` and `(^*)` for scalar multiplication. The first takes a number on
    the left and a vector on the right. The second takes a vector on the left and
    a number on the right. The vector always goes next to the caret symbol. The second
    vector multiplication method is the dot product. We use `(<.>)` for the dot product.
    The third vector multiplication method is the cross product. We use `(><)` for
    the cross product.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以相乘三维向量。第一种是标量乘法，我们将一个数与一个向量相乘，或者一个向量与一个数相乘。我们使用`(*^)`和`(^*)`来表示标量乘法。第一个符号表示左边是数值，右边是向量；第二个符号则表示左边是向量，右边是数值。向量总是紧挨着插入符号。第二种向量乘法方法是点积。我们用`(<.>)`表示点积。第三种向量乘法方法是叉积。我们用`(><)`表示叉积。
- en: 'Here are the definitions for the three vector multiplications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三种向量乘法的定义：
- en: '[PRE56]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first two definitions are for scalar multiplication. If the vector is to
    the right of the number, we use the operator with the caret on the right. If the
    vector is to the left of the number, we use the operator with the caret on the
    left. In either case, the definition says that scalar multiplication is carried
    out by multiplying each Cartesian component by the scaling number. The dot product
    is defined via Equation 10.8\. The cross product is defined via Equation 10.9.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个定义是关于标量乘法的。如果向量在数值的右边，我们使用右侧有插入符号的操作符。如果向量在数值的左边，我们使用左侧有插入符号的操作符。在这两种情况下，定义表明标量乘法是通过将每个笛卡尔分量与缩放数相乘来完成的。点积通过方程式10.8定义。叉积通过方程式10.9定义。
- en: We can also divide a vector by a scalar.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将向量除以标量。
- en: '[PRE57]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, we define a `magnitude` function to take the magnitude of a vector.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个`magnitude`函数来计算向量的大小。
- en: '[PRE58]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This completes our data type definition for the new data type `Vec`, along with
    supporting functions that allow us to write about vectors in the way we think
    about them and use them in physics.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们为新的数据类型`Vec`定义的数据类型，并附带支持函数，使我们能够以我们对向量的理解和在物理中使用它们的方式来编写代码。
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed kinematics in three spatial dimensions. In three dimensions,
    time is represented by a real number while velocity and acceleration are represented
    by vectors. Position is not truly a vector, but in this chapter we keep it simple
    and regard position as the displacement vector from the origin of some preferred
    or default coordinate system.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了三维空间中的运动学。在三维空间中，时间由实数表示，而速度和加速度由向量表示。位置严格来说并不是一个向量，但在本章中，我们简化处理，将位置视为某个优选或默认坐标系统原点到某点的位移向量。
- en: Vectors are fundamentally geometric entities; to use numbers to describe the
    components of a vector, we must introduce a coordinate system. In any situation
    in which an object is moving, we can decompose the acceleration into a component
    parallel to the velocity and a component perpendicular to the velocity. This decomposition
    is coordinate independent.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 向量本质上是几何实体；为了用数字描述向量的分量，我们必须引入一个坐标系。在任何物体运动的情境中，我们都可以将加速度分解为与速度平行的分量和与速度垂直的分量。这种分解是与坐标系无关的。
- en: With a system for vectors in place, we are now in a position to do all the projectile
    motion problems we ever wanted to do. We showed Haskell’s facility for defining
    our own data types, and we used that system to implement the `Vec` type for three-dimensional
    vectors.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有了向量系统，我们现在可以解决我们曾经想做的所有抛物运动问题。我们展示了 Haskell 在定义自定义数据类型方面的便捷性，并利用这一系统实现了三维向量的`Vec`类型。
- en: Exercises
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 10.1.** Translate the following mathematical definitions into Haskell
    definitions:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.1.** 将以下数学定义翻译为 Haskell 定义：'
- en: '| (a) ![Image](Images/e0159-01.jpg) | (Use `v0` in Haskell for `**v**[0]`.)
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| (a) ![图片](Images/e0159-01.jpg) | (在 Haskell 中使用`v0`表示`**v**[0]`。) |'
- en: '| (b) ![Image](Images/e0159-02.jpg) | (Use `v1` for `**v**[1]`.) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| (b) ![图片](Images/e0159-02.jpg) | (使用`v1`表示`**v**[1]`。) |'
- en: '| (c) ![Image](Images/e0159-03.jpg) | (Use `v` for **v**.) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| (c) ![图片](Images/e0159-03.jpg) | (使用`v`表示**v**。) |'
- en: '| (d) ![Image](Images/e0159-04.jpg) | (Use `r` for **r**.) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| (d) ![图片](Images/e0159-04.jpg) | (使用`r`表示**r**。) |'
- en: '| (e) ![Image](Images/e0159-05.jpg) | (Use `x` for *x*.) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| (e) ![图片](Images/e0159-05.jpg) | (使用`x`表示*x*。) |'
- en: What are the Haskell types of v0, v1, v, r, and x?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: v0、v1、v、r 和 x 的 Haskell 类型是什么？
- en: '**Exercise 10.2.** Write an integration function'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.2.** 编写一个积分函数'
- en: '[PRE59]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: for vector-valued functions of a real variable that is similar to the function
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 用于实变量的向量值函数，类似于函数
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: that we wrote in [Chapter 6](ch06.xhtml).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 6 章](ch06.xhtml) 中写过的函数。
- en: '**Exercise 10.3.** Write a function'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.3.** 编写一个函数'
- en: '[PRE61]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: that returns the maximum z-component for projectile motion in which the initial
    position and the initial velocity of an object are given. Assume gravity acts
    in the negative z-direction.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 返回投射运动中的最大 z 分量，其中给定了物体的初始位置和初始速度。假设重力作用于负 z 方向。
- en: '**Exercise 10.4.** Write a function'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.4.** 编写一个函数'
- en: '[PRE62]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: that, given an initial velocity and a constant acceleration, returns a function
    giving speed as a function of time.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 给定初始速度和恒定加速度，返回一个给出速度随时间变化的函数。
- en: '**Exercise 10.5.** In the spirit of the function `projectilePos`, write a type
    signature and function definition for a function `projectileVel` that computes
    the velocity of a projectile at a given time.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.5.** 按照 `projectilePos` 函数的思路，编写类型签名和函数定义，定义一个计算给定时间投射物速度的函数 `projectileVel`。'
- en: '**Exercise 10.6.** Define a new type `Vec2D` for two-dimensional vectors. Then
    define functions'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.6.** 为二维向量定义一个新的类型 `Vec2D`。然后定义函数'
- en: '[PRE63]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: that find the magnitude and angle of a two-dimensional vector and construct
    a two-dimensional vector from a magnitude and angle. You may want to use the `atan`
    or `atan2` functions, which we discussed in [Chapter 1](ch01.xhtml).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 计算二维向量的大小和角度，并从大小和角度构建一个二维向量。你可能想使用我们在 [第 1 章](ch01.xhtml) 中讨论过的 `atan` 或 `atan2`
    函数。
- en: '**Exercise 10.7.** Define a function'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.7.** 定义一个函数'
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: that computes the projection of a vector into the xy plane. For example, `xyProj
    (vec 6 9 7)` should evaluate to `vec 6 9 0`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个向量在 xy 平面的投影。例如，`xyProj (vec 6 9 7)` 应该计算为 `vec 6 9 0`。
- en: '**Exercise 10.8.** Define a function'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.8.** 定义一个函数'
- en: '[PRE65]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: that returns a triple (*v*, *θ*, *ϕ*) for a vector **v** in which
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个三元组 (*v*, *θ*, *ϕ*)，其中 **v** 是一个向量，并且
- en: '![Image](Images/161equ01.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/161equ01.jpg)'
- en: 'For example, `magAngles (vec (-1) (-2) (-3))` should evaluate to:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`magAngles (vec (-1) (-2) (-3))` 应该计算为：
- en: '[PRE66]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Exercise 10.9.** The velocity and acceleration of a ball launched from the
    ground are'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.9.** 从地面发射的一个球的速度和加速度是'
- en: '![Image](Images/161equ02.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/161equ02.jpg)'
- en: where **v**[0] is the initial velocity of the ball and **g** is the acceleration
    of gravity. Suppose a ball is launched from the ground with an initial speed of
    25 m/s at an angle 52^∘ above horizontal. Choose a coordinate system and define
    a constant
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 **v**[0] 是球的初速度，**g** 是重力加速度。假设一颗球从地面发射，初速度为 25 m/s，角度为 52^∘ 以上水平面。选择一个坐标系并定义一个常量
- en: '[PRE67]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: for the acceleration of gravity near Earth’s surface. It should be 9.8 m/s²
    toward the center of the earth. Next, define a function
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 用于地球表面附近的重力加速度。它应该是 9.8 m/s²，指向地球的中心。接着，定义一个函数
- en: '[PRE68]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: that gives the velocity of the ball as a function of time. Now define a function
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 给出球的速度随时间变化的函数。现在定义一个函数
- en: '[PRE69]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: that gives the rate of change of the speed of the ball as a function of time.
    You may want to use `speedRateChange` for this. At what point in the ball’s motion
    is the rate of change of its speed equal to zero? Is its velocity zero at that
    point? Is its acceleration zero at that point? Use `plotFunc` from [Chapter 7](ch07.xhtml)
    to make a graph of the rate of change of the speed of the ball as a function of
    time over the four seconds it is in the air.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 给出球的速度变化率作为时间的函数。你可能想使用 `speedRateChange` 来处理这个问题。在球的运动过程中，在哪一点速度变化率为零？此时它的速度是零吗？此时它的加速度是零吗？使用
    [第 7 章](ch07.xhtml) 中的 `plotFunc` 绘制球的速度变化率随时间变化的图形，时间为四秒。
- en: '**Exercise 10.10.** Consider a particle in uniform circular motion. If we choose
    our coordinate system so that the motion takes place in the xy-plane with the
    origin at the center of the circle, we can write the position of the particle
    as'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.10.** 考虑一个做匀速圆周运动的粒子。如果我们选择坐标系，使得运动发生在 xy 平面内，圆心作为原点，则可以将粒子的位置写为'
- en: '![Image](Images/161equ03.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/161equ03.jpg)'
- en: where *R* is the radius of the circle and *ω* is the angular velocity of the
    motion. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *R* 是圆的半径，*ω* 是运动的角速度。粒子的速度可以通过对位置关于时间的导数来找到。
- en: '![Image](Images/162equ01.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/162equ01.jpg)'
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的加速度可以通过对速度关于时间的导数来求得。
- en: '![Image](Images/162equ02.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/162equ02.jpg)'
- en: This particle in uniform circular motion has a speed *v*[*UCM*] (*t*) = *ωR*,
    which does not depend on time. The constant speed is what we mean by the word
    “uniform.”
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在匀速圆周运动中的粒子有一个速度 *v*[*UCM*] (*t*) = *ωR*，这个速度与时间无关。常数速度就是我们所说的“匀速”。
- en: For a uniform circular motion with *R* = 2 m and *ω* = 6 rad/s, encode the position,
    velocity, and acceleration of the particle in Haskell. Use `aParallel` to confirm
    that the tangential component of acceleration is 0 at several different times.
    Use `aPerp` to confirm that the magnitude of the radial component of acceleration
    is [*v*[UCM] (*t*)]²/*R* = ^(*ω*2)*R*, again at several different times.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 对于半径 *R* = 2米，角速度 *ω* = 6 rad/s 的匀速圆周运动，用 Haskell 编码粒子的位移、速度和加速度。使用`aParallel`确认在多个不同的时刻，加速度的切向分量为0。使用`aPerp`确认在多个不同的时刻，加速度的径向分量的大小为[*v*[UCM]
    (*t*)]²/*R* = ^(*ω*²)*R*。
- en: '**Exercise 10.11.** Consider a particle in nonuniform circular motion on a
    circle with radius *R*. If we choose our coordinate system so that the motion
    takes place in the xy-plane with the origin at the center of the circle, we can
    write the position of the particle as'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.11.** 考虑一个在半径 *R* 的圆上做非匀速圆周运动的粒子。如果我们选择坐标系统，使得运动发生在xy平面上，圆心为原点，则可以将粒子的位置写作'
- en: '![Image](Images/162equ03.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/162equ03.jpg)'
- en: where *θ*(*t*) describes the angle the particle makes with the x-axis as a function
    of time. The velocity of the particle can be found by taking the derivative of
    position with respect to time.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *θ*(*t*) 描述了粒子与x轴的夹角随时间变化的函数。粒子的速度可以通过对位置关于时间的导数来求得。
- en: '![Image](Images/162equ04.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/162equ04.jpg)'
- en: The acceleration of the particle can be found by taking the derivative of velocity
    with respect to time.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的加速度可以通过对速度关于时间的导数来求得。
- en: '![Image](Images/162equ05.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/162equ05.jpg)'
- en: This particle in circular motion has speed *v*[NCM] (*t*) = *R* |*Dθ*(*t*)|,
    which will depend on time unless *Dθ*(*t*) is constant. The magnitude of the particle’s
    tangential acceleration is *R* |^(*D*2)*θ*(*t*)| and the magnitude of its radial
    acceleration is [*v*[NCM] (*t*)]²/*R* = *R*[*Dθ*(*t*)]².
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在圆周运动中的粒子有一个速度 *v*[NCM] (*t*) = *R* |*Dθ*(*t*)|，这个速度会依赖于时间，除非 *Dθ*(*t*) 是常数。粒子切向加速度的大小是
    *R* |^(*D*²)*θ*(*t*)|，其径向加速度的大小是 [*v*[NCM] (*t*)]²/*R* = *R*[*Dθ*(*t*)]²。
- en: Write a function
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: that takes a radius *R*, a function *θ*, and a time *t* as input and returns
    a position vector as output.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受半径 *R*、函数 *θ* 和时间 *t* 作为输入，并返回位置向量作为输出。
- en: The purpose of this exercise is to confirm that, even in nonuniform circular
    motion, the magnitude of a particle’s radial component of acceleration is equal
    to the square of its speed divided by the radius of the circle. The following
    function finds the radial component of acceleration for any particle whose position
    can be given as function of time. Its first input is a small time interval to
    use for numerical derivatives. Its second input is the position function for the
    particle, and its third input is time.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是确认即使在非匀速圆周运动中，粒子的加速度径向分量的大小也等于其速度的平方除以圆的半径。以下函数可以求得任何粒子的加速度径向分量，其位置可以表示为时间的函数。它的第一个输入是用于数值求导的小时间间隔。第二个输入是粒子的位置函数，第三个输入是时间。
- en: '[PRE71]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: For a radius *R* = 2 m and
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对于半径 *R* = 2米，并且
- en: '![Image](Images/163equ01.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/163equ01.jpg)'
- en: use `aPerpFromPosition` to find the radial component of acceleration at *t*
    = 2 seconds. Then find the speed of the particle at that time. Finally, show that
    the magnitude of the radial component is equal to the square of its speed divided
    by the radius of the circle.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aPerpFromPosition`在 *t* = 2秒时求解加速度的径向分量。然后求粒子在该时刻的速度。最后，证明径向分量的大小等于其速度的平方除以圆的半径。
